------- FILE mytb.asm LEVEL 1 PASS 6
      1 U2c41				   input      processor	6502
      2 U2c41 ????						;=====================================================
      3 U2c41 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U2c41 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U2c41 ????						; Free Time. Now abiut 6K Full OS features.
      6 U2c41 ????						;
      7 U2c41 ????						; While working on the Corsham Technologies KIM Clone
      8 U2c41 ????						; project, I wanted to include a TINY BASIC since that
      9 U2c41 ????						; was a highly desirable feature of early computers.
     10 U2c41 ????						;
     11 U2c41 ????						; Rather than negotiating copyright issues for
     12 U2c41 ????						; existing BASICs, I decided to just write one from
     13 U2c41 ????						; scratch.
     14 U2c41 ????						;
     15 U2c41 ????						; 10/07/2017
     16 U2c41 ????						;
     17 U2c41 ????						; This implements a stripped down Tiny BASIC
     18 U2c41 ????						; interpreter using the Interpretive Language (IL)
     19 U2c41 ????						; method as described in the first few issues of
     20 U2c41 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U2c41 ????						; to write various languages simply by changing the
     22 U2c41 ????						; IL code rather than the interpreter itself.
     23 U2c41 ????						;
     24 U2c41 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U2c41 ????						;		* Fixed major bug in findLine that
     26 U2c41 ????						;		  caused corrupted lines, crashes, etc.
     27 U2c41 ????						;		* If no parameter given to RND, assume
     28 U2c41 ????						;		  32766.
     29 U2c41 ????						;		* No more error 5 when a program
     30 U2c41 ????						;		  reaches the end without an END.
     31 U2c41 ????						;
     32 U2c41 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U2c41 ????						;		 * Unexpanded version to play with everything
     34 U2c41 ????						;		 * Add some usefull system level functions
     35 U2c41 ????						;		 * allow a larger number of tiny basic formats
     36 U2c41 ????						;		 * Add byte at start of line holding length
     37 U2c41 ????						;		   for faster execution of goto and gosub
     38 U2c41 ????						;		 * Re-added gosub
     39 U2c41 ????						;		 * allow ; or , at end if print stmt
     40 U2c41 ????						;		   without CRLF being added.
     41 U2c41 ????						;		 * Added extended function erase to
     42 U2c41 ????						;		   use the extended ctmon65 rm file
     43 U2c41 ????						;		 * Fix quoted text to not have to backtrack
     44 U2c41 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U2c41 ????						;		 * Add concurrency features
     46 U2c41 ????						;
     47 U2c41 ????						; www.corshamtech.com
     48 U2c41 ????						; bob@corshamtech.com
     49 U2c41 ????						; JustLostInTime@gmail.com
     50 U2c41 ????						;
     51 U2c41 ????						;=====================================================
     52 U2c41 ????						;
     53 U2c41 ????						; Create TRUE and FALSE values for conditionals.
     54 U2c41 ????						;
     55 U2c41 ????
     56 U2c41 ????	       00 00	   FALSE      equ	0
     57 U2c41 ????	       ff ff ff ff TRUE       equ	~FALSE
     58 U2c41 ????						;
     59 U2c41 ????						;---------------------------------------------------------
     60 U2c41 ????						; One of these must be set to indicate which environment
     61 U2c41 ????						; Tiny BASIC will be running in.  Here are the current
     62 U2c41 ????						; environments:
     63 U2c41 ????						;
     64 U2c41 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     65 U2c41 ????						; more K of RAM.
     66 U2c41 ????						;
     67 U2c41 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     68 U2c41 ????						; which enhances, without replacing, the standard KIM
     69 U2c41 ????						; monitor.  It gives access to routines to save/load files
     70 U2c41 ????						; to a micro SD card.
     71 U2c41 ????						;
     72 U2c41 ????						; CTMON65 is a from-scratch monitor written for the
     73 U2c41 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     74 U2c41 ????						; easily be ported to other systems.  It has support for
     75 U2c41 ????						; using a micro SD card for file storage/retrieval.
     76 U2c41 ????						;
     77 U2c41 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     78 U2c41 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     79 U2c41 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     80 U2c41 ????	       ff ff ff ff USEDEBUGPORT equ	TRUE	;Use a second terminal as a debug port
     81 U2c41 ????	       e0 20	   DEBUGPORT  equ	$E020	;This second terminal used for debug
     82 U2c41 ????						;
     83 U2c41 ????						;   Need to define some macros for the dasm assembler
     84 U2c41 ????						;
     85 U2c41 ????				      MACRO	dw
     86 U2c41 ????				      .word	{0}
     87 U2c41 ????				      ENDM
     88 U2c41 ????
     89 U2c41 ????				      MACRO	db
     90 U2c41 ????				      .byte	{0}
     91 U2c41 ????				      ENDM
     92 U2c41 ????
     93 U2c41 ????						;
     94 U2c41 ????						; If set, include disk functions.
     95 U2c41 ????						;
     96 U2c41 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U2c41 ????						;
     98 U2c41 ????						; If ILTRACE is set then dump out the address of every
     99 U2c41 ????						; IL opcode before executing it.
    100 U2c41 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U2c41 ????						;
    102 U2c41 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U2c41 ????						;
    104 U2c41 ????						; If FIXED is set, put the IL code and the user
    105 U2c41 ????						; program space at fixed locations in memory.	This is
    106 U2c41 ????						; meant only for debugging.
    107 U2c41 ????						;
    108 U2c41 ????	       00 00	   FIXED      equ	FALSE
    109 U2c41 ????						;
    110 U2c41 ????						; Sets the arithmetic stack depth.  This is *TINY*
    111 U2c41 ????						; BASIC, so keep this small!
    112 U2c41 ????						;
    113 U2c41 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    114 U2c41 ????	       00 14	   ILSTACKSIZE equ	20	;number of entries in ilstack
    115 U2c41 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    116 U2c41 ????	       00 1b	   VARIABLESSIZE equ	27	;26 variables + 1 for exit code
    117 U2c41 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 64 tasks
    118 U2c41 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    119 U2c41 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    120 U2c41 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    121 U2c41 ????						;
    122 U2c41 ????						; Gosub entry types
    123 U2c41 ????
    124 U2c41 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    125 U2c41 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    126 U2c41 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    127 U2c41 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    128 U2c41 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    129 U2c41 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    130 U2c41 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    131 U2c41 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    132 U2c41 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    133 U2c41 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    134 U2c41 ????						;
    135 U2c41 ????						; Common ASCII constants
    136 U2c41 ????						;
    137 U2c41 ????	       00 07	   BEL	      equ	$07
    138 U2c41 ????	       00 08	   BS	      equ	$08
    139 U2c41 ????	       00 09	   TAB	      equ	$09
    140 U2c41 ????	       00 0a	   LF	      equ	$0A
    141 U2c41 ????	       00 0d	   CR	      equ	$0D
    142 U2c41 ????	       00 22	   quote      equ	$22
    143 U2c41 ????	       00 20	   SPACE      equ	$20
    144 U2c41 ????	       00 2c	   COMMA      equ	',
    145 U2c41 ????	       00 3b	   SEMICOLON  equ	';
    146 U2c41 ????	       00 3a	   COLON      equ	':
    147 U2c41 ????	       00 24	   DOLLAR     equ	'$
    148 U2c41 ????						;
    149 U2c41 ????						; These are error codes
    150 U2c41 ????						;
    151 U2c41 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    152 U2c41 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    153 U2c41 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    154 U2c41 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    155 U2c41 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    156 U2c41 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    157 U2c41 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    158 U2c41 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    159 U2c41 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    160 U2c41 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    161 U2c41 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    162 U2c41 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    163 U2c41 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    164 U2c41 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    165 U2c41 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    166 U2c41 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    167 U2c41 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    168 U2c41 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    169 U2c41 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    170 U2c41 ????						;
    171 U2c41 ????						;=====================================================
    172 U2c41 ????						; Zero page storage.
    173 U2c41 ????						;
    174 U00f6 ????				      SEG.U	ZEROPAGE
    175 U0040					      org	$0040
    176 U0040
    177 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    178 U0041
    179 U0041							; The context is used to locate a task switch
    180 U0041							; it copies from here till all task fields are saved/swapped
    181 U0041							; The max number of tasks is 256 / context length
    182 U0041							; All positions POS values are plus one task table incldues
    183 U0041							; a leading status byte .
    184 U0041							;
    185 U0041		       00 41	   CONTEXT    equ	*
    186 U0041		       00 01	   VARIABLEPOS equ	* - CONTEXT + 1
    187 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    188 U0043		       00 00	   ILPC       ds	2	; IL program counter
    189 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    190 U0047		       00	   ILSTACKPTR ds	1
    191 U0047		       00 08	   MATHSTACKPOS equ	* - CONTEXT + 1
    192 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    193 U0048		       00 0a	   MATHSTACKPTRPOS equ	* - CONTEXT + 1
    194 U004a		       00	   MATHSTACKPTR ds	1
    195 U004a		       00 0b	   GOSUBSTKPOS equ	* - CONTEXT + 1	; Get the offset to the gosub/msg stack
    196 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    197 U004b		       00 0d	   GOSUBPTRPOS equ	* - CONTEXT+1	; Pointer to gosub stack pointer
    198 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    199 U004d		       00 0e	   MSGPTRPOS  equ	* - CONTEXT+1	; Pointer to the message counter
    200 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of ilstack
    201 U004f							;
    202 U004f							; CURPTR is a pointer to curent BASIC line being
    203 U004f							; executed.  Always points to start of line, CUROFF
    204 U004f							; is the offset to the current character.
    205 U004f							; The order of these fields is important
    206 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    207 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    208 U0052							;
    209 U0052							;The order of these fields in important
    210 U0052
    211 U0052							;
    212 U0052							; R0, R1 and MQ are used for arithmetic operations and
    213 U0052							; general use.
    214 U0052							;
    215 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    216 U0052		       00 00	   REG0       equ	R0 - REGISTERS
    217 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    218 U0052		       00 02	   REG1       equ	R1 - REGISTERS	;offset of R1
    219 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    220 U0054		       00 04	   REGMQ      equ	MQ - REGISTERS	;offset og MQ
    221 U0056		       00 00	   MQ	      ds	2	;used for some math
    222 U0056		       00 06	   REG2       equ	R2 - REGISTERS
    223 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    224 U0058		       00 59	   REGISTERSEND equ	*
    225 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    226 U0059
    227 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    228 U0059		       00 18	   CONTEXTLEN equ	CONTEXTEND - CONTEXT	; length of the context
    229 U0059
    230 U0059		       00 00	   dpl	      ds	2	;Used as a pointer to call il instructions
    231 U005b							;
    232 U005b							; This is zero if in immediate mode, or non-zero
    233 U005b							; if currently running a program.  Any input from
    234 U005b							; the main loop clears this, and the XFER IL
    235 U005b							; statement will set it.
    236 U005b							;
    237 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    238 U005c							;
    239 U005c							; Used for line insertion/removal.
    240 U005c							;
    241 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    242 U005e
    243 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    244 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    245 U005e							;
    246 U005e		       00 00	   PrtFrom    ds	2	; FROM
    247 U0060							;
    248 U0060							;=====================================================
    249 U0060							;Pointers for memory Management
    250 U0060							;Allocated block are not chained but can be followed for all memory by the associated length
    251 U0060							; Mem block format is
    252 U0060							;	 0-1   pointer to next block for free blocks
    253 U0060							;	 0-1   for allocated blocks
    254 U0060							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
    255 U0060							;	   1   refrence counter ... lol only up to 256 but it is something
    256 U0060							;	 2-3   length constant for exevy type of memory block
    257 U0060							; Memory is recombined as it is released
    258 U0060							; The memory manager is not interupted durring allocation
    259 U0060							; or freeing of memory
    260 U0060							;====================================================
    261 U0060		       00 00	   MemFreeList ds	2	; list of free blocks of memory
    262 U0062		       00 00	   MemR0      ds	2	; source for copy/move/Init
    263 U0064		       00 00	   MemR1      ds	2	; Destination for copy/move
    264 U0066							;
    265 U0066							;=====================================================
    266 U0066							;
    267  22c9 ????				      SEG	Code
    268  0200					      org	$0200
    269  0200							;
    270  0200							; Cold start is at $0200.  Warm start is at $0203.
    271  0200							;
    272  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    273  0203		       4c 8c 02    warm       jmp	warm2	;Entry point for worm restart
    274  0206							;
    275  0206							; These are the user-supplied vectors to I/O routines.
    276  0206							; If you want, you can just patch these in the binary
    277  0206							; file, but it would be better to change the source
    278  0206							; code.
    279  0206							;
    280  0206				  -	      if	KIM
    281  0206				  -OUTCH      jmp	$1ea0	;output char in A
    282  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    283  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    284  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    285  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    286  0206					      endif
    287  0206				  -	      if	XKIM
    288  0206				  -	      include	"xkim.inc"
    289  0206				  -	      SEG	Code
    290  0206				  -OUTCH      jmp	$1ea0
    291  0206				  -GETCH      jmp	xkGETCH
    292  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    293  0206				  -OUTHEX     jmp	xkPRTBYT
    294  0206				  -MONITOR    jmp	extKIM
    295  0206				  -puts       equ	putsil
    296  0206				  -BUFFER_SIZE equ	132
    297  0206					      endif
    298  0206
    299  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0066					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    301 Udf8e
    302  0206					      SEG	Code
    303  0206							;
    304  0206		       f0 0c	   OUTCH      equ	cout
    305  0206		       f0 09	   GETCH      equ	cin
    306  0206		       1a a4	   CRLF       equ	tbcrlf
    307  0206		       12 92	   OUTHEX     equ	HexToOut
    308  0206		       f0 03	   MONITOR    equ	WARM
    309  0206		       f0 0f	   ISCHAR     equ	cstatus
    310  0206		       1b f3	   puts       equ	tbputs
    311  0206					      endif
    312  0206							;
    313  0206		       20 d3 1b    cold2      jsr	SetOutConsole
    314  0209		       20 e0 1b 	      jsr	SetInConsole
    315  020c		       20 f3 1b 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.0.3	IRQs/Tasks"
      0  0239					      db	CR,LF,0
      1  0239		       0d 0a 00 	      .byte.b	CR,LF,0
    319  023c							;
    320  023c		       20 af 12 	      jsr	MemInit	;setup the free space available
    321  023f
    322  023f		       a9 01	   calcstack  lda	#1
    323  0241		       8d dd 23 	      sta	taskCounter	; Initialize number of tasks to 1
    324  0244		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    325  0246		       8d df 22 	      sta	taskTable	; mark the main task as active
    326  0249		       20 9c 13 	      jsr	taskSetStacks	; setup all the task stacks/Variables
    327  024c		       a9 fd		      lda	#IL&$ff
    328  024e		       85 43		      sta	ILPC
    329  0250		       a9 1d		      lda	#IL>>8
    330  0252		       85 44		      sta	ILPC+1
    331  0254							;
    332  0254							;		  lda	  ProgramStart		     ; user prog
    333  0254							;		  sta	  ProgramEnd
    334  0254							;		  lda	  ProgramStart+1
    335  0254							;		  sta	  ProgramEnd+1
    336  0254							;
    337  0254							;  Init time slices defaults
    338  0254		       a9 02		      lda	#TASKCYCLESHIGH
    339  0256		       8d dc 23 	      sta	taskResetValue+1
    340  0259		       a9 ff		      lda	#TASKCYCLESDEFAULT
    341  025b		       8d db 23 	      sta	taskResetValue
    342  025e							;
    343  025e							; Initialize the pseudo-random number sequence...
    344  025e							;
    345  025e		       a9 5a		      lda	#$5a
    346  0260		       8d 27 2c 	      sta	rtemp1
    347  0263		       a9 9d		      lda	#%10011101
    348  0265		       8d 29 2c 	      sta	random
    349  0268		       a9 5b		      lda	#%01011011
    350  026a		       8d 2a 2c 	      sta	random+1
    351  026d							;
    352  026d							;   Insert a Basic irq handler for the basic Language
    353  026d		       a9 7a		      lda	#ServiceIrq&$ff
    354  026f		       8d 00 df 	      sta	IRQvec
    355  0272		       a9 02		      lda	#ServiceIrq>>8
    356  0274		       8d 01 df 	      sta	IRQvec+1
    357  0277		       4c 9f 02 	      jmp	coldtwo
    358  027a
    359  027a							;
    360  027a							; This is the Basic IRQ handler
    361  027a		       48	   ServiceIrq pha
    362  027b		       ad da 22 	      lda	IRQStatus
    363  027e		       f0 0a		      BEQ	RetIrq
    364  0280		       ad db 22 	      lda	IRQPending
    365  0283		       d0 05		      bne	RetIrq
    366  0285		       a9 01		      lda	#1
    367  0287		       8d db 22 	      sta	IRQPending
    368  028a		       68	   RetIrq     pla
    369  028b		       40		      rti
    370  028c							;
    371  028c							;
    372  028c							; This is the warm start entry point
    373  028c							;
    374  028c		       20 d3 1b    warm2      jsr	SetOutConsole
    375  028f		       20 e0 1b 	      jsr	SetInConsole
    376  0292		       20 a4 1a 	      jsr	CRLF
    377  0295		       ad 24 2c 	      lda	errGoto
    378  0298		       85 43		      sta	ILPC
    379  029a		       ad 25 2c 	      lda	errGoto+1
    380  029d		       85 44		      sta	ILPC+1
    381  029f							;
    382  029f							; And continue with both starts here
    383  029f							;
    384  029f				   coldtwo
    385  029f							;
    386  029f							; The ILTrace flag is now run-time settable.
    387  029f							;
    388  029f		       a9 00		      lda	#ILTRACE&$ff
    389  02a1		       85 40		      sta	ILTrace
    390  02a3							;
    391  02a3
    392  02a3		       a9 00		      lda	#0
    393  02a5		       85 5b		      sta	RunMode
    394  02a7		       8d 9a 2b 	      sta	LINBUF
    395  02aa
    396  02aa							; Clear everything from the stacks
    397  02aa
    398  02aa		       8d 35 2c 	      sta	taskIOPending	; No one waiting for io
    399  02ad		       8d 36 2c 	      sta	taskRDPending	; No one waiting for bg io
    400  02b0
    401  02b0		       20 0f 14 	      jsr	taskReset
    402  02b3							;
    403  02b3		       a9 9a		      lda	#LINBUF&$ff
    404  02b5		       85 4f		      sta	CURPTR
    405  02b7		       a9 2b		      lda	#LINBUF>>8
    406  02b9		       85 50		      sta	CURPTR+1	;fall through...
    407  02bb
    408  02bb							;=====================================================
    409  02bb							; This is the top of the IL interpreter.  This fetches
    410  02bb							; and executes the instruction currently pointed to
    411  02bb							; by ILPC and adjusts ILPC to point to the next
    412  02bb							; instruction to execute.
    413  02bb							;
    414  02bb		       ce d9 23    NextIL     dec	taskCurrentCycles
    415  02be		       d0 03		      bne	NextIlNow
    416  02c0		       20 38 14 	      jsr	iTaskSwitch	;check for a task switch
    417  02c3		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02c5		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02c7
    420  02c7		       20 30 1b 	      jsr	dbgLine	;Print the IL trace information
    421  02ca
    422  02ca		       a4 51	   NextIL2    ldy	CUROFF
    423  02cc		       20 9b 1a 	      jsr	SkipSpaces
    424  02cf		       84 51		      sty	CUROFF
    425  02d1							;Task IO Management
    426  02d1		       ad 36 2c 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02d4		       f0 08		      beq	NextILStr
    428  02d6		       20 eb 18 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02d9		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02db		       ce 36 2c 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02de							;
    432  02de		       20 6e 17    NextILStr  jsr	getILByte
    433  02e1							;
    434  02e1							; When the handler is called, these are the conditions
    435  02e1							; of several important items:
    436  02e1							;
    437  02e1							;    (ILPC) will point to the byte AFTER the IL
    438  02e1							;    opcode being executed.
    439  02e1							;
    440  02e1							;    (CURPTR),CUROFF will point to the start of the
    441  02e1							;    next word in the input buffer.  Ie, the next word
    442  02e1							;    in the user program.
    443  02e1							;
    444  02e1		       0a		      asl
    445  02e2		       c9 cc		      cmp	#ILTBLend-ILTBL+2
    446  02e4		       90 33		      bcc	ILgood
    447  02e6							;
    448  02e6							; This handles an illegal IL opcode.  This is serious
    449  02e6							; and there's no way to recover.
    450  02e6							;
    451  02e6		       20 f3 1b    ILbad      jsr	puts
      0  02e9					      db	CR,LF
      1  02e9		       0d 0a		      .byte.b	CR,LF
      0  02eb					      db	"Illegal IL "
      1  02eb		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02f6					      db	0
      1  02f6		       00		      .byte.b	0
    455  02f7							;
    456  02f7							; Well this is awkward, we need to back up the IL
    457  02f7							; by one since it no longer points to the current
    458  02f7							; opcode.
    459  02f7							;
    460  02f7		       20 7b 17 	      jsr	decIL
    461  02fa							;
    462  02fa		       a0 00		      ldy	#0
    463  02fc		       b1 43		      lda	(ILPC),y
    464  02fe		       20 92 12 	      jsr	OUTHEX
    465  0301		       20 f3 1b 	      jsr	puts
      0  0304					      db	" at ",0
      1  0304		       20 61 74 20*	      .byte.b	" at ",0
    467  0309		       a5 44		      lda	ILPC+1
    468  030b		       20 92 12 	      jsr	OUTHEX
    469  030e		       a5 43		      lda	ILPC
    470  0310		       20 92 12 	      jsr	OUTHEX
    471  0313		       20 a4 1a 	      jsr	CRLF
    472  0316		       4c 03 f0 	      jmp	MONITOR
    473  0319							;
    474  0319							; Just jump to the address (ILPC),y.  Have to do
    475  0319							; some goofy stuff.
    476  0319							;
    477  0319		       a8	   ILgood     tay		;move index into Y
    478  031a		       b9 27 03 	      lda	ILTBL,y
    479  031d		       85 59		      sta	dpl
    480  031f		       b9 28 03 	      lda	ILTBL+1,y
    481  0322		       85 5a		      sta	dpl+1
    482  0324		       6c 59 00 	      jmp	(dpl)	;go to handler
    483  0327							;
    484  0327							;=====================================================
    485  0327							; This is the IL jump table.  The IL opcode is
    486  0327							; mulitplied by two, then looked-up in this table.
    487  0327							; There is absolutely nothing special about the order
    488  0327							; of entries here... they all decode at exactly the
    489  0327							; same speed.	However the entry number must match the
    490  0327							; values in IL.inc.
    491  0327							;
    492  0327				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0327					      include	"ilvectortable.asm"
      1  0327					      seg	Code
      2  0327
      0  0327					      dw	iXINIT	;0
      1  0327		       29 04		      .word.w	iXINIT
      0  0329					      dw	iDONE	;1
      1  0329		       44 04		      .word.w	iDONE
      0  032b					      dw	iPRS	;2
      1  032b		       60 04		      .word.w	iPRS
      0  032d					      dw	iPRN	;3
      1  032d		       6a 04		      .word.w	iPRN
      0  032f					      dw	iSPC	;4
      1  032f		       73 04		      .word.w	iSPC
      0  0331					      dw	iNLINE	;5
      1  0331		       25 09		      .word.w	iNLINE
      0  0333					      dw	iNXT	;6
      1  0333		       7b 04		      .word.w	iNXT
      0  0335					      dw	iXFER	;7
      1  0335		       a7 04		      .word.w	iXFER
      0  0337					      dw	iSAV	;8
      1  0337		       d4 04		      .word.w	iSAV
      0  0339					      dw	iRSTR	;9
      1  0339		       17 05		      .word.w	iRSTR
      0  033b					      dw	iCMPR	;10
      1  033b		       4c 05		      .word.w	iCMPR
      0  033d					      dw	iINNUM	;11
      1  033d		       cd 05		      .word.w	iINNUM
      0  033f					      dw	iFIN	;12
      1  033f		       01 06		      .word.w	iFIN
      0  0341					      dw	iERR	;13
      1  0341		       15 06		      .word.w	iERR
      0  0343					      dw	iADD	;14
      1  0343		       85 06		      .word.w	iADD
      0  0345					      dw	iSUB	;15
      1  0345		       9b 06		      .word.w	iSUB
      0  0347					      dw	iNEG	;16
      1  0347		       b1 06		      .word.w	iNEG
      0  0349					      dw	iMUL	;17
      1  0349		       c9 06		      .word.w	iMUL
      0  034b					      dw	iDIV	;18
      1  034b		       09 07		      .word.w	iDIV
      0  034d					      dw	iSTORE	;19
      1  034d		       5f 07		      .word.w	iSTORE
      0  034f					      dw	iIND	;20
      1  034f		       77 07		      .word.w	iIND
      0  0351					      dw	iLST	;21
      1  0351		       e5 07		      .word.w	iLST
      0  0353					      dw	iINIT	;22
      1  0353		       f1 03		      .word.w	iINIT
      0  0355					      dw	iGETLINE	;23
      1  0355		       4a 08		      .word.w	iGETLINE
      0  0357					      dw	iINSRT	;24
      1  0357		       61 08		      .word.w	iINSRT
      0  0359					      dw	iRTN	;25
      1  0359		       1f 09		      .word.w	iRTN
      0  035b					      dw	MONITOR	;26
      1  035b		       03 f0		      .word.w	MONITOR
      0  035d					      dw	iLIT	;27
      1  035d		       45 09		      .word.w	iLIT
      0  035f					      dw	iCALL	;28
      1  035f		       2b 09		      .word.w	iCALL
      0  0361					      dw	iJMP	;29
      1  0361		       33 09		      .word.w	iJMP
      0  0363					      dw	iVINIT	;30
      1  0363		       62 09		      .word.w	iVINIT
      0  0365					      dw	iERRGOTO	;31
      1  0365		       68 09		      .word.w	iERRGOTO
      0  0367					      dw	iTST	;32
      1  0367		       74 09		      .word.w	iTST
      0  0369					      dw	iTSTV	;33
      1  0369		       55 0a		      .word.w	iTSTV
      0  036b					      dw	iTSTL	;34
      1  036b		       d4 0a		      .word.w	iTSTL
      0  036d					      dw	iTSTN	;35
      1  036d		       ef 0a		      .word.w	iTSTN
      0  036f					      dw	iFREE	;36
      1  036f		       6c 0b		      .word.w	iFREE
      0  0371					      dw	iRANDOM	;37
      1  0371		       75 0b		      .word.w	iRANDOM
      0  0373					      dw	iABS	;38
      1  0373		       46 0c		      .word.w	iABS
     42  0375							;
     43  0375							; Disk functions.  There must be pointers
     44  0375							; to functions even if no disk is supported.
     45  0375							; Makes things easier in IL.inc.
     46  0375							;
     47  0375					      if	DISK_ACCESS
      0  0375					      dw	iOPENREAD	;39
      1  0375		       d8 1c		      .word.w	iOPENREAD
      0  0377					      dw	iOPENWRITE	;40
      1  0377		       2c 1d		      .word.w	iOPENWRITE
      0  0379					      dw	iDCLOSE	;41
      1  0379		       b0 1d		      .word.w	iDCLOSE
      0  037b					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  037b		       4b 1d		      .word.w	iDGETLINE
      0  037d					      dw	iDLIST	;43 Did you remeber your towel?
      1  037d		       aa 1d		      .word.w	iDLIST
      0  037f					      dw	iDDIR	;44
      1  037f		       85 1d		      .word.w	iDDIR
      0  0381					      dw	iRMFILE	;45
      1  0381		       06 1d		      .word.w	iRMFILE
     55  0383				  -	      else
     56  0383				  -	      dw	NextIL	;39
     57  0383				  -	      dw	NextIL	;40
     58  0383				  -	      dw	NextIL	;41
     59  0383				  -	      dw	NextIL	;42
     60  0383				  -	      dw	NextIL	;43
     61  0383				  -	      dw	NextIL	;44
     62  0383				  -	      dw	NextIL	;45
     63  0383					      endif
     64  0383							;
      0  0383					      dw	iCLEARSCREEN	;46
      1  0383		       4c 1c		      .word.w	iCLEARSCREEN
      0  0385					      dw	iPOKEMEMORY	;47
      1  0385		       d3 0b		      .word.w	iPOKEMEMORY
      0  0387					      dw	iPEEKMEMORY	;48
      1  0387		       e8 0b		      .word.w	iPEEKMEMORY
      0  0389					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0389		       bb 09		      .word.w	iTSTLET
      0  038b					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  038b		       f9 09		      .word.w	iTSTDONE
      0  038d					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  038d		       15 0c		      .word.w	iGETCHAR
      0  038f					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  038f		       29 0c		      .word.w	iPUTCHAR
      0  0391					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0391		       fe 0b		      .word.w	iCallFunc
      0  0393					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0393		       9d 05		      .word.w	iBranch
      0  0395					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  0395		       9e 09		      .word.w	iTSTStr
      0  0397					      dw	iSetIrq	;56	   sets the irq handler
      1  0397		       c3 0c		      .word.w	iSetIrq
      0  0399					      dw	iTstIrq	;57	   test if irq is pending
      1  0399		       34 0b		      .word.w	iTstIrq
      0  039b					      dw	iRET	;58	   return from interupt
      1  039b		       05 05		      .word.w	iRET
      0  039d					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  039d		       e4 05		      .word.w	iINSTR
      0  039f					      dw	iMOD	;60	   returns remainder of division
      1  039f		       12 07		      .word.w	iMOD
      0  03a1					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  03a1		       8c 14		      .word.w	iTaskSet
      0  03a3					      dw	iETask	;62	   Terminates a task
      1  03a3		       b7 15		      .word.w	iETask
      0  03a5					      dw	iNTask	;63	   goto next task
      1  03a5		       6a 15		      .word.w	iNTask
      0  03a7					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a7		       8c 07		      .word.w	iArray
      0  03a9					      dw	iTaskKill	;65	   kill a running task
      1  03a9		       62 15		      .word.w	iTaskKill
      0  03ab					      dw	iTaskStat	;66	   return the state of a task PID
      1  03ab		       36 15		      .word.w	iTaskStat
      0  03ad					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03ad		       34 0c		      .word.w	iHexOut
      0  03af					      dw	iReadComplete	;68	   Called after a background read completes
      1  03af		       b9 05		      .word.w	iReadComplete
      0  03b1					      dw	iReadStart	;69	   Called to start a background read request
      1  03b1		       af 05		      .word.w	iReadStart
      0  03b3					      dw	iStartIO	;70	   Lock task until io complete
      1  03b3		       9a 15		      .word.w	iStartIO
      0  03b5					      dw	iEndIO	;71	   release task lock for io
      1  03b5		       a0 15		      .word.w	iEndIO
      0  03b7					      dw	iLogNot	;72	   Logical not
      1  03b7		       9f 0c		      .word.w	iLogNot
      0  03b9					      dw	iLogOr	;73	   Logical Or
      1  03b9		       75 0c		      .word.w	iLogOr
      0  03bb					      dw	iLogAnd	;74	   Logical And
      1  03bb		       60 0c		      .word.w	iLogAnd
      0  03bd					      dw	iLogXor	;75	   Logical Xor
      1  03bd		       8a 0c		      .word.w	iLogXor
      0  03bf					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03bf		       75 15		      .word.w	iWTASK
      0  03c1					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03c1		       ab 15		      .word.w	iTASKPID
      0  03c3					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03c3		       ff 0c		      .word.w	iTRACEPROG
      0  03c5					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03c5		       b1 1a		      .word.w	idbgBasic
      0  03c7					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c7		       6d 16		      .word.w	iIPCS
      0  03c9					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c9		       84 16		      .word.w	iIPCR
      0  03cb					      dw	iIPCC	;82	   Check if any message available for task
      1  03cb		       98 16		      .word.w	iIPCC
      0  03cd					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03cd		       a5 16		      .word.w	iIPCIO
      0  03cf					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03cf		       04 13		      .word.w	iPushMathStack
      0  03d1					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03d1		       34 13		      .word.w	iPopMathStack
      0  03d3					      dw	iSaveMathStack	;86	   Save all math info
      1  03d3		       51 13		      .word.w	iSaveMathStack
      0  03d5					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03d5		       70 13		      .word.w	iRestoreMathStack
      0  03d7					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d7		       21 13		      .word.w	iIncParmCount
      0  03d9					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d9		       d7 15		      .word.w	iTaskGetMathStack
      0  03db					      dw	iTaskEnable	;90	   enable a suspended task
      1  03db		       04 15		      .word.w	iTaskEnable
      0  03dd					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03dd		       1e 15		      .word.w	iTaskSuspend
      0  03df					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03df		       f1 15		      .word.w	iTaskPutMathPtr
      0  03e1					      dw	iTSTVT	;93	   test for another tasks variable
      1  03e1		       4c 0a		      .word.w	iTSTVT
      0  03e3					      dw	iSetR2	;94
      1  03e3		       3d 09		      .word.w	iSetR2
      0  03e5					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03e5		       e3 04		      .word.w	iStk2Tmp
      0  03e7					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e7		       f4 04		      .word.w	iTmp2Stk
      0  03e9					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e9		       da 09		      .word.w	iTSTBYTE
      0  03eb					      dw	iINCVAR	;98	   Increment variable
      1  03eb		       1e 0a		      .word.w	iINCVAR
      0  03ed					      dw	iDECVAR	;99	   Decrement variable
      1  03ed		       36 0a		      .word.w	iDECVAR
      0  03ef					      dw	iSLICE	;100	   set the time slice for tasks
      1  03ef		       00 16		      .word.w	iSLICE
    120  03f1
------- FILE mytb.asm
    494  03f1		       03 f1	   ILTBLend   equ	*
    495  03f1							;
    496  03f1							;=====================================================
    497  03f1							;=====================================================
    498  03f1							;=====================================================
    499  03f1							; This marks the start of the handlers for IL opcodes.
    500  03f1							;=====================================================
    501  03f1							;=====================================================
    502  03f1							;=====================================================
    503  03f1							;
    504  03f1							;
    505  03f1		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    506  03f3		       85 47		      sta	ILSTACKPTR
    507  03f5		       85 4a		      sta	MATHSTACKPTR
    508  03f7		       85 4d		      sta	GOSUBSTACKPTR
    509  03f9		       a9 40		      lda	#GOSUBSTACKSIZE*4
    510  03fb		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    511  03fd							;
    512  03fd		       ad 37 2c 	      lda	ProgramStart	;user prog
    513  0400		       85 4f		      sta	CURPTR
    514  0402		       8d e0 22 	      sta	taskTable+1
    515  0405		       8d 39 2c 	      sta	ProgramEnd
    516  0408		       ad 38 2c 	      lda	ProgramStart+1
    517  040b		       85 50		      sta	CURPTR+1
    518  040d		       8d e1 22 	      sta	taskTable+2
    519  0410		       8d 3a 2c 	      sta	ProgramEnd+1
    520  0413		       a9 80		      lda	#TASKACTIVE
    521  0415		       8d df 22 	      sta	taskTable	;Mark the first slot as active
    522  0418		       a9 01		      lda	#1
    523  041a		       8d dd 23 	      sta	taskCounter	;there is always one task / Main task
    524  041d		       ad db 23 	      lda	taskResetValue
    525  0420		       8d d9 23 	      sta	taskCurrentCycles	; set up the task switch counts
    526  0423		       ad dc 23 	      lda	taskResetValue+1
    527  0426		       8d da 23 	      sta	taskCurrentCycles+1
    528  0429							;
    529  0429							; fall into XINIT...
    530  0429							;
    531  0429							;=====================================================
    532  0429							; This initializes for the start of the next line of
    533  0429							; BASIC text.
    534  0429							;
    535  0429		       78	   iXINIT     sei		;ensure interupts are off
    536  042a		       20 0f 14 	      jsr	taskReset	;Clear the task table
    537  042d		       8d db 22 	      sta	IRQPending	; reset the irq pending
    538  0430		       8d da 22 	      sta	IRQStatus	; Make sure irqs are off
    539  0433
    540  0433		       4c bb 02    goodExit   jmp	NextIL
    541  0436							;
    542  0436							;=====================================================
    543  0436							; This check if the escape key has been entered
    544  0436							; then changes out of run mode. z Set if esc found
    545  0436				   BreakSet
    546  0436		       20 0f f0 	      jsr	ISCHAR
    547  0439		       f0 06		      beq	BreakNo
    548  043b		       20 f0 1b 	      jsr	VGETCH
    549  043e		       c9 1b		      cmp	#$1B
    550  0440		       60		      rts
    551  0441				   BreakNo
    552  0441		       a9 01		      lda	#1
    553  0443		       60		      rts
    554  0444
    555  0444							;
    556  0444
    557  0444							;=====================================================
    558  0444							; Verify there is nothing else on this input line.
    559  0444							; If there is, generate an error.
    560  0444							;
    561  0444		       a4 51	   iDONE      ldy	CUROFF
    562  0446		       20 9b 1a 	      jsr	SkipSpaces
    563  0449		       b1 4f		      lda	(CURPTR),y
    564  044b		       f0 10		      beq	doneadv
    565  044d		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    566  044f		       d0 05		      bne	idoneErr
    567  0451		       84 51		      sty	CUROFF
    568  0453		       4c bb 02 	      jmp	NextIL	; continue on this line
    569  0456
    570  0456				   idoneErr
    571  0456		       a2 04		      ldx	#ERR_EXTRA_STUFF
    572  0458		       a9 00		      lda	#0
    573  045a		       4c 18 06 	      jmp	iErr2
    574  045d							;
    575  045d							; Advance to the next line
    576  045d							;
    577  045d				   doneadv
    578  045d							;		 jsr	 FindNext2
    579  045d		       4c bb 02 	      jmp	NextIL
    580  0460							;
    581  0460							;=====================================================
    582  0460							; Print the string until a closing quote
    583  0460							;
    584  0460		       a4 51	   iPRS       ldy	CUROFF
    585  0462							;
    586  0462							; Odd logic here.  The main loop skipped any leading
    587  0462							; whitespace inside the quoted text, so move back to
    588  0462							; the quote, then move forward again.
    589  0462							;
    590  0462		       20 1d 1c 	      jsr	PrtQuoted
    591  0465		       84 51		      sty	CUROFF
    592  0467		       4c bb 02 	      jmp	NextIL
    593  046a							;
    594  046a							;=====================================================
    595  046a							; Pop the top off the stack and print it as a signed
    596  046a							; decimal number.
    597  046a							;
    598  046a		       20 eb 19    iPRN       jsr	popR0
    599  046d		       20 e0 11 	      jsr	PrintDecimal
    600  0470		       4c bb 02 	      jmp	NextIL
    601  0473							;
    602  0473							;=====================================================
    603  0473							; Space to next zone.	Currently the code does not
    604  0473							; keep track of which column the output is on, so
    605  0473							; just print a tab.
    606  0473							;
    607  0473		       a9 09	   iSPC       lda	#TAB
    608  0475		       20 ed 1b 	      jsr	VOUTCH
    609  0478		       4c bb 02 	      jmp	NextIL
    610  047b							;
    611  047b							;=====================================================
    612  047b							; If in immediate mode, jump to the address following
    613  047b							; the NXT instruction.  Else move to the next line of
    614  047b							; user code and continue.
    615  047b							;
    616  047b		       a5 5b	   iNXT       lda	RunMode
    617  047d		       d0 03		      bne	iNxtRun	;in run mode
    618  047f							;
    619  047f							; Get address and jump to it.
    620  047f							;
    621  047f		       4c 33 09 	      jmp	iJMP
    622  0482							;
    623  0482				   iNxtRun
    624  0482		       a4 51		      ldy	CUROFF
    625  0484		       20 9b 1a 	      jsr	SkipSpaces
    626  0487		       b1 4f		      lda	(CURPTR),y
    627  0489		       c9 3a		      cmp	#COLON
    628  048b		       d0 09		      bne	iNxtRunGo
    629  048d		       c8		      iny
    630  048e		       20 9b 1a 	      jsr	SkipSpaces
    631  0491		       84 51		      sty	CUROFF
    632  0493		       4c a1 04 	      jmp	iNxtRun2
    633  0496
    634  0496				   iNxtRunGo
    635  0496		       20 f8 17 	      jsr	FindNextLine
    636  0499		       20 0c 18 	      jsr	AtEnd
    637  049c		       d0 03		      bne	iNxtRun2	;not at end
    638  049e							;
    639  049e							; At the end of the program.  Pretend an END statement
    640  049e							; was found.
    641  049e							;
    642  049e		       4c 01 06    iFINv      jmp	iFIN
    643  04a1							;
    644  04a1		       20 6a 17    iNxtRun2   jsr	getILWord	;ignore next word
    645  04a4		       4c bb 02 	      jmp	NextIL
    646  04a7							;
    647  04a7							;=====================================================
    648  04a7							; XFER takes the number on top of the stack and looks
    649  04a7							; for that line in the program, or the next line
    650  04a7							; higher.  Ie, if it's 1 but there is no line 1, then
    651  04a7							; find the next one after that.
    652  04a7							;
    653  04a7		       20 eb 19    iXFER      jsr	popR0
    654  04aa		       20 b3 17 	      jsr	findLine
    655  04ad		       20 0c 18    iXFER2     jsr	AtEnd	;at end of user program?
    656  04b0		       f0 ec		      beq	iFINv
    657  04b2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    658  04b4		       84 51		      sty	CUROFF
    659  04b6		       a9 ff		      lda	#$ff
    660  04b8		       85 5b		      sta	RunMode
    661  04ba							;
    662  04ba							; Transfer IL to STMT.  I don't like having this
    663  04ba							; hard-coded; fix it.
    664  04ba							;
    665  04ba		       a9 0b		      lda	#STMT&$ff
    666  04bc		       85 43		      sta	ILPC
    667  04be		       a9 1e		      lda	#STMT>>8
    668  04c0		       85 44		      sta	ILPC+1
    669  04c2		       4c bb 02 	      jmp	NextIL
    670  04c5							;
    671  04c5							; Run
    672  04c5							;
    673  04c5				   iXferok
    674  04c5		       a9 ff		      lda	#$ff
    675  04c7		       85 5b		      sta	RunMode	;we're running
    676  04c9							;
    677  04c9							; Need a more elegant way to do this
    678  04c9							;
    679  04c9		       a9 0b		      lda	#STMT&$ff
    680  04cb		       85 43		      sta	ILPC
    681  04cd		       a9 1e		      lda	#STMT>>8
    682  04cf		       85 44		      sta	ILPC+1
    683  04d1		       4c bb 02 	      jmp	NextIL
    684  04d4							;
    685  04d4							;=====================================================
    686  04d4							; Save the pointer to the next line to the call stack.
    687  04d4							;
    688  04d4		       20 81 19    iSAV       jsr	pushLN
    689  04d7		       b0 03		      bcs	iSAVErr
    690  04d9		       4c bb 02 	      jmp	NextIL
    691  04dc
    692  04dc		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    693  04de		       a9 00	   iSAVErr2   lda	#0
    694  04e0		       4c 18 06 	      jmp	iErr2
    695  04e3							;====================================================
    696  04e3							; Move stack top to and from temp area
    697  04e3				   iStk2Tmp
    698  04e3		       20 eb 19 	      jsr	popR0
    699  04e6		       a5 52		      lda	R0
    700  04e8		       a0 19		      ldy	#TASKEXITCODE	; can also be used as temp
    701  04ea		       91 41		      sta	(VARIABLES),y
    702  04ec		       c8		      iny
    703  04ed		       a5 53		      lda	R0+1
    704  04ef		       91 41		      sta	(VARIABLES),y
    705  04f1		       4c bb 02 	      jmp	NextIL
    706  04f4
    707  04f4		       a0 19	   iTmp2Stk   ldy	#TASKEXITCODE
    708  04f6		       b1 41		      lda	(VARIABLES),y
    709  04f8		       85 52		      sta	R0
    710  04fa		       c8		      iny
    711  04fb		       b1 41		      lda	(VARIABLES),y
    712  04fd		       85 53		      sta	R0+1
    713  04ff		       20 67 19 	      jsr	pushR0
    714  0502		       4c bb 02 	      jmp	NextIL
    715  0505							;
    716  0505							;=====================================================
    717  0505							; Pop the next line from the call stack.
    718  0505							;
    719  0505		       20 a6 19    iRET       jsr	popLN
    720  0508		       b0 d2		      bcs	iSAVErr
    721  050a		       a0 03		      ldy	#3
    722  050c		       84 51		      sty	CUROFF
    723  050e		       a9 00		      lda	#0
    724  0510		       8d db 22 	      sta	IRQPending
    725  0513		       58		      cli
    726  0514		       4c bb 02 	      jmp	NextIL
    727  0517							;
    728  0517							;=====================================================
    729  0517							; Return from GOSUB function
    730  0517							;
    731  0517		       a4 4d	   iRSTR      ldy	GOSUBSTACKPTR
    732  0519		       f0 0f		      beq	iRSTRNoValue
    733  051b		       a5 58		      lda	R2
    734  051d		       85 56		      sta	MQ
    735  051f		       88		      dey
    736  0520		       b1 4b		      lda	(GOSUBSTACK),y
    737  0522		       c9 81		      cmp	#GOSUB_RTN_VALUE
    738  0524		       d0 04		      bne	iRSTRNoValue
    739  0526		       a9 01		      lda	#1
    740  0528		       d0 02		      bne	iRSTRExit
    741  052a				   iRSTRNoValue
    742  052a		       a9 00		      lda	#0
    743  052c				   iRSTRExit
    744  052c		       85 58		      sta	R2
    745  052e		       20 a6 19 	      jsr	popLN
    746  0531		       b0 06		      bcs	iRSTRErr
    747  0533		       20 3a 13 	      jsr	PopMathStackNow
    748  0536		       4c bb 02 	      jmp	NextIL
    749  0539
    750  0539		       ad de 22    iRSTRErr   lda	taskPtr	; Check if this is task zero
    751  053c		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    752  053e		       a5 56		      lda	MQ
    753  0540		       d0 03		      bne	taskRet
    754  0542		       20 61 1c 	      jsr	pushFalse	; the result code by default is 0
    755  0545				   taskRet
    756  0545		       4c b7 15 	      jmp	iETask	; not task zero then do a task end instead
    757  0548				   taskZeroEnd
    758  0548		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    759  054a		       d0 92		      bne	iSAVErr2
    760  054c							;
    761  054c							;=====================================================
    762  054c							; Compare items on stack.  Okay, so on input there are
    763  054c							; three things on the stack
    764  054c							;
    765  054c							;    EXPR2 <- Top of stack
    766  054c							;    OP    <- relational operator, next on stack
    767  054c							;    EXPR1 <- last item on stack
    768  054c							;
    769  054c							; Comparison is: EXPR1 <operator> EXPR2
    770  054c							;
    771  054c							; Operator is one of...
    772  054c							;
    773  054c							;    2 is =
    774  054c							;    1 is <
    775  054c							;    3 is <=
    776  054c							;    5 is <>
    777  054c							;    4 is >
    778  054c							;    6 is >=
    779  054c							;
    780  054c							; Those are bit-mapped:
    781  054c							;
    782  054c							;    xxxxxGEL
    783  054c							;
    784  054c							;    G = Greater than
    785  054c							;    E = Equal
    786  054c							;    L = Less than
    787  054c							;
    788  054c							; If the comparison is false, do a NXT, ie, move to the
    789  054c							; next line and continue.  If true, continue executing
    790  054c							; on this line.
    791  054c							;
    792  054c		       00 01	   REL_LT     equ	%001
    793  054c		       00 02	   REL_EQUAL  equ	%010
    794  054c		       00 04	   REL_GT     equ	%100
    795  054c							;
    796  054c		       20 03 1a    iCMPR      jsr	popR1
    797  054f		       20 1a 1a 	      jsr	popMQ	;operator in MQ
    798  0552		       20 eb 19 	      jsr	popR0
    799  0555		       20 5e 05 	      jsr	iCMPRsub
    800  0558		       20 67 19 	      jsr	pushR0
    801  055b		       4c bb 02 	      jmp	NextIL
    802  055e							;
    803  055e							; See if they are equal or not
    804  055e							;
    805  055e				   iCMPRsub		; Called by internal functions
    806  055e
    807  055e		       a5 52		      lda	R0
    808  0560		       c5 54		      cmp	R1
    809  0562		       d0 0a		      bne	iCMPRnoteq	;try not equal
    810  0564		       a5 53		      lda	R0+1
    811  0566		       c5 55		      cmp	R1+1
    812  0568		       d0 04		      bne	iCMPRnoteq
    813  056a							;
    814  056a							; Equal, set the flag in MQ+1
    815  056a							;
    816  056a		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    817  056c		       d0 14		      bne	iCMPcom	;Exit it is equal
    818  056e							;
    819  056e							; See if EXPR1 (R0) < EXPR2 (R1)
    820  056e							; See www.6502.org/tutorials/compare_beyond.html
    821  056e							;
    822  056e				   iCMPRnoteq
    823  056e		       a5 52		      lda	R0
    824  0570		       c5 54		      cmp	R1
    825  0572		       a5 53		      lda	R0+1
    826  0574		       e5 55		      sbc	R1+1
    827  0576		       50 02		      bvc	iCMPR_2
    828  0578		       49 80		      eor	#$80
    829  057a		       30 04	   iCMPR_2    bmi	iCMPlt
    830  057c		       a9 04		      lda	#REL_GT
    831  057e		       d0 02		      bne	iCMPcom
    832  0580		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    833  0582
    834  0582		       05 57	   iCMPcom    ora	MQ+1	; or with original mask
    835  0584							;
    836  0584							; Now compare the end result with what the caller
    837  0584							; was looking for.
    838  0584							;
    839  0584		       25 56		      and	MQ
    840  0586		       f0 0c		      beq	iCMPno	; no match
    841  0588		       a9 ff		      lda	#$FF	; true is $ffff
    842  058a		       85 52		      sta	R0
    843  058c		       85 53		      sta	R0+1
    844  058e		       d0 0c		      bne	iCMPDone
    845  0590							;
    846  0590							; R0 > R1
    847  0590							;
    848  0590		       a9 04	   iCMPgt     lda	#REL_GT
    849  0592		       d0 ee		      bne	iCMPcom
    850  0594				   iCMPno
    851  0594		       a9 00		      lda	#0
    852  0596		       85 52		      sta	R0
    853  0598		       a9 00		      lda	#0
    854  059a		       85 53		      sta	R0+1
    855  059c
    856  059c				   iCMPDone
    857  059c		       60		      rts
    858  059d
    859  059d							;
    860  059d							; if Not a match, so jump to the next line of code.
    861  059d							; Branches based upon value on top of the stack
    862  059d				   iBranch
    863  059d		       20 eb 19 	      jsr	popR0
    864  05a0		       a5 52		      lda	R0
    865  05a2		       05 53		      ora	R0+1
    866  05a4		       f0 03		      beq	iBranchFalse	; not true
    867  05a6		       4c bb 02 	      jmp	NextIL	; It is true if any value not zero
    868  05a9							;
    869  05a9				   iBranchFalse
    870  05a9		       20 f8 17 	      jsr	FindNextLine
    871  05ac		       4c ad 04 	      jmp	iXFER2
    872  05af							;
    873  05af							;=====================================================
    874  05af							; Start a read of data in background
    875  05af				   iReadStart
    876  05af		       a9 3f		      lda	#'?	; Prompt with question mark
    877  05b1		       a6 01		      ldx	1	; Indicate to start read in background
    878  05b3		       20 84 18 	      jsr	GetLine	; Call the getline to start read
    879  05b6		       4c bb 02 	      jmp	NextIL	; next instruction
    880  05b9							;
    881  05b9							;=====================================================
    882  05b9							; Complete the read and return the curptr, curoff pointing to data
    883  05b9				   iReadComplete
    884  05b9		       20 81 19 	      jsr	pushLN
    885  05bc		       90 03		      bcc	iReadOk
    886  05be		       4c 65 0b    iReadErr   jmp	ErrStkOver	; Check if there was an error
    887  05c1				   iReadOk
    888  05c1		       20 a4 18 	      jsr	ReadComplete
    889  05c4		       4c bb 02 	      jmp	NextIL
    890  05c7		       20 a6 19 	      jsr	popLN
    891  05ca		       4c bb 02 	      jmp	NextIL
    892  05cd							;=====================================================
    893  05cd							; Get a line of text from the user, convert to a
    894  05cd							; number, leave on top of stack.
    895  05cd							;
    896  05cd				   iINNUM
    897  05cd		       20 81 19 	      jsr	pushLN
    898  05d0		       b0 ec		      bcs	iReadErr	; Stack over flow error
    899  05d2							;
    900  05d2		       a9 3f		      lda	#'?
    901  05d4		       a2 00		      ldx	#0	;Wait for complete
    902  05d6		       20 84 18 	      jsr	GetLine
    903  05d9		       20 19 18 	      jsr	getDecimal
    904  05dc		       20 67 19 	      jsr	pushR0	;put onto stack
    905  05df		       b0 dd		      bcs	iReadErr	;StackOverflow error
    906  05e1							;
    907  05e1		       4c fb 05 	      jmp	ExitIn
    908  05e4							;
    909  05e4							;=====================================================
    910  05e4							; Get a line of text from the user, convert to a
    911  05e4							; character value , leave on top of stack. up to 2 characters
    912  05e4							;
    913  05e4				   iINSTR
    914  05e4		       20 81 19 	      jsr	pushLN
    915  05e7		       b0 d5		      bcs	iReadErr	; Stack overflow error
    916  05e9		       a9 3f		      lda	#'?
    917  05eb		       a2 00		      ldx	#0	;wait for read complete
    918  05ed		       20 84 18 	      jsr	GetLine
    919  05f0		       b1 4f		      lda	(CURPTR),y
    920  05f2		       85 52		      sta	R0
    921  05f4		       a9 00		      lda	#0
    922  05f6		       85 53		      sta	R0+1
    923  05f8		       20 67 19 	      jsr	pushR0	;put onto stack
    924  05fb				   ExitIn
    925  05fb		       20 a6 19 	      jsr	popLN
    926  05fe		       4c bb 02 	      jmp	NextIL
    927  0601							;
    928  0601							;
    929  0601							;=====================================================
    930  0601							; Stop the currently running program.	Actually very
    931  0601							; simple to do... clear the RunMode flag, then set the
    932  0601							; ILPC to the standard handler and continue running.
    933  0601							;
    934  0601		       a9 00	   iFIN       lda	#0
    935  0603		       85 5b		      sta	RunMode
    936  0605		       20 0f 14 	      jsr	taskReset
    937  0608							;
    938  0608		       ad 24 2c 	      lda	errGoto
    939  060b		       85 43		      sta	ILPC
    940  060d		       ad 25 2c 	      lda	errGoto+1
    941  0610		       85 44		      sta	ILPC+1
    942  0612		       4c bb 02 	      jmp	NextIL
    943  0615							;
    944  0615							;=====================================================
    945  0615							; Handle the ERR opcode.  Following the instruction is
    946  0615							; a 16 bit error number.  Print an error message, and
    947  0615							; if we're in run mode, print the line number.  Stop
    948  0615							; program execution and return to the initial state.
    949  0615							;
    950  0615		       20 6a 17    iERR       jsr	getILWord	;get err code
    951  0618							;
    952  0618							; Enter here with the error code in X (LSB) and A (MSB).
    953  0618							;
    954  0618		       86 52	   iErr2      stx	R0
    955  061a		       85 53		      sta	R0+1
    956  061c							;
    957  061c		       20 f3 1b 	      jsr	puts
      0  061f					      db	CR,LF,"Error ",0
      1  061f		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    959  0628		       20 e0 11 	      jsr	PrintDecimal
    960  062b							;
    961  062b		       a5 5b		      lda	RunMode	;running?
    962  062d		       f0 3b		      beq	iERR3	;nope
    963  062f		       20 f3 1b 	      jsr	puts
      0  0632					      db	" at line ",0
      1  0632		       20 61 74 20*	      .byte.b	" at line ",0
    965  063c		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    966  063e				   iErr2a
    967  063e		       b1 4f		      lda	(CURPTR),y
    968  0640		       85 52		      sta	R0
    969  0642		       c8		      iny
    970  0643		       b1 4f		      lda	(CURPTR),y
    971  0645		       85 53		      sta	R0+1
    972  0647		       20 e0 11 	      jsr	PrintDecimal
    973  064a		       20 f3 1b 	      jsr	puts
      0  064d					      db	":",0
      1  064d		       3a 00		      .byte.b	":",0
    975  064f		       a9 00		      lda	#0
    976  0651		       85 53		      sta	R0+1
    977  0653		       a5 51		      lda	CUROFF
    978  0655		       18		      clc
    979  0656		       e9 03		      sbc	#3
    980  0658		       85 52		      sta	R0
    981  065a		       20 e0 11 	      jsr	PrintDecimal
    982  065d		       20 f3 1b 	      jsr	puts
      0  0660					      db	":",0
      1  0660		       3a 00		      .byte.b	":",0
    984  0662		       ad de 22 	      lda	taskPtr
    985  0665		       85 52		      sta	R0
    986  0667		       20 e0 11 	      jsr	PrintDecimal
    987  066a							;
    988  066a		       20 a4 1a    iERR3      jsr	CRLF
    989  066d		       20 07 14 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    990  0670		       a9 00		      lda	#0
    991  0672		       85 5b		      sta	RunMode	;fall through...
    992  0674							;
    993  0674							;=====================================================
    994  0674							; Reset the IL to be back at the idle loop.  Does not
    995  0674							; clear variables so the user can see what state
    996  0674							; the program is in.
    997  0674							;
    998  0674		       a9 00	   ResetIL    lda	#0
    999  0676		       85 47		      sta	ILSTACKPTR
   1000  0678		       ad 24 2c 	      lda	errGoto
   1001  067b		       85 43		      sta	ILPC
   1002  067d		       ad 25 2c 	      lda	errGoto+1
   1003  0680		       85 44		      sta	ILPC+1
   1004  0682		       4c bb 02 	      jmp	NextIL
   1005  0685
   1006  0685							;
   1007  0685							;=====================================================
   1008  0685							; Pop two items off stack, add them, then place the
   1009  0685							; result back onto the stack.
   1010  0685							;
   1011  0685		       20 eb 19    iADD       jsr	popR0
   1012  0688		       20 03 1a 	      jsr	popR1
   1013  068b				   iADDfast
   1014  068b		       18		      clc
   1015  068c		       a5 52		      lda	R0
   1016  068e		       65 54		      adc	R1
   1017  0690		       85 52		      sta	R0
   1018  0692		       a5 53		      lda	R0+1
   1019  0694		       65 55		      adc	R1+1
   1020  0696		       85 53		      sta	R0+1
   1021  0698		       4c 03 07 	      jmp	pushR0nextIl
   1022  069b							;
   1023  069b							;=====================================================
   1024  069b							; Pop two items off the stack.  Subtract the top of
   1025  069b							; stack from the lower entry.
   1026  069b							;
   1027  069b		       20 03 1a    iSUB       jsr	popR1
   1028  069e		       20 eb 19 	      jsr	popR0
   1029  06a1		       38		      sec
   1030  06a2		       a5 52		      lda	R0
   1031  06a4		       e5 54		      sbc	R1
   1032  06a6		       85 52		      sta	R0
   1033  06a8		       a5 53		      lda	R0+1
   1034  06aa		       e5 55		      sbc	R1+1
   1035  06ac		       85 53		      sta	R0+1
   1036  06ae		       4c 03 07 	      jmp	pushR0nextIl
   1037  06b1							;
   1038  06b1							;=====================================================
   1039  06b1							; Negate the top of stack.
   1040  06b1							;
   1041  06b1		       20 eb 19    iNEG       jsr	popR0
   1042  06b4		       a5 52		      lda	R0
   1043  06b6		       49 ff		      eor	#$ff
   1044  06b8		       85 52		      sta	R0
   1045  06ba		       a5 53		      lda	R0+1
   1046  06bc		       49 ff		      eor	#$ff
   1047  06be		       85 53		      sta	R0+1
   1048  06c0		       e6 52		      inc	R0
   1049  06c2		       d0 02		      bne	iNEG2
   1050  06c4		       e6 53		      inc	R0+1
   1051  06c6		       4c 03 07    iNEG2      jmp	pushR0nextIl
   1052  06c9							;
   1053  06c9							;=====================================================
   1054  06c9							; Multiply top two items on the stack, put the results
   1055  06c9							; on top.  This uses the algorithm documented on page
   1056  06c9							; 115 of "Microprocessor Programming for Computer
   1057  06c9							; Hobbyists" by Neill Graham.
   1058  06c9							;
   1059  06c9		       20 cf 06    iMUL       jsr	iMultiply
   1060  06cc		       4c bb 02 	      jmp	NextIL
   1061  06cf
   1062  06cf				   iMultiply
   1063  06cf		       20 eb 19 	      jsr	popR0	;AC
   1064  06d2		       20 03 1a 	      jsr	popR1	;OP
   1065  06d5							;
   1066  06d5		       a5 52		      lda	R0
   1067  06d7		       85 56		      sta	MQ
   1068  06d9		       a5 53		      lda	R0+1
   1069  06db		       85 57		      sta	MQ+1
   1070  06dd		       a9 00		      lda	#0	;clear result
   1071  06df		       85 52		      sta	R0
   1072  06e1		       85 53		      sta	R0+1
   1073  06e3							;
   1074  06e3		       a2 10		      ldx	#16	;number of bits in value
   1075  06e5		       06 52	   multloop   asl	R0
   1076  06e7		       26 53		      rol	R0+1
   1077  06e9		       06 56		      asl	MQ
   1078  06eb		       26 57		      rol	MQ+1
   1079  06ed		       90 0d		      bcc	multno	;skip add if no carry
   1080  06ef							;
   1081  06ef							; Add R1 back into R0
   1082  06ef							;
   1083  06ef		       18		      clc
   1084  06f0		       a5 52		      lda	R0
   1085  06f2		       65 54		      adc	R1
   1086  06f4		       85 52		      sta	R0
   1087  06f6		       a5 53		      lda	R0+1
   1088  06f8		       65 55		      adc	R1+1
   1089  06fa		       85 53		      sta	R0+1
   1090  06fc							;
   1091  06fc		       ca	   multno     dex		;did all bits yet?
   1092  06fd		       d0 e6		      bne	multloop
   1093  06ff		       20 67 19 	      jsr	pushR0	;OP
   1094  0702		       60		      rts
   1095  0703							;
   1096  0703				   pushR0nextIl
   1097  0703		       20 67 19 	      jsr	pushR0	;OP
   1098  0706		       4c bb 02 	      jmp	NextIL
   1099  0709							;
   1100  0709							;=====================================================
   1101  0709							; Divide the top of stack into the next to top item.
   1102  0709							; Leave results on stack.  Taken from:
   1103  0709							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1104  0709							;
   1105  0709							; R0 = R0 / R1
   1106  0709							; Remainder is in MQ
   1107  0709							;
   1108  0709		       20 23 07    iDIV       jsr	iDoDiv
   1109  070c		       20 6c 1a 	      jsr	RestoreSigns
   1110  070f		       4c 03 07 	      jmp	pushR0nextIl
   1111  0712
   1112  0712		       20 23 07    iMOD       jsr	iDoDiv
   1113  0715		       20 6c 1a 	      jsr	RestoreSigns
   1114  0718		       a5 56		      lda	MQ
   1115  071a		       85 52		      sta	R0
   1116  071c		       a5 57		      lda	MQ+1
   1117  071e		       85 53		      sta	R0+1
   1118  0720		       4c 03 07 	      jmp	pushR0nextIl
   1119  0723
   1120  0723				   iDoDiv
   1121  0723		       20 03 1a 	      jsr	popR1
   1122  0726		       20 eb 19 	      jsr	popR0
   1123  0729							;
   1124  0729							; Check for divide by zero
   1125  0729							;
   1126  0729
   1127  0729				   iDivNoPop
   1128  0729		       a5 54		      lda	R1
   1129  072b		       05 55		      ora	R1+1
   1130  072d		       f0 29		      beq	divby0
   1131  072f							;
   1132  072f		       20 31 1a 	      jsr	SaveSigns
   1133  0732		       a9 00		      lda	#0	;preset remainder to 0
   1134  0734		       85 56		      sta	MQ
   1135  0736		       85 57		      sta	MQ+1
   1136  0738		       a2 10		      ldx	#16	;repeat for each bit: ...
   1137  073a				   divloop
   1138  073a		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1139  073c		       26 53		      rol	R0+1
   1140  073e		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1141  0740		       26 57		      rol	MQ+1
   1142  0742		       a5 56		      lda	MQ
   1143  0744		       38		      sec
   1144  0745		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1145  0747		       a8		      tay		;lb result -> Y, for we may need it later
   1146  0748		       a5 57		      lda	MQ+1
   1147  074a		       e5 55		      sbc	R1+1
   1148  074c		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1149  074e
   1150  074e		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1151  0750		       84 56		      sty	MQ
   1152  0752		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1153  0754
   1154  0754		       ca	   skip       dex
   1155  0755		       d0 e3		      bne	divloop
   1156  0757		       60		      rts
   1157  0758							;
   1158  0758							; Indicate divide-by-zero error
   1159  0758							;
   1160  0758		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1161  075a		       a9 00		      lda	#0
   1162  075c		       4c 18 06 	      jmp	iErr2
   1163  075f							;
   1164  075f							;=====================================================
   1165  075f							; This pops the top two items off the stack.  The top
   1166  075f							; item is a data value and the other is an ABSOLUTE address.
   1167  075f							;Save the value into that address.
   1168  075f							;
   1169  075f		       98	   iSTORE     tya
   1170  0760		       48		      pha
   1171  0761		       20 eb 19 	      jsr	popR0	;data
   1172  0764		       20 03 1a 	      jsr	popR1	;Storage location
   1173  0767		       a0 00		      ldy	#0
   1174  0769		       a5 52		      lda	R0
   1175  076b		       91 54		      sta	(R1),y
   1176  076d		       a5 53		      lda	R0+1
   1177  076f		       c8		      iny
   1178  0770		       91 54		      sta	(R1),y
   1179  0772		       68		      pla
   1180  0773		       a8		      tay
   1181  0774		       4c bb 02 	      jmp	NextIL
   1182  0777							;
   1183  0777							;=====================================================
   1184  0777							; Replaces the top of stack with the variable whose
   1185  0777							; absolute address it represents.
   1186  0777							;
   1187  0777		       98	   iIND       tya
   1188  0778		       48		      pha
   1189  0779		       20 03 1a 	      jsr	popR1
   1190  077c		       a0 00		      ldy	#0
   1191  077e		       b1 54		      lda	(R1),y
   1192  0780		       85 52		      sta	R0
   1193  0782		       c8		      iny
   1194  0783		       b1 54		      lda	(R1),y
   1195  0785		       85 53		      sta	R0+1
   1196  0787		       68		      pla
   1197  0788		       a8		      tay
   1198  0789		       4c 03 07 	      jmp	pushR0nextIl
   1199  078c							;
   1200  078c							;=====================================================
   1201  078c							; Get the array index from top of stack get Current variable
   1202  078c							; address from next on stack, add the offset
   1203  078c							; push the result back onto the stack
   1204  078c				   iArray
   1205  078c		       20 eb 19 	      jsr	popR0	; Get the array index
   1206  078f		       20 03 1a 	      jsr	popR1	; Get the Variable address
   1207  0792
   1208  0792		       18		      clc		; Multiplythe value by 2
   1209  0793		       26 52		      rol	R0	; Do the multiply
   1210  0795		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1211  0797		       18		      clc
   1212  0798		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1213  079a		       65 52		      adc	R0
   1214  079c		       85 52		      sta	R0
   1215  079e		       a5 55		      lda	R1+1
   1216  07a0		       65 53		      adc	R0+1
   1217  07a2		       85 53		      sta	R0+1	; the new Variable Addressis  stored in R0
   1218  07a4		       20 67 19 	      jsr	pushR0	; Push R0 assume it is correct
   1219  07a7
   1220  07a7		       a5 54		      lda	R1	; Check if we are processing a VARIABLE A-Z
   1221  07a9		       c5 41		      cmp	VARIABLES	; So is this the @ pointer
   1222  07ab		       d0 22		      bne	iArrayAtTest	; if they want to use the memory then good luck
   1223  07ad		       a5 55		      lda	R1+1
   1224  07af		       c5 42		      cmp	VARIABLES+1
   1225  07b1		       d0 1c		      bne	iArrayAtTest
   1226  07b3		       18		      clc
   1227  07b4		       a9 34		      lda	#52	; add the max offset that is valid
   1228  07b6		       65 54		      adc	R1	; update to be the largest offset that is valid
   1229  07b8		       85 54		      sta	R1
   1230  07ba		       a9 00		      lda	#0
   1231  07bc		       65 55		      adc	R1+1
   1232  07be		       85 55		      sta	R1+1
   1233  07c0				   iArrayVerify 		; try to enforce some sanity to using arrays
   1234  07c0		       a5 53		      lda	R0+1
   1235  07c2		       c5 55		      cmp	R1+1
   1236  07c4		       d0 04		      bne	iArrayDecide
   1237  07c6		       a5 52		      lda	R0
   1238  07c8		       c5 54		      cmp	R1
   1239  07ca				   iArrayDecide
   1240  07ca		       b0 0f		      bcs	iArrayError	; is the new value greater than the end
   1241  07cc		       4c bb 02 	      jmp	NextIL
   1242  07cf
   1243  07cf				   iArrayAtTest
   1244  07cf		       ad 3b 2c 	      lda	HighMem
   1245  07d2		       85 54		      sta	R1
   1246  07d4		       ad 3c 2c 	      lda	HighMem+1
   1247  07d7		       85 55		      sta	R1+1
   1248  07d9		       d0 e5		      bne	iArrayVerify	; The high byte of address is never 0
   1249  07db
   1250  07db							; Get here if array index is out of range
   1251  07db		       20 eb 19    iArrayError jsr	popR0
   1252  07de		       a9 00		      lda	#0
   1253  07e0		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1254  07e2		       4c 18 06 	      jmp	iErr2
   1255  07e5							;
   1256  07e5							;=====================================================
   1257  07e5							; List the current BASIC program in memory.  Uses R0,
   1258  07e5							; tempIly, and dpl.
   1259  07e5							;
   1260  07e5		       20 d3 1b    iLST       jsr	SetOutConsole
   1261  07e8		       ad 37 2c    iLST2      lda	ProgramStart
   1262  07eb		       85 59		      sta	dpl
   1263  07ed		       ad 38 2c 	      lda	ProgramStart+1
   1264  07f0		       85 5a		      sta	dpl+1
   1265  07f2							;
   1266  07f2							; dpl/dph point to the current line.  See if we're at
   1267  07f2							; the end of the program.
   1268  07f2							;
   1269  07f2		       a5 59	   iLSTloop   lda	dpl
   1270  07f4		       cd 39 2c 	      cmp	ProgramEnd
   1271  07f7		       d0 07		      bne	iLstNotEnd
   1272  07f9		       a5 5a		      lda	dpl+1
   1273  07fb		       cd 3a 2c 	      cmp	ProgramEnd+1
   1274  07fe		       f0 44		      beq	iLstdone
   1275  0800							;
   1276  0800		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1277  0802		       b1 59		      lda	(dpl),y	;line number LSB
   1278  0804		       85 52		      sta	R0
   1279  0806		       c8		      iny
   1280  0807		       b1 59		      lda	(dpl),y	;line number MSB
   1281  0809		       85 53		      sta	R0+1
   1282  080b		       c8		      iny
   1283  080c		       8c 32 2c 	      sty	tempIlY
   1284  080f		       20 e0 11 	      jsr	PrintDecimal
   1285  0812		       a9 20		      lda	#SPACE
   1286  0814		       20 ed 1b 	      jsr	VOUTCH
   1287  0817		       ac 32 2c 	      ldy	tempIlY
   1288  081a		       b1 59	   iLSTl2     lda	(dpl),y
   1289  081c		       f0 0c		      beq	iLST3	;end of this line 0 value
   1290  081e		       8c 32 2c 	      sty	tempIlY
   1291  0821		       20 ed 1b 	      jsr	VOUTCH
   1292  0824		       ac 32 2c 	      ldy	tempIlY
   1293  0827		       c8		      iny
   1294  0828		       d0 f0		      bne	iLSTl2	;do next char
   1295  082a							;
   1296  082a							; End of this line.  Print CR/LF, then move to the
   1297  082a							; next line.
   1298  082a							;
   1299  082a		       c8	   iLST3      iny		;Move to next line
   1300  082b		       18		      clc		;Clear the carry flag
   1301  082c		       98		      tya		;Current Offset
   1302  082d		       65 59		      adc	dpl	;Add the offset to the pointer
   1303  082f		       85 59		      sta	dpl	;Save the new value
   1304  0831		       a5 5a		      lda	dpl+1	;Next byte
   1305  0833		       69 00		      adc	#0	;ad in the carry if any
   1306  0835		       85 5a		      sta	dpl+1	;Save it
   1307  0837							;
   1308  0837							; Have to manually do CR/LF so it uses the vectored
   1309  0837							; output function.
   1310  0837							;
   1311  0837		       a9 0d		      lda	#CR
   1312  0839		       20 ed 1b 	      jsr	VOUTCH
   1313  083c		       a9 0a		      lda	#LF
   1314  083e		       20 ed 1b 	      jsr	VOUTCH
   1315  0841		       4c f2 07 	      jmp	iLSTloop	;do next line
   1316  0844							;
   1317  0844		       20 d3 1b    iLstdone   jsr	SetOutConsole
   1318  0847		       4c bb 02 	      jmp	NextIL
   1319  084a							;
   1320  084a							;=====================================================
   1321  084a							; Get a line of text into LINBUF.  Terminate with a
   1322  084a							; null byte.
   1323  084a							;
   1324  084a				   iGETLINE
   1325  084a		       a9 3e		      lda	#'>	;prompt character
   1326  084c		       a6 00		      ldx	0	;Wait for read to complete
   1327  084e		       20 84 18 	      jsr	GetLine
   1328  0851							;
   1329  0851		       a9 00		      lda	#0
   1330  0853		       85 5b		      sta	RunMode
   1331  0855				   iGetParseLine
   1332  0855		       a5 51		      lda	CUROFF
   1333  0857		       48		      pha
   1334  0858		       20 cd 0e 	      jsr	ParseInputLine
   1335  085b		       48		      pha
   1336  085c		       85 51		      sta	CUROFF
   1337  085e		       4c bb 02 	      jmp	NextIL
   1338  0861							;
   1339  0861							;=====================================================
   1340  0861							; This is called when the input buffer contains a line
   1341  0861							; typed in by the user that starts with a line number.
   1342  0861							; Insert the line into the program or delete the line
   1343  0861							; if there is nothing after the line number,
   1344  0861							;
   1345  0861		       a0 00	   iINSRT     ldy	#0
   1346  0863		       20 19 18 	      jsr	getDecimal	;convert line #
   1347  0866		       20 9b 1a 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1348  0869		       8c 33 2c 	      sty	offset	;Save the start of the program line text
   1349  086c							;
   1350  086c							; Now find the line OR the next higher line OR the
   1351  086c							; end of the program.
   1352  086c							;
   1353  086c		       20 b3 17 	      jsr	findLine	; Look for the line number in the current program
   1354  086f							; Returns Z and curptr point to the line if found
   1355  086f							; Returns C and curptr at next higher line if not found and there is a higher line
   1356  086f							; Returns ZC clear and curptr to end of program if higher than all other lines
   1357  086f							;
   1358  086f							; If the line exists, it needs to be removed.
   1359  086f							;
   1360  086f		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1361  0871							;
   1362  0871							; Get length of line to be removed, we fall thru to here if we find a matching line
   1363  0871							;
   1364  0871							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1365  0871		       a0 00		      ldy	#0
   1366  0873		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1367  0875		       a8		      tay
   1368  0876							;If it is equal we delete the line and replace it, get length
   1369  0876							;then adjust all program line after up or down depending on len of line
   1370  0876							;If next higher then just move everythimg down by length bytes
   1371  0876							;This call will return how many bytes in the line we found
   1372  0876		       8c 34 2c 	      sty	lineLength	;Save the length of the line we found
   1373  0879							;
   1374  0879							; Compute the new end of the program first.
   1375  0879							;
   1376  0879		       38		      sec		;Set the carry bit
   1377  087a		       ad 39 2c 	      lda	ProgramEnd	;Get low byte of program end
   1378  087d		       ed 34 2c 	      sbc	lineLength	;Subtract the length of the current line
   1379  0880		       8d 39 2c 	      sta	ProgramEnd	;save it
   1380  0883		       ad 3a 2c 	      lda	ProgramEnd+1
   1381  0886		       e9 00		      sbc	#0	;Process the carry
   1382  0888		       8d 3a 2c 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1383  088b							;
   1384  088b							; Copy CURPTR into R1 for working
   1385  088b							;
   1386  088b		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1387  088d		       85 54		      sta	R1
   1388  088f		       a5 50		      lda	CURPTR+1
   1389  0891		       85 55		      sta	R1+1
   1390  0893							;
   1391  0893							; See if we're at the end.
   1392  0893							;
   1393  0893		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1394  0895		       cd 39 2c 	      cmp	ProgramEnd
   1395  0898		       d0 07		      bne	InsDelLoop
   1396  089a		       a5 55		      lda	R1+1
   1397  089c		       cd 3a 2c 	      cmp	ProgramEnd+1
   1398  089f		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1399  08a1							;
   1400  08a1							; Move one byte, move to next location.
   1401  08a1							;
   1402  08a1		       ac 34 2c    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1403  08a4		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1404  08a6		       b1 54		      lda	(R1),y
   1405  08a8		       a0 00		      ldy	#0
   1406  08aa		       91 54		      sta	(R1),y
   1407  08ac		       e6 54		      inc	R1
   1408  08ae		       d0 e3		      bne	InsDelChk
   1409  08b0		       e6 55		      inc	R1+1
   1410  08b2		       4c 93 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1411  08b5							;
   1412  08b5							; Deletion is done.
   1413  08b5							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1414  08b5							;
   1415  08b5		       ac 33 2c    insert2    ldy	offset	; get back ptr  Get the current offset
   1416  08b8		       b9 9a 2b 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1417  08bb		       f0 5f		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1418  08bd							;
   1419  08bd							; CURPTR points to where the line will be inserted.
   1420  08bd							;
   1421  08bd		       20 3e 19 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1422  08c0							;
   1423  08c0		       ad 39 2c 	      lda	ProgramEnd	;Load the start address for the copy
   1424  08c3							;At this point curptr still contains the location we will insert data
   1425  08c3		       85 5c		      sta	FROM
   1426  08c5		       ad 3a 2c 	      lda	ProgramEnd+1
   1427  08c8		       85 5d		      sta	FROM+1
   1428  08ca							;
   1429  08ca		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1430  08cc		       b1 5c		      lda	(FROM),y
   1431  08ce		       ac 34 2c 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1432  08d1		       91 5c		      sta	(FROM),y	;Save the new byte
   1433  08d3							;
   1434  08d3		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1435  08d5		       c5 4f		      cmp	CURPTR
   1436  08d7		       d0 06		      bne	mvUpMore
   1437  08d9		       a5 5d		      lda	FROM+1
   1438  08db		       c5 50		      cmp	CURPTR+1
   1439  08dd		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1440  08df							;
   1441  08df							; Not done yet
   1442  08df							;
   1443  08df		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1444  08e1		       d0 02		      bne	mvUpMore2
   1445  08e3		       c6 5d		      dec	FROM+1
   1446  08e5		       c6 5c	   mvUpMore2  dec	FROM
   1447  08e7		       4c ca 08 	      jmp	mvup1	;Loop until everything is moved
   1448  08ea							;
   1449  08ea							; All done with copy.
   1450  08ea							;
   1451  08ea				   mvUpDone
   1452  08ea		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1453  08eb		       ad 34 2c 	      lda	lineLength	;Number of bytes to copy from line buff
   1454  08ee		       6d 39 2c 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1455  08f1		       8d 39 2c 	      sta	ProgramEnd
   1456  08f4		       ad 3a 2c 	      lda	ProgramEnd+1
   1457  08f7		       69 00		      adc	#0
   1458  08f9		       8d 3a 2c 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1459  08fc							;
   1460  08fc							;===================jlit use length before line newline
   1461  08fc
   1462  08fc		       a0 00		      ldy	#0	;Set offset of copy
   1463  08fe		       ad 34 2c 	      lda	lineLength	;We will insert the actual length of the line first
   1464  0901		       91 4f		      sta	(CURPTR),y	;Store the length
   1465  0903		       c8		      iny
   1466  0904		       a5 52		      lda	R0	;Store the line number next
   1467  0906		       91 4f		      sta	(CURPTR),y
   1468  0908		       c8		      iny
   1469  0909		       a5 53		      lda	R0+1
   1470  090b		       91 4f		      sta	(CURPTR),y
   1471  090d		       c8		      iny
   1472  090e							;
   1473  090e		       ae 33 2c 	      ldx	offset	;Load the offset into line buffer in page zero
   1474  0911		       bd 9a 2b    mvUpLoop2  lda	LINBUF,x	;get a byte
   1475  0914		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1476  0916		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1477  0918		       e8		      inx
   1478  0919		       c8		      iny
   1479  091a		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1480  091c							;
   1481  091c		       4c bb 02    mvUpFini   jmp	NextIL
   1482  091f							;
   1483  091f							;=====================================================
   1484  091f							; Pops the top value of the ILPC stack and stores it
   1485  091f							; in ILPC.  Ie, return from an IL subroutine.
   1486  091f							;
   1487  091f		       20 a1 17    iRTN       jsr	popILPC
   1488  0922		       4c bb 02 	      jmp	NextIL
   1489  0925							;
   1490  0925							;=====================================================
   1491  0925							; NLINE print a newline
   1492  0925							;
   1493  0925		       20 a4 1a    iNLINE     jsr	CRLF	;user supplied sub
   1494  0928		       4c bb 02 	      jmp	NextIL
   1495  092b							;
   1496  092b							;=====================================================
   1497  092b							; This saves the current ILPC value on the stack, then
   1498  092b							; jumps to the address specified by the next two bytes.
   1499  092b							;
   1500  092b		       20 84 17    iCALL      jsr	pushILPC	;save ILPC
   1501  092e		       90 03		      bcc	iJMP
   1502  0930		       4c 65 0b 	      jmp	ErrStkOver	; Check if there was an error
   1503  0933							;
   1504  0933							; Jmp to a specific location in the IL code.  The new
   1505  0933							; address immediately follows the opcode.
   1506  0933							;
   1507  0933		       20 6a 17    iJMP       jsr	getILWord
   1508  0936		       86 43		      stx	ILPC
   1509  0938		       85 44		      sta	ILPC+1
   1510  093a		       4c bb 02 	      jmp	NextIL
   1511  093d
   1512  093d
   1513  093d							;
   1514  093d							;=====================================================
   1515  093d							; Push the next two bytes onto the arithmetic stack.
   1516  093d							;
   1517  093d		       20 6e 17    iSetR2     jsr	getILByte
   1518  0940		       85 58		      sta	R2
   1519  0942		       4c bb 02 	      jmp	NextIL
   1520  0945							;
   1521  0945							;=====================================================
   1522  0945							; Push the next two bytes onto the arithmetic stack.
   1523  0945							;
   1524  0945		       20 6a 17    iLIT       jsr	getILWord
   1525  0948		       86 52		      stx	R0
   1526  094a		       85 53		      sta	R0+1
   1527  094c		       20 67 19 	      jsr	pushR0
   1528  094f		       4c bb 02 	      jmp	NextIL
   1529  0952							;
   1530  0952							;=====================================================
   1531  0952							; Initialize all variables for a single task.	Ie, set to zero.
   1532  0952							;
   1533  0952		       98	   subVINIT   tya
   1534  0953		       48		      pha
   1535  0954
   1536  0954		       a9 00		      lda	#0
   1537  0956		       a0 00		      ldy	#0
   1538  0958		       91 41	   Vinit2     sta	(VARIABLES),y
   1539  095a		       c8		      iny
   1540  095b		       c0 19		      cpy	#VARIABLESSIZE-1 * 2	; skip the old exit code
   1541  095d		       90 f9		      bcc	Vinit2
   1542  095f
   1543  095f		       68		      pla
   1544  0960		       a8		      tay
   1545  0961		       60		      rts
   1546  0962
   1547  0962		       20 52 09    iVINIT     jsr	subVINIT
   1548  0965		       4c bb 02 	      jmp	NextIL
   1549  0968							;
   1550  0968							;=====================================================
   1551  0968							; Set the address of the error handler.  After any
   1552  0968							; error, set to the ILPC to the specified location.
   1553  0968							;
   1554  0968		       20 6a 17    iERRGOTO   jsr	getILWord
   1555  096b		       8e 24 2c 	      stx	errGoto
   1556  096e		       8d 25 2c 	      sta	errGoto+1
   1557  0971		       4c bb 02 	      jmp	NextIL
   1558  0974							;
   1559  0974							;=====================================================
   1560  0974							; TST is followed by an 8 bit signed offset, then a
   1561  0974							; null terminated string.  Compare the string against
   1562  0974							; the string starting at (CURPTR),CUROFF.  If the
   1563  0974							; strings match, continue executing the next IL
   1564  0974							; opcode.  Else, add the offset to ILPC.
   1565  0974							;
   1566  0974		       20 6e 17    iTST       jsr	getILByte	;Get the relative jump address
   1567  0977		       8d 33 2c 	      sta	offset	;save it to use if test faile
   1568  097a		       20 51 19 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1569  097d
   1570  097d		       a4 51		      ldy	CUROFF
   1571  097f		       84 59		      sty	dpl	;save for later
   1572  0981							;
   1573  0981		       20 6e 17    iTSTloop   jsr	getILByte	;get next char
   1574  0984		       f0 11		      beq	iTSTm	;match!
   1575  0986		       a4 59		      ldy	dpl
   1576  0988		       d1 4f		      cmp	(CURPTR),y
   1577  098a		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1578  098c		       09 20		      ora	#$20	; lets allow lowercase as well
   1579  098e		       d1 4f		      cmp	(CURPTR),y
   1580  0990		       d0 23		      bne	iTSTfail	;mismatch
   1581  0992		       c8	   iTSTUpper  iny
   1582  0993		       84 59		      sty	dpl
   1583  0995		       d0 ea		      bne	iTSTloop
   1584  0997							;
   1585  0997							; It's a match!  Clean up a bit.
   1586  0997							;
   1587  0997		       a4 59	   iTSTm      ldy	dpl
   1588  0999		       84 51		      sty	CUROFF
   1589  099b		       4c bb 02 	      jmp	NextIL
   1590  099e
   1591  099e							; Test for a single quote string
   1592  099e		       20 6e 17    iTSTStr    jsr	getILByte
   1593  09a1		       8d 33 2c 	      sta	offset
   1594  09a4		       20 51 19 	      jsr	saveIL
   1595  09a7		       a4 51		      ldy	CUROFF
   1596  09a9		       a9 22		      lda	#'"
   1597  09ab		       d1 4f		      cmp	(CURPTR),y
   1598  09ad		       d0 06		      bne	iTSTfail
   1599  09af		       c8		      iny
   1600  09b0		       84 51		      sty	CUROFF
   1601  09b2		       4c de 02 	      jmp	NextILStr
   1602  09b5							;
   1603  09b5							; Not a match, reset ILPC and then move to the
   1604  09b5							; offset.
   1605  09b5							;
   1606  09b5		       20 5c 19    iTSTfail   jsr	restoreIL
   1607  09b8		       4c 15 0b 	      jmp	tstBranch
   1608  09bb							;
   1609  09bb							;=================================================JLIT=
   1610  09bb							; Test if we have a let statement without the let keyword
   1611  09bb		       20 6e 17    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1612  09be		       8d 33 2c 	      sta	offset	; Save the jump offset for fails
   1613  09c1		       20 51 19 	      jsr	saveIL	; save to restore when done if fail
   1614  09c4
   1615  09c4		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1616  09c6		       20 9b 1a 	      jsr	SkipSpaces	; Skipp leading spaces reall only for command line execution
   1617  09c9		       c8		      iny		; skip the Variable name, the leading spaces are always removed
   1618  09ca		       20 9b 1a 	      jsr	SkipSpaces	; skip any SkipSpaces
   1619  09cd		       b1 4f		      lda	(CURPTR),y	; Get what should be an equal sign
   1620  09cf		       c9 3d		      cmp	#'=	; check if equals
   1621  09d1		       f0 04		      beq	iTSTLETGOOD	; Yes that is fine
   1622  09d3		       c9 5b		      cmp	#'[	; Can be a subscript as well
   1623  09d5		       d0 de		      bne	iTSTfail	; return it failed
   1624  09d7
   1625  09d7				   iTSTLETGOOD
   1626  09d7		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1627  09da
   1628  09da							;=================================================JLIT=
   1629  09da							;
   1630  09da		       20 6e 17    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1631  09dd		       8d 33 2c 	      sta	offset	; Save the jump offset for fails
   1632  09e0		       20 51 19 	      jsr	saveIL	; save to restore when done if fail
   1633  09e3		       20 6a 17 	      jsr	getILWord	; Get a word into RO
   1634  09e6		       86 52		      stx	R0
   1635  09e8		       85 53		      sta	R0+1
   1636  09ea		       20 6e 17 	      jsr	getILByte	; Get byte into A
   1637  09ed		       a0 00		      ldy	#0
   1638  09ef		       d1 52		      cmp	(R0),y
   1639  09f1		       d0 03		      bne	iTSTByteNotEqual
   1640  09f3		       4c b5 09 	      jmp	iTSTfail
   1641  09f6
   1642  09f6				   iTSTByteNotEqual
   1643  09f6		       4c bb 02 	      jmp	NextIL	; Then next instruction
   1644  09f9
   1645  09f9
   1646  09f9							;================================================jLIT=
   1647  09f9							;Test for end of line
   1648  09f9							;
   1649  09f9		       20 6e 17    iTSTDONE   jsr	getILByte
   1650  09fc		       8d 33 2c 	      sta	offset
   1651  09ff		       20 51 19 	      jsr	saveIL
   1652  0a02		       a4 51		      ldy	CUROFF
   1653  0a04		       84 59		      sty	dpl
   1654  0a06		       20 9b 1a 	      jsr	SkipSpaces
   1655  0a09		       b1 4f		      lda	(CURPTR),y
   1656  0a0b		       f0 0b		      beq	iTSTDONEtrue
   1657  0a0d		       c9 3a		      cmp	#COLON
   1658  0a0f		       f0 07		      beq	iTSTDONEtrue
   1659  0a11		       a4 59		      ldy	dpl
   1660  0a13		       84 51		      sty	CUROFF
   1661  0a15		       4c b5 09 	      jmp	iTSTfail
   1662  0a18							;
   1663  0a18							; Advance to the next line
   1664  0a18							;
   1665  0a18				   iTSTDONEtrue
   1666  0a18		       4c bb 02 	      jmp	NextIL
   1667  0a1b
   1668  0a1b		       4c 15 0b    tstBranchLink jmp	tstBranch
   1669  0a1e							;
   1670  0a1e							;=====================================================
   1671  0a1e							; Inc and dec a variable , faster than a = a + 1
   1672  0a1e				   iINCVAR
   1673  0a1e		       20 eb 19 	      jsr	popR0
   1674  0a21		       a0 00		      ldy	#0
   1675  0a23		       18		      clc
   1676  0a24		       a9 01		      lda	#1
   1677  0a26		       71 52		      adc	(R0),y
   1678  0a28		       91 52		      sta	(R0),y
   1679  0a2a		       90 07		      bcc	iINCDONE
   1680  0a2c		       c8		      iny
   1681  0a2d		       a9 00		      lda	#0
   1682  0a2f		       71 52		      adc	(R0),y
   1683  0a31		       91 52		      sta	(R0),y
   1684  0a33				   iINCDONE
   1685  0a33		       4c bb 02 	      jmp	NextIL
   1686  0a36				   iDECVAR
   1687  0a36		       20 eb 19 	      jsr	popR0
   1688  0a39		       a0 00		      ldy	#0
   1689  0a3b		       38		      sec
   1690  0a3c		       b1 52		      lda	(R0),y
   1691  0a3e		       e9 01		      sbc	#1
   1692  0a40		       91 52		      sta	(R0),y
   1693  0a42		       c8		      iny
   1694  0a43		       b1 52		      lda	(R0),y
   1695  0a45		       69 00		      adc	#0
   1696  0a47		       91 52		      sta	(R0),y
   1697  0a49		       4c bb 02 	      jmp	NextIL
   1698  0a4c
   1699  0a4c
   1700  0a4c							;
   1701  0a4c							;=====================================================
   1702  0a4c							; TSTV is followed by an 8 bit signed offset.	If the
   1703  0a4c							; value at (CURPTR),CUROFF appears to be a variable
   1704  0a4c							; name, move to the next IL statement.  Else, add the
   1705  0a4c							; offset to ILPC. Converted to use actual absolute memory addresses
   1706  0a4c							; TSTVT Looks for the task context
   1707  0a4c							;
   1708  0a4c		       20 03 1a    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1709  0a4f		       a9 00		      lda	#0
   1710  0a51		       85 58		      sta	R2
   1711  0a53		       f0 04		      beq	iTSTVV
   1712  0a55
   1713  0a55		       a9 01	   iTSTV      lda	#1
   1714  0a57		       85 58		      sta	R2
   1715  0a59
   1716  0a59		       20 6e 17    iTSTVV     jsr	getILByte	;offset
   1717  0a5c		       8d 33 2c 	      sta	offset
   1718  0a5f							;
   1719  0a5f		       a4 51		      ldy	CUROFF
   1720  0a61		       20 9b 1a 	      jsr	SkipSpaces
   1721  0a64		       b1 4f		      lda	(CURPTR),y
   1722  0a66		       d0 03		      bne	iTSTVnext
   1723  0a68		       4c 1b 0a 	      jmp	tstBranchLink	;if we are at the end of line just get out with error
   1724  0a6b							;
   1725  0a6b				   iTSTVnext
   1726  0a6b		       c9 40		      cmp	#'@	;allow access to all unused memory as an array or integers
   1727  0a6d		       f0 47		      beq	iTSTVat	;Setup to do a pointer to unused memory
   1728  0a6f
   1729  0a6f		       c9 23		      cmp	#'#	; parameters passed to this task
   1730  0a71		       f0 53		      beq	iTSTVParm
   1731  0a73
   1732  0a73		       c9 5e		      cmp	#'^	; task exit code
   1733  0a75		       d0 04		      bne	iTSTV_A2Z
   1734  0a77		       a9 19		      lda	#TASKEXITCODE
   1735  0a79		       d0 10		      bne	iTSTVContinue
   1736  0a7b
   1737  0a7b				   iTSTV_A2Z
   1738  0a7b		       09 20		      ora	#$20	;make lower then upper
   1739  0a7d		       49 20		      eor	#$20	;allow lower case here
   1740  0a7f		       c9 41		      cmp	#'A
   1741  0a81		       90 98		      bcc	tstBranchLink
   1742  0a83		       c9 5b		      cmp	#'Z+1
   1743  0a85		       b0 94		      bcs	tstBranchLink
   1744  0a87
   1745  0a87
   1746  0a87							;
   1747  0a87							; The condition is true, so convert to an index, push
   1748  0a87							; it onto the stack and continue running.
   1749  0a87							;
   1750  0a87		       38		      sec
   1751  0a88		       e9 41		      sbc	#'A	;index is zero based
   1752  0a8a		       0a		      asl		;multiply by two
   1753  0a8b
   1754  0a8b				   iTSTVContinue
   1755  0a8b		       c8		      iny
   1756  0a8c		       84 51		      sty	CUROFF	;it is a valid variable
   1757  0a8e		       48		      pha
   1758  0a8f		       a5 58		      lda	R2
   1759  0a91		       d0 11		      bne	iTSTVLocalValue	;Value local to this task
   1760  0a93
   1761  0a93		       20 51 17 	      jsr	ipc_getcontext	; Get the other tasks variables
   1762  0a96		       a0 01		      ldy	#VARIABLEPOS
   1763  0a98		       b1 56		      lda	(MQ),y
   1764  0a9a		       85 52		      sta	R0
   1765  0a9c		       c8		      iny
   1766  0a9d		       b1 56		      lda	(MQ),y
   1767  0a9f		       85 53		      sta	R0+1
   1768  0aa1		       4c ac 0a 	      jmp	iTSTVAddOffset
   1769  0aa4
   1770  0aa4				   iTSTVLocalValue
   1771  0aa4		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1772  0aa6		       85 52		      sta	R0
   1773  0aa8		       a5 42		      lda	VARIABLES+1
   1774  0aaa		       85 53		      sta	R0+1
   1775  0aac
   1776  0aac				   iTSTVAddOffset
   1777  0aac		       68		      pla
   1778  0aad		       85 54		      sta	R1
   1779  0aaf		       a9 00		      lda	#0
   1780  0ab1		       85 55		      sta	R1+1
   1781  0ab3
   1782  0ab3				   iTSTVcontinue
   1783  0ab3
   1784  0ab3		       4c 8b 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1785  0ab6
   1786  0ab6							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1787  0ab6							; an array of integer values
   1788  0ab6				   iTSTVat
   1789  0ab6		       c8		      iny
   1790  0ab7		       84 51		      sty	CUROFF	;it is a valid variable
   1791  0ab9		       ad 39 2c 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1792  0abc		       85 52		      sta	R0
   1793  0abe		       ad 3a 2c 	      lda	ProgramEnd+1
   1794  0ac1		       85 53		      sta	R0+1
   1795  0ac3		       4c 03 07 	      jmp	pushR0nextIl	;place this onto the stack
   1796  0ac6
   1797  0ac6							; When we get parameters passed we can access them using the # variable with[]
   1798  0ac6							; example #[0] #[1] etc, we dont check yet if there is too many
   1799  0ac6				   iTSTVParm
   1800  0ac6		       c8		      iny
   1801  0ac7		       84 51		      sty	CUROFF	;it is a valid variable
   1802  0ac9		       a5 48		      lda	MATHSTACK
   1803  0acb		       85 52		      sta	R0
   1804  0acd		       a5 49		      lda	MATHSTACK+1
   1805  0acf		       85 53		      sta	R0+1
   1806  0ad1		       4c 03 07 	      jmp	pushR0nextIl
   1807  0ad4
   1808  0ad4							;
   1809  0ad4							;=====================================================
   1810  0ad4							; TSTL seems basically the same as TSTN, but leave the
   1811  0ad4							; value in R0 instead of pushing onto stack.
   1812  0ad4							; This tests for a valid line number
   1813  0ad4							;
   1814  0ad4		       20 6e 17    iTSTL      jsr	getILByte
   1815  0ad7		       8d 33 2c 	      sta	offset
   1816  0ada							;
   1817  0ada		       a4 51		      ldy	CUROFF
   1818  0adc		       20 9b 1a 	      jsr	SkipSpaces
   1819  0adf		       b1 4f		      lda	(CURPTR),y
   1820  0ae1							;
   1821  0ae1		       c9 30		      cmp	#'0
   1822  0ae3		       90 30		      bcc	tstBranch
   1823  0ae5		       c9 3a		      cmp	#'9+1
   1824  0ae7		       b0 2c		      bcs	tstBranch
   1825  0ae9							;
   1826  0ae9							; It's a digit, so convert to a number.
   1827  0ae9							;
   1828  0ae9		       20 19 18 	      jsr	getDecimal
   1829  0aec		       4c bb 02 	      jmp	NextIL
   1830  0aef							;
   1831  0aef							;=====================================================
   1832  0aef							; TSTN checks for a number.  This is very simplistic;
   1833  0aef							; if the character is a digit, assume it's a number.
   1834  0aef							; Convert to a number and push it onto the stack.
   1835  0aef							;
   1836  0aef		       20 6e 17    iTSTN      jsr	getILByte
   1837  0af2		       8d 33 2c 	      sta	offset
   1838  0af5							;
   1839  0af5		       a4 51		      ldy	CUROFF
   1840  0af7		       20 9b 1a 	      jsr	SkipSpaces
   1841  0afa		       b1 4f		      lda	(CURPTR),y
   1842  0afc		       f0 17		      beq	tstBranch
   1843  0afe		       c9 2d		      cmp	#'-	;negative?
   1844  0b00		       f0 08		      beq	iTSTN_1
   1845  0b02		       c9 30		      cmp	#'0
   1846  0b04		       90 0f		      bcc	tstBranch
   1847  0b06		       c9 3a		      cmp	#'9+1
   1848  0b08		       b0 0b		      bcs	tstBranch
   1849  0b0a							;
   1850  0b0a							; It's a digit, so convert to a number.
   1851  0b0a							;
   1852  0b0a				   iTSTN_1
   1853  0b0a		       20 19 18 	      jsr	getDecimal
   1854  0b0d		       84 51		      sty	CUROFF
   1855  0b0f		       20 67 19 	      jsr	pushR0	;save onto stack
   1856  0b12		       4c bb 02 	      jmp	NextIL
   1857  0b15
   1858  0b15							;
   1859  0b15							; Common jump point for all TSTx instructions that
   1860  0b15							; fail to meet the requirements.  This takes the
   1861  0b15							; offset and adds/subtracts to/from ILPC.
   1862  0b15							;
   1863  0b15		       ad 33 2c    tstBranch  lda	offset	;get signed offset
   1864  0b18		       10 0e		      bpl	tstPositive
   1865  0b1a							;
   1866  0b1a							; Do negative branch.	Do sign extension.
   1867  0b1a							;
   1868  0b1a		       18	   tstNegative clc
   1869  0b1b		       65 43		      adc	ILPC
   1870  0b1d		       85 43		      sta	ILPC
   1871  0b1f							;		  bcc	  tstBothDone
   1872  0b1f							;		  dec	  ILPC+1
   1873  0b1f							;		  jmp	  NextIL
   1874  0b1f
   1875  0b1f		       a5 44		      lda	ILPC+1
   1876  0b21		       69 ff		      adc	#$ff
   1877  0b23		       85 44		      sta	ILPC+1
   1878  0b25		       4c bb 02 	      jmp	NextIL	;keep going
   1879  0b28							;
   1880  0b28		       18	   tstPositive clc
   1881  0b29		       65 43		      adc	ILPC
   1882  0b2b		       85 43		      sta	ILPC
   1883  0b2d		       90 02		      bcc	tstBothDone
   1884  0b2f		       e6 44		      inc	ILPC+1
   1885  0b31				   tstBothDone
   1886  0b31		       4c bb 02 	      jmp	NextIL
   1887  0b34
   1888  0b34							;
   1889  0b34							;====================================================
   1890  0b34							; Test for IRQ pending, and test if a break key pressed
   1891  0b34							; Yes I know but this handles all sorts of irq/break issues
   1892  0b34							;
   1893  0b34		       20 6e 17    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1894  0b37		       8d 33 2c 	      sta	offset	; Store the not true jump address offset
   1895  0b3a		       20 36 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1896  0b3d		       d0 03		      bne	irqNo	; z not set of no break found
   1897  0b3f		       4c 01 06 	      jmp	iFIN	; Exit out of run mode
   1898  0b42		       ad db 22    irqNo      lda	IRQPending
   1899  0b45		       f0 ce		      beq	tstBranch
   1900  0b47		       c9 01		      cmp	#1	; only do this if set to first time
   1901  0b49		       d0 ca		      bne	tstBranch
   1902  0b4b		       78		      sei		; disable the interupt until ireturn resets it
   1903  0b4c		       ee db 22    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1904  0b4f		       20 81 19 	      jsr	pushLN	; Push the next line to be executed
   1905  0b52		       b0 11		      bcs	ErrStkOver	; Check if there was an error
   1906  0b54		       ad dc 22 	      lda	IRQEntry	; Get the line number to branch to
   1907  0b57		       85 4f		      sta	CURPTR	; put line number into r0
   1908  0b59		       ad dd 22 	      lda	IRQEntry+1
   1909  0b5c		       85 50		      sta	CURPTR+1
   1910  0b5e		       a9 03		      lda	#3	; Point to first byte of program text
   1911  0b60		       85 51		      sta	CUROFF
   1912  0b62		       4c bb 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1913  0b65
   1914  0b65		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   1915  0b67		       a9 00		      lda	#0	; stop the execution
   1916  0b69		       4c 18 06 	      jmp	iErr2
   1917  0b6c							;
   1918  0b6c
   1919  0b6c							;=====================================================
   1920  0b6c							; This places the number of free bytes on top of the
   1921  0b6c							; stack.
   1922  0b6c							;
   1923  0b6c		       20 d4 12    iFREE      jsr	MemFree
   1924  0b6f		       20 67 19 	      jsr	pushR0
   1925  0b72		       4c bb 02 	      jmp	NextIL
   1926  0b75							;
   1927  0b75							;=====================================================
   1928  0b75							; Generate a random number from 0-FFFF and then MOD
   1929  0b75							; it with the value on top of stack.  Leaves number on
   1930  0b75							; stack
   1931  0b75							;
   1932  0b75		       20 03 1a    iRANDOM    jsr	popR1	;mod value
   1933  0b78							;
   1934  0b78							; If the value is zero, just return a one.
   1935  0b78							;
   1936  0b78		       a5 54		      lda	R1
   1937  0b7a		       05 55		      ora	R1+1
   1938  0b7c		       f0 4a		      beq	irandom1
   1939  0b7e							;
   1940  0b7e		       ad 2a 2c 	      lda	random+1
   1941  0b81		       8d 27 2c 	      sta	rtemp1
   1942  0b84		       ad 29 2c 	      lda	random
   1943  0b87		       0a		      asl
   1944  0b88		       2e 27 2c 	      rol	rtemp1
   1945  0b8b		       0a		      asl
   1946  0b8c		       2e 27 2c 	      rol	rtemp1
   1947  0b8f		       18		      clc
   1948  0b90		       6d 29 2c 	      adc	random
   1949  0b93
   1950  0b93		       48		      pha
   1951  0b94
   1952  0b94		       ad 27 2c 	      lda	rtemp1
   1953  0b97		       6d 2a 2c 	      adc	random+1
   1954  0b9a		       8d 2a 2c 	      sta	random+1
   1955  0b9d
   1956  0b9d		       68		      pla
   1957  0b9e
   1958  0b9e		       69 11		      adc	#$11
   1959  0ba0		       8d 29 2c 	      sta	random
   1960  0ba3		       ad 2a 2c 	      lda	random+1
   1961  0ba6		       69 36		      adc	#$36
   1962  0ba8		       8d 2a 2c 	      sta	random+1
   1963  0bab
   1964  0bab		       ad 29 2c 	      lda	random
   1965  0bae		       85 52		      sta	R0
   1966  0bb0		       ad 2a 2c 	      lda	random+1
   1967  0bb3		       29 7f		      and	#$7f	;make positive
   1968  0bb5		       85 53		      sta	R0+1
   1969  0bb7							;
   1970  0bb7							; R0 contains the number and R1 contains the max value.
   1971  0bb7							;
   1972  0bb7		       20 29 07 	      jsr	iDivNoPop
   1973  0bba		       20 6c 1a 	      jsr	RestoreSigns
   1974  0bbd		       a5 56		      lda	MQ
   1975  0bbf		       85 52		      sta	R0
   1976  0bc1		       a5 57		      lda	MQ+1
   1977  0bc3		       85 53		      sta	R0+1
   1978  0bc5		       4c 03 07 	      jmp	pushR0nextIl
   1979  0bc8				   irandom1
   1980  0bc8		       a9 00		      lda	#0
   1981  0bca		       85 53		      sta	R0+1
   1982  0bcc		       a9 01		      lda	#1
   1983  0bce		       85 52		      sta	R0
   1984  0bd0		       4c 03 07 	      jmp	pushR0nextIl
   1985  0bd3
   1986  0bd3							; The following replaced by call to division/modulo
   1987  0bd3							;iRANDOM_2	lda	R0
   1988  0bd3							;		cmp	R1
   1989  0bd3							;		bne	iRANDOM_1
   1990  0bd3							;		lda	R0+1
   1991  0bd3							;		cmp	R1+1
   1992  0bd3							;		bne	iRANDOM_1	;need to subtract
   1993  0bd3							;
   1994  0bd3							; Subtract R1 from R0
   1995  0bd3							;
   1996  0bd3							;iRANDOM_sub	sec
   1997  0bd3							;		lda	R0
   1998  0bd3							;		sbc	R1
   1999  0bd3							;		sta	R0
   2000  0bd3							;		lda	R0+1
   2001  0bd3							;		sbc	R1+1
   2002  0bd3							;		sta	R0+1
   2003  0bd3							;		jmp	iRANDOM_2
   2004  0bd3							;
   2005  0bd3							; See if R1 > R0.  If so, branch to subtract.
   2006  0bd3							;
   2007  0bd3							;iRANDOM_1	lda	R0
   2008  0bd3							;		cmp	R1
   2009  0bd3							;		lda	R0+1
   2010  0bd3							;		sbc	R1+1
   2011  0bd3							;		bvc	iRANDOM_4
   2012  0bd3							;		eor	#$80
   2013  0bd3							;iRANDOM_4	bpl	iRANDOM_sub
   2014  0bd3							;
   2015  0bd3							; All done.  Almost.  Add one, then push the result.
   2016  0bd3							;
   2017  0bd3							;irandom1	inc	R0
   2018  0bd3							;		bne	iRANDOM_3
   2019  0bd3							;		inc	R0+1
   2020  0bd3							;iRANDOM_3
   2021  0bd3							;		  jsr	pushR0	;return value
   2022  0bd3							;		jmp	NextIL
   2023  0bd3							;
   2024  0bd3							; Poke a value into a memory location
   2025  0bd3		       8c 2f 2c    iPOKEMEMORY sty	tempy
   2026  0bd6		       20 eb 19 	      jsr	popR0
   2027  0bd9		       20 03 1a 	      jsr	popR1
   2028  0bdc		       a0 00		      ldy	#0
   2029  0bde		       a5 52		      lda	R0
   2030  0be0		       91 54		      sta	(R1),y
   2031  0be2		       ac 2f 2c 	      ldy	tempy
   2032  0be5		       4c bb 02 	      jmp	NextIL
   2033  0be8							;
   2034  0be8							; Get a value from a memory location
   2035  0be8							;
   2036  0be8		       8c 2f 2c    iPEEKMEMORY sty	tempy
   2037  0beb		       20 eb 19 	      jsr	popR0
   2038  0bee		       a0 00		      ldy	#0
   2039  0bf0		       b1 52		      lda	(R0),y
   2040  0bf2		       ac 2f 2c 	      ldy	tempy
   2041  0bf5		       85 52		      sta	R0
   2042  0bf7		       a9 00		      lda	#0
   2043  0bf9		       85 53		      sta	R0+1
   2044  0bfb		       4c 03 07 	      jmp	pushR0nextIl
   2045  0bfe							;
   2046  0bfe							; Call to address return what ever is in a to the stack
   2047  0bfe							; func2 will load a value into a before the call
   2048  0bfe		       20 03 1a    iCallFunc  jsr	popR1
   2049  0c01		       a5 54		      lda	R1
   2050  0c03		       20 0f 0c 	      jsr	iCallRtn
   2051  0c06		       85 52		      sta	R0
   2052  0c08		       a9 00		      lda	#0
   2053  0c0a		       85 53		      sta	R0+1
   2054  0c0c		       20 03 07 	      jsr	pushR0nextIl
   2055  0c0f				   iCallRtn
   2056  0c0f		       20 eb 19 	      jsr	popR0
   2057  0c12		       6c 52 00 	      jmp	(R0)
   2058  0c15
   2059  0c15
   2060  0c15							;===========================================jlit======
   2061  0c15							;Get a character from the terminal convert to value
   2062  0c15							;leave the number on top of the stack
   2063  0c15							;
   2064  0c15				   iGETCHAR
   2065  0c15		       20 f0 1b 	      jsr	VGETCH
   2066  0c18					      if	CTMON65
   2067  0c18		       48		      pha
   2068  0c19		       20 ed 1b 	      jsr	VOUTCH	;echo echo echo
   2069  0c1c		       68		      pla
   2070  0c1d					      endif
   2071  0c1d		       85 52		      sta	R0
   2072  0c1f		       a9 00		      lda	#0
   2073  0c21		       85 53		      sta	R0+1
   2074  0c23		       20 67 19 	      jsr	pushR0
   2075  0c26							;
   2076  0c26		       4c bb 02 	      jmp	NextIL
   2077  0c29							;===========================================jusilostintim======
   2078  0c29							;Put a character to the terminal convert to
   2079  0c29							;
   2080  0c29		       20 eb 19    iPUTCHAR   jsr	popR0
   2081  0c2c		       a5 52		      lda	R0
   2082  0c2e		       20 ed 1b 	      jsr	VOUTCH
   2083  0c31		       4c bb 02 	      jmp	NextIL
   2084  0c34							;=====================================================
   2085  0c34							; Put the number on the stack out as hex, suppress leading 0
   2086  0c34				   iHexOut
   2087  0c34		       20 eb 19 	      jsr	popR0
   2088  0c37		       a5 53		      lda	R0+1
   2089  0c39		       f0 03		      beq	iHexSecondByte
   2090  0c3b		       20 92 12 	      jsr	OUTHEX
   2091  0c3e				   iHexSecondByte
   2092  0c3e		       a5 52		      lda	R0
   2093  0c40		       20 92 12 	      jsr	OUTHEX
   2094  0c43		       4c bb 02 	      jmp	NextIL
   2095  0c46							;
   2096  0c46							;=====================================================
   2097  0c46							; Replace TOS with its absolute value.
   2098  0c46							;
   2099  0c46		       20 eb 19    iABS       jsr	popR0
   2100  0c49		       a5 53		      lda	R0+1
   2101  0c4b		       10 10		      bpl	iABS_1	;already positive
   2102  0c4d		       49 ff		      eor	#$ff
   2103  0c4f		       85 53		      sta	R0+1
   2104  0c51		       a5 52		      lda	R0
   2105  0c53		       49 ff		      eor	#$ff
   2106  0c55		       85 52		      sta	R0
   2107  0c57		       e6 52		      inc	R0
   2108  0c59		       d0 02		      bne	iABS_1
   2109  0c5b		       e6 53		      inc	R0+1
   2110  0c5d		       4c 03 07    iABS_1     jmp	pushR0nextIl
   2111  0c60
   2112  0c60							;
   2113  0c60							;================================================================
   2114  0c60							; The set of logical operators
   2115  0c60				   iLogAnd
   2116  0c60		       20 eb 19 	      jsr	popR0
   2117  0c63		       20 03 1a 	      jsr	popR1
   2118  0c66		       a5 52		      lda	R0
   2119  0c68		       25 54		      and	R1
   2120  0c6a		       85 52		      sta	R0
   2121  0c6c		       a5 53		      lda	R0+1
   2122  0c6e		       25 55		      and	R1+1
   2123  0c70		       85 53		      sta	R0+1
   2124  0c72		       4c 03 07 	      jmp	pushR0nextIl
   2125  0c75				   iLogOr
   2126  0c75		       20 eb 19 	      jsr	popR0
   2127  0c78		       20 03 1a 	      jsr	popR1
   2128  0c7b		       a5 52		      lda	R0
   2129  0c7d		       05 54		      ora	R1
   2130  0c7f		       85 52		      sta	R0
   2131  0c81		       a5 53		      lda	R0+1
   2132  0c83		       05 55		      ora	R1+1
   2133  0c85		       85 53		      sta	R0+1
   2134  0c87		       4c 03 07 	      jmp	pushR0nextIl
   2135  0c8a				   iLogXor
   2136  0c8a		       20 eb 19 	      jsr	popR0
   2137  0c8d		       20 03 1a 	      jsr	popR1
   2138  0c90		       a5 52		      lda	R0
   2139  0c92		       45 54		      eor	R1
   2140  0c94		       85 52		      sta	R0
   2141  0c96		       a5 53		      lda	R0+1
   2142  0c98		       45 55		      eor	R1+1
   2143  0c9a		       85 53		      sta	R0+1
   2144  0c9c		       4c 03 07 	      jmp	pushR0nextIl
   2145  0c9f				   iLogNot
   2146  0c9f		       20 eb 19 	      jsr	popR0
   2147  0ca2		       a5 52		      lda	R0
   2148  0ca4		       49 ff		      eor	#$FF
   2149  0ca6		       85 52		      sta	R0
   2150  0ca8		       a5 53		      lda	R0+1
   2151  0caa		       49 ff		      eor	#$FF
   2152  0cac		       85 53		      sta	R0+1
   2153  0cae		       4c 03 07 	      jmp	pushR0nextIl
   2154  0cb1
   2155  0cb1				   iTruth
   2156  0cb1		       a9 ff		      lda	#$FF
   2157  0cb3		       85 52		      sta	R0
   2158  0cb5		       85 53		      sta	R0+1
   2159  0cb7		       4c 03 07 	      jmp	pushR0nextIl
   2160  0cba				   iFalse
   2161  0cba		       a9 00		      lda	#$00
   2162  0cbc		       85 52		      sta	R0
   2163  0cbe		       85 53		      sta	R0+1
   2164  0cc0		       4c 03 07 	      jmp	pushR0nextIl
   2165  0cc3
   2166  0cc3							;================================================================
   2167  0cc3							;Set the IRQ service rtn line number
   2168  0cc3							;
   2169  0cc3		       78	   iSetIrq    sei		; disable the interupts
   2170  0cc4		       a9 00		      lda	#0	; Zero the Status flag
   2171  0cc6		       8d da 22 	      sta	IRQStatus
   2172  0cc9		       20 eb 19 	      jsr	popR0	; get the line number
   2173  0ccc		       a5 52		      lda	R0
   2174  0cce		       05 53		      ora	R0+1
   2175  0cd0		       f0 20		      beq	iSetExt	; if it is zero disable all
   2176  0cd2		       20 81 19 	      jsr	pushLN	; Save the current line pointer
   2177  0cd5		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2178  0cd7		       4c 65 0b 	      jmp	ErrStkOver	; Check if there was an error
   2179  0cda				   iSetIrqOk
   2180  0cda		       20 b3 17 	      jsr	findLine	; Find the IRQ func Line Pointer
   2181  0cdd		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   2182  0cdf		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2183  0ce1		       8d dd 22 	      sta	IRQEntry+1
   2184  0ce4		       a5 4f		      lda	CURPTR
   2185  0ce6		       8d dc 22 	      sta	IRQEntry
   2186  0ce9		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2187  0ceb		       8d da 22 	      sta	IRQStatus
   2188  0cee		       20 a6 19 	      jsr	popLN	; Restore the old line number
   2189  0cf1		       58		      cli		; Enable the interupts
   2190  0cf2		       4c bb 02    iSetExt    jmp	NextIL
   2191  0cf5
   2192  0cf5		       20 a6 19    iSetIrqErr jsr	popLN
   2193  0cf8		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2194  0cfa		       a9 00		      lda	#0
   2195  0cfc		       4c 18 06 	      jmp	iErr2
   2196  0cff							;
   2197  0cff		       20 eb 19    iTRACEPROG jsr	popR0
   2198  0d02		       a5 52		      lda	R0
   2199  0d04		       85 40		      sta	ILTrace
   2200  0d06		       4c bb 02 	      jmp	NextIL
   2201  0d09
   2202  0d09							;=====================================================
   2203  0d09							; Define start of non page zero data
   2204 U2c41 ????				      seg.u	TBData
   2205 U22c9					      org	PROGEND
   2206 U22c9							;=================================================================
   2207 U22c9							;
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0 U22c9					      include	"tokenizer.asm"
      1  0d09					      seg	Code
      2  0d09		       ff ff ff ff DEBUGPARSER equ	TRUE	; Print debugging information
      3  0d09
      4  0d09							; Define the types of tokens found, and identifiers
      5  0d09		       00 80	   KeywordsMax equ	128	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  0d09		       00 80	   tVa	      equ	128	; Variable A = 1, .... Z = 26	 ^ = 27
      7  0d09		       00 82	   tVb	      equ	130	; Variables 128 - 157	$80-$9D
      8  0d09		       00 9b	   tVhat      equ	155	; Variable ^
      9  0d09		       00 9c	   tVhash     equ	156	; Variable #
     10  0d09		       00 9d	   tVat       equ	157	; Variable @ = 0
     11  0d09
     12  0d09		       00 a0	   tInteger   equ	160	; all tokenized integers start with 251 as first byte
     13  0d09		       00 a1	   tString    equ	161	; String all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     14  0d09		       00 a2	   tByte      equ	162	; Unsigned byte value
     15  0d09		       00 a3	   tArray     equ	163	; Identifies Array Type, the byte following defines the length of each element
     16  0d09							; Arrays of string are arrays of pointers 2 bytes
     17  0d09		       00 a4	   tPointer   equ	164	; Pointer to another variable
     18  0d09		       00 a5	   tVariable  equ	165	; Variable index  = A-Z and ^ variables
     19  0d09		       00 a7	   tIndirect  equ	167	; Points to an address that points to the data
     20  0d09
     21  0d09		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     22  0d09							;  +($F0), <($F1),=($F2),<=($F3), >($F4), <>($F5), >=($F6), -($F7), /($F8), %($F9), *($FA), (($FB), )($FC)
     23  0d09							;  240 - 252
     24  0d09		       00 ff	   tError     equ	255	; Error should never happen
     25  0d09							;
     26  0d09							; Keyword table contains 48 keywords
     27  0d09				   KeyWordTable
      0  0d09					      db	"leT"	; 1, we only have 0 at end of program or line
      1  0d09		       6c 65 54 	      .byte.b	"leT"
      0  0d0c					      db	"inC"
      1  0d0c		       69 6e 43 	      .byte.b	"inC"
      0  0d0f					      db	"deC"
      1  0d0f		       64 65 43 	      .byte.b	"deC"
      0  0d12					      db	"ireturN"
      1  0d12		       69 72 65 74*	      .byte.b	"ireturN"
      0  0d19					      db	"iF"
      1  0d19		       69 46		      .byte.b	"iF"
      0  0d1b					      db	"theN"
      1  0d1b		       74 68 65 4e	      .byte.b	"theN"
      0  0d1f					      db	"gotO"
      1  0d1f		       67 6f 74 4f	      .byte.b	"gotO"
      0  0d23					      db	"gosuB"
      1  0d23		       67 6f 73 75*	      .byte.b	"gosuB"
      0  0d28					      db	"returN"
      1  0d28		       72 65 74 75*	      .byte.b	"returN"
      0  0d2e					      db	"reM"
      1  0d2e		       72 65 4d 	      .byte.b	"reM"
      0  0d31					      db	"prinT"
      1  0d31		       70 72 69 6e*	      .byte.b	"prinT"
     39  0d31		       00 0b	   kPrint     equ	11	; sould be entry for print
      0  0d36					      db	"taskE"
      1  0d36		       74 61 73 6b*	      .byte.b	"taskE"
      0  0d3b					      db	"taskN"
      1  0d3b		       74 61 73 6b*	      .byte.b	"taskN"
      0  0d40					      db	"taskW"
      1  0d40		       74 61 73 6b*	      .byte.b	"taskW"
      0  0d45					      db	"pokE"
      1  0d45		       70 6f 6b 45	      .byte.b	"pokE"
      0  0d49					      db	"putcH"
      1  0d49		       70 75 74 63*	      .byte.b	"putcH"
      0  0d4e					      db	"clS"
      1  0d4e		       63 6c 53 	      .byte.b	"clS"
      0  0d51					      db	"inpuT"
      1  0d51		       69 6e 70 75*	      .byte.b	"inpuT"
      0  0d56					      db	"enD"
      1  0d56		       65 6e 44 	      .byte.b	"enD"
      0  0d59					      db	"irQ"
      1  0d59		       69 72 51 	      .byte.b	"irQ"
      0  0d5c					      db	"kilL"
      1  0d5c		       6b 69 6c 4c	      .byte.b	"kilL"
      0  0d60					      db	"lisT"
      1  0d60		       6c 69 73 54	      .byte.b	"lisT"
      0  0d64					      db	"ruN"
      1  0d64		       72 75 4e 	      .byte.b	"ruN"
      0  0d67					      db	"neW"
      1  0d67		       6e 65 57 	      .byte.b	"neW"
      0  0d6a					      db	"slicE"
      1  0d6a		       73 6c 69 63*	      .byte.b	"slicE"
      0  0d6f					      db	"tracE"
      1  0d6f		       74 72 61 63*	      .byte.b	"tracE"
      0  0d74					      db	"exiT"
      1  0d74		       65 78 69 54	      .byte.b	"exiT"
      0  0d78					      db	"savE"
      1  0d78		       73 61 76 45	      .byte.b	"savE"
      0  0d7c					      db	"loaD"
      1  0d7c		       6c 6f 61 44	      .byte.b	"loaD"
      0  0d80					      db	"erasE"
      1  0d80		       65 72 61 73*	      .byte.b	"erasE"
      0  0d85					      db	"noT"
      1  0d85		       6e 6f 54 	      .byte.b	"noT"
      0  0d88					      db	"oR"
      1  0d88		       6f 52		      .byte.b	"oR"
      0  0d8a					      db	"xoR"
      1  0d8a		       78 6f 52 	      .byte.b	"xoR"
      0  0d8d					      db	"anD"
      1  0d8d		       61 6e 44 	      .byte.b	"anD"
      0  0d90					      db	"truE"
      1  0d90		       74 72 75 45	      .byte.b	"truE"
      0  0d94					      db	"falsE"
      1  0d94		       66 61 6c 73*	      .byte.b	"falsE"
     65  0d99							;functions returning values
      0  0d99					      db	"freE"
      1  0d99		       66 72 65 45	      .byte.b	"freE"
      0  0d9d					      db	"getcH"
      1  0d9d		       67 65 74 63*	      .byte.b	"getcH"
      0  0da2					      db	"peeK"
      1  0da2		       70 65 65 4b	      .byte.b	"peeK"
      0  0da6					      db	"tasK"
      1  0da6		       74 61 73 4b	      .byte.b	"tasK"
      0  0daa					      db	"ipcc"
      1  0daa		       69 70 63 63	      .byte.b	"ipcc"
      0  0dae					      db	"ipcS"
      1  0dae		       69 70 63 53	      .byte.b	"ipcS"
      0  0db2					      db	"ipcR"
      1  0db2		       69 70 63 52	      .byte.b	"ipcR"
      0  0db6					      db	"rnD"
      1  0db6		       72 6e 44 	      .byte.b	"rnD"
      0  0db9					      db	"staT"
      1  0db9		       73 74 61 54	      .byte.b	"staT"
      0  0dbd					      db	"abS"
      1  0dbd		       61 62 53 	      .byte.b	"abS"
      0  0dc0					      db	"calL"
      1  0dc0		       63 61 6c 4c	      .byte.b	"calL"
      0  0dc4					      db	"gofN"
      1  0dc4		       67 6f 66 4e	      .byte.b	"gofN"
      0  0dc8					      db	0,0
      1  0dc8		       00 00		      .byte.b	0,0
     79  0dc8		       0d ca	   KeyWordTableEnd equ	*
     80  0dc8		       00 c1	   KeyWordTableLength equ	* - KeyWordTable
     81  0dca		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
     82  0eca		       00 00 00    printStorage ds	3
     83  0ecd							;==================================================================================================================
     84  0ecd							; Read accross the inputline and output to TOKENBUFFER
     85  0ecd							; Format   byte      Description
     86  0ecd							;	     0	      length of line 1-255
     87  0ecd							;	    0-1       Line Number
     88  0ecd							;	    Tokens and litteral values encoded into the line
     89  0ecd							;
     90  0ecd							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
     91  0ecd							;  if fails then test for keywords
     92  0ecd							;  if fails then test for variables and arrays
     93  0ecd							;  if fails check for operators + - < > = % / * ()
     94  0ecd				   ParseInputLine
     95  0ecd					      if	DEBUGPARSER
     96  0ecd		       20 76 1c 	      jsr	SetOutDebug
     97  0ed0		       20 8e 10 	      jsr	DebugClearBuffer
     98  0ed3					      endif
     99  0ed3		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    100  0ed5		       20 19 18 	      jsr	getDecimal	; Check for a line number, none is ok too
    101  0ed8		       84 51		      sty	CUROFF
    102  0eda		       20 d7 10 	      jsr	R02TOKEN	; Move R0 to token buffer
    103  0edd
    104  0edd				   ParseInputLoop
    105  0edd		       a4 51		      ldy	CUROFF
    106  0edf		       20 9b 1a 	      jsr	SkipSpaces	; Skip any spaces
    107  0ee2		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    108  0ee4		       b9 9a 2b 	      lda	LINBUF,y	; Check for end of line
    109  0ee7		       f0 2d		      beq	ParseComplete	; Finish token buffer and return
    110  0ee9
    111  0ee9				   ParseForString
    112  0ee9		       20 8a 0f 	      jsr	ParseString	; Check for a string
    113  0eec		       90 ef		      bcc	ParseInputLoop	; It was a string
    114  0eee
    115  0eee				   ParseForKey
    116  0eee		       20 25 0f 	      jsr	ParseLookupKey	; Check for a keyword value
    117  0ef1		       b0 02		      bcs	ParseForNumber	; Go look for a number
    118  0ef3		       90 e8		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    119  0ef5
    120  0ef5				   ParseForNumber
    121  0ef5		       20 b4 0f 	      jsr	ParseNumeric	; Check for a numeric value
    122  0ef8		       b0 02		      bcs	ParseForOp	; Check for some form of operator
    123  0efa		       90 e1		      bcc	ParseInputLoop	; Go Back for next element
    124  0efc
    125  0efc				   ParseForOp
    126  0efc		       20 25 10 	      jsr	ParseForOperator
    127  0eff		       b0 02		      bcs	ParseForVar	; Check for variables
    128  0f01		       d0 da		      bne	ParseInputLoop
    129  0f03
    130  0f03				   ParseForVar
    131  0f03		       20 a0 10 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    132  0f06		       b0 02		      bcs	ParseKeepChar	; If we can match nothing then error get output
    133  0f08		       90 d3		      bcc	ParseInputLoop
    134  0f0a
    135  0f0a				   ParseKeepChar		; if it does not parse just keep it safe
    136  0f0a		       b9 9a 2b 	      lda	LINBUF,y
    137  0f0d		       9d ca 0d 	      sta	TOKENBUFFER,x
    138  0f10		       e8		      inx
    139  0f11		       c8		      iny
    140  0f12		       84 51		      sty	CUROFF
    141  0f14		       d0 c7		      bne	ParseInputLoop
    142  0f16
    143  0f16				   ParseComplete
    144  0f16		       8e ca 0d 	      stx	TOKENBUFFER	; Place size into buffer start
    145  0f19		       a9 00		      lda	#0
    146  0f1b		       9d ca 0d 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    147  0f1e					      if	DEBUGPARSER
    148  0f1e		       20 f4 10 	      jsr	PrintProgramLine
    149  0f21		       20 d3 1b 	      jsr	SetOutConsole
    150  0f24					      endif
    151  0f24		       60		      rts
    152  0f25
    153  0f25							;==================================================================================================================
    154  0f25							; Look at curptr, curpos and check for a valid KeyWord
    155  0f25							; A contains the index value. c is clear
    156  0f25							;		     not found c set  A undefined
    157  0f25							; X is prerserved
    158  0f25							;
    159  0f25				   ParseLookupKey
    160  0f25		       86 58		      stx	R2
    161  0f27		       a4 51		      ldy	CUROFF
    162  0f29		       a2 00		      ldx	#0
    163  0f2b		       a9 01		      lda	#1
    164  0f2d		       85 52		      sta	R0	; at the end this will contain the index of the keyword
    165  0f2f					      if	DEBUGPARSER
    166  0f2f		       20 63 10 	      jsr	DebugKeyword
    167  0f32					      endif
    168  0f32		       a9 3f		      lda	#'?	; check for fast form of print
    169  0f34		       d9 9a 2b 	      cmp	LINBUF,y
    170  0f37		       d0 04		      bne	ParseLookupLoop	; Skip to loop if not ?
    171  0f39		       a9 0b		      lda	#kPrint	; Number for print
    172  0f3b		       d0 25		      bne	ParseKeySpecial	; Get out with the special case
    173  0f3d
    174  0f3d				   ParseLookupLoop
    175  0f3d		       bd 09 0d 	      lda	KeyWordTable,x	; Check both upper and lower characters
    176  0f40		       29 df		      and	#%11011111	; Force Keyword to upper case
    177  0f42		       d9 9a 2b 	      cmp	LINBUF,y
    178  0f45		       f0 07		      beq	ParseNextLetter
    179  0f47		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    180  0f49		       d9 9a 2b 	      cmp	LINBUF,y
    181  0f4c		       d0 1f		      bne	ParseNextEntry
    182  0f4e
    183  0f4e				   ParseNextLetter
    184  0f4e		       bd 09 0d 	      lda	KeyWordTable,x	; Check if we just processed the last letter
    185  0f51		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    186  0f53		       f0 0b		      beq	ParseKeyFound
    187  0f55		       e8		      inx
    188  0f56		       c8		      iny
    189  0f57		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    190  0f59		       d9 9a 2b 	      cmp	LINBUF,y
    191  0f5c		       f0 0f		      beq	ParseNextEntry	; End of buffer but no keyword
    192  0f5e		       d0 dd		      bne	ParseLookupLoop
    193  0f60
    194  0f60				   ParseKeyFound
    195  0f60		       a5 52		      lda	R0
    196  0f62
    197  0f62				   ParseKeySpecial
    198  0f62		       c8		      iny		;point past the last character
    199  0f63		       84 51		      sty	CUROFF
    200  0f65		       a6 58		      ldx	R2	; preserved the X pointer
    201  0f67		       9d ca 0d 	      sta	TOKENBUFFER,x
    202  0f6a		       e8		      inx
    203  0f6b		       18		      clc
    204  0f6c		       60		      rts
    205  0f6d
    206  0f6d							; Move forward to the next entry in table
    207  0f6d				   ParseNextEntry
    208  0f6d		       bd 09 0d 	      lda	KeyWordTable,x
    209  0f70		       29 20		      and	#%00100000
    210  0f72		       f0 03		      beq	ParseEndOfEntry
    211  0f74		       e8		      inx
    212  0f75		       d0 f6		      bne	ParseNextEntry
    213  0f77
    214  0f77				   ParseEndOfEntry
    215  0f77		       e8		      inx
    216  0f78					      if	DEBUGPARSER
    217  0f78		       20 63 10 	      jsr	DebugKeyword
    218  0f7b					      endif
    219  0f7b		       e6 52		      inc	R0	; Point to next index
    220  0f7d		       a4 51		      ldy	CUROFF	; Restore Y to start of the parse
    221  0f7f		       bd 09 0d 	      lda	KeyWordTable,x
    222  0f82		       f0 02		      beq	ParseNoneFound
    223  0f84		       d0 b7		      bne	ParseLookupLoop
    224  0f86
    225  0f86				   ParseNoneFound
    226  0f86		       a6 58		      ldx	R2
    227  0f88		       38		      sec
    228  0f89		       60		      rts
    229  0f8a
    230  0f8a							;=========================================================================================================
    231  0f8a							;ParseString Parse a quotes string
    232  0f8a							; on input X = outbuf position
    233  0f8a							; y = inbuf position
    234  0f8a							; Copies string to output buffer, updates x and y
    235  0f8a				   ParseString
    236  0f8a		       a4 51		      ldy	CUROFF
    237  0f8c		       a9 a1		      lda	#tString
    238  0f8e		       9d ca 0d 	      sta	TOKENBUFFER,X
    239  0f91		       b9 9a 2b 	      lda	LINBUF,y
    240  0f94		       c9 22		      cmp	#'"
    241  0f96		       d0 1a		      bne	ParseStringInvalid
    242  0f98		       e8		      inx
    243  0f99		       9d ca 0d 	      sta	TOKENBUFFER,x
    244  0f9c		       e8		      inx
    245  0f9d		       c8		      iny
    246  0f9e
    247  0f9e				   ParseStringLoop
    248  0f9e		       b9 9a 2b 	      lda	LINBUF,y
    249  0fa1		       9d ca 0d 	      sta	TOKENBUFFER,x
    250  0fa4		       c9 22		      cmp	#'"
    251  0fa6		       f0 04		      beq	ParseStringDone
    252  0fa8		       c8		      iny
    253  0fa9		       e8		      inx
    254  0faa		       d0 f2		      bne	ParseStringLoop
    255  0fac
    256  0fac				   ParseStringDone
    257  0fac		       e8		      inx
    258  0fad		       c8		      iny
    259  0fae		       84 51		      sty	CUROFF
    260  0fb0		       18		      clc
    261  0fb1		       60		      rts
    262  0fb2
    263  0fb2				   ParseStringInvalid
    264  0fb2		       38		      sec
    265  0fb3		       60		      rts
    266  0fb4
    267  0fb4							;=========================================================================================================
    268  0fb4							; Get numeric values and return value in RO and type in a
    269  0fb4							;
    270  0fb4				   ParseNumeric
    271  0fb4		       a4 51		      ldy	CUROFF
    272  0fb6		       b9 9a 2b 	      lda	LINBUF,y
    273  0fb9		       c9 30		      cmp	#'0
    274  0fbb		       90 33		      bcc	ParseNumInvalid
    275  0fbd		       c9 3a		      cmp	#'9+1
    276  0fbf		       b0 2f		      bcs	ParseNumInvalid
    277  0fc1		       86 58		      stx	R2
    278  0fc3		       20 19 18 	      jsr	getDecimal
    279  0fc6		       a6 58		      ldx	R2
    280  0fc8		       84 51		      sty	CUROFF
    281  0fca		       a5 53		      lda	R0+1
    282  0fcc		       f0 14		      beq	ParseByteValue
    283  0fce
    284  0fce				   ParseIntegerValue
    285  0fce		       a9 a0		      lda	#tInteger
    286  0fd0		       9d ca 0d 	      sta	TOKENBUFFER,x
    287  0fd3		       e8		      inx
    288  0fd4		       a5 52		      lda	R0
    289  0fd6		       9d ca 0d 	      sta	TOKENBUFFER,x
    290  0fd9		       e8		      inx
    291  0fda		       a5 53		      lda	R0+1
    292  0fdc		       9d ca 0d 	      sta	TOKENBUFFER,X
    293  0fdf		       e8		      inx
    294  0fe0		       18		      clc
    295  0fe1		       60		      rts
    296  0fe2
    297  0fe2				   ParseByteValue
    298  0fe2		       a9 a2		      lda	#tByte
    299  0fe4		       9d ca 0d 	      sta	TOKENBUFFER,x
    300  0fe7		       e8		      inx
    301  0fe8		       a5 52		      lda	R0
    302  0fea		       9d ca 0d 	      sta	TOKENBUFFER,x
    303  0fed		       e8		      inx
    304  0fee		       18		      clc
    305  0fef		       60		      rts
    306  0ff0
    307  0ff0				   ParseNumInvalid		;Not a valid Numeric
    308  0ff0		       38		      sec
    309  0ff1		       60		      rts
    310  0ff2
    311  0ff2							;=========================================================================================================
    312  0ff2							;Parse for operators
    313  0ff2							; +($F0), <($F1),=($F2),<=($F3), >($F4), <>($F5), >=($F6), -($F7), /($F8), %($F9), *($FA), (($FB), )($FC)
    314  0ff2							; on exit the A has the oper code, c is clear
    315  0ff2							;		 not found then c is set
    316  0ff2							;	x is preserved
    317  0ff2							;
    318  0ff2		       3c 3e 3c 3d*Operators  BYTE.b	"<>","<=",">=",'+,0,'<,0,'=,0,">",0,"-",0,"/",0,"%",0,"*",0,"(",0,")",0,",",0,";",0,"[",0,"]",0
    319  0ff2		       00 22	   OperatorLen equ	*-Operators
    320  1014
    321  1014		       f5 f3 f6 f0*OperValues BYTE.b	$F5,$F3,$F6,$F0,$F1,$F2,$F4,$F7,$F8,$F9,$FA,$E0,$E1,$E2,$E3,$E4,$E5
    322  1014		       00 11	   OPCount    equ	* - OperValues
    323  1025
    324  1025				   ParseForOperator
    325  1025		       86 58		      stx	R2
    326  1027		       a4 51		      ldy	CUROFF
    327  1029		       a6 00		      ldx	0
    328  102b					      if	DEBUGPARSER
    329  102b		       20 7a 10 	      jsr	DebugPrintOP
    330  102e					      endif
    331  102e				   ParseOpLoop
    332  102e		       bd f2 0f 	      lda	Operators,x
    333  1031		       d9 9a 2b 	      cmp	LINBUF,y
    334  1034		       d0 1c		      bne	ParseOpNext
    335  1036		       c8		      iny
    336  1037		       bd f3 0f 	      lda	Operators+1,x
    337  103a		       f0 06		      beq	ParseOpFoundSingle
    338  103c		       d9 9a 2b 	      cmp	LINBUF,y
    339  103f		       d0 11		      bne	ParseOpNext
    340  1041
    341  1041				   ParseOpFound
    342  1041		       c8		      iny
    343  1042
    344  1042				   ParseOpFoundSingle
    345  1042		       84 51		      sty	CUROFF
    346  1044
    347  1044		       8a		      txa
    348  1045		       4a		      lsr
    349  1046		       aa		      tax
    350  1047		       bd 14 10 	      lda	OperValues,x
    351  104a		       a6 58		      ldx	R2
    352  104c		       9d ca 0d 	      sta	TOKENBUFFER,x
    353  104f		       e8		      inx
    354  1050		       18		      clc
    355  1051		       60		      rts
    356  1052
    357  1052				   ParseOpNext
    358  1052		       e8		      inx
    359  1053		       e8		      inx
    360  1054		       e0 22		      cpx	#OperatorLen
    361  1056		       b0 07		      bcs	ParseOpNotFound
    362  1058					      if	DEBUGPARSER
    363  1058		       20 7a 10 	      jsr	DebugPrintOP
    364  105b					      endif
    365  105b		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    366  105d		       d0 cf		      bne	ParseOpLoop
    367  105f
    368  105f				   ParseOpNotFound
    369  105f		       a6 58		      ldx	R2
    370  1061		       38		      sec
    371  1062		       60		      rts
    372  1063							;=========================================================================================================
    373  1063					      if	DEBUGPARSER
    374  1063							;Print the text of a keyword
    375  1063							;Input x = offset into table
    376  1063				   DebugKeyword
    377  1063		       48		      pha
    378  1064		       8a		      txa
    379  1065		       48		      pha
    380  1066				   DebugKeyLoop
    381  1066		       bd 09 0d 	      lda	KeyWordTable,x
    382  1069		       20 ed 1b 	      jsr	VOUTCH
    383  106c		       29 20		      and	#%00100000
    384  106e		       f0 03		      beq	DebugKeyDone
    385  1070		       e8		      inx
    386  1071		       d0 f3		      bne	DebugKeyLoop
    387  1073
    388  1073				   DebugKeyDone
    389  1073		       20 a4 1a 	      jsr	CRLF
    390  1076		       68		      pla
    391  1077		       aa		      tax
    392  1078		       68		      pla
    393  1079		       60		      rts
    394  107a							;========================================
    395  107a				   DebugPrintOP
    396  107a		       48		      pha
    397  107b		       bd f2 0f 	      lda	Operators,x
    398  107e		       20 ed 1b 	      jsr	VOUTCH
    399  1081		       bd f3 0f 	      lda	Operators+1,x
    400  1084		       f0 03		      beq	DbgPrtOpDone
    401  1086		       20 ed 1b 	      jsr	VOUTCH
    402  1089
    403  1089				   DbgPrtOpDone
    404  1089		       20 a4 1a 	      jsr	CRLF
    405  108c		       68		      pla
    406  108d		       60		      rts
    407  108e							;=======================================
    408  108e				   DebugClearBuffer
    409  108e		       8a		      txa
    410  108f		       48		      pha
    411  1090		       a2 ff		      ldx	#$FF
    412  1092		       a9 00		      lda	#0
    413  1094				   DebugClrLoop
    414  1094		       9d ca 0d 	      sta	TOKENBUFFER,x
    415  1097		       ca		      dex
    416  1098		       d0 fa		      bne	DebugClrLoop
    417  109a		       9d ca 0d 	      sta	TOKENBUFFER,x
    418  109d		       68		      pla
    419  109e		       aa		      tax
    420  109f		       60		      rts
    421  10a0					      endif
    422  10a0
    423  10a0
    424  10a0							;=========================================================================================================
    425  10a0							; Parse for variables A-Z @, ^  x!x x[op]
    426  10a0				   ParseForVariable
    427  10a0		       a4 51		      ldy	CUROFF
    428  10a2		       b9 9a 2b 	      lda	LINBUF,y
    429  10a5		       c9 5e		      cmp	#'^	; is it an exit code
    430  10a7		       d0 04		      bne	ParseVarMem
    431  10a9		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    432  10ab		       d0 1f		      bne	ParseVarSpecial
    433  10ad
    434  10ad				   ParseVarMem
    435  10ad		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    436  10af		       d0 04		      bne	ParseVarStack
    437  10b1		       a9 9d		      lda	#tVat
    438  10b3		       d0 17		      bne	ParseVarSpecial
    439  10b5
    440  10b5				   ParseVarStack
    441  10b5		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    442  10b7		       d0 04		      bne	ParseVarLetters
    443  10b9		       a9 9c		      lda	#tVhash
    444  10bb		       d0 0f		      bne	ParseVarSpecial
    445  10bd
    446  10bd				   ParseVarLetters
    447  10bd		       29 df		      and	#%11011111	; Force upper case
    448  10bf		       c9 41		      cmp	#'A
    449  10c1		       90 12		      bcc	ParseVarInvalid
    450  10c3		       c9 5b		      cmp	#'Z+1
    451  10c5		       b0 0e		      bcs	ParseVarInvalid
    452  10c7							;
    453  10c7							; The condition is true, so convert to an index, push
    454  10c7							; it onto the stack and continue running.
    455  10c7							;
    456  10c7		       38		      sec
    457  10c8		       e9 41		      sbc	#'A	;index is zero based
    458  10ca		       09 80		      ora	#$80
    459  10cc
    460  10cc				   ParseVarSpecial
    461  10cc		       9d ca 0d 	      sta	TOKENBUFFER,x
    462  10cf		       e8		      inx
    463  10d0		       c8		      iny
    464  10d1		       84 51		      sty	CUROFF
    465  10d3		       18		      clc
    466  10d4		       60		      rts
    467  10d5
    468  10d5				   ParseVarInvalid
    469  10d5		       38		      sec
    470  10d6		       60		      rts
    471  10d7
    472  10d7
    473  10d7							;=========================================================================================================
    474  10d7							; Transfer R0 to the TOKENBUFFER
    475  10d7							;
    476  10d7				   R02TOKEN
    477  10d7		       a5 52		      lda	R0
    478  10d9		       9d ca 0d 	      sta	TOKENBUFFER,x
    479  10dc		       e8		      inx
    480  10dd		       a5 53		      lda	R0+1
    481  10df		       9d ca 0d 	      sta	TOKENBUFFER,x
    482  10e2		       e8		      inx
    483  10e3		       18		      clc
    484  10e4		       60		      rts
    485  10e5				   TOKEN2R0
    486  10e5		       b9 ca 0d 	      lda	TOKENBUFFER,y
    487  10e8		       85 52		      sta	R0
    488  10ea		       c8		      iny
    489  10eb		       ca		      dex
    490  10ec		       b9 ca 0d 	      lda	TOKENBUFFER,y
    491  10ef		       c8		      iny
    492  10f0		       ca		      dex
    493  10f1		       85 53		      sta	R0+1
    494  10f3		       60		      rts
    495  10f4
    496  10f4							;==========================================================================================================
    497  10f4							; Decode and print a line of grogram text
    498  10f4							; Prints line number from R0 upto line number in R1 if r1 is 0 then prints to end
    499  10f4							; if R0 and R1 = 0 then print entire program.
    500  10f4							;
    501  10f4				   PrintProgramLine
    502  10f4		       8e ca 0e 	      stx	printStorage
    503  10f7		       8c cb 0e 	      sty	printStorage+1
    504  10fa
    505  10fa		       a0 01		      ldy	#1	; index into the token buffer
    506  10fc		       84 58		      sty	R2	; print unsigned decimal
    507  10fe		       ae ca 0d 	      ldx	TOKENBUFFER	; get number of bytes
    508  1101		       ca		      dex		; Deduct the length byte
    509  1102		       20 e5 10 	      jsr	TOKEN2R0	; Print the line number
    510  1105		       20 e0 11 	      jsr	PrintDecimal
    511  1108		       a9 20		      lda	#$20
    512  110a		       20 ed 1b 	      jsr	VOUTCH
    513  110d
    514  110d				   PrintProgLoop
    515  110d		       b9 ca 0d 	      lda	TOKENBUFFER,y	; Get a character
    516  1110		       f0 3c		      beq	PrintProgramComplete
    517  1112		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    518  1114		       f0 44		      beq	PrintKeyword	; It uses the index in a to find a keyword
    519  1116
    520  1116				   PrintProgVars
    521  1116		       b9 ca 0d 	      lda	TOKENBUFFER,y
    522  1119		       29 e0		      and	#$E0	; Check for operators and punctuation
    523  111b		       c9 e0		      cmp	#$E0
    524  111d		       f0 6f		      beq	PrintProgOperator
    525  111f		       b9 ca 0d 	      lda	TOKENBUFFER,y
    526  1122		       c9 9e		      cmp	#$9D+1
    527  1124		       90 32		      bcc	PrintProgVariableVec
    528  1126		       c8		      iny		; we have a numerical value
    529  1127		       ca		      dex
    530  1128		       48		      pha
    531  1129		       a9 00		      lda	#0
    532  112b		       85 53		      sta	R0+1
    533  112d		       85 58		      sta	R2	; Set to print signed number
    534  112f		       b9 ca 0d 	      lda	TOKENBUFFER,y
    535  1132		       85 52		      sta	R0
    536  1134		       68		      pla
    537  1135		       c9 a0		      cmp	#tInteger
    538  1137		       d0 07		      bne	PrintProgNumDone
    539  1139		       c8		      iny
    540  113a		       ca		      dex
    541  113b		       b9 ca 0d 	      lda	TOKENBUFFER,y
    542  113e		       85 53		      sta	R0+1
    543  1140
    544  1140				   PrintProgNumDone
    545  1140		       c8		      iny
    546  1141		       ca		      dex
    547  1142		       20 e0 11 	      jsr	PrintDecimal
    548  1145
    549  1145				   PrintProgNext
    550  1145		       a9 20		      lda	#$20
    551  1147		       20 ed 1b 	      jsr	VOUTCH
    552  114a				   PrintProgSkipSpace
    553  114a		       e0 00		      cpx	#0
    554  114c		       d0 bf		      bne	PrintProgLoop
    555  114e				   PrintProgramComplete
    556  114e		       20 a4 1a 	      jsr	CRLF
    557  1151
    558  1151		       ae ca 0e 	      ldx	printStorage
    559  1154		       ac cb 0e 	      ldy	printStorage+1
    560  1157
    561  1157		       60		      rts
    562  1158
    563  1158				   PrintProgVariableVec
    564  1158		       90 5e		      bcc	PrintProgVariable
    565  115a							;===============================================================================================================
    566  115a				   PrintKeyword
    567  115a		       60		      rts
    568  115b		       b9 ca 0d 	      lda	TOKENBUFFER,y
    569  115e		       ca		      dex
    570  115f		       c8		      iny
    571  1160		       85 52		      sta	R0	; the counter save area
    572  1162		       8e cc 0e 	      stx	printStorage+2
    573  1165		       a2 00		      ldx	#0
    574  1167				   PrintKeyLoop
    575  1167		       c6 52		      dec	R0	; Keyword indexes are 1 relative, adjust to zero relative
    576  1169		       a9 00		      lda	#0
    577  116b		       c5 52		      cmp	R0
    578  116d		       f0 0a		      Beq	PrintKeyFound	; We have the correct index, now print it
    579  116f				   PrintKeyNext
    580  116f		       bd 09 0d 	      lda	KeyWordTable,x
    581  1172		       e8		      inx		; Point to next byte always
    582  1173		       29 20		      and	#%00100000
    583  1175		       f0 f0		      beq	PrintKeyLoop
    584  1177		       d0 f6		      bne	PrintKeyNext
    585  1179
    586  1179				   PrintKeyFound
    587  1179		       bd 09 0d 	      lda	KeyWordTable,x
    588  117c		       48		      pha
    589  117d		       09 20		      ora	#%00100000
    590  117f		       20 ed 1b 	      jsr	VOUTCH
    591  1182		       e8		      inx
    592  1183		       68		      pla
    593  1184		       29 20		      and	#%00100000
    594  1186		       d0 f1		      bne	PrintKeyFound
    595  1188
    596  1188		       ae cc 0e 	      ldx	printStorage+2
    597  118b		       4c 45 11 	      jmp	PrintProgNext
    598  118e							;==================================================================================================================
    599  118e							;Print Variable, number or operator
    600  118e				   PrintProgOperator
    601  118e		       b9 ca 0d 	      lda	TOKENBUFFER,y
    602  1191		       c8		      iny
    603  1192		       ca		      dex
    604  1193		       8e cc 0e 	      stx	printStorage+2
    605  1196		       a2 00		      ldx	#0
    606  1198				   PrintOprLoop
    607  1198		       dd 14 10 	      cmp	OperValues,x
    608  119b		       f0 03		      beq	PrintOprFound
    609  119d		       e8		      inx
    610  119e		       d0 f8		      bne	PrintOprLoop
    611  11a0				   PrintOprFound
    612  11a0		       8a		      txa
    613  11a1		       0a		      asl
    614  11a2		       aa		      tax
    615  11a3		       bd f2 0f 	      lda	Operators,x
    616  11a6		       20 ed 1b 	      jsr	VOUTCH
    617  11a9		       e8		      inx
    618  11aa		       bd f2 0f 	      lda	Operators,x
    619  11ad		       f0 03		      beq	PrintOprDone
    620  11af		       20 ed 1b 	      jsr	VOUTCH
    621  11b2				   PrintOprDone
    622  11b2		       ae cc 0e 	      ldx	printStorage+2
    623  11b5		       4c 45 11 	      jmp	PrintProgNext
    624  11b8
    625  11b8							;=================================================================================================================
    626  11b8							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    627  11b8							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    628  11b8							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    629  11b8							;tVhat 	    equ     155 		   ; Variable ^
    630  11b8							;tVhash	    equ     156 		   ; Variable #
    631  11b8							;tVat		    equ     157 		   ; Variable @ = 0
    632  11b8				   PrintProgVariable
    633  11b8		       b9 ca 0d 	      lda	TOKENBUFFER,y
    634  11bb		       c8		      iny
    635  11bc		       ca		      dex
    636  11bd		       c5 9b		      cmp	tVhat
    637  11bf		       d0 04		      bne	PrintProgChkHash
    638  11c1		       a9 5e		      lda	#'^
    639  11c3		       d0 15		      bne	PrintTheVar
    640  11c5				   PrintProgChkHash
    641  11c5		       c5 9c		      cmp	tVhash
    642  11c7		       d0 04		      bne	PrintProgChkAt
    643  11c9		       a9 23		      lda	#'#
    644  11cb		       d0 0d		      bne	PrintTheVar
    645  11cd				   PrintProgChkAt
    646  11cd		       c5 9d		      cmp	tVat
    647  11cf		       d0 04		      bne	PrintProgVarLetter
    648  11d1		       a9 40		      lda	#'@
    649  11d3		       d0 05		      bne	PrintTheVar
    650  11d5				   PrintProgVarLetter
    651  11d5		       29 7f		      and	#%01111111
    652  11d7		       18		      clc
    653  11d8		       69 41		      adc	#'A
    654  11da				   PrintTheVar
    655  11da		       20 ed 1b 	      jsr	VOUTCH
    656  11dd		       4c 45 11 	      jmp	PrintProgNext
    657  11e0
    658  11e0
    659  11e0
    660  11e0
    661  11e0
    662  11e0
    663  11e0
    664  11e0
    665  11e0
    666  11e0
    667  11e0
    668  11e0
    669  11e0
    670  11e0
    671  11e0
    672  11e0
    673  11e0
    674  11e0
    675  11e0
    676  11e0
    677  11e0
    678  11e0
    679  11e0
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  11e0					      include	"print.asm"
      1  11e0					      Seg	Code
      2  11e0							;---------------------------
      3  11e0							; Print 24-bit decimal number or  16bit unsigned
      4  11e0							; ---------------------------
      5  11e0							; On entry, R0=number to print
      6  11e0							;	     Defaults to pad=0 , y=21 default
      7  11e0							;	     R2 = 1 unsigned 16 bit
      8  11e0							;	     R2 = 0 Signed   16 bit
      9  11e0
     10  11e0							; On entry at PrintDecPadded:
     11  11e0							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  11e0
     13  11e0							; On exit,  A,X,Y,num,pad corrupted
     14  11e0							; Size      129 bytes, Table 24 bytes	--- total 153
     15  11e0							; -----------------------------------------------------------------
     16  11e0
     17  11e0				   PrintDecimal
     18  11e0		       8a		      TXA
     19  11e1		       48		      pha
     20  11e2		       98		      tya
     21  11e3		       48		      pha
     22  11e4		       a9 00		      lda	#0
     23  11e6		       8d 79 12 	      sta	pad
     24  11e9		       a0 15		      LDY	#21	; Offset to powers of ten
     25  11eb		       4c f1 11 	      JMP	PrintDo
     26  11ee
     27  11ee				   PrintDecPadded
     28  11ee		       8e 79 12 	      stx	pad
     29  11f1
     30  11f1				   PrintDo
     31  11f1		       a9 00		      lda	#0
     32  11f3		       85 54		      sta	R1
     33  11f5
     34  11f5		       a5 58		      lda	R2
     35  11f7		       d0 29		      bne	PrintPos
     36  11f9
     37  11f9		       a5 53		      lda	R0+1	;MSB has sign
     38  11fb		       10 25		      bpl	PrintPos	;it's a positive number;
     39  11fd
     40  11fd
     41  11fd							; Negative numbers need more work.  Invert all the bits,
     42  11fd							; then add one.
     43  11fd
     44  11fd		       a9 2d		      lda	#'-
     45  11ff		       20 ed 1b 	      jsr	VOUTCH	;print the negative sign
     46  1202
     47  1202		       a9 ff		      lda	#$FF
     48  1204		       85 54		      sta	R1
     49  1206		       a5 52		      lda	R0	;invert bits
     50  1208		       49 ff		      eor	#$ff
     51  120a		       85 52		      sta	R0
     52  120c		       a5 53		      lda	R0+1
     53  120e		       49 ff		      eor	#$ff
     54  1210		       85 53		      sta	R0+1
     55  1212		       a5 54		      lda	R1
     56  1214		       49 ff		      eor	#$ff
     57  1216		       85 54		      sta	R1
     58  1218		       e6 52		      inc	R0	;add one
     59  121a		       d0 06		      bne	PrintPos
     60  121c		       e6 53		      inc	R0+1
     61  121e		       d0 02		      bne	PrintPos
     62  1220		       e6 54		      inc	R1
     63  1222				   PrintPos
     64  1222
     65  1222				   PrDec24Lp1
     66  1222		       a2 ff		      LDX	#$FF
     67  1224		       38		      SEC		; Start with digit=-1
     68  1225				   PrDec24Lp2
     69  1225		       a5 52		      LDA	R0+0
     70  1227		       f9 7a 12 	      SBC	PrDec24Tens+0,Y
     71  122a		       85 52		      STA	R0+0	; Subtract current tens
     72  122c		       a5 53		      LDA	R0+1
     73  122e		       f9 7b 12 	      SBC	PrDec24Tens+1,Y
     74  1231		       85 53		      STA	R0+1
     75  1233		       a5 54		      LDA	R0+2
     76  1235		       f9 7c 12 	      SBC	PrDec24Tens+2,Y
     77  1238		       85 54		      STA	R0+2
     78  123a		       e8		      INX
     79  123b		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  123d		       a5 52		      LDA	R0+0
     81  123f		       79 7a 12 	      ADC	PrDec24Tens+0,Y
     82  1242		       85 52		      STA	R0+0	; Add current tens back in
     83  1244		       a5 53		      LDA	R0+1
     84  1246		       79 7b 12 	      ADC	PrDec24Tens+1,Y
     85  1249		       85 53		      STA	R0+1
     86  124b		       a5 54		      LDA	R0+2
     87  124d		       79 7c 12 	      ADC	PrDec24Tens+2,Y
     88  1250		       85 54		      STA	R0+2
     89  1252		       8a		      TXA
     90  1253		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  1255		       ad 79 12 	      LDA	pad
     92  1258		       d0 09		      BNE	PrDec24Print
     93  125a		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  125c				   PrDec24Digit
     95  125c		       a2 30		      LDX	#'0
     96  125e		       8e 79 12 	      STX	pad	; No more zero padding
     97  1261		       09 30		      ORA	#'0	; Print this digit
     98  1263				   PrDec24Print
     99  1263		       20 ed 1b 	      JSR	VOUTCH
    100  1266				   PrDec24Next
    101  1266		       88		      DEY
    102  1267		       88		      DEY
    103  1268		       88		      DEY
    104  1269		       f0 07		      beq	PrDec24LastDigit
    105  126b		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  126d		       68		      pla
    107  126e		       a8		      tay
    108  126f		       68		      pla
    109  1270		       aa		      tax
    110  1271		       60		      RTS
    111  1272				   PrDec24LastDigit
    112  1272		       a2 30		      LDX	#'0
    113  1274		       8e 79 12 	      STX	pad	; No more zero padding
    114  1277		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  1279
      0  1279				   pad	      db	0
      1  1279		       00		      .byte.b	0
    117  127a				   PrDec24Tens
      0  127a					      dw	1
      1  127a		       01 00		      .word.w	1
      0  127c					      db	1 / 65536
      1  127c		       00		      .byte.b	1 / 65536
      0  127d					      dw	10
      1  127d		       0a 00		      .word.w	10
      0  127f					      db	10 / 65536
      1  127f		       00		      .byte.b	10 / 65536
      0  1280					      dw	100
      1  1280		       64 00		      .word.w	100
      0  1282					      db	100 / 65536
      1  1282		       00		      .byte.b	100 / 65536
      0  1283					      dw	1000
      1  1283		       e8 03		      .word.w	1000
      0  1285					      db	1000 / 65536
      1  1285		       00		      .byte.b	1000 / 65536
      0  1286					      dw	10000
      1  1286		       10 27		      .word.w	10000
      0  1288					      db	10000 / 65536
      1  1288		       00		      .byte.b	10000 / 65536
      0  1289					      dw	100000
      1  1289		       a0 86		      .word.w	100000
      0  128b					      db	100000 / 65536
      1  128b		       01		      .byte.b	100000 / 65536
      0  128c					      dw	1000000
      1  128c		       40 42		      .word.w	1000000
      0  128e					      db	1000000 / 65536
      1  128e		       0f		      .byte.b	1000000 / 65536
      0  128f					      dw	10000000
      1  128f		       80 96		      .word.w	10000000
      0  1291					      db	10000000 / 65536
      1  1291		       98		      .byte.b	10000000 / 65536
    134  1292							;=====================================================
    135  1292							; Print character in A as two hex digits to the
    136  1292
    137  1292
    138  1292		       48	   HexToOut   pha		;save return value
    139  1293		       48		      pha
    140  1294		       4a		      lsr		;a  ;move top nibble to bottom
    141  1295		       4a		      lsr		;a
    142  1296		       4a		      lsr		;a
    143  1297		       4a		      lsr		;a
    144  1298		       20 a1 12 	      jsr	hexta	;output nibble
    145  129b		       68		      pla
    146  129c		       20 a1 12 	      jsr	hexta
    147  129f		       68		      pla		;restore
    148  12a0		       60		      rts
    149  12a1							;
    150  12a1		       29 0f	   hexta      and	#%0001111
    151  12a3		       c9 0a		      cmp	#$0a
    152  12a5		       18		      clc
    153  12a6		       30 02		      bmi	hexta1
    154  12a8		       69 07		      adc	#7
    155  12aa		       69 30	   hexta1     adc	#'0	;then fall into...
    156  12ac		       4c ed 1b 	      jmp	VOUTCH
    157  12af							;
    158  12af							;==================================================================================================
    159  12af							; Size of print functions
    160  12af		       00 cf	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  12af					      include	"mem.asm"
      1  12af							;===================================================================
      2  12af							;This file contains the memory allocation and free functions
      3  12af							;in herant in this is the management of free memory in the system
      4  12af							; the interface to these functions
      5  12af							; a,x returns or provides the low hi bytes of the managed addresses
      6  12af							; This uses the programend, to memory end as the area to manage
      7  12af							;===================================================================
      8  12af					      Seg	Code
      9  12af							;=====================================================
     10  12af							;Pointers for memory Management
     11  12af							;Allocated block are not chained but can be followed for all memory by the associated length
     12  12af							; Mem block format is
     13  12af							;	 0-1   pointer to next block for free blocks
     14  12af							;	 0-1   for allocated blocks
     15  12af							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     16  12af							;	   1   refrence counter ... lol only up to 256 but it is something
     17  12af							;	 2-3   length constant for exevy type of memory block
     18  12af							; Memory is recombined as it is released
     19  12af							; The memory manager is not interupted durring allocation
     20  12af							; or freeing of memory
     21  12af							; Memory is allocated from the highest memory address towards
     22  12af							; the lowest memory address. meeting the Basic program end.
     23  12af							;====================================================
     24  12af							;MemFreeList		 ds	  2		    ; list of free blocks of memory, points to first block
     25  12af							;MemR0 		 ds	  2		    ; source for copy/move/Init
     26  12af							;MemR1 		 ds	  2		    ; Destination for copy/move
     27  12af							;=====================================================
     28  12af				   MemInit
     29  12af		       a9 41		      lda	#FreeMemStart&$FF
     30  12b1		       8d 37 2c 	      sta	ProgramStart
     31  12b4		       8d 39 2c 	      sta	ProgramEnd
     32  12b7		       a9 2c		      lda	#FreeMemStart>>8
     33  12b9		       8d 38 2c 	      sta	ProgramStart+1
     34  12bc		       8d 3a 2c 	      sta	ProgramEnd+1
     35  12bf
     36  12bf		       20 c9 12 	      jsr	GetSizes
     37  12c2		       20 d4 12 	      jsr	MemFree
     38  12c5		       20 ec 12 	      jsr	MemUsed
     39  12c8				   MemInitEnd
     40  12c8		       60		      rts
     41  12c9
     42  12c9
     43  12c9							;
     44  12c9							;=====================================================
     45  12c9							; This function might go away eventually, but was
     46  12c9							; added to provide data for other pieces of code.
     47  12c9							; It has some ties to the operating environment that
     48  12c9							; will need to be customized for the target system.
     49  12c9							;
     50  12c9				   GetSizes
     51  12c9							;
     52  12c9							; Here is machine specific code to get the highest
     53  12c9							; memory location that can be used by BASIC.
     54  12c9							;
     55  12c9				  -	      if	ProgramStart < $2000
     56  12c9				  -	      lda	#$ff
     57  12c9				  -	      sta	HighMem	;$13ff for KIM-1
     58  12c9				  -	      sta	MemFreeList
     59  12c9				  -	      lda	#$DE	;#$13
     60  12c9				  -	      sta	HighMem+1
     61  12c9				  -	      sta	MemFreeList+1
     62  12c9					      else
     63  12c9		       a9 ff		      lda	#$ff
     64  12cb		       8d 3b 2c 	      sta	HighMem	;$CFFF otherwise
     65  12ce		       a9 cf		      lda	#$cf
     66  12d0		       8d 3c 2c 	      sta	HighMem+1
     67  12d3					      endif
     68  12d3		       60		      rts
     69  12d4							;
     70  12d4							; This computes the available memory remaining.
     71  12d4							;
     72  12d4				   MemFree
     73  12d4		       38		      sec
     74  12d5		       ad 3b 2c 	      lda	HighMem
     75  12d8		       ed 39 2c 	      sbc	ProgramEnd
     76  12db		       8d 3f 2c 	      sta	FreeMem
     77  12de		       85 52		      sta	R0
     78  12e0		       ad 3c 2c 	      lda	HighMem+1
     79  12e3		       ed 3a 2c 	      sbc	ProgramEnd+1
     80  12e6		       8d 40 2c 	      sta	FreeMem+1
     81  12e9		       85 53		      sta	R0+1
     82  12eb		       60		      rts
     83  12ec							;
     84  12ec							; This computes the size of the current user program.
     85  12ec							;
     86  12ec				   MemUsed
     87  12ec		       38		      sec
     88  12ed		       ad 39 2c 	      lda	ProgramEnd
     89  12f0		       ed 37 2c 	      sbc	ProgramStart
     90  12f3		       8d 3d 2c 	      sta	UsedMem
     91  12f6		       85 52		      sta	R0
     92  12f8		       ad 3a 2c 	      lda	ProgramEnd+1
     93  12fb		       ed 38 2c 	      sbc	ProgramStart+1
     94  12fe		       8d 3e 2c 	      sta	UsedMem+1
     95  1301		       85 53		      sta	R0+1
     96  1303							;
     97  1303		       60		      rts
     98  1304
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  1304					      include	"gosub.asm"
      1  1304					      seg	Code
      2  1304
      3  1304							; Gosub and return related functions
      4  1304							;==========================================================
      5  1304							; Push the current math stack frame onto the gosub stack
      6  1304				   iPushMathStack
      7  1304		       98		      tya
      8  1305		       48		      pha
      9  1306		       a4 4d		      ldy	GOSUBSTACKPTR
     10  1308		       a5 4a		      lda	MATHSTACKPTR
     11  130a		       91 4b		      sta	(GOSUBSTACK),y
     12  130c		       a9 00		      lda	#0
     13  130e		       c8		      iny
     14  130f		       91 4b		      sta	(GOSUBSTACK),y
     15  1311		       c8		      iny
     16  1312		       91 4b		      sta	(GOSUBSTACK),y
     17  1314		       c8		      iny
     18  1315		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  1317		       91 4b		      sta	(GOSUBSTACK),y
     20  1319		       c8		      iny
     21  131a		       84 4d		      sty	GOSUBSTACKPTR
     22  131c		       68		      pla
     23  131d		       a8		      tay
     24  131e		       4c bb 02 	      jmp	NextIL
     25  1321							;
     26  1321							;==========================================================
     27  1321							; Increment parameter count. Assume Stack frame is top of stack
     28  1321				   iIncParmCount
     29  1321		       98		      tya
     30  1322		       48		      pha
     31  1323		       a4 4d		      ldy	GOSUBSTACKPTR
     32  1325		       88		      dey
     33  1326		       88		      dey
     34  1327		       88		      dey
     35  1328		       b1 4b		      lda	(GOSUBSTACK),y
     36  132a		       aa		      tax
     37  132b		       e8		      inx
     38  132c		       8a		      txa
     39  132d		       91 4b		      sta	(GOSUBSTACK),y
     40  132f		       68		      pla
     41  1330		       a8		      tay
     42  1331		       4c bb 02 	      jmp	NextIL
     43  1334							;
     44  1334							;==========================================================
     45  1334							;Restore the math stack frame
     46  1334		       20 3a 13    iPopMathStack jsr	PopMathStackNow
     47  1337		       4c bb 02 	      jmp	NextIL
     48  133a
     49  133a				   PopMathStackNow
     50  133a		       98		      tya
     51  133b		       48		      pha
     52  133c
     53  133c		       a4 4d		      ldy	GOSUBSTACKPTR
     54  133e		       88		      dey
     55  133f		       b1 4b		      lda	(GOSUBSTACK),y
     56  1341		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  1343		       d0 09		      bne	iPopMathStackNoFrame
     58  1345		       88		      dey
     59  1346		       88		      dey
     60  1347		       88		      dey
     61  1348		       b1 4b		      lda	(GOSUBSTACK),y
     62  134a		       85 4a		      sta	MATHSTACKPTR
     63  134c		       84 4d		      sty	GOSUBSTACKPTR
     64  134e
     65  134e				   iPopMathStackNoFrame
     66  134e
     67  134e		       68		      pla
     68  134f		       a8		      tay
     69  1350		       60		      rts
     70  1351
     71  1351
     72  1351							;==========================================================
     73  1351							; Push the current math stack information onto the gosub stack
     74  1351				   iSaveMathStack
     75  1351		       98		      tya
     76  1352		       48		      pha
     77  1353		       a4 4d		      ldy	GOSUBSTACKPTR
     78  1355		       a5 4a		      lda	MATHSTACKPTR
     79  1357		       91 4b		      sta	(GOSUBSTACK),y
     80  1359		       a5 48		      lda	MATHSTACK
     81  135b		       c8		      iny
     82  135c
     83  135c		       91 4b		      sta	(GOSUBSTACK),y
     84  135e		       c8		      iny
     85  135f
     86  135f		       a5 49		      lda	MATHSTACK+1
     87  1361		       91 4b		      sta	(GOSUBSTACK),y
     88  1363		       c8		      iny
     89  1364
     90  1364		       a9 06		      lda	#GOSUB_STACK_SAVE
     91  1366		       91 4b		      sta	(GOSUBSTACK),y
     92  1368		       c8		      iny
     93  1369
     94  1369		       84 4d		      sty	GOSUBSTACKPTR
     95  136b		       68		      pla
     96  136c		       a8		      tay
     97  136d		       4c bb 02 	      jmp	NextIL
     98  1370							;
     99  1370							;==========================================================
    100  1370							;Restore the math stack information from the gosub stack
    101  1370				   iRestoreMathStack
    102  1370		       98		      tya
    103  1371		       48		      pha
    104  1372
    105  1372		       a5 4a		      lda	MATHSTACKPTR
    106  1374		       85 58		      sta	R2	; save the current offset for whatever task to R2
    107  1376
    108  1376		       a4 4d		      ldy	GOSUBSTACKPTR
    109  1378		       88		      dey
    110  1379		       b1 4b		      lda	(GOSUBSTACK),y
    111  137b		       c9 06		      cmp	#GOSUB_STACK_SAVE
    112  137d		       d0 16		      bne	iPopMathStack_Err
    113  137f		       88		      dey
    114  1380		       b1 4b		      lda	(GOSUBSTACK),y
    115  1382		       85 49		      sta	MATHSTACK+1
    116  1384		       88		      dey
    117  1385		       b1 4b		      lda	(GOSUBSTACK),y
    118  1387		       85 48		      sta	MATHSTACK
    119  1389		       88		      dey
    120  138a		       b1 4b		      lda	(GOSUBSTACK),y
    121  138c		       85 4a		      sta	MATHSTACKPTR
    122  138e		       84 4d		      sty	GOSUBSTACKPTR
    123  1390		       68		      pla
    124  1391		       a8		      tay
    125  1392		       4c bb 02 	      jmp	NextIL
    126  1395
    127  1395				   iPopMathStack_Err
    128  1395		       a9 00		      lda	#0
    129  1397		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    130  1399		       4c 18 06 	      jmp	iErr2
    131  139c							;=========================================
    132  139c							; For functions and tasks the variable address of # means
    133  139c							; a passed parameter so #[0] is the first parameter etc
    134  139c							; will try for a better way later
    135  139c
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  139c					      include	"tasks.asm"
      1  139c							;=====================================================
      2  139c							; Tiny Basic IL task management
      3  139c							; Data required by task management
      4  139c							; currently each context is about 30 bytes and is swapped
      5  139c							; into and out of page zero on each task switch....
      6  139c							; LOL yes it is slow, but works for this iteration.
      7  139c							;
      8  139c
      9  139c					      Seg	Code
     10  139c							;=====================================================
     11  139c							; Sets the pointers to the math,IL and gosub stacks
     12  139c							; Creates the initial Context for each task slot
     13  139c				   taskSetStacks
     14  139c		       a9 de		      lda	#mathStack&$FF
     15  139e		       85 48		      sta	MATHSTACK
     16  13a0		       a9 23		      lda	#mathStack>>8
     17  13a2		       85 49		      sta	MATHSTACK+1
     18  13a4
     19  13a4		       a9 6e		      lda	#ilStack&$ff
     20  13a6		       85 45		      sta	ILSTACK
     21  13a8		       a9 25		      lda	#ilStack>>8
     22  13aa		       85 46		      sta	ILSTACK+1
     23  13ac
     24  13ac		       a9 fe		      lda	#gosubStack&$FF
     25  13ae		       85 4b		      sta	GOSUBSTACK
     26  13b0		       a9 26		      lda	#gosubStack>>8
     27  13b2		       85 4c		      sta	GOSUBSTACK+1
     28  13b4
     29  13b4		       a9 7e		      lda	#variableStack&$FF
     30  13b6		       85 41		      sta	VARIABLES
     31  13b8		       a9 29		      lda	#variableStack>>8
     32  13ba		       85 42		      sta	VARIABLES+1
     33  13bc		       a2 0a		      ldx	#TASKCOUNT
     34  13be		       a0 00		      ldy	#0
     35  13c0		       20 4b 16 	      jsr	ContextSave
     36  13c3
     37  13c3		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  13c5		       b0 3a		      bcs	taskSetDone
     39  13c7
     40  13c7		       a5 4b		      lda	GOSUBSTACK
     41  13c9		       18		      clc
     42  13ca		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  13cc		       85 4b		      sta	GOSUBSTACK
     44  13ce		       a5 4c		      lda	GOSUBSTACK+1
     45  13d0		       69 00		      adc	#0
     46  13d2		       85 4c		      sta	GOSUBSTACK+1
     47  13d4
     48  13d4		       a5 45		      lda	ILSTACK	; must be less than 256
     49  13d6		       18		      clc
     50  13d7		       69 28		      adc	#ILSTACKSIZE*2
     51  13d9		       85 45		      sta	ILSTACK
     52  13db		       a5 46		      lda	ILSTACK+1
     53  13dd		       69 00		      adc	#0
     54  13df		       85 46		      sta	ILSTACK+1
     55  13e1
     56  13e1		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  13e3		       18		      clc
     58  13e4		       69 28		      adc	#MATHSTACKSIZE*2
     59  13e6		       85 48		      sta	MATHSTACK
     60  13e8		       a5 49		      lda	MATHSTACK+1
     61  13ea		       69 00		      adc	#0
     62  13ec		       85 49		      sta	MATHSTACK+1
     63  13ee
     64  13ee		       a5 41		      lda	VARIABLES	; must be less than 256
     65  13f0		       18		      clc
     66  13f1		       69 36		      adc	#VARIABLESSIZE*2
     67  13f3		       85 41		      sta	VARIABLES
     68  13f5		       a5 42		      lda	VARIABLES+1
     69  13f7		       69 00		      adc	#0
     70  13f9		       85 42		      sta	VARIABLES+1
     71  13fb
     72  13fb		       20 4b 16 	      jsr	ContextSave
     73  13fe		       4c c3 13 	      jmp	taskSetLoop
     74  1401
     75  1401				   taskSetDone
     76  1401		       a0 00		      ldy	#0	; reload the main loop context
     77  1403		       20 5a 16 	      jsr	ContextLoad
     78  1406		       60		      rts
     79  1407							;
     80  1407							;=====================================================
     81  1407							; In some error cases the math stacks may be left pointing to the wrong stack
     82  1407							; This function will reset those stack addresses but not the actual pointer
     83  1407				   taskResetStacks
     84  1407		       a0 00		      ldy	#0
     85  1409		       20 5a 16 	      jsr	ContextLoad
     86  140c		       4c 9c 13 	      jmp	taskSetStacks
     87  140f							;
     88  140f							;=====================================================
     89  140f							; Clear all task entries and task stacks
     90  140f		       98	   taskReset  tya		; Save Y
     91  1410		       48		      pha
     92  1411		       a9 01		      lda	#1
     93  1413		       8d dd 23 	      sta	taskCounter	; Set number of active tasks to 1
     94  1416		       ac de 22 	      ldy	taskPtr	; Set the active task to 0 MAIN
     95  1419		       c0 00		      cpy	#0	; check if we are the main context
     96  141b		       f0 08		      beq	taskResetCont	; if we are just continue
     97  141d
     98  141d		       a0 00		      ldy	#0	; else we need to switch to the main context
     99  141f		       8c de 22 	      sty	taskPtr
    100  1422		       20 5a 16 	      jsr	ContextLoad	; load the System Task context
    101  1425				   taskResetCont
    102  1425		       a0 19		      ldy	#CONTEXTLEN+1	; Start at the second task +1 account for task control byte
    103  1427
    104  1427				   taskResetLoop
    105  1427		       a9 00		      lda	#TASKINACTIVE
    106  1429		       99 df 22 	      sta	taskTable,y	; Ensure that the task is made inactive
    107  142c		       18		      clc
    108  142d		       98		      tya
    109  142e		       69 19		      adc	#CONTEXTLEN+1
    110  1430		       a8		      tay
    111  1431		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    112  1433		       90 f2		      bcc	taskResetLoop	; Go for more
    113  1435
    114  1435				   taskResetComplete
    115  1435
    116  1435		       68		      pla		; Restore y
    117  1436		       a8		      tay
    118  1437		       60		      rts
    119  1438
    120  1438							;
    121  1438							;======================================================
    122  1438							; iTaskSwitch	 switch to new task if not interrupt and
    123  1438							;		 count is exceded for task time slice gets here
    124  1438							;		 when time slice has reached zero
    125  1438							;
    126  1438		       98	   iTaskSwitch tya
    127  1439		       48		      pha
    128  143a
    129  143a		       ad db 23 	      lda	taskResetValue	; Always reset the counter value
    130  143d		       8d d9 23 	      sta	taskCurrentCycles	; Update the counter with the new value
    131  1440		       ce da 23 	      dec	taskCurrentCycles+1	; dec high order byte
    132  1443		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    133  1445
    134  1445		       ad dc 23 	      lda	taskResetValue+1
    135  1448		       8d da 23 	      sta	taskCurrentCycles+1
    136  144b
    137  144b		       ad db 22 	      lda	IRQPending	; Skip this if we are processing an irq
    138  144e		       0d 35 2c 	      ora	taskIOPending	; If set then don't switch
    139  1451		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    140  1453
    141  1453		       ad dd 23    iTaskMain  lda	taskCounter	; Number of tasks
    142  1456		       c9 01		      cmp	#1	; if there is only one task must be main
    143  1458		       d0 07		      bne	itasknext	; if it some other number continue to next
    144  145a
    145  145a		       ac de 22 	      ldy	taskPtr	; check if we have not just ended some other task
    146  145d		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    147  145f		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    148  1461							;
    149  1461							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    150  1461							;
    151  1461				   itasknext
    152  1461		       ac de 22 	      ldy	taskPtr
    153  1464		       20 4b 16 	      jsr	ContextSave	; Save the current context, y points to next context
    154  1467				   itaskLoop
    155  1467		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    156  1469		       90 04		      bcc	iTaskNextChk
    157  146b
    158  146b		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    159  146d		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    160  146f
    161  146f				   iTaskNextChk
    162  146f		       b9 df 22 	      lda	taskTable,y	; there is always at least one entry in table
    163  1472		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    164  1474		       18	   iTaskNext  clc
    165  1475		       98		      tya
    166  1476		       69 19		      adc	#CONTEXTLEN+1	; Next Table entry
    167  1478		       a8		      tay
    168  1479		       4c 67 14 	      jmp	itaskLoop	; Check for busy entry
    169  147c
    170  147c		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    171  147e		       59 df 22 	      eor	taskTable,y	; Check for anything waiting io
    172  1481		       d0 f1		      bne	iTaskNext
    173  1483		       20 5a 16 	      jsr	ContextLoad	; load the next context
    174  1486		       8c de 22 	      sty	taskPtr	; update the task pointer
    175  1489
    176  1489				   iTaskSwitchDone
    177  1489		       68		      pla
    178  148a		       a8		      tay
    179  148b		       60		      rts
    180  148c							;
    181  148c							;================================================================
    182  148c							; Task Set task number to line number to start
    183  148c							; Task Table structure:
    184  148c							;    byte 0	-   Active inactive
    185  148c							;    byte 1-2	-   Basic code line pointer
    186  148c							;    byte 3	-   Offset on current line
    187  148c		       98	   iTaskSet   tya		;preserve Y
    188  148d		       48		      pha		; push a
    189  148e
    190  148e		       20 eb 19 	      jsr	popR0	; Get the line number to be saved
    191  1491
    192  1491		       ac de 22 	      ldy	taskPtr	; find out where we are
    193  1494		       20 4b 16 	      jsr	ContextSave	; Save the current context
    194  1497
    195  1497							;Find the pointer to the line we need to start at
    196  1497		       20 b3 17 	      jsr	findLine	; Get the offset of the line to start task at
    197  149a		       f0 0b		      beq	iTaskCont
    198  149c
    199  149c		       ac de 22 	      ldy	taskPtr	; Restore the original Context Error Exit
    200  149f		       20 5a 16 	      jsr	ContextLoad
    201  14a2
    202  14a2		       68		      pla		; pop a - exit
    203  14a3		       a8		      tay
    204  14a4		       4c f5 0c 	      jmp	iSetIrqErr	; Bad line number provided
    205  14a7
    206  14a7				   iTaskCont
    207  14a7		       20 1d 16 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    208  14aa		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    209  14ac
    210  14ac		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    211  14ae		       99 df 22 	      sta	taskTable,y	; new task as active
    212  14b1
    213  14b1		       a5 4f		      lda	CURPTR
    214  14b3		       48		      pha		; push a
    215  14b4		       a5 50		      lda	CURPTR+1
    216  14b6		       48		      pha		; push a
    217  14b7
    218  14b7		       20 5a 16 	      jsr	ContextLoad	; load the context of the new task
    219  14ba
    220  14ba		       68		      pla		; pop a
    221  14bb		       85 50		      sta	CURPTR+1
    222  14bd		       68		      pla		; pop a
    223  14be		       85 4f		      sta	CURPTR
    224  14c0		       a9 03		      lda	#3	; Offset to first instruction
    225  14c2		       85 51		      sta	CUROFF
    226  14c4
    227  14c4		       a9 00		      lda	#0
    228  14c6		       85 47		      sta	ILSTACKPTR
    229  14c8		       85 4a		      sta	MATHSTACKPTR
    230  14ca		       85 4d		      sta	GOSUBSTACKPTR
    231  14cc		       a9 40		      lda	#GOSUBSTACKSIZE*4
    232  14ce		       85 4e		      sta	MESSAGEPTR
    233  14d0
    234  14d0		       20 52 09 	      jsr	subVINIT	; Clear the variables
    235  14d3
    236  14d3		       a9 0b		      lda	#STMT&$FF
    237  14d5		       85 43		      sta	ILPC
    238  14d7		       a9 1e		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    239  14d9		       85 44		      sta	ILPC+1
    240  14db
    241  14db		       98		      tya		; Save the new context offset to return to user
    242  14dc		       48		      pha		; push a
    243  14dd
    244  14dd		       20 4b 16    itaskSetSave jsr	ContextSave	; save the updated context
    245  14e0		       ee dd 23 	      inc	taskCounter	; Update the number of Tasks running
    246  14e3
    247  14e3		       ac de 22 	      ldy	taskPtr
    248  14e6		       20 5a 16 	      jsr	ContextLoad	; restore the original context
    249  14e9
    250  14e9		       a9 00		      lda	#0	; Set the R0 upper to zero
    251  14eb		       85 53		      sta	R0+1
    252  14ed		       68		      pla		; Get the task pid we stored				 ; pop a
    253  14ee		       85 52		      sta	R0	; Get the table entry value
    254  14f0
    255  14f0		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    256  14f1		       a8		      tay
    257  14f2
    258  14f2		       4c 03 07 	      jmp	pushR0nextIl	; Push R0 and continue
    259  14f5				   iTaskNoEmpty
    260  14f5		       ac de 22 	      ldy	taskPtr
    261  14f8		       20 5a 16 	      jsr	ContextLoad
    262  14fb
    263  14fb		       68		      pla		; pop a    -- exit
    264  14fc		       a8		      tay
    265  14fd
    266  14fd		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    267  14ff		       a9 00		      lda	#0
    268  1501		       4c 18 06 	      jmp	iErr2
    269  1504							;
    270  1504							;===============================================================
    271  1504							; Run the task whos PID is on the stack, preserve the stack
    272  1504							;
    273  1504				   iTaskEnable
    274  1504		       98		      tya
    275  1505		       48		      pha
    276  1506		       20 03 1a 	      jsr	popR1
    277  1509		       20 d1 19 	      jsr	pushR1
    278  150c		       20 51 17 	      jsr	ipc_getcontext	; get context pointer into mq
    279  150f		       a0 00		      ldy	#0
    280  1511		       b1 56		      lda	(MQ),y
    281  1513		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    282  1515		       09 80		      ora	#TASKACTIVE
    283  1517		       91 56		      sta	(MQ),y
    284  1519		       68		      pla
    285  151a		       a8		      tay
    286  151b		       4c bb 02 	      jmp	NextIL
    287  151e
    288  151e							;
    289  151e							;===============================================================
    290  151e							; Suspend the task whos PID  is on the stack, preserve the stack
    291  151e							;
    292  151e				   iTaskSuspend
    293  151e		       98		      tya
    294  151f		       48		      pha
    295  1520		       20 03 1a 	      jsr	popR1
    296  1523		       20 d1 19 	      jsr	pushR1
    297  1526		       20 51 17 	      jsr	ipc_getcontext	; get context pointer into mq
    298  1529		       a0 00		      ldy	#0
    299  152b		       b1 56		      lda	(MQ),y
    300  152d		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    301  152f		       09 80		      ora	#TASKACTIVE
    302  1531		       68		      pla
    303  1532		       a8		      tay
    304  1533		       4c bb 02 	      jmp	NextIL
    305  1536
    306  1536							;================================================================
    307  1536							; Returns task Status
    308  1536				   iTaskStat
    309  1536		       98		      tya
    310  1537		       48		      pha
    311  1538		       20 4a 15 	      jsr	iTaskValid	; returns pointer to task entry
    312  153b		       b9 df 22 	      lda	taskTable,y
    313  153e		       f0 05		      beq	iTaskStatExit
    314  1540		       68		      pla
    315  1541		       a8		      tay
    316  1542		       4c b1 0c 	      jmp	iTruth
    317  1545				   iTaskStatExit
    318  1545		       68		      pla
    319  1546		       a8		      tay
    320  1547		       4c ba 0c 	      jmp	iFalse
    321  154a
    322  154a							;
    323  154a							;================================================================
    324  154a							; Validate the task number on top of the stack
    325  154a							; on exit y points to the requested task entry
    326  154a							;
    327  154a		       20 eb 19    iTaskValid jsr	popR0	; get result of the multiply
    328  154d		       a5 53		      lda	R0+1
    329  154f		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    330  1551		       a5 52		      lda	R0
    331  1553		       c9 fa		      cmp	#TASKTABLELEN
    332  1555		       90 09		      bcc	iTaskIsValid
    333  1557
    334  1557		       68	   iTaskValidErr pla		;remove return address
    335  1558		       68		      pla
    336  1559		       a2 10		      ldx	#ERR_INVALID_PID
    337  155b		       a9 00		      lda	#0
    338  155d		       4c 18 06 	      jmp	iErr2
    339  1560
    340  1560		       a8	   iTaskIsValid tay
    341  1561		       60		      rts
    342  1562							;
    343  1562							;================================================================
    344  1562							; Kill a running task, do nothing if already stopped
    345  1562		       20 4a 15    iTaskKill  jsr	iTaskValid
    346  1565		       a9 00		      lda	#0
    347  1567		       99 df 22 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    348  156a							;
    349  156a							;================================================================
    350  156a							;Skip to next task
    351  156a				   iNTask
    352  156a		       a9 01		      lda	#1
    353  156c		       8d d9 23 	      sta	taskCurrentCycles
    354  156f		       8d da 23 	      sta	taskCurrentCycles+1
    355  1572		       4c bb 02 	      jmp	NextIL
    356  1575							;
    357  1575							;=======================================================
    358  1575							; Wait for a task to complete
    359  1575				   iWTASK
    360  1575		       20 6e 17 	      jsr	getILByte
    361  1578		       8d 33 2c 	      sta	offset
    362  157b							;
    363  157b		       20 51 19 	      jsr	saveIL	;in case of failure
    364  157e
    365  157e		       20 4a 15 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    366  1581		       b9 df 22 	      lda	taskTable,y
    367  1584		       d0 03		      bne	iWTASKWAIT
    368  1586				   iWTASKEXITED
    369  1586		       4c bb 02 	      jmp	NextIL
    370  1589				   iWTASKWAIT
    371  1589		       20 67 19 	      jsr	pushR0	; Push R0 back onto the stack
    372  158c		       a9 01		      lda	#1
    373  158e		       8d d9 23 	      sta	taskCurrentCycles	; Give up the cycles
    374  1591		       8d da 23 	      sta	taskCurrentCycles+1
    375  1594		       20 5c 19 	      jsr	restoreIL
    376  1597		       4c 15 0b 	      jmp	tstBranch
    377  159a							;
    378  159a							;=======================================================
    379  159a							; Set task io lock
    380  159a		       ee 35 2c    iStartIO   inc	taskIOPending
    381  159d		       4c bb 02 	      jmp	NextIL
    382  15a0							;
    383  15a0							;=======================================================
    384  15a0							; Release the io lock
    385  15a0		       ad 35 2c    iEndIO     lda	taskIOPending
    386  15a3		       f0 03		      beq	iEndIOExit
    387  15a5		       ce 35 2c 	      dec	taskIOPending
    388  15a8		       4c bb 02    iEndIOExit jmp	NextIL
    389  15ab							;
    390  15ab							;===============================================================
    391  15ab							; Return the task PID
    392  15ab				   iTASKPID
    393  15ab		       a9 00		      lda	#0
    394  15ad		       85 53		      sta	R0+1
    395  15af		       ad de 22 	      lda	taskPtr
    396  15b2		       85 52		      sta	R0
    397  15b4		       4c 03 07 	      jmp	pushR0nextIl
    398  15b7							;
    399  15b7							;================================================================
    400  15b7							; Terminate a task
    401  15b7		       ac de 22    iETask     ldy	taskPtr
    402  15ba		       c0 00		      cpy	#0
    403  15bc		       d0 03		      bne	iETaskCont
    404  15be		       4c 01 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    405  15c1				   iETaskCont
    406  15c1		       a9 00		      lda	#TASKINACTIVE
    407  15c3		       99 df 22 	      sta	taskTable,y	; mark entry as free
    408  15c6		       ce dd 23 	      dec	taskCounter	; reduce the number of active tasks
    409  15c9		       a9 01		      lda	#1
    410  15cb		       8d d9 23 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    411  15ce		       8d da 23 	      sta	taskCurrentCycles+1
    412  15d1		       20 38 16 	      jsr	TaskSetExitCode
    413  15d4				   iETaskExit
    414  15d4		       4c bb 02 	      jmp	NextIL
    415  15d7							;================================================================
    416  15d7							; make the current tasks math stack equal another tasks stack
    417  15d7							; The task to get is stored on the math stack
    418  15d7
    419  15d7				   iTaskGetMathStack
    420  15d7		       20 65 1c 	      jsr	CopyStackR1	; Get the top of stack to R1
    421  15da		       20 51 17 	      jsr	ipc_getcontext	; MQ now has the context address
    422  15dd		       a0 0a		      ldy	#MATHSTACKPTRPOS
    423  15df		       b1 56		      lda	(MQ),y
    424  15e1		       85 4a		      sta	MATHSTACKPTR
    425  15e3		       a0 08		      ldy	#MATHSTACKPOS
    426  15e5		       b1 56		      lda	(MQ),y
    427  15e7		       85 48		      sta	MATHSTACK
    428  15e9		       c8		      iny
    429  15ea		       b1 56		      lda	(MQ),y
    430  15ec		       85 49		      sta	MATHSTACK+1
    431  15ee		       4c bb 02 	      jmp	NextIL
    432  15f1							;==================================================================
    433  15f1							; Updates the tasks math stack pointer with contents of R2
    434  15f1							; PID is on top of the stack
    435  15f1				   iTaskPutMathPtr
    436  15f1		       20 65 1c 	      jsr	CopyStackR1	; Get the top of stack to R1
    437  15f4		       20 51 17 	      jsr	ipc_getcontext	; MQ now has the context address
    438  15f7		       a5 58		      lda	R2
    439  15f9		       a0 0a		      ldy	#MATHSTACKPTRPOS
    440  15fb		       91 56		      sta	(MQ),y
    441  15fd		       4c bb 02 	      jmp	NextIL
    442  1600							;
    443  1600							;================================================================
    444  1600							; Set the time slice for each task
    445  1600				   iSLICE
    446  1600		       20 eb 19 	      jsr	popR0
    447  1603		       a5 52		      lda	R0
    448  1605		       8d db 23 	      sta	taskResetValue
    449  1608		       a5 53		      lda	R0+1
    450  160a		       8d dc 23 	      sta	taskResetValue+1
    451  160d		       d0 0b		      bne	iSliceSet
    452  160f		       ee dc 23 	      inc	taskResetValue+1	; must be at least 1 high counter
    453  1612		       a9 01		      lda	#1
    454  1614		       8d d9 23 	      sta	taskCurrentCycles
    455  1617		       8d da 23 	      sta	taskCurrentCycles+1
    456  161a				   iSliceSet
    457  161a		       4c bb 02 	      jmp	NextIL
    458  161d							;================================================================
    459  161d							; Find an empty slot in the taskTable
    460  161d							; Return the index in y
    461  161d							; on exit   c set if an empty slot is found
    462  161d							;	     c clear if not found
    463  161d							;================================================================
    464  161d							;
    465  161d		       ad dd 23    TaskEmpty  lda	taskCounter
    466  1620		       c9 0a		      cmp	#TASKCOUNT
    467  1622		       b0 10		      bcs	TaskNoSlot
    468  1624		       a0 19		      ldy	#CONTEXTLEN+1	;The first slot is always the main line SKIP
    469  1626				   TaskLoop
    470  1626		       b9 df 22 	      lda	taskTable,y
    471  1629		       f0 0b		      beq	TaskEmptyFnd
    472  162b		       98		      tya
    473  162c		       18		      clc
    474  162d		       69 19		      adc	#CONTEXTLEN+1
    475  162f		       a8		      tay
    476  1630		       c0 fa		      cpy	#TASKTABLELEN
    477  1632		       90 f2		      bcc	TaskLoop	; Y is never zero
    478  1634				   TaskNoSlot
    479  1634		       18		      clc
    480  1635		       60		      rts
    481  1636				   TaskEmptyFnd
    482  1636		       38		      sec
    483  1637		       60		      rts
    484  1638							;====================================================
    485  1638							; Set the task exit code called from the return command
    486  1638							; on entry stack top hold exit value
    487  1638				   TaskSetExitCode
    488  1638		       98		      tya
    489  1639		       48		      pha
    490  163a		       20 eb 19 	      jsr	popR0
    491  163d		       a0 19		      ldy	#TASKEXITCODE
    492  163f		       a5 52		      lda	R0
    493  1641		       91 41		      sta	(VARIABLES),y
    494  1643		       c8		      iny
    495  1644		       a5 53		      lda	R0+1
    496  1646		       91 41		      sta	(VARIABLES),y
    497  1648		       68		      pla
    498  1649		       98		      tya
    499  164a		       60		      rts
    500  164b
    501  164b							;
    502  164b							;=====================================================
    503  164b							; Save Context Store the context to the TASK Table
    504  164b							; on entry y contains the task table entry to save to
    505  164b							; on exit y points to next task table entry
    506  164b							;	   x contains the number of bytes copied
    507  164b		       a2 00	   ContextSave ldx	#0
    508  164d		       c8		      iny		;inc past the task flags
    509  164e		       b5 41	   ContextSvLoop lda	CONTEXT,x
    510  1650		       99 df 22 	      sta	taskTable,y
    511  1653		       c8		      iny
    512  1654		       e8		      inx
    513  1655		       e0 18		      cpx	#CONTEXTLEN
    514  1657		       90 f5		      bcc	ContextSvLoop
    515  1659		       60		      rts
    516  165a							;
    517  165a							; Load Context transfer context from task table to the Current Context
    518  165a							; on entry y contains the task table entry to transfer
    519  165a							; on exit y points to the original task table entry
    520  165a							;	   x contains the number of byts copied
    521  165a		       98	   ContextLoad tya
    522  165b		       48		      pha
    523  165c		       a2 00		      ldx	#0
    524  165e		       c8		      iny		;inc past the task flags
    525  165f		       b9 df 22    ContextLDLoop lda	taskTable,y
    526  1662		       95 41		      sta	CONTEXT,x
    527  1664		       c8		      iny
    528  1665		       e8		      inx
    529  1666		       e0 18		      cpx	#CONTEXTLEN
    530  1668		       90 f5		      bcc	ContextLDLoop
    531  166a		       68		      pla
    532  166b		       a8		      tay
    533  166c		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  166d					      include	"ipc.asm"
      1  166d							;======================================================
      2  166d							; Inter process communications.
      3  166d							; Tasks may write/read integer messages among
      4  166d							; them selves.
      5  166d							; This uses each tasks gosub stack as a message queue
      6  166d							; Gosub calls start at the highest address and the
      7  166d							; msg queue starts at the highest address.
      8  166d							;
      9  166d							;======================================================
     10  166d							; ipcs   - Send msg to another task or many tasks
     11  166d							; on entry  math stack contains the  top PID
     12  166d							;				      2ND Message value
     13  166d							; on exit   math stack contain top True-good or False-failed
     14  166d							;
     15  166d							; it may not be sent if queue is full
     16  166d							;
     17  166d							; a = ipcs(<message-expression>,<task PID-expression>)
     18  166d							;
     19  166d				   iIPCS
     20  166d		       98		      tya
     21  166e		       48		      pha
     22  166f		       20 d6 16 	      jsr	ipc_enqueue
     23  1672		       b0 08		      bcs	iIPC_BAD
     24  1674		       20 57 1c 	      jsr	pushTrue
     25  1677		       68		      pla
     26  1678		       a8		      tay
     27  1679		       4c bb 02 	      jmp	NextIL
     28  167c				   iIPC_BAD
     29  167c		       68		      pla
     30  167d		       a8		      tay
     31  167e		       20 61 1c 	      jsr	pushFalse
     32  1681		       4c bb 02 	      jmp	NextIL
     33  1684
     34  1684							;======================================================
     35  1684							; ipcr   - Recieve msg from task
     36  1684							; on exit  the message value is returned from message queue
     37  1684							;	    message -1	is reserved meaning no entry found
     38  1684							; The provided variable contains the pid of the sending
     39  1684							; task. This is optional. This always waits for a message
     40  1684							; before returning.
     41  1684							;
     42  1684							; a = ipcr(<variable name>)
     43  1684							;
     44  1684				   iIPCR
     45  1684		       98		      tya
     46  1685		       48		      pha
     47  1686		       20 18 17 	      jsr	ipc_dequeue
     48  1689		       b0 05		      bcs	iIPCR_Q_Empty
     49  168b		       68		      pla
     50  168c		       a8		      tay
     51  168d		       4c bb 02 	      jmp	NextIL
     52  1690				   iIPCR_Q_Empty
     53  1690		       68		      pla
     54  1691		       a8		      tay
     55  1692		       20 57 1c 	      jsr	pushTrue	; puts -1 on the stack
     56  1695		       4c bb 02 	      jmp	NextIL
     57  1698
     58  1698							;=======================================================
     59  1698							; ipcc   - Check if message available
     60  1698							; on exit  Stack contains number of messages
     61  1698							;
     62  1698							; a = ipcc()
     63  1698							;
     64  1698				   iIPCC
     65  1698		       98		      tya
     66  1699		       48		      pha
     67  169a		       20 c3 16 	      jsr	ipc_queue_count
     68  169d		       20 67 19 	      jsr	pushR0	; return the count
     69  16a0		       68		      pla
     70  16a1		       a8		      tay
     71  16a2		       4c bb 02 	      jmp	NextIL
     72  16a5
     73  16a5							;=======================================================
     74  16a5							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  16a5				   iIPCIO
     76  16a5		       98		      tya
     77  16a6		       48		      pha
     78  16a7		       20 c3 16 	      jsr	ipc_queue_count
     79  16aa		       a5 52		      lda	R0
     80  16ac		       d0 10		      bne	iIPCIO_No_Halt
     81  16ae		       a9 01		      lda	#1
     82  16b0		       8d d9 23 	      sta	taskCurrentCycles	; force a task switch
     83  16b3		       a9 01		      lda	#TASKWAITIPC
     84  16b5		       ac de 22 	      ldy	taskPtr
     85  16b8		       19 df 22 	      ora	taskTable,y
     86  16bb		       99 df 22 	      sta	taskTable,y
     87  16be
     88  16be				   iIPCIO_No_Halt
     89  16be		       68		      pla
     90  16bf		       a8		      tay
     91  16c0		       4c bb 02 	      jmp	NextIL
     92  16c3							;======================================================
     93  16c3							;ipc_queue_count
     94  16c3				   ipc_queue_count
     95  16c3		       a5 4e		      lda	MESSAGEPTR
     96  16c5		       18		      clc
     97  16c6		       4a		      lsr		; divide by 4
     98  16c7		       4a		      lsr
     99  16c8		       85 52		      sta	R0	; store into R0
    100  16ca		       a9 10		      lda	#GOSUBSTACKSIZE
    101  16cc		       38		      sec
    102  16cd		       e5 52		      sbc	R0	; Get how many entries on queue
    103  16cf		       85 52		      sta	R0
    104  16d1		       a9 00		      lda	#0
    105  16d3		       85 53		      sta	R0+1
    106  16d5		       60		      rts
    107  16d6							;=======================================================
    108  16d6							; Support functions for messaging
    109  16d6							;
    110  16d6							; Enqueue message -> onto PID's MSG Q
    111  16d6							; on entry top of stack contains the PID
    112  16d6							;	    second contains the Message of the task
    113  16d6							; on exit contains c set if failed
    114  16d6							;		    c cleared if success
    115  16d6							;		    PID's MSG Q PTR points to the message
    116  16d6							;
    117  16d6				   ipc_enqueue
    118  16d6		       20 03 1a 	      jsr	popR1	; Get the pid
    119  16d9		       20 51 17 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  16dc
    121  16dc		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  16de		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  16e0		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  16e2		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  16e4		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  16e6
    127  16e6
    128  16e6							; Get the PID'S stack address into R0
    129  16e6		       a0 0b		      ldy	#GOSUBSTKPOS
    130  16e8		       b1 56		      lda	(MQ),y
    131  16ea		       85 52		      sta	R0
    132  16ec		       c8		      iny
    133  16ed		       b1 56		      lda	(MQ),y
    134  16ef		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  16f1
    136  16f1							; Set y to point to the msg q entry
    137  16f1		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  16f3		       b1 56		      lda	(MQ),y	; Get the index
    139  16f5		       a8		      tay		; Set y to queue offset
    140  16f6
    141  16f6							; enqueue the message
    142  16f6		       88		      dey		; First byte to save to
    143  16f7		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  16f9		       91 52		      sta	(R0),y	; Set the entry type
    145  16fb
    146  16fb		       88		      dey
    147  16fc		       ad de 22 	      lda	taskPtr	; Store the PID into queue
    148  16ff		       91 52		      sta	(R0),y
    149  1701		       20 03 1a 	      jsr	popR1	; Get the actual message value
    150  1704		       20 5f 17 	      jsr	ipc_pushR1	; Store Message value into queue
    151  1707
    152  1707		       98		      tya		; Save the new q ptr
    153  1708		       a0 0e		      ldy	#MSGPTRPOS
    154  170a		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  170c		       a0 00		      ldy	#0	; points to context root
    156  170e		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  1710		       51 56		      eor	(MQ),y	; Turn off the bit
    158  1712		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  1714		       18		      clc
    160  1715		       60		      rts
    161  1716				   ipc_enq_full
    162  1716		       38		      sec
    163  1717		       60		      rts
    164  1718							;=============================================================
    165  1718							; De-queue for message stack -> local tasks msg q
    166  1718							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  1718							;  message into
    168  1718							;  on exit   math stack contains value of message
    169  1718							;				  Variable if provided is pid
    170  1718				   ipc_dequeue
    171  1718		       20 1a 1a 	      jsr	popMQ	; Variable address to put PID into
    172  171b
    173  171b		       a4 4e		      ldy	MESSAGEPTR
    174  171d		       c0 40		      cpy	#GOSUBSTACKSIZE*4	; see if anything to pop from stack
    175  171f		       b0 2e		      bcs	ipc_deq_empty
    176  1721		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  1723		       85 52		      sta	R0
    178  1725		       c8		      iny
    179  1726		       b1 4b		      lda	(GOSUBSTACK),y
    180  1728		       85 53		      sta	R0+1
    181  172a		       c8		      iny
    182  172b		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  172d		       85 54		      sta	R1
    184  172f		       c8		      iny
    185  1730		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  1732		       c8		      iny
    187  1733		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  1735
    189  1735		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  1737		       d0 16		      bne	ipc_deq_empty
    191  1739
    192  1739		       20 67 19 	      jsr	pushR0	; place value on stack
    193  173c
    194  173c		       a5 56		      lda	MQ
    195  173e		       05 57		      ora	MQ+1
    196  1740		       f0 0b		      beq	ipc_deq_done
    197  1742		       a5 54		      lda	R1
    198  1744		       a0 00		      ldy	#0
    199  1746		       91 56		      sta	(MQ),y
    200  1748		       c8		      iny
    201  1749		       a9 00		      lda	#0
    202  174b		       91 56		      sta	(MQ),y
    203  174d				   ipc_deq_done
    204  174d		       18		      clc
    205  174e		       60		      rts
    206  174f
    207  174f				   ipc_deq_empty
    208  174f		       38		      sec
    209  1750		       60		      rts
    210  1751
    211  1751							;=============================================
    212  1751							;  Get the context address into MQ from R1 with
    213  1751							;  context/index/pid
    214  1751				   ipc_getcontext
    215  1751		       18		      clc		; Get pointer to Task context
    216  1752		       a9 df		      lda	#taskTable&$FF	; change ptr to address
    217  1754		       65 54		      adc	R1
    218  1756		       85 56		      sta	MQ
    219  1758		       a9 22		      lda	#taskTable>>8
    220  175a		       65 55		      adc	R1+1
    221  175c		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  175e		       60		      rts
    223  175f							;
    224  175f							;==============================================
    225  175f							;Push R1 onto the stack
    226  175f							;on entry y = next entry
    227  175f							;R0 points to the stack space
    228  175f							;on exit y points to next free byte
    229  175f				   ipc_pushR1
    230  175f		       88		      dey
    231  1760		       a5 55		      lda	R1+1	; PID first
    232  1762		       91 52		      sta	(R0),y
    233  1764		       88		      dey
    234  1765		       a5 54		      lda	R1
    235  1767		       91 52		      sta	(R0),y
    236  1769		       60		      rts
    237  176a
    238  176a
    239  176a
    240  176a
    241  176a
    242  176a
    243  176a
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  176a					      include	"support.asm"
      1  176a							;
      2  176a							;=====================================================
      3  176a							;=====================================================
      4  176a							;=====================================================
      5  176a							; This marks the start of support functions used by
      6  176a							; the IL opcodes.  These are support functions, NOT
      7  176a							; the IL code.
      8  176a							;=====================================================
      9  176a							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  176a							;=====================================================
     11  176a					      Seg	Code
     12  176a							;=====================================================
     13  176a							; This gets the next two bytes pointed to by ILPC and
     14  176a							; returns them; X contains LSB, A contains MSB.  ILPC
     15  176a							; is advanced by two, and Y contains 0 on return.
     16  176a
     17  176a							;
     18  176a		       20 6e 17    getILWord  jsr	getILByte	;LSB
     19  176d		       aa		      tax
     20  176e							;
     21  176e							;=====================================================
     22  176e							; This gets the next byte pointed to by ILPC and
     23  176e							; returns it in A.  On return, X is unchanged but Y
     24  176e							; contains 0.
     25  176e							;
     26  176e		       a0 00	   getILByte  ldy	#0
     27  1770		       b1 43		      lda	(ILPC),y	;get byte
     28  1772		       08		      php		;save status
     29  1773		       e6 43		      inc	ILPC	;inc LSB
     30  1775		       d0 02		      bne	getILb2	;branch if no overflow
     31  1777		       e6 44		      inc	ILPC+1	;inc MSB
     32  1779		       28	   getILb2    plp		;restore status
     33  177a		       60		      rts
     34  177b							;
     35  177b							;=====================================================
     36  177b							; Decrement ILPC by one.
     37  177b							;
     38  177b		       a5 43	   decIL      lda	ILPC
     39  177d		       d0 02		      bne	decIL2
     40  177f		       c6 44		      dec	ILPC+1
     41  1781		       c6 43	   decIL2     dec	ILPC
     42  1783		       60		      rts
     43  1784							;
     44  1784							;=====================================================
     45  1784							; Push the ILPC onto the return stack.  Actually, this
     46  1784							; pushes the address of ILPC+2 since that's the next
     47  1784							; address to execute.
     48  1784							;
     49  1784		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  1786		       c0 28		      cpy	#ILSTACKSIZE<<1
     51  1788		       b0 15		      bcs	pushErr
     52  178a		       a5 43		      lda	ILPC
     53  178c		       18		      clc
     54  178d		       69 02		      adc	#2
     55  178f		       91 45		      sta	(ILSTACK),y
     56  1791		       08		      php		;save C bit
     57  1792		       c8		      iny
     58  1793		       a5 44		      lda	ILPC+1
     59  1795		       28		      plp		;restore C
     60  1796		       69 00		      adc	#0
     61  1798		       91 45		      sta	(ILSTACK),y
     62  179a		       c8		      iny
     63  179b		       84 47		      sty	ILSTACKPTR
     64  179d		       18		      clc
     65  179e		       60		      rts
     66  179f				   pushErr
     67  179f		       38		      sec
     68  17a0		       60		      rts
     69  17a1							;
     70  17a1							;=====================================================
     71  17a1							; Pull the top entry from return stack and put into
     72  17a1							; ILPC.
     73  17a1							;
     74  17a1		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  17a3		       f0 fa		      beq	pushErr
     76  17a5		       88		      dey
     77  17a6		       b1 45		      lda	(ILSTACK),y
     78  17a8		       85 44		      sta	ILPC+1
     79  17aa		       88		      dey
     80  17ab		       b1 45		      lda	(ILSTACK),y
     81  17ad		       85 43		      sta	ILPC
     82  17af		       84 47		      sty	ILSTACKPTR
     83  17b1		       18		      clc
     84  17b2		       60		      rts
     85  17b3							;
     86  17b3							;=====================================================
     87  17b3							; This searches for a specific line number that is in
     88  17b3							; R0.	There are three possible return conditions:
     89  17b3							; Line numbers are now the third byte, the first byte is now **************
     90  17b3							; a pointer to the next line, of course no longer that 53 byte
     91  17b3							; per line.
     92  17b3							;
     93  17b3							; Exact match was found:
     94  17b3							;    * Z set
     95  17b3							;    * CURPTR points to two-byte line number for that
     96  17b3							;	line.
     97  17b3							;
     98  17b3							; Next highest line found:
     99  17b3							;    * Z cleared
    100  17b3							;    * C set
    101  17b3							;    * CURPTR points to two-byte line number for that
    102  17b3							;	line.
    103  17b3							;
    104  17b3							; End of program reached:
    105  17b3							;    * Z cleared
    106  17b3							;    * C cleared
    107  17b3							;    * CURPTR points to first free byte at end of
    108  17b3							;	program.  Ie, it has save value as PROGRAMEND.
    109  17b3							;
    110  17b3							; A, X, and Y are all undefined on return.
    111  17b3							;
    112  17b3
    113  17b3				   findLine
    114  17b3		       ad 37 2c 	      lda	ProgramStart	;Start of program -> CURPTR
    115  17b6		       85 4f		      sta	CURPTR
    116  17b8		       ad 38 2c 	      lda	ProgramStart+1
    117  17bb		       85 50		      sta	CURPTR+1
    118  17bd							;
    119  17bd							; At end of code?
    120  17bd							;
    121  17bd				   iXFER1
    122  17bd		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  17bf		       cd 39 2c 	      cmp	ProgramEnd	; at end of program then stop run
    124  17c2		       d0 0b		      bne	xfer2	; not end
    125  17c4		       a5 50		      lda	CURPTR+1
    126  17c6		       cd 3a 2c 	      cmp	ProgramEnd+1
    127  17c9		       d0 04		      bne	xfer2	;Not at end
    128  17cb							;
    129  17cb							; Line not found and the end of the program was
    130  17cb							; reached.  Return Z and C both clear.
    131  17cb							;
    132  17cb		       a9 01		      lda	#1	;clear Z
    133  17cd		       18		      clc		;clear C
    134  17ce		       60		      rts
    135  17cf							;
    136  17cf							; Check for an exact line number match
    137  17cf							;
    138  17cf		       a5 52	   xfer2      lda	R0
    139  17d1		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  17d3		       d1 4f		      cmp	(CURPTR),y
    141  17d5		       d0 08		      bne	xfernotit
    142  17d7		       c8		      iny
    143  17d8		       a5 53		      lda	R0+1
    144  17da		       d1 4f		      cmp	(CURPTR),y
    145  17dc		       d0 01		      bne	xfernotit	; not a matching line number
    146  17de							;
    147  17de							; This is exactly the line we want.
    148  17de							;
    149  17de		       60		      rts		;it matches exactly
    150  17df							;
    151  17df							; See if this line is greater than the one we're
    152  17df							; searching for.
    153  17df							;
    154  17df		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  17e1		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  17e3		       c5 53		      cmp	R0+1
    157  17e5		       90 0b		      bcc	xfer3
    158  17e7		       d0 07		      bne	xfer4
    159  17e9		       88		      dey
    160  17ea		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  17ec		       c5 52		      cmp	R0
    162  17ee		       90 02		      bcc	xfer3
    163  17f0							;
    164  17f0							; This line is greater than the one we want, so
    165  17f0							; return Z clear and C set.
    166  17f0							;
    167  17f0		       38	   xfer4      sec		;We found a line number greater
    168  17f1		       60		      rts		;both conditions set
    169  17f2							;
    170  17f2							; Not the line (or droid) we're looking for.  Move to
    171  17f2							; the next line.
    172  17f2							;
    173  17f2		       20 f8 17    xfer3      jsr	FindNextLine
    174  17f5		       4c bd 17 	      jmp	iXFER1
    175  17f8							;
    176  17f8							;=====================================================
    177  17f8							; This advances CURPTR to the next line.  If there
    178  17f8							; are no more lines, this leaves CURPTR equal to
    179  17f8							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  17f8							; CURPTR is pointing to a valid line on entry.  This
    181  17f8							; pointer points to the two-byte line number.
    182  17f8							; Update this points to the 1 byte line length  ****************
    183  17f8							;
    184  17f8				   FindNextLine
    185  17f8		       a0 03		      ldy	#3	;skip line number and length byte
    186  17fa		       84 51		      sty	CUROFF	;this is the new offset
    187  17fc		       a0 00		      ldy	#0
    188  17fe		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  1800		       18		      clc
    190  1801		       65 4f		      adc	CURPTR
    191  1803		       85 4f		      sta	CURPTR
    192  1805		       a5 50		      lda	CURPTR+1
    193  1807		       69 00		      adc	#0
    194  1809		       85 50		      sta	CURPTR+1
    195  180b		       60	   FindNext4  rts
    196  180c							;
    197  180c							;=====================================================
    198  180c							; This compares CURPTR to PROGRAMEND and returns Z set
    199  180c							; if they are equal, Z clear if not.
    200  180c							;
    201  180c		       a5 4f	   AtEnd      lda	CURPTR
    202  180e		       cd 39 2c 	      cmp	ProgramEnd
    203  1811		       d0 05		      bne	atendexit
    204  1813		       a5 50		      lda	CURPTR+1
    205  1815		       cd 3a 2c 	      cmp	ProgramEnd+1
    206  1818		       60	   atendexit  rts
    207  1819							;
    208  1819
    209  1819							;
    210  1819							;=====================================================
    211  1819							; Convert an ASCII string to a number.  On input,
    212  1819							; (CURPTR),Y points to the first digit.  This gets
    213  1819							; digit-by-digit until finding a non-number.  Returns
    214  1819							; Y pointing to the non-digit, and R0 contains the
    215  1819							; number.  This does NOT check for valid ranges, so
    216  1819							; a value like "123456789" will produce something,
    217  1819							; but not what you had expected.
    218  1819							;
    219  1819		       a9 00	   getDecimal lda	#0
    220  181b		       85 52		      sta	R0
    221  181d		       85 53		      sta	R0+1
    222  181f		       85 59		      sta	dpl	;temporary negative flag
    223  1821							;
    224  1821							; See if it's negative...
    225  1821							;
    226  1821							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  1821		       b1 4f		      lda	(CURPTR),y
    228  1823		       c9 2d		      cmp	#'-
    229  1825		       d0 02		      bne	getDecLoop
    230  1827		       e6 59		      inc	dpl	;it's negative
    231  1829							;
    232  1829		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  182b		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  182d		       c9 30		      cmp	#'0
    235  182f		       90 36		      bcc	getDdone
    236  1831		       c9 3a		      cmp	#'9+1
    237  1833		       b0 32		      bcs	getDdone
    238  1835		       38		      sec
    239  1836		       e9 30		      sbc	#'0	;convert to binary
    240  1838		       48		      pha
    241  1839							;
    242  1839							; Now multiply R0 by 10.  Remember that
    243  1839							; 2*N + 8*N = 10*N.
    244  1839							;
    245  1839		       06 52		      asl	R0
    246  183b		       26 53		      rol	R0+1	;*2
    247  183d		       a5 52		      lda	R0
    248  183f		       85 54		      sta	R1
    249  1841		       a5 53		      lda	R0+1
    250  1843		       85 55		      sta	R1+1
    251  1845		       06 52		      asl	R0
    252  1847		       26 53		      rol	R0+1	;*4
    253  1849		       06 52		      asl	R0
    254  184b		       26 53		      rol	R0+1	;*8
    255  184d		       18		      clc		;now add the partial sums...
    256  184e		       a5 52		      lda	R0	;...to get *10
    257  1850		       65 54		      adc	R1
    258  1852		       85 52		      sta	R0
    259  1854		       a5 53		      lda	R0+1
    260  1856		       65 55		      adc	R1+1
    261  1858		       85 53		      sta	R0+1
    262  185a							;
    263  185a							; Add in the new digit
    264  185a							;
    265  185a		       68		      pla
    266  185b		       18		      clc
    267  185c		       65 52		      adc	R0
    268  185e		       85 52		      sta	R0
    269  1860		       90 02		      bcc	getD2
    270  1862		       e6 53		      inc	R0+1
    271  1864							;
    272  1864							; Move to next character
    273  1864							;
    274  1864		       c8	   getD2      iny
    275  1865		       d0 c2		      bne	getDecLoop
    276  1867							;
    277  1867							; All done with digits, so now deal with it being
    278  1867							; negative.  If zero, then don't check for negative
    279  1867							; flag.  Ie, -0 is stored as 0.
    280  1867							;
    281  1867		       a5 52	   getDdone   lda	R0
    282  1869		       05 53		      ora	R0+1
    283  186b		       f0 16		      beq	getDone2	;zero
    284  186d		       a5 59		      lda	dpl
    285  186f		       f0 12		      beq	getDone2	;positive
    286  1871							;
    287  1871							; Invert all the bits, then add one.
    288  1871							;
    289  1871		       a5 52		      lda	R0
    290  1873		       49 ff		      eor	#$ff
    291  1875		       85 52		      sta	R0
    292  1877		       a5 53		      lda	R0+1
    293  1879		       49 ff		      eor	#$ff
    294  187b		       85 53		      sta	R0+1
    295  187d							;
    296  187d		       e6 52		      inc	R0
    297  187f		       d0 02		      bne	getDone2
    298  1881		       e6 53		      inc	R0+1
    299  1883				   getDone2
    300  1883							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  1883							;lda	  R0
    302  1883							;sta	  $0010
    303  1883							;lda	  R0+1
    304  1883							;sta	  $0011
    305  1883							;lda	  dpl
    306  1883							;sta	  $012
    307  1883
    308  1883		       60		      rts
    309  1884
    310  1884							;=====================================================
    311  1884							; Gets a line of input into LINBUF.
    312  1884							;
    313  1884							; On entry:
    314  1884							;    A contains the prompt character, or 0 if none.
    315  1884							;    X = 1 Background read
    316  1884							;    x = 0 Forground read with wait
    317  1884							;
    318  1884							; On exit:
    319  1884							;    CURPTR points to LINBUF
    320  1884							;    LINBUF contains the line with 0 at the end.
    321  1884							;    Y has offset to first non-space character
    322  1884							;    CURROFF has the same as Y.
    323  1884							;
    324  1884		       20 d3 18    GetLine    jsr	ReadPrompt
    325  1887		       e0 00		      cpx	#0
    326  1889		       f0 14		      beq	GetLineRetry
    327  188b		       ae de 22 	      ldx	taskPtr
    328  188e		       bd df 22 	      lda	taskTable,x
    329  1891		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  1893		       d0 3d		      bne	taskWaitingIO
    331  1895		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  1897		       9d df 22 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  189a		       ce d2 18 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  189d		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  189f
    336  189f							;
    337  189f							; Now read a line and wait for the CR
    338  189f							;
    339  189f				   GetLineRetry
    340  189f		       a9 00		      lda	#0	;Wait for input to complete
    341  18a1		       20 eb 18 	      jsr	ReadLine
    342  18a4
    343  18a4							;
    344  18a4							; Point to the line we just read
    345  18a4							; Set the current pointer to point to the input line
    346  18a4							;
    347  18a4		       a0 00	   ReadComplete ldy	#0
    348  18a6		       84 51		      sty	CUROFF
    349  18a8		       a2 9a		      ldx	#LINBUF&$ff
    350  18aa		       86 4f		      stx	CURPTR
    351  18ac		       a2 2b		      ldx	#LINBUF>>8
    352  18ae		       86 50		      stx	CURPTR+1
    353  18b0							;
    354  18b0							; Output a CR/LF
    355  18b0							;
    356  18b0		       20 a4 1a 	      jsr	CRLF
    357  18b3							;
    358  18b3							; If a blank line, prompt again.
    359  18b3							;
    360  18b3		       20 9b 1a 	      jsr	SkipSpaces
    361  18b6		       b1 4f		      lda	(CURPTR),y
    362  18b8		       d0 10		      bne	GetLineDone	;We have data then exit
    363  18ba		       20 d6 18 	      jsr	ReadPromptRetry
    364  18bd		       ae de 22 	      ldx	taskPtr	;if this task is waiting for IO
    365  18c0		       bd df 22 	      lda	taskTable,x	;then get out, wait for line to
    366  18c3		       29 40		      and	#TASKWAITIO	;Complete again
    367  18c5		       d0 0b		      bne	taskWaitingIO
    368  18c7		       4c 9f 18 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  18ca
    370  18ca				   GetLineDone
    371  18ca		       ae de 22 	      ldx	taskPtr
    372  18cd		       a9 80		      lda	#TASKACTIVE
    373  18cf		       9d df 22 	      sta	taskTable,x	;IO is complete
    374  18d2
    375  18d2				   taskWaitingIO
    376  18d2		       60		      rts
    377  18d3
    378  18d3							;
    379  18d3							;=======================================================================
    380  18d3							; Display the prompt character
    381  18d3							; On entry
    382  18d3							;	    A contains the prompt character
    383  18d3							; On exit
    384  18d3							;	    The readbuffer index is reset to 0
    385  18d3							;
    386  18d3		       8d 21 2c    ReadPrompt sta	promptChar
    387  18d6
    388  18d6							;
    389  18d6							; Prompt
    390  18d6							;
    391  18d6
    392  18d6		       ad 21 2c    ReadPromptRetry lda	promptChar
    393  18d9		       09 00		      ora	#0	;any prompt?
    394  18db		       f0 08		      beq	getlinenp
    395  18dd		       20 ed 1b 	      jsr	VOUTCH
    396  18e0		       a9 20		      lda	#$20
    397  18e2		       20 ed 1b 	      jsr	VOUTCH	;Space after prompt
    398  18e5							;
    399  18e5		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  18e7		       8e 1e 2c 	      stx	getlinx
    401  18ea		       60		      rts
    402  18eb							;
    403  18eb							;===============================================================
    404  18eb							; This fuction is the driver for the line input
    405  18eb							; on call if a = 0 then it waits for all input
    406  18eb							;	      a = 1 then nowait for input
    407  18eb							; On exit
    408  18eb							;		       c clear if not complete line
    409  18eb							;		       c set if it was a complete line
    410  18eb
    411  18eb				   ReadLine
    412  18eb		       8d 20 2c 	      sta	inputNoWait
    413  18ee		       c9 00		      cmp	#0
    414  18f0		       f0 05		      beq	getline1
    415  18f2		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  18f5		       f0 2b		      beq	GetLineNoWait
    417  18f7		       20 f0 1b    getline1   jsr	VGETCH
    418  18fa					      if	CTMON65
    419  18fa		       48		      pha
    420  18fb		       20 ed 1b 	      jsr	VOUTCH	;echo echo echo
    421  18fe		       68		      pla
    422  18ff					      endif
    423  18ff		       c9 0d		      cmp	#CR
    424  1901		       f0 15		      beq	getlind	;end of line
    425  1903		       c9 08		      cmp	#BS	;backspace?
    426  1905		       f0 1d		      beq	getlinebs
    427  1907		       ae 1e 2c 	      ldx	getlinx
    428  190a		       9d 9a 2b 	      sta	LINBUF,x
    429  190d		       e8		      inx
    430  190e		       8e 1e 2c 	      stx	getlinx
    431  1911		       ad 20 2c 	      lda	inputNoWait
    432  1914		       f0 e1		      beq	getline1
    433  1916		       d0 0a		      bne	GetLineNoWait
    434  1918							;
    435  1918							; CR was hit
    436  1918							;
    437  1918		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  191a		       ae 1e 2c 	      ldx	getlinx
    439  191d		       9d 9a 2b 	      sta	LINBUF,x
    440  1920
    441  1920		       38		      sec		; Carry set then cr received
    442  1921		       60		      rts
    443  1922
    444  1922				   GetLineNoWait
    445  1922		       18		      clc		; Carry clear no end of line
    446  1923		       60		      rts
    447  1924							;
    448  1924							; Backspace was hit
    449  1924							;
    450  1924		       ae 1e 2c    getlinebs  ldx	getlinx
    451  1927		       f0 0e		      beq	getlineEOL	;at start of line
    452  1929		       ca		      dex
    453  192a		       8e 1e 2c 	      stx	getlinx
    454  192d		       20 f3 1b    getlinepbs jsr	puts
      0  1930					      db	27,"[K",0
      1  1930		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  1934		       4c f7 18 	      jmp	getline1
    457  1937		       a9 20	   getlineEOL lda	#SPACE
    458  1939		       20 ed 1b 	      jsr	VOUTCH
    459  193c		       d0 ef		      bne	getlinepbs
    460  193e							;
    461  193e							;=====================================================
    462  193e							; Count the length of the line currently in LINBUF
    463  193e							; starting at offset Y.  Returns the length in X.  The
    464  193e							; starting offset in Y should point past the ASCII
    465  193e							; line number.  Also counts the trailing NULL and two
    466  193e							; extra bytes for where the line number will be.
    467  193e							; Update must now include leading length byte not the null at end ****************
    468  193e							;
    469  193e				   getLineLength
    470  193e		       a2 00		      ldx	#0	;size
    471  1940		       b9 9a 2b    getLineL2  lda	LINBUF,y
    472  1943		       f0 04		      beq	getLineL3
    473  1945		       c8		      iny
    474  1946		       e8		      inx
    475  1947		       d0 f7		      bne	getLineL2
    476  1949		       e8	   getLineL3  inx		;count null at end
    477  194a		       e8		      inx		;line number LSB
    478  194b		       e8		      inx		;MSB
    479  194c		       e8		      inx		;change: count new leading line length
    480  194d		       8e 34 2c 	      stx	lineLength
    481  1950		       60		      rts
    482  1951							;
    483  1951							;=====================================================
    484  1951							; Count the length of the line pointed to by CURPTR.
    485  1951							; This also counts the line number and the terminating
    486  1951							; null.  Ie, this string returns 8:
    487  1951							;
    488  1951							; <lineLow><lineHi>Hello<null>
    489  1951							;
    490  1951							; Another way of looking at it: add the return value
    491  1951							; to the CURPTR and it'll point to the next line's
    492  1951							; line number.  Returns the value in Y.
    493  1951							; Update to ject get the leading byte length ********************
    494  1951							;
    495  1951							;getCURPTRLength
    496  1951							;		ldy	CURPTR
    497  1951							;		ldy	#3	;change: skip line number and leading length byte
    498  1951							;getCLineL2	lda	(CURPTR),y
    499  1951							;		beq	getCLineL3
    500  1951							;		iny
    501  1951							;		bne	getCLineL2
    502  1951							;getCLineL3	iny		;count null at end
    503  1951							;		rts
    504  1951
    505  1951							;
    506  1951							;=====================================================
    507  1951							; This saves ILPC.  This saves to a single save area,
    508  1951							; so it can't be called more than once.
    509  1951							;
    510  1951		       a5 43	   saveIL     lda	ILPC
    511  1953		       8d 30 2c 	      sta	tempIL
    512  1956		       a5 44		      lda	ILPC+1
    513  1958		       8d 31 2c 	      sta	tempIL+1
    514  195b		       60		      rts
    515  195c							;
    516  195c							;=====================================================
    517  195c							; This restores ILPC.
    518  195c							;
    519  195c		       ad 30 2c    restoreIL  lda	tempIL
    520  195f		       85 43		      sta	ILPC
    521  1961		       ad 31 2c 	      lda	tempIL+1
    522  1964		       85 44		      sta	ILPC+1
    523  1966		       60		      rts
    524  1967							;
    525  1967							;=====================================================
    526  1967							; This pushes R0 onto the stack.
    527  1967							;
    528  1967		       8c 27 2c    pushR0     sty	rtemp1
    529  196a		       a4 4a		      ldy	MATHSTACKPTR
    530  196c		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  196e		       b0 34		      bcs	pusherr
    532  1970		       a5 52		      lda	R0
    533  1972		       91 48		      sta	(MATHSTACK),y
    534  1974		       c8		      iny
    535  1975		       a5 53		      lda	R0+1
    536  1977		       91 48		      sta	(MATHSTACK),y
    537  1979		       c8		      iny
    538  197a		       84 4a		      sty	MATHSTACKPTR
    539  197c		       ac 27 2c 	      ldy	rtemp1
    540  197f		       18		      clc
    541  1980		       60		      rts
    542  1981
    543  1981							;=====================================================
    544  1981							; This pushes curptr basic current line onto the call stack.
    545  1981							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  1981
    547  1981				   pushLN
    548  1981		       8c 27 2c 	      sty	rtemp1
    549  1984		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    550  1986		       c5 4d		      cmp	GOSUBSTACKPTR
    551  1988		       90 1a		      bcc	pusherr	; No error
    552  198a		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    553  198c		       a2 00		      ldx	#0	; Start of bytes to copy
    554  198e				   pushLoop
    555  198e		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    556  1990		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    557  1992		       c8		      iny		; Next destination
    558  1993		       e8		      inx		; Next Source byte
    559  1994		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    560  1996		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    561  1998
    562  1998		       a9 01	   pushDone   lda	#GOSUB_RTN	; Type of stack entry
    563  199a		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    564  199c		       c8		      iny		; Next entry
    565  199d
    566  199d		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    567  199f		       ac 27 2c 	      ldy	rtemp1
    568  19a2		       18		      clc
    569  19a3		       60		      rts
    570  19a4				   pusherr
    571  19a4		       38		      sec
    572  19a5		       60		      rts
    573  19a6							;=====================================================
    574  19a6							; This pops Top Off gosub call Stack and
    575  19a6							; places it in CURPTR/CUROFF.
    576  19a6							; This checks if the type = 1 GOSUB
    577  19a6							; if not it removes what ever is on the stack
    578  19a6							; until it finds the next return. Allowing
    579  19a6							; a return from within a for/next
    580  19a6		       8c 27 2c    popLN      sty	rtemp1
    581  19a9		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    582  19ab		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    583  19ad
    584  19ad				   popContinue
    585  19ad		       c0 04		      cpy	#4	; if less than 4 on stack then error
    586  19af		       90 18		      bcc	poperr	; Process an error
    587  19b1
    588  19b1		       88		      dey		; Position to read entry type
    589  19b2		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    590  19b4		       c9 01		      cmp	#1	; Type is a gosub entry
    591  19b6		       d0 13		      bne	popSkipEntry	; No then just skip this
    592  19b8
    593  19b8				   popLoop
    594  19b8		       88		      dey
    595  19b9		       ca		      dex
    596  19ba		       b1 4b		      lda	(GOSUBSTACK),y
    597  19bc		       95 4f		      sta	CURPTR,x
    598  19be		       e0 00		      cpx	#0
    599  19c0		       d0 f6		      bne	popLoop	; Loop until all moved
    600  19c2
    601  19c2
    602  19c2		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    603  19c4		       ac 27 2c 	      ldy	rtemp1
    604  19c7		       18		      clc
    605  19c8		       60		      rts
    606  19c9
    607  19c9		       38	   poperr     sec
    608  19ca		       60		      rts
    609  19cb
    610  19cb		       88	   popSkipEntry dey
    611  19cc		       88		      dey
    612  19cd		       88		      dey
    613  19ce		       4c ad 19 	      jmp	popContinue
    614  19d1
    615  19d1							;
    616  19d1							;=====================================================
    617  19d1							; This pushes R1 onto the stack
    618  19d1							;
    619  19d1		       8c 27 2c    pushR1     sty	rtemp1
    620  19d4		       a4 4a		      ldy	MATHSTACKPTR
    621  19d6		       c0 28		      cpy	#MATHSTACKSIZE<<1
    622  19d8		       b0 ef		      bcs	poperr
    623  19da		       a5 54		      lda	R1
    624  19dc		       91 48		      sta	(MATHSTACK),y
    625  19de		       c8		      iny
    626  19df		       a5 55		      lda	R1+1
    627  19e1		       91 48		      sta	(MATHSTACK),y
    628  19e3		       c8		      iny
    629  19e4		       84 4a		      sty	MATHSTACKPTR
    630  19e6		       ac 27 2c 	      ldy	rtemp1
    631  19e9		       18		      clc
    632  19ea		       60		      rts
    633  19eb							;
    634  19eb							;=====================================================
    635  19eb							; This pops Top Of Stack and places it in R0.
    636  19eb							;
    637  19eb		       8c 27 2c    popR0      sty	rtemp1
    638  19ee		       a4 4a		      ldy	MATHSTACKPTR
    639  19f0		       f0 d7		      beq	poperr
    640  19f2		       88		      dey
    641  19f3		       b1 48		      lda	(MATHSTACK),y
    642  19f5		       85 53		      sta	R0+1
    643  19f7		       88		      dey
    644  19f8		       b1 48		      lda	(MATHSTACK),y
    645  19fa		       85 52		      sta	R0
    646  19fc		       84 4a		      sty	MATHSTACKPTR
    647  19fe		       ac 27 2c 	      ldy	rtemp1
    648  1a01		       18		      clc
    649  1a02		       60		      rts
    650  1a03
    651  1a03							;
    652  1a03							;=====================================================
    653  1a03							; This pops TOS and places it in R1.
    654  1a03							;
    655  1a03		       8c 27 2c    popR1      sty	rtemp1
    656  1a06		       a4 4a		      ldy	MATHSTACKPTR
    657  1a08		       f0 bf		      beq	poperr
    658  1a0a		       88		      dey
    659  1a0b		       b1 48		      lda	(MATHSTACK),y
    660  1a0d		       85 55		      sta	R1+1
    661  1a0f		       88		      dey
    662  1a10		       b1 48		      lda	(MATHSTACK),y
    663  1a12		       85 54		      sta	R1
    664  1a14		       84 4a		      sty	MATHSTACKPTR
    665  1a16		       ac 27 2c 	      ldy	rtemp1
    666  1a19		       60		      rts
    667  1a1a							;
    668  1a1a							;=====================================================
    669  1a1a							; This pops TOS and places it in MQ.
    670  1a1a							;
    671  1a1a		       8c 27 2c    popMQ      sty	rtemp1
    672  1a1d		       a4 4a		      ldy	MATHSTACKPTR
    673  1a1f		       f0 a8		      beq	poperr
    674  1a21		       88		      dey
    675  1a22		       b1 48		      lda	(MATHSTACK),y
    676  1a24		       85 57		      sta	MQ+1
    677  1a26		       88		      dey
    678  1a27		       b1 48		      lda	(MATHSTACK),y
    679  1a29		       85 56		      sta	MQ
    680  1a2b		       84 4a		      sty	MATHSTACKPTR
    681  1a2d		       ac 27 2c 	      ldy	rtemp1
    682  1a30		       60		      rts
    683  1a31							;
    684  1a31							;=====================================================
    685  1a31							; This assists with multiplication and division by
    686  1a31							; looking at R0 and R1 and saving a flag as to what
    687  1a31							; sign the result will be.  Math is always done on
    688  1a31							; positive numbers, so this converts negative numbers
    689  1a31							; into positives.  On exit, R0 and R1 are both
    690  1a31							; positive.  If the signs were different then 'signs'
    691  1a31							; will be non-zero.
    692  1a31							;
    693  1a31		       a9 00	   SaveSigns  lda	#0
    694  1a33		       8d 26 2c 	      sta	sign	;assume positive
    695  1a36		       a5 53		      lda	R0+1	;MSB
    696  1a38		       10 13		      bpl	SaveSigns1
    697  1a3a		       ee 26 2c 	      inc	sign	;it's negative
    698  1a3d		       49 ff		      eor	#$ff	;flip bits
    699  1a3f		       85 53		      sta	R0+1
    700  1a41		       a5 52		      lda	R0
    701  1a43		       49 ff		      eor	#$ff
    702  1a45		       85 52		      sta	R0
    703  1a47		       e6 52		      inc	R0
    704  1a49		       d0 02		      bne	SaveSigns1
    705  1a4b		       e6 53		      inc	R0+1
    706  1a4d		       a5 55	   SaveSigns1 lda	R1+1
    707  1a4f		       10 1a		      bpl	SaveSigns2
    708  1a51		       48		      pha
    709  1a52		       ad 26 2c 	      lda	sign
    710  1a55		       49 01		      eor	#1
    711  1a57		       8d 26 2c 	      sta	sign
    712  1a5a		       68		      pla
    713  1a5b		       49 ff		      eor	#$ff	;flip bits
    714  1a5d		       85 55		      sta	R1+1
    715  1a5f		       a5 54		      lda	R1
    716  1a61		       49 ff		      eor	#$ff
    717  1a63		       85 54		      sta	R1
    718  1a65		       e6 54		      inc	R1
    719  1a67		       d0 02		      bne	SaveSigns2
    720  1a69		       e6 55		      inc	R1+1
    721  1a6b		       60	   SaveSigns2 rts
    722  1a6c							;
    723  1a6c							;=====================================================
    724  1a6c							; This looks at the value of 'signs' and will convert
    725  1a6c							; both R0 and R1 to negative if set.
    726  1a6c							;
    727  1a6c				   RestoreSigns
    728  1a6c		       ad 26 2c 	      lda	sign
    729  1a6f		       f0 28		      beq	restoresigns2
    730  1a71							;
    731  1a71		       a5 52		      lda	R0
    732  1a73		       d0 02		      bne	restoresigns3
    733  1a75		       c6 53		      dec	R0+1
    734  1a77				   restoresigns3
    735  1a77		       c6 52		      dec	R0
    736  1a79		       a5 52		      lda	R0
    737  1a7b		       49 ff		      eor	#$ff
    738  1a7d		       85 52		      sta	R0
    739  1a7f		       a5 53		      lda	R0+1
    740  1a81		       49 ff		      eor	#$ff
    741  1a83		       85 53		      sta	R0+1
    742  1a85							;
    743  1a85		       a5 54		      lda	R1
    744  1a87		       d0 02		      bne	restoresigns4
    745  1a89		       c6 55		      dec	R1+1
    746  1a8b				   restoresigns4
    747  1a8b		       c6 54		      dec	R1
    748  1a8d		       a5 54		      lda	R1
    749  1a8f		       49 ff		      eor	#$ff
    750  1a91		       85 54		      sta	R1
    751  1a93		       a5 55		      lda	R1+1
    752  1a95		       49 ff		      eor	#$ff
    753  1a97		       85 55		      sta	R1+1
    754  1a99							;
    755  1a99				   restoresigns2
    756  1a99		       60		      rts
    757  1a9a							;
    758  1a9a							;=====================================================
    759  1a9a							; Skip over spaces.  Returns Y with the offset to
    760  1a9a							; either the last character in the line, or the first
    761  1a9a							; non-space character.
    762  1a9a							;
    763  1a9a
    764  1a9a		       c8	   skipsp2    iny
    765  1a9b		       b1 4f	   SkipSpaces lda	(CURPTR),y
    766  1a9d		       f0 04		      beq	Skip3	;end of line
    767  1a9f		       c9 20		      cmp	#SPACE
    768  1aa1		       f0 f7		      beq	skipsp2
    769  1aa3		       60	   Skip3      rts
    770  1aa4							;*********************************************************
    771  1aa4							; Output a CR/LF combination to the console.  Preserves
    772  1aa4							; all registers.
    773  1aa4							;
    774  1aa4		       48	   tbcrlf     pha
    775  1aa5		       a9 0d		      lda	#CR
    776  1aa7		       20 ed 1b 	      jsr	VOUTCH
    777  1aaa		       a9 0a		      lda	#LF
    778  1aac		       20 ed 1b 	      jsr	VOUTCH
    779  1aaf		       68		      pla
    780  1ab0		       60		      rts
    781  1ab1							;
    782  1ab1							;=====================================================
    783  1ab1							; Some logic to print the Line of basic code being executed
    784  1ab1		       24 40	   idbgBasic  bit	ILTrace
    785  1ab3		       50 70		      bvc	dbgBasicNone
    786  1ab5		       98		      tya
    787  1ab6		       48		      pha
    788  1ab7		       20 76 1c 	      jsr	SetOutDebug
    789  1aba		       20 16 1c 	      jsr	PrtPrgLine
    790  1abd		       20 a4 1a 	      jsr	CRLF
    791  1ac0		       a5 40		      lda	ILTrace
    792  1ac2		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    793  1ac4		       f0 5a		      beq	dbgBasicDone
    794  1ac6		       20 81 1c 	      jsr	SetInDebug
    795  1ac9		       20 f3 1b 	      jsr	puts
      0  1acc					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  1acc		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    797  1b09				   dbgBasicLoop
    798  1b09		       20 f0 1b 	      jsr	VGETCH
    799  1b0c		       20 a4 1a 	      jsr	CRLF
    800  1b0f		       20 e0 1b 	      jsr	SetInConsole
    801  1b12
    802  1b12		       c9 73		      cmp	#'s	; Quit program
    803  1b14		       f0 12		      beq	dbgBasicStop
    804  1b16
    805  1b16		       c9 64		      cmp	#'d	; Display Variables
    806  1b18		       d0 06		      bne	dbgBasicDone
    807  1b1a
    808  1b1a		       20 a5 1c 	      jsr	PrintAllVars
    809  1b1d		       18		      clc
    810  1b1e		       90 e9		      bcc	dbgBasicLoop	; Next char
    811  1b20
    812  1b20		       20 d3 1b    dbgBasicDone jsr	SetOutConsole
    813  1b23		       68		      pla
    814  1b24		       a8		      tay
    815  1b25		       4c bb 02    dbgBasicNone jmp	NextIL
    816  1b28
    817  1b28				   dbgBasicStop
    818  1b28		       20 d3 1b 	      jsr	SetOutConsole
    819  1b2b		       68		      pla
    820  1b2c		       a8		      tay
    821  1b2d		       4c 01 06 	      jmp	iFIN
    822  1b30							;
    823  1b30							;=====================================================
    824  1b30							; This is some debug logic which displays the current
    825  1b30							; value of the ILPC and the line buffer.
    826  1b30							;
    827  1b30		       24 40	   dbgLine    bit	ILTrace
    828  1b32		       30 01		      bmi	dbgPrt
    829  1b34		       60		      rts
    830  1b35				   dbgPrt
    831  1b35		       20 76 1c 	      jsr	SetOutDebug
    832  1b38		       20 f3 1b 	      jsr	puts
      0  1b3b					      db	"ILPC: ",0
      1  1b3b		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    834  1b42		       a5 44		      lda	ILPC+1
    835  1b44		       20 92 12 	      jsr	OUTHEX
    836  1b47		       a5 43		      lda	ILPC
    837  1b49		       20 92 12 	      jsr	OUTHEX
    838  1b4c		       a9 20		      lda	#SPACE
    839  1b4e		       20 ed 1b 	      jsr	VOUTCH
    840  1b51		       a0 00		      ldy	#0
    841  1b53		       b1 43		      lda	(ILPC),y
    842  1b55		       20 92 12 	      jsr	OUTHEX
    843  1b58							;
    844  1b58							; Display the CURPTR value and offset
    845  1b58							;
    846  1b58		       20 f3 1b 	      jsr	puts
      0  1b5b					      db	", CURPTR: ",0
      1  1b5b		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    848  1b66		       a5 50		      lda	CURPTR+1
    849  1b68		       20 92 12 	      jsr	OUTHEX
    850  1b6b		       a5 4f		      lda	CURPTR
    851  1b6d		       20 92 12 	      jsr	OUTHEX
    852  1b70		       a9 2b		      lda	#'+
    853  1b72		       20 ed 1b 	      jsr	VOUTCH
    854  1b75		       a5 51		      lda	CUROFF
    855  1b77		       20 92 12 	      jsr	OUTHEX
    856  1b7a							;
    857  1b7a		       20 a4 1a 	      jsr	CRLF
    858  1b7d		       20 d3 1b 	      jsr	SetOutConsole
    859  1b80		       20 b3 1b 	      jsr	ILChkRange
    860  1b83		       b0 02		      bcs	dbgLineErr
    861  1b85		       18		      clc
    862  1b86		       60		      rts
    863  1b87
    864  1b87				   dbgLineErr
    865  1b87		       20 76 1c 	      jsr	SetOutDebug
    866  1b8a		       20 f3 1b 	      jsr	puts
      0  1b8d					      db	"Outside Valid IL Address Range",CR,LF,0
      1  1b8d		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    868  1bae		       20 d3 1b 	      jsr	SetOutConsole
    869  1bb1		       38		      sec
    870  1bb2		       60		      rts
    871  1bb3
    872  1bb3		       a5 44	   ILChkRange lda	ILPC+1
    873  1bb5		       c9 1d		      cmp	#IL>>8
    874  1bb7		       90 18		      bcc	ILBadRange
    875  1bb9		       d0 06		      bne	ILChkHigh
    876  1bbb
    877  1bbb		       a5 43		      lda	ILPC
    878  1bbd		       c9 fd		      cmp	#IL&$ff
    879  1bbf		       90 10		      bcc	ILBadRange
    880  1bc1
    881  1bc1		       a5 44	   ILChkHigh  lda	ILPC+1
    882  1bc3		       c9 22		      cmp	#ILEND>>8
    883  1bc5		       90 08		      bcc	ILGoodRange
    884  1bc7		       d0 08		      bne	ILBadRange
    885  1bc9
    886  1bc9		       a5 43		      lda	ILPC
    887  1bcb		       c9 c9		      cmp	#ILEND&$ff
    888  1bcd		       b0 02		      bcs	ILBadRange
    889  1bcf
    890  1bcf		       18	   ILGoodRange clc
    891  1bd0		       60		      rts
    892  1bd1				   ILBadRange
    893  1bd1		       38		      sec
    894  1bd2		       60		      rts
    895  1bd3
    896  1bd3
    897  1bd3							;=====================================================
    898  1bd3							; Set output vector to the console output function
    899  1bd3							;
    900  1bd3				   SetOutConsole
    901  1bd3		       48		      pha
    902  1bd4		       a9 0c		      lda	#OUTCH&$ff
    903  1bd6		       8d 2b 2c 	      sta	BOutVec
    904  1bd9		       a9 f0		      lda	#OUTCH>>8
    905  1bdb		       8d 2c 2c 	      sta	BOutVec+1
    906  1bde		       68		      pla
    907  1bdf		       60		      rts
    908  1be0
    909  1be0				   SetInConsole
    910  1be0		       48		      pha
    911  1be1		       a9 09		      lda	#GETCH&$ff
    912  1be3		       8d 2d 2c 	      sta	BInVec
    913  1be6		       a9 f0		      lda	#GETCH>>8
    914  1be8		       8d 2e 2c 	      sta	BInVec+1
    915  1beb		       68		      pla
    916  1bec		       60		      rts
    917  1bed
    918  1bed							;=====================================================
    919  1bed							; Jump to the output/input function in BOutVec/BInVec
    920  1bed							;
    921  1bed		       6c 2b 2c    VOUTCH     jmp	(BOutVec)
    922  1bf0		       6c 2d 2c    VGETCH     jmp	(BInVec)
    923  1bf3							;
    924  1bf3							;=====================================================
    925  1bf3							; Print the string that immediately follows the JSR to
    926  1bf3							; this function.  Stops when a null byte is found,
    927  1bf3							; then returns to the instruction immediately
    928  1bf3							; following the null.
    929  1bf3							;
    930  1bf3							; Thanks to Ross Archer for this code.
    931  1bf3							; http://www.6502.org/source/io/primm.htm
    932  1bf3							;
    933  1bf3
    934  1bf3		       68	   tbputs     pla		;Get the low part of "return" address
    935  1bf4							;(data start address)
    936  1bf4		       85 5e		      sta	PrtFrom
    937  1bf6		       68		      pla
    938  1bf7		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    939  1bf9							;(data start address)
    940  1bf9							;Note: actually we're pointing one short
    941  1bf9		       a0 01	   PSINB      ldy	#1
    942  1bfb		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    943  1bfd		       e6 5e		      inc	PrtFrom	;update the pointer
    944  1bff		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    945  1c01		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    946  1c03		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    947  1c05							;   Accumulator
    948  1c05		       f0 06		      beq	PSIX1	;don't print the final NULL
    949  1c07		       20 ed 1b 	      jsr	VOUTCH	;write it out
    950  1c0a		       4c f9 1b 	      jmp	PSINB	;back around
    951  1c0d		       e6 5e	   PSIX1      inc	PrtFrom
    952  1c0f		       d0 02		      bne	PSIX2
    953  1c11		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    954  1c13		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    955  1c16
    956  1c16							;
    957  1c16
    958  1c16							;====================================================
    959  1c16		       2c 2f	   PrtTerm    equ	tempy
    960  1c16
    961  1c16							; on exit Print Y has the offset to use
    962  1c16							; input y =	 addr low
    963  1c16							;	 x =	 addr high
    964  1c16							;	 a =	 termination string
    965  1c16
    966  1c16				   PrtPrgLine
    967  1c16		       a9 00		      lda	#0
    968  1c18		       8d 2f 2c 	      sta	PrtTerm
    969  1c1b		       f0 05		      beq	PrtPrgText
    970  1c1d
    971  1c1d		       a9 22	   PrtQuoted  lda	#'"
    972  1c1f		       8d 2f 2c 	      sta	PrtTerm
    973  1c22
    974  1c22		       a4 51	   PrtPrgText ldy	CUROFF
    975  1c24		       a5 4f		      lda	CURPTR
    976  1c26		       85 5e		      sta	PrtFrom
    977  1c28		       a5 50		      lda	CURPTR+1
    978  1c2a		       85 5f		      sta	PrtFrom+1
    979  1c2c		       4c 38 1c 	      jmp	PrtLoop
    980  1c2f
    981  1c2f							; Print a string pointed to by x= h, y=l terminated by a
    982  1c2f							; Return y as the length
    983  1c2f
    984  1c2f		       86 5f	   PrtStr     stx	PrtFrom+1
    985  1c31		       84 5e		      sty	PrtFrom
    986  1c33		       8d 2f 2c 	      sta	PrtTerm
    987  1c36		       a0 00		      ldy	#0
    988  1c38							;
    989  1c38							; On entry here ptrfrom and prtterm point to area to print
    990  1c38							;
    991  1c38		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    992  1c3a		       cd 2f 2c 	      cmp	PrtTerm
    993  1c3d		       f0 0b		      beq	PrtEnd
    994  1c3f		       c9 00		      cmp	#0	; always end if 0 is found
    995  1c41		       f0 07		      beq	PrtEnd
    996  1c43		       20 ed 1b 	      jsr	VOUTCH
    997  1c46		       c8		      iny
    998  1c47		       4c 38 1c 	      jmp	PrtLoop
    999  1c4a		       c8	   PrtEnd     iny		;return byte after the copy
   1000  1c4b		       60		      rts
   1001  1c4c
   1002  1c4c							;====================================================
   1003  1c4c							;Clear the terminal assume it is ansii or vt100
   1004  1c4c							;
   1005  1c4c				   iCLEARSCREEN
   1006  1c4c		       20 f3 1b 	      jsr	puts
      0  1c4f					      db	$1b,'[,'2,'J,0
      1  1c4f		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
   1008  1c54		       4c bb 02 	      jmp	NextIL
   1009  1c57
   1010  1c57							;====================================================
   1011  1c57							; Push true and false onto math stack
   1012  1c57				   pushTrue
   1013  1c57		       a9 ff		      lda	#$ff
   1014  1c59		       85 52	   pushTF     sta	R0
   1015  1c5b		       85 53		      sta	R0+1
   1016  1c5d		       20 67 19 	      jsr	pushR0
   1017  1c60		       60		      rts
   1018  1c61		       a9 00	   pushFalse  lda	#0
   1019  1c63		       f0 f4		      beq	pushTF
   1020  1c65
   1021  1c65							;======================================================
   1022  1c65							; Copy stack top to R1
   1023  1c65				   CopyStackR1
   1024  1c65		       98		      tya
   1025  1c66		       48		      pha
   1026  1c67		       a4 4a		      ldy	MATHSTACKPTR
   1027  1c69		       88		      dey
   1028  1c6a		       b1 48		      lda	(MATHSTACK),y
   1029  1c6c		       85 55		      sta	R1+1
   1030  1c6e		       88		      dey
   1031  1c6f		       b1 48		      lda	(MATHSTACK),y
   1032  1c71		       85 54		      sta	R1
   1033  1c73		       68		      pla
   1034  1c74		       a8		      tay
   1035  1c75		       60		      rts
   1036  1c76
   1037  1c76
   1038  1c76							;====================================================
   1039  1c76							;Swap the out debug call for standard calls
   1040  1c76
   1041  1c76				   SetOutDebug
   1042  1c76					      if	USEDEBUGPORT
   1043  1c76		       a9 96		      lda	#OUTDEBUG&$ff	; Put the Debug output
   1044  1c78		       8d 2b 2c 	      sta	BOutVec
   1045  1c7b		       a9 1c		      lda	#OUTDEBUG>>8
   1046  1c7d		       8d 2c 2c 	      sta	BOutVec+1
   1047  1c80					      endif
   1048  1c80		       60		      rts
   1049  1c81				   SetInDebug
   1050  1c81					      if	USEDEBUGPORT
   1051  1c81		       a9 9a		      lda	#INDEBUG&$ff
   1052  1c83		       8d 2d 2c 	      sta	BInVec
   1053  1c86		       a9 1c		      lda	#INDEBUG>>8
   1054  1c88		       8d 2e 2c 	      sta	BInVec+1
   1055  1c8b					      endif
   1056  1c8b		       60		      rts
   1057  1c8c							;
   1058  1c8c							;====================================================
   1059  1c8c							; Output to the debug console
   1060  1c8c							;     x = high address byte
   1061  1c8c							;     y = low address byte
   1062  1c8c							;     a = Terminator for string
   1063  1c8c				   DebugWrite
   1064  1c8c		       20 76 1c 	      jsr	SetOutDebug
   1065  1c8f		       20 2f 1c 	      jsr	PrtStr
   1066  1c92		       20 d3 1b 	      jsr	SetOutConsole
   1067  1c95		       60		      rts
   1068  1c96
   1069  1c96				   OUTDEBUG
   1070  1c96		       8d 21 e0 	      sta	DEBUGPORT+1	;Dont check anything just output the byte
   1071  1c99		       60		      RTS
   1072  1c9a
   1073  1c9a		       ad 20 e0    INDEBUG    lda	DEBUGPORT
   1074  1c9d		       29 01		      and	#$01
   1075  1c9f		       f0 f9		      beq	INDEBUG
   1076  1ca1		       ad 21 e0 	      lda	DEBUGPORT+1
   1077  1ca4		       60		      rts
   1078  1ca5							;
   1079  1ca5							;=======================================================
   1080  1ca5							; Print all Variables
   1081  1ca5				   PrintAllVars
   1082  1ca5		       a0 00		      ldy	#0
   1083  1ca7		       a9 41		      lda	#'A
   1084  1ca9				   PrintAllVarsLoop
   1085  1ca9		       48		      pha
   1086  1caa		       b1 41		      lda	(VARIABLES),y
   1087  1cac		       85 52		      sta	R0
   1088  1cae		       c8		      iny
   1089  1caf		       b1 41		      lda	(VARIABLES),y
   1090  1cb1		       85 53		      sta	R0+1
   1091  1cb3
   1092  1cb3		       68		      pla		;get the current letter
   1093  1cb4		       48		      pha
   1094  1cb5		       20 ed 1b 	      jsr	VOUTCH
   1095  1cb8		       20 f3 1b 	      jsr	puts
      0  1cbb					      db	"=",0
      1  1cbb		       3d 00		      .byte.b	"=",0
   1097  1cbd		       68		      pla
   1098  1cbe		       aa		      tax
   1099  1cbf		       e8		      inx
   1100  1cc0		       8a		      txa
   1101  1cc1		       48		      pha		;
   1102  1cc2
   1103  1cc2		       98		      tya
   1104  1cc3		       48		      pha
   1105  1cc4		       20 e0 11 	      jsr	PrintDecimal
   1106  1cc7		       20 f3 1b 	      jsr	puts
      0  1cca					      db	" ",0
      1  1cca		       20 00		      .byte.b	" ",0
   1108  1ccc		       68		      pla
   1109  1ccd		       a8		      tay
   1110  1cce		       c8		      iny
   1111  1ccf		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
   1112  1cd1		       90 d6		      bcc	PrintAllVarsLoop
   1113  1cd3		       20 a4 1a 	      jsr	CRLF
   1114  1cd6
   1115  1cd6		       68		      pla
   1116  1cd7		       60		      rts
   1117  1cd8
   1118  1cd8
   1119  1cd8
   1120  1cd8
   1121  1cd8
   1122  1cd8
   1123  1cd8
   1124  1cd8
   1125  1cd8
   1126  1cd8
   1127  1cd8
   1128  1cd8
   1129  1cd8
   1130  1cd8
   1131  1cd8
   1132  1cd8
   1133  1cd8
   1134  1cd8
   1135  1cd8
------- FILE mytb.asm
   2215  1cd8
   2216  1cd8					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  1cd8					      include	"storage.asm"
      1  1cd8							;
      2  1cd8							;=====================================================
      3  1cd8							;=====================================================
      4  1cd8							;=====================================================
      5  1cd8							; This file contains the functions for saving and
      6  1cd8							; restoring programs from some sort of mass storage
      7  1cd8							; device.  This particular version is for using the
      8  1cd8							; Corsham Tech SD Card System.
      9  1cd8							;=====================================================
     10  1cd8							;=====================================================
     11  1cd8							;=====================================================
     12  1cd8
     13 U22c9					      seg.u	TBData
     14 U22c9		       00	   diskBufLength ds	1
     15 U22ca		       00	   diskBufOffset ds	1
     16 U22cb		       00 00 00 00*DiskFileName ds	14
     17 U22d9
     18  1cd8					      SEG	Code
     19  1cd8
     20  1cd8							;
     21  1cd8							;=====================================================
     22  1cd8							; Open a file for reading as a program.  The next
     23  1cd8							; thing on the line should be the filename.
     24  1cd8							;
     25  1cd8				   iOPENREAD
     26  1cd8					      if	XKIM || CTMON65
     27  1cd8		       a4 51		      ldy	CUROFF
     28  1cda		       b1 4f		      lda	(CURPTR),y
     29  1cdc		       d0 07		      bne	iOPENfn	;might be filename
     30  1cde							;
     31  1cde							; No filename supplied.
     32  1cde							;
     33  1cde		       a9 00	   iOPENnofn  lda	#0
     34  1ce0		       a2 09		      ldx	#ERR_NO_FILENAME
     35  1ce2		       4c 18 06 	      jmp	iErr2
     36  1ce5							;
     37  1ce5							; Add the offset into the buffer start
     38  1ce5							;
     39  1ce5		       18	   iOPENfn    clc
     40  1ce6		       98		      tya
     41  1ce7		       65 4f		      adc	CURPTR
     42  1ce9		       a8		      tay		;LSB
     43  1cea		       a5 50		      lda	CURPTR+1
     44  1cec		       69 00		      adc	#0
     45  1cee		       aa		      tax
     46  1cef		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  1cf2		       90 07		      bcc	Ropenok	;branch if opened ok
     48  1cf4							;
     49  1cf4							; Open failed
     50  1cf4							;
     51  1cf4		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1cf6		       a9 00	   Rdfail2    lda	#0
     53  1cf8		       4c 18 06 	      jmp	iErr2
     54  1cfb							;
     55  1cfb							; Clear counts and offsets so the next read will
     56  1cfb							; cause the file to be read.
     57  1cfb							;
     58  1cfb		       a9 00	   Ropenok    lda	#0
     59  1cfd		       8d ca 22 	      sta	diskBufOffset
     60  1d00		       8d c9 22 	      sta	diskBufLength
     61  1d03		       4c bb 02 	      jmp	NextIL
     62  1d06					      endif
     63  1d06
     64  1d06							;
     65  1d06							;==============================JUSTLOSTINTIME 08/02/2022========
     66  1d06							;Remove a file from the disk
     67  1d06				   iRMFILE
     68  1d06					      if	XKIM || CTMON65
     69  1d06		       a4 51		      ldy	CUROFF
     70  1d08		       b1 4f		      lda	(CURPTR),y
     71  1d0a		       f0 19		      beq	iRMnofn
     72  1d0c							;
     73  1d0c		       18		      clc
     74  1d0d		       98		      tya
     75  1d0e		       65 4f		      adc	CURPTR
     76  1d10		       a8		      tay		;LSB
     77  1d11		       a5 50		      lda	CURPTR+1
     78  1d13		       69 00		      adc	#0
     79  1d15		       aa		      tax
     80  1d16		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1d19		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1d1b		       a9 00		      lda	#0
     83  1d1d		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  1d1f		       4c 18 06 	      jmp	iErr2
     85  1d22		       4c bb 02    wrmOk      jmp	NextIL
     86  1d25
     87  1d25							; No filename supplied.
     88  1d25							;
     89  1d25		       a9 00	   iRMnofn    lda	#0
     90  1d27		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1d29		       4c 18 06 	      jmp	iErr2
     92  1d2c					      endif
     93  1d2c							;
     94  1d2c							;=====================================================
     95  1d2c				   iOPENWRITE
     96  1d2c					      if	XKIM || CTMON65
     97  1d2c		       a4 51		      ldy	CUROFF
     98  1d2e		       b1 4f		      lda	(CURPTR),y
     99  1d30		       f0 f3		      beq	iRMnofn
    100  1d32							;
    101  1d32		       18		      clc
    102  1d33		       98		      tya
    103  1d34		       65 4f		      adc	CURPTR
    104  1d36		       a8		      tay		;LSB
    105  1d37		       a5 50		      lda	CURPTR+1
    106  1d39		       69 00		      adc	#0
    107  1d3b		       aa		      tax
    108  1d3c		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  1d3f		       90 07		      bcc	Wopenok	;branch if opened ok
    110  1d41							;
    111  1d41							; Open failed
    112  1d41							;
    113  1d41		       a9 00	   Wdfail     lda	#0
    114  1d43		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  1d45		       4c 18 06 	      jmp	iErr2
    116  1d48							;
    117  1d48		       4c bb 02    Wopenok    jmp	NextIL
    118  1d4b					      endif
    119  1d4b							;
    120  1d4b							;=====================================================
    121  1d4b							; Gets a line of input from the disk file and puts it
    122  1d4b							; into LINBUF.
    123  1d4b							;
    124  1d4b							; On exit:
    125  1d4b							;    CURPTR points to LINBUF
    126  1d4b							;    LINBUF contains the line with 0 at the end.
    127  1d4b							;    Y has offset to first non-space character
    128  1d4b							;    CURROFF has the same as Y.
    129  1d4b							;
    130  1d4b				   iDGETLINE
    131  1d4b					      if	XKIM || CTMON65
    132  1d4b		       a2 9a		      ldx	#LINBUF&$ff
    133  1d4d		       86 4f		      stx	CURPTR
    134  1d4f		       a2 2b		      ldx	#LINBUF>>8
    135  1d51		       86 50		      stx	CURPTR+1
    136  1d53							;
    137  1d53		       a2 00		      ldx	#0	;offset
    138  1d55		       8e 1e 2c    iDgetLoop  stx	getlinx
    139  1d58		       20 b6 1d 	      jsr	getNextFileByte
    140  1d5b		       b0 16		      bcs	iGetEOF
    141  1d5d		       c9 0d		      cmp	#CR
    142  1d5f		       f0 0d		      beq	iGetEOL
    143  1d61		       c9 0a		      cmp	#LF
    144  1d63		       f0 09		      beq	iGetEOL
    145  1d65		       ae 1e 2c 	      ldx	getlinx
    146  1d68		       9d 9a 2b 	      sta	LINBUF,x
    147  1d6b		       e8		      inx
    148  1d6c		       d0 e7		      bne	iDgetLoop
    149  1d6e							;
    150  1d6e							; Handle end of line.	If the line has nothing, loop
    151  1d6e							; back and get another line.
    152  1d6e							;
    153  1d6e		       ae 1e 2c    iGetEOL    ldx	getlinx	;blank line?
    154  1d71		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  1d73							;
    156  1d73							; This can fall through when there is a line, or
    157  1d73							; called directly when EOF is encountered.
    158  1d73							;
    159  1d73		       ae 1e 2c    iGetEOF    ldx	getlinx
    160  1d76		       a9 00		      lda	#0
    161  1d78		       9d 9a 2b 	      sta	LINBUF,x
    162  1d7b		       85 51		      sta	CUROFF
    163  1d7d		       a0 00		      ldy	#0
    164  1d7f		       20 9b 1a 	      jsr	SkipSpaces
    165  1d82		       4c bb 02 	      jmp	NextIL
    166  1d85					      endif
    167  1d85
    168  1d85							;
    169  1d85							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  1d85							; DISK
    171  1d85							;
    172  1d85				   iDDIR
    173  1d85					      if	XKIM || CTMON65
    174  1d85		       20 30 f0 	      jsr	DiskDir
    175  1d88							;
    176  1d88							; Get/Display each entry
    177  1d88							;
    178  1d88		       a2 22	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    179  1d8a		       a0 cb		      ldy	#DiskFileName&$ff
    180  1d8c		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  1d8f		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  1d91		       20 f3 1b 	      jsr	puts
      0  1d94					      db	"   ",0
      1  1d94		       20 20 20 00	      .byte.b	"   ",0
    184  1d98							; Print the line to the console
    185  1d98		       a2 22		      ldx	#DiskFileName>>8	;pointer to buffer
    186  1d9a		       a0 cb		      ldy	#DiskFileName&$ff
    187  1d9c		       a5 00		      lda	0
    188  1d9e		       20 2f 1c 	      jsr	PrtStr	;else print name
    189  1da1		       20 18 f0 	      jsr	crlf
    190  1da4
    191  1da4		       4c 88 1d 	      jmp	DiskDirLoop	;do next entry
    192  1da7
    193  1da7		       4c bb 02    DiskDirEnd jmp	NextIL
    194  1daa					      endif
    195  1daa							;
    196  1daa							;=====================================================
    197  1daa							; Does a LIST to a Disk file.
    198  1daa							;
    199  1daa				   iDLIST
    200  1daa					      if	XKIM || CTMON65
    201  1daa		       20 e5 1d 	      jsr	SetOutDisk
    202  1dad		       4c e8 07 	      jmp	iLST2
    203  1db0					      endif
    204  1db0							;
    205  1db0							;=====================================================
    206  1db0							; Closes any pending disk file.  Okay to call if there
    207  1db0							; is no open file.
    208  1db0							;
    209  1db0				   iDCLOSE
    210  1db0					      if	XKIM || CTMON65
    211  1db0		       20 42 f0 	      jsr	DiskClose
    212  1db3		       4c bb 02 	      jmp	NextIL
    213  1db6					      endif
    214  1db6							;
    215  1db6							;=====================================================
    216  1db6							; This gets the next byte from an open disk file.  If
    217  1db6							; there are no more bytes left, this returns C set.
    218  1db6							; Else, C is clear and A contains the character.
    219  1db6							;
    220  1db6				   getNextFileByte
    221  1db6					      if	XKIM || CTMON65
    222  1db6		       ae ca 22 	      ldx	diskBufOffset
    223  1db9		       ec c9 22 	      cpx	diskBufLength
    224  1dbc		       d0 14		      bne	hasdata	;branch if still data
    225  1dbe							;
    226  1dbe							; There is no data left in the buffer, so read a
    227  1dbe							; block from the SD system.
    228  1dbe							;
    229  1dbe		       a9 84		      lda	#BUFFER_SIZE
    230  1dc0		       a2 df		      ldx	#buffer>>8
    231  1dc2		       a0 0a		      ldy	#buffer&$ff
    232  1dc4		       20 3c f0 	      jsr	DiskRead
    233  1dc7		       b0 12		      bcs	getNextEof
    234  1dc9							;
    235  1dc9							; A contains the number of bytes actually read.
    236  1dc9							;
    237  1dc9		       8d c9 22 	      sta	diskBufLength	;save length
    238  1dcc		       c9 00		      cmp	#0	;shouldn't happen
    239  1dce		       f0 0b		      beq	getNextEof
    240  1dd0							;
    241  1dd0		       a2 00		      ldx	#0
    242  1dd2		       bd 0a df    hasdata    lda	buffer,x
    243  1dd5		       e8		      inx
    244  1dd6		       8e ca 22 	      stx	diskBufOffset
    245  1dd9		       18		      clc
    246  1dda		       60		      rts
    247  1ddb							;
    248  1ddb		       a9 00	   getNextEof lda	#0
    249  1ddd		       8d ca 22 	      sta	diskBufOffset
    250  1de0		       8d c9 22 	      sta	diskBufLength
    251  1de3		       38		      sec
    252  1de4		       60		      rts
    253  1de5							;
    254  1de5							;=====================================================
    255  1de5							; Set output vector to the disk output function
    256  1de5							;
    257  1de5		       a9 f0	   SetOutDisk lda	#DOUT&$ff
    258  1de7		       8d 2b 2c 	      sta	BOutVec
    259  1dea		       a9 1d		      lda	#DOUT/256
    260  1dec		       8d 2c 2c 	      sta	BOutVec+1
    261  1def		       60		      rts
    262  1df0							;
    263  1df0							;=====================================================
    264  1df0
    265  1df0		       8d 0a df    DOUT       sta	buffer
    266  1df3		       a9 01		      lda	#1
    267  1df5		       a0 0a		      ldy	#buffer&$ff
    268  1df7		       a2 df		      ldx	#buffer>>8
    269  1df9		       20 3f f0 	      jsr	DiskWrite
    270  1dfc							;
    271  1dfc							; need error checking here
    272  1dfc							;
    273  1dfc		       60		      rts
    274  1dfd					      endif
    275  1dfd
    276  1dfd
------- FILE mytb.asm
   2218  1dfd					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  1dfd					      include	"IL.inc"
      1  1dfd
      2  1dfd							;=====================================================
      3  1dfd							; IL.inc
      4  1dfd							; These are macros for IL instructions
      5  1dfd							;
      6  1dfd					      mac	dw
      7  1dfd					      .word	{0}
      8  1dfd					      endm
      9  1dfd					      mac	db
     10  1dfd					      .byte	{0}
     11  1dfd					      endm
     12  1dfd					      macro	xinit
     13  1dfd					      db	0
     14  1dfd					      endm		;reset the il to start clear all
     15  1dfd							;
     16  1dfd					      macro	done
     17  1dfd					      db	1
     18  1dfd					      endm		;print an error if not end of line
     19  1dfd							;
     20  1dfd					      macro	prs
     21  1dfd					      db	2
     22  1dfd					      endm		;print a quoted string
     23  1dfd							;
     24  1dfd					      macro	prn
     25  1dfd					      db	3
     26  1dfd					      endm		;print a number
     27  1dfd							;
     28  1dfd					      macro	spc
     29  1dfd					      db	4
     30  1dfd					      endm		;print space til new tabstop
     31  1dfd							;
     32  1dfd					      macro	nline
     33  1dfd					      db	5
     34  1dfd					      endm		;print a new line crlf
     35  1dfd							;
     36  1dfd							; My NXT is a bit different in that it takes one
     37  1dfd							; parameter, which is an address.  If the BASIC
     38  1dfd							; program is currently running then move to the
     39  1dfd							; next line and continue execution.  However, if
     40  1dfd							; in direct mode, jump to the specified IL label.
     41  1dfd							;
     42  1dfd					      macro	nxt
     43  1dfd					      db	6
     44  1dfd					      dw	{1}	; addr
     45  1dfd					      endm		; addr
     46  1dfd							;
     47  1dfd					      macro	xfer
     48  1dfd					      db	7
     49  1dfd					      endm
     50  1dfd							;
     51  1dfd					      macro	sav
     52  1dfd					      db	8
     53  1dfd					      db	{1}
     54  1dfd					      endm
     55  1dfd							;
     56  1dfd					      macro	rstr
     57  1dfd					      db	9
     58  1dfd					      endm
     59  1dfd							;
     60  1dfd					      macro	cmpr
     61  1dfd					      db	10
     62  1dfd					      endm
     63  1dfd							;
     64  1dfd					      macro	innum
     65  1dfd					      db	11
     66  1dfd					      endm
     67  1dfd							;
     68  1dfd					      macro	fin
     69  1dfd					      db	12
     70  1dfd					      endm
     71  1dfd							;
     72  1dfd							; ERR is followed by an error number.	The error
     73  1dfd							; code is printed along with the line number.
     74  1dfd							; Control is passed to the statement set with
     75  1dfd							; the ERRGOTO statement.
     76  1dfd							;
     77  1dfd					      macro	errmsg
     78  1dfd					      db	13
     79  1dfd					      dw	{1}	;ecode
     80  1dfd					      endm		;ecode
     81  1dfd							;
     82  1dfd					      macro	add
     83  1dfd					      db	14
     84  1dfd					      endm
     85  1dfd							;
     86  1dfd					      macro	sub
     87  1dfd					      db	15
     88  1dfd					      endm
     89  1dfd							;
     90  1dfd					      macro	neg
     91  1dfd					      db	16
     92  1dfd					      endm
     93  1dfd							;
     94  1dfd					      macro	mul
     95  1dfd					      db	17
     96  1dfd					      endm
     97  1dfd							;
     98  1dfd					      macro	div
     99  1dfd					      db	18
    100  1dfd					      endm
    101  1dfd							;
    102  1dfd					      macro	store
    103  1dfd					      db	19
    104  1dfd					      endm
    105  1dfd							;
    106  1dfd					      macro	ind
    107  1dfd					      db	20
    108  1dfd					      endm
    109  1dfd							;
    110  1dfd					      macro	lst
    111  1dfd					      db	21
    112  1dfd					      endm
    113  1dfd							;
    114  1dfd					      macro	init
    115  1dfd					      db	22
    116  1dfd					      endm
    117  1dfd							;
    118  1dfd					      macro	getline
    119  1dfd					      db	23
    120  1dfd					      endm
    121  1dfd							;
    122  1dfd					      macro	insert
    123  1dfd					      db	24
    124  1dfd					      endm
    125  1dfd							;
    126  1dfd					      macro	rtn
    127  1dfd					      db	25
    128  1dfd					      endm
    129  1dfd							;
    130  1dfd					      macro	exit
    131  1dfd					      db	26
    132  1dfd					      endm
    133  1dfd							;
    134  1dfd					      macro	lit
    135  1dfd					      db	27
    136  1dfd					      dw	{1}	;value
    137  1dfd					      endm		; value LIT
    138  1dfd							;
    139  1dfd					      macro	call
    140  1dfd					      db	28
    141  1dfd					      dw	{1}	;addr
    142  1dfd					      endm		;addr
    143  1dfd							;
    144  1dfd							; IJMP will set the IL PC to the specified value.
    145  1dfd							;
    146  1dfd					      macro	ijmp
    147  1dfd					      db	29
    148  1dfd					      dw	{1}	;addr
    149  1dfd					      endm		;addr
    150  1dfd							;
    151  1dfd					      macro	vinit
    152  1dfd					      db	30
    153  1dfd					      endm
    154  1dfd							;
    155  1dfd							; ERRGOTO sets the point in the code where the IL
    156  1dfd							; interpreter will go after any error.
    157  1dfd							;
    158  1dfd					      macro	errgoto
    159  1dfd					      db	31
    160  1dfd					      dw	{1}	;addr
    161  1dfd					      endm		;addr
    162  1dfd							;
    163  1dfd					      macro	tst
    164  1dfd					      db	32
    165  1dfd					      db	({1}-*)-1	;(addr-*)-1
    166  1dfd					      db	{2},0	;string,0
    167  1dfd					      endm		;addr,string
    168  1dfd							;
    169  1dfd					      macro	tstv
    170  1dfd					      db	33
    171  1dfd					      db	({1}-*)-1	;(addr-*)-1
    172  1dfd					      endm		;addr
    173  1dfd							;
    174  1dfd					      macro	tstl
    175  1dfd					      db	34
    176  1dfd					      db	({1}-*)-1	;(addr-*)-1
    177  1dfd					      endm		;addr
    178  1dfd							;
    179  1dfd					      macro	tstn
    180  1dfd					      db	35
    181  1dfd					      db	({1}-*)-1	;(addr-*)-1
    182  1dfd					      endm		;addr
    183  1dfd							;
    184  1dfd							; FREE returns the amount of free RAM on top of
    185  1dfd							; the stack.  This is the amount of room the user
    186  1dfd							; program has available.
    187  1dfd							;
    188  1dfd					      macro	free
    189  1dfd					      db	36
    190  1dfd					      endm
    191  1dfd							;
    192  1dfd							; RANDOM takes the top item off the stack and
    193  1dfd							; replaces it with a random number that is
    194  1dfd							; MOD the initial value.  Ie, if the TOS is
    195  1dfd							; 42 then RANDOM returns a value from 0 to 41.
    196  1dfd							;
    197  1dfd					      macro	random
    198  1dfd					      db	37
    199  1dfd					      endm
    200  1dfd							;
    201  1dfd							; ABS will replace the top of stack with the
    202  1dfd							; absolute value.
    203  1dfd							;
    204  1dfd					      macro	abs
    205  1dfd					      db	38
    206  1dfd					      endm
    207  1dfd							;
    208  1dfd							; OPENREAD opens a file for reading, as in getting
    209  1dfd							; statements from it.
    210  1dfd							;
    211  1dfd					      macro	openread
    212  1dfd					      db	39
    213  1dfd					      endm
    214  1dfd							;
    215  1dfd							; OPENWRITE opens a file for writing, as in saving
    216  1dfd							; the current program to it.
    217  1dfd							;
    218  1dfd					      macro	openwrite
    219  1dfd					      db	40
    220  1dfd					      endm
    221  1dfd							;
    222  1dfd							; DCLOSE closes any open disk file.
    223  1dfd							;
    224  1dfd					      macro	dclose
    225  1dfd					      db	41
    226  1dfd					      endm
    227  1dfd							;
    228  1dfd							; DGETLINE gets one line from the disk file and puts it
    229  1dfd							; into LINBUFF.
    230  1dfd							;
    231  1dfd					      macro	dgetline
    232  1dfd					      db	42
    233  1dfd					      endm
    234  1dfd							;
    235  1dfd							; DLIST saves the program to an open disk file.
    236  1dfd							;
    237  1dfd					      macro	dlist
    238  1dfd					      db	43
    239  1dfd					      endm
    240  1dfd							; DDIR list the current directory
    241  1dfd							;
    242  1dfd					      macro	ddir
    243  1dfd					      db	44
    244  1dfd					      endm
    245  1dfd
    246  1dfd							; RMFILE remove a fle from disk
    247  1dfd					      macro	rmfile
    248  1dfd					      db	45
    249  1dfd					      endm
    250  1dfd
    251  1dfd							; CLEARSCREEN clear the screen
    252  1dfd					      macro	clearscreen
    253  1dfd					      db	46
    254  1dfd					      endm
    255  1dfd							; POKEMEM Poke value into memory
    256  1dfd					      macro	pokemem
    257  1dfd					      db	47
    258  1dfd					      endm
    259  1dfd							; PEEKMEM peek at value in memory
    260  1dfd					      macro	peekmem
    261  1dfd					      db	48
    262  1dfd					      endm
    263  1dfd							; TSTLET Test if the statement is a let without the keyword let
    264  1dfd					      macro	tstlet
    265  1dfd					      db	49
    266  1dfd					      db	({1}-*)-1	;(addr-*)-1
    267  1dfd					      endm		;addr
    268  1dfd							; TSTDONE if we reach the end of a statement
    269  1dfd					      macro	tstdone
    270  1dfd					      db	50
    271  1dfd					      db	({1}-*)-1	;(addr-*)-1
    272  1dfd					      endm		;addr
    273  1dfd							; GETCHAR	get a character from the input line leave it in RO
    274  1dfd					      macro	getchar
    275  1dfd					      db	51
    276  1dfd					      endm
    277  1dfd							; PUTCHAR	Put a character to the terminal
    278  1dfd					      macro	putchar
    279  1dfd					      db	52
    280  1dfd					      endm
    281  1dfd							; Call		Call a machine function return a to stack
    282  1dfd					      macro	callfunc
    283  1dfd					      db	53
    284  1dfd					      endm
    285  1dfd
    286  1dfd							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    287  1dfd					      macro	ibranch
    288  1dfd					      db	54
    289  1dfd					      endm
    290  1dfd
    291  1dfd							; TSTSTR	 Tests for the open quote in a string
    292  1dfd					      macro	tststr
    293  1dfd					      db	55
    294  1dfd					      db	({1}-*)-1	;(addr-*)-1
    295  1dfd					      endm
    296  1dfd							; SETIRQ	Sets the line number to run when an irq happens irq 550
    297  1dfd					      macro	setirq
    298  1dfd					      db	56
    299  1dfd					      endm
    300  1dfd
    301  1dfd							; TSTIRQ	Test for irq pending,
    302  1dfd							;		if so push the IRQ LINE NUMBER into RO, onto stack
    303  1dfd					      macro	tstirq
    304  1dfd					      db	57
    305  1dfd					      db	({1}-*)-1	;(addr-*)-1
    306  1dfd					      endm
    307  1dfd
    308  1dfd							; IRET    return from interupt service
    309  1dfd					      macro	iret
    310  1dfd					      db	58
    311  1dfd					      endm
    312  1dfd
    313  1dfd							; INSTR   read a string from the input
    314  1dfd					      macro	instr
    315  1dfd					      db	59
    316  1dfd					      endm
    317  1dfd
    318  1dfd							; MODULO Returns the remainder of the division
    319  1dfd					      macro	modulo
    320  1dfd					      db	60
    321  1dfd					      endm
    322  1dfd							; Set a task line
    323  1dfd					      macro	taskcreate
    324  1dfd					      db	61
    325  1dfd					      endm
    326  1dfd							; End a task
    327  1dfd					      macro	etask
    328  1dfd					      db	62
    329  1dfd					      endm
    330  1dfd							; Skip to next task
    331  1dfd					      macro	ntask
    332  1dfd					      db	63
    333  1dfd					      endm
    334  1dfd							; Subscript
    335  1dfd					      macro	subscript
    336  1dfd					      db	64
    337  1dfd					      endm
    338  1dfd							; KILL Task
    339  1dfd					      macro	taskkill
    340  1dfd					      db	65
    341  1dfd					      endm
    342  1dfd							; STAT Task
    343  1dfd					      macro	taskstat
    344  1dfd					      db	66
    345  1dfd					      endm
    346  1dfd							;  output value as hex
    347  1dfd					      macro	hexprt
    348  1dfd					      db	67
    349  1dfd					      endm
    350  1dfd							;  Read in background has completed
    351  1dfd					      macro	readcomplete
    352  1dfd					      db	68
    353  1dfd					      endm
    354  1dfd							;  ReadInput line
    355  1dfd					      macro	readstart
    356  1dfd					      db	69
    357  1dfd					      endm
    358  1dfd							; Startio request
    359  1dfd					      macro	startio
    360  1dfd					      db	70
    361  1dfd					      endm
    362  1dfd							; Endio
    363  1dfd					      macro	endio
    364  1dfd					      db	71
    365  1dfd					      endm
    366  1dfd							; Logical not
    367  1dfd					      macro	lognot
    368  1dfd					      db	72
    369  1dfd					      endm
    370  1dfd							; Logical OR
    371  1dfd					      macro	logor
    372  1dfd					      db	73
    373  1dfd					      endm
    374  1dfd							;Logical and
    375  1dfd					      macro	logand
    376  1dfd					      db	74
    377  1dfd					      endm
    378  1dfd							;Logical XOR
    379  1dfd					      macro	logxor
    380  1dfd					      db	75
    381  1dfd					      endm
    382  1dfd							;Wait for task to complete, or list of tasks
    383  1dfd					      macro	wtask
    384  1dfd					      db	76
    385  1dfd					      db	({1}-*)-1	;(addr-*)-1
    386  1dfd					      endm
    387  1dfd							;Get the current task id
    388  1dfd					      MACRO	taskpid
    389  1dfd					      db	77
    390  1dfd					      endm
    391  1dfd							;Trace the basic execution
    392  1dfd					      Macro	traceprogram
    393  1dfd					      db	78
    394  1dfd					      endm
    395  1dfd							;Do a basic program Trace
    396  1dfd					      Macro	debugbasic
    397  1dfd					      db	79
    398  1dfd					      endm
    399  1dfd
    400  1dfd							; Inter Process communications instructions
    401  1dfd					      Macro	ipcsend
    402  1dfd					      db	80
    403  1dfd					      endm
    404  1dfd					      Macro	ipcreceive
    405  1dfd					      db	81
    406  1dfd					      endm
    407  1dfd					      Macro	ipccheck
    408  1dfd					      db	82
    409  1dfd					      endm
    410  1dfd					      Macro	ipcio
    411  1dfd					      db	83
    412  1dfd					      endm
    413  1dfd					      Macro	pushmathstack
    414  1dfd					      db	84
    415  1dfd					      endm
    416  1dfd					      Macro	popmathstack
    417  1dfd					      db	85
    418  1dfd					      endm
    419  1dfd					      Macro	savemathstack
    420  1dfd					      db	86
    421  1dfd					      endm
    422  1dfd					      Macro	restoremathstack
    423  1dfd					      db	87
    424  1dfd					      endm
    425  1dfd					      Macro	incparmcount
    426  1dfd					      db	88
    427  1dfd					      endm
    428  1dfd					      Macro	taskgetmathstack
    429  1dfd					      db	89
    430  1dfd					      endm
    431  1dfd					      Macro	taskenable
    432  1dfd					      db	90
    433  1dfd					      endm
    434  1dfd					      Macro	tasksuspend
    435  1dfd					      db	91
    436  1dfd					      endm
    437  1dfd					      Macro	taskputmathptr
    438  1dfd					      db	92
    439  1dfd					      endm
    440  1dfd							; Test for an extension type of variable that allows access to a tasks variables
    441  1dfd							; Using  PID!<Var name>
    442  1dfd					      Macro	tstvt
    443  1dfd					      db	93
    444  1dfd					      db	({1}-*)-1	;(addr-*)-1
    445  1dfd					      endm
    446  1dfd
    447  1dfd							; Provide access to R2 for the IL program
    448  1dfd					      Macro	setr2
    449  1dfd					      db	94
    450  1dfd					      db	{1}	; R2 is only one byte
    451  1dfd					      endm
    452  1dfd							;Move stack top to temp
    453  1dfd					      Macro	stk2tmp
    454  1dfd					      db	95
    455  1dfd					      endm
    456  1dfd
    457  1dfd					      Macro	tmp2stk
    458  1dfd					      db	96
    459  1dfd					      endm
    460  1dfd
    461  1dfd					      Macro	tstbyte
    462  1dfd					      db	97
    463  1dfd					      db	({1}-*)-1	; (addr-*)-1 goto if match
    464  1dfd					      dw	{2}	; address to check
    465  1dfd					      db	{3}	; Value to compare
    466  1dfd					      endm
    467  1dfd
    468  1dfd					      Macro	incvar
    469  1dfd					      db	98
    470  1dfd					      endm
    471  1dfd					      Macro	decvar
    472  1dfd					      db	99
    473  1dfd					      endm
    474  1dfd
    475  1dfd					      Macro	slice
    476  1dfd					      db	100
    477  1dfd					      endm
    478  1dfd
    479  1dfd
    480  1dfd
------- FILE mytb.asm
   2220  1dfd							;
   2221  1dfd				  -	      if	FIXED
   2222  1dfd				  -	      org	$1000
   2223  1dfd					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  1dfd					      include	"basic.il"
      1  1dfd							;LET
      2  1dfd							;=====================================================
      3  1dfd							;=====================================================
      4  1dfd					      seg	Code
      5  1dfd							;=====================================================
      6  1dfd							; This is the IL of the BASIC (or whatever) language.
      7  1dfd							; Because of the way macros are implemented by as65,
      8  1dfd							; labels can't be on the same line as a macro
      9  1dfd							; invocation, so that's why labels are on separate
     10  1dfd							; lines.
     11  1dfd							;
     12  1dfd		       1d fd	   IL	      equ	*
     13  1dfd
     14  1dfd							;THE IL CONTROL SECTION
     15  1dfd
     16  1dfd				   START
      0  1dfd					      INIT		;INITIALIZE
      0  1dfd					      db	22
      1  1dfd		       16		      .byte.b	22
      0  1dfe					      NLINE		;WRITE CRLF
      0  1dfe					      db	5
      1  1dfe		       05		      .byte.b	5
      0  1dff					      ERRGOTO	CO	;where to go after an error
      0  1dff					      db	31
      1  1dff		       1f		      .byte.b	31
      0  1e00					      dw	CO
      1  1e00		       03 1e		      .word.w	CO
      0  1e02					      VINIT		;clear all variables
      0  1e02					      db	30
      1  1e02		       1e		      .byte.b	30
     21  1e03							;
     22  1e03							; This is where we jump to get a line of commands or
     23  1e03							; a program from the user.
     24  1e03							;
     25  1e03				   CO
      0  1e03					      GETLINE		;WRITE PROMPT AND GET LINE
      0  1e03					      db	23
      1  1e03		       17		      .byte.b	23
      0  1e04					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  1e04					      db	34
      1  1e04		       22		      .byte.b	34
      0  1e05					      db	(XEC-*)-1
      1  1e05		       04		      .byte.b	(XEC-*)-1
      0  1e06					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1e06					      db	24
      1  1e06		       18		      .byte.b	24
      0  1e07					      IJMP	CO
      0  1e07					      db	29
      1  1e07		       1d		      .byte.b	29
      0  1e08					      dw	CO
      1  1e08		       03 1e		      .word.w	CO
     30  1e0a				   XEC
      0  1e0a					      XINIT		;INITIALIZE
      0  1e0a					      db	0
      1  1e0a		       00		      .byte.b	0
     32  1e0b							;============================================================================
     33  1e0b							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
     34  1e0b							;
     35  1e0b				   STMT
      0  1e0b					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  1e0b					      db	79
      1  1e0b		       4f		      .byte.b	79
      0  1e0c					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1e0c					      db	57
      1  1e0c		       39		      .byte.b	57
      0  1e0d					      db	(notirq-*)-1
      1  1e0d		       00		      .byte.b	(notirq-*)-1
     38  1e0e							;==========================================================================================
     39  1e0e							; Process a let statement implied or explicit.
     40  1e0e							;
     41  1e0e				   notirq
      0  1e0e					      TSTLET	LET	;Test if second field is = or []
      0  1e0e					      db	49
      1  1e0e		       31		      .byte.b	49
      0  1e0f					      db	(LET-*)-1
      1  1e0f		       03		      .byte.b	(LET-*)-1
      0  1e10					      IJMP	DOLET	;allow the default to be let
      0  1e10					      db	29
      1  1e10		       1d		      .byte.b	29
      0  1e11					      dw	DOLET
      1  1e11		       19 1e		      .word.w	DOLET
     44  1e13				   LET
      0  1e13					      TST	S1,"LET"	;IS STATEMENT A LET
      0  1e13					      db	32
      1  1e13		       20		      .byte.b	32
      0  1e14					      db	(S1-*)-1
      1  1e14		       21		      .byte.b	(S1-*)-1
      0  1e15					      db	"LET",0
      1  1e15		       4c 45 54 00	      .byte.b	"LET",0
     46  1e19				   DOLET
      0  1e19					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  1e19					      db	33
      1  1e19		       21		      .byte.b	33
      0  1e1a					      db	(ERRVEC-*)-1
      1  1e1a		       ea		      .byte.b	(ERRVEC-*)-1
      0  1e1b					      TST	LETBE,"["
      0  1e1b					      db	32
      1  1e1b		       20		      .byte.b	32
      0  1e1c					      db	(LETBE-*)-1
      1  1e1c		       0a		      .byte.b	(LETBE-*)-1
      0  1e1d					      db	"[",0
      1  1e1d		       5b 00		      .byte.b	"[",0
      0  1e1f					      CALL	EXPR
      0  1e1f					      db	28
      1  1e1f		       1c		      .byte.b	28
      0  1e20					      dw	EXPR
      1  1e20		       a8 20		      .word.w	EXPR
      0  1e22					      TST	ERRVEC,"]"
      0  1e22					      db	32
      1  1e22		       20		      .byte.b	32
      0  1e23					      db	(ERRVEC-*)-1
      1  1e23		       e1		      .byte.b	(ERRVEC-*)-1
      0  1e24					      db	"]",0
      1  1e24		       5d 00		      .byte.b	"]",0
      0  1e26					      SUBSCRIPT
      0  1e26					      db	64
      1  1e26		       40		      .byte.b	64
     52  1e27				   LETBE
      0  1e27					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1e27					      db	32
      1  1e27		       20		      .byte.b	32
      0  1e28					      db	(ERRVEC-*)-1
      1  1e28		       dc		      .byte.b	(ERRVEC-*)-1
      0  1e29					      db	"=",0
      1  1e29		       3d 00		      .byte.b	"=",0
      0  1e2b					      CALL	EXPR	;PLACE EXPR VALUE ON MathSTK
      0  1e2b					      db	28
      1  1e2b		       1c		      .byte.b	28
      0  1e2c					      dw	EXPR
      1  1e2c		       a8 20		      .word.w	EXPR
      0  1e2e					      DONE		;REPORT ERROR IF NOT NEXT
      0  1e2e					      db	1
      1  1e2e		       01		      .byte.b	1
      0  1e2f					      STORE		;STORE RESULT
      0  1e2f					      db	19
      1  1e2f		       13		      .byte.b	19
      0  1e30					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1e30					      db	6
      1  1e30		       06		      .byte.b	6
      0  1e31					      dw	CO
      1  1e31		       03 1e		      .word.w	CO
      0  1e33					      IJMP	STMT
      0  1e33					      db	29
      1  1e33		       1d		      .byte.b	29
      0  1e34					      dw	STMT
      1  1e34		       0b 1e		      .word.w	STMT
     59  1e36							;=============================================================
     60  1e36							; Inc or dec a variable
     61  1e36				   S1
      0  1e36					      TST	S1Dec,"INC"	;Increment variable
      0  1e36					      db	32
      1  1e36		       20		      .byte.b	32
      0  1e37					      db	(S1Dec-*)-1
      1  1e37		       0e		      .byte.b	(S1Dec-*)-1
      0  1e38					      db	"INC",0
      1  1e38		       49 4e 43 00	      .byte.b	"INC",0
      0  1e3c					      TSTV	ERRVEC
      0  1e3c					      db	33
      1  1e3c		       21		      .byte.b	33
      0  1e3d					      db	(ERRVEC-*)-1
      1  1e3d		       c7		      .byte.b	(ERRVEC-*)-1
      0  1e3e					      INCVAR
      0  1e3e					      db	98
      1  1e3e		       62		      .byte.b	98
      0  1e3f					      DONE
      0  1e3f					      db	1
      1  1e3f		       01		      .byte.b	1
      0  1e40					      NXT	CO
      0  1e40					      db	6
      1  1e40		       06		      .byte.b	6
      0  1e41					      dw	CO
      1  1e41		       03 1e		      .word.w	CO
      0  1e43					      IJMP	STMT
      0  1e43					      db	29
      1  1e43		       1d		      .byte.b	29
      0  1e44					      dw	STMT
      1  1e44		       0b 1e		      .word.w	STMT
     68  1e46				   S1Dec
      0  1e46					      TST	S1Iret,"DEC"	;Dec variable
      0  1e46					      db	32
      1  1e46		       20		      .byte.b	32
      0  1e47					      db	(S1Iret-*)-1
      1  1e47		       0e		      .byte.b	(S1Iret-*)-1
      0  1e48					      db	"DEC",0
      1  1e48		       44 45 43 00	      .byte.b	"DEC",0
      0  1e4c					      TSTV	ERRVEC
      0  1e4c					      db	33
      1  1e4c		       21		      .byte.b	33
      0  1e4d					      db	(ERRVEC-*)-1
      1  1e4d		       b7		      .byte.b	(ERRVEC-*)-1
      0  1e4e					      DECVAR
      0  1e4e					      db	99
      1  1e4e		       63		      .byte.b	99
      0  1e4f					      DONE
      0  1e4f					      db	1
      1  1e4f		       01		      .byte.b	1
      0  1e50					      NXT	CO
      0  1e50					      db	6
      1  1e50		       06		      .byte.b	6
      0  1e51					      dw	CO
      1  1e51		       03 1e		      .word.w	CO
      0  1e53					      IJMP	STMT
      0  1e53					      db	29
      1  1e53		       1d		      .byte.b	29
      0  1e54					      dw	STMT
      1  1e54		       0b 1e		      .word.w	STMT
     75  1e56							;====================================================================
     76  1e56							; iret or ireturn, Return from interupt process
     77  1e56							;
     78  1e56				   S1Iret
      0  1e56					      TST	S1S1,"IRET"	;test return from interupt
      0  1e56					      db	32
      1  1e56		       20		      .byte.b	32
      0  1e57					      db	(S1S1-*)-1
      1  1e57		       10		      .byte.b	(S1S1-*)-1
      0  1e58					      db	"IRET",0
      1  1e58		       49 52 45 54*	      .byte.b	"IRET",0
      0  1e5d					      TST	S1Sa,"URN"
      0  1e5d					      db	32
      1  1e5d		       20		      .byte.b	32
      0  1e5e					      db	(S1Sa-*)-1
      1  1e5e		       04		      .byte.b	(S1Sa-*)-1
      0  1e5f					      db	"URN",0
      1  1e5f		       55 52 4e 00	      .byte.b	"URN",0
     81  1e63				   S1Sa
      0  1e63					      DONE		;Must be only thing on the line
      0  1e63					      db	1
      1  1e63		       01		      .byte.b	1
      0  1e64					      IRET		;RESTORE LINE NUMBER OF CALL
      0  1e64					      db	58
      1  1e64		       3a		      .byte.b	58
      0  1e65					      IJMP	STMT
      0  1e65					      db	29
      1  1e65		       1d		      .byte.b	29
      0  1e66					      dw	STMT
      1  1e66		       0b 1e		      .word.w	STMT
     85  1e68							;=======================================================================
     86  1e68							;Process if statement, if true then process all statements until end of line reached
     87  1e68				   S1S1
      0  1e68					      TST	S1Z,"IF"	;IF STATEMENT
      0  1e68					      db	32
      1  1e68		       20		      .byte.b	32
      0  1e69					      db	(S1Z-*)-1
      1  1e69		       11		      .byte.b	(S1Z-*)-1
      0  1e6a					      db	"IF",0
      1  1e6a		       49 46 00 	      .byte.b	"IF",0
      0  1e6d					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1e6d					      db	28
      1  1e6d		       1c		      .byte.b	28
      0  1e6e					      dw	EXPR
      1  1e6e		       a8 20		      .word.w	EXPR
      0  1e70					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  1e70					      db	32
      1  1e70		       20		      .byte.b	32
      0  1e71					      db	(S1W-*)-1
      1  1e71		       05		      .byte.b	(S1W-*)-1
      0  1e72					      db	"THEN",0
      1  1e72		       54 48 45 4e*	      .byte.b	"THEN",0
     91  1e77				   S1W
      0  1e77					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1e77					      db	54
      1  1e77		       36		      .byte.b	54
      0  1e78					      IJMP	STMT
      0  1e78					      db	29
      1  1e78		       1d		      .byte.b	29
      0  1e79					      dw	STMT
      1  1e79		       0b 1e		      .word.w	STMT
     94  1e7b							;===============================================================
     95  1e7b							; Test for GO
     96  1e7b				   S1Z
      0  1e7b					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1e7b					      db	32
      1  1e7b		       20		      .byte.b	32
      0  1e7c					      db	(S2b-*)-1
      1  1e7c		       19		      .byte.b	(S2b-*)-1
      0  1e7d					      db	"GO",0
      1  1e7d		       47 4f 00 	      .byte.b	"GO",0
     98  1e80							;================================================================
     99  1e80							; process a goto
      0  1e80					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  1e80					      db	32
      1  1e80		       20		      .byte.b	32
      0  1e81					      db	(S2-*)-1
      1  1e81		       07		      .byte.b	(S2-*)-1
      0  1e82					      db	"TO",0
      1  1e82		       54 4f 00 	      .byte.b	"TO",0
      0  1e85					      CALL	EXPR	;GET LABEL
      0  1e85					      db	28
      1  1e85		       1c		      .byte.b	28
      0  1e86					      dw	EXPR
      1  1e86		       a8 20		      .word.w	EXPR
      0  1e88					      XFER		;SET UP AND JUMP
      0  1e88					      db	7
      1  1e88		       07		      .byte.b	7
    103  1e89				   S2
    104  1e89							;===========================================================================
    105  1e89							; Process gosub / function
    106  1e89							;
      0  1e89					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  1e89					      db	32
      1  1e89		       20		      .byte.b	32
      0  1e8a					      db	(ERRVEC-*)-1
      1  1e8a		       7a		      .byte.b	(ERRVEC-*)-1
      0  1e8b					      db	"SUB",0
      1  1e8b		       53 55 42 00	      .byte.b	"SUB",0
      0  1e8f					      CALL	GOSUBSTATEMENT	;Do the gosub
      0  1e8f					      db	28
      1  1e8f		       1c		      .byte.b	28
      0  1e90					      dw	GOSUBSTATEMENT
      1  1e90		       af 22		      .word.w	GOSUBSTATEMENT
      0  1e92					      DONE		;ERROR IF CR NOT NEXT
      0  1e92					      db	1
      1  1e92		       01		      .byte.b	1
      0  1e93					      SAV	GOSUB_RTN	;SAVE RETURN LINE
      0  1e93					      db	8
      1  1e93		       08		      .byte.b	8
      0  1e94					      db	GOSUB_RTN
      1  1e94		       01		      .byte.b	GOSUB_RTN
      0  1e95					      XFER		;AND JUMP
      0  1e95					      db	7
      1  1e95		       07		      .byte.b	7
    112  1e96							;
    113  1e96							; End of gosub processing
    114  1e96							;==========================================================================
    115  1e96							; Return from a gosub
    116  1e96				   S2b
      0  1e96					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  1e96					      db	32
      1  1e96		       20		      .byte.b	32
      0  1e97					      db	(S3-*)-1
      1  1e97		       36		      .byte.b	(S3-*)-1
      0  1e98					      db	"RE",0
      1  1e98		       52 45 00 	      .byte.b	"RE",0
      0  1e9b					      TST	S2a,"T"
      0  1e9b					      db	32
      1  1e9b		       20		      .byte.b	32
      0  1e9c					      db	(S2a-*)-1
      1  1e9c		       27		      .byte.b	(S2a-*)-1
      0  1e9d					      db	"T",0
      1  1e9d		       54 00		      .byte.b	"T",0
      0  1e9f					      TST	S2aa,"URN"	; RETURN STATEMENT
      0  1e9f					      db	32
      1  1e9f		       20		      .byte.b	32
      0  1ea0					      db	(S2aa-*)-1
      1  1ea0		       04		      .byte.b	(S2aa-*)-1
      0  1ea1					      db	"URN",0
      1  1ea1		       55 52 4e 00	      .byte.b	"URN",0
    120  1ea5				   S2aa
      0  1ea5					      SETR2	0	; Default no return value
      0  1ea5					      db	94
      1  1ea5		       5e		      .byte.b	94
      0  1ea6					      db	0
      1  1ea6		       00		      .byte.b	0
      0  1ea7					      TST	S2RetDone,"("	; Check if we will return some value
      0  1ea7					      db	32
      1  1ea7		       20		      .byte.b	32
      0  1ea8					      db	(S2RetDone-*)-1
      1  1ea8		       0b		      .byte.b	(S2RetDone-*)-1
      0  1ea9					      db	"(",0
      1  1ea9		       28 00		      .byte.b	"(",0
      0  1eab					      SETR2	1	; Indicate a return value provided
      0  1eab					      db	94
      1  1eab		       5e		      .byte.b	94
      0  1eac					      db	1
      1  1eac		       01		      .byte.b	1
      0  1ead					      CALL	EXPR
      0  1ead					      db	28
      1  1ead		       1c		      .byte.b	28
      0  1eae					      dw	EXPR
      1  1eae		       a8 20		      .word.w	EXPR
      0  1eb0					      TST	ERRVEC,")"	; Now a value is on the stack
      0  1eb0					      db	32
      1  1eb0		       20		      .byte.b	32
      0  1eb1					      db	(ERRVEC-*)-1
      1  1eb1		       53		      .byte.b	(ERRVEC-*)-1
      0  1eb2					      db	")",0
      1  1eb2		       29 00		      .byte.b	")",0
    126  1eb4
    127  1eb4				   S2RetDone
      0  1eb4					      DONE		; MUST BE CR or :
      0  1eb4					      db	1
      1  1eb4		       01		      .byte.b	1
      0  1eb5					      RSTR		; RESTORE LINE NUMBER OF CALL
      0  1eb5					      db	9
      1  1eb5		       09		      .byte.b	9
      0  1eb6					      TSTBYTE	S2RetFunc,R2,1	; In This case jumps if equal
      0  1eb6					      db	97
      1  1eb6		       61		      .byte.b	97
      0  1eb7					      db	(S2RetFunc-*)-1
      1  1eb7		       09		      .byte.b	(S2RetFunc-*)-1
      0  1eb8					      dw	R2
      1  1eb8		       58 00		      .word.w	R2
      0  1eba					      db	1
      1  1eba		       01		      .byte.b	1
      0  1ebb					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  1ebb					      db	6
      1  1ebb		       06		      .byte.b	6
      0  1ebc					      dw	CO
      1  1ebc		       03 1e		      .word.w	CO
      0  1ebe					      IJMP	STMT
      0  1ebe					      db	29
      1  1ebe		       1d		      .byte.b	29
      0  1ebf					      dw	STMT
      1  1ebf		       0b 1e		      .word.w	STMT
    133  1ec1				   S2RetFunc
      0  1ec1					      IJMP	GOFNRet	; Back into the Function
      0  1ec1					      db	29
      1  1ec1		       1d		      .byte.b	29
      0  1ec2					      dw	GOFNRet
      1  1ec2		       85 22		      .word.w	GOFNRet
    135  1ec4							;
    136  1ec4							; End of return from gosub
    137  1ec4							;============================================================================
    138  1ec4							; Process REM statement
    139  1ec4							;
    140  1ec4				   S2a
      0  1ec4					      TST	S3,"M"	;REMark.  Skip rest of line
      0  1ec4					      db	32
      1  1ec4		       20		      .byte.b	32
      0  1ec5					      db	(S3-*)-1
      1  1ec5		       08		      .byte.b	(S3-*)-1
      0  1ec6					      db	"M",0
      1  1ec6		       4d 00		      .byte.b	"M",0
      0  1ec8					      NXT	CO
      0  1ec8					      db	6
      1  1ec8		       06		      .byte.b	6
      0  1ec9					      dw	CO
      1  1ec9		       03 1e		      .word.w	CO
      0  1ecb					      IJMP	STMT
      0  1ecb					      db	29
      1  1ecb		       1d		      .byte.b	29
      0  1ecc					      dw	STMT
      1  1ecc		       0b 1e		      .word.w	STMT
    144  1ece							;============================================================================
    145  1ece							; Print statement
    146  1ece							;
    147  1ece				   S3
      0  1ece					      TST	S3a,"?"	; ? symonym for print
      0  1ece					      db	32
      1  1ece		       20		      .byte.b	32
      0  1ecf					      db	(S3a-*)-1
      1  1ecf		       05		      .byte.b	(S3a-*)-1
      0  1ed0					      db	"?",0
      1  1ed0		       3f 00		      .byte.b	"?",0
      0  1ed2					      IJMP	S4S
      0  1ed2					      db	29
      1  1ed2		       1d		      .byte.b	29
      0  1ed3					      dw	S4S
      1  1ed3		       e0 1e		      .word.w	S4S
    150  1ed5				   S3a
      0  1ed5					      TST	S8,"PR"	;allow short form of print
      0  1ed5					      db	32
      1  1ed5		       20		      .byte.b	32
      0  1ed6					      db	(S8-*)-1
      1  1ed6		       5b		      .byte.b	(S8-*)-1
      0  1ed7					      db	"PR",0
      1  1ed7		       50 52 00 	      .byte.b	"PR",0
      0  1eda					      TST	S4S,"INT"	;PRINT
      0  1eda					      db	32
      1  1eda		       20		      .byte.b	32
      0  1edb					      db	(S4S-*)-1
      1  1edb		       04		      .byte.b	(S4S-*)-1
      0  1edc					      db	"INT",0
      1  1edc		       49 4e 54 00	      .byte.b	"INT",0
    153  1ee0				   S4S
      0  1ee0					      STARTIO		;Lock task until io completes
      0  1ee0					      db	70
      1  1ee0		       46		      .byte.b	70
    155  1ee1				   S4
      0  1ee1					      TSTDONE	S4a	;Test if we just want crlf printed
      0  1ee1					      db	50
      1  1ee1		       32		      .byte.b	50
      0  1ee2					      db	(S4a-*)-1
      1  1ee2		       03		      .byte.b	(S4a-*)-1
      0  1ee3					      IJMP	S6
      0  1ee3					      db	29
      1  1ee3		       1d		      .byte.b	29
      0  1ee4					      dw	S6
      1  1ee4		       fc 1e		      .word.w	S6
    158  1ee6
    159  1ee6				   S4a
      0  1ee6					      TSTSTR	S7	;TEST FOR QUOTED String
      0  1ee6					      db	55
      1  1ee6		       37		      .byte.b	55
      0  1ee7					      db	(S7-*)-1
      1  1ee7		       21		      .byte.b	(S7-*)-1
      0  1ee8					      PRS		;PRINT STRING
      0  1ee8					      db	2
      1  1ee8		       02		      .byte.b	2
    162  1ee9				   S5
      0  1ee9					      TST	S6A,COMMA	;IS THERE MORE?
      0  1ee9					      db	32
      1  1ee9		       20		      .byte.b	32
      0  1eea					      db	(S6A-*)-1
      1  1eea		       08		      .byte.b	(S6A-*)-1
      0  1eeb					      db	COMMA,0
      1  1eeb		       2c 00		      .byte.b	COMMA,0
      0  1eed					      SPC		;SPACE TO NEXT ZONE
      0  1eed					      db	4
      1  1eed		       04		      .byte.b	4
      0  1eee					      TSTDONE	S4	;Not end of line jump back
      0  1eee					      db	50
      1  1eee		       32		      .byte.b	50
      0  1eef					      db	(S4-*)-1
      1  1eef		       f1		      .byte.b	(S4-*)-1
      0  1ef0					      IJMP	S6Z	;YES JUMP BACK
      0  1ef0					      db	29
      1  1ef0		       1d		      .byte.b	29
      0  1ef1					      dw	S6Z
      1  1ef1		       fe 1e		      .word.w	S6Z
    167  1ef3
    168  1ef3							;
    169  1ef3							; If a semicolon, don't do anything.
    170  1ef3							;
    171  1ef3				   S6A
      0  1ef3					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  1ef3					      db	32
      1  1ef3		       20		      .byte.b	32
      0  1ef4					      db	(S6-*)-1
      1  1ef4		       07		      .byte.b	(S6-*)-1
      0  1ef5					      db	SEMICOLON,0
      1  1ef5		       3b 00		      .byte.b	SEMICOLON,0
      0  1ef7					      TSTDONE	S4	;Jump Back if not end of line
      0  1ef7					      db	50
      1  1ef7		       32		      .byte.b	50
      0  1ef8					      db	(S4-*)-1
      1  1ef8		       e8		      .byte.b	(S4-*)-1
      0  1ef9					      IJMP	S6Z
      0  1ef9					      db	29
      1  1ef9		       1d		      .byte.b	29
      0  1efa					      dw	S6Z
      1  1efa		       fe 1e		      .word.w	S6Z
    175  1efc				   S6
      0  1efc					      DONE		;ERROR IF CR NOT NEXT
      0  1efc					      db	1
      1  1efc		       01		      .byte.b	1
      0  1efd					      NLINE
      0  1efd					      db	5
      1  1efd		       05		      .byte.b	5
    178  1efe				   S6Z
      0  1efe					      ENDIO		;release task io completed
      0  1efe					      db	71
      1  1efe		       47		      .byte.b	71
      0  1eff					      NXT	CO	;exit here if , or ; at end of print
      0  1eff					      db	6
      1  1eff		       06		      .byte.b	6
      0  1f00					      dw	CO
      1  1f00		       03 1e		      .word.w	CO
      0  1f02					      IJMP	STMT
      0  1f02					      db	29
      1  1f02		       1d		      .byte.b	29
      0  1f03					      dw	STMT
      1  1f03		       0b 1e		      .word.w	STMT
    182  1f05							;
    183  1f05							; A jump for code too far away for relative branch
    184  1f05							;
    185  1f05				   ERRVEC
      0  1f05					      ENDIO
      0  1f05					      db	71
      1  1f05		       47		      .byte.b	71
      0  1f06					      IJMP	UNKNOWN
      0  1f06					      db	29
      1  1f06		       1d		      .byte.b	29
      0  1f07					      dw	UNKNOWN
      1  1f07		       a4 20		      .word.w	UNKNOWN
    188  1f09							;
    189  1f09							; Get here if there is an expression to print
    190  1f09				   S7
      0  1f09					      TST	S7AUnsigned,"$"
      0  1f09					      db	32
      1  1f09		       20		      .byte.b	32
      0  1f0a					      db	(S7AUnsigned-*)-1
      1  1f0a		       09		      .byte.b	(S7AUnsigned-*)-1
      0  1f0b					      db	"$",0
      1  1f0b		       24 00		      .byte.b	"$",0
      0  1f0d					      CALL	EXPR
      0  1f0d					      db	28
      1  1f0d		       1c		      .byte.b	28
      0  1f0e					      dw	EXPR
      1  1f0e		       a8 20		      .word.w	EXPR
      0  1f10					      HEXPRT
      0  1f10					      db	67
      1  1f10		       43		      .byte.b	67
      0  1f11					      IJMP	S5
      0  1f11					      db	29
      1  1f11		       1d		      .byte.b	29
      0  1f12					      dw	S5
      1  1f12		       e9 1e		      .word.w	S5
    195  1f14
    196  1f14				   S7AUnsigned
    197  1f14
      0  1f14					      TST	S7A,"%"
      0  1f14					      db	32
      1  1f14		       20		      .byte.b	32
      0  1f15					      db	(S7A-*)-1
      1  1f15		       0b		      .byte.b	(S7A-*)-1
      0  1f16					      db	"%",0
      1  1f16		       25 00		      .byte.b	"%",0
      0  1f18					      CALL	EXPR
      0  1f18					      db	28
      1  1f18		       1c		      .byte.b	28
      0  1f19					      dw	EXPR
      1  1f19		       a8 20		      .word.w	EXPR
      0  1f1b					      SETR2	1
      0  1f1b					      db	94
      1  1f1b		       5e		      .byte.b	94
      0  1f1c					      db	1
      1  1f1c		       01		      .byte.b	1
      0  1f1d					      PRN
      0  1f1d					      db	3
      1  1f1d		       03		      .byte.b	3
      0  1f1e					      IJMP	S5
      0  1f1e					      db	29
      1  1f1e		       1d		      .byte.b	29
      0  1f1f					      dw	S5
      1  1f1f		       e9 1e		      .word.w	S5
    203  1f21
    204  1f21				   S7A
    205  1f21
      0  1f21					      CALL	EXPR
      0  1f21					      db	28
      1  1f21		       1c		      .byte.b	28
      0  1f22					      dw	EXPR
      1  1f22		       a8 20		      .word.w	EXPR
      0  1f24					      TST	S7B,"$"
      0  1f24					      db	32
      1  1f24		       20		      .byte.b	32
      0  1f25					      db	(S7B-*)-1
      1  1f25		       06		      .byte.b	(S7B-*)-1
      0  1f26					      db	"$",0
      1  1f26		       24 00		      .byte.b	"$",0
      0  1f28					      PUTCHAR
      0  1f28					      db	52
      1  1f28		       34		      .byte.b	52
      0  1f29					      IJMP	S5
      0  1f29					      db	29
      1  1f29		       1d		      .byte.b	29
      0  1f2a					      dw	S5
      1  1f2a		       e9 1e		      .word.w	S5
    210  1f2c
    211  1f2c				   S7B
      0  1f2c					      SETR2	0
      0  1f2c					      db	94
      1  1f2c		       5e		      .byte.b	94
      0  1f2d					      db	0
      1  1f2d		       00		      .byte.b	0
      0  1f2e					      PRN		;PRINT IT
      0  1f2e					      db	3
      1  1f2e		       03		      .byte.b	3
      0  1f2f					      IJMP	S5	;IS THERE MORE?
      0  1f2f					      db	29
      1  1f2f		       1d		      .byte.b	29
      0  1f30					      dw	S5
      1  1f30		       e9 1e		      .word.w	S5
    215  1f32							;
    216  1f32							;===========================================================
    217  1f32							; PROCESS ALL THE TAST STATEMENTS
    218  1f32							;
    219  1f32				   S8
      0  1f32					      TST	S8a1,"TASK"	; Any Task Command
      0  1f32					      db	32
      1  1f32		       20		      .byte.b	32
      0  1f33					      db	(S8a1-*)-1
      1  1f33		       4b		      .byte.b	(S8a1-*)-1
      0  1f34					      db	"TASK",0
      1  1f34		       54 41 53 4b*	      .byte.b	"TASK",0
    221  1f39							;==========================================================
    222  1f39							; End of TASK process
    223  1f39							;
      0  1f39					      TST	S8G,"E"
      0  1f39					      db	32
      1  1f39		       20		      .byte.b	32
      0  1f3a					      db	(S8G-*)-1
      1  1f3a		       1a		      .byte.b	(S8G-*)-1
      0  1f3b					      db	"E",0
      1  1f3b		       45 00		      .byte.b	"E",0
      0  1f3d					      TST	S8NoParm,"("
      0  1f3d					      db	32
      1  1f3d		       20		      .byte.b	32
      0  1f3e					      db	(S8NoParm-*)-1
      1  1f3e		       0e		      .byte.b	(S8NoParm-*)-1
      0  1f3f					      db	"(",0
      1  1f3f		       28 00		      .byte.b	"(",0
      0  1f41					      CALL	EXPR
      0  1f41					      db	28
      1  1f41		       1c		      .byte.b	28
      0  1f42					      dw	EXPR
      1  1f42		       a8 20		      .word.w	EXPR
      0  1f44					      TST	UNKNOWNLnk,")"
      0  1f44					      db	32
      1  1f44		       20		      .byte.b	32
      0  1f45					      db	(UNKNOWNLnk-*)-1
      1  1f45		       36		      .byte.b	(UNKNOWNLnk-*)-1
      0  1f46					      db	")",0
      1  1f46		       29 00		      .byte.b	")",0
      0  1f48					      ETASK
      0  1f48					      db	62
      1  1f48		       3e		      .byte.b	62
      0  1f49					      DONE
      0  1f49					      db	1
      1  1f49		       01		      .byte.b	1
      0  1f4a					      IJMP	STMT
      0  1f4a					      db	29
      1  1f4a		       1d		      .byte.b	29
      0  1f4b					      dw	STMT
      1  1f4b		       0b 1e		      .word.w	STMT
    231  1f4d				   S8NoParm
      0  1f4d					      LIT	0
      0  1f4d					      db	27
      1  1f4d		       1b		      .byte.b	27
      0  1f4e					      dw	0
      1  1f4e		       00 00		      .word.w	0
      0  1f50					      ETASK
      0  1f50					      db	62
      1  1f50		       3e		      .byte.b	62
      0  1f51					      DONE		; Must be last thing on a line
      0  1f51					      db	1
      1  1f51		       01		      .byte.b	1
      0  1f52					      IJMP	STMT
      0  1f52					      db	29
      1  1f52		       1d		      .byte.b	29
      0  1f53					      dw	STMT
      1  1f53		       0b 1e		      .word.w	STMT
    236  1f55							;
    237  1f55							;===========================================================
    238  1f55							; The task gives up the rest of the cycles
    239  1f55				   S8G
      0  1f55					      TST	S8a,"N"	;Next task
      0  1f55					      db	32
      1  1f55		       20		      .byte.b	32
      0  1f56					      db	(S8a-*)-1
      1  1f56		       09		      .byte.b	(S8a-*)-1
      0  1f57					      db	"N",0
      1  1f57		       4e 00		      .byte.b	"N",0
      0  1f59					      NTASK
      0  1f59					      db	63
      1  1f59		       3f		      .byte.b	63
      0  1f5a					      NXT	CO	;Next statement to execute
      0  1f5a					      db	6
      1  1f5a		       06		      .byte.b	6
      0  1f5b					      dw	CO
      1  1f5b		       03 1e		      .word.w	CO
      0  1f5d					      IJMP	STMT
      0  1f5d					      db	29
      1  1f5d		       1d		      .byte.b	29
      0  1f5e					      dw	STMT
      1  1f5e		       0b 1e		      .word.w	STMT
    244  1f60							;
    245  1f60							;===========================================================
    246  1f60							; Waits for a task or list of tasks to complete
    247  1f60				   S8a
      0  1f60					      TST	S8TASKNO,"W("	;Wait for tasks
      0  1f60					      db	32
      1  1f60		       20		      .byte.b	32
      0  1f61					      db	(S8TASKNO-*)-1
      1  1f61		       1a		      .byte.b	(S8TASKNO-*)-1
      0  1f62					      db	"W(",0
      1  1f62		       57 28 00 	      .byte.b	"W(",0
    249  1f65				   S8TSK
      0  1f65					      Call	EXPR	;Gets the PID of task to wait for
      0  1f65					      db	28
      1  1f65		       1c		      .byte.b	28
      0  1f66					      dw	EXPR
      1  1f66		       a8 20		      .word.w	EXPR
    251  1f68				   S8LOOP
      0  1f68					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  1f68					      db	76
      1  1f68		       4c		      .byte.b	76
      0  1f69					      db	(S8LOOP-*)-1
      1  1f69		       fe		      .byte.b	(S8LOOP-*)-1
      0  1f6a					      TST	S8aa,COMMA	;Checks for more tasks
      0  1f6a					      db	32
      1  1f6a		       20		      .byte.b	32
      0  1f6b					      db	(S8aa-*)-1
      1  1f6b		       05		      .byte.b	(S8aa-*)-1
      0  1f6c					      db	COMMA,0
      1  1f6c		       2c 00		      .byte.b	COMMA,0
      0  1f6e					      IJMP	S8TSK	;Go for the next task number
      0  1f6e					      db	29
      1  1f6e		       1d		      .byte.b	29
      0  1f6f					      dw	S8TSK
      1  1f6f		       65 1f		      .word.w	S8TSK
    255  1f71				   S8aa
      0  1f71					      TST	S8TASKNO,")"	;end of list
      0  1f71					      db	32
      1  1f71		       20		      .byte.b	32
      0  1f72					      db	(S8TASKNO-*)-1
      1  1f72		       09		      .byte.b	(S8TASKNO-*)-1
      0  1f73					      db	")",0
      1  1f73		       29 00		      .byte.b	")",0
      0  1f75					      DONE
      0  1f75					      db	1
      1  1f75		       01		      .byte.b	1
      0  1f76					      NXT	CO
      0  1f76					      db	6
      1  1f76		       06		      .byte.b	6
      0  1f77					      dw	CO
      1  1f77		       03 1e		      .word.w	CO
      0  1f79					      IJMP	STMT	;Next Statement
      0  1f79					      db	29
      1  1f79		       1d		      .byte.b	29
      0  1f7a					      dw	STMT
      1  1f7a		       0b 1e		      .word.w	STMT
    260  1f7c				   S8TASKNO
    261  1f7c
    262  1f7c				   UNKNOWNLnk
      0  1f7c					      iJMP	UNKNOWN
      0  1f7c					      db	29
      1  1f7c		       1d		      .byte.b	29
      0  1f7d					      dw	UNKNOWN
      1  1f7d		       a4 20		      .word.w	UNKNOWN
    264  1f7f
    265  1f7f							;
    266  1f7f							;===========================================================
    267  1f7f							; Update a memory location with a value
    268  1f7f							;  Use @[offset] to write a word value to memory
    269  1f7f							;
    270  1f7f				   S8a1
      0  1f7f					      TST	S8b,"POKE("	; Poke a value into memory
      0  1f7f					      db	32
      1  1f7f		       20		      .byte.b	32
      0  1f80					      db	(S8b-*)-1
      1  1f80		       1c		      .byte.b	(S8b-*)-1
      0  1f81					      db	"POKE(",0
      1  1f81		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  1f87					      CALL	EXPR	; Get address to write to
      0  1f87					      db	28
      1  1f87		       1c		      .byte.b	28
      0  1f88					      dw	EXPR
      1  1f88		       a8 20		      .word.w	EXPR
      0  1f8a					      TST	UNKNOWNV,COMMA	; Must have a coma
      0  1f8a					      db	32
      1  1f8a		       20		      .byte.b	32
      0  1f8b					      db	(UNKNOWNV-*)-1
      1  1f8b		       64		      .byte.b	(UNKNOWNV-*)-1
      0  1f8c					      db	COMMA,0
      1  1f8c		       2c 00		      .byte.b	COMMA,0
      0  1f8e					      CALL	EXPR	; Get the value to poke
      0  1f8e					      db	28
      1  1f8e		       1c		      .byte.b	28
      0  1f8f					      dw	EXPR
      1  1f8f		       a8 20		      .word.w	EXPR
      0  1f91					      TST	UNKNOWNV,")"	; closing bracket
      0  1f91					      db	32
      1  1f91		       20		      .byte.b	32
      0  1f92					      db	(UNKNOWNV-*)-1
      1  1f92		       5d		      .byte.b	(UNKNOWNV-*)-1
      0  1f93					      db	")",0
      1  1f93		       29 00		      .byte.b	")",0
      0  1f95					      POKEMEM
      0  1f95					      db	47
      1  1f95		       2f		      .byte.b	47
      0  1f96					      DONE
      0  1f96					      db	1
      1  1f96		       01		      .byte.b	1
      0  1f97					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1f97					      db	6
      1  1f97		       06		      .byte.b	6
      0  1f98					      dw	CO
      1  1f98		       03 1e		      .word.w	CO
      0  1f9a					      IJMP	STMT
      0  1f9a					      db	29
      1  1f9a		       1d		      .byte.b	29
      0  1f9b					      dw	STMT
      1  1f9b		       0b 1e		      .word.w	STMT
    280  1f9d							;================================================================
    281  1f9d							; Write a single byte to the output device
    282  1f9d							;
    283  1f9d				   S8b
      0  1f9d					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1f9d					      db	32
      1  1f9d		       20		      .byte.b	32
      0  1f9e					      db	(S8c-*)-1
      1  1f9e		       11		      .byte.b	(S8c-*)-1
      0  1f9f					      db	"PUTCH",0
      1  1f9f		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  1fa5					      CALL	EXPR
      0  1fa5					      db	28
      1  1fa5		       1c		      .byte.b	28
      0  1fa6					      dw	EXPR
      1  1fa6		       a8 20		      .word.w	EXPR
      0  1fa8					      PUTCHAR
      0  1fa8					      db	52
      1  1fa8		       34		      .byte.b	52
      0  1fa9					      DONE
      0  1fa9					      db	1
      1  1fa9		       01		      .byte.b	1
      0  1faa					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1faa					      db	6
      1  1faa		       06		      .byte.b	6
      0  1fab					      dw	CO
      1  1fab		       03 1e		      .word.w	CO
      0  1fad					      IJMP	STMT
      0  1fad					      db	29
      1  1fad		       1d		      .byte.b	29
      0  1fae					      dw	STMT
      1  1fae		       0b 1e		      .word.w	STMT
    290  1fb0							;================================================================
    291  1fb0							; Clear the screen lines
    292  1fb0							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    293  1fb0							;
    294  1fb0				   S8c
      0  1fb0					      TST	S9,"CLS"	;Clear the screen
      0  1fb0					      db	32
      1  1fb0		       20		      .byte.b	32
      0  1fb1					      db	(S9-*)-1
      1  1fb1		       0b		      .byte.b	(S9-*)-1
      0  1fb2					      db	"CLS",0
      1  1fb2		       43 4c 53 00	      .byte.b	"CLS",0
      0  1fb6					      CLEARSCREEN
      0  1fb6					      db	46
      1  1fb6		       2e		      .byte.b	46
      0  1fb7					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1fb7					      db	6
      1  1fb7		       06		      .byte.b	6
      0  1fb8					      dw	CO
      1  1fb8		       03 1e		      .word.w	CO
      0  1fba					      IJMP	STMT
      0  1fba					      db	29
      1  1fba		       1d		      .byte.b	29
      0  1fbb					      dw	STMT
      1  1fbb		       0b 1e		      .word.w	STMT
    299  1fbd							;==================================================================
    300  1fbd							; Get input from the terminal
    301  1fbd							;   Reads from the currently active input device
    302  1fbd							;
    303  1fbd				   S9
      0  1fbd					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  1fbd					      db	32
      1  1fbd		       20		      .byte.b	32
      0  1fbe					      db	(S13-*)-1
      1  1fbe		       2a		      .byte.b	(S13-*)-1
      0  1fbf					      db	"INPUT",0
      1  1fbf		       49 4e 50 55*	      .byte.b	"INPUT",0
    305  1fc5				   S10
      0  1fc5					      TSTSTR	S10A	;If there is a string print the prompt
      0  1fc5					      db	55
      1  1fc5		       37		      .byte.b	55
      0  1fc6					      db	(S10A-*)-1
      1  1fc6		       05		      .byte.b	(S10A-*)-1
      0  1fc7					      PRS
      0  1fc7					      db	2
      1  1fc7		       02		      .byte.b	2
      0  1fc8					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  1fc8					      db	32
      1  1fc8		       20		      .byte.b	32
      0  1fc9					      db	(S10Z-*)-1
      1  1fc9		       15		      .byte.b	(S10Z-*)-1
      0  1fca					      db	SEMICOLON,0
      1  1fca		       3b 00		      .byte.b	SEMICOLON,0
    309  1fcc				   S10A
      0  1fcc					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  1fcc					      db	33
      1  1fcc		       21		      .byte.b	33
      0  1fcd					      db	(UNKNOWN-*)-1
      1  1fcd		       d6		      .byte.b	(UNKNOWN-*)-1
      0  1fce					      TST	S10A1,DOLLAR
      0  1fce					      db	32
      1  1fce		       20		      .byte.b	32
      0  1fcf					      db	(S10A1-*)-1
      1  1fcf		       06		      .byte.b	(S10A1-*)-1
      0  1fd0					      db	DOLLAR,0
      1  1fd0		       24 00		      .byte.b	DOLLAR,0
      0  1fd2					      INSTR		;Move character From tty to AESTK
      0  1fd2					      db	59
      1  1fd2		       3b		      .byte.b	59
      0  1fd3					      IJMP	S10A2
      0  1fd3					      db	29
      1  1fd3		       1d		      .byte.b	29
      0  1fd4					      dw	S10A2
      1  1fd4		       d7 1f		      .word.w	S10A2
    314  1fd6				   S10A1
      0  1fd6					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1fd6					      db	11
      1  1fd6		       0b		      .byte.b	11
    316  1fd7				   S10A2
      0  1fd7					      STORE		;STORE IT
      0  1fd7					      db	19
      1  1fd7		       13		      .byte.b	19
      0  1fd8					      TST	S11,COMMA	;IS THERE MORE?
      0  1fd8					      db	32
      1  1fd8		       20		      .byte.b	32
      0  1fd9					      db	(S11-*)-1
      1  1fd9		       08		      .byte.b	(S11-*)-1
      0  1fda					      db	COMMA,0
      1  1fda		       2c 00		      .byte.b	COMMA,0
      0  1fdc					      IJMP	S10	;YES
      0  1fdc					      db	29
      1  1fdc		       1d		      .byte.b	29
      0  1fdd					      dw	S10
      1  1fdd		       c5 1f		      .word.w	S10
    320  1fdf				   S10Z
      0  1fdf					      iJMP	UNKNOWN
      0  1fdf					      db	29
      1  1fdf		       1d		      .byte.b	29
      0  1fe0					      dw	UNKNOWN
      1  1fe0		       a4 20		      .word.w	UNKNOWN
    322  1fe2				   S11
      0  1fe2					      DONE		;MUST BE CR
      0  1fe2					      db	1
      1  1fe2		       01		      .byte.b	1
      0  1fe3					      NXT	CO	;SEQUENCE TO NEXT
      0  1fe3					      db	6
      1  1fe3		       06		      .byte.b	6
      0  1fe4					      dw	CO
      1  1fe4		       03 1e		      .word.w	CO
      0  1fe6					      IJMP	STMT
      0  1fe6					      db	29
      1  1fe6		       1d		      .byte.b	29
      0  1fe7					      dw	STMT
      1  1fe7		       0b 1e		      .word.w	STMT
    326  1fe9							;=====================================================================
    327  1fe9							; End of program, return to command line process
    328  1fe9							; Main Task may also use taske or return to stopped
    329  1fe9							;
    330  1fe9				   S13
      0  1fe9					      TST	S14,"END"
      0  1fe9					      db	32
      1  1fe9		       20		      .byte.b	32
      0  1fea					      db	(S14-*)-1
      1  1fea		       08		      .byte.b	(S14-*)-1
      0  1feb					      db	"END",0
      1  1feb		       45 4e 44 00	      .byte.b	"END",0
      0  1fef					      FIN
      0  1fef					      db	12
      1  1fef		       0c		      .byte.b	12
    333  1ff0
    334  1ff0				   UNKNOWNV
      0  1ff0					      IJMP	UNKNOWN
      0  1ff0					      db	29
      1  1ff0		       1d		      .byte.b	29
      0  1ff1					      dw	UNKNOWN
      1  1ff1		       a4 20		      .word.w	UNKNOWN
    336  1ff3							;====================================================================
    337  1ff3							; IRQ <IRQ-HANDLER-Line expression>
    338  1ff3							;   Specify a line number subroutine to call when an interupt is processed
    339  1ff3							;   These subroutines must use iret to return.
    340  1ff3							;
    341  1ff3				   S14
      0  1ff3					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  1ff3					      db	32
      1  1ff3		       20		      .byte.b	32
      0  1ff4					      db	(S14Z-*)-1
      1  1ff4		       0f		      .byte.b	(S14Z-*)-1
      0  1ff5					      db	"IRQ",0
      1  1ff5		       49 52 51 00	      .byte.b	"IRQ",0
      0  1ff9					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  1ff9					      db	28
      1  1ff9		       1c		      .byte.b	28
      0  1ffa					      dw	EXPR
      1  1ffa		       a8 20		      .word.w	EXPR
      0  1ffc					      DONE		;must be CR
      0  1ffc					      db	1
      1  1ffc		       01		      .byte.b	1
      0  1ffd					      SETIRQ		;Set the line number now
      0  1ffd					      db	56
      1  1ffd		       38		      .byte.b	56
      0  1ffe					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1ffe					      db	6
      1  1ffe		       06		      .byte.b	6
      0  1fff					      dw	CO
      1  1fff		       03 1e		      .word.w	CO
      0  2001					      IJMP	STMT
      0  2001					      db	29
      1  2001		       1d		      .byte.b	29
      0  2002					      dw	STMT
      1  2002		       0b 1e		      .word.w	STMT
    348  2004
    349  2004							;=========================================================================
    350  2004							; KILL PID-expression	 kill a running task
    351  2004							;  ignored of task has already stopped
    352  2004							;
    353  2004				   S14Z
      0  2004					      TST	S14S1,"KILL"	; Kill A running Task
      0  2004					      db	32
      1  2004		       20		      .byte.b	32
      0  2005					      db	(S14S1-*)-1
      1  2005		       10		      .byte.b	(S14S1-*)-1
      0  2006					      db	"KILL",0
      1  2006		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  200b					      CALL	EXPR
      0  200b					      db	28
      1  200b		       1c		      .byte.b	28
      0  200c					      dw	EXPR
      1  200c		       a8 20		      .word.w	EXPR
      0  200e					      DONE
      0  200e					      db	1
      1  200e		       01		      .byte.b	1
      0  200f					      TASKKILL
      0  200f					      db	65
      1  200f		       41		      .byte.b	65
      0  2010					      NXT	CO
      0  2010					      db	6
      1  2010		       06		      .byte.b	6
      0  2011					      dw	CO
      1  2011		       03 1e		      .word.w	CO
      0  2013					      IJMP	STMT
      0  2013					      db	29
      1  2013		       1d		      .byte.b	29
      0  2014					      dw	STMT
      1  2014		       0b 1e		      .word.w	STMT
    360  2016
    361  2016							;============================================================================
    362  2016							; List all program lines
    363  2016							;
    364  2016				   S14S1
      0  2016					      TST	S15,"LIST"	;LIST COMMAND
      0  2016					      db	32
      1  2016		       20		      .byte.b	32
      0  2017					      db	(S15-*)-1
      1  2017		       0a		      .byte.b	(S15-*)-1
      0  2018					      db	"LIST",0
      1  2018		       4c 49 53 54*	      .byte.b	"LIST",0
      0  201d					      DONE
      0  201d					      db	1
      1  201d		       01		      .byte.b	1
      0  201e					      LST
      0  201e					      db	21
      1  201e		       15		      .byte.b	21
      0  201f					      IJMP	CO
      0  201f					      db	29
      1  201f		       1d		      .byte.b	29
      0  2020					      dw	CO
      1  2020		       03 1e		      .word.w	CO
    369  2022							;=======================================================================
    370  2022							;RUN begin to executed the program in memory
    371  2022							;
    372  2022				   S15
      0  2022					      TST	S16,"RUN"	;RUN COMMAND
      0  2022					      db	32
      1  2022		       20		      .byte.b	32
      0  2023					      db	(S16-*)-1
      1  2023		       0d		      .byte.b	(S16-*)-1
      0  2024					      db	"RUN",0
      1  2024		       52 55 4e 00	      .byte.b	"RUN",0
      0  2028					      DONE
      0  2028					      db	1
      1  2028		       01		      .byte.b	1
      0  2029					      VINIT		;clear variables
      0  2029					      db	30
      1  2029		       1e		      .byte.b	30
      0  202a					      LIT	1	;GOTO line 1
      0  202a					      db	27
      1  202a		       1b		      .byte.b	27
      0  202b					      dw	1
      1  202b		       01 00		      .word.w	1
      0  202d					      XFER		;Bob's addition
      0  202d					      db	7
      1  202d		       07		      .byte.b	7
    378  202e							; EXIT
      0  202e					      IJMP	STMT	;and run!
      0  202e					      db	29
      1  202e		       1d		      .byte.b	29
      0  202f					      dw	STMT
      1  202f		       0b 1e		      .word.w	STMT
    380  2031							;=========================================================================
    381  2031							;Clear the program memory, delete all proram lines
    382  2031							;
    383  2031				   S16
      0  2031					      TST	S16A,"NEW"	;clear program
      0  2031					      db	32
      1  2031		       20		      .byte.b	32
      0  2032					      db	(S16A-*)-1
      1  2032		       08		      .byte.b	(S16A-*)-1
      0  2033					      db	"NEW",0
      1  2033		       4e 45 57 00	      .byte.b	"NEW",0
      0  2037					      DONE
      0  2037					      db	1
      1  2037		       01		      .byte.b	1
      0  2038					      IJMP	START
      0  2038					      db	29
      1  2038		       1d		      .byte.b	29
      0  2039					      dw	START
      1  2039		       fd 1d		      .word.w	START
    387  203b
    388  203b							;========================================================================
    389  203b							; Slice(slice legth expression)
    390  203b							;   set the length of time between task switches
    391  203b							;
    392  203b				   S16A
      0  203b					      TST	S16Trace,"SLICE"
      0  203b					      db	32
      1  203b		       20		      .byte.b	32
      0  203c					      db	(S16Trace-*)-1
      1  203c		       11		      .byte.b	(S16Trace-*)-1
      0  203d					      db	"SLICE",0
      1  203d		       53 4c 49 43*	      .byte.b	"SLICE",0
      0  2043					      CALL	EXPR
      0  2043					      db	28
      1  2043		       1c		      .byte.b	28
      0  2044					      dw	EXPR
      1  2044		       a8 20		      .word.w	EXPR
      0  2046					      SLICE
      0  2046					      db	100
      1  2046		       64		      .byte.b	100
      0  2047					      DONE
      0  2047					      db	1
      1  2047		       01		      .byte.b	1
      0  2048					      NXT	CO
      0  2048					      db	6
      1  2048		       06		      .byte.b	6
      0  2049					      dw	CO
      1  2049		       03 1e		      .word.w	CO
      0  204b					      IJMP	STMT
      0  204b					      db	29
      1  204b		       1d		      .byte.b	29
      0  204c					      dw	STMT
      1  204c		       0b 1e		      .word.w	STMT
    399  204e							;==========================================================================
    400  204e							; Turn off and on the thrace functions
    401  204e							; a debug terminal needs to be available
    402  204e							; Trace( Trace flag expression)
    403  204e							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    404  204e							;	for individual lines of basic code. These can be combined
    405  204e				   S16Trace
      0  204e					      TST	S17A,"TRACE("	;Are we going to trace
      0  204e					      db	32
      1  204e		       20		      .byte.b	32
      0  204f					      db	(S17A-*)-1
      1  204f		       16		      .byte.b	(S17A-*)-1
      0  2050					      db	"TRACE(",0
      1  2050		       54 52 41 43*	      .byte.b	"TRACE(",0
      0  2057					      CALL	EXPR
      0  2057					      db	28
      1  2057		       1c		      .byte.b	28
      0  2058					      dw	EXPR
      1  2058		       a8 20		      .word.w	EXPR
      0  205a					      TST	UNKNOWN,")"
      0  205a					      db	32
      1  205a		       20		      .byte.b	32
      0  205b					      db	(UNKNOWN-*)-1
      1  205b		       48		      .byte.b	(UNKNOWN-*)-1
      0  205c					      db	")",0
      1  205c		       29 00		      .byte.b	")",0
      0  205e					      TRACEPROGRAM
      0  205e					      db	78
      1  205e		       4e		      .byte.b	78
      0  205f					      DONE
      0  205f					      db	1
      1  205f		       01		      .byte.b	1
      0  2060					      NXT	CO
      0  2060					      db	6
      1  2060		       06		      .byte.b	6
      0  2061					      dw	CO
      1  2061		       03 1e		      .word.w	CO
      0  2063					      IJMP	STMT
      0  2063					      db	29
      1  2063		       1d		      .byte.b	29
      0  2064					      dw	STMT
      1  2064		       0b 1e		      .word.w	STMT
    413  2066							;=====================================================================
    414  2066							; Exit basic to machine monitor
    415  2066							;
    416  2066				   S17A
      0  2066					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  2066					      db	32
      1  2066		       20		      .byte.b	32
      0  2067					      db	(S17B-*)-1
      1  2067		       06		      .byte.b	(S17B-*)-1
      0  2068					      db	"EXIT",0
      1  2068		       45 58 49 54*	      .byte.b	"EXIT",0
      0  206d					      EXIT
      0  206d					      db	26
      1  206d		       1a		      .byte.b	26
    419  206e
    420  206e							;=======================================================================
    421  206e							; Commands related to saving/restoring programs
    422  206e							; to/from mass storage.
    423  206e							;
    424  206e				   S17B
    425  206e					      if	(XKIM || CTMON65) && DISK_ACCESS
    426  206e
      0  206e					      TST	S17C,"SAVE"
      0  206e					      db	32
      1  206e		       20		      .byte.b	32
      0  206f					      db	(S17C-*)-1
      1  206f		       0b		      .byte.b	(S17C-*)-1
      0  2070					      db	"SAVE",0
      1  2070		       53 41 56 45*	      .byte.b	"SAVE",0
      0  2075					      OPENWRITE
      0  2075					      db	40
      1  2075		       28		      .byte.b	40
      0  2076					      DLIST
      0  2076					      db	43
      1  2076		       2b		      .byte.b	43
      0  2077					      DCLOSE
      0  2077					      db	41
      1  2077		       29		      .byte.b	41
      0  2078					      IJMP	CO
      0  2078					      db	29
      1  2078		       1d		      .byte.b	29
      0  2079					      dw	CO
      1  2079		       03 1e		      .word.w	CO
    432  207b
    433  207b				   S17C
      0  207b					      TST	S18,"LOAD"
      0  207b					      db	32
      1  207b		       20		      .byte.b	32
      0  207c					      db	(S18-*)-1
      1  207c		       11		      .byte.b	(S18-*)-1
      0  207d					      db	"LOAD",0
      1  207d		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  2082					      OPENREAD
      0  2082					      db	39
      1  2082		       27		      .byte.b	39
    436  2083				   S17CLP
      0  2083					      DGETLINE		;get line from file
      0  2083					      db	42
      1  2083		       2a		      .byte.b	42
      0  2084					      TSTL	S17EOL	;no line num means EOL
      0  2084					      db	34
      1  2084		       22		      .byte.b	34
      0  2085					      db	(S17EOL-*)-1
      1  2085		       04		      .byte.b	(S17EOL-*)-1
      0  2086					      INSERT		;put it into the program
      0  2086					      db	24
      1  2086		       18		      .byte.b	24
      0  2087					      IJMP	S17CLP	;keep going
      0  2087					      db	29
      1  2087		       1d		      .byte.b	29
      0  2088					      dw	S17CLP
      1  2088		       83 20		      .word.w	S17CLP
    441  208a				   S17EOL
      0  208a					      DCLOSE		;close disk file
      0  208a					      db	41
      1  208a		       29		      .byte.b	41
      0  208b					      IJMP	CO	;back to start
      0  208b					      db	29
      1  208b		       1d		      .byte.b	29
      0  208c					      dw	CO
      1  208c		       03 1e		      .word.w	CO
    444  208e
    445  208e				   S18
      0  208e					      TST	S19,"DIR"
      0  208e					      db	32
      1  208e		       20		      .byte.b	32
      0  208f					      db	(S19-*)-1
      1  208f		       08		      .byte.b	(S19-*)-1
      0  2090					      db	"DIR",0
      1  2090		       44 49 52 00	      .byte.b	"DIR",0
      0  2094					      DDIR		;Display the directory content
      0  2094					      db	44
      1  2094		       2c		      .byte.b	44
      0  2095					      IJMP	CO
      0  2095					      db	29
      1  2095		       1d		      .byte.b	29
      0  2096					      dw	CO
      1  2096		       03 1e		      .word.w	CO
    449  2098
      0  2098				   S19	      TST	UNKNOWN,"ERASE"
      0  2098					      db	32
      1  2098		       20		      .byte.b	32
      0  2099					      db	(UNKNOWN-*)-1
      1  2099		       0a		      .byte.b	(UNKNOWN-*)-1
      0  209a					      db	"ERASE",0
      1  209a		       45 52 41 53*	      .byte.b	"ERASE",0
      0  20a0					      RMFILE		;Erase the file from the disk
      0  20a0					      db	45
      1  20a0		       2d		      .byte.b	45
      0  20a1					      IJMP	CO
      0  20a1					      db	29
      1  20a1		       1d		      .byte.b	29
      0  20a2					      dw	CO
      1  20a2		       03 1e		      .word.w	CO
    453  20a4
    454  20a4					      endif
    455  20a4
    456  20a4							;
    457  20a4							; Else, unknown command.
    458  20a4							;
    459  20a4				   UNKNOWN
      0  20a4					      ENDIO
      0  20a4					      db	71
      1  20a4		       47		      .byte.b	71
      0  20a5					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  20a5					      db	13
      1  20a5		       0d		      .byte.b	13
      0  20a6					      dw	ERR_SYNTAX
      1  20a6		       05 00		      .word.w	ERR_SYNTAX
    462  20a8
    463  20a8							;=======================================================
    464  20a8							; Process Expresions, precidence is represented by the
    465  20a8							; various call levels
    466  20a8							;
    467  20a8				   EXPR
      0  20a8					      TST	EXPRLOGS,"NOT"
      0  20a8					      db	32
      1  20a8		       20		      .byte.b	32
      0  20a9					      db	(EXPRLOGS-*)-1
      1  20a9		       09		      .byte.b	(EXPRLOGS-*)-1
      0  20aa					      db	"NOT",0
      1  20aa		       4e 4f 54 00	      .byte.b	"NOT",0
      0  20ae					      Call	EXPR
      0  20ae					      db	28
      1  20ae		       1c		      .byte.b	28
      0  20af					      dw	EXPR
      1  20af		       a8 20		      .word.w	EXPR
      0  20b1					      LOGNOT
      0  20b1					      db	72
      1  20b1		       48		      .byte.b	72
      0  20b2					      RTN
      0  20b2					      db	25
      1  20b2		       19		      .byte.b	25
    472  20b3
    473  20b3							;=========================================================
    474  20b3							;Look for logical operators
    475  20b3				   EXPRLOGS
      0  20b3					      Call	EXPRCMP
      0  20b3					      db	28
      1  20b3		       1c		      .byte.b	28
      0  20b4					      dw	EXPRCMP
      1  20b4		       d7 20		      .word.w	EXPRCMP
      0  20b6					      TST	iLOG1,"AND"
      0  20b6					      db	32
      1  20b6		       20		      .byte.b	32
      0  20b7					      db	(iLOG1-*)-1
      1  20b7		       09		      .byte.b	(iLOG1-*)-1
      0  20b8					      db	"AND",0
      1  20b8		       41 4e 44 00	      .byte.b	"AND",0
      0  20bc					      Call	EXPR
      0  20bc					      db	28
      1  20bc		       1c		      .byte.b	28
      0  20bd					      dw	EXPR
      1  20bd		       a8 20		      .word.w	EXPR
      0  20bf					      LOGAND
      0  20bf					      db	74
      1  20bf		       4a		      .byte.b	74
      0  20c0					      RTN
      0  20c0					      db	25
      1  20c0		       19		      .byte.b	25
    481  20c1				   iLOG1
      0  20c1					      TST	iLOG2,"OR"
      0  20c1					      db	32
      1  20c1		       20		      .byte.b	32
      0  20c2					      db	(iLOG2-*)-1
      1  20c2		       08		      .byte.b	(iLOG2-*)-1
      0  20c3					      db	"OR",0
      1  20c3		       4f 52 00 	      .byte.b	"OR",0
      0  20c6					      Call	EXPR
      0  20c6					      db	28
      1  20c6		       1c		      .byte.b	28
      0  20c7					      dw	EXPR
      1  20c7		       a8 20		      .word.w	EXPR
      0  20c9					      LOGOR
      0  20c9					      db	73
      1  20c9		       49		      .byte.b	73
      0  20ca					      RTN
      0  20ca					      db	25
      1  20ca		       19		      .byte.b	25
    486  20cb				   iLOG2
      0  20cb					      TST	iLOG3,"XOR"
      0  20cb					      db	32
      1  20cb		       20		      .byte.b	32
      0  20cc					      db	(iLOG3-*)-1
      1  20cc		       09		      .byte.b	(iLOG3-*)-1
      0  20cd					      db	"XOR",0
      1  20cd		       58 4f 52 00	      .byte.b	"XOR",0
      0  20d1					      Call	EXPR
      0  20d1					      db	28
      1  20d1		       1c		      .byte.b	28
      0  20d2					      dw	EXPR
      1  20d2		       a8 20		      .word.w	EXPR
      0  20d4					      LOGXOR
      0  20d4					      db	75
      1  20d4		       4b		      .byte.b	75
      0  20d5					      RTN
      0  20d5					      db	25
      1  20d5		       19		      .byte.b	25
    491  20d6				   iLOG3
      0  20d6					      RTN
      0  20d6					      db	25
      1  20d6		       19		      .byte.b	25
    493  20d7
    494  20d7				   EXPRCMP
      0  20d7					      Call	EXPR2	; get the first expression
      0  20d7					      db	28
      1  20d7		       1c		      .byte.b	28
      0  20d8					      dw	EXPR2
      1  20d8		       23 21		      .word.w	EXPR2
      0  20da					      TST	iR0,"="
      0  20da					      db	32
      1  20da		       20		      .byte.b	32
      0  20db					      db	(iR0-*)-1
      1  20db		       08		      .byte.b	(iR0-*)-1
      0  20dc					      db	"=",0
      1  20dc		       3d 00		      .byte.b	"=",0
      0  20de					      LIT	2	;=
      0  20de					      db	27
      1  20de		       1b		      .byte.b	27
      0  20df					      dw	2
      1  20df		       02 00		      .word.w	2
      0  20e1					      IJMP	iRFound
      0  20e1					      db	29
      1  20e1		       1d		      .byte.b	29
      0  20e2					      dw	iRFound
      1  20e2		       1d 21		      .word.w	iRFound
    499  20e4				   iR0
      0  20e4					      TST	iR4,"<"
      0  20e4					      db	32
      1  20e4		       20		      .byte.b	32
      0  20e5					      db	(iR4-*)-1
      1  20e5		       1c		      .byte.b	(iR4-*)-1
      0  20e6					      db	"<",0
      1  20e6		       3c 00		      .byte.b	"<",0
      0  20e8					      TST	iR1,"="
      0  20e8					      db	32
      1  20e8		       20		      .byte.b	32
      0  20e9					      db	(iR1-*)-1
      1  20e9		       08		      .byte.b	(iR1-*)-1
      0  20ea					      db	"=",0
      1  20ea		       3d 00		      .byte.b	"=",0
      0  20ec					      LIT	3	;<=
      0  20ec					      db	27
      1  20ec		       1b		      .byte.b	27
      0  20ed					      dw	3
      1  20ed		       03 00		      .word.w	3
      0  20ef					      IJMP	iRFound
      0  20ef					      db	29
      1  20ef		       1d		      .byte.b	29
      0  20f0					      dw	iRFound
      1  20f0		       1d 21		      .word.w	iRFound
    504  20f2				   iR1
      0  20f2					      TST	iR3,">"
      0  20f2					      db	32
      1  20f2		       20		      .byte.b	32
      0  20f3					      db	(iR3-*)-1
      1  20f3		       08		      .byte.b	(iR3-*)-1
      0  20f4					      db	">",0
      1  20f4		       3e 00		      .byte.b	">",0
      0  20f6					      LIT	5	;<>
      0  20f6					      db	27
      1  20f6		       1b		      .byte.b	27
      0  20f7					      dw	5
      1  20f7		       05 00		      .word.w	5
      0  20f9					      IJMP	iRFound
      0  20f9					      db	29
      1  20f9		       1d		      .byte.b	29
      0  20fa					      dw	iRFound
      1  20fa		       1d 21		      .word.w	iRFound
    508  20fc				   iR3
      0  20fc					      LIT	1	;<
      0  20fc					      db	27
      1  20fc		       1b		      .byte.b	27
      0  20fd					      dw	1
      1  20fd		       01 00		      .word.w	1
      0  20ff					      IJMP	iRFound
      0  20ff					      db	29
      1  20ff		       1d		      .byte.b	29
      0  2100					      dw	iRFound
      1  2100		       1d 21		      .word.w	iRFound
    511  2102				   iR4
      0  2102					      TST	iRDone,">"
      0  2102					      db	32
      1  2102		       20		      .byte.b	32
      0  2103					      db	(iRDone-*)-1
      1  2103		       1e		      .byte.b	(iRDone-*)-1
      0  2104					      db	">",0
      1  2104		       3e 00		      .byte.b	">",0
      0  2106					      TST	iR5,"="
      0  2106					      db	32
      1  2106		       20		      .byte.b	32
      0  2107					      db	(iR5-*)-1
      1  2107		       08		      .byte.b	(iR5-*)-1
      0  2108					      db	"=",0
      1  2108		       3d 00		      .byte.b	"=",0
      0  210a					      LIT	6	;>=
      0  210a					      db	27
      1  210a		       1b		      .byte.b	27
      0  210b					      dw	6
      1  210b		       06 00		      .word.w	6
      0  210d					      IJMP	iRFound
      0  210d					      db	29
      1  210d		       1d		      .byte.b	29
      0  210e					      dw	iRFound
      1  210e		       1d 21		      .word.w	iRFound
    516  2110				   iR5
      0  2110					      TST	iR6,"<"
      0  2110					      db	32
      1  2110		       20		      .byte.b	32
      0  2111					      db	(iR6-*)-1
      1  2111		       08		      .byte.b	(iR6-*)-1
      0  2112					      db	"<",0
      1  2112		       3c 00		      .byte.b	"<",0
      0  2114					      LIT	1
      0  2114					      db	27
      1  2114		       1b		      .byte.b	27
      0  2115					      dw	1
      1  2115		       01 00		      .word.w	1
      0  2117					      IJMP	iRFound	;(This line originally omitted)
      0  2117					      db	29
      1  2117		       1d		      .byte.b	29
      0  2118					      dw	iRFound
      1  2118		       1d 21		      .word.w	iRFound
    520  211a				   iR6
      0  211a					      LIT	4	;>
      0  211a					      db	27
      1  211a		       1b		      .byte.b	27
      0  211b					      dw	4
      1  211b		       04 00		      .word.w	4
    522  211d				   iRFound
      0  211d					      Call	EXPR	; get the right side of the expression
      0  211d					      db	28
      1  211d		       1c		      .byte.b	28
      0  211e					      dw	EXPR
      1  211e		       a8 20		      .word.w	EXPR
      0  2120					      CMPR		; Push the value of the true false onto the stack
      0  2120					      db	10
      1  2120		       0a		      .byte.b	10
      0  2121					      RTN
      0  2121					      db	25
      1  2121		       19		      .byte.b	25
    526  2122
    527  2122				   iRDone
      0  2122					      RTN
      0  2122					      db	25
      1  2122		       19		      .byte.b	25
    529  2123
    530  2123				   EXPR2
      0  2123					      TST	E0,"-"	; Look for leading - to negate term
      0  2123					      db	32
      1  2123		       20		      .byte.b	32
      0  2124					      db	(E0-*)-1
      1  2124		       09		      .byte.b	(E0-*)-1
      0  2125					      db	"-",0
      1  2125		       2d 00		      .byte.b	"-",0
      0  2127					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  2127					      db	28
      1  2127		       1c		      .byte.b	28
      0  2128					      dw	TERM
      1  2128		       4c 21		      .word.w	TERM
      0  212a					      NEG		; Make value negated
      0  212a					      db	16
      1  212a		       10		      .byte.b	16
      0  212b					      IJMP	E1	; We have Left term process operators next
      0  212b					      db	29
      1  212b		       1d		      .byte.b	29
      0  212c					      dw	E1
      1  212c		       35 21		      .word.w	E1
    535  212e				   E0
      0  212e					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  212e					      db	32
      1  212e		       20		      .byte.b	32
      0  212f					      db	(E1A-*)-1
      1  212f		       02		      .byte.b	(E1A-*)-1
      0  2130					      db	"+",0
      1  2130		       2b 00		      .byte.b	"+",0
    537  2132				   E1A
      0  2132					      CALL	TERM	; Get the left term if it was not negated
      0  2132					      db	28
      1  2132		       1c		      .byte.b	28
      0  2133					      dw	TERM
      1  2133		       4c 21		      .word.w	TERM
    539  2135				   E1
      0  2135					      TST	E2,"+"	; Check if we are adding left term to something
      0  2135					      db	32
      1  2135		       20		      .byte.b	32
      0  2136					      db	(E2-*)-1
      1  2136		       09		      .byte.b	(E2-*)-1
      0  2137					      db	"+",0
      1  2137		       2b 00		      .byte.b	"+",0
      0  2139					      CALL	TERM	; if adding then get the right side term
      0  2139					      db	28
      1  2139		       1c		      .byte.b	28
      0  213a					      dw	TERM
      1  213a		       4c 21		      .word.w	TERM
      0  213c					      ADD		; Add it to left term
      0  213c					      db	14
      1  213c		       0e		      .byte.b	14
      0  213d					      IJMP	E1	; look for next + or -
      0  213d					      db	29
      1  213d		       1d		      .byte.b	29
      0  213e					      dw	E1
      1  213e		       35 21		      .word.w	E1
    544  2140				   E2
      0  2140					      TST	E3,"-"	; Check if we are subtractig something
      0  2140					      db	32
      1  2140		       20		      .byte.b	32
      0  2141					      db	(E3-*)-1
      1  2141		       09		      .byte.b	(E3-*)-1
      0  2142					      db	"-",0
      1  2142		       2d 00		      .byte.b	"-",0
      0  2144					      CALL	TERM	; get right side to subtract Diffrence
      0  2144					      db	28
      1  2144		       1c		      .byte.b	28
      0  2145					      dw	TERM
      1  2145		       4c 21		      .word.w	TERM
      0  2147					      SUB		; Subtract the value
      0  2147					      db	15
      1  2147		       0f		      .byte.b	15
      0  2148					      IJMP	E1	; Look for next + or -
      0  2148					      db	29
      1  2148		       1d		      .byte.b	29
      0  2149					      dw	E1
      1  2149		       35 21		      .word.w	E1
    549  214b				   E3			; Finish processing the expression
      0  214b					      RTN		; We are finished processing the Expression
      0  214b					      db	25
      1  214b		       19		      .byte.b	25
    551  214c							;
    552  214c							; Get one of the terms of an expression
    553  214c							;
    554  214c				   TERM
      0  214c					      CALL	FACT	; Get a value
      0  214c					      db	28
      1  214c		       1c		      .byte.b	28
      0  214d					      dw	FACT
      1  214d		       74 21		      .word.w	FACT
    556  214f				   T0			; Check for higher precidence operators
      0  214f					      TST	T1,"*"	; Check for *
      0  214f					      db	32
      1  214f		       20		      .byte.b	32
      0  2150					      db	(T1-*)-1
      1  2150		       09		      .byte.b	(T1-*)-1
      0  2151					      db	"*",0
      1  2151		       2a 00		      .byte.b	"*",0
      0  2153					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  2153					      db	28
      1  2153		       1c		      .byte.b	28
      0  2154					      dw	FACT
      1  2154		       74 21		      .word.w	FACT
      0  2156					      MUL		; Multiply factors
      0  2156					      db	17
      1  2156		       11		      .byte.b	17
      0  2157					      IJMP	T0	; Check for * or /
      0  2157					      db	29
      1  2157		       1d		      .byte.b	29
      0  2158					      dw	T0
      1  2158		       4f 21		      .word.w	T0
    561  215a				   T1
      0  215a					      TST	T2,"/"	; Check for a division
      0  215a					      db	32
      1  215a		       20		      .byte.b	32
      0  215b					      db	(T2-*)-1
      1  215b		       09		      .byte.b	(T2-*)-1
      0  215c					      db	"/",0
      1  215c		       2f 00		      .byte.b	"/",0
      0  215e					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  215e					      db	28
      1  215e		       1c		      .byte.b	28
      0  215f					      dw	FACT
      1  215f		       74 21		      .word.w	FACT
      0  2161					      DIV		; do division
      0  2161					      db	18
      1  2161		       12		      .byte.b	18
      0  2162					      IJMP	T0	; check for more * or /
      0  2162					      db	29
      1  2162		       1d		      .byte.b	29
      0  2163					      dw	T0
      1  2163		       4f 21		      .word.w	T0
    566  2165				   T2
      0  2165					      TST	T3,"%"	; Check for a division
      0  2165					      db	32
      1  2165		       20		      .byte.b	32
      0  2166					      db	(T3-*)-1
      1  2166		       09		      .byte.b	(T3-*)-1
      0  2167					      db	"%",0
      1  2167		       25 00		      .byte.b	"%",0
      0  2169					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  2169					      db	28
      1  2169		       1c		      .byte.b	28
      0  216a					      dw	FACT
      1  216a		       74 21		      .word.w	FACT
      0  216c					      MODULO		; do division for remainder
      0  216c					      db	60
      1  216c		       3c		      .byte.b	60
      0  216d					      IJMP	T0	; check for more * or / or %
      0  216d					      db	29
      1  216d		       1d		      .byte.b	29
      0  216e					      dw	T0
      1  216e		       4f 21		      .word.w	T0
    571  2170				   T3			; Finish processing the Term
      0  2170					      RTN
      0  2170					      db	25
      1  2170		       19		      .byte.b	25
    573  2171
    574  2171				   UNKNOWNVEC
      0  2171					      IJMP	UNKNOWN
      0  2171					      db	29
      1  2171		       1d		      .byte.b	29
      0  2172					      dw	UNKNOWN
      1  2172		       a4 20		      .word.w	UNKNOWN
    576  2174
    577  2174							;=============================================================================================
    578  2174							; Factor an expression.  Always test for functions
    579  2174							; first or else they'll be confused for variables.
    580  2174							;
    581  2174				   FACT
      0  2174					      TST	F1AA,"TRUE"
      0  2174					      db	32
      1  2174		       20		      .byte.b	32
      0  2175					      db	(F1AA-*)-1
      1  2175		       09		      .byte.b	(F1AA-*)-1
      0  2176					      db	"TRUE",0
      1  2176		       54 52 55 45*	      .byte.b	"TRUE",0
      0  217b					      LIT	-1
      0  217b					      db	27
      1  217b		       1b		      .byte.b	27
      0  217c					      dw	-1
      1  217c		       ff ff		      .word.w	-1
      0  217e					      RTN
      0  217e					      db	25
      1  217e		       19		      .byte.b	25
    585  217f				   F1AA
      0  217f					      TST	F1AB,"FALSE"
      0  217f					      db	32
      1  217f		       20		      .byte.b	32
      0  2180					      db	(F1AB-*)-1
      1  2180		       0a		      .byte.b	(F1AB-*)-1
      0  2181					      db	"FALSE",0
      1  2181		       46 41 4c 53*	      .byte.b	"FALSE",0
      0  2187					      LIT	0
      0  2187					      db	27
      1  2187		       1b		      .byte.b	27
      0  2188					      dw	0
      1  2188		       00 00		      .word.w	0
      0  218a					      RTN
      0  218a					      db	25
      1  218a		       19		      .byte.b	25
    589  218b							;==================================================================================
    590  218b							; Returns the amount of free SPACE
    591  218b							;
    592  218b				   F1AB
      0  218b					      TST	F1A,"FREE()"
      0  218b					      db	32
      1  218b		       20		      .byte.b	32
      0  218c					      db	(F1A-*)-1
      1  218c		       09		      .byte.b	(F1A-*)-1
      0  218d					      db	"FREE()",0
      1  218d		       46 52 45 45*	      .byte.b	"FREE()",0
      0  2194					      FREE
      0  2194					      db	36
      1  2194		       24		      .byte.b	36
      0  2195					      RTN
      0  2195					      db	25
      1  2195		       19		      .byte.b	25
    596  2196							;===================================================================================
    597  2196							; getch() read a character from the input device
    598  2196							;
    599  2196				   F1A
      0  2196					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  2196					      db	32
      1  2196		       20		      .byte.b	32
      0  2197					      db	(F1A2-*)-1
      1  2197		       0a		      .byte.b	(F1A2-*)-1
      0  2198					      db	"GETCH()",0
      1  2198		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  21a0					      GETCHAR
      0  21a0					      db	51
      1  21a0		       33		      .byte.b	51
      0  21a1					      RTN
      0  21a1					      db	25
      1  21a1		       19		      .byte.b	25
    603  21a2							;====================================================================================
    604  21a2							; peek(mem address) return the value of a byte in memory
    605  21a2							; @[offset] return a word value from offset -- see tstv
    606  21a2							;
    607  21a2				   F1A2
      0  21a2					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  21a2					      db	32
      1  21a2		       20		      .byte.b	32
      0  21a3					      db	(F2AZ-*)-1
      1  21a3		       0f		      .byte.b	(F2AZ-*)-1
      0  21a4					      db	"PEEK(",0
      1  21a4		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  21aa					      CALL	EXPR	;Get the address to write to
      0  21aa					      db	28
      1  21aa		       1c		      .byte.b	28
      0  21ab					      dw	EXPR
      1  21ab		       a8 20		      .word.w	EXPR
      0  21ad					      TST	UNKNOWNVEC,")"	;Closing bracket
      0  21ad					      db	32
      1  21ad		       20		      .byte.b	32
      0  21ae					      db	(UNKNOWNVEC-*)-1
      1  21ae		       c2		      .byte.b	(UNKNOWNVEC-*)-1
      0  21af					      db	")",0
      1  21af		       29 00		      .byte.b	")",0
      0  21b1					      PEEKMEM
      0  21b1					      db	48
      1  21b1		       30		      .byte.b	48
      0  21b2					      RTN
      0  21b2					      db	25
      1  21b2		       19		      .byte.b	25
    613  21b3							;=======================================================================================
    614  21b3							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    615  21b3							;
    616  21b3				   F2AZ
      0  21b3					      TST	F2AZ1,"TASK("	;Check if we are setting a task start
      0  21b3					      db	32
      1  21b3		       20		      .byte.b	32
      0  21b4					      db	(F2AZ1-*)-1
      1  21b4		       22		      .byte.b	(F2AZ1-*)-1
      0  21b5					      db	"TASK(",0
      1  21b5		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  21bb					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  21bb					      db	28
      1  21bb		       1c		      .byte.b	28
      0  21bc					      dw	EXPR
      1  21bc		       a8 20		      .word.w	EXPR
      0  21be					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  21be					      db	61
      1  21be		       3d		      .byte.b	61
      0  21bf					      TST	F2AZNoParms,COMMA	;Parameters to be passed to task
      0  21bf					      db	32
      1  21bf		       20		      .byte.b	32
      0  21c0					      db	(F2AZNoParms-*)-1
      1  21c0		       10		      .byte.b	(F2AZNoParms-*)-1
      0  21c1					      db	COMMA,0
      1  21c1		       2c 00		      .byte.b	COMMA,0
      0  21c3					      SAVEMATHSTACK		;Push The mathstack
      0  21c3					      db	86
      1  21c3		       56		      .byte.b	86
      0  21c4					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  21c4					      db	89
      1  21c4		       59		      .byte.b	89
    623  21c5				   F2AZLOOP
      0  21c5					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  21c5					      db	28
      1  21c5		       1c		      .byte.b	28
      0  21c6					      dw	EXPR
      1  21c6		       a8 20		      .word.w	EXPR
      0  21c8					      TST	F2AZEndParm,COMMA	;Parameters to be passed tp task
      0  21c8					      db	32
      1  21c8		       20		      .byte.b	32
      0  21c9					      db	(F2AZEndParm-*)-1
      1  21c9		       05		      .byte.b	(F2AZEndParm-*)-1
      0  21ca					      db	COMMA,0
      1  21ca		       2c 00		      .byte.b	COMMA,0
      0  21cc					      IJMP	F2AZLOOP	;check for more
      0  21cc					      db	29
      1  21cc		       1d		      .byte.b	29
      0  21cd					      dw	F2AZLOOP
      1  21cd		       c5 21		      .word.w	F2AZLOOP
    627  21cf				   F2AZEndParm
      0  21cf					      RESTOREMATHSTACK		;Back to normal stack
      0  21cf					      db	87
      1  21cf		       57		      .byte.b	87
      0  21d0					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  21d0					      db	92
      1  21d0		       5c		      .byte.b	92
    630  21d1				   F2AZNoParms
      0  21d1					      TST	UNKNOWNVEC,")"	;must be )
      0  21d1					      db	32
      1  21d1		       20		      .byte.b	32
      0  21d2					      db	(UNKNOWNVEC-*)-1
      1  21d2		       9e		      .byte.b	(UNKNOWNVEC-*)-1
      0  21d3					      db	")",0
      1  21d3		       29 00		      .byte.b	")",0
      0  21d5					      TASKENABLE		;Enable the task to execute
      0  21d5					      db	90
      1  21d5		       5a		      .byte.b	90
      0  21d6					      RTN		;Returns the Task number
      0  21d6					      db	25
      1  21d6		       19		      .byte.b	25
    634  21d7							;=========================================================================================
    635  21d7							; Check for IPC interproccess instructions
    636  21d7							;   IPCS  - Send a message
    637  21d7							;
    638  21d7				   F2AZ1
      0  21d7					      TST	F2A,"IPC"	;Test if one of the IPC functions
      0  21d7					      db	32
      1  21d7		       20		      .byte.b	32
      0  21d8					      db	(F2A-*)-1
      1  21d8		       3c		      .byte.b	(F2A-*)-1
      0  21d9					      db	"IPC",0
      1  21d9		       49 50 43 00	      .byte.b	"IPC",0
      0  21dd					      TST	F2AZa,"S("	;IPCS - send a message
      0  21dd					      db	32
      1  21dd		       20		      .byte.b	32
      0  21de					      db	(F2AZa-*)-1
      1  21de		       13		      .byte.b	(F2AZa-*)-1
      0  21df					      db	"S(",0
      1  21df		       53 28 00 	      .byte.b	"S(",0
      0  21e2					      CALL	EXPR	;Get the message value
      0  21e2					      db	28
      1  21e2		       1c		      .byte.b	28
      0  21e3					      dw	EXPR
      1  21e3		       a8 20		      .word.w	EXPR
      0  21e5					      TST	UNKNOWNVEC,COMMA
      0  21e5					      db	32
      1  21e5		       20		      .byte.b	32
      0  21e6					      db	(UNKNOWNVEC-*)-1
      1  21e6		       8a		      .byte.b	(UNKNOWNVEC-*)-1
      0  21e7					      db	COMMA,0
      1  21e7		       2c 00		      .byte.b	COMMA,0
      0  21e9					      CALL	EXPR	;Get pid of task to send to
      0  21e9					      db	28
      1  21e9		       1c		      .byte.b	28
      0  21ea					      dw	EXPR
      1  21ea		       a8 20		      .word.w	EXPR
      0  21ec					      TST	UNKNOWNVEC,")"
      0  21ec					      db	32
      1  21ec		       20		      .byte.b	32
      0  21ed					      db	(UNKNOWNVEC-*)-1
      1  21ed		       83		      .byte.b	(UNKNOWNVEC-*)-1
      0  21ee					      db	")",0
      1  21ee		       29 00		      .byte.b	")",0
      0  21f0					      IPCSEND		;Send msg and clear pid msg pending
      0  21f0					      db	80
      1  21f0		       50		      .byte.b	80
      0  21f1					      RTN
      0  21f1					      db	25
      1  21f1		       19		      .byte.b	25
    647  21f2							;================================================================================
    648  21f2							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    649  21f2							;
    650  21f2				   F2AZa
      0  21f2					      TST	F2AZb,"R("	;IPCR recieve a message , wait if none
      0  21f2					      db	32
      1  21f2		       20		      .byte.b	32
      0  21f3					      db	(F2AZb-*)-1
      1  21f3		       16		      .byte.b	(F2AZb-*)-1
      0  21f4					      db	"R(",0
      1  21f4		       52 28 00 	      .byte.b	"R(",0
      0  21f7					      TST	F2AZa1,")"
      0  21f7					      db	32
      1  21f7		       20		      .byte.b	32
      0  21f8					      db	(F2AZa1-*)-1
      1  21f8		       08		      .byte.b	(F2AZa1-*)-1
      0  21f9					      db	")",0
      1  21f9		       29 00		      .byte.b	")",0
      0  21fb					      LIT	0	;We dont want the pid returned to us
      0  21fb					      db	27
      1  21fb		       1b		      .byte.b	27
      0  21fc					      dw	0
      1  21fc		       00 00		      .word.w	0
      0  21fe					      IPCIO		;Set the io bit and suspend the task till message
      0  21fe					      db	83
      1  21fe		       53		      .byte.b	83
      0  21ff					      IPCRECEIVE		;Get the message
      0  21ff					      db	81
      1  21ff		       51		      .byte.b	81
      0  2200					      RTN
      0  2200					      db	25
      1  2200		       19		      .byte.b	25
    657  2201				   F2AZa1
      0  2201					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  2201					      db	33
      1  2201		       21		      .byte.b	33
      0  2202					      db	(UNKNOWNVEC-*)-1
      1  2202		       6e		      .byte.b	(UNKNOWNVEC-*)-1
      0  2203					      TST	UNKNOWNVEC,")"
      0  2203					      db	32
      1  2203		       20		      .byte.b	32
      0  2204					      db	(UNKNOWNVEC-*)-1
      1  2204		       6c		      .byte.b	(UNKNOWNVEC-*)-1
      0  2205					      db	")",0
      1  2205		       29 00		      .byte.b	")",0
      0  2207					      IPCIO		;Set the io bit and exit task till message
      0  2207					      db	83
      1  2207		       53		      .byte.b	83
      0  2208					      IPCRECEIVE		;Get the message
      0  2208					      db	81
      1  2208		       51		      .byte.b	81
      0  2209					      RTN
      0  2209					      db	25
      1  2209		       19		      .byte.b	25
    663  220a							;===============================================================================
    664  220a							; IPCC ---- check if a message is available
    665  220a				   F2AZb
      0  220a					      TST	UNKNOWNVEC,"C()"	;Returns number of messages on the message queue
      0  220a					      db	32
      1  220a		       20		      .byte.b	32
      0  220b					      db	(UNKNOWNVEC-*)-1
      1  220b		       65		      .byte.b	(UNKNOWNVEC-*)-1
      0  220c					      db	"C()",0
      1  220c		       43 28 29 00	      .byte.b	"C()",0
      0  2210					      IPCCHECK
      0  2210					      db	82
      1  2210		       52		      .byte.b	82
      0  2211					      RTN
      0  2211					      db	25
      1  2211		       19		      .byte.b	25
    669  2212
    670  2212				   UNKNOWNID
      0  2212					      IJMP	UNKNOWN
      0  2212					      db	29
      1  2212		       1d		      .byte.b	29
      0  2213					      dw	UNKNOWN
      1  2213		       a4 20		      .word.w	UNKNOWN
    672  2215							;============================================================
    673  2215							; RND() is supposed to have an argument but if none
    674  2215							; was provided, just assume a large value.
    675  2215							;
    676  2215				   F2A
      0  2215					      TST	F2B,"RND("
      0  2215					      db	32
      1  2215		       20		      .byte.b	32
      0  2216					      db	(F2B-*)-1
      1  2216		       17		      .byte.b	(F2B-*)-1
      0  2217					      db	"RND(",0
      1  2217		       52 4e 44 28*	      .byte.b	"RND(",0
      0  221c					      TST	F2A1,")"
      0  221c					      db	32
      1  221c		       20		      .byte.b	32
      0  221d					      db	(F2A1-*)-1
      1  221d		       07		      .byte.b	(F2A1-*)-1
      0  221e					      db	")",0
      1  221e		       29 00		      .byte.b	")",0
      0  2220					      LIT	32766
      0  2220					      db	27
      1  2220		       1b		      .byte.b	27
      0  2221					      dw	32766
      1  2221		       fe 7f		      .word.w	32766
      0  2223					      RANDOM
      0  2223					      db	37
      1  2223		       25		      .byte.b	37
      0  2224					      RTN
      0  2224					      db	25
      1  2224		       19		      .byte.b	25
    682  2225
    683  2225				   F2A1
      0  2225					      CALL	FACT	;GET RANGE
      0  2225					      db	28
      1  2225		       1c		      .byte.b	28
      0  2226					      dw	FACT
      1  2226		       74 21		      .word.w	FACT
      0  2228					      TST	UNKNOWNVEC,")"
      0  2228					      db	32
      1  2228		       20		      .byte.b	32
      0  2229					      db	(UNKNOWNVEC-*)-1
      1  2229		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  222a					      db	")",0
      1  222a		       29 00		      .byte.b	")",0
      0  222c					      RANDOM
      0  222c					      db	37
      1  222c		       25		      .byte.b	37
      0  222d					      RTN
      0  222d					      db	25
      1  222d		       19		      .byte.b	25
    688  222e							;==========================================================
    689  222e							;	Return absolute value of expresion
    690  222e							;
    691  222e				   F2B
      0  222e					      TST	F2B2,"ABS("
      0  222e					      db	32
      1  222e		       20		      .byte.b	32
      0  222f					      db	(F2B2-*)-1
      1  222f		       0e		      .byte.b	(F2B2-*)-1
      0  2230					      db	"ABS(",0
      1  2230		       41 42 53 28*	      .byte.b	"ABS(",0
      0  2235					      CALL	EXPR	;get value
      0  2235					      db	28
      1  2235		       1c		      .byte.b	28
      0  2236					      dw	EXPR
      1  2236		       a8 20		      .word.w	EXPR
      0  2238					      TST	UNKNOWNVEC,")"
      0  2238					      db	32
      1  2238		       20		      .byte.b	32
      0  2239					      db	(UNKNOWNVEC-*)-1
      1  2239		       37		      .byte.b	(UNKNOWNVEC-*)-1
      0  223a					      db	")",0
      1  223a		       29 00		      .byte.b	")",0
      0  223c					      ABS
      0  223c					      db	38
      1  223c		       26		      .byte.b	38
      0  223d					      RTN
      0  223d					      db	25
      1  223d		       19		      .byte.b	25
    697  223e							;============================================================
    698  223e							;     Return the the status of a task, provide the PID
    699  223e							;
    700  223e				   F2B2
      0  223e					      TST	F2Z,"STAT("
      0  223e					      db	32
      1  223e		       20		      .byte.b	32
      0  223f					      db	(F2Z-*)-1
      1  223f		       0f		      .byte.b	(F2Z-*)-1
      0  2240					      db	"STAT(",0
      1  2240		       53 54 41 54*	      .byte.b	"STAT(",0
      0  2246					      Call	EXPR
      0  2246					      db	28
      1  2246		       1c		      .byte.b	28
      0  2247					      dw	EXPR
      1  2247		       a8 20		      .word.w	EXPR
      0  2249					      TST	UNKNOWNVEC,")"
      0  2249					      db	32
      1  2249		       20		      .byte.b	32
      0  224a					      db	(UNKNOWNVEC-*)-1
      1  224a		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  224b					      db	")",0
      1  224b		       29 00		      .byte.b	")",0
      0  224d					      TASKSTAT
      0  224d					      db	66
      1  224d		       42		      .byte.b	66
      0  224e					      RTN
      0  224e					      db	25
      1  224e		       19		      .byte.b	25
    706  224f				   F2Z
      0  224f					      TST	F2ZA,"PID"
      0  224f					      db	32
      1  224f		       20		      .byte.b	32
      0  2250					      db	(F2ZA-*)-1
      1  2250		       06		      .byte.b	(F2ZA-*)-1
      0  2251					      db	"PID",0
      1  2251		       50 49 44 00	      .byte.b	"PID",0
      0  2255					      TASKPID
      0  2255					      db	77
      1  2255		       4d		      .byte.b	77
      0  2256					      RTN
      0  2256					      db	25
      1  2256		       19		      .byte.b	25
    710  2257							;===========================================================================
    711  2257							; Call a machine function, provide the address to call and optionally
    712  2257							; the value to be passed in reg A
    713  2257				   F2ZA
      0  2257					      TST	F2FUNC,"CALL("	;call machine function
      0  2257					      db	32
      1  2257		       20		      .byte.b	32
      0  2258					      db	(F2FUNC-*)-1
      1  2258		       1f		      .byte.b	(F2FUNC-*)-1
      0  2259					      db	"CALL(",0
      1  2259		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  225f					      CALL	EXPR
      0  225f					      db	28
      1  225f		       1c		      .byte.b	28
      0  2260					      dw	EXPR
      1  2260		       a8 20		      .word.w	EXPR
      0  2262					      TST	F2B2A,COMMA
      0  2262					      db	32
      1  2262		       20		      .byte.b	32
      0  2263					      db	(F2B2A-*)-1
      1  2263		       0b		      .byte.b	(F2B2A-*)-1
      0  2264					      db	COMMA,0
      1  2264		       2c 00		      .byte.b	COMMA,0
      0  2266					      CALL	EXPR
      0  2266					      db	28
      1  2266		       1c		      .byte.b	28
      0  2267					      dw	EXPR
      1  2267		       a8 20		      .word.w	EXPR
      0  2269					      TST	UNKNOWNVEC,")"
      0  2269					      db	32
      1  2269		       20		      .byte.b	32
      0  226a					      db	(UNKNOWNVEC-*)-1
      1  226a		       06		      .byte.b	(UNKNOWNVEC-*)-1
      0  226b					      db	")",0
      1  226b		       29 00		      .byte.b	")",0
      0  226d					      CALLFUNC
      0  226d					      db	53
      1  226d		       35		      .byte.b	53
      0  226e					      RTN
      0  226e					      db	25
      1  226e		       19		      .byte.b	25
    721  226f							; Run the gosub within this function
    722  226f				   F2B2A
      0  226f					      TST	UNKNOWNID,")"
      0  226f					      db	32
      1  226f		       20		      .byte.b	32
      0  2270					      db	(UNKNOWNID-*)-1
      1  2270		       a1		      .byte.b	(UNKNOWNID-*)-1
      0  2271					      db	")",0
      1  2271		       29 00		      .byte.b	")",0
      0  2273					      LIT	0	; No parameter passed so just load zero to A
      0  2273					      db	27
      1  2273		       1b		      .byte.b	27
      0  2274					      dw	0
      1  2274		       00 00		      .word.w	0
      0  2276					      CALLFUNC
      0  2276					      db	53
      1  2276		       35		      .byte.b	53
      0  2277					      RTN
      0  2277					      db	25
      1  2277		       19		      .byte.b	25
    727  2278							;===========================================================================
    728  2278							; Same as gosub but expects a return value
    729  2278							;   GOFN 1000(parm1, ....)  Expects an integer to be returned
    730  2278							;
      0  2278				   F2FUNC     TST	F2C,"GOFN"
      0  2278					      db	32
      1  2278		       20		      .byte.b	32
      0  2279					      db	(F2C-*)-1
      1  2279		       0c		      .byte.b	(F2C-*)-1
      0  227a					      db	"GOFN",0
      1  227a		       47 4f 46 4e*	      .byte.b	"GOFN",0
      0  227f					      Call	GOSUBSTATEMENT
      0  227f					      db	28
      1  227f		       1c		      .byte.b	28
      0  2280					      dw	GOSUBSTATEMENT
      1  2280		       af 22		      .word.w	GOSUBSTATEMENT
      0  2282					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  2282					      db	8
      1  2282		       08		      .byte.b	8
      0  2283					      db	GOSUB_RTN_VALUE
      1  2283		       81		      .byte.b	GOSUB_RTN_VALUE
      0  2284					      XFER
      0  2284					      db	7
      1  2284		       07		      .byte.b	7
    735  2285				   GOFNRet
      0  2285					      RTN
      0  2285					      db	25
      1  2285		       19		      .byte.b	25
    737  2286							;=============================================================================
    738  2286							; See if this is just a simple variable
    739  2286							;  Allow a subscript for any variable
    740  2286							;
    741  2286				   F2C
      0  2286					      TSTV	F0
      0  2286					      db	33
      1  2286		       21		      .byte.b	33
      0  2287					      db	(F0-*)-1
      1  2287		       15		      .byte.b	(F0-*)-1
      0  2288					      TST	F2CLocalTask,"!"
      0  2288					      db	32
      1  2288		       20		      .byte.b	32
      0  2289					      db	(F2CLocalTask-*)-1
      1  2289		       05		      .byte.b	(F2CLocalTask-*)-1
      0  228a					      db	"!",0
      1  228a		       21 00		      .byte.b	"!",0
      0  228c					      IND		; we just got a pid
      0  228c					      db	20
      1  228c		       14		      .byte.b	20
      0  228d					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  228d					      db	93
      1  228d		       5d		      .byte.b	93
      0  228e					      db	(UNKNOWNID-*)-1
      1  228e		       83		      .byte.b	(UNKNOWNID-*)-1
    746  228f
    747  228f				   F2CLocalTask
      0  228f					      TST	F2C1,"["
      0  228f					      db	32
      1  228f		       20		      .byte.b	32
      0  2290					      db	(F2C1-*)-1
      1  2290		       0a		      .byte.b	(F2C1-*)-1
      0  2291					      db	"[",0
      1  2291		       5b 00		      .byte.b	"[",0
      0  2293					      CALL	EXPR
      0  2293					      db	28
      1  2293		       1c		      .byte.b	28
      0  2294					      dw	EXPR
      1  2294		       a8 20		      .word.w	EXPR
      0  2296					      TST	UNKNOWNID,"]"
      0  2296					      db	32
      1  2296		       20		      .byte.b	32
      0  2297					      db	(UNKNOWNID-*)-1
      1  2297		       7a		      .byte.b	(UNKNOWNID-*)-1
      0  2298					      db	"]",0
      1  2298		       5d 00		      .byte.b	"]",0
      0  229a					      SUBSCRIPT
      0  229a					      db	64
      1  229a		       40		      .byte.b	64
    752  229b				   F2C1
      0  229b					      IND		;YES, GET THE VALUE.
      0  229b					      db	20
      1  229b		       14		      .byte.b	20
      0  229c					      RTN
      0  229c					      db	25
      1  229c		       19		      .byte.b	25
    755  229d							;=================================================================================
    756  229d							;Finally check for a number !
    757  229d							;
    758  229d				   F0
      0  229d					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  229d					      db	35
      1  229d		       23		      .byte.b	35
      0  229e					      db	(F1-*)-1
      1  229e		       01		      .byte.b	(F1-*)-1
      0  229f					      RTN
      0  229f					      db	25
      1  229f		       19		      .byte.b	25
    761  22a0				   F1
      0  22a0					      TST	F2RTN,"("	;PARENTHESIZED EXPR.
      0  22a0					      db	32
      1  22a0		       20		      .byte.b	32
      0  22a1					      db	(F2RTN-*)-1
      1  22a1		       09		      .byte.b	(F2RTN-*)-1
      0  22a2					      db	"(",0
      1  22a2		       28 00		      .byte.b	"(",0
      0  22a4					      CALL	EXPR
      0  22a4					      db	28
      1  22a4		       1c		      .byte.b	28
      0  22a5					      dw	EXPR
      1  22a5		       a8 20		      .word.w	EXPR
      0  22a7					      TST	F2,")"
      0  22a7					      db	32
      1  22a7		       20		      .byte.b	32
      0  22a8					      db	(F2-*)-1
      1  22a8		       03		      .byte.b	(F2-*)-1
      0  22a9					      db	")",0
      1  22a9		       29 00		      .byte.b	")",0
    765  22ab				   F2RTN
      0  22ab					      RTN
      0  22ab					      db	25
      1  22ab		       19		      .byte.b	25
    767  22ac
    768  22ac				   F2
      0  22ac					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  22ac					      db	13
      1  22ac		       0d		      .byte.b	13
      0  22ad					      dw	ERR_SYNTAX
      1  22ad		       05 00		      .word.w	ERR_SYNTAX
    770  22af							;
    771  22af							;=============================================================
    772  22af							; Gosub can be both a Function and a Subroutine
    773  22af				   GOSUBSTATEMENT
      0  22af					      CALL	EXPR	;GET DESTINATION
      0  22af					      db	28
      1  22af		       1c		      .byte.b	28
      0  22b0					      dw	EXPR
      1  22b0		       a8 20		      .word.w	EXPR
      0  22b2					      TST	GOSUBDONE,"("	;Check if any Parameters
      0  22b2					      db	32
      1  22b2		       20		      .byte.b	32
      0  22b3					      db	(GOSUBDONE-*)-1
      1  22b3		       14		      .byte.b	(GOSUBDONE-*)-1
      0  22b4					      db	"(",0
      1  22b4		       28 00		      .byte.b	"(",0
      0  22b6					      STK2TMP		;Transfer stack top to temp
      0  22b6					      db	95
      1  22b6		       5f		      .byte.b	95
      0  22b7					      PUSHMATHSTACK		;Record stack frame for return
      0  22b7					      db	84
      1  22b7		       54		      .byte.b	84
    778  22b8				   GOSUBLOOP
      0  22b8					      CALL	EXPR	; Allows what ever fits onto stack
      0  22b8					      db	28
      1  22b8		       1c		      .byte.b	28
      0  22b9					      dw	EXPR
      1  22b9		       a8 20		      .word.w	EXPR
      0  22bb					      INCPARMCOUNT
      0  22bb					      db	88
      1  22bb		       58		      .byte.b	88
      0  22bc					      TST	GOSUBParmDONE,COMMA
      0  22bc					      db	32
      1  22bc		       20		      .byte.b	32
      0  22bd					      db	(GOSUBParmDONE-*)-1
      1  22bd		       05		      .byte.b	(GOSUBParmDONE-*)-1
      0  22be					      db	COMMA,0
      1  22be		       2c 00		      .byte.b	COMMA,0
      0  22c0					      IJMP	GOSUBLOOP
      0  22c0					      db	29
      1  22c0		       1d		      .byte.b	29
      0  22c1					      dw	GOSUBLOOP
      1  22c1		       b8 22		      .word.w	GOSUBLOOP
    783  22c3				   GOSUBParmDONE
      0  22c3					      TST	F2,")"
      0  22c3					      db	32
      1  22c3		       20		      .byte.b	32
      0  22c4					      db	(F2-*)-1
      1  22c4		       e7		      .byte.b	(F2-*)-1
      0  22c5					      db	")",0
      1  22c5		       29 00		      .byte.b	")",0
      0  22c7					      TMP2STK		;Restore line to goto
      0  22c7					      db	96
      1  22c7		       60		      .byte.b	96
    786  22c8				   GOSUBDONE
      0  22c8					      RTN
      0  22c8					      db	25
      1  22c8		       19		      .byte.b	25
    788  22c9
    789  22c9		       22 c9	   ILEND      equ	*
------- FILE mytb.asm
   2225  22c9		       22 c9	   PROGEND    equ	*
   2226  22c9
   2227  22c9
   2228  22c9							;=====================================================
   2229  22c9							; Define start of non page zero data
   2230 U22d9					      seg.u	TBData
   2231 U22d9
   2232 U22d9							;=====================================================
   2233 U22d9							; These are storage items not in page zero.
   2234 U22d9							;
   2235 U22d9							; IRQ BASIC Code Service RTN Support
      0 U22d9				   SaveIrqReg db	0	; Store current setting
      1 U22d9		       00		      .byte.b	0
      0 U22da				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U22da		       00		      .byte.b	0
      0 U22db				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U22db		       00		      .byte.b	0
      0 U22dc				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U22dc		       00 00		      .byte.b	0,0
   2240 U22de
   2241 U22de							;
   2242 U22de							;==================================================================================================
   2243 U22de							; Task Management information
   2244 U22de							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2245 U22de							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2246 U22de							; Task switchs happen at the beginning of the next Basic command line
   2247 U22de							; It will not happen during an input or output operations
   2248 U22de							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2249 U22de							; Task Zero is always the root task, main line program
   2250 U22de							;
   2251 U22de							; Layout is repeated for each configured task
   2252 U22de							; Task Table Byte   use masks follow
   2253 U22de		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2254 U22de		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2255 U22de		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2256 U22de		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2257 U22de		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2258 U22de
   2259 U22de		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2260 U22df		       00 00 00 00*taskTable  ds	TASKCOUNT*(CONTEXTLEN+1)	; Task Table Offset and pointer to Basic code, active flag
   2261 U22df		       23 d9	   TASKTABLEEND equ	*	; End of task table
   2262 U22df		       00 fa	   TASKTABLELEN equ	TASKTABLEEND-taskTable	; actual length of the task table
   2263 U23d9
   2264 U23d9							;Task Cycle Counter and reset count
   2265 U23d9		       00 00	   taskCurrentCycles ds	2
   2266 U23db		       00 00	   taskResetValue ds	2
   2267 U23dd		       00	   taskCounter ds	1	; Count of active tasks
   2268 U23de
   2269 U23de							;
   2270 U23de							; Math stack and IL call and Gosub/For-next return stack definitions
   2271 U23de							;
   2272 U23de		       23 de	   STACKSTART equ	*
   2273 U23de		       00 00 00 00*mathStack  ds	MATHSTACKSIZE*2*TASKCOUNT	;Stack used for math expressions
   2274 U256e		       00 00 00 00*ilStack    ds	ILSTACKSIZE*2*TASKCOUNT	;stack used by the IL for calls and returns
   2275 U26fe		       00 00 00 00*gosubStack ds	(GOSUBSTACKSIZE)*4*TASKCOUNT	;stack size for gosub stacks
   2276 U297e		       00 00 00 00*variableStack ds	VARIABLESSIZE*2*TASKCOUNT	;Stack of variables, 26 A-Z-task exit code
   2277 U297e		       00 19	   TASKEXITCODE equ	VARIABLESSIZE-1*2	; Offset to exit code location
   2278 U297e		       2b 9a	   STACKEND   equ	*
   2279 U297e		       07 bc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2280 U2b9a							;
   2281 U2b9a							;
   2282 U2b9a		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2283 U2c1e		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2284 U2c1f		       00	   printtx    ds	1	;temp X for print funcs
   2285 U2c20		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2286 U2c21		       00	   promptChar ds	1	;the character to use for a prompt
   2287 U2c22		       00	   diddigit   ds	1	;for leading zero suppression
   2288 U2c23		       00	   putsy      ds	1
   2289 U2c24		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2290 U2c26		       00	   sign       ds	1	;0 = positive, else negative
   2291 U2c27		       00 00	   rtemp1     ds	2	;Temp for x and y
   2292 U2c29		       00 00	   random     ds	2
   2293 U2c2b		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
   2294 U2c2d		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
   2295 U2c2f		       00	   tempy      ds	1	;temp y storage
   2296 U2c30
   2297 U2c30							; Moved from page zero as one clock cycle diff gives more space on page zero
   2298 U2c30		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2299 U2c32		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2300 U2c33		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2301 U2c34		       00	   lineLength ds	1	;Length of current line
   2302 U2c35
   2303 U2c35		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2304 U2c36		       00	   taskRDPending ds	1	; 1 = background read is pending
   2305 U2c37
   2306 U2c37				  -	      if	XKIM
   2307 U2c37				  -buffer     ds	BUFFER_SIZE
   2308 U2c37					      endif
   2309 U2c37							;
   2310 U2c37							; PROGRAMEND is the end of the user's BASIC program.
   2311 U2c37							; More precisely, it is one byte past the end.  Or,
   2312 U2c37							; it's where the next line added to the end will be
   2313 U2c37							; placed.
   2314 U2c37							;
   2315 U2c37		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2316 U2c39		       00 00	   ProgramEnd ds	2	; End of users basic program
   2317 U2c3b		       00 00	   HighMem    ds	2	; highest location
   2318 U2c3d		       00 00	   UsedMem    ds	2	; size of user program
   2319 U2c3f		       00 00	   FreeMem    ds	2	; amount of free memory
   2320 U2c41							;
   2321 U2c41							;=====================================================
   2322 U2c41							; This is the start of the user's BASIC program space.
   2323 U2c41							;
   2324 U2c41							; PERSONAL GOAL: This should be no larger than $0DFF.
   2325 U2c41							;		  0200-05FF = 1K
   2326 U2c41							;		  0200-09FF = 2K
   2327 U2c41							;		  0200-0DFF = 3K
   2328 U2c41							;		  0200-11FF = 4K
   2329 U2c41							;		  0200-13FF = 4.5K
   2330 U2c41							;
   2331 U2c41				  -	      if	FIXED
   2332 U2c41				  -	      org	$2000
   2333 U2c41					      endif
   2334 U2c41
   2335 U2c41		       2c 41	   FreeMemStart equ	*
   2336 U2c41							;/*
   2337 U2c41							;	if	CTMON65 || XKIM
   2338 U2c41							;		SEG Code
   2339 U2c41							;		org	AutoRun
   2340 U2c41							;		dw	TBasicCold
   2341 U2c41							;	endif
   2342 U2c41							;*/
   2343 U2c41					      end
