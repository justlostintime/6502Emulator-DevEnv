------- FILE mytb.asm LEVEL 1 PASS 4
      1 U1335				   input      processor	6502
      2 U1335 ????						;=====================================================
      3 U1335 ????						; Bob's Tiny BASIC
      4 U1335 ????						;
      5 U1335 ????						; While working on the Corsham Technologies KIM Clone
      6 U1335 ????						; project, I wanted to include a TINY BASIC since that
      7 U1335 ????						; was a highly desirable feature of early computers.
      8 U1335 ????						;
      9 U1335 ????						; Rather than negotiating copyright issues for
     10 U1335 ????						; existing BASICs, I decided to just write one from
     11 U1335 ????						; scratch.
     12 U1335 ????						;
     13 U1335 ????						; 10/07/2017
     14 U1335 ????						;
     15 U1335 ????						; This implements a stripped down Tiny BASIC
     16 U1335 ????						; interpreter using the Interpretive Language (IL)
     17 U1335 ????						; method as described in the first few issues of
     18 U1335 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U1335 ????						; to write various languages simply by changing the
     20 U1335 ????						; IL code rather than the interpreter itself.
     21 U1335 ????						;
     22 U1335 ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U1335 ????						;		* Fixed major bug in findLine that
     24 U1335 ????						;		  caused corrupted lines, crashes, etc.
     25 U1335 ????						;		* If no parameter given to RND, assume
     26 U1335 ????						;		  32766.
     27 U1335 ????						;		* No more error 5 when a program
     28 U1335 ????						;		  reaches the end without an END.
     29 U1335 ????						;
     30 U1335 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     31 U1335 ????						;		 * Add some usefull system level functions
     32 U1335 ????						;		 * allow a larger number of tiny basic formats
     33 U1335 ????						;		 * Add byte at start of line holding length
     34 U1335 ????						;		   for faster execution of goto and gosub
     35 U1335 ????						;		 * Re-added gosub
     36 U1335 ????						;		 * allow ; or , at end if print stmt
     37 U1335 ????						;		   without CRLF being added.
     38 U1335 ????						;		 * Added extended function erase to
     39 U1335 ????						;		   use the extended ctmon65 rm file
     40 U1335 ????						;		 * Fix quoted text to not have to backtrack
     41 U1335 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     42 U1335 ????						;
     43 U1335 ????						; www.corshamtech.com
     44 U1335 ????						; bob@corshamtech.com
     45 U1335 ????						; JustLostInTime@gmail.com
     46 U1335 ????						;
     47 U1335 ????						;=====================================================
     48 U1335 ????						;
     49 U1335 ????						; Create TRUE and FALSE values for conditionals.
     50 U1335 ????						;
     51 U1335 ????
     52 U1335 ????	       00 00	   FALSE      equ	0
     53 U1335 ????	       ff ff ff ff TRUE       equ	~FALSE
     54 U1335 ????						;
     55 U1335 ????						;---------------------------------------------------------
     56 U1335 ????						; One of these must be set to indicate which environment
     57 U1335 ????						; Tiny BASIC will be running in.  Here are the current
     58 U1335 ????						; environments:
     59 U1335 ????						;
     60 U1335 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     61 U1335 ????						; more K of RAM.
     62 U1335 ????						;
     63 U1335 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     64 U1335 ????						; which enhances, without replacing, the standard KIM
     65 U1335 ????						; monitor.  It gives access to routines to save/load files
     66 U1335 ????						; to a micro SD card.
     67 U1335 ????						;
     68 U1335 ????						; CTMON65 is a from-scratch monitor written for the
     69 U1335 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     70 U1335 ????						; easily be ported to other systems.  It has support for
     71 U1335 ????						; using a micro SD card for file storage/retrieval.
     72 U1335 ????						;
     73 U1335 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     74 U1335 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     75 U1335 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     76 U1335 ????						;
     77 U1335 ????						;   Need to define some macros for the dasm assembler
     78 U1335 ????						;
     79 U1335 ????				      MACRO	dw
     80 U1335 ????				      .word	{0}
     81 U1335 ????				      ENDM
     82 U1335 ????
     83 U1335 ????				      MACRO	db
     84 U1335 ????				      .byte	{0}
     85 U1335 ????				      ENDM
     86 U1335 ????
     87 U1335 ????						;
     88 U1335 ????						; If set, include disk functions.
     89 U1335 ????						;
     90 U1335 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     91 U1335 ????						;
     92 U1335 ????						; If ILTRACE is set then dump out the address of every
     93 U1335 ????						; IL opcode before executing it.
     94 U1335 ????						;
     95 U1335 ????	       00 00	   ILTRACE    equ	FALSE
     96 U1335 ????						;
     97 U1335 ????						; If FIXED is set, put the IL code and the user
     98 U1335 ????						; program space at fixed locations in memory.	This is
     99 U1335 ????						; meant only for debugging.
    100 U1335 ????						;
    101 U1335 ????	       00 00	   FIXED      equ	FALSE
    102 U1335 ????						;
    103 U1335 ????						; Sets the arithmetic stack depth.  This is *TINY*
    104 U1335 ????						; BASIC, so keep this small!
    105 U1335 ????						;
    106 U1335 ????	       00 14	   STACKSIZE  equ	20	;number of entries
    107 U1335 ????	       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting max is 85
    108 U1335 ????						;
    109 U1335 ????						; Common ASCII constants
    110 U1335 ????						;
    111 U1335 ????	       00 07	   BEL	      equ	$07
    112 U1335 ????	       00 08	   BS	      equ	$08
    113 U1335 ????	       00 09	   TAB	      equ	$09
    114 U1335 ????	       00 0a	   LF	      equ	$0A
    115 U1335 ????	       00 0d	   CR	      equ	$0D
    116 U1335 ????	       00 22	   QUOTE      equ	$22
    117 U1335 ????	       00 20	   SPACE      equ	$20
    118 U1335 ????	       00 2c	   COMMA      equ	',
    119 U1335 ????	       00 3b	   SEMICOLON  equ	';
    120 U1335 ????	       00 3a	   COLON      equ	58
    121 U1335 ????	       00 24	   DOLLAR     equ	$24
    122 U1335 ????						;
    123 U1335 ????						; These are error codes
    124 U1335 ????						;
    125 U1335 ????	       00 00	   ERR_NONE   equ	0
    126 U1335 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    127 U1335 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    128 U1335 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    129 U1335 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    130 U1335 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    131 U1335 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    132 U1335 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    133 U1335 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    134 U1335 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    135 U1335 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    136 U1335 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    137 U1335 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    138 U1335 ????						;
    139 U1335 ????						;=====================================================
    140 U1335 ????						; Zero page storage.
    141 U1335 ????						;
    142 U1335 ????				      SEG.U	Data
    143 U0040					      org	$0040
    144 U0040
    145 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    146 U0041		       00 00 00 00*variables  ds	26*2	;2 bytes, A-Z
    147 U0041		       00 75	   variablesEnd equ	*
    148 U0075		       00 00	   ILPC       ds	2	;IL program counter
    149 U0077		       00 00	   dpl	      ds	2
    150 U0079		       00 00	   tempIL     ds	2
    151 U007b		       00	   tempIlY    ds	1
    152 U007c		       00	   offset     ds	1
    153 U007d		       00	   lineLength ds	1
    154 U007e							;
    155 U007e							; CURPTR is a pointer to curent BASIC line being
    156 U007e							; executed.  Always points to start of line, CUROFF
    157 U007e							; is the offset to the current character.
    158 U007e							;
    159 U007e		       00 00	   CURPTR     ds	2
    160 U0080		       00	   CUROFF     ds	1
    161 U0081							;
    162 U0081		       00 00	   GOSUBSTACK ds	2	;pointer to gosub stack
    163 U0083							;
    164 U0083
    165 U0083							;
    166 U0083							; R0 and R1 are used for arithmetic operations and
    167 U0083							; general use.
    168 U0083							;
    169 U0083		       00 00	   R0	      ds	2	;arithmetic register 0
    170 U0085		       00 00	   R1	      ds	2	;arithmetic register 1
    171 U0087							;
    172 U0087							; This is zero if in immediate mode, or non-zero
    173 U0087							; if currently running a program.  Any input from
    174 U0087							; the main loop clears this, and the XFER IL
    175 U0087							; statement will set it.
    176 U0087							;
    177 U0087		       00	   RunMode    ds	1
    178 U0088							;
    179 U0088							; Used for line insertion/removal.
    180 U0088							;
    181 U0088		       00 00	   FROM       ds	2
    182 U008a
    183 U008a							; THE ADDRESS USED BY THE PRINTER FUNCTION
    184 U008a							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    185 U008a							;
    186 U008a		       00 88	   PrtFrom    EQU	FROM
    187 U008a							;
    188 U008a							;=====================================================
    189 U008a							;
    190  1247 ????				      SEG	Code
    191  0200					      org	$0200
    192  0200							;
    193  0200							; Cold start is at $0200.  Warm start is at $0203.
    194  0200							;
    195  0200		       4c 15 02    TBasicCold jmp	cold2	;jump around vectors
    196  0203		       4c bf 02    warm       jmp	warm2
    197  0206							;
    198  0206							; These are the user-supplied vectors to I/O routines.
    199  0206							; If you want, you can just patch these in the binary
    200  0206							; file, but it would be better to change the source
    201  0206							; code.
    202  0206							;
    203  0206				  -	      if	KIM
    204  0206				  -OUTCH      jmp	$1ea0	;output char in A
    205  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    206  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    207  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    208  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    209  0206					      endif
    210  0206				  -	      if	XKIM
    211  0206				  -	      include	"xkim.inc"
    212  0206				  -	      SEG	Code
    213  0206				  -OUTCH      jmp	$1ea0
    214  0206				  -GETCH      jmp	xkGETCH
    215  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    216  0206				  -OUTHEX     jmp	xkPRTBYT
    217  0206				  -MONITOR    jmp	extKIM
    218  0206				  -puts       equ	putsil
    219  0206				  -BUFFER_SIZE equ	132
    220  0206					      endif
    221  0206
    222  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 4
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 4
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U00f6 ????				      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 U008a					      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    224  0206					      SEG	Code
    225  0206
    226  0206		       4c 0c f0    OUTCH      jmp	cout
    227  0209		       4c 09 f0    GETCH      jmp	cin
    228  020c		       4c 18 f0    CRLF       jmp	crlf
    229  020f		       4c 1b f0    OUTHEX     jmp	HexA
    230  0212		       4c 03 f0    MONITOR    jmp	WARM
    231  0212		       f0 12	   puts       equ	putsil
    232  0215					      endif
    233  0215							;
    234  0215		       20 12 f0    cold2      jsr	puts
      0  0218					      db	CR,LF
      1  0218		       0d 0a		      .byte.b	CR,LF
      0  021a					      db	"Bob's Tiny BASIC v1.0.2 IRQs"
      1  021a		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0.2 IRQs"
      0  0236					      db	CR,LF
      1  0236		       0d 0a		      .byte.b	CR,LF
      0  0238					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  0238		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  0266					      db	CR,LF,0
      1  0266		       0d 0a 00 	      .byte.b	CR,LF,0
    240  0269							;
    241  0269		       20 cb 0d 	      jsr	GetSizes	;setup the free space available
    242  026c		       ad 2f 13 	      lda	HighMem
    243  026f		       e9 3c		      sbc	#GOSUBSTACKSIZE*3
    244  0271		       85 81		      sta	GOSUBSTACK
    245  0273		       ad 30 13 	      lda	HighMem+1
    246  0276		       e9 00		      sbc	#0
    247  0278		       85 82		      sta	GOSUBSTACK+1
    248  027a		       a9 69		      lda	#IL&$ff
    249  027c		       85 75		      sta	ILPC
    250  027e		       a9 0f		      lda	#IL>>8
    251  0280		       85 76		      sta	ILPC+1
    252  0282							;
    253  0282		       a9 35		      lda	#ProgramStart&$ff	;user prog
    254  0284		       8d 2d 13 	      sta	PROGRAMEND
    255  0287		       a9 13		      lda	#ProgramStart>>8
    256  0289		       8d 2e 13 	      sta	PROGRAMEND+1
    257  028c							;
    258  028c							; Initialize the pseudo-random number sequence...
    259  028c							;
    260  028c		       a9 5a		      lda	#$5a
    261  028e		       8d 27 13 	      sta	rtemp1
    262  0291		       a9 9d		      lda	#%10011101
    263  0293		       8d 28 13 	      sta	random
    264  0296		       a9 5b		      lda	#%01011011
    265  0298		       8d 29 13 	      sta	random+1
    266  029b							;
    267  029b							;   Insert a Basic irq handler for the basic Language
    268  029b		       a9 ad		      lda	#ServiceIrq&$ff
    269  029d		       8d 00 df 	      sta	IRQvec
    270  02a0		       a9 02		      lda	#ServiceIrq>>8
    271  02a2		       8d 01 df 	      sta	IRQvec+1
    272  02a5		       4c cc 02 	      jmp	coldtwo
    273  02a8
    274  02a8							;
    275  02a8							; This is the Basic IRQ handler
      0  02a8				   SaveIrqReg db	0
      1  02a8		       00		      .byte.b	0
      0  02a9				   IRQStatus  db	0
      1  02a9		       00		      .byte.b	0
      0  02aa				   IRQPending db	0
      1  02aa		       00		      .byte.b	0
      0  02ab				   IRQEntry   db	0,0
      1  02ab		       00 00		      .byte.b	0,0
    280  02ad
    281  02ad		       48	   ServiceIrq pha
    282  02ae		       ad a9 02 	      lda	IRQStatus
    283  02b1		       f0 0a		      BEQ	RetIrq
    284  02b3		       ad aa 02 	      lda	IRQPending
    285  02b6		       d0 05		      BNE	RetIrq
    286  02b8		       a9 01		      lda	#1
    287  02ba		       8d aa 02 	      sta	IRQPending
    288  02bd		       68	   RetIrq     pla
    289  02be		       40		      rti
    290  02bf							;
    291  02bf							;
    292  02bf							; This is the warm start entry point
    293  02bf							;
    294  02bf		       20 0c 02    warm2      jsr	CRLF
    295  02c2		       ad 22 13 	      lda	errGoto
    296  02c5		       85 75		      sta	ILPC
    297  02c7		       ad 23 13 	      lda	errGoto+1
    298  02ca		       85 76		      sta	ILPC+1
    299  02cc							;
    300  02cc							; And continue with both starts here
    301  02cc							;
    302  02cc		       20 fe 0d    coldtwo    jsr	SetOutConsole
    303  02cf							;
    304  02cf							; The ILTrace flag is now run-time settable.
    305  02cf							;
    306  02cf		       a9 00		      lda	#ILTRACE&$ff
    307  02d1		       85 40		      sta	ILTrace
    308  02d3							;
    309  02d3		       a9 00		      lda	#0
    310  02d5		       85 87		      sta	RunMode
    311  02d7		       8d 9a 12 	      sta	LINBUF
    312  02da							; Clear everything from the stacks
    313  02da		       8d 6f 12 	      sta	mathStackPtr
    314  02dd		       8d 98 12 	      sta	retStackPtr
    315  02e0		       8d 99 12 	      sta	GoSubStackPtr
    316  02e3							;
    317  02e3		       a9 9a		      lda	#LINBUF&$ff
    318  02e5		       85 7e		      sta	CURPTR
    319  02e7		       a9 12		      lda	#LINBUF>>8
    320  02e9		       85 7f		      sta	CURPTR+1	;fall through...
    321  02eb							;
    322  02eb							;=====================================================
    323  02eb							; This is the top of the IL interpreter.  This fetches
    324  02eb							; and executes the instruction currently pointed to
    325  02eb							; by ILPC and adjusts ILPC to point to the next
    326  02eb							; instruction to execute.
    327  02eb							;
    328  02eb		       a5 40	   NextIL     lda	ILTrace
    329  02ed		       f0 03		      beq	NextIL2
    330  02ef		       20 86 0d 	      jsr	dbgLine
    331  02f2		       a4 80	   NextIL2    ldy	CUROFF
    332  02f4		       20 7d 0d 	      jsr	SkipSpaces
    333  02f7		       84 80		      sty	CUROFF
    334  02f9							;
    335  02f9		       20 61 0a    NextILStr  jsr	getILByte
    336  02fc							;
    337  02fc							; When the handler is called, these are the conditions
    338  02fc							; of several important items:
    339  02fc							;
    340  02fc							;    (ILPC) will point to the byte AFTER the IL
    341  02fc							;    opcode being executed.
    342  02fc							;
    343  02fc							;    (CURPTR),CUROFF will point to the start of the
    344  02fc							;    next word in the input buffer.  Ie, the next word
    345  02fc							;    in the user program.
    346  02fc							;
    347  02fc		       0a		      asl
    348  02fd		       c9 7c		      cmp	#ILTBLend-ILTBL+2
    349  02ff		       90 33		      bcc	ILgood
    350  0301							;
    351  0301							; This handles an illegal IL opcode.  This is serious
    352  0301							; and there's no way to recover.
    353  0301							;
    354  0301		       20 12 f0    ILbad      jsr	puts
      0  0304					      db	CR,LF
      1  0304		       0d 0a		      .byte.b	CR,LF
      0  0306					      db	"Illegal IL "
      1  0306		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  0311					      db	0
      1  0311		       00		      .byte.b	0
    358  0312							;
    359  0312							; Well this is awkward, we need to back up the IL
    360  0312							; by one since it no longer points to the current
    361  0312							; opcode.
    362  0312							;
    363  0312		       20 6e 0a 	      jsr	decIL
    364  0315							;
    365  0315		       a0 00		      ldy	#0
    366  0317		       b1 75		      lda	(ILPC),y
    367  0319		       20 0f 02 	      jsr	OUTHEX
    368  031c		       20 12 f0 	      jsr	puts
      0  031f					      db	" at ",0
      1  031f		       20 61 74 20*	      .byte.b	" at ",0
    370  0324		       a5 76		      lda	ILPC+1
    371  0326		       20 0f 02 	      jsr	OUTHEX
    372  0329		       a5 75		      lda	ILPC
    373  032b		       20 0f 02 	      jsr	OUTHEX
    374  032e		       20 0c 02 	      jsr	CRLF
    375  0331		       4c 12 02 	      jmp	MONITOR
    376  0334							;
    377  0334							; Just jump to the address (ILPC),y.  Have to do
    378  0334							; some goofy stuff.
    379  0334							;
    380  0334		       a8	   ILgood     tay		;move index into Y
    381  0335		       b9 42 03 	      lda	ILTBL,y
    382  0338		       85 77		      sta	dpl
    383  033a		       b9 43 03 	      lda	ILTBL+1,y
    384  033d		       85 78		      sta	dpl+1
    385  033f		       6c 77 00 	      jmp	(dpl)	;go to handler
    386  0342							;
    387  0342							;=====================================================
    388  0342							; This is the IL jump table.  The IL opcode is
    389  0342							; mulitplied by two, then looked-up in this table.
    390  0342							; There is absolutely nothing special about the order
    391  0342							; of entries here... they all decode at exactly the
    392  0342							; same speed.	However the entry number must match the
    393  0342							; values in IL.inc.
    394  0342							;
      0  0342				   ILTBL      dw	iXINIT	;0
      1  0342		       d2 03		      .word.w	iXINIT
      0  0344					      dw	iDONE	;1
      1  0344		       da 03		      .word.w	iDONE
      0  0346					      dw	iPRS	;2
      1  0346		       f6 03		      .word.w	iPRS
      0  0348					      dw	iPRN	;3
      1  0348		       00 04		      .word.w	iPRN
      0  034a					      dw	iSPC	;4
      1  034a		       09 04		      .word.w	iSPC
      0  034c					      dw	iNLINE	;5
      1  034c		       9e 07		      .word.w	iNLINE
      0  034e					      dw	iNXT	;6
      1  034e		       11 04		      .word.w	iNXT
      0  0350					      dw	iXFER	;7
      1  0350		       37 04		      .word.w	iXFER
      0  0352					      dw	iSAV	;8
      1  0352		       64 04		      .word.w	iSAV
      0  0354					      dw	iRSTR	;9
      1  0354		       85 04		      .word.w	iRSTR
      0  0356					      dw	iCMPR	;10
      1  0356		       91 04		      .word.w	iCMPR
      0  0358					      dw	iINNUM	;11
      1  0358		       f0 04		      .word.w	iINNUM
      0  035a					      dw	iFIN	;12
      1  035a		       1a 05		      .word.w	iFIN
      0  035c					      dw	iERR	;13
      1  035c		       2b 05		      .word.w	iERR
      0  035e					      dw	iADD	;14
      1  035e		       77 05		      .word.w	iADD
      0  0360					      dw	iSUB	;15
      1  0360		       8d 05		      .word.w	iSUB
      0  0362					      dw	iNEG	;16
      1  0362		       a3 05		      .word.w	iNEG
      0  0364					      dw	iMUL	;17
      1  0364		       bb 05		      .word.w	iMUL
      0  0366					      dw	iDIV	;18
      1  0366		       f5 05		      .word.w	iDIV
      0  0368					      dw	iSTORE	;19
      1  0368		       55 06		      .word.w	iSTORE
      0  036a					      dw	iIND	;20
      1  036a		       68 06		      .word.w	iIND
      0  036c					      dw	iLST	;21
      1  036c		       78 06		      .word.w	iLST
      0  036e					      dw	iINIT	;22
      1  036e		       bc 03		      .word.w	iINIT
      0  0370					      dw	iGETLINE	;23
      1  0370		       d7 06		      .word.w	iGETLINE
      0  0372					      dw	iINSRT	;24
      1  0372		       e3 06		      .word.w	iINSRT
      0  0374					      dw	iRTN	;25
      1  0374		       98 07		      .word.w	iRTN
      0  0376					      dw	MONITOR	;26
      1  0376		       12 02		      .word.w	MONITOR
      0  0378					      dw	iLIT	;27
      1  0378		       b1 07		      .word.w	iLIT
      0  037a					      dw	iCALL	;28
      1  037a		       a4 07		      .word.w	iCALL
      0  037c					      dw	iJMP	;29
      1  037c		       a7 07		      .word.w	iJMP
      0  037e					      dw	iVINIT	;30
      1  037e		       be 07		      .word.w	iVINIT
      0  0380					      dw	iERRGOTO	;31
      1  0380		       cc 07		      .word.w	iERRGOTO
      0  0382					      dw	iTST	;32
      1  0382		       d8 07		      .word.w	iTST
      0  0384					      dw	iTSTV	;33
      1  0384		       5b 08		      .word.w	iTSTV
      0  0386					      dw	iTSTL	;34
      1  0386		       85 08		      .word.w	iTSTL
      0  0388					      dw	iTSTN	;35
      1  0388		       9f 08		      .word.w	iTSTN
      0  038a					      dw	iFREE	;36
      1  038a		       11 09		      .word.w	iFREE
      0  038c					      dw	iRANDOM	;37
      1  038c		       1a 09		      .word.w	iRANDOM
      0  038e					      dw	iABS	;38
      1  038e		       0b 0a		      .word.w	iABS
    434  0390							;
    435  0390							; Disk functions.  There must be pointers
    436  0390							; to functions even if no disk is supported.
    437  0390							; Makes things easier in IL.inc.
    438  0390							;
    439  0390					      if	DISK_ACCESS
      0  0390					      dw	iOPENREAD	;39
      1  0390		       44 0e		      .word.w	iOPENREAD
      0  0392					      dw	iOPENWRITE	;40
      1  0392		       98 0e		      .word.w	iOPENWRITE
      0  0394					      dw	iDCLOSE	;41
      1  0394		       1c 0f		      .word.w	iDCLOSE
      0  0396					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0396		       b7 0e		      .word.w	iDGETLINE
      0  0398					      dw	iDLIST	;43 Did you remeber your towel?
      1  0398		       16 0f		      .word.w	iDLIST
      0  039a					      dw	iDDIR	;44
      1  039a		       f1 0e		      .word.w	iDDIR
      0  039c					      dw	iRMFILE	;45
      1  039c		       72 0e		      .word.w	iRMFILE
    447  039e				  -	      else
    448  039e				  -	      dw	NextIL	;39
    449  039e				  -	      dw	NextIL	;40
    450  039e				  -	      dw	NextIL	;41
    451  039e				  -	      dw	NextIL	;42
    452  039e				  -	      dw	NextIL	;43
    453  039e				  -	      dw	NextIL	;44
    454  039e				  -	      dw	NextIL	;45
    455  039e					      endif
    456  039e							;
      0  039e					      dw	iCLEARSCREEN	;46
      1  039e		       39 0e		      .word.w	iCLEARSCREEN
      0  03a0					      dw	iPOKEMEMORY	;47
      1  03a0		       92 09		      .word.w	iPOKEMEMORY
      0  03a2					      dw	iPEEKMEMORY	;48
      1  03a2		       a7 09		      .word.w	iPEEKMEMORY
      0  03a4					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  03a4		       1d 08		      .word.w	iTSTLET
      0  03a6					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  03a6		       3a 08		      .word.w	iTSTDONE
      0  03a8					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  03a8		       da 09		      .word.w	iGETCHAR
      0  03aa					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  03aa		       00 0a		      .word.w	iPUTCHAR
      0  03ac					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  03ac		       c0 09		      .word.w	iCallFunc
      0  03ae					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  03ae		       de 04		      .word.w	iBranch
      0  03b0					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  03b0		       01 08		      .word.w	iTSTStr
      0  03b2					      dw	iSetIrq	;56	   sets the irq handler
      1  03b2		       28 0a		      .word.w	iSetIrq
      0  03b4					      dw	iTstIrq	;57	   test if irq is pending
      1  03b4		       e2 08		      .word.w	iTstIrq
      0  03b6					      dw	iRET	;58	   return from interupt
      1  03b6		       73 04		      .word.w	iRET
      0  03b8					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03b8		       01 05		      .word.w	iINSTR
      0  03ba					      dw	iMOD	;60	   returns remainder of division
      1  03ba		       fe 05		      .word.w	iMOD
    472  03bc
    473  03bc		       03 bc	   ILTBLend   equ	*
    474  03bc							;
    475  03bc							;=====================================================
    476  03bc							;=====================================================
    477  03bc							;=====================================================
    478  03bc							; This marks the start of the handlers for IL opcodes.
    479  03bc							;=====================================================
    480  03bc							;=====================================================
    481  03bc							;=====================================================
    482  03bc							;
    483  03bc							;
    484  03bc		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    485  03be		       8d 98 12 	      sta	retStackPtr
    486  03c1		       8d 99 12 	      sta	GoSubStackPtr
    487  03c4							;
    488  03c4		       a9 35		      lda	#ProgramStart&$ff	;user prog
    489  03c6		       85 7e		      sta	CURPTR
    490  03c8		       8d 2d 13 	      sta	PROGRAMEND
    491  03cb		       a9 13		      lda	#ProgramStart>>8
    492  03cd		       85 7f		      sta	CURPTR+1
    493  03cf		       8d 2e 13 	      sta	PROGRAMEND+1
    494  03d2							;
    495  03d2							; fall into XINIT...
    496  03d2							;
    497  03d2							;=====================================================
    498  03d2							; This initializes for the start of the next line of
    499  03d2							; BASIC text.
    500  03d2							;
    501  03d2		       a9 00	   iXINIT     lda	#0
    502  03d4		       8d 6f 12 	      sta	mathStackPtr	;clear math stack
    503  03d7		       4c eb 02    goodExit   jmp	NextIL
    504  03da							;
    505  03da							;=====================================================
    506  03da							; Verify there is nothing else on this input line.
    507  03da							; If there is, generate an error.
    508  03da							;
    509  03da		       a4 80	   iDONE      ldy	CUROFF
    510  03dc		       20 7d 0d 	      jsr	SkipSpaces
    511  03df		       b1 7e		      lda	(CURPTR),y
    512  03e1		       f0 10		      beq	doneadv
    513  03e3		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    514  03e5		       d0 05		      bne	idoneErr
    515  03e7		       84 80		      sty	CUROFF
    516  03e9		       4c eb 02 	      jmp	NextIL	; continue on this line
    517  03ec
    518  03ec				   idoneErr
    519  03ec		       a2 04		      ldx	#ERR_EXTRA_STUFF
    520  03ee		       a9 00		      lda	#0
    521  03f0		       4c 2e 05 	      jmp	iErr2
    522  03f3							;
    523  03f3							; Advance to the next line
    524  03f3							;
    525  03f3				   doneadv
    526  03f3							;		jsr	FindNext2
    527  03f3		       4c eb 02 	      jmp	NextIL
    528  03f6							;
    529  03f6							;=====================================================
    530  03f6							; Print the string until a closing quote
    531  03f6							;
    532  03f6		       a4 80	   iPRS       ldy	CUROFF
    533  03f8							;
    534  03f8							; Odd logic here.  The main loop skipped any leading
    535  03f8							; whitespace inside the quoted text, so move back to
    536  03f8							; the quote, then move forward again.
    537  03f8							;
    538  03f8		       20 0c 0e 	      jsr	PrtQuoted
    539  03fb		       84 80		      sty	CUROFF
    540  03fd		       4c eb 02 	      jmp	NextIL
    541  0400							;
    542  0400							;=====================================================
    543  0400							; Pop the top off the stack and print it as a signed
    544  0400							; decimal number.
    545  0400							;
    546  0400		       20 b4 0c    iPRN       jsr	popR0
    547  0403		       20 06 0b 	      jsr	PrintDecimal
    548  0406		       4c eb 02 	      jmp	NextIL
    549  0409							;
    550  0409							;=====================================================
    551  0409							; Space to next zone.	Currently the code does not
    552  0409							; keep track of which column the output is on, so
    553  0409							; just print a tab.
    554  0409							;
    555  0409		       a9 09	   iSPC       lda	#TAB
    556  040b		       20 06 02 	      jsr	OUTCH
    557  040e		       4c eb 02 	      jmp	NextIL
    558  0411							;
    559  0411							;=====================================================
    560  0411							; If in immediate mode, jump to the address following
    561  0411							; the NXT instruction.  Else move to the next line of
    562  0411							; user code and continue.
    563  0411							;
    564  0411		       a5 87	   iNXT       lda	RunMode
    565  0413		       d0 03		      bne	iNxtRun	;in run mode
    566  0415							;
    567  0415							; Get address and jump to it.
    568  0415							;
    569  0415		       4c a7 07 	      jmp	iJMP
    570  0418							;
    571  0418				   iNxtRun
    572  0418		       a4 80		      ldy	CUROFF
    573  041a		       b1 7e		      lda	(CURPTR),y
    574  041c		       c9 3a		      cmp	#COLON
    575  041e		       d0 06		      bne	iNxtRunGo
    576  0420		       c8		      iny
    577  0421		       84 80		      sty	CUROFF
    578  0423		       4c 31 04 	      jmp	iNxtRun2
    579  0426
    580  0426				   iNxtRunGo
    581  0426		       20 e7 0a 	      jsr	FindNextLine
    582  0429		       20 f9 0a 	      jsr	AtEnd
    583  042c		       d0 03		      bne	iNxtRun2	;not at end
    584  042e							;
    585  042e							; At the end of the program.  Pretend an END statement
    586  042e							; was found.
    587  042e							;
    588  042e		       4c 1a 05    iFINv      jmp	iFIN
    589  0431							;
    590  0431		       20 5d 0a    iNxtRun2   jsr	getILWord	;ignore next word
    591  0434		       4c eb 02 	      jmp	NextIL
    592  0437							;
    593  0437							;=====================================================
    594  0437							; XFER takes the number on top of the stack and looks
    595  0437							; for that line in the program, or the next line
    596  0437							; higher.  Ie, if it's 1 but there is no line 1, then
    597  0437							; find the next one after that.
    598  0437							;
    599  0437		       20 b4 0c    iXFER      jsr	popR0
    600  043a		       20 a4 0a 	      jsr	findLine
    601  043d		       20 f9 0a    iXFER2     jsr	AtEnd	;at end of user program?
    602  0440		       f0 ec		      beq	iFINv
    603  0442		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    604  0444		       84 80		      sty	CUROFF
    605  0446		       a9 ff		      lda	#$ff
    606  0448		       85 87		      sta	RunMode
    607  044a							;
    608  044a							; Transfer IL to STMT.  I don't like having this
    609  044a							; hard-coded; fix it.
    610  044a							;
    611  044a		       a9 77		      lda	#STMT&$ff
    612  044c		       85 75		      sta	ILPC
    613  044e		       a9 0f		      lda	#STMT>>8
    614  0450		       85 76		      sta	ILPC+1
    615  0452		       4c eb 02 	      jmp	NextIL
    616  0455							;
    617  0455							; Run
    618  0455							;
    619  0455				   iXferok
    620  0455		       a9 ff		      lda	#$ff
    621  0457		       85 87		      sta	RunMode	;we're running
    622  0459							;
    623  0459							; Need a more elegant way to do this
    624  0459							;
    625  0459		       a9 77		      lda	#STMT&$ff
    626  045b		       85 75		      sta	ILPC
    627  045d		       a9 0f		      lda	#STMT>>8
    628  045f		       85 76		      sta	ILPC+1
    629  0461		       4c eb 02 	      jmp	NextIL
    630  0464							;
    631  0464							;=====================================================
    632  0464							; Save the pointer to the next line to the call stack.
    633  0464							;
    634  0464		       20 7d 0c    iSAV       jsr	pushLN
    635  0467		       b0 03		      bcs	iSAVErr
    636  0469		       4c eb 02 	      jmp	NextIL
    637  046c		       a2 0c	   iSAVErr    ldx	#12
    638  046e		       a9 00	   iSAVErr2   lda	#0
    639  0470		       4c 2e 05 	      jmp	iErr2
    640  0473
    641  0473							;
    642  0473							;=====================================================
    643  0473							; Pop the next line from the call stack.
    644  0473							;
    645  0473		       20 c7 0c    iRET       jsr	popLN
    646  0476		       b0 f4		      bcs	iSAVErr
    647  0478		       a0 03		      ldy	#3
    648  047a		       84 80		      sty	CUROFF
    649  047c		       a5 00		      lda	0
    650  047e		       8d aa 02 	      sta	IRQPending
    651  0481		       58		      cli
    652  0482		       4c eb 02 	      jmp	NextIL
    653  0485
    654  0485		       20 c7 0c    iRSTR      jsr	popLN
    655  0488		       b0 e2		      bcs	iSAVErr
    656  048a		       4c eb 02 	      jmp	NextIL
    657  048d		       a2 0b	   iRSTRErr   ldx	#11
    658  048f		       d0 dd		      bne	iSAVErr2
    659  0491							;
    660  0491							;=====================================================
    661  0491							; Compare items on stack.  Okay, so on input there are
    662  0491							; three things on the stack
    663  0491							;
    664  0491							;    EXPR2 <- Top of stack
    665  0491							;    OP    <- relational operator, next on stack
    666  0491							;    EXPR1 <- last item on stack
    667  0491							;
    668  0491							; Comparison is: EXPR1 <operator> EXPR2
    669  0491							;
    670  0491							; Operator is one of...
    671  0491							;
    672  0491							;    2 is =
    673  0491							;    1 is <
    674  0491							;    3 is <=
    675  0491							;    5 is <>
    676  0491							;    4 is >
    677  0491							;    6 is >=
    678  0491							;
    679  0491							; Those are bit-mapped:
    680  0491							;
    681  0491							;    xxxxxGEL
    682  0491							;
    683  0491							;    G = Greater than
    684  0491							;    E = Equal
    685  0491							;    L = Less than
    686  0491							;
    687  0491							; If the comparison is false, do a NXT, ie, move to the
    688  0491							; next line and continue.  If true, continue executing
    689  0491							; on this line.
    690  0491							;
    691  0491		       00 01	   REL_LT     equ	%001
    692  0491		       00 02	   REL_EQUAL  equ	%010
    693  0491		       00 04	   REL_GT     equ	%100
    694  0491							;
    695  0491		       20 eb 0c    iCMPR      jsr	popR1
    696  0494		       20 fe 0c 	      jsr	popMQ	;operator in MQ
    697  0497		       20 b4 0c 	      jsr	popR0
    698  049a							;
    699  049a							; See if they are equal or not
    700  049a							;
    701  049a		       a5 83		      lda	R0
    702  049c		       c5 85		      cmp	R1
    703  049e		       d0 0a		      bne	iCMPRnoteq	;try not equal
    704  04a0		       a5 84		      lda	R0+1
    705  04a2		       c5 86		      cmp	R1+1
    706  04a4		       d0 04		      bne	iCMPRnoteq
    707  04a6							;
    708  04a6							; Equal, set the flag in MQ+1
    709  04a6							;
    710  04a6		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    711  04a8		       d0 14		      bne	iCMPcom	;Exit it is equal
    712  04aa							;
    713  04aa							; See if EXPR1 (R0) < EXPR2 (R1)
    714  04aa							; See www.6502.org/tutorials/compare_beyond.html
    715  04aa							;
    716  04aa				   iCMPRnoteq
    717  04aa		       a5 83		      lda	R0
    718  04ac		       c5 85		      cmp	R1
    719  04ae		       a5 84		      lda	R0+1
    720  04b0		       e5 86		      sbc	R1+1
    721  04b2		       50 02		      bvc	iCMPR_2
    722  04b4		       49 80		      eor	#$80
    723  04b6		       30 04	   iCMPR_2    bmi	iCMPlt
    724  04b8		       a9 04		      lda	#REL_GT
    725  04ba		       d0 02		      bne	iCMPcom
    726  04bc		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    727  04be
    728  04be		       0d 25 13    iCMPcom    ora	MQ+1	; or with original mask
    729  04c1							;
    730  04c1							; Now compare the end result with what the caller
    731  04c1							; was looking for.
    732  04c1							;
    733  04c1		       2d 24 13 	      and	MQ
    734  04c4		       f0 0a		      beq	iCMPno	; no match
    735  04c6		       a9 01		      lda	#1
    736  04c8		       85 83		      sta	R0
    737  04ca		       d0 08		      bne	iCMPDone
    738  04cc							;
    739  04cc							; R0 > R1
    740  04cc							;
    741  04cc		       a9 04	   iCMPgt     lda	#REL_GT
    742  04ce		       d0 ee		      bne	iCMPcom
    743  04d0				   iCMPno
    744  04d0		       a9 00		      lda	#0
    745  04d2		       85 83		      sta	R0
    746  04d4
    747  04d4				   iCMPDone
    748  04d4		       a9 00		      lda	#0
    749  04d6		       85 84		      sta	R0+1
    750  04d8		       20 6a 0c 	      jsr	pushR0
    751  04db		       4c eb 02 	      jmp	NextIL
    752  04de							;
    753  04de							; if Not a match, so jump to the next line of code.
    754  04de							; Branches based upon value on top of the stack
    755  04de				   iBranch
    756  04de		       20 b4 0c 	      jsr	popR0
    757  04e1		       a5 83		      lda	R0
    758  04e3		       05 84		      ora	R0+1
    759  04e5		       f0 03		      beq	iBranchFalse	; not true
    760  04e7		       4c eb 02 	      jmp	NextIL	; It is true if any value not zero
    761  04ea							;
    762  04ea				   iBranchFalse
    763  04ea		       20 e7 0a 	      jsr	FindNextLine
    764  04ed		       4c 3d 04 	      jmp	iXFER2
    765  04f0							;
    766  04f0							;=====================================================
    767  04f0							; Get a line of text from the user, convert to a
    768  04f0							; number, leave on top of stack.
    769  04f0							;
    770  04f0				   iINNUM
    771  04f0		       20 7d 0c 	      jsr	pushLN
    772  04f3							;
    773  04f3		       a9 3f		      lda	#'?
    774  04f5		       20 e9 0b 	      jsr	GetLine
    775  04f8		       20 72 0b 	      jsr	getDecimal
    776  04fb		       20 6a 0c 	      jsr	pushR0	;put onto stack
    777  04fe							;
    778  04fe		       4c 14 05 	      jmp	ExitIn
    779  0501							;
    780  0501							;=====================================================
    781  0501							; Get a line of text from the user, convert to a
    782  0501							; String , leave on top of stack. up to 2 characters
    783  0501							;
    784  0501				   iINSTR
    785  0501		       20 7d 0c 	      jsr	pushLN
    786  0504							;
    787  0504		       a9 3f		      lda	#'?
    788  0506		       20 e9 0b 	      jsr	GetLine
    789  0509		       b1 7e		      lda	(CURPTR),y
    790  050b		       85 83		      sta	R0
    791  050d		       a9 00		      lda	#0
    792  050f		       85 84		      sta	R0+1
    793  0511		       20 6a 0c 	      jsr	pushR0	;put onto stack
    794  0514							;
    795  0514				   ExitIn
    796  0514		       20 c7 0c 	      jsr	popLN
    797  0517							;
    798  0517		       4c eb 02 	      jmp	NextIL
    799  051a							;
    800  051a							;
    801  051a							;=====================================================
    802  051a							; Stop the currently running program.	Actually very
    803  051a							; simple to do... clear the RunMode flag, then set the
    804  051a							; ILPC to the standard handler and continue running.
    805  051a							;
    806  051a		       a9 00	   iFIN       lda	#0
    807  051c		       85 87		      sta	RunMode
    808  051e							;
    809  051e		       ad 22 13 	      lda	errGoto
    810  0521		       85 75		      sta	ILPC
    811  0523		       ad 23 13 	      lda	errGoto+1
    812  0526		       85 76		      sta	ILPC+1
    813  0528		       4c eb 02 	      jmp	NextIL
    814  052b							;
    815  052b							;=====================================================
    816  052b							; Handle the ERR opcode.  Following the instruction is
    817  052b							; a 16 bit error number.  Print an error message, and
    818  052b							; if we're in run mode, print the line number.  Stop
    819  052b							; program execution and return to the initial state.
    820  052b							;
    821  052b		       20 5d 0a    iERR       jsr	getILWord	;get err code
    822  052e							;
    823  052e							; Enter here with the error code in X (LSB) and A (MSB).
    824  052e							;
    825  052e		       86 83	   iErr2      stx	R0
    826  0530		       85 84		      sta	R0+1
    827  0532							;
    828  0532		       20 12 f0 	      jsr	puts
      0  0535					      db	"Error ",0
      1  0535		       45 72 72 6f*	      .byte.b	"Error ",0
    830  053c		       20 06 0b 	      jsr	PrintDecimal
    831  053f							;
    832  053f		       a5 87		      lda	RunMode	;running?
    833  0541		       f0 1b		      beq	iERR2	;nope
    834  0543		       20 12 f0 	      jsr	puts
      0  0546					      db	" at line ",0
      1  0546		       20 61 74 20*	      .byte.b	" at line ",0
    836  0550		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    837  0552		       b1 7e		      lda	(CURPTR),y
    838  0554		       85 83		      sta	R0
    839  0556		       c8		      iny
    840  0557		       b1 7e		      lda	(CURPTR),y
    841  0559		       85 84		      sta	R0+1
    842  055b		       20 06 0b 	      jsr	PrintDecimal
    843  055e							;
    844  055e		       20 0c 02    iERR2      jsr	CRLF
    845  0561		       a9 00		      lda	#0
    846  0563		       85 87		      sta	RunMode	;fall through...
    847  0565							;
    848  0565							;=====================================================
    849  0565							; Reset the IL to be back at the idle loop.  Does not
    850  0565							; clear variables so the user can see what state
    851  0565							; the program is in.
    852  0565							;
    853  0565		       a9 00	   ResetIL    lda	#0
    854  0567		       8d 98 12 	      sta	retStackPtr
    855  056a		       ad 22 13 	      lda	errGoto
    856  056d		       85 75		      sta	ILPC
    857  056f		       ad 23 13 	      lda	errGoto+1
    858  0572		       85 76		      sta	ILPC+1
    859  0574		       4c eb 02 	      jmp	NextIL
    860  0577							;
    861  0577							;=====================================================
    862  0577							; Pop two items off stack, add them, then place the
    863  0577							; result back onto the stack.
    864  0577							;
    865  0577		       20 b4 0c    iADD       jsr	popR0
    866  057a		       20 eb 0c 	      jsr	popR1
    867  057d		       18		      clc
    868  057e		       a5 83		      lda	R0
    869  0580		       65 85		      adc	R1
    870  0582		       85 83		      sta	R0
    871  0584		       a5 84		      lda	R0+1
    872  0586		       65 86		      adc	R1+1
    873  0588		       85 84		      sta	R0+1
    874  058a		       4c ef 05 	      jmp	pushR0nextIl
    875  058d							;
    876  058d							;=====================================================
    877  058d							; Pop two items off the stack.  Subtract the top of
    878  058d							; stack from the lower entry.
    879  058d							;
    880  058d		       20 eb 0c    iSUB       jsr	popR1
    881  0590		       20 b4 0c 	      jsr	popR0
    882  0593		       38		      sec
    883  0594		       a5 83		      lda	R0
    884  0596		       e5 85		      sbc	R1
    885  0598		       85 83		      sta	R0
    886  059a		       a5 84		      lda	R0+1
    887  059c		       e5 86		      sbc	R1+1
    888  059e		       85 84		      sta	R0+1
    889  05a0		       4c ef 05 	      jmp	pushR0nextIl
    890  05a3							;
    891  05a3							;=====================================================
    892  05a3							; Negate the top of stack.
    893  05a3							;
    894  05a3		       20 b4 0c    iNEG       jsr	popR0
    895  05a6		       a5 83		      lda	R0
    896  05a8		       49 ff		      eor	#$ff
    897  05aa		       85 83		      sta	R0
    898  05ac		       a5 84		      lda	R0+1
    899  05ae		       49 ff		      eor	#$ff
    900  05b0		       85 84		      sta	R0+1
    901  05b2		       e6 83		      inc	R0
    902  05b4		       d0 02		      bne	iNEG2
    903  05b6		       e6 84		      inc	R0+1
    904  05b8		       4c ef 05    iNEG2      jmp	pushR0nextIl
    905  05bb							;
    906  05bb							;=====================================================
    907  05bb							; Multiply top two items on the stack, put the results
    908  05bb							; on top.  This uses the algorithm documented on page
    909  05bb							; 115 of "Microprocessor Programming for Computer
    910  05bb							; Hobbyists" by Neill Graham.
    911  05bb							;
    912  05bb		       20 b4 0c    iMUL       jsr	popR0	;AC
    913  05be		       20 eb 0c 	      jsr	popR1	;OP
    914  05c1							;
    915  05c1		       a5 83		      lda	R0
    916  05c3		       8d 24 13 	      sta	MQ
    917  05c6		       a5 84		      lda	R0+1
    918  05c8		       8d 25 13 	      sta	MQ+1
    919  05cb		       a9 00		      lda	#0	;clear result
    920  05cd		       85 83		      sta	R0
    921  05cf		       85 84		      sta	R0+1
    922  05d1							;
    923  05d1		       a2 10		      ldx	#16	;number of bits in value
    924  05d3		       06 83	   multloop   asl	R0
    925  05d5		       26 84		      rol	R0+1
    926  05d7		       0e 24 13 	      asl	MQ
    927  05da		       2e 25 13 	      rol	MQ+1
    928  05dd		       90 0d		      bcc	multno	;skip add if no carry
    929  05df							;
    930  05df							; Add R1 back into R0
    931  05df							;
    932  05df		       18		      clc
    933  05e0		       a5 83		      lda	R0
    934  05e2		       65 85		      adc	R1
    935  05e4		       85 83		      sta	R0
    936  05e6		       a5 84		      lda	R0+1
    937  05e8		       65 86		      adc	R1+1
    938  05ea		       85 84		      sta	R0+1
    939  05ec							;
    940  05ec		       ca	   multno     dex		;did all bits yet?
    941  05ed		       d0 e4		      bne	multloop
    942  05ef							;
    943  05ef				   pushR0nextIl
    944  05ef		       20 6a 0c 	      jsr	pushR0	;OP
    945  05f2		       4c eb 02 	      jmp	NextIL
    946  05f5							;
    947  05f5							;=====================================================
    948  05f5							; Divide the top of stack into the next to top item.
    949  05f5							; Leave results on stack.  Taken from:
    950  05f5							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
    951  05f5							;
    952  05f5							; R0 = R0 / R1
    953  05f5							; Remainder is in MQ
    954  05f5							;
    955  05f5		       20 11 06    iDIV       jsr	iDoDiv
    956  05f8		       20 4e 0d 	      jsr	RestoreSigns
    957  05fb		       4c ef 05 	      jmp	pushR0nextIl
    958  05fe
    959  05fe		       20 11 06    iMOD       jsr	iDoDiv
    960  0601		       20 4e 0d 	      jsr	RestoreSigns
    961  0604		       ad 24 13 	      lda	MQ
    962  0607		       85 83		      sta	R0
    963  0609		       ad 25 13 	      lda	MQ+1
    964  060c		       85 84		      sta	R0+1
    965  060e		       4c ef 05 	      jmp	pushR0nextIl
    966  0611
    967  0611				   iDoDiv
    968  0611		       20 eb 0c 	      jsr	popR1
    969  0614		       20 b4 0c 	      jsr	popR0
    970  0617							;
    971  0617							; Check for divide by zero
    972  0617							;
    973  0617		       a5 85		      lda	R1
    974  0619		       05 86		      ora	R1+1
    975  061b		       f0 31		      beq	divby0
    976  061d							;
    977  061d		       20 13 0d 	      jsr	SaveSigns
    978  0620		       a9 00		      lda	#0	;preset remainder to 0
    979  0622		       8d 24 13 	      sta	MQ
    980  0625		       8d 25 13 	      sta	MQ+1
    981  0628		       a2 10		      ldx	#16	;repeat for each bit: ...
    982  062a				   divloop
    983  062a		       06 83		      asl	R0	;dividend lb & hb*2, msb -> Carry
    984  062c		       26 84		      rol	R0+1
    985  062e		       2e 24 13 	      rol	MQ	;remainder lb & hb * 2 + msb from carry
    986  0631		       2e 25 13 	      rol	MQ+1
    987  0634		       ad 24 13 	      lda	MQ
    988  0637		       38		      sec
    989  0638		       e5 85		      sbc	R1	;substract divisor to see if it fits in
    990  063a		       a8		      tay		;lb result -> Y, for we may need it later
    991  063b		       ad 25 13 	      lda	MQ+1
    992  063e		       e5 86		      sbc	R1+1
    993  0640		       90 08		      bcc	skip	;if carry=0 then divisor didn't fit in yet
    994  0642
    995  0642		       8d 25 13 	      sta	MQ+1	;else save substraction result as new remainder,
    996  0645		       8c 24 13 	      sty	MQ
    997  0648		       e6 83		      inc	R0	;and INCrement result cause divisor fit in 1 times
    998  064a
    999  064a		       ca	   skip       dex
   1000  064b		       d0 dd		      bne	divloop
   1001  064d		       60		      rts
   1002  064e							;
   1003  064e							; Indicate divide-by-zero error
   1004  064e							;
   1005  064e		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1006  0650		       a9 00		      lda	#0
   1007  0652		       4c 2e 05 	      jmp	iErr2
   1008  0655							;
   1009  0655							;=====================================================
   1010  0655							; This pops the top two items off the stack.  The top
   1011  0655							; item is a data value and the other is an index into
   1012  0655							; the variable table.	Save the value into that entry.
   1013  0655							;
   1014  0655		       20 b4 0c    iSTORE     jsr	popR0	;data
   1015  0658		       20 eb 0c 	      jsr	popR1	;index
   1016  065b		       a6 85		      ldx	R1	;get index
   1017  065d		       a5 83		      lda	R0
   1018  065f		       95 41		      sta	variables,x
   1019  0661		       a5 84		      lda	R0+1
   1020  0663		       95 42		      sta	variables+1,x
   1021  0665		       4c eb 02 	      jmp	NextIL
   1022  0668							;
   1023  0668							;=====================================================
   1024  0668							; Replaces the top of stack with the variable whose
   1025  0668							; index it represents.
   1026  0668							;
   1027  0668		       20 eb 0c    iIND       jsr	popR1
   1028  066b		       a6 85		      ldx	R1	;get index
   1029  066d		       b5 41		      lda	variables,x
   1030  066f		       85 83		      sta	R0
   1031  0671		       b5 42		      lda	variables+1,x
   1032  0673		       85 84		      sta	R0+1
   1033  0675		       4c ef 05 	      jmp	pushR0nextIl
   1034  0678							;
   1035  0678							;=====================================================
   1036  0678							; List the current BASIC program in memory.  Uses R0,
   1037  0678							; tempIly, and dpl.
   1038  0678							;
   1039  0678		       20 fe 0d    iLST       jsr	SetOutConsole
   1040  067b		       a9 35	   iLST2      lda	#ProgramStart&$ff
   1041  067d		       85 77		      sta	dpl
   1042  067f		       a9 13		      lda	#ProgramStart>>8
   1043  0681		       85 78		      sta	dpl+1
   1044  0683							;
   1045  0683							; dpl/dph point to the current line.  See if we're at
   1046  0683							; the end of the program.
   1047  0683							;
   1048  0683		       a5 77	   iLSTloop   lda	dpl
   1049  0685		       cd 2d 13 	      cmp	PROGRAMEND
   1050  0688		       d0 07		      bne	iLstNotEnd
   1051  068a		       a5 78		      lda	dpl+1
   1052  068c		       cd 2e 13 	      cmp	PROGRAMEND+1
   1053  068f		       f0 40		      beq	iLstdone
   1054  0691							;
   1055  0691		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1056  0693		       b1 77		      lda	(dpl),y	;line number LSB
   1057  0695		       85 83		      sta	R0
   1058  0697		       c8		      iny
   1059  0698		       b1 77		      lda	(dpl),y	;line number MSB
   1060  069a		       85 84		      sta	R0+1
   1061  069c		       c8		      iny
   1062  069d		       84 7b		      sty	tempIlY
   1063  069f		       20 06 0b 	      jsr	PrintDecimal
   1064  06a2		       a9 20		      lda	#SPACE
   1065  06a4		       20 09 0e 	      jsr	VOUTCH
   1066  06a7		       a4 7b		      ldy	tempIlY
   1067  06a9		       b1 77	   iLSTl2     lda	(dpl),y
   1068  06ab		       f0 0a		      beq	iLST3	;end of this line
   1069  06ad		       84 7b		      sty	tempIlY
   1070  06af		       20 09 0e 	      jsr	VOUTCH
   1071  06b2		       a4 7b		      ldy	tempIlY
   1072  06b4		       c8		      iny
   1073  06b5		       d0 f2		      bne	iLSTl2	;do next char
   1074  06b7							;
   1075  06b7							; End of this line.  Print CR/LF, then move to the
   1076  06b7							; next line.
   1077  06b7							;
   1078  06b7		       c8	   iLST3      iny
   1079  06b8		       18		      clc
   1080  06b9		       98		      tya
   1081  06ba		       65 77		      adc	dpl
   1082  06bc		       85 77		      sta	dpl
   1083  06be		       a5 78		      lda	dpl+1
   1084  06c0		       69 00		      adc	#0
   1085  06c2		       85 78		      sta	dpl+1
   1086  06c4							;
   1087  06c4							; Have to manually do CR/LF so it uses the vectored
   1088  06c4							; output function.
   1089  06c4							;
   1090  06c4		       a9 0d		      lda	#CR
   1091  06c6		       20 09 0e 	      jsr	VOUTCH
   1092  06c9		       a9 0a		      lda	#LF
   1093  06cb		       20 09 0e 	      jsr	VOUTCH
   1094  06ce		       4c 83 06 	      jmp	iLSTloop	;do next line
   1095  06d1							;
   1096  06d1		       20 fe 0d    iLstdone   jsr	SetOutConsole
   1097  06d4		       4c eb 02 	      jmp	NextIL
   1098  06d7							;
   1099  06d7							;=====================================================
   1100  06d7							; Get a line of text into LINBUF.  Terminate with a
   1101  06d7							; null byte.
   1102  06d7							;
   1103  06d7		       a9 3e	   iGETLINE   lda	#'>	;prompt character
   1104  06d9		       20 e9 0b 	      jsr	GetLine
   1105  06dc							;
   1106  06dc		       a9 00		      lda	#0
   1107  06de		       85 87		      sta	RunMode
   1108  06e0		       4c eb 02 	      jmp	NextIL
   1109  06e3							;
   1110  06e3							;=====================================================
   1111  06e3							; This is called when the input buffer contains a line
   1112  06e3							; typed in by the user that starts with a line number.
   1113  06e3							; Insert the line into the program or delete the line
   1114  06e3							; if there is nothing after the line number,
   1115  06e3							;
   1116  06e3		       a0 00	   iINSRT     ldy	#0
   1117  06e5		       20 72 0b 	      jsr	getDecimal	;convert line #
   1118  06e8		       20 7d 0d 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1119  06eb		       84 7c		      sty	offset	;Save the start of the program line text
   1120  06ed							;
   1121  06ed							; Now find the line OR the next higher line OR the
   1122  06ed							; end of the program.
   1123  06ed							;
   1124  06ed		       20 a4 0a 	      jsr	findLine	; Look for the line number in the current program
   1125  06f0							; Returns Z and curptr point to the line if found
   1126  06f0							; Returns C and curptr at next higher line if not found and there is a higher line
   1127  06f0							; Returns ZC clear and curptr to end of program if higher than all other lines
   1128  06f0							;
   1129  06f0							; If the line exists, it needs to be removed.
   1130  06f0							;
   1131  06f0		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1132  06f2							;
   1133  06f2							; Get length of line to be removed, we fall thru to here if we find a matching line
   1134  06f2							;
   1135  06f2							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1136  06f2		       a0 00		      ldy	#0
   1137  06f4		       b1 7e		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1138  06f6		       a8		      tay
   1139  06f7							;If it is equal we delete the line and replace it, get length
   1140  06f7							;then adjust all program line after up or down depending on len of line
   1141  06f7							;If next higher then just move everythimg down by length bytes
   1142  06f7							;This call will return how many bytes in the line we found
   1143  06f7		       84 7d		      sty	lineLength	;Save the length of the line we found
   1144  06f9							;
   1145  06f9							; Compute the new end of the program first.
   1146  06f9							;
   1147  06f9		       38		      sec		;Set the carry bit
   1148  06fa		       ad 2d 13 	      lda	PROGRAMEND	;Get low byte of program end
   1149  06fd		       e5 7d		      sbc	lineLength	;Subtract the length of the current line
   1150  06ff		       8d 2d 13 	      sta	PROGRAMEND	;save it
   1151  0702		       ad 2e 13 	      lda	PROGRAMEND+1
   1152  0705		       e9 00		      sbc	#0	;Process the carry
   1153  0707		       8d 2e 13 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1154  070a							;
   1155  070a							; Copy CURPTR into R1 for working
   1156  070a							;
   1157  070a		       a5 7e		      lda	CURPTR	;Save the current position to r1 copy destination
   1158  070c		       85 85		      sta	R1
   1159  070e		       a5 7f		      lda	CURPTR+1
   1160  0710		       85 86		      sta	R1+1
   1161  0712							;
   1162  0712							; See if we're at the end.
   1163  0712							;
   1164  0712		       a5 85	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1165  0714		       cd 2d 13 	      cmp	PROGRAMEND
   1166  0717		       d0 07		      bne	InsDelLoop
   1167  0719		       a5 86		      lda	R1+1
   1168  071b		       cd 2e 13 	      cmp	PROGRAMEND+1
   1169  071e		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1170  0720							;
   1171  0720							; Move one byte, move to next location.
   1172  0720							;
   1173  0720		       a4 7d	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1174  0722		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1175  0724		       b1 85		      lda	(R1),y
   1176  0726		       a0 00		      ldy	#0
   1177  0728		       91 85		      sta	(R1),y
   1178  072a		       e6 85		      inc	R1
   1179  072c		       d0 e4		      bne	InsDelChk
   1180  072e		       e6 86		      inc	R1+1
   1181  0730		       4c 12 07 	      jmp	InsDelChk	; Check if we have moved the last byte
   1182  0733							;
   1183  0733							; Deletion is done.
   1184  0733							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1185  0733							;
   1186  0733		       a4 7c	   insert2    ldy	offset	;get back ptr	Get the current offset
   1187  0735		       b9 9a 12 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1188  0738		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1189  073a							;
   1190  073a							; CURPTR points to where the line will be inserted.
   1191  073a							;
   1192  073a		       20 46 0c 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1193  073d							;
   1194  073d		       ad 2d 13 	      lda	PROGRAMEND	;Load the start address for the copy
   1195  0740							;At this point curptr still contains the location we will insert data
   1196  0740		       85 88		      sta	FROM
   1197  0742		       ad 2e 13 	      lda	PROGRAMEND+1
   1198  0745		       85 89		      sta	FROM+1
   1199  0747							;
   1200  0747		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1201  0749		       b1 88		      lda	(FROM),y
   1202  074b		       a4 7d		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1203  074d		       91 88		      sta	(FROM),y	;Save the new byte
   1204  074f							;
   1205  074f		       a5 88		      lda	FROM	;Check if we have copies the last byte
   1206  0751		       c5 7e		      cmp	CURPTR
   1207  0753		       d0 06		      bne	mvUpMore
   1208  0755		       a5 89		      lda	FROM+1
   1209  0757		       c5 7f		      cmp	CURPTR+1
   1210  0759		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1211  075b							;
   1212  075b							; Not done yet
   1213  075b							;
   1214  075b		       a5 88	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1215  075d		       d0 02		      bne	mvUpMore2
   1216  075f		       c6 89		      dec	FROM+1
   1217  0761		       c6 88	   mvUpMore2  dec	FROM
   1218  0763		       4c 47 07 	      jmp	mvup1	;Loop until everything is moved
   1219  0766							;
   1220  0766							; All done with copy.
   1221  0766							;
   1222  0766		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1223  0767		       a5 7d		      lda	lineLength	;Number of bytes to copy from line buff
   1224  0769		       6d 2d 13 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1225  076c		       8d 2d 13 	      sta	PROGRAMEND
   1226  076f		       ad 2e 13 	      lda	PROGRAMEND+1
   1227  0772		       69 00		      adc	#0
   1228  0774		       8d 2e 13 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1229  0777							;
   1230  0777							;===================jlit use length before line newline
   1231  0777
   1232  0777		       a0 00		      ldy	#0	;Set offset of copy
   1233  0779		       a5 7d		      lda	lineLength	;We will insert the actual length of the line first
   1234  077b		       91 7e		      sta	(CURPTR),y	;Store the length
   1235  077d		       c8		      iny
   1236  077e		       a5 83		      lda	R0	;Store the line number next
   1237  0780		       91 7e		      sta	(CURPTR),y
   1238  0782		       c8		      iny
   1239  0783		       a5 84		      lda	R0+1
   1240  0785		       91 7e		      sta	(CURPTR),y
   1241  0787		       c8		      iny
   1242  0788							;
   1243  0788		       a6 7c		      ldx	offset	;Load the offset into line buffer in page zero
   1244  078a		       bd 9a 12    mvUpLoop2  lda	LINBUF,x	;get a byte
   1245  078d		       91 7e		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1246  078f		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1247  0791		       e8		      inx
   1248  0792		       c8		      iny
   1249  0793		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1250  0795							;
   1251  0795		       4c eb 02    mvUpFini   jmp	NextIL
   1252  0798							;
   1253  0798							;=====================================================
   1254  0798							; Pops the top value of the ILPC stack and stores it
   1255  0798							; in ILPC.  Ie, return from an IL subroutine.
   1256  0798							;
   1257  0798		       20 91 0a    iRTN       jsr	popILPC
   1258  079b		       4c eb 02 	      jmp	NextIL
   1259  079e							;
   1260  079e							;=====================================================
   1261  079e							; NLINE print a newline
   1262  079e							;
   1263  079e		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1264  07a1		       4c eb 02 	      jmp	NextIL
   1265  07a4							;
   1266  07a4							;=====================================================
   1267  07a4							; This saves the current ILPC value on the stack, then
   1268  07a4							; jumps to the address specified by the next two bytes.
   1269  07a4							;
   1270  07a4		       20 77 0a    iCALL      jsr	pushILPC	;save ILPC
   1271  07a7							;
   1272  07a7							; Jmp to a specific location in the IL code.  The new
   1273  07a7							; address immediately follows the opcode.
   1274  07a7							;
   1275  07a7		       20 5d 0a    iJMP       jsr	getILWord
   1276  07aa		       86 75		      stx	ILPC
   1277  07ac		       85 76		      sta	ILPC+1
   1278  07ae		       4c eb 02 	      jmp	NextIL
   1279  07b1							;
   1280  07b1							;=====================================================
   1281  07b1							; Push the next two bytes onto the arithmetic stack.
   1282  07b1							;
   1283  07b1		       20 5d 0a    iLIT       jsr	getILWord
   1284  07b4		       86 83		      stx	R0
   1285  07b6		       85 84		      sta	R0+1
   1286  07b8		       20 6a 0c 	      jsr	pushR0
   1287  07bb		       4c eb 02 	      jmp	NextIL
   1288  07be							;
   1289  07be							;=====================================================
   1290  07be							; Initialize all variables.  Ie, set to zero.
   1291  07be							;
   1292  07be		       a9 00	   iVINIT     lda	#0
   1293  07c0		       a2 00		      ldx	#0
   1294  07c2		       95 41	   Vinit2     sta	variables,x
   1295  07c4		       e8		      inx
   1296  07c5		       e0 34		      cpx	#variablesEnd-variables
   1297  07c7		       d0 f9		      bne	Vinit2
   1298  07c9		       4c eb 02 	      jmp	NextIL
   1299  07cc							;
   1300  07cc							;=====================================================
   1301  07cc							; Set the address of the error handler.  After any
   1302  07cc							; error, set to the ILPC to the specified location.
   1303  07cc							;
   1304  07cc		       20 5d 0a    iERRGOTO   jsr	getILWord
   1305  07cf		       8e 22 13 	      stx	errGoto
   1306  07d2		       8d 23 13 	      sta	errGoto+1
   1307  07d5		       4c eb 02 	      jmp	NextIL
   1308  07d8							;
   1309  07d8							;=====================================================
   1310  07d8							; TST is followed by an 8 bit signed offset, then a
   1311  07d8							; null terminated string.  Compare the string against
   1312  07d8							; the string starting at (CURPTR),CUROFF.  If the
   1313  07d8							; strings match, continue executing the next IL
   1314  07d8							; opcode.  Else, add the offset to ILPC.
   1315  07d8							;
   1316  07d8		       20 61 0a    iTST       jsr	getILByte
   1317  07db		       85 7c		      sta	offset
   1318  07dd							;
   1319  07dd		       20 58 0c 	      jsr	saveIL	;in case of failure
   1320  07e0		       a4 80		      ldy	CUROFF
   1321  07e2		       84 77		      sty	dpl	;save for later
   1322  07e4							;
   1323  07e4		       20 61 0a    iTSTloop   jsr	getILByte	;get next char
   1324  07e7		       f0 11		      beq	iTSTm	;match!
   1325  07e9		       a4 77		      ldy	dpl
   1326  07eb		       d1 7e		      cmp	(CURPTR),y
   1327  07ed		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1328  07ef		       09 20		      ora	#$20	; lets allow lowercase as well
   1329  07f1		       d1 7e		      cmp	(CURPTR),y
   1330  07f3		       d0 22		      bne	iTSTfail	;mismatch
   1331  07f5		       c8	   iTSTUpper  iny
   1332  07f6		       84 77		      sty	dpl
   1333  07f8		       d0 ea		      bne	iTSTloop
   1334  07fa							;
   1335  07fa							; It's a match!  Clean up a bit.
   1336  07fa							;
   1337  07fa		       a4 77	   iTSTm      ldy	dpl
   1338  07fc		       84 80		      sty	CUROFF
   1339  07fe		       4c eb 02 	      jmp	NextIL
   1340  0801							; Test for a single quote
   1341  0801		       20 61 0a    iTSTStr    jsr	getILByte
   1342  0804		       85 7c		      sta	offset
   1343  0806		       20 58 0c 	      jsr	saveIL
   1344  0809		       a4 80		      ldy	CUROFF
   1345  080b		       a9 22		      lda	#'"
   1346  080d		       d1 7e		      cmp	(CURPTR),y
   1347  080f		       d0 06		      bne	iTSTfail
   1348  0811		       c8		      iny
   1349  0812		       84 80		      sty	CUROFF
   1350  0814		       4c f9 02 	      jmp	NextILStr
   1351  0817							;
   1352  0817							; Not a match, reset ILPC and then move to the
   1353  0817							; offset.
   1354  0817							;
   1355  0817		       20 61 0c    iTSTfail   jsr	restoreIL
   1356  081a		       4c c2 08 	      jmp	tstBranch
   1357  081d							;
   1358  081d							;=================================================JLIT=
   1359  081d							; Test if we have a let statement without the let keyword
   1360  081d		       20 61 0a    iTSTLET    jsr	getILByte
   1361  0820		       85 7c		      sta	offset
   1362  0822		       20 58 0c 	      jsr	saveIL	; save to restore when done
   1363  0825
   1364  0825		       a4 80		      ldy	CUROFF
   1365  0827		       20 7d 0d 	      jsr	SkipSpaces
   1366  082a		       c8		      iny		; skip the Variable name
   1367  082b		       20 7d 0d 	      jsr	SkipSpaces	; skip any SkipSpaces
   1368  082e		       b1 7e		      lda	(CURPTR),y	; Get what should be an equal sign
   1369  0830		       c9 3d		      cmp	#'=	; check if equals
   1370  0832		       d0 e3		      bne	iTSTfail	; return it failed
   1371  0834		       20 61 0c 	      jsr	restoreIL	; restore the IL anyway
   1372  0837		       4c eb 02 	      jmp	NextIL	; Then next instruction
   1373  083a
   1374  083a							;================================================jLIT=
   1375  083a							;Test for end of line
   1376  083a							;
   1377  083a		       20 61 0a    iTSTDONE   jsr	getILByte
   1378  083d		       85 7c		      sta	offset
   1379  083f		       20 58 0c 	      jsr	saveIL
   1380  0842		       a4 80		      ldy	CUROFF
   1381  0844		       84 77		      sty	dpl
   1382  0846		       20 7d 0d 	      jsr	SkipSpaces
   1383  0849		       b1 7e		      lda	(CURPTR),y
   1384  084b		       f0 0b		      beq	iTSTDONEtrue
   1385  084d		       c9 3a		      cmp	#COLON
   1386  084f		       f0 07		      beq	iTSTDONEtrue
   1387  0851		       a4 77		      ldy	dpl
   1388  0853		       84 80		      sty	CUROFF
   1389  0855		       4c 17 08 	      jmp	iTSTfail
   1390  0858							;
   1391  0858							; Advance to the next line
   1392  0858							;
   1393  0858				   iTSTDONEtrue
   1394  0858		       4c eb 02 	      jmp	NextIL
   1395  085b							;
   1396  085b							;=====================================================
   1397  085b							; TSTV is followed by an 8 bit signed offset.	If the
   1398  085b							; value at (CURPTR),CUROFF appears to be a variable
   1399  085b							; name, move to the next IL statement.  Else, add the
   1400  085b							; offset to ILPC.
   1401  085b							;
   1402  085b		       20 61 0a    iTSTV      jsr	getILByte	;offset
   1403  085e		       85 7c		      sta	offset
   1404  0860							;
   1405  0860		       a4 80		      ldy	CUROFF
   1406  0862		       20 7d 0d 	      jsr	SkipSpaces
   1407  0865		       b1 7e		      lda	(CURPTR),y
   1408  0867							;
   1409  0867		       09 20		      ora	#$20	;make lower then upper
   1410  0869		       49 20		      eor	#$20	;allow lower case here
   1411  086b		       c9 41		      cmp	#'A
   1412  086d		       90 53		      bcc	tstBranch
   1413  086f		       c9 5b		      cmp	#'Z+1
   1414  0871		       b0 4f		      bcs	tstBranch
   1415  0873							;
   1416  0873							; The condition is true, so convert to an index, push
   1417  0873							; it onto the stack and continue running.
   1418  0873							;
   1419  0873		       38		      sec
   1420  0874		       e9 41		      sbc	#'A	;index is zero based
   1421  0876		       0a		      asl		;multiply by two
   1422  0877		       85 83		      sta	R0
   1423  0879		       a9 00		      lda	#0
   1424  087b		       85 84		      sta	R0+1
   1425  087d		       20 6a 0c 	      jsr	pushR0	;put index onto stack
   1426  0880		       e6 80		      inc	CUROFF	;move to next input char
   1427  0882		       4c eb 02 	      jmp	NextIL
   1428  0885							;
   1429  0885							;=====================================================
   1430  0885							; TSTL seems basically the same as TSTN, but leave the
   1431  0885							; value in R0 instead of pushing onto stack.
   1432  0885							; This tests for a valid line number
   1433  0885							;
   1434  0885		       20 61 0a    iTSTL      jsr	getILByte
   1435  0888		       85 7c		      sta	offset
   1436  088a							;
   1437  088a		       a4 80		      ldy	CUROFF
   1438  088c		       20 7d 0d 	      jsr	SkipSpaces
   1439  088f		       b1 7e		      lda	(CURPTR),y
   1440  0891							;
   1441  0891		       c9 30		      cmp	#'0
   1442  0893		       90 2d		      bcc	tstBranch
   1443  0895		       c9 3a		      cmp	#'9+1
   1444  0897		       b0 29		      bcs	tstBranch
   1445  0899							;
   1446  0899							; It's a digit, so convert to a number.
   1447  0899							;
   1448  0899		       20 72 0b 	      jsr	getDecimal
   1449  089c		       4c eb 02 	      jmp	NextIL
   1450  089f							;
   1451  089f							;=====================================================
   1452  089f							; TSTN checks for a number.  This is very simplistic;
   1453  089f							; if the character is a digit, assume it's a number.
   1454  089f							; Convert to a number and push it onto the stack.
   1455  089f							;
   1456  089f		       20 61 0a    iTSTN      jsr	getILByte
   1457  08a2		       85 7c		      sta	offset
   1458  08a4							;
   1459  08a4		       a4 80		      ldy	CUROFF
   1460  08a6		       20 7d 0d 	      jsr	SkipSpaces
   1461  08a9		       b1 7e		      lda	(CURPTR),y
   1462  08ab		       c9 2d		      cmp	#'-	;negative?
   1463  08ad		       f0 08		      beq	iTSTN_1
   1464  08af		       c9 30		      cmp	#'0
   1465  08b1		       90 0f		      bcc	tstBranch
   1466  08b3		       c9 3a		      cmp	#'9+1
   1467  08b5		       b0 0b		      bcs	tstBranch
   1468  08b7							;
   1469  08b7							; It's a digit, so convert to a number.
   1470  08b7							;
   1471  08b7		       20 72 0b    iTSTN_1    jsr	getDecimal
   1472  08ba		       84 80		      sty	CUROFF
   1473  08bc		       20 6a 0c 	      jsr	pushR0	;save onto stack
   1474  08bf		       4c eb 02 	      jmp	NextIL
   1475  08c2
   1476  08c2							;
   1477  08c2							; Common jump point for all TSTx instructions that
   1478  08c2							; fail to meet the requirements.  This takes the
   1479  08c2							; offset and adds/subtracts to/from ILPC.
   1480  08c2							;
   1481  08c2		       a5 7c	   tstBranch  lda	offset	;get signed offset
   1482  08c4		       10 0e		      bpl	tstPositive
   1483  08c6							;
   1484  08c6							; Do negative branch.	Do sign extension.
   1485  08c6							;
   1486  08c6		       18		      clc
   1487  08c7		       65 75		      adc	ILPC
   1488  08c9		       85 75		      sta	ILPC
   1489  08cb		       a5 76		      lda	ILPC+1
   1490  08cd		       69 ff		      adc	#$ff
   1491  08cf		       85 76		      sta	ILPC+1
   1492  08d1		       4c eb 02 	      jmp	NextIL	;keep going
   1493  08d4							;
   1494  08d4		       18	   tstPositive clc
   1495  08d5		       65 75		      adc	ILPC
   1496  08d7		       85 75		      sta	ILPC
   1497  08d9		       a5 76		      lda	ILPC+1
   1498  08db		       69 00		      adc	#0
   1499  08dd		       85 76		      sta	ILPC+1
   1500  08df		       4c eb 02 	      jmp	NextIL
   1501  08e2
   1502  08e2							;
   1503  08e2							;====================================================
   1504  08e2							;Test for IRQ pending
   1505  08e2							;
   1506  08e2		       20 61 0a    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1507  08e5		       85 7c		      sta	offset
   1508  08e7		       ad aa 02 	      lda	IRQPending
   1509  08ea		       f0 d6		      beq	tstBranch
   1510  08ec		       c9 01		      cmp	#1	; only do this if set to first time
   1511  08ee		       d0 d2		      bne	tstBranch
   1512  08f0		       78		      sei		; disable the interupt until ireturn resets it
   1513  08f1		       ee aa 02    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1514  08f4		       20 7d 0c 	      jsr	pushLN	; Push the next line to be executed
   1515  08f7		       b0 11		      bcs	irqErra	; Check if there was an error
   1516  08f9		       ad ab 02 	      lda	IRQEntry	; Get the line number to branch to
   1517  08fc		       85 7e		      sta	CURPTR	; put line number into r0
   1518  08fe		       ad ac 02 	      lda	IRQEntry+1
   1519  0901		       85 7f		      sta	CURPTR+1
   1520  0903		       a9 03		      lda	#3
   1521  0905		       85 80		      sta	CUROFF
   1522  0907		       4c eb 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1523  090a		       a2 0c	   irqErra    ldx	#12	; Flag any error in line number
   1524  090c		       a9 00		      lda	#0	; stop the execution
   1525  090e		       4c 2e 05 	      jmp	iErr2
   1526  0911							;
   1527  0911							;=====================================================
   1528  0911							; This places the number of free bytes on top of the
   1529  0911							; stack.
   1530  0911							;
   1531  0911		       20 cb 0d    iFREE      jsr	GetSizes
   1532  0914		       20 6a 0c 	      jsr	pushR0
   1533  0917		       4c eb 02 	      jmp	NextIL
   1534  091a							;
   1535  091a							;=====================================================
   1536  091a							; Generate a random number from 0-FFFF and then MOD
   1537  091a							; it with the value on top of stack.  Leaves number on
   1538  091a							; stack
   1539  091a							;
   1540  091a		       20 eb 0c    iRANDOM    jsr	popR1	;mod value
   1541  091d							;
   1542  091d							; If the value is zero, just return a one.
   1543  091d							;
   1544  091d		       a5 85		      lda	R1
   1545  091f		       05 86		      ora	R1+1
   1546  0921		       f0 63		      beq	irandom1
   1547  0923							;
   1548  0923		       ad 29 13 	      lda	random+1
   1549  0926		       8d 27 13 	      sta	rtemp1
   1550  0929		       ad 28 13 	      lda	random
   1551  092c		       0a		      asl
   1552  092d		       2e 27 13 	      rol	rtemp1
   1553  0930		       0a		      asl
   1554  0931		       2e 27 13 	      rol	rtemp1
   1555  0934		       18		      clc
   1556  0935		       6d 28 13 	      adc	random
   1557  0938		       48		      pha
   1558  0939		       ad 27 13 	      lda	rtemp1
   1559  093c		       6d 29 13 	      adc	random+1
   1560  093f		       8d 29 13 	      sta	random+1
   1561  0942		       68		      pla
   1562  0943		       69 11		      adc	#$11
   1563  0945		       8d 28 13 	      sta	random
   1564  0948		       ad 29 13 	      lda	random+1
   1565  094b		       69 36		      adc	#$36
   1566  094d		       8d 29 13 	      sta	random+1
   1567  0950
   1568  0950		       ad 28 13 	      lda	random
   1569  0953		       85 83		      sta	R0
   1570  0955		       ad 29 13 	      lda	random+1
   1571  0958		       29 7f		      and	#$7f	;make positive
   1572  095a		       85 84		      sta	R0+1
   1573  095c							;
   1574  095c							; R0 contains the number and R1 contains the max value.
   1575  095c							;
   1576  095c		       a5 83	   iRANDOM_2  lda	R0
   1577  095e		       c5 85		      cmp	R1
   1578  0960		       d0 16		      bne	iRANDOM_1
   1579  0962		       a5 84		      lda	R0+1
   1580  0964		       c5 86		      cmp	R1+1
   1581  0966		       d0 10		      bne	iRANDOM_1	;need to subtract
   1582  0968							;
   1583  0968							; Subtract R1 from R0
   1584  0968							;
   1585  0968		       38	   iRANDOM_sub sec
   1586  0969		       a5 83		      lda	R0
   1587  096b		       e5 85		      sbc	R1
   1588  096d		       85 83		      sta	R0
   1589  096f		       a5 84		      lda	R0+1
   1590  0971		       e5 86		      sbc	R1+1
   1591  0973		       85 84		      sta	R0+1
   1592  0975		       4c 5c 09 	      jmp	iRANDOM_2
   1593  0978							;
   1594  0978							; See if R1 > R0.  If so, branch to subtract.
   1595  0978							;
   1596  0978		       a5 83	   iRANDOM_1  lda	R0
   1597  097a		       c5 85		      cmp	R1
   1598  097c		       a5 84		      lda	R0+1
   1599  097e		       e5 86		      sbc	R1+1
   1600  0980		       50 02		      bvc	iRANDOM_4
   1601  0982		       49 80		      eor	#$80
   1602  0984		       10 e2	   iRANDOM_4  bpl	iRANDOM_sub
   1603  0986							;
   1604  0986							; All done.  Almost.  Add one, then push the result.
   1605  0986							;
   1606  0986		       e6 83	   irandom1   inc	R0
   1607  0988		       d0 02		      bne	iRANDOM_3
   1608  098a		       e6 84		      inc	R0+1
   1609  098c				   iRANDOM_3
   1610  098c		       20 6a 0c 	      jsr	pushR0	;return value
   1611  098f		       4c eb 02 	      jmp	NextIL
   1612  0992							;
   1613  0992							; Poke a value into a memory location
   1614  0992		       8c 2c 13    iPOKEMEMORY sty	tempy
   1615  0995		       20 b4 0c 	      jsr	popR0
   1616  0998		       20 eb 0c 	      jsr	popR1
   1617  099b		       a0 00		      ldy	#0
   1618  099d		       a5 83		      lda	R0
   1619  099f		       91 85		      sta	(R1),y
   1620  09a1		       ac 2c 13 	      ldy	tempy
   1621  09a4		       4c eb 02 	      jmp	NextIL
   1622  09a7							;
   1623  09a7							; Get a value from a memory location
   1624  09a7							;
   1625  09a7		       8c 2c 13    iPEEKMEMORY sty	tempy
   1626  09aa		       20 b4 0c 	      jsr	popR0
   1627  09ad		       a0 00		      ldy	#0
   1628  09af		       b1 83		      lda	(R0),y
   1629  09b1		       ac 2c 13 	      ldy	tempy
   1630  09b4		       85 83		      sta	R0
   1631  09b6		       a9 00		      lda	#0
   1632  09b8		       85 84		      sta	R0+1
   1633  09ba		       20 6a 0c 	      jsr	pushR0
   1634  09bd		       4c eb 02 	      jmp	NextIL
   1635  09c0							;
   1636  09c0							; Call to address return what ever is in a to the stack
   1637  09c0							; func2 will load a value into a before the call
   1638  09c0		       20 eb 0c    iCallFunc  jsr	popR1
   1639  09c3		       a5 85		      lda	R1
   1640  09c5		       20 d4 09 	      jsr	iCallRtn
   1641  09c8		       85 83		      sta	R0
   1642  09ca		       a9 00		      lda	#0
   1643  09cc		       85 84		      sta	R0+1
   1644  09ce		       20 6a 0c 	      jsr	pushR0
   1645  09d1		       4c eb 02 	      jmp	NextIL
   1646  09d4				   iCallRtn
   1647  09d4		       20 b4 0c 	      jsr	popR0
   1648  09d7		       6c 83 00 	      jmp	(R0)
   1649  09da
   1650  09da
   1651  09da							;===========================================jlit======
   1652  09da							;Get a character from the terminal convert to value
   1653  09da							;leave the number on top f the stack
   1654  09da							;
   1655  09da				   iGETCHAR
   1656  09da		       a5 80		      lda	CUROFF	;save state before GetLine
   1657  09dc		       48		      pha
   1658  09dd		       a5 7f		      lda	CURPTR+1
   1659  09df		       48		      pha
   1660  09e0		       a5 7e		      lda	CURPTR
   1661  09e2		       48		      pha
   1662  09e3							;
   1663  09e3		       20 09 02 	      jsr	GETCH
   1664  09e6					      if	CTMON65
   1665  09e6		       48		      pha
   1666  09e7		       20 0c f0 	      jsr	cout	;echo echo echo
   1667  09ea		       68		      pla
   1668  09eb					      endif
   1669  09eb		       85 83		      sta	R0
   1670  09ed		       a9 00		      lda	#0
   1671  09ef		       85 84		      sta	R0+1
   1672  09f1		       20 6a 0c 	      jsr	pushR0
   1673  09f4							;
   1674  09f4		       68		      pla
   1675  09f5		       85 7e		      sta	CURPTR
   1676  09f7		       68		      pla
   1677  09f8		       85 7f		      sta	CURPTR+1
   1678  09fa		       68		      pla
   1679  09fb		       85 80		      sta	CUROFF
   1680  09fd
   1681  09fd		       4c eb 02 	      jmp	NextIL
   1682  0a00							;===========================================jlit======
   1683  0a00							;Put a character to the terminal convert to
   1684  0a00							;
   1685  0a00		       20 b4 0c    iPUTCHAR   jsr	popR0
   1686  0a03		       a5 83		      lda	R0
   1687  0a05		       20 06 02 	      jsr	OUTCH
   1688  0a08		       4c eb 02 	      jmp	NextIL
   1689  0a0b							;
   1690  0a0b							;
   1691  0a0b							;=====================================================
   1692  0a0b							; Replace TOS with its absolute value.
   1693  0a0b							;
   1694  0a0b		       20 b4 0c    iABS       jsr	popR0
   1695  0a0e		       a5 84		      lda	R0+1
   1696  0a10		       10 10		      bpl	iABS_1	;already positive
   1697  0a12		       49 ff		      eor	#$ff
   1698  0a14		       85 84		      sta	R0+1
   1699  0a16		       a5 83		      lda	R0
   1700  0a18		       49 ff		      eor	#$ff
   1701  0a1a		       85 83		      sta	R0
   1702  0a1c		       e6 83		      inc	R0
   1703  0a1e		       d0 02		      bne	iABS_1
   1704  0a20		       e6 84		      inc	R0+1
   1705  0a22		       20 6a 0c    iABS_1     jsr	pushR0
   1706  0a25		       4c eb 02 	      jmp	NextIL
   1707  0a28							;
   1708  0a28							;================================================================
   1709  0a28							;Set the IRQ service rtn line number
   1710  0a28							;
   1711  0a28		       78	   iSetIrq    sei		; disable the interupts
   1712  0a29		       a9 00		      lda	#0	; Zero the Status flag
   1713  0a2b		       8d a9 02 	      sta	IRQStatus
   1714  0a2e		       20 b4 0c 	      jsr	popR0	; get the line number
   1715  0a31		       a5 83		      lda	R0
   1716  0a33		       05 84		      ora	R0+1
   1717  0a35		       f0 23		      beq	iSetExt	; if it is zero disable all
   1718  0a37		       a5 80		      lda	CUROFF
   1719  0a39		       8d a8 02 	      sta	SaveIrqReg	; save the offset
   1720  0a3c		       20 7d 0c 	      jsr	pushLN	; Save the current line pointer
   1721  0a3f		       20 a4 0a 	      jsr	findLine	; Find the IRQ func Line Pointer
   1722  0a42		       a5 7f		      lda	CURPTR+1	; Copy it to the Entry pointer
   1723  0a44		       8d ac 02 	      sta	IRQEntry+1
   1724  0a47		       a5 7e		      lda	CURPTR
   1725  0a49		       8d ab 02 	      sta	IRQEntry
   1726  0a4c		       a9 01		      lda	#1	; Indicate there is an irq gosub
   1727  0a4e		       8d a9 02 	      sta	IRQStatus
   1728  0a51		       20 c7 0c 	      jsr	popLN	; Restore the old line number
   1729  0a54		       ad a8 02 	      lda	SaveIrqReg
   1730  0a57		       85 80		      sta	CUROFF	; restore the offset
   1731  0a59		       58		      cli		; Enable the interupts
   1732  0a5a		       4c eb 02    iSetExt    jmp	NextIL
   1733  0a5d
   1734  0a5d							;================================================================
   1735  0a5d							;
------- FILE support.asm LEVEL 2 PASS 4
      0  0a5d					      include	"support.asm"
      1  0a5d							;
      2  0a5d							;=====================================================
      3  0a5d							;=====================================================
      4  0a5d							;=====================================================
      5  0a5d							; This marks the start of support functions used by
      6  0a5d							; the IL opcodes.  These are support functions, NOT
      7  0a5d							; the IL code.
      8  0a5d							;=====================================================
      9  0a5d		       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting
     10  0a5d							;=====================================================
     11  0a5d					      Seg	Code
     12  0a5d							;=====================================================
     13  0a5d							; This gets the next two bytes pointed to by ILPC and
     14  0a5d							; returns them; X contains LSB, A contains MSB.  ILPC
     15  0a5d							; is advanced by two, and Y contains 0 on return.
     16  0a5d
     17  0a5d							;
     18  0a5d		       20 61 0a    getILWord  jsr	getILByte	;LSB
     19  0a60		       aa		      tax
     20  0a61							;
     21  0a61							;=====================================================
     22  0a61							; This gets the next byte pointed to by ILPC and
     23  0a61							; returns it in A.  On return, X is unchanged but Y
     24  0a61							; contains 0.
     25  0a61							;
     26  0a61		       a0 00	   getILByte  ldy	#0
     27  0a63		       b1 75		      lda	(ILPC),y	;get byte
     28  0a65		       08		      php		;save status
     29  0a66		       e6 75		      inc	ILPC	;inc LSB
     30  0a68		       d0 02		      bne	getILb2	;branch if no overflow
     31  0a6a		       e6 76		      inc	ILPC+1	;inc MSB
     32  0a6c		       28	   getILb2    plp		;restore status
     33  0a6d		       60		      rts
     34  0a6e							;
     35  0a6e							;=====================================================
     36  0a6e							; Decrement ILPC by one.
     37  0a6e							;
     38  0a6e		       a5 75	   decIL      lda	ILPC
     39  0a70		       d0 02		      bne	decIL2
     40  0a72		       c6 76		      dec	ILPC+1
     41  0a74		       c6 75	   decIL2     dec	ILPC
     42  0a76		       60		      rts
     43  0a77							;
     44  0a77							;=====================================================
     45  0a77							; Push the ILPC onto the return stack.  Actually, this
     46  0a77							; pushes the address of ILPC+2 since that's the next
     47  0a77							; address to execute.
     48  0a77							;
     49  0a77		       ac 98 12    pushILPC   ldy	retStackPtr
     50  0a7a		       a5 75		      lda	ILPC
     51  0a7c		       18		      clc
     52  0a7d		       69 02		      adc	#2
     53  0a7f		       99 70 12 	      sta	retStack,y
     54  0a82		       08		      php		;save C bit
     55  0a83		       c8		      iny
     56  0a84		       a5 76		      lda	ILPC+1
     57  0a86		       28		      plp		;restore C
     58  0a87		       69 00		      adc	#0
     59  0a89		       99 70 12 	      sta	retStack,y
     60  0a8c		       c8		      iny
     61  0a8d		       8c 98 12 	      sty	retStackPtr
     62  0a90		       60		      rts
     63  0a91							;
     64  0a91							;=====================================================
     65  0a91							; Pull the top entry from return stack and put into
     66  0a91							; ILPC.
     67  0a91							;
     68  0a91		       ac 98 12    popILPC    ldy	retStackPtr
     69  0a94		       88		      dey
     70  0a95		       b9 70 12 	      lda	retStack,y
     71  0a98		       85 76		      sta	ILPC+1
     72  0a9a		       88		      dey
     73  0a9b		       b9 70 12 	      lda	retStack,y
     74  0a9e		       85 75		      sta	ILPC
     75  0aa0		       8c 98 12 	      sty	retStackPtr
     76  0aa3		       60		      rts
     77  0aa4							;
     78  0aa4							;=====================================================
     79  0aa4							; This searches for a specific line number that is in
     80  0aa4							; R0.	There are three possible return conditions:
     81  0aa4							; Line numbers are now the third byte, the first byte is now **************
     82  0aa4							; a pointer to the next line, of course no longer that 53 byte
     83  0aa4							; per line.
     84  0aa4							;
     85  0aa4							; Exact match was found:
     86  0aa4							;    * Z set
     87  0aa4							;    * CURPTR points to two-byte line number for that
     88  0aa4							;	line.
     89  0aa4							;
     90  0aa4							; Next highest line found:
     91  0aa4							;    * Z cleared
     92  0aa4							;    * C set
     93  0aa4							;    * CURPTR points to two-byte line number for that
     94  0aa4							;	line.
     95  0aa4							;
     96  0aa4							; End of program reached:
     97  0aa4							;    * Z cleared
     98  0aa4							;    * C cleared
     99  0aa4							;    * CURPTR points to first free byte at end of
    100  0aa4							;	program.  Ie, it has save value as PROGRAMEND.
    101  0aa4							;
    102  0aa4							; A, X, and Y are all undefined on return.
    103  0aa4							;
    104  0aa4
    105  0aa4		       a9 35	   findLine   lda	#ProgramStart&$ff	;Start of program -> CURPTR
    106  0aa6		       85 7e		      sta	CURPTR
    107  0aa8		       a9 13		      lda	#ProgramStart>>8
    108  0aaa		       85 7f		      sta	CURPTR+1
    109  0aac							;
    110  0aac							; At end of code?
    111  0aac							;
    112  0aac		       a5 7e	   iXFER1     lda	CURPTR	; chk CURPTR = END PROGRAM
    113  0aae		       cd 2d 13 	      cmp	PROGRAMEND
    114  0ab1		       d0 0b		      bne	xfer2	;not end
    115  0ab3		       a5 7f		      lda	CURPTR+1
    116  0ab5		       cd 2e 13 	      cmp	PROGRAMEND+1
    117  0ab8		       d0 04		      bne	xfer2	;Not at end
    118  0aba							;
    119  0aba							; Line not found and the end of the program was
    120  0aba							; reached.  Return Z and C both clear.
    121  0aba							;
    122  0aba		       a9 01		      lda	#1	;clear Z
    123  0abc		       18		      clc		;clear C
    124  0abd		       60		      rts
    125  0abe							;
    126  0abe							; Check for an exact line number match
    127  0abe							;
    128  0abe		       a5 83	   xfer2      lda	R0
    129  0ac0		       a0 01		      ldy	#1	; changed to skip extra length byte
    130  0ac2		       d1 7e		      cmp	(CURPTR),y
    131  0ac4		       d0 08		      bne	xfernotit
    132  0ac6		       c8		      iny
    133  0ac7		       a5 84		      lda	R0+1
    134  0ac9		       d1 7e		      cmp	(CURPTR),y
    135  0acb		       d0 01		      bne	xfernotit	; not a matching line number
    136  0acd							;
    137  0acd							; This is exactly the line we want.
    138  0acd							;
    139  0acd		       60		      rts		;it matches exactly
    140  0ace							;
    141  0ace							; See if this line is greater than the one we're
    142  0ace							; searching for.
    143  0ace							;
    144  0ace		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    145  0ad0		       b1 7e		      lda	(CURPTR),y	;compare MSB first
    146  0ad2		       c5 84		      cmp	R0+1
    147  0ad4		       90 0b		      bcc	xfer3
    148  0ad6		       d0 07		      bne	xfer4
    149  0ad8		       88		      dey
    150  0ad9		       b1 7e		      lda	(CURPTR),y	;compare LSB
    151  0adb		       c5 83		      cmp	R0
    152  0add		       90 02		      bcc	xfer3
    153  0adf							;
    154  0adf							; This line is greater than the one we want, so
    155  0adf							; return Z clear and C set.
    156  0adf							;
    157  0adf		       38	   xfer4      sec		;We found a line number greater
    158  0ae0		       60		      rts		;both conditions set
    159  0ae1							;
    160  0ae1							; Not the line (or droid) we're looking for.  Move to
    161  0ae1							; the next line.
    162  0ae1							;
    163  0ae1		       20 e7 0a    xfer3      jsr	FindNextLine
    164  0ae4		       4c ac 0a 	      jmp	iXFER1
    165  0ae7							;
    166  0ae7							;=====================================================
    167  0ae7							; This advances CURPTR to the next line.  If there
    168  0ae7							; are no more lines, this leaves CURPTR equal to
    169  0ae7							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    170  0ae7							; CURPTR is pointing to a valid line on entry.  This
    171  0ae7							; pointer points to the two-byte line number.
    172  0ae7							; Update this points to the 1 byte line length  ****************
    173  0ae7							;
    174  0ae7				   FindNextLine
    175  0ae7		       a0 03		      ldy	#3	;skip line number and length byte
    176  0ae9		       84 80		      sty	CUROFF	;this is the new offset
    177  0aeb		       a0 00		      ldy	#0
    178  0aed		       b1 7e		      lda	(CURPTR),y	;Get the length
    179  0aef		       18		      clc
    180  0af0		       65 7e		      adc	CURPTR
    181  0af2		       85 7e		      sta	CURPTR
    182  0af4		       90 02		      bcc	FindNext4	;exit
    183  0af6		       e6 7f		      inc	CURPTR+1
    184  0af8		       60	   FindNext4  rts
    185  0af9							;
    186  0af9							;=====================================================
    187  0af9							; This compares CURPTR to PROGRAMEND and returns Z set
    188  0af9							; if they are equal, Z clear if not.
    189  0af9							;
    190  0af9		       a5 7e	   AtEnd      lda	CURPTR
    191  0afb		       cd 2d 13 	      cmp	PROGRAMEND
    192  0afe		       d0 05		      bne	atendexit
    193  0b00		       a5 7f		      lda	CURPTR+1
    194  0b02		       cd 2e 13 	      cmp	PROGRAMEND+1
    195  0b05		       60	   atendexit  rts
    196  0b06							;
    197  0b06							;=====================================================
    198  0b06							; Print the contents of R0 as a signed decimal number.
    199  0b06							; Does leading zero suppression.
    200  0b06							;
    201  0b06				   PrintDecimal
    202  0b06		       a5 84		      lda	R0+1	;MSB has sign
    203  0b08		       10 17		      bpl	pplus	;it's a positive number
    204  0b0a							;
    205  0b0a							; Negative numbers need more work.  Invert all the bits,
    206  0b0a							; then add one.
    207  0b0a							;
    208  0b0a		       a9 2d		      lda	#'-
    209  0b0c		       20 09 0e 	      jsr	VOUTCH	;print the negative sign
    210  0b0f							;
    211  0b0f		       a5 83		      lda	R0	;invert bits
    212  0b11		       49 ff		      eor	#$ff
    213  0b13		       85 83		      sta	R0
    214  0b15		       a5 84		      lda	R0+1
    215  0b17		       49 ff		      eor	#$ff
    216  0b19		       85 84		      sta	R0+1
    217  0b1b		       e6 83		      inc	R0	;add one
    218  0b1d		       d0 02		      bne	pplus
    219  0b1f		       e6 84		      inc	R0+1
    220  0b21							;
    221  0b21							; Print the value in R0 as a positive number.
    222  0b21							;
    223  0b21		       a2 00	   pplus      ldx	#0	;start of subtraction table
    224  0b23		       8e 20 13 	      stx	diddigit	;no digits yet
    225  0b26		       a0 00	   pploop     ldy	#0	;result of division
    226  0b28		       a5 83	   pploop2    lda	R0	;LSB
    227  0b2a		       38		      sec
    228  0b2b		       fd 6a 0b 	      sbc	dectable,x
    229  0b2e		       85 83		      sta	R0
    230  0b30		       a5 84		      lda	R0+1
    231  0b32		       fd 6b 0b 	      sbc	dectable+1,x
    232  0b35		       10 2e		      bpl	pplusok	;no underflow
    233  0b37							;
    234  0b37							; Else, underflow.  Add back in the LSB of the
    235  0b37							; table to R0.
    236  0b37							;
    237  0b37		       18		      clc
    238  0b38		       a5 83		      lda	R0
    239  0b3a		       7d 6a 0b 	      adc	dectable,x
    240  0b3d		       85 83		      sta	R0
    241  0b3f							;
    242  0b3f							; Print the value in Y.  Actually, see if Y is zero and
    243  0b3f							; whether any digit has been printed yet.  If Y isn't
    244  0b3f							; zero or we've printed a digit, go ahead and print.
    245  0b3f							;
    246  0b3f		       8e 1f 13 	      stx	printtx
    247  0b42		       98		      tya
    248  0b43		       09 00		      ora	#0	;set flags
    249  0b45		       d0 05		      bne	pprintit	;non-zero, print
    250  0b47							;
    251  0b47		       ad 20 13 	      lda	diddigit
    252  0b4a		       f0 09		      beq	pprintno	;don't print
    253  0b4c							;
    254  0b4c		       98	   pprintit   tya
    255  0b4d		       09 30		      ora	#'0
    256  0b4f		       8d 20 13 	      sta	diddigit
    257  0b52		       20 09 0e 	      jsr	VOUTCH
    258  0b55		       ae 1f 13    pprintno   ldx	printtx
    259  0b58							;
    260  0b58							; Move to the next table entry
    261  0b58							;
    262  0b58		       e8		      inx
    263  0b59		       e8		      inx
    264  0b5a		       e0 08		      cpx	#dectableend-dectable
    265  0b5c		       d0 c8		      bne	pploop	;not at end
    266  0b5e							;
    267  0b5e							; At the end.	R0 contains the final value
    268  0b5e							; to print.
    269  0b5e							;
    270  0b5e		       a5 83		      lda	R0
    271  0b60		       09 30		      ora	#'0
    272  0b62		       4c 09 0e 	      jmp	VOUTCH
    273  0b65							;
    274  0b65							; Finish doing the subtraction.
    275  0b65							;
    276  0b65		       85 84	   pplusok    sta	R0+1
    277  0b67		       c8		      iny
    278  0b68		       d0 be		      bne	pploop2
    279  0b6a							;
    280  0b6a							; Table of powers-of-ten
    281  0b6a							;
      0  0b6a				   dectable   dw	10000
      1  0b6a		       10 27		      .word.w	10000
      0  0b6c					      dw	1000
      1  0b6c		       e8 03		      .word.w	1000
      0  0b6e					      dw	100
      1  0b6e		       64 00		      .word.w	100
      0  0b70					      dw	10
      1  0b70		       0a 00		      .word.w	10
    286  0b70		       0b 72	   dectableend equ	*
    287  0b72							;
    288  0b72							;=====================================================
    289  0b72							; Convert an ASCII string to a number.  On input,
    290  0b72							; (CURPTR),Y points to the first digit.  This gets
    291  0b72							; digit-by-digit until finding a non-number.  Returns
    292  0b72							; Y pointing to the non-digit, and R0 contains the
    293  0b72							; number.  This does NOT check for valid ranges, so
    294  0b72							; a value like "123456789" will produce something,
    295  0b72							; but not what you had expected.
    296  0b72							;
    297  0b72		       a9 00	   getDecimal lda	#0
    298  0b74		       85 83		      sta	R0
    299  0b76		       85 84		      sta	R0+1
    300  0b78		       85 77		      sta	dpl	;temporary negative flag
    301  0b7a							;
    302  0b7a							; See if it's negative...
    303  0b7a							;
    304  0b7a		       84 13		      sty	$0013
    305  0b7c		       b1 7e		      lda	(CURPTR),y
    306  0b7e		       c9 2d		      cmp	#'-
    307  0b80		       d0 02		      bne	getDecLoop
    308  0b82		       e6 77		      inc	dpl	;it's negative
    309  0b84							;
    310  0b84		       b1 7e	   getDecLoop lda	(CURPTR),y
    311  0b86		       c9 30		      cmp	#'0
    312  0b88		       90 36		      bcc	getDdone
    313  0b8a		       c9 3a		      cmp	#'9+1
    314  0b8c		       b0 32		      bcs	getDdone
    315  0b8e		       38		      sec
    316  0b8f		       e9 30		      sbc	#'0	;convert to binary
    317  0b91		       48		      pha
    318  0b92							;
    319  0b92							; Now multiply R0 by 10.  Remember that
    320  0b92							; 2*N + 8*N = 10*N.
    321  0b92							;
    322  0b92		       06 83		      asl	R0
    323  0b94		       26 84		      rol	R0+1	;*2
    324  0b96		       a5 83		      lda	R0
    325  0b98		       85 85		      sta	R1
    326  0b9a		       a5 84		      lda	R0+1
    327  0b9c		       85 86		      sta	R1+1
    328  0b9e		       06 83		      asl	R0
    329  0ba0		       26 84		      rol	R0+1	;*4
    330  0ba2		       06 83		      asl	R0
    331  0ba4		       26 84		      rol	R0+1	;*8
    332  0ba6		       18		      clc		;now add the partial sums...
    333  0ba7		       a5 83		      lda	R0	;...to get *10
    334  0ba9		       65 85		      adc	R1
    335  0bab		       85 83		      sta	R0
    336  0bad		       a5 84		      lda	R0+1
    337  0baf		       65 86		      adc	R1+1
    338  0bb1		       85 84		      sta	R0+1
    339  0bb3							;
    340  0bb3							; Add in the new digit
    341  0bb3							;
    342  0bb3		       68		      pla
    343  0bb4		       18		      clc
    344  0bb5		       65 83		      adc	R0
    345  0bb7		       85 83		      sta	R0
    346  0bb9		       90 02		      bcc	getD2
    347  0bbb		       e6 84		      inc	R0+1
    348  0bbd							;
    349  0bbd							; Move to next character
    350  0bbd							;
    351  0bbd		       c8	   getD2      iny
    352  0bbe		       d0 c4		      bne	getDecLoop
    353  0bc0							;
    354  0bc0							; All done with digits, so now deal with it being
    355  0bc0							; negative.  If zero, then don't check for negative
    356  0bc0							; flag.  Ie, -0 is stored as 0.
    357  0bc0							;
    358  0bc0		       a5 83	   getDdone   lda	R0
    359  0bc2		       05 84		      ora	R0+1
    360  0bc4		       f0 16		      beq	getDone2	;zero
    361  0bc6		       a5 77		      lda	dpl
    362  0bc8		       f0 12		      beq	getDone2	;positive
    363  0bca							;
    364  0bca							; Invert all the bits, then add one.
    365  0bca							;
    366  0bca		       a5 83		      lda	R0
    367  0bcc		       49 ff		      eor	#$ff
    368  0bce		       85 83		      sta	R0
    369  0bd0		       a5 84		      lda	R0+1
    370  0bd2		       49 ff		      eor	#$ff
    371  0bd4		       85 84		      sta	R0+1
    372  0bd6							;
    373  0bd6		       e6 83		      inc	R0
    374  0bd8		       d0 02		      bne	getDone2
    375  0bda		       e6 84		      inc	R0+1
    376  0bdc				   getDone2
    377  0bdc		       a5 83		      lda	R0
    378  0bde		       85 10		      sta	$0010
    379  0be0		       a5 84		      lda	R0+1
    380  0be2		       85 11		      sta	$0011
    381  0be4		       a5 77		      lda	dpl
    382  0be6		       85 12		      sta	$012
    383  0be8
    384  0be8		       60		      rts
    385  0be9							;
    386  0be9							;=====================================================
    387  0be9							; Print the string that immediately follows the JSR to
    388  0be9							; this function.  Stops when a null byte is found,
    389  0be9							; then returns to the instruction immediately
    390  0be9							; following the null.
    391  0be9							;
    392  0be9							; Thanks to Ross Archer for this code.
    393  0be9							; http://www.6502.org/source/io/primm.htm
    394  0be9							;
    395  0be9				  -	      if	KIM
    396  0be9				  -puts       sty	putsy
    397  0be9				  -	      pla		;low part of "return" address
    398  0be9				  -			;(data start address)
    399  0be9				  -	      sta	dpl
    400  0be9				  -	      pla
    401  0be9				  -	      sta	dpl+1	;high part of "return" address
    402  0be9				  -			;(data start address)
    403  0be9				  -			;Note: we're pointing one short
    404  0be9				  -psinb      ldy	#1
    405  0be9				  -	      lda	(dpl),y	;Get next string character
    406  0be9				  -	      inc	dpl	;update the pointer
    407  0be9				  -	      bne	psinc	;if not, we're pntng to next char
    408  0be9				  -	      inc	dpl+1	;account for page crossing
    409  0be9				  -psinc      ora	#0	;Set flags according to contents of
    410  0be9				  -			;   Accumulator
    411  0be9				  -	      beq	psix1	;don't print the final NULL
    412  0be9				  -	      jsr	OUTCH	;write it out
    413  0be9				  -	      jmp	psinb	;back around
    414  0be9				  -psix1      inc	dpl
    415  0be9				  -	      bne	psix2
    416  0be9				  -	      inc	dpl+1	;account for page crossing
    417  0be9				  -psix2      ldy	putsy
    418  0be9				  -	      jmp	(dpl)	;return to byte following NULL
    419  0be9					      endif
    420  0be9							;
    421  0be9							;=====================================================
    422  0be9							; Gets a line of input into LINBUF.
    423  0be9							;
    424  0be9							; On entry:
    425  0be9							;    A contains the prompt character, or 0 if none.
    426  0be9							;
    427  0be9							; On exit:
    428  0be9							;    CURPTR points to LINBUF
    429  0be9							;    LINBUF contains the line with 0 at the end.
    430  0be9							;    Y has offset to first non-space character
    431  0be9							;    CURROFF has the same as Y.
    432  0be9							;
    433  0be9		       a2 9a	   GetLine    ldx	#LINBUF&$ff
    434  0beb		       86 7e		      stx	CURPTR
    435  0bed		       a2 12		      ldx	#LINBUF>>8
    436  0bef		       86 7f		      stx	CURPTR+1
    437  0bf1							;
    438  0bf1							; Prompt
    439  0bf1							;
    440  0bf1		       48		      pha		;save for retries
    441  0bf2		       68	   GetLinePr  pla		;restore
    442  0bf3		       48		      pha		;save again
    443  0bf4		       09 00		      ora	#0	;any prompt?
    444  0bf6		       f0 08		      beq	getlinenp
    445  0bf8		       20 06 02 	      jsr	OUTCH
    446  0bfb		       a9 20		      lda	#$20
    447  0bfd		       20 06 02 	      jsr	OUTCH	;space after prompt
    448  0c00							;
    449  0c00		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    450  0c02		       8e 1e 13    getline1   stx	getlinx
    451  0c05		       20 09 02 	      jsr	GETCH
    452  0c08					      if	CTMON65
    453  0c08		       48		      pha
    454  0c09		       20 0c f0 	      jsr	cout	;echo echo echo
    455  0c0c		       68		      pla
    456  0c0d					      endif
    457  0c0d		       c9 0d		      cmp	#CR
    458  0c0f		       f0 0d		      beq	getlind	;end of line
    459  0c11		       c9 08		      cmp	#BS	;backspace?
    460  0c13		       f0 21		      beq	getlinebs
    461  0c15		       ae 1e 13 	      ldx	getlinx
    462  0c18		       9d 9a 12 	      sta	LINBUF,x
    463  0c1b		       e8		      inx
    464  0c1c		       d0 e4		      bne	getline1
    465  0c1e							;
    466  0c1e							; CR was hit
    467  0c1e							;
    468  0c1e		       a9 00	   getlind    lda	#0
    469  0c20		       ae 1e 13 	      ldx	getlinx
    470  0c23		       9d 9a 12 	      sta	LINBUF,x
    471  0c26		       85 80		      sta	CUROFF
    472  0c28							;
    473  0c28							; Output a CR/LF
    474  0c28							;
    475  0c28		       20 0c 02 	      jsr	CRLF
    476  0c2b							;
    477  0c2b							; If a blank line, prompt again.
    478  0c2b							;
    479  0c2b		       a0 00		      ldy	#0
    480  0c2d		       20 7d 0d 	      jsr	SkipSpaces
    481  0c30		       b1 7e		      lda	(CURPTR),y
    482  0c32		       f0 be		      beq	GetLinePr	;empty line
    483  0c34		       68		      pla		;get rid of prompt char
    484  0c35		       60		      rts
    485  0c36							;
    486  0c36							; Backspace was hit
    487  0c36							;
    488  0c36		       ae 1e 13    getlinebs  ldx	getlinx
    489  0c39		       f0 c7		      beq	getline1	;at start of line
    490  0c3b		       ca		      dex
    491  0c3c		       20 12 f0 	      jsr	puts
      0  0c3f					      db	27,"[K",0
      1  0c3f		       1b 5b 4b 00	      .byte.b	27,"[K",0
    493  0c43		       4c 02 0c 	      jmp	getline1
    494  0c46							;
    495  0c46							;=====================================================
    496  0c46							; Count the length of the line currently in LINBUF
    497  0c46							; starting at offset Y.  Returns the length in X.  The
    498  0c46							; starting offset in Y should point past the ASCII
    499  0c46							; line number.  Also counts the trailing NULL and two
    500  0c46							; extra bytes for where the line number will be.
    501  0c46							; Update must now include leading length byte not the null at end ****************
    502  0c46							;
    503  0c46				   getLineLength
    504  0c46		       a2 00		      ldx	#0	;size
    505  0c48		       b9 9a 12    getLineL2  lda	LINBUF,y
    506  0c4b		       f0 04		      beq	getLineL3
    507  0c4d		       c8		      iny
    508  0c4e		       e8		      inx
    509  0c4f		       d0 f7		      bne	getLineL2
    510  0c51		       e8	   getLineL3  inx		;count null at end
    511  0c52		       e8		      inx		;line number LSB
    512  0c53		       e8		      inx		;MSB
    513  0c54		       e8		      inx		;change: count new leading line length
    514  0c55		       86 7d		      stx	lineLength
    515  0c57		       60		      rts
    516  0c58							;
    517  0c58							;=====================================================
    518  0c58							; Count the length of the line pointed to by CURPTR.
    519  0c58							; This also counts the line number and the terminating
    520  0c58							; null.  Ie, this string returns 8:
    521  0c58							;
    522  0c58							; <lineLow><lineHi>Hello<null>
    523  0c58							;
    524  0c58							; Another way of looking at it: add the return value
    525  0c58							; to the CURPTR and it'll point to the next line's
    526  0c58							; line number.  Returns the value in Y.
    527  0c58							; Update to ject get the leading byte length ********************
    528  0c58							;
    529  0c58							;getCURPTRLength
    530  0c58							;		ldy	CURPTR
    531  0c58							;		ldy	#3	;change: skip line number and leading length byte
    532  0c58							;getCLineL2	lda	(CURPTR),y
    533  0c58							;		beq	getCLineL3
    534  0c58							;		iny
    535  0c58							;		bne	getCLineL2
    536  0c58							;getCLineL3	iny		;count null at end
    537  0c58							;		rts
    538  0c58							;
    539  0c58							;=====================================================
    540  0c58							; This saves ILPC.  This saves to a single save area,
    541  0c58							; so it can't be called more than once.
    542  0c58							;
    543  0c58		       a5 75	   saveIL     lda	ILPC
    544  0c5a		       85 79		      sta	tempIL
    545  0c5c		       a5 76		      lda	ILPC+1
    546  0c5e		       85 7a		      sta	tempIL+1
    547  0c60		       60		      rts
    548  0c61							;
    549  0c61							;=====================================================
    550  0c61							; This restores ILPC.
    551  0c61							;
    552  0c61		       a5 79	   restoreIL  lda	tempIL
    553  0c63		       85 75		      sta	ILPC
    554  0c65		       a5 7a		      lda	tempIL+1
    555  0c67		       85 76		      sta	ILPC+1
    556  0c69		       60		      rts
    557  0c6a							;
    558  0c6a							;=====================================================
    559  0c6a							; This pushes R0 onto the stack.
    560  0c6a							;
    561  0c6a		       ae 6f 12    pushR0     ldx	mathStackPtr
    562  0c6d		       a5 83		      lda	R0
    563  0c6f		       9d 47 12 	      sta	mathStack,x
    564  0c72		       e8		      inx
    565  0c73		       a5 84		      lda	R0+1
    566  0c75		       9d 47 12 	      sta	mathStack,x
    567  0c78		       e8		      inx
    568  0c79		       8e 6f 12 	      stx	mathStackPtr
    569  0c7c		       60		      rts
    570  0c7d
    571  0c7d							;=====================================================
    572  0c7d							; This pushes curptr basic current line onto the call stack.
    573  0c7d
    574  0c7d				   pushLN
    575  0c7d		       8c 27 13 	      sty	rtemp1
    576  0c80		       ac 99 12 	      ldy	GoSubStackPtr
    577  0c83		       98		      tya
    578  0c84		       c9 3c		      cmp	#GOSUBSTACKSIZE*3
    579  0c86		       f0 17		      beq	pusherr
    580  0c88		       a5 7e		      lda	CURPTR
    581  0c8a		       91 81		      sta	(GOSUBSTACK),y
    582  0c8c		       c8		      iny
    583  0c8d		       a5 7f		      lda	CURPTR+1
    584  0c8f		       91 81		      sta	(GOSUBSTACK),y
    585  0c91		       c8		      iny
    586  0c92		       a5 80		      lda	CUROFF
    587  0c94		       91 81		      sta	(GOSUBSTACK),y
    588  0c96		       c8		      iny
    589  0c97		       8c 99 12 	      sty	GoSubStackPtr
    590  0c9a		       ac 27 13 	      ldy	rtemp1
    591  0c9d		       18		      clc
    592  0c9e		       60		      rts
    593  0c9f
    594  0c9f				   pusherr
    595  0c9f		       38		      sec
    596  0ca0		       60		      rts
    597  0ca1							;
    598  0ca1							;=====================================================
    599  0ca1							; This pushes R1 onto the stack
    600  0ca1							;
    601  0ca1		       ae 6f 12    pushR1     ldx	mathStackPtr
    602  0ca4		       a5 85		      lda	R1
    603  0ca6		       9d 47 12 	      sta	mathStack,x
    604  0ca9		       e8		      inx
    605  0caa		       a5 86		      lda	R1+1
    606  0cac		       9d 47 12 	      sta	mathStack,x
    607  0caf		       e8		      inx
    608  0cb0		       8e 6f 12 	      stx	mathStackPtr
    609  0cb3		       60		      rts
    610  0cb4							;
    611  0cb4							;=====================================================
    612  0cb4							; This pops Top Of Stack and places it in R0.
    613  0cb4							;
    614  0cb4		       ae 6f 12    popR0      ldx	mathStackPtr
    615  0cb7		       ca		      dex
    616  0cb8		       bd 47 12 	      lda	mathStack,x
    617  0cbb		       85 84		      sta	R0+1
    618  0cbd		       ca		      dex
    619  0cbe		       bd 47 12 	      lda	mathStack,x
    620  0cc1		       85 83		      sta	R0
    621  0cc3		       8e 6f 12 	      stx	mathStackPtr
    622  0cc6		       60		      rts
    623  0cc7							;=====================================================
    624  0cc7							; This pops Top Of gosub call Stack and
    625  0cc7							; laces it in CURPTR.
    626  0cc7							;
    627  0cc7		       8c 27 13    popLN      sty	rtemp1
    628  0cca		       ac 99 12 	      ldy	GoSubStackPtr
    629  0ccd		       88		      dey
    630  0cce		       98		      tya
    631  0ccf		       c9 ff		      cmp	#$FF
    632  0cd1		       f0 16		      beq	poperr
    633  0cd3		       b1 81		      lda	(GOSUBSTACK),y
    634  0cd5		       85 80		      sta	CUROFF
    635  0cd7		       88		      dey
    636  0cd8		       b1 81		      lda	(GOSUBSTACK),y
    637  0cda		       85 7f		      sta	CURPTR+1
    638  0cdc		       88		      dey
    639  0cdd		       b1 81		      lda	(GOSUBSTACK),y
    640  0cdf		       85 7e		      sta	CURPTR
    641  0ce1		       8c 99 12 	      sty	GoSubStackPtr
    642  0ce4		       ac 27 13 	      ldy	rtemp1
    643  0ce7		       18		      clc
    644  0ce8		       60		      rts
    645  0ce9		       38	   poperr     sec
      0  0cea					      rtn
      0  0cea					      db	25
      1  0cea		       19		      .byte.b	25
    647  0ceb							;
    648  0ceb							;=====================================================
    649  0ceb							; This pops TOS and places it in R1.
    650  0ceb							;
    651  0ceb		       ae 6f 12    popR1      ldx	mathStackPtr
    652  0cee		       ca		      dex
    653  0cef		       bd 47 12 	      lda	mathStack,x
    654  0cf2		       85 86		      sta	R1+1
    655  0cf4		       ca		      dex
    656  0cf5		       bd 47 12 	      lda	mathStack,x
    657  0cf8		       85 85		      sta	R1
    658  0cfa		       8e 6f 12 	      stx	mathStackPtr
    659  0cfd		       60		      rts
    660  0cfe							;
    661  0cfe							;=====================================================
    662  0cfe							; This pops TOS and places it in MQ.
    663  0cfe							;
    664  0cfe		       ae 6f 12    popMQ      ldx	mathStackPtr
    665  0d01		       ca		      dex
    666  0d02		       bd 47 12 	      lda	mathStack,x
    667  0d05		       8d 25 13 	      sta	MQ+1
    668  0d08		       ca		      dex
    669  0d09		       bd 47 12 	      lda	mathStack,x
    670  0d0c		       8d 24 13 	      sta	MQ
    671  0d0f		       8e 6f 12 	      stx	mathStackPtr
    672  0d12		       60		      rts
    673  0d13							;
    674  0d13							;=====================================================
    675  0d13							; This assists with multiplication and division by
    676  0d13							; looking at R0 and R1 and saving a flag as to what
    677  0d13							; sign the result will be.  Math is always done on
    678  0d13							; positive numbers, so this converts negative numbers
    679  0d13							; into positives.  On exit, R0 and R1 are both
    680  0d13							; positive.  If the signs were different then 'signs'
    681  0d13							; will be non-zero.
    682  0d13							;
    683  0d13		       a9 00	   SaveSigns  lda	#0
    684  0d15		       8d 26 13 	      sta	sign	;assume positive
    685  0d18		       a5 84		      lda	R0+1	;MSB
    686  0d1a		       10 13		      bpl	SaveSigns1
    687  0d1c		       ee 26 13 	      inc	sign	;it's negative
    688  0d1f		       49 ff		      eor	#$ff	;flip bits
    689  0d21		       85 84		      sta	R0+1
    690  0d23		       a5 83		      lda	R0
    691  0d25		       49 ff		      eor	#$ff
    692  0d27		       85 83		      sta	R0
    693  0d29		       e6 83		      inc	R0
    694  0d2b		       d0 02		      bne	SaveSigns1
    695  0d2d		       e6 84		      inc	R0+1
    696  0d2f		       a5 86	   SaveSigns1 lda	R1+1
    697  0d31		       10 1a		      bpl	SaveSigns2
    698  0d33		       48		      pha
    699  0d34		       ad 26 13 	      lda	sign
    700  0d37		       49 01		      eor	#1
    701  0d39		       8d 26 13 	      sta	sign
    702  0d3c		       68		      pla
    703  0d3d		       49 ff		      eor	#$ff	;flip bits
    704  0d3f		       85 86		      sta	R1+1
    705  0d41		       a5 85		      lda	R1
    706  0d43		       49 ff		      eor	#$ff
    707  0d45		       85 85		      sta	R1
    708  0d47		       e6 85		      inc	R1
    709  0d49		       d0 02		      bne	SaveSigns2
    710  0d4b		       e6 86		      inc	R1+1
    711  0d4d		       60	   SaveSigns2 rts
    712  0d4e							;
    713  0d4e							;=====================================================
    714  0d4e							; This looks at the value of 'signs' and will convert
    715  0d4e							; both R0 and R1 to negative if set.
    716  0d4e							;
    717  0d4e				   RestoreSigns
    718  0d4e		       ad 26 13 	      lda	sign
    719  0d51		       f0 28		      beq	restoresigns2
    720  0d53							;
    721  0d53		       a5 83		      lda	R0
    722  0d55		       d0 02		      bne	restoresigns3
    723  0d57		       c6 84		      dec	R0+1
    724  0d59				   restoresigns3
    725  0d59		       c6 83		      dec	R0
    726  0d5b		       a5 83		      lda	R0
    727  0d5d		       49 ff		      eor	#$ff
    728  0d5f		       85 83		      sta	R0
    729  0d61		       a5 84		      lda	R0+1
    730  0d63		       49 ff		      eor	#$ff
    731  0d65		       85 84		      sta	R0+1
    732  0d67							;
    733  0d67		       a5 85		      lda	R1
    734  0d69		       d0 02		      bne	restoresigns4
    735  0d6b		       c6 86		      dec	R1+1
    736  0d6d				   restoresigns4
    737  0d6d		       c6 85		      dec	R1
    738  0d6f		       a5 85		      lda	R1
    739  0d71		       49 ff		      eor	#$ff
    740  0d73		       85 85		      sta	R1
    741  0d75		       a5 86		      lda	R1+1
    742  0d77		       49 ff		      eor	#$ff
    743  0d79		       85 86		      sta	R1+1
    744  0d7b							;
    745  0d7b				   restoresigns2
    746  0d7b		       60		      rts
    747  0d7c							;
    748  0d7c							;=====================================================
    749  0d7c							; Skip over spaces.  Returns Y with the offset to
    750  0d7c							; either the last character in the line, or the first
    751  0d7c							; non-space character.
    752  0d7c							;
    753  0d7c		       c8	   skipsp2    iny
    754  0d7d		       b1 7e	   SkipSpaces lda	(CURPTR),y
    755  0d7f		       f0 04		      beq	Skip3	;end of line
    756  0d81		       c9 20		      cmp	#SPACE
    757  0d83		       f0 f7		      beq	skipsp2
    758  0d85		       60	   Skip3      rts
    759  0d86							;
    760  0d86							;=====================================================
    761  0d86							; This is some debug logic which displays the current
    762  0d86							; value of the ILPC and the line buffer.
    763  0d86							;
    764  0d86		       20 12 f0    dbgLine    jsr	puts
      0  0d89					      db	"ILPC: ",0
      1  0d89		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    766  0d90		       a5 76		      lda	ILPC+1
    767  0d92		       20 0f 02 	      jsr	OUTHEX
    768  0d95		       a5 75		      lda	ILPC
    769  0d97		       20 0f 02 	      jsr	OUTHEX
    770  0d9a		       a9 20		      lda	#SPACE
    771  0d9c		       20 06 02 	      jsr	OUTCH
    772  0d9f		       a0 00		      ldy	#0
    773  0da1		       b1 75		      lda	(ILPC),y
    774  0da3		       20 0f 02 	      jsr	OUTHEX
    775  0da6							;
    776  0da6							; Display the CURPTR value and offset
    777  0da6							;
    778  0da6		       20 12 f0 	      jsr	puts
      0  0da9					      db	", CURPTR: ",0
      1  0da9		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    780  0db4		       a5 7f		      lda	CURPTR+1
    781  0db6		       20 0f 02 	      jsr	OUTHEX
    782  0db9		       a5 7e		      lda	CURPTR
    783  0dbb		       20 0f 02 	      jsr	OUTHEX
    784  0dbe		       a9 2b		      lda	#'+
    785  0dc0		       20 06 02 	      jsr	OUTCH
    786  0dc3		       a5 80		      lda	CUROFF
    787  0dc5		       20 0f 02 	      jsr	OUTHEX
    788  0dc8							;
    789  0dc8		       4c 0c 02 	      jmp	CRLF
    790  0dcb							;
    791  0dcb							;=====================================================
    792  0dcb							; This function might go away eventually, but was
    793  0dcb							; added to provide data for other pieces of code.
    794  0dcb							; It has some ties to the operating environment that
    795  0dcb							; will need to be customized for the target system.
    796  0dcb							;
    797  0dcb				   GetSizes
    798  0dcb							;
    799  0dcb							; Here is machine specific code to get the highest
    800  0dcb							; memory location that can be used by BASIC.
    801  0dcb							;
    802  0dcb					      if	ProgramStart < $2000
    803  0dcb		       a9 ff		      lda	#$ff
    804  0dcd		       8d 2f 13 	      sta	HighMem	;$13ff for KIM-1
    805  0dd0		       a9 de		      lda	#$DE	;#$13
    806  0dd2		       8d 30 13 	      sta	HighMem+1
    807  0dd5				  -	      else
    808  0dd5				  -	      lda	#$ff
    809  0dd5				  -	      sta	HighMem	;$CFFF otherwise
    810  0dd5				  -	      lda	#$cf
    811  0dd5				  -	      sta	HighMem+1
    812  0dd5					      endif
    813  0dd5							;
    814  0dd5							; This computes the available memory remaining.
    815  0dd5							;
    816  0dd5		       38		      sec
    817  0dd6		       ad 2f 13 	      lda	HighMem
    818  0dd9		       ed 2d 13 	      sbc	PROGRAMEND
    819  0ddc		       8d 33 13 	      sta	FreeMem
    820  0ddf		       85 83		      sta	R0
    821  0de1		       ad 30 13 	      lda	HighMem+1
    822  0de4		       ed 2e 13 	      sbc	PROGRAMEND+1
    823  0de7		       8d 34 13 	      sta	FreeMem+1
    824  0dea		       85 84		      sta	R0+1
    825  0dec							;
    826  0dec							; This computes the size of the current user program.
    827  0dec							;
    828  0dec		       38		      sec
    829  0ded		       ad 2d 13 	      lda	PROGRAMEND
    830  0df0		       e9 35		      sbc	#ProgramStart&$ff
    831  0df2		       8d 31 13 	      sta	UsedMem
    832  0df5		       ad 2e 13 	      lda	PROGRAMEND+1
    833  0df8		       e9 13		      sbc	#ProgramStart>>8
    834  0dfa		       8d 32 13 	      sta	UsedMem+1
    835  0dfd							;
    836  0dfd		       60		      rts
    837  0dfe							;
    838  0dfe							;=====================================================
    839  0dfe							; Set output vector to the console output function
    840  0dfe							;
    841  0dfe				   SetOutConsole
    842  0dfe		       a9 06		      lda	#OUTCH&$ff
    843  0e00		       8d 2a 13 	      sta	BOutVec
    844  0e03		       a9 02		      lda	#OUTCH/256
    845  0e05		       8d 2b 13 	      sta	BOutVec+1
    846  0e08		       60		      rts
    847  0e09							;
    848  0e09							;=====================================================
    849  0e09							; Jump to the output function in BOutVec
    850  0e09							;
    851  0e09		       6c 2a 13    VOUTCH     jmp	(BOutVec)
    852  0e0c
    853  0e0c							;====================================================
    854  0e0c		       13 27	   PrtTerm    equ	rtemp1
    855  0e0c
    856  0e0c							; Print Y has the offset to use
    857  0e0c		       a5 7e	   PrtQuoted  lda	CURPTR
    858  0e0e		       85 88		      sta	PrtFrom
    859  0e10		       a5 7f		      lda	CURPTR+1
    860  0e12		       85 89		      sta	PrtFrom+1
    861  0e14		       a9 22		      lda	#'"
    862  0e16		       8d 27 13 	      sta	PrtTerm
    863  0e19		       4c 25 0e 	      jmp	PrtLoop
    864  0e1c							; Print a string pointed to by x= h, y=l terminated by a
    865  0e1c							; Return y as the length
    866  0e1c		       86 89	   PrtStr     stx	PrtFrom+1
    867  0e1e		       84 88		      sty	PrtFrom
    868  0e20		       8d 27 13 	      sta	PrtTerm
    869  0e23		       a0 00		      ldy	#0
    870  0e25
    871  0e25		       b1 88	   PrtLoop    lda	(PrtFrom),y
    872  0e27		       cd 27 13 	      cmp	PrtTerm
    873  0e2a		       f0 0b		      beq	PrtEnd
    874  0e2c		       c9 00		      cmp	#0	; always end if 0 is found
    875  0e2e		       f0 07		      beq	PrtEnd
    876  0e30		       20 06 02 	      jsr	OUTCH
    877  0e33		       c8		      iny
    878  0e34		       4c 25 0e 	      jmp	PrtLoop
    879  0e37		       c8	   PrtEnd     iny		;return byte after the copy
    880  0e38		       60		      rts
    881  0e39
    882  0e39							;====================================================
    883  0e39							;Clear the terminal assume it is ansii or vt100
    884  0e39							;
    885  0e39				   iCLEARSCREEN
    886  0e39		       20 12 f0 	      jsr	puts
      0  0e3c					      db	$1b,'[,'3,'J,0
      1  0e3c		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
    888  0e41		       4c eb 02 	      jmp	NextIL
------- FILE mytb.asm
   1737  0e44					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 4
      0  0e44					      include	"storage.asm"
      1  0e44							;
      2  0e44							;=====================================================
      3  0e44							;=====================================================
      4  0e44							;=====================================================
      5  0e44							; This file contains the functions for saving and
      6  0e44							; restoring programs from some sort of mass storage
      7  0e44							; device.  This particular version is for using the
      8  0e44							; Corsham Tech SD Card System.
      9  0e44							;=====================================================
     10  0e44							;=====================================================
     11  0e44							;=====================================================
     12  0e44
     13 Udf8e					      seg.u	Data
     14 Udf8e		       00	   diskBufLength ds	1
     15 Udf8f		       00	   diskBufOffset ds	1
     16 Udf90		       00 00 00 00*DiskFileName ds	14
     17 Udf9e
     18  0e44					      SEG	Code
     19  0e44
     20  0e44							;
     21  0e44							;=====================================================
     22  0e44							; Open a file for reading as a program.  The next
     23  0e44							; thing on the line should be the filename.
     24  0e44							;
     25  0e44				   iOPENREAD
     26  0e44					      if	XKIM || CTMON65
     27  0e44		       a4 80		      ldy	CUROFF
     28  0e46		       b1 7e		      lda	(CURPTR),y
     29  0e48		       d0 07		      bne	iOPENfn	;might be filename
     30  0e4a							;
     31  0e4a							; No filename supplied.
     32  0e4a							;
     33  0e4a		       a9 00	   iOPENnofn  lda	#0
     34  0e4c		       a2 09		      ldx	#ERR_NO_FILENAME
     35  0e4e		       4c 2e 05 	      jmp	iErr2
     36  0e51							;
     37  0e51							; Add the offset into the buffer start
     38  0e51							;
     39  0e51		       18	   iOPENfn    clc
     40  0e52		       98		      tya
     41  0e53		       65 7e		      adc	CURPTR
     42  0e55		       a8		      tay		;LSB
     43  0e56		       a5 7f		      lda	CURPTR+1
     44  0e58		       69 00		      adc	#0
     45  0e5a		       aa		      tax
     46  0e5b		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  0e5e		       90 07		      bcc	Ropenok	;branch if opened ok
     48  0e60							;
     49  0e60							; Open failed
     50  0e60							;
     51  0e60		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  0e62		       a9 00	   Rdfail2    lda	#0
     53  0e64		       4c 2e 05 	      jmp	iErr2
     54  0e67							;
     55  0e67							; Clear counts and offsets so the next read will
     56  0e67							; cause the file to be read.
     57  0e67							;
     58  0e67		       a9 00	   Ropenok    lda	#0
     59  0e69		       8d 8f df 	      sta	diskBufOffset
     60  0e6c		       8d 8e df 	      sta	diskBufLength
     61  0e6f		       4c eb 02 	      jmp	NextIL
     62  0e72					      endif
     63  0e72
     64  0e72							;
     65  0e72							;==============================jlit 08/02/2022========
     66  0e72							;Remove a file from the disk
     67  0e72				   iRMFILE
     68  0e72					      if	XKIM || CTMON65
     69  0e72		       a4 80		      ldy	CUROFF
     70  0e74		       b1 7e		      lda	(CURPTR),y
     71  0e76		       f0 19		      beq	iRMnofn
     72  0e78							;
     73  0e78		       18		      clc
     74  0e79		       98		      tya
     75  0e7a		       65 7e		      adc	CURPTR
     76  0e7c		       a8		      tay		;LSB
     77  0e7d		       a5 7f		      lda	CURPTR+1
     78  0e7f		       69 00		      adc	#0
     79  0e81		       aa		      tax
     80  0e82		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  0e85		       90 07		      bcc	wrmOk	;branch if removed ok
     82  0e87		       a9 00		      lda	#0
     83  0e89		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  0e8b		       4c 2e 05 	      jmp	iErr2
     85  0e8e		       4c eb 02    wrmOk      jmp	NextIL
     86  0e91
     87  0e91							; No filename supplied.
     88  0e91							;
     89  0e91		       a9 00	   iRMnofn    lda	#0
     90  0e93		       a2 09		      ldx	#ERR_NO_FILENAME
     91  0e95		       4c 2e 05 	      jmp	iErr2
     92  0e98					      endif
     93  0e98							;
     94  0e98							;=====================================================
     95  0e98				   iOPENWRITE
     96  0e98					      if	XKIM || CTMON65
     97  0e98		       a4 80		      ldy	CUROFF
     98  0e9a		       b1 7e		      lda	(CURPTR),y
     99  0e9c		       f0 f3		      beq	iRMnofn
    100  0e9e							;
    101  0e9e		       18		      clc
    102  0e9f		       98		      tya
    103  0ea0		       65 7e		      adc	CURPTR
    104  0ea2		       a8		      tay		;LSB
    105  0ea3		       a5 7f		      lda	CURPTR+1
    106  0ea5		       69 00		      adc	#0
    107  0ea7		       aa		      tax
    108  0ea8		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  0eab		       90 07		      bcc	Wopenok	;branch if opened ok
    110  0ead							;
    111  0ead							; Open failed
    112  0ead							;
    113  0ead		       a9 00	   Wdfail     lda	#0
    114  0eaf		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  0eb1		       4c 2e 05 	      jmp	iErr2
    116  0eb4							;
    117  0eb4		       4c eb 02    Wopenok    jmp	NextIL
    118  0eb7					      endif
    119  0eb7							;
    120  0eb7							;=====================================================
    121  0eb7							; Gets a line of input from the disk file and puts it
    122  0eb7							; into LINBUF.
    123  0eb7							;
    124  0eb7							; On exit:
    125  0eb7							;    CURPTR points to LINBUF
    126  0eb7							;    LINBUF contains the line with 0 at the end.
    127  0eb7							;    Y has offset to first non-space character
    128  0eb7							;    CURROFF has the same as Y.
    129  0eb7							;
    130  0eb7				   iDGETLINE
    131  0eb7					      if	XKIM || CTMON65
    132  0eb7		       a2 9a		      ldx	#LINBUF&$ff
    133  0eb9		       86 7e		      stx	CURPTR
    134  0ebb		       a2 12		      ldx	#LINBUF>>8
    135  0ebd		       86 7f		      stx	CURPTR+1
    136  0ebf							;
    137  0ebf		       a2 00		      ldx	#0	;offset
    138  0ec1		       8e 1e 13    iDgetLoop  stx	getlinx
    139  0ec4		       20 22 0f 	      jsr	getNextFileByte
    140  0ec7		       b0 16		      bcs	iGetEOF
    141  0ec9		       c9 0d		      cmp	#CR
    142  0ecb		       f0 0d		      beq	iGetEOL
    143  0ecd		       c9 0a		      cmp	#LF
    144  0ecf		       f0 09		      beq	iGetEOL
    145  0ed1		       ae 1e 13 	      ldx	getlinx
    146  0ed4		       9d 9a 12 	      sta	LINBUF,x
    147  0ed7		       e8		      inx
    148  0ed8		       d0 e7		      bne	iDgetLoop
    149  0eda							;
    150  0eda							; Handle end of line.	If the line has nothing, loop
    151  0eda							; back and get another line.
    152  0eda							;
    153  0eda		       ae 1e 13    iGetEOL    ldx	getlinx	;blank line?
    154  0edd		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  0edf							;
    156  0edf							; This can fall through when there is a line, or
    157  0edf							; called directly when EOF is encountered.
    158  0edf							;
    159  0edf		       ae 1e 13    iGetEOF    ldx	getlinx
    160  0ee2		       a9 00		      lda	#0
    161  0ee4		       9d 9a 12 	      sta	LINBUF,x
    162  0ee7		       85 80		      sta	CUROFF
    163  0ee9		       a0 00		      ldy	#0
    164  0eeb		       20 7d 0d 	      jsr	SkipSpaces
    165  0eee		       4c eb 02 	      jmp	NextIL
    166  0ef1					      endif
    167  0ef1
    168  0ef1							;
    169  0ef1							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  0ef1							; DISK
    171  0ef1							;
    172  0ef1				   iDDIR
    173  0ef1					      if	XKIM || CTMON65
    174  0ef1		       20 30 f0 	      jsr	DiskDir
    175  0ef4							;
    176  0ef4							; Get/Display each entry
    177  0ef4							;
    178  0ef4		       a2 df	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  0ef6		       a0 90		      ldy	#DiskFileName&$ff
    180  0ef8		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  0efb		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  0efd		       20 12 f0 	      jsr	puts
      0  0f00					      db	"   ",0
      1  0f00		       20 20 20 00	      .byte.b	"   ",0
    184  0f04							; Print the line to the console
    185  0f04		       a2 df		      ldx	#DiskFileName/256	;pointer to buffer
    186  0f06		       a0 90		      ldy	#DiskFileName&$ff
    187  0f08		       a5 00		      lda	0
    188  0f0a		       20 1c 0e 	      jsr	PrtStr	;else print name
    189  0f0d		       20 18 f0 	      jsr	crlf
    190  0f10
    191  0f10		       4c f4 0e 	      jmp	DiskDirLoop	;do next entry
    192  0f13		       4c eb 02    DiskDirEnd jmp	NextIL
    193  0f16					      endif
    194  0f16							;
    195  0f16							;=====================================================
    196  0f16							; Does a LIST to a Disk file.
    197  0f16							;
    198  0f16				   iDLIST
    199  0f16					      if	XKIM || CTMON65
    200  0f16		       20 51 0f 	      jsr	SetOutDisk
    201  0f19		       4c 7b 06 	      jmp	iLST2
    202  0f1c					      endif
    203  0f1c							;
    204  0f1c							;=====================================================
    205  0f1c							; Closes any pending disk file.  Okay to call if there
    206  0f1c							; is no open file.
    207  0f1c							;
    208  0f1c				   iDCLOSE
    209  0f1c					      if	XKIM || CTMON65
    210  0f1c		       20 42 f0 	      jsr	DiskClose
    211  0f1f		       4c eb 02 	      jmp	NextIL
    212  0f22					      endif
    213  0f22							;
    214  0f22							;=====================================================
    215  0f22							; This gets the next byte from an open disk file.  If
    216  0f22							; there are no more bytes left, this returns C set.
    217  0f22							; Else, C is clear and A contains the character.
    218  0f22							;
    219  0f22				   getNextFileByte
    220  0f22					      if	XKIM || CTMON65
    221  0f22		       ae 8f df 	      ldx	diskBufOffset
    222  0f25		       ec 8e df 	      cpx	diskBufLength
    223  0f28		       d0 14		      bne	hasdata	;branch if still data
    224  0f2a							;
    225  0f2a							; There is no data left in the buffer, so read a
    226  0f2a							; block from the SD system.
    227  0f2a							;
    228  0f2a		       a9 84		      lda	#BUFFER_SIZE
    229  0f2c		       a2 df		      ldx	#buffer>>8
    230  0f2e		       a0 0a		      ldy	#buffer&$ff
    231  0f30		       20 3c f0 	      jsr	DiskRead
    232  0f33		       b0 12		      bcs	getNextEof
    233  0f35							;
    234  0f35							; A contains the number of bytes actually read.
    235  0f35							;
    236  0f35		       8d 8e df 	      sta	diskBufLength	;save length
    237  0f38		       c9 00		      cmp	#0	;shouldn't happen
    238  0f3a		       f0 0b		      beq	getNextEof
    239  0f3c							;
    240  0f3c		       a2 00		      ldx	#0
    241  0f3e		       bd 0a df    hasdata    lda	buffer,x
    242  0f41		       e8		      inx
    243  0f42		       8e 8f df 	      stx	diskBufOffset
    244  0f45		       18		      clc
    245  0f46		       60		      rts
    246  0f47							;
    247  0f47		       a9 00	   getNextEof lda	#0
    248  0f49		       8d 8f df 	      sta	diskBufOffset
    249  0f4c		       8d 8e df 	      sta	diskBufLength
    250  0f4f		       38		      sec
    251  0f50		       60		      rts
    252  0f51							;
    253  0f51							;=====================================================
    254  0f51							; Set output vector to the disk output function
    255  0f51							;
    256  0f51		       a9 5c	   SetOutDisk lda	#DOUT&$ff
    257  0f53		       8d 2a 13 	      sta	BOutVec
    258  0f56		       a9 0f		      lda	#DOUT/256
    259  0f58		       8d 2b 13 	      sta	BOutVec+1
    260  0f5b		       60		      rts
    261  0f5c							;
    262  0f5c							;=====================================================
    263  0f5c
    264  0f5c		       8d 0a df    DOUT       sta	buffer
    265  0f5f		       a9 01		      lda	#1
    266  0f61		       a0 0a		      ldy	#buffer&$ff
    267  0f63		       a2 df		      ldx	#buffer/256
    268  0f65		       20 3f f0 	      jsr	DiskWrite
    269  0f68							;
    270  0f68							; need error checking here
    271  0f68							;
    272  0f68		       60		      rts
    273  0f69					      endif
    274  0f69
    275  0f69
------- FILE mytb.asm
   1739  0f69					      endif
------- FILE IL.inc LEVEL 2 PASS 4
      0  0f69					      include	"IL.inc"
      1  0f69
      2  0f69							;=====================================================
      3  0f69							; IL.inc
      4  0f69							; These are macros for IL instructions
      5  0f69							;
      6  0f69					      mac	dw
      7  0f69					      .word	{0}
      8  0f69					      endm
      9  0f69					      mac	db
     10  0f69					      .byte	{0}
     11  0f69					      endm
     12  0f69					      macro	xinit
     13  0f69					      db	0
     14  0f69					      endm		;reset the il to start clear all
     15  0f69							;
     16  0f69					      macro	done
     17  0f69					      db	1
     18  0f69					      endm		;print an error if not end of line
     19  0f69							;
     20  0f69					      macro	prs
     21  0f69					      db	2
     22  0f69					      endm		;print a quoted string
     23  0f69							;
     24  0f69					      macro	prn
     25  0f69					      db	3
     26  0f69					      endm		;print a number
     27  0f69							;
     28  0f69					      macro	spc
     29  0f69					      db	4
     30  0f69					      endm		;print space til new tabstop
     31  0f69							;
     32  0f69					      macro	nline
     33  0f69					      db	5
     34  0f69					      endm		;print a new line crlf
     35  0f69							;
     36  0f69							; My NXT is a bit different in that it takes one
     37  0f69							; parameter, which is an address.  If the BASIC
     38  0f69							; program is currently running then move to the
     39  0f69							; next line and continue execution.  However, if
     40  0f69							; in direct mode, jump to the specified IL label.
     41  0f69							;
     42  0f69					      macro	nxt
     43  0f69					      db	6
     44  0f69					      dw	{1}	; addr
     45  0f69					      endm		; addr
     46  0f69							;
     47  0f69					      macro	xfer
     48  0f69					      db	7
     49  0f69					      endm
     50  0f69							;
     51  0f69					      macro	sav
     52  0f69					      db	8
     53  0f69					      endm
     54  0f69							;
     55  0f69					      macro	rstr
     56  0f69					      db	9
     57  0f69					      endm
     58  0f69							;
     59  0f69					      macro	cmpr
     60  0f69					      db	10
     61  0f69					      endm
     62  0f69							;
     63  0f69					      macro	innum
     64  0f69					      db	11
     65  0f69					      endm
     66  0f69							;
     67  0f69					      macro	fin
     68  0f69					      db	12
     69  0f69					      endm
     70  0f69							;
     71  0f69							; ERR is followed by an error number.	The error
     72  0f69							; code is printed along with the line number.
     73  0f69							; Control is passed to the statement set with
     74  0f69							; the ERRGOTO statement.
     75  0f69							;
     76  0f69					      macro	errmsg
     77  0f69					      db	13
     78  0f69					      dw	{1}	;ecode
     79  0f69					      endm		;ecode
     80  0f69							;
     81  0f69					      macro	add
     82  0f69					      db	14
     83  0f69					      endm
     84  0f69							;
     85  0f69					      macro	sub
     86  0f69					      db	15
     87  0f69					      endm
     88  0f69							;
     89  0f69					      macro	neg
     90  0f69					      db	16
     91  0f69					      endm
     92  0f69							;
     93  0f69					      macro	mul
     94  0f69					      db	17
     95  0f69					      endm
     96  0f69							;
     97  0f69					      macro	div
     98  0f69					      db	18
     99  0f69					      endm
    100  0f69							;
    101  0f69					      macro	store
    102  0f69					      db	19
    103  0f69					      endm
    104  0f69							;
    105  0f69					      macro	ind
    106  0f69					      db	20
    107  0f69					      endm
    108  0f69							;
    109  0f69					      macro	lst
    110  0f69					      db	21
    111  0f69					      endm
    112  0f69							;
    113  0f69					      macro	init
    114  0f69					      db	22
    115  0f69					      endm
    116  0f69							;
    117  0f69					      macro	getline
    118  0f69					      db	23
    119  0f69					      endm
    120  0f69							;
    121  0f69					      macro	insert
    122  0f69					      db	24
    123  0f69					      endm
    124  0f69							;
    125  0f69					      macro	rtn
    126  0f69					      db	25
    127  0f69					      endm
    128  0f69							;
    129  0f69					      macro	exit
    130  0f69					      db	26
    131  0f69					      endm
    132  0f69							;
    133  0f69					      macro	lit
    134  0f69					      db	27
    135  0f69					      dw	{1}	;value
    136  0f69					      endm		; value LIT
    137  0f69							;
    138  0f69					      macro	call
    139  0f69					      db	28
    140  0f69					      dw	{1}	;addr
    141  0f69					      endm		;addr
    142  0f69							;
    143  0f69							; IJMP will set the IL PC to the specified value.
    144  0f69							;
    145  0f69					      macro	ijmp
    146  0f69					      db	29
    147  0f69					      dw	{1}	;addr
    148  0f69					      endm		;addr
    149  0f69							;
    150  0f69					      macro	vinit
    151  0f69					      db	30
    152  0f69					      endm
    153  0f69							;
    154  0f69							; ERRGOTO sets the point in the code where the IL
    155  0f69							; interpreter will go after any error.
    156  0f69							;
    157  0f69					      macro	errgoto
    158  0f69					      db	31
    159  0f69					      dw	{1}	;addr
    160  0f69					      endm		;addr
    161  0f69							;
    162  0f69					      macro	tst
    163  0f69					      db	32
    164  0f69					      db	({1}-*)-1	;(addr-*)-1
    165  0f69					      db	{2},0	;string,0
    166  0f69					      endm		;addr,string
    167  0f69							;
    168  0f69					      macro	tstv
    169  0f69					      db	33
    170  0f69					      db	({1}-*)-1	;(addr-*)-1
    171  0f69					      endm		;addr
    172  0f69							;
    173  0f69					      macro	tstl
    174  0f69					      db	34
    175  0f69					      db	({1}-*)-1	;(addr-*)-1
    176  0f69					      endm		;addr
    177  0f69							;
    178  0f69					      macro	tstn
    179  0f69					      db	35
    180  0f69					      db	({1}-*)-1	;(addr-*)-1
    181  0f69					      endm		;addr
    182  0f69							;
    183  0f69							; FREE returns the amount of free RAM on top of
    184  0f69							; the stack.  This is the amount of room the user
    185  0f69							; program has available.
    186  0f69							;
    187  0f69					      macro	free
    188  0f69					      db	36
    189  0f69					      endm
    190  0f69							;
    191  0f69							; RANDOM takes the top item off the stack and
    192  0f69							; replaces it with a random number that is
    193  0f69							; MOD the initial value.  Ie, if the TOS is
    194  0f69							; 42 then RANDOM returns a value from 0 to 41.
    195  0f69							;
    196  0f69					      macro	random
    197  0f69					      db	37
    198  0f69					      endm
    199  0f69							;
    200  0f69							; ABS will replace the top of stack with the
    201  0f69							; absolute value.
    202  0f69							;
    203  0f69					      macro	abs
    204  0f69					      db	38
    205  0f69					      endm
    206  0f69							;
    207  0f69							; OPENREAD opens a file for reading, as in getting
    208  0f69							; statements from it.
    209  0f69							;
    210  0f69					      macro	openread
    211  0f69					      db	39
    212  0f69					      endm
    213  0f69							;
    214  0f69							; OPENWRITE opens a file for writing, as in saving
    215  0f69							; the current program to it.
    216  0f69							;
    217  0f69					      macro	openwrite
    218  0f69					      db	40
    219  0f69					      endm
    220  0f69							;
    221  0f69							; DCLOSE closes any open disk file.
    222  0f69							;
    223  0f69					      macro	dclose
    224  0f69					      db	41
    225  0f69					      endm
    226  0f69							;
    227  0f69							; DGETLINE gets one line from the disk file and puts it
    228  0f69							; into LINBUFF.
    229  0f69							;
    230  0f69					      macro	dgetline
    231  0f69					      db	42
    232  0f69					      endm
    233  0f69							;
    234  0f69							; DLIST saves the program to an open disk file.
    235  0f69							;
    236  0f69					      macro	dlist
    237  0f69					      db	43
    238  0f69					      endm
    239  0f69							; DDIR list the current directory
    240  0f69							;
    241  0f69					      macro	ddir
    242  0f69					      db	44
    243  0f69					      endm
    244  0f69
    245  0f69							; RMFILE remove a fle from disk
    246  0f69					      macro	rmfile
    247  0f69					      db	45
    248  0f69					      endm
    249  0f69
    250  0f69							; CLEARSCREEN clear the screen
    251  0f69					      macro	clearscreen
    252  0f69					      db	46
    253  0f69					      endm
    254  0f69							; POKEMEM Poke value into memory
    255  0f69					      macro	pokemem
    256  0f69					      db	47
    257  0f69					      endm
    258  0f69							; PEEKMEM peek at value in memory
    259  0f69					      macro	peekmem
    260  0f69					      db	48
    261  0f69					      endm
    262  0f69							; TSTLET Test if the statement is a let without the keyword let
    263  0f69					      macro	tstlet
    264  0f69					      db	49
    265  0f69					      db	({1}-*)-1	;(addr-*)-1
    266  0f69					      endm		;addr
    267  0f69							; TSTDONE if we reach the end of a statement
    268  0f69					      macro	tstdone
    269  0f69					      db	50
    270  0f69					      db	({1}-*)-1	;(addr-*)-1
    271  0f69					      endm		;addr
    272  0f69							; GETCHAR	get a character from the input line leave it in RO
    273  0f69					      macro	getchar
    274  0f69					      db	51
    275  0f69					      endm
    276  0f69							; PUTCHAR	Put a character to the terminal
    277  0f69					      macro	putchar
    278  0f69					      db	52
    279  0f69					      endm
    280  0f69							; Call		Call a machine function return a to stack
    281  0f69					      macro	callfunc
    282  0f69					      db	53
    283  0f69					      endm
    284  0f69
    285  0f69							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    286  0f69					      macro	ibranch
    287  0f69					      db	54
    288  0f69					      endm
    289  0f69
    290  0f69							; TSTSTR	 Tests for the open quote in a string
    291  0f69					      macro	tststr
    292  0f69					      db	55
    293  0f69					      db	({1}-*)-1	;(addr-*)-1
    294  0f69					      endm
    295  0f69							; SETIRQ	Sets the line number to run when an irq happens irq 550
    296  0f69					      macro	setirq
    297  0f69					      db	56
    298  0f69					      endm
    299  0f69
    300  0f69							; TSTIRQ	Test for irq pending,
    301  0f69							;		if so push the IRQ LINE NUMBER into RO, onto stack
    302  0f69					      macro	tstirq
    303  0f69					      db	57
    304  0f69					      db	({1}-*)-1	;(addr-*)-1
    305  0f69					      endm
    306  0f69
    307  0f69							; IRET    return from interupt service
    308  0f69					      macro	iret
    309  0f69					      db	58
    310  0f69					      endm
    311  0f69
    312  0f69							; INSTR   read a string from the input
    313  0f69					      macro	instr
    314  0f69					      db	59
    315  0f69					      endm
    316  0f69
    317  0f69							; MODULO Returns the remainder of the division
    318  0f69					      macro	modulo
    319  0f69					      db	60
    320  0f69					      endm
------- FILE mytb.asm
   1741  0f69							;
   1742  0f69				  -	      if	FIXED
   1743  0f69				  -	      org	$1000
   1744  0f69					      endif
------- FILE basic.il LEVEL 2 PASS 4
      0  0f69					      include	"basic.il"
      1  0f69							;LET
      2  0f69							;=====================================================
      3  0f69							;=====================================================
      4  0f69							;=====================================================
      5  0f69							; This is the IL of the BASIC (or whatever) language.
      6  0f69							; Because of the way macros are implemented by as65,
      7  0f69							; labels can't be on the same line as a macro
      8  0f69							; invocation, so that's why labels are on separate
      9  0f69							; lines.
     10  0f69							;
     11  0f69		       0f 69	   IL	      equ	*
     12  0f69
     13  0f69							;THE IL CONTROL SECTION
     14  0f69
     15  0f69				   START
      0  0f69					      INIT		;INITIALIZE
      0  0f69					      db	22
      1  0f69		       16		      .byte.b	22
      0  0f6a					      NLINE		;WRITE CRLF
      0  0f6a					      db	5
      1  0f6a		       05		      .byte.b	5
      0  0f6b					      ERRGOTO	CO	;where to go after an error
      0  0f6b					      db	31
      1  0f6b		       1f		      .byte.b	31
      0  0f6c					      dw	CO
      1  0f6c		       6f 0f		      .word.w	CO
      0  0f6e					      VINIT		;clear all variables
      0  0f6e					      db	30
      1  0f6e		       1e		      .byte.b	30
     20  0f6f							;
     21  0f6f							; This is where we jump to get a line of commands or
     22  0f6f							; a program from the user.
     23  0f6f							;
     24  0f6f				   CO
      0  0f6f					      GETLINE		;WRITE PROMPT AND GET LINE
      0  0f6f					      db	23
      1  0f6f		       17		      .byte.b	23
      0  0f70					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  0f70					      db	34
      1  0f70		       22		      .byte.b	34
      0  0f71					      db	(XEC-*)-1
      1  0f71		       04		      .byte.b	(XEC-*)-1
      0  0f72					      INSERT		;INSERT IT (MAY BE DELETE)
      0  0f72					      db	24
      1  0f72		       18		      .byte.b	24
      0  0f73					      IJMP	CO
      0  0f73					      db	29
      1  0f73		       1d		      .byte.b	29
      0  0f74					      dw	CO
      1  0f74		       6f 0f		      .word.w	CO
     29  0f76				   XEC
      0  0f76					      XINIT		;INITIALIZE
      0  0f76					      db	0
      1  0f76		       00		      .byte.b	0
     31  0f77
     32  0f77							;STATEMENT EXECUTOR
     33  0f77				   STMT
      0  0f77					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  0f77					      db	57
      1  0f77		       39		      .byte.b	57
      0  0f78					      db	(notirq-*)-1
      1  0f78		       00		      .byte.b	(notirq-*)-1
     35  0f79				   notirq
      0  0f79					      TSTLET	LET	;Test if second field is =
      0  0f79					      db	49
      1  0f79		       31		      .byte.b	49
      0  0f7a					      db	(LET-*)-1
      1  0f7a		       03		      .byte.b	(LET-*)-1
      0  0f7b					      IJMP	DOLET	;allow the default to be let
      0  0f7b					      db	29
      1  0f7b		       1d		      .byte.b	29
      0  0f7c					      dw	DOLET
      1  0f7c		       84 0f		      .word.w	DOLET
     38  0f7e				   LET
      0  0f7e					      TST	S1,"LET"	;IS STATEMENT A LET
      0  0f7e					      db	32
      1  0f7e		       20		      .byte.b	32
      0  0f7f					      db	(S1-*)-1
      1  0f7f		       15		      .byte.b	(S1-*)-1
      0  0f80					      db	"LET",0
      1  0f80		       4c 45 54 00	      .byte.b	"LET",0
     40  0f84				   DOLET
      0  0f84					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  0f84					      db	33
      1  0f84		       21		      .byte.b	33
      0  0f85					      db	(ERRVEC-*)-1
      1  0f85		       92		      .byte.b	(ERRVEC-*)-1
      0  0f86					      TST	ERRVEC,"="	;(This line originally omitted)
      0  0f86					      db	32
      1  0f86		       20		      .byte.b	32
      0  0f87					      db	(ERRVEC-*)-1
      1  0f87		       90		      .byte.b	(ERRVEC-*)-1
      0  0f88					      db	"=",0
      1  0f88		       3d 00		      .byte.b	"=",0
      0  0f8a					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  0f8a					      db	28
      1  0f8a		       1c		      .byte.b	28
      0  0f8b					      dw	EXPR
      1  0f8b		       23 11		      .word.w	EXPR
      0  0f8d					      DONE		;REPORT ERROR IF NOT NEXT
      0  0f8d					      db	1
      1  0f8d		       01		      .byte.b	1
      0  0f8e					      STORE		;STORE RESULT
      0  0f8e					      db	19
      1  0f8e		       13		      .byte.b	19
      0  0f8f					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0f8f					      db	6
      1  0f8f		       06		      .byte.b	6
      0  0f90					      dw	CO
      1  0f90		       6f 0f		      .word.w	CO
      0  0f92					      IJMP	STMT
      0  0f92					      db	29
      1  0f92		       1d		      .byte.b	29
      0  0f93					      dw	STMT
      1  0f93		       77 0f		      .word.w	STMT
     48  0f95				   S1
      0  0f95					      TST	S1S1,"IRET"	;test return from interupt
      0  0f95					      db	32
      1  0f95		       20		      .byte.b	32
      0  0f96					      db	(S1S1-*)-1
      1  0f96		       10		      .byte.b	(S1S1-*)-1
      0  0f97					      db	"IRET",0
      1  0f97		       49 52 45 54*	      .byte.b	"IRET",0
      0  0f9c					      TST	S1Sa,"URN"
      0  0f9c					      db	32
      1  0f9c		       20		      .byte.b	32
      0  0f9d					      db	(S1Sa-*)-1
      1  0f9d		       04		      .byte.b	(S1Sa-*)-1
      0  0f9e					      db	"URN",0
      1  0f9e		       55 52 4e 00	      .byte.b	"URN",0
     51  0fa2				   S1Sa
      0  0fa2					      DONE		;Must be only thing on the line
      0  0fa2					      db	1
      1  0fa2		       01		      .byte.b	1
      0  0fa3					      IRET		;RESTORE LINE NUMBER OF CALL
      0  0fa3					      db	58
      1  0fa3		       3a		      .byte.b	58
      0  0fa4					      IJMP	STMT
      0  0fa4					      db	29
      1  0fa4		       1d		      .byte.b	29
      0  0fa5					      dw	STMT
      1  0fa5		       77 0f		      .word.w	STMT
     55  0fa7
     56  0fa7				   S1S1
      0  0fa7					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  0fa7					      db	32
      1  0fa7		       20		      .byte.b	32
      0  0fa8					      db	(S2b-*)-1
      1  0fa8		       19		      .byte.b	(S2b-*)-1
      0  0fa9					      db	"GO",0
      1  0fa9		       47 4f 00 	      .byte.b	"GO",0
      0  0fac					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  0fac					      db	32
      1  0fac		       20		      .byte.b	32
      0  0fad					      db	(S2-*)-1
      1  0fad		       08		      .byte.b	(S2-*)-1
      0  0fae					      db	"TO",0
      1  0fae		       54 4f 00 	      .byte.b	"TO",0
      0  0fb1					      CALL	EXPR	;GET LABEL
      0  0fb1					      db	28
      1  0fb1		       1c		      .byte.b	28
      0  0fb2					      dw	EXPR
      1  0fb2		       23 11		      .word.w	EXPR
      0  0fb4					      DONE		;ERROR IF CR NOT NEXT
      0  0fb4					      db	1
      1  0fb4		       01		      .byte.b	1
      0  0fb5					      XFER		;SET UP AND JUMP
      0  0fb5					      db	7
      1  0fb5		       07		      .byte.b	7
     62  0fb6				   S2
      0  0fb6					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  0fb6					      db	32
      1  0fb6		       20		      .byte.b	32
      0  0fb7					      db	(ERRVEC-*)-1
      1  0fb7		       60		      .byte.b	(ERRVEC-*)-1
      0  0fb8					      db	"SUB",0
      1  0fb8		       53 55 42 00	      .byte.b	"SUB",0
      0  0fbc					      CALL	EXPR	;GET DESTINATION
      0  0fbc					      db	28
      1  0fbc		       1c		      .byte.b	28
      0  0fbd					      dw	EXPR
      1  0fbd		       23 11		      .word.w	EXPR
      0  0fbf					      DONE		;ERROR IF CR NOT NEXT
      0  0fbf					      db	1
      1  0fbf		       01		      .byte.b	1
      0  0fc0					      SAV		;SAVE RETURN LINE
      0  0fc0					      db	8
      1  0fc0		       08		      .byte.b	8
      0  0fc1					      XFER		;AND JUMP
      0  0fc1					      db	7
      1  0fc1		       07		      .byte.b	7
     68  0fc2				   S2b
      0  0fc2					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  0fc2					      db	32
      1  0fc2		       20		      .byte.b	32
      0  0fc3					      db	(S3-*)-1
      1  0fc3		       1f		      .byte.b	(S3-*)-1
      0  0fc4					      db	"RE",0
      1  0fc4		       52 45 00 	      .byte.b	"RE",0
      0  0fc7					      TST	S2a,"T"
      0  0fc7					      db	32
      1  0fc7		       20		      .byte.b	32
      0  0fc8					      db	(S2a-*)-1
      1  0fc8		       10		      .byte.b	(S2a-*)-1
      0  0fc9					      db	"T",0
      1  0fc9		       54 00		      .byte.b	"T",0
      0  0fcb					      TST	S2aa,"URN"	;RETURN STATEMENT
      0  0fcb					      db	32
      1  0fcb		       20		      .byte.b	32
      0  0fcc					      db	(S2aa-*)-1
      1  0fcc		       04		      .byte.b	(S2aa-*)-1
      0  0fcd					      db	"URN",0
      1  0fcd		       55 52 4e 00	      .byte.b	"URN",0
     72  0fd1				   S2aa
      0  0fd1					      DONE		;MUST BE CR
      0  0fd1					      db	1
      1  0fd1		       01		      .byte.b	1
      0  0fd2					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  0fd2					      db	9
      1  0fd2		       09		      .byte.b	9
      0  0fd3					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  0fd3					      db	6
      1  0fd3		       06		      .byte.b	6
      0  0fd4					      dw	CO
      1  0fd4		       6f 0f		      .word.w	CO
      0  0fd6					      IJMP	STMT
      0  0fd6					      db	29
      1  0fd6		       1d		      .byte.b	29
      0  0fd7					      dw	STMT
      1  0fd7		       77 0f		      .word.w	STMT
     77  0fd9				   S2a
      0  0fd9					      TST	S3,"M"	;REMark.  Skip rest of line
      0  0fd9					      db	32
      1  0fd9		       20		      .byte.b	32
      0  0fda					      db	(S3-*)-1
      1  0fda		       08		      .byte.b	(S3-*)-1
      0  0fdb					      db	"M",0
      1  0fdb		       4d 00		      .byte.b	"M",0
      0  0fdd					      NXT	CO
      0  0fdd					      db	6
      1  0fdd		       06		      .byte.b	6
      0  0fde					      dw	CO
      1  0fde		       6f 0f		      .word.w	CO
      0  0fe0					      IJMP	STMT
      0  0fe0					      db	29
      1  0fe0		       1d		      .byte.b	29
      0  0fe1					      dw	STMT
      1  0fe1		       77 0f		      .word.w	STMT
     81  0fe3
     82  0fe3				   S3
      0  0fe3					      TST	S3a,"?"	; ? symonym for print
      0  0fe3					      db	32
      1  0fe3		       20		      .byte.b	32
      0  0fe4					      db	(S3a-*)-1
      1  0fe4		       05		      .byte.b	(S3a-*)-1
      0  0fe5					      db	"?",0
      1  0fe5		       3f 00		      .byte.b	"?",0
      0  0fe7					      IJMP	S4
      0  0fe7					      db	29
      1  0fe7		       1d		      .byte.b	29
      0  0fe8					      dw	S4
      1  0fe8		       f5 0f		      .word.w	S4
     85  0fea				   S3a
      0  0fea					      TST	S8,"PR"	;allow short form of print
      0  0fea					      db	32
      1  0fea		       20		      .byte.b	32
      0  0feb					      db	(S8-*)-1
      1  0feb		       36		      .byte.b	(S8-*)-1
      0  0fec					      db	"PR",0
      1  0fec		       50 52 00 	      .byte.b	"PR",0
      0  0fef					      TST	S4,"INT"	;PRINT
      0  0fef					      db	32
      1  0fef		       20		      .byte.b	32
      0  0ff0					      db	(S4-*)-1
      1  0ff0		       04		      .byte.b	(S4-*)-1
      0  0ff1					      db	"INT",0
      1  0ff1		       49 4e 54 00	      .byte.b	"INT",0
     88  0ff5				   S4
      0  0ff5					      TSTDONE	S4a	;Test if we just want crlf printed
      0  0ff5					      db	50
      1  0ff5		       32		      .byte.b	50
      0  0ff6					      db	(S4a-*)-1
      1  0ff6		       03		      .byte.b	(S4a-*)-1
      0  0ff7					      IJMP	S6
      0  0ff7					      db	29
      1  0ff7		       1d		      .byte.b	29
      0  0ff8					      dw	S6
      1  0ff8		       10 10		      .word.w	S6
     91  0ffa
      0  0ffa				   S4a	      TSTSTR	S7	;TEST FOR QUOTED String
      0  0ffa					      db	55
      1  0ffa		       37		      .byte.b	55
      0  0ffb					      db	(S7-*)-1
      1  0ffb		       1f		      .byte.b	(S7-*)-1
      0  0ffc					      PRS		;PRINT STRING
      0  0ffc					      db	2
      1  0ffc		       02		      .byte.b	2
     94  0ffd				   S5
      0  0ffd					      TST	S6A,COMMA	;IS THERE MORE?
      0  0ffd					      db	32
      1  0ffd		       20		      .byte.b	32
      0  0ffe					      db	(S6A-*)-1
      1  0ffe		       08		      .byte.b	(S6A-*)-1
      0  0fff					      db	COMMA,0
      1  0fff		       2c 00		      .byte.b	COMMA,0
      0  1001					      SPC		;SPACE TO NEXT ZONE
      0  1001					      db	4
      1  1001		       04		      .byte.b	4
      0  1002					      TSTDONE	S4	;Not end of line jump back
      0  1002					      db	50
      1  1002		       32		      .byte.b	50
      0  1003					      db	(S4-*)-1
      1  1003		       f1		      .byte.b	(S4-*)-1
      0  1004					      IJMP	S6a	;YES JUMP BACK
      0  1004					      db	29
      1  1004		       1d		      .byte.b	29
      0  1005					      dw	S6a
      1  1005		       12 10		      .word.w	S6a
     99  1007							;
    100  1007							; If a semicolon, don't do anything.
    101  1007							;
    102  1007				   S6A
      0  1007					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  1007					      db	32
      1  1007		       20		      .byte.b	32
      0  1008					      db	(S6-*)-1
      1  1008		       07		      .byte.b	(S6-*)-1
      0  1009					      db	SEMICOLON,0
      1  1009		       3b 00		      .byte.b	SEMICOLON,0
      0  100b					      TSTDONE	S4	;Jump Back if not end of line
      0  100b					      db	50
      1  100b		       32		      .byte.b	50
      0  100c					      db	(S4-*)-1
      1  100c		       e8		      .byte.b	(S4-*)-1
      0  100d					      IJMP	S6a
      0  100d					      db	29
      1  100d		       1d		      .byte.b	29
      0  100e					      dw	S6a
      1  100e		       12 10		      .word.w	S6a
    106  1010				   S6
      0  1010					      DONE		;ERROR IF CR NOT NEXT
      0  1010					      db	1
      1  1010		       01		      .byte.b	1
      0  1011					      NLINE
      0  1011					      db	5
      1  1011		       05		      .byte.b	5
      0  1012				   S6a	      NXT	CO	;exit here if , or ; at end of print
      0  1012					      db	6
      1  1012		       06		      .byte.b	6
      0  1013					      dw	CO
      1  1013		       6f 0f		      .word.w	CO
      0  1015					      IJMP	STMT
      0  1015					      db	29
      1  1015		       1d		      .byte.b	29
      0  1016					      dw	STMT
      1  1016		       77 0f		      .word.w	STMT
    111  1018							;
    112  1018							; A jump for code too far away for relative branch
    113  1018							;
    114  1018				   ERRVEC
      0  1018					      IJMP	UNKNOWN
      0  1018					      db	29
      1  1018		       1d		      .byte.b	29
      0  1019					      dw	UNKNOWN
      1  1019		       20 11		      .word.w	UNKNOWN
    116  101b							;
    117  101b				   S7
      0  101b					      CALL	EXPR
      0  101b					      db	28
      1  101b		       1c		      .byte.b	28
      0  101c					      dw	EXPR
      1  101c		       23 11		      .word.w	EXPR
      0  101e					      PRN		;PRINT IT
      0  101e					      db	3
      1  101e		       03		      .byte.b	3
      0  101f					      IJMP	S5	;IS THERE MORE?
      0  101f					      db	29
      1  101f		       1d		      .byte.b	29
      0  1020					      dw	S5
      1  1020		       fd 0f		      .word.w	S5
    121  1022				   S8
      0  1022					      TST	S8a,"IF"	;IF STATEMENT
      0  1022					      db	32
      1  1022		       20		      .byte.b	32
      0  1023					      db	(S8a-*)-1
      1  1023		       11		      .byte.b	(S8a-*)-1
      0  1024					      db	"IF",0
      1  1024		       49 46 00 	      .byte.b	"IF",0
      0  1027					      CALL	EXPR	;GET EXPRESSION
      0  1027					      db	28
      1  1027		       1c		      .byte.b	28
      0  1028					      dw	EXPR
      1  1028		       23 11		      .word.w	EXPR
    124  102a							;Expression is not including the relative operators, true and false
    125  102a							;CALL	     RELOP	     ;DETERMINE OPR AND PUT ON STK
    126  102a							;CALL	     EXPR	     ;GET EXPRESSION
      0  102a					      TST	S8a1,"THEN"	;(This line originally omitted) not required
      0  102a					      db	32
      1  102a		       20		      .byte.b	32
      0  102b					      db	(S8a1-*)-1
      1  102b		       05		      .byte.b	(S8a1-*)-1
      0  102c					      db	"THEN",0
      1  102c		       54 48 45 4e*	      .byte.b	"THEN",0
    128  1031				   S8a1
      0  1031					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1031					      db	54
      1  1031		       36		      .byte.b	54
      0  1032					      IJMP	STMT
      0  1032					      db	29
      1  1032		       1d		      .byte.b	29
      0  1033					      dw	STMT
      1  1033		       77 0f		      .word.w	STMT
    131  1035
    132  1035				   S8a
      0  1035					      TST	S8b,"POKE("	;Poke a value into memory
      0  1035					      db	32
      1  1035		       20		      .byte.b	32
      0  1036					      db	(S8b-*)-1
      1  1036		       1c		      .byte.b	(S8b-*)-1
      0  1037					      db	"POKE(",0
      1  1037		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  103d					      CALL	EXPR	;Get address to write to
      0  103d					      db	28
      1  103d		       1c		      .byte.b	28
      0  103e					      dw	EXPR
      1  103e		       23 11		      .word.w	EXPR
      0  1040					      TST	UNKNOWN,COMMA	;Must have a coma
      0  1040					      db	32
      1  1040		       20		      .byte.b	32
      0  1041					      db	(UNKNOWN-*)-1
      1  1041		       de		      .byte.b	(UNKNOWN-*)-1
      0  1042					      db	COMMA,0
      1  1042		       2c 00		      .byte.b	COMMA,0
      0  1044					      CALL	EXPR	;Get the value to poke
      0  1044					      db	28
      1  1044		       1c		      .byte.b	28
      0  1045					      dw	EXPR
      1  1045		       23 11		      .word.w	EXPR
      0  1047					      TST	UNKNOWN,")"
      0  1047					      db	32
      1  1047		       20		      .byte.b	32
      0  1048					      db	(UNKNOWN-*)-1
      1  1048		       d7		      .byte.b	(UNKNOWN-*)-1
      0  1049					      db	")",0
      1  1049		       29 00		      .byte.b	")",0
      0  104b					      POKEMEM
      0  104b					      db	47
      1  104b		       2f		      .byte.b	47
      0  104c					      DONE
      0  104c					      db	1
      1  104c		       01		      .byte.b	1
      0  104d					      NXT	CO	;AND SEQUENCE TO NEXT
      0  104d					      db	6
      1  104d		       06		      .byte.b	6
      0  104e					      dw	CO
      1  104e		       6f 0f		      .word.w	CO
      0  1050					      IJMP	STMT
      0  1050					      db	29
      1  1050		       1d		      .byte.b	29
      0  1051					      dw	STMT
      1  1051		       77 0f		      .word.w	STMT
    142  1053
    143  1053				   S8b
      0  1053					      TST	S8c,"PUTCH("	;Put a char to the terminal
      0  1053					      db	32
      1  1053		       20		      .byte.b	32
      0  1054					      db	(S8c-*)-1
      1  1054		       16		      .byte.b	(S8c-*)-1
      0  1055					      db	"PUTCH(",0
      1  1055		       50 55 54 43*	      .byte.b	"PUTCH(",0
      0  105c					      CALL	EXPR
      0  105c					      db	28
      1  105c		       1c		      .byte.b	28
      0  105d					      dw	EXPR
      1  105d		       23 11		      .word.w	EXPR
      0  105f					      TST	UNKNOWN,")"
      0  105f					      db	32
      1  105f		       20		      .byte.b	32
      0  1060					      db	(UNKNOWN-*)-1
      1  1060		       bf		      .byte.b	(UNKNOWN-*)-1
      0  1061					      db	")",0
      1  1061		       29 00		      .byte.b	")",0
      0  1063					      PUTCHAR
      0  1063					      db	52
      1  1063		       34		      .byte.b	52
      0  1064					      DONE
      0  1064					      db	1
      1  1064		       01		      .byte.b	1
      0  1065					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1065					      db	6
      1  1065		       06		      .byte.b	6
      0  1066					      dw	CO
      1  1066		       6f 0f		      .word.w	CO
      0  1068					      IJMP	STMT
      0  1068					      db	29
      1  1068		       1d		      .byte.b	29
      0  1069					      dw	STMT
      1  1069		       77 0f		      .word.w	STMT
    151  106b				   S8c
      0  106b					      TST	S9,"CLS"	;Clear the screen
      0  106b					      db	32
      1  106b		       20		      .byte.b	32
      0  106c					      db	(S9-*)-1
      1  106c		       0c		      .byte.b	(S9-*)-1
      0  106d					      db	"CLS",0
      1  106d		       43 4c 53 00	      .byte.b	"CLS",0
      0  1071					      CLEARSCREEN
      0  1071					      db	46
      1  1071		       2e		      .byte.b	46
      0  1072					      DONE
      0  1072					      db	1
      1  1072		       01		      .byte.b	1
      0  1073					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1073					      db	6
      1  1073		       06		      .byte.b	6
      0  1074					      dw	CO
      1  1074		       6f 0f		      .word.w	CO
      0  1076					      IJMP	STMT
      0  1076					      db	29
      1  1076		       1d		      .byte.b	29
      0  1077					      dw	STMT
      1  1077		       77 0f		      .word.w	STMT
    157  1079				   S9
      0  1079					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  1079					      db	32
      1  1079		       20		      .byte.b	32
      0  107a					      db	(S13-*)-1
      1  107a		       2a		      .byte.b	(S13-*)-1
      0  107b					      db	"INPUT",0
      1  107b		       49 4e 50 55*	      .byte.b	"INPUT",0
    159  1081				   S10
      0  1081					      TSTSTR	S10A	;If there is a string print the prompt
      0  1081					      db	55
      1  1081		       37		      .byte.b	55
      0  1082					      db	(S10A-*)-1
      1  1082		       05		      .byte.b	(S10A-*)-1
      0  1083					      PRS
      0  1083					      db	2
      1  1083		       02		      .byte.b	2
      0  1084					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  1084					      db	32
      1  1084		       20		      .byte.b	32
      0  1085					      db	(S10Z-*)-1
      1  1085		       15		      .byte.b	(S10Z-*)-1
      0  1086					      db	SEMICOLON,0
      1  1086		       3b 00		      .byte.b	SEMICOLON,0
    163  1088				   S10A
      0  1088					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  1088					      db	33
      1  1088		       21		      .byte.b	33
      0  1089					      db	(UNKNOWN-*)-1
      1  1089		       96		      .byte.b	(UNKNOWN-*)-1
      0  108a					      TST	S10A1,DOLLAR
      0  108a					      db	32
      1  108a		       20		      .byte.b	32
      0  108b					      db	(S10A1-*)-1
      1  108b		       06		      .byte.b	(S10A1-*)-1
      0  108c					      db	DOLLAR,0
      1  108c		       24 00		      .byte.b	DOLLAR,0
      0  108e					      INSTR
      0  108e					      db	59
      1  108e		       3b		      .byte.b	59
      0  108f					      IJMP	S10A2
      0  108f					      db	29
      1  108f		       1d		      .byte.b	29
      0  1090					      dw	S10A2
      1  1090		       93 10		      .word.w	S10A2
    168  1092				   S10A1
      0  1092					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  1092					      db	11
      1  1092		       0b		      .byte.b	11
    170  1093				   S10A2
      0  1093					      STORE		;STORE IT
      0  1093					      db	19
      1  1093		       13		      .byte.b	19
      0  1094					      TST	S11,COMMA	;IS THERE MORE?
      0  1094					      db	32
      1  1094		       20		      .byte.b	32
      0  1095					      db	(S11-*)-1
      1  1095		       08		      .byte.b	(S11-*)-1
      0  1096					      db	COMMA,0
      1  1096		       2c 00		      .byte.b	COMMA,0
      0  1098					      IJMP	S10	;YES
      0  1098					      db	29
      1  1098		       1d		      .byte.b	29
      0  1099					      dw	S10
      1  1099		       81 10		      .word.w	S10
    174  109b				   S10Z
      0  109b					      iJMP	UNKNOWN
      0  109b					      db	29
      1  109b		       1d		      .byte.b	29
      0  109c					      dw	UNKNOWN
      1  109c		       20 11		      .word.w	UNKNOWN
    176  109e				   S11
      0  109e					      DONE		;MUST BE CR
      0  109e					      db	1
      1  109e		       01		      .byte.b	1
      0  109f					      NXT	CO	;SEQUENCE TO NEXT
      0  109f					      db	6
      1  109f		       06		      .byte.b	6
      0  10a0					      dw	CO
      1  10a0		       6f 0f		      .word.w	CO
      0  10a2					      IJMP	STMT
      0  10a2					      db	29
      1  10a2		       1d		      .byte.b	29
      0  10a3					      dw	STMT
      1  10a3		       77 0f		      .word.w	STMT
    180  10a5				   S13
      0  10a5					      TST	S14,"END"
      0  10a5					      db	32
      1  10a5		       20		      .byte.b	32
      0  10a6					      db	(S14-*)-1
      1  10a6		       05		      .byte.b	(S14-*)-1
      0  10a7					      db	"END",0
      1  10a7		       45 4e 44 00	      .byte.b	"END",0
      0  10ab					      FIN
      0  10ab					      db	12
      1  10ab		       0c		      .byte.b	12
    183  10ac				   S14
      0  10ac					      TST	S14S1,"IRQ"	;Check if we are setting IRQ HANDLER
      0  10ac					      db	32
      1  10ac		       20		      .byte.b	32
      0  10ad					      db	(S14S1-*)-1
      1  10ad		       0f		      .byte.b	(S14S1-*)-1
      0  10ae					      db	"IRQ",0
      1  10ae		       49 52 51 00	      .byte.b	"IRQ",0
      0  10b2					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  10b2					      db	28
      1  10b2		       1c		      .byte.b	28
      0  10b3					      dw	EXPR
      1  10b3		       23 11		      .word.w	EXPR
      0  10b5					      DONE		;must be CR
      0  10b5					      db	1
      1  10b5		       01		      .byte.b	1
      0  10b6					      SETIRQ		;Set the line number now
      0  10b6					      db	56
      1  10b6		       38		      .byte.b	56
      0  10b7					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  10b7					      db	6
      1  10b7		       06		      .byte.b	6
      0  10b8					      dw	CO
      1  10b8		       6f 0f		      .word.w	CO
      0  10ba					      IJMP	STMT
      0  10ba					      db	29
      1  10ba		       1d		      .byte.b	29
      0  10bb					      dw	STMT
      1  10bb		       77 0f		      .word.w	STMT
    190  10bd				   S14S1
      0  10bd					      TST	S15,"LIST"	;LIST COMMAND
      0  10bd					      db	32
      1  10bd		       20		      .byte.b	32
      0  10be					      db	(S15-*)-1
      1  10be		       0a		      .byte.b	(S15-*)-1
      0  10bf					      db	"LIST",0
      1  10bf		       4c 49 53 54*	      .byte.b	"LIST",0
      0  10c4					      DONE
      0  10c4					      db	1
      1  10c4		       01		      .byte.b	1
      0  10c5					      LST
      0  10c5					      db	21
      1  10c5		       15		      .byte.b	21
      0  10c6					      IJMP	CO
      0  10c6					      db	29
      1  10c6		       1d		      .byte.b	29
      0  10c7					      dw	CO
      1  10c7		       6f 0f		      .word.w	CO
    195  10c9				   S15
      0  10c9					      TST	S16,"RUN"	;RUN COMMAND
      0  10c9					      db	32
      1  10c9		       20		      .byte.b	32
      0  10ca					      db	(S16-*)-1
      1  10ca		       0d		      .byte.b	(S16-*)-1
      0  10cb					      db	"RUN",0
      1  10cb		       52 55 4e 00	      .byte.b	"RUN",0
      0  10cf					      DONE
      0  10cf					      db	1
      1  10cf		       01		      .byte.b	1
      0  10d0					      VINIT		;clear variables
      0  10d0					      db	30
      1  10d0		       1e		      .byte.b	30
      0  10d1					      LIT	1	;GOTO line 1
      0  10d1					      db	27
      1  10d1		       1b		      .byte.b	27
      0  10d2					      dw	1
      1  10d2		       01 00		      .word.w	1
      0  10d4					      XFER		;Bob's addition
      0  10d4					      db	7
      1  10d4		       07		      .byte.b	7
    201  10d5							; EXIT
      0  10d5					      IJMP	STMT	;and run!
      0  10d5					      db	29
      1  10d5		       1d		      .byte.b	29
      0  10d6					      dw	STMT
      1  10d6		       77 0f		      .word.w	STMT
    203  10d8				   S16
      0  10d8					      TST	S17A,"NEW"	;clear program
      0  10d8					      db	32
      1  10d8		       20		      .byte.b	32
      0  10d9					      db	(S17A-*)-1
      1  10d9		       08		      .byte.b	(S17A-*)-1
      0  10da					      db	"NEW",0
      1  10da		       4e 45 57 00	      .byte.b	"NEW",0
      0  10de					      DONE
      0  10de					      db	1
      1  10de		       01		      .byte.b	1
      0  10df					      IJMP	START
      0  10df					      db	29
      1  10df		       1d		      .byte.b	29
      0  10e0					      dw	START
      1  10e0		       69 0f		      .word.w	START
    207  10e2
    208  10e2				   S17A
      0  10e2					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  10e2					      db	32
      1  10e2		       20		      .byte.b	32
      0  10e3					      db	(S17B-*)-1
      1  10e3		       06		      .byte.b	(S17B-*)-1
      0  10e4					      db	"EXIT",0
      1  10e4		       45 58 49 54*	      .byte.b	"EXIT",0
      0  10e9					      EXIT
      0  10e9					      db	26
      1  10e9		       1a		      .byte.b	26
    211  10ea
    212  10ea							;
    213  10ea							; Commands related to saving/restoring programs
    214  10ea							; to/from mass storage.
    215  10ea							;
    216  10ea				   S17B
    217  10ea					      if	(XKIM || CTMON65) && DISK_ACCESS
    218  10ea
      0  10ea					      TST	S17C,"SAVE"
      0  10ea					      db	32
      1  10ea		       20		      .byte.b	32
      0  10eb					      db	(S17C-*)-1
      1  10eb		       0b		      .byte.b	(S17C-*)-1
      0  10ec					      db	"SAVE",0
      1  10ec		       53 41 56 45*	      .byte.b	"SAVE",0
      0  10f1					      OPENWRITE
      0  10f1					      db	40
      1  10f1		       28		      .byte.b	40
      0  10f2					      DLIST
      0  10f2					      db	43
      1  10f2		       2b		      .byte.b	43
      0  10f3					      DCLOSE
      0  10f3					      db	41
      1  10f3		       29		      .byte.b	41
      0  10f4					      IJMP	CO
      0  10f4					      db	29
      1  10f4		       1d		      .byte.b	29
      0  10f5					      dw	CO
      1  10f5		       6f 0f		      .word.w	CO
    224  10f7
    225  10f7				   S17C
      0  10f7					      TST	S18,"LOAD"
      0  10f7					      db	32
      1  10f7		       20		      .byte.b	32
      0  10f8					      db	(S18-*)-1
      1  10f8		       11		      .byte.b	(S18-*)-1
      0  10f9					      db	"LOAD",0
      1  10f9		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  10fe					      OPENREAD
      0  10fe					      db	39
      1  10fe		       27		      .byte.b	39
    228  10ff				   S17CLP
      0  10ff					      DGETLINE		;get line from file
      0  10ff					      db	42
      1  10ff		       2a		      .byte.b	42
      0  1100					      TSTL	S17EOL	;no line num means EOL
      0  1100					      db	34
      1  1100		       22		      .byte.b	34
      0  1101					      db	(S17EOL-*)-1
      1  1101		       04		      .byte.b	(S17EOL-*)-1
      0  1102					      INSERT		;put it into the program
      0  1102					      db	24
      1  1102		       18		      .byte.b	24
      0  1103					      IJMP	S17CLP	;keep going
      0  1103					      db	29
      1  1103		       1d		      .byte.b	29
      0  1104					      dw	S17CLP
      1  1104		       ff 10		      .word.w	S17CLP
    233  1106				   S17EOL
      0  1106					      DCLOSE		;close disk file
      0  1106					      db	41
      1  1106		       29		      .byte.b	41
      0  1107					      IJMP	CO	;back to start
      0  1107					      db	29
      1  1107		       1d		      .byte.b	29
      0  1108					      dw	CO
      1  1108		       6f 0f		      .word.w	CO
    236  110a
      0  110a				   S18	      TST	S19,"DIR"
      0  110a					      db	32
      1  110a		       20		      .byte.b	32
      0  110b					      db	(S19-*)-1
      1  110b		       08		      .byte.b	(S19-*)-1
      0  110c					      db	"DIR",0
      1  110c		       44 49 52 00	      .byte.b	"DIR",0
      0  1110					      DDIR		;Display the directory content
      0  1110					      db	44
      1  1110		       2c		      .byte.b	44
      0  1111					      IJMP	CO
      0  1111					      db	29
      1  1111		       1d		      .byte.b	29
      0  1112					      dw	CO
      1  1112		       6f 0f		      .word.w	CO
    240  1114					      endif
    241  1114
      0  1114				   S19	      TST	UNKNOWN,"ERASE"
      0  1114					      db	32
      1  1114		       20		      .byte.b	32
      0  1115					      db	(UNKNOWN-*)-1
      1  1115		       0a		      .byte.b	(UNKNOWN-*)-1
      0  1116					      db	"ERASE",0
      1  1116		       45 52 41 53*	      .byte.b	"ERASE",0
      0  111c					      RMFILE		;Erase the file from the disk
      0  111c					      db	45
      1  111c		       2d		      .byte.b	45
      0  111d					      IJMP	CO
      0  111d					      db	29
      1  111d		       1d		      .byte.b	29
      0  111e					      dw	CO
      1  111e		       6f 0f		      .word.w	CO
    245  111e					      endif
    246  1120
    247  1120							;
    248  1120							; Else, unknown command.
    249  1120							;
    250  1120				   UNKNOWN
      0  1120					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  1120					      db	13
      1  1120		       0d		      .byte.b	13
      0  1121					      dw	ERR_SYNTAX
      1  1121		       05 00		      .word.w	ERR_SYNTAX
    252  1123
    253  1123							;-----------------------------------------------------
    254  1123				   EXPR
      0  1123					      Call	EXPR2	; get the first expression
      0  1123					      db	28
      1  1123		       1c		      .byte.b	28
      0  1124					      dw	EXPR2
      1  1124		       6e 11		      .word.w	EXPR2
      0  1126					      TST	iR0,"="
      0  1126					      db	32
      1  1126		       20		      .byte.b	32
      0  1127					      db	(iR0-*)-1
      1  1127		       08		      .byte.b	(iR0-*)-1
      0  1128					      db	"=",0
      1  1128		       3d 00		      .byte.b	"=",0
      0  112a					      LIT	2	;=
      0  112a					      db	27
      1  112a		       1b		      .byte.b	27
      0  112b					      dw	2
      1  112b		       02 00		      .word.w	2
      0  112d					      IJMP	iRFound
      0  112d					      db	29
      1  112d		       1d		      .byte.b	29
      0  112e					      dw	iRFound
      1  112e		       69 11		      .word.w	iRFound
    259  1130				   iR0
      0  1130					      TST	iR4,"<"
      0  1130					      db	32
      1  1130		       20		      .byte.b	32
      0  1131					      db	(iR4-*)-1
      1  1131		       1c		      .byte.b	(iR4-*)-1
      0  1132					      db	"<",0
      1  1132		       3c 00		      .byte.b	"<",0
      0  1134					      TST	iR1,"="
      0  1134					      db	32
      1  1134		       20		      .byte.b	32
      0  1135					      db	(iR1-*)-1
      1  1135		       08		      .byte.b	(iR1-*)-1
      0  1136					      db	"=",0
      1  1136		       3d 00		      .byte.b	"=",0
      0  1138					      LIT	3	;<=
      0  1138					      db	27
      1  1138		       1b		      .byte.b	27
      0  1139					      dw	3
      1  1139		       03 00		      .word.w	3
      0  113b					      IJMP	iRFound
      0  113b					      db	29
      1  113b		       1d		      .byte.b	29
      0  113c					      dw	iRFound
      1  113c		       69 11		      .word.w	iRFound
    264  113e				   iR1
      0  113e					      TST	iR3,">"
      0  113e					      db	32
      1  113e		       20		      .byte.b	32
      0  113f					      db	(iR3-*)-1
      1  113f		       08		      .byte.b	(iR3-*)-1
      0  1140					      db	">",0
      1  1140		       3e 00		      .byte.b	">",0
      0  1142					      LIT	5	;<>
      0  1142					      db	27
      1  1142		       1b		      .byte.b	27
      0  1143					      dw	5
      1  1143		       05 00		      .word.w	5
      0  1145					      IJMP	iRFound
      0  1145					      db	29
      1  1145		       1d		      .byte.b	29
      0  1146					      dw	iRFound
      1  1146		       69 11		      .word.w	iRFound
    268  1148				   iR3
      0  1148					      LIT	1	;<
      0  1148					      db	27
      1  1148		       1b		      .byte.b	27
      0  1149					      dw	1
      1  1149		       01 00		      .word.w	1
      0  114b					      IJMP	iRFound
      0  114b					      db	29
      1  114b		       1d		      .byte.b	29
      0  114c					      dw	iRFound
      1  114c		       69 11		      .word.w	iRFound
    271  114e				   iR4
      0  114e					      TST	iRDone,">"
      0  114e					      db	32
      1  114e		       20		      .byte.b	32
      0  114f					      db	(iRDone-*)-1
      1  114f		       1d		      .byte.b	(iRDone-*)-1
      0  1150					      db	">",0
      1  1150		       3e 00		      .byte.b	">",0
      0  1152					      TST	iR5,"="
      0  1152					      db	32
      1  1152		       20		      .byte.b	32
      0  1153					      db	(iR5-*)-1
      1  1153		       08		      .byte.b	(iR5-*)-1
      0  1154					      db	"=",0
      1  1154		       3d 00		      .byte.b	"=",0
      0  1156					      LIT	6	;>=
      0  1156					      db	27
      1  1156		       1b		      .byte.b	27
      0  1157					      dw	6
      1  1157		       06 00		      .word.w	6
      0  1159					      IJMP	iRFound
      0  1159					      db	29
      1  1159		       1d		      .byte.b	29
      0  115a					      dw	iRFound
      1  115a		       69 11		      .word.w	iRFound
    276  115c				   iR5
      0  115c					      TST	iR6,"<"
      0  115c					      db	32
      1  115c		       20		      .byte.b	32
      0  115d					      db	(iR6-*)-1
      1  115d		       08		      .byte.b	(iR6-*)-1
      0  115e					      db	"<",0
      1  115e		       3c 00		      .byte.b	"<",0
      0  1160					      LIT	1
      0  1160					      db	27
      1  1160		       1b		      .byte.b	27
      0  1161					      dw	1
      1  1161		       01 00		      .word.w	1
      0  1163					      IJMP	iRFound	;(This line originally omitted)
      0  1163					      db	29
      1  1163		       1d		      .byte.b	29
      0  1164					      dw	iRFound
      1  1164		       69 11		      .word.w	iRFound
    280  1166				   iR6
      0  1166					      LIT	4	;>
      0  1166					      db	27
      1  1166		       1b		      .byte.b	27
      0  1167					      dw	4
      1  1167		       04 00		      .word.w	4
    282  1169				   iRFound
      0  1169					      Call	EXPR2	; get the right side of the expression
      0  1169					      db	28
      1  1169		       1c		      .byte.b	28
      0  116a					      dw	EXPR2
      1  116a		       6e 11		      .word.w	EXPR2
      0  116c					      CMPR		; Push the value of the true false onto the stack
      0  116c					      db	10
      1  116c		       0a		      .byte.b	10
    285  116d
    286  116d				   iRDone
      0  116d					      RTN
      0  116d					      db	25
      1  116d		       19		      .byte.b	25
    288  116e
    289  116e				   EXPR2
      0  116e					      TST	E0,"-"	; Look for leading - to negate term
      0  116e					      db	32
      1  116e		       20		      .byte.b	32
      0  116f					      db	(E0-*)-1
      1  116f		       09		      .byte.b	(E0-*)-1
      0  1170					      db	"-",0
      1  1170		       2d 00		      .byte.b	"-",0
      0  1172					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  1172					      db	28
      1  1172		       1c		      .byte.b	28
      0  1173					      dw	TERM
      1  1173		       97 11		      .word.w	TERM
      0  1175					      NEG		; Make value negated
      0  1175					      db	16
      1  1175		       10		      .byte.b	16
      0  1176					      IJMP	E1	; We have Left term process operators next
      0  1176					      db	29
      1  1176		       1d		      .byte.b	29
      0  1177					      dw	E1
      1  1177		       80 11		      .word.w	E1
    294  1179				   E0
      0  1179					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  1179					      db	32
      1  1179		       20		      .byte.b	32
      0  117a					      db	(E1A-*)-1
      1  117a		       02		      .byte.b	(E1A-*)-1
      0  117b					      db	"+",0
      1  117b		       2b 00		      .byte.b	"+",0
    296  117d				   E1A
      0  117d					      CALL	TERM	; Get the left term if it was not negated
      0  117d					      db	28
      1  117d		       1c		      .byte.b	28
      0  117e					      dw	TERM
      1  117e		       97 11		      .word.w	TERM
    298  1180				   E1
      0  1180					      TST	E2,"+"	; Check if we are adding left term to something
      0  1180					      db	32
      1  1180		       20		      .byte.b	32
      0  1181					      db	(E2-*)-1
      1  1181		       09		      .byte.b	(E2-*)-1
      0  1182					      db	"+",0
      1  1182		       2b 00		      .byte.b	"+",0
      0  1184					      CALL	TERM	; if adding then get the right side term
      0  1184					      db	28
      1  1184		       1c		      .byte.b	28
      0  1185					      dw	TERM
      1  1185		       97 11		      .word.w	TERM
      0  1187					      ADD		; Add it to left term
      0  1187					      db	14
      1  1187		       0e		      .byte.b	14
      0  1188					      IJMP	E1	; look for next + or -
      0  1188					      db	29
      1  1188		       1d		      .byte.b	29
      0  1189					      dw	E1
      1  1189		       80 11		      .word.w	E1
    303  118b				   E2
      0  118b					      TST	E3,"-"	; Check if we are subtractig something
      0  118b					      db	32
      1  118b		       20		      .byte.b	32
      0  118c					      db	(E3-*)-1
      1  118c		       09		      .byte.b	(E3-*)-1
      0  118d					      db	"-",0
      1  118d		       2d 00		      .byte.b	"-",0
      0  118f					      CALL	TERM	; get right side to subtract Diffrence
      0  118f					      db	28
      1  118f		       1c		      .byte.b	28
      0  1190					      dw	TERM
      1  1190		       97 11		      .word.w	TERM
      0  1192					      SUB		; Subtract the value
      0  1192					      db	15
      1  1192		       0f		      .byte.b	15
      0  1193					      IJMP	E1	; Look for next + or -
      0  1193					      db	29
      1  1193		       1d		      .byte.b	29
      0  1194					      dw	E1
      1  1194		       80 11		      .word.w	E1
    308  1196				   E3			; Finish processing the expression
      0  1196					      RTN		; We are finished processing the Expression
      0  1196					      db	25
      1  1196		       19		      .byte.b	25
    310  1197							;
    311  1197							; Get one of the terms of an expression
    312  1197							;
    313  1197				   TERM
      0  1197					      CALL	FACT	; Get a value
      0  1197					      db	28
      1  1197		       1c		      .byte.b	28
      0  1198					      dw	FACT
      1  1198		       bf 11		      .word.w	FACT
    315  119a				   T0			; Check for higher precidence operators
      0  119a					      TST	T1,"*"	; Check for *
      0  119a					      db	32
      1  119a		       20		      .byte.b	32
      0  119b					      db	(T1-*)-1
      1  119b		       09		      .byte.b	(T1-*)-1
      0  119c					      db	"*",0
      1  119c		       2a 00		      .byte.b	"*",0
      0  119e					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  119e					      db	28
      1  119e		       1c		      .byte.b	28
      0  119f					      dw	FACT
      1  119f		       bf 11		      .word.w	FACT
      0  11a1					      MUL		; Multiply factors
      0  11a1					      db	17
      1  11a1		       11		      .byte.b	17
      0  11a2					      IJMP	T0	; Check for * or /
      0  11a2					      db	29
      1  11a2		       1d		      .byte.b	29
      0  11a3					      dw	T0
      1  11a3		       9a 11		      .word.w	T0
    320  11a5				   T1
      0  11a5					      TST	T2,"/"	; Check for a division
      0  11a5					      db	32
      1  11a5		       20		      .byte.b	32
      0  11a6					      db	(T2-*)-1
      1  11a6		       09		      .byte.b	(T2-*)-1
      0  11a7					      db	"/",0
      1  11a7		       2f 00		      .byte.b	"/",0
      0  11a9					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  11a9					      db	28
      1  11a9		       1c		      .byte.b	28
      0  11aa					      dw	FACT
      1  11aa		       bf 11		      .word.w	FACT
      0  11ac					      DIV		; do division
      0  11ac					      db	18
      1  11ac		       12		      .byte.b	18
      0  11ad					      IJMP	T0	; check for more * or /
      0  11ad					      db	29
      1  11ad		       1d		      .byte.b	29
      0  11ae					      dw	T0
      1  11ae		       9a 11		      .word.w	T0
    325  11b0				   T2
      0  11b0					      TST	T3,"%"	; Check for a division
      0  11b0					      db	32
      1  11b0		       20		      .byte.b	32
      0  11b1					      db	(T3-*)-1
      1  11b1		       09		      .byte.b	(T3-*)-1
      0  11b2					      db	"%",0
      1  11b2		       25 00		      .byte.b	"%",0
      0  11b4					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  11b4					      db	28
      1  11b4		       1c		      .byte.b	28
      0  11b5					      dw	FACT
      1  11b5		       bf 11		      .word.w	FACT
      0  11b7					      MODULO		; do division for remainder
      0  11b7					      db	60
      1  11b7		       3c		      .byte.b	60
      0  11b8					      IJMP	T0	; check for more * or / or %
      0  11b8					      db	29
      1  11b8		       1d		      .byte.b	29
      0  11b9					      dw	T0
      1  11b9		       9a 11		      .word.w	T0
    330  11bb				   T3			; Finish processing the Term
      0  11bb					      RTN
      0  11bb					      db	25
      1  11bb		       19		      .byte.b	25
    332  11bc
    333  11bc				   UNKNOWNVEC
      0  11bc					      IJMP	UNKNOWN
      0  11bc					      db	29
      1  11bc		       1d		      .byte.b	29
      0  11bd					      dw	UNKNOWN
      1  11bd		       20 11		      .word.w	UNKNOWN
    335  11bf
    336  11bf
    337  11bf							;
    338  11bf							; Factor an expression.  Always test for functions
    339  11bf							; first or else they'll be confused for variables.
    340  11bf							;
    341  11bf				   FACT
      0  11bf					      TST	F1A,"FREE()"
      0  11bf					      db	32
      1  11bf		       20		      .byte.b	32
      0  11c0					      db	(F1A-*)-1
      1  11c0		       09		      .byte.b	(F1A-*)-1
      0  11c1					      db	"FREE()",0
      1  11c1		       46 52 45 45*	      .byte.b	"FREE()",0
      0  11c8					      FREE
      0  11c8					      db	36
      1  11c8		       24		      .byte.b	36
      0  11c9					      RTN
      0  11c9					      db	25
      1  11c9		       19		      .byte.b	25
    345  11ca				   F1A
      0  11ca					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  11ca					      db	32
      1  11ca		       20		      .byte.b	32
      0  11cb					      db	(F1A2-*)-1
      1  11cb		       0a		      .byte.b	(F1A2-*)-1
      0  11cc					      db	"GETCH()",0
      1  11cc		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  11d4					      GETCHAR
      0  11d4					      db	51
      1  11d4		       33		      .byte.b	51
      0  11d5					      RTN
      0  11d5					      db	25
      1  11d5		       19		      .byte.b	25
    349  11d6				   F1A2
      0  11d6					      TST	F2A,"PEEK("	;Return a value from memory
      0  11d6					      db	32
      1  11d6		       20		      .byte.b	32
      0  11d7					      db	(F2A-*)-1
      1  11d7		       0f		      .byte.b	(F2A-*)-1
      0  11d8					      db	"PEEK(",0
      1  11d8		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  11de					      CALL	EXPR	;Get the address to write to
      0  11de					      db	28
      1  11de		       1c		      .byte.b	28
      0  11df					      dw	EXPR
      1  11df		       23 11		      .word.w	EXPR
      0  11e1					      TST	UNKNOWN,")"	;Closing bracket
      0  11e1					      db	32
      1  11e1		       20		      .byte.b	32
      0  11e2					      db	(UNKNOWN-*)-1
      1  11e2		       3d		      .byte.b	(UNKNOWN-*)-1
      0  11e3					      db	")",0
      1  11e3		       29 00		      .byte.b	")",0
      0  11e5					      PEEKMEM
      0  11e5					      db	48
      1  11e5		       30		      .byte.b	48
      0  11e6					      RTN
      0  11e6					      db	25
      1  11e6		       19		      .byte.b	25
    355  11e7							;
    356  11e7							; RND() is supposed to have an argument but if none
    357  11e7							; was provided, just assume a large value.
    358  11e7							;
    359  11e7				   F2A
      0  11e7					      TST	F2B,"RND("
      0  11e7					      db	32
      1  11e7		       20		      .byte.b	32
      0  11e8					      db	(F2B-*)-1
      1  11e8		       17		      .byte.b	(F2B-*)-1
      0  11e9					      db	"RND(",0
      1  11e9		       52 4e 44 28*	      .byte.b	"RND(",0
      0  11ee					      TST	F2A1,")"
      0  11ee					      db	32
      1  11ee		       20		      .byte.b	32
      0  11ef					      db	(F2A1-*)-1
      1  11ef		       07		      .byte.b	(F2A1-*)-1
      0  11f0					      db	")",0
      1  11f0		       29 00		      .byte.b	")",0
      0  11f2					      LIT	32766
      0  11f2					      db	27
      1  11f2		       1b		      .byte.b	27
      0  11f3					      dw	32766
      1  11f3		       fe 7f		      .word.w	32766
      0  11f5					      RANDOM
      0  11f5					      db	37
      1  11f5		       25		      .byte.b	37
      0  11f6					      RTN
      0  11f6					      db	25
      1  11f6		       19		      .byte.b	25
    365  11f7				   F2A1
      0  11f7					      CALL	FACT	;GET RANGE
      0  11f7					      db	28
      1  11f7		       1c		      .byte.b	28
      0  11f8					      dw	FACT
      1  11f8		       bf 11		      .word.w	FACT
      0  11fa					      TST	UNKNOWN,")"
      0  11fa					      db	32
      1  11fa		       20		      .byte.b	32
      0  11fb					      db	(UNKNOWN-*)-1
      1  11fb		       24		      .byte.b	(UNKNOWN-*)-1
      0  11fc					      db	")",0
      1  11fc		       29 00		      .byte.b	")",0
      0  11fe					      RANDOM
      0  11fe					      db	37
      1  11fe		       25		      .byte.b	37
      0  11ff					      RTN
      0  11ff					      db	25
      1  11ff		       19		      .byte.b	25
    370  1200
    371  1200				   F2B
      0  1200					      TST	F2B2,"ABS("
      0  1200					      db	32
      1  1200		       20		      .byte.b	32
      0  1201					      db	(F2B2-*)-1
      1  1201		       0e		      .byte.b	(F2B2-*)-1
      0  1202					      db	"ABS(",0
      1  1202		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1207					      CALL	FACT	;get value
      0  1207					      db	28
      1  1207		       1c		      .byte.b	28
      0  1208					      dw	FACT
      1  1208		       bf 11		      .word.w	FACT
      0  120a					      TST	UNKNOWN,")"
      0  120a					      db	32
      1  120a		       20		      .byte.b	32
      0  120b					      db	(UNKNOWN-*)-1
      1  120b		       14		      .byte.b	(UNKNOWN-*)-1
      0  120c					      db	")",0
      1  120c		       29 00		      .byte.b	")",0
      0  120e					      ABS
      0  120e					      db	38
      1  120e		       26		      .byte.b	38
      0  120f					      RTN
      0  120f					      db	25
      1  120f		       19		      .byte.b	25
    377  1210
    378  1210				   F2B2
      0  1210					      TST	F2C,"CALL("	;call machine function
      0  1210					      db	32
      1  1210		       20		      .byte.b	32
      0  1211					      db	(F2C-*)-1
      1  1211		       1f		      .byte.b	(F2C-*)-1
      0  1212					      db	"CALL(",0
      1  1212		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1218					      CALL	EXPR
      0  1218					      db	28
      1  1218		       1c		      .byte.b	28
      0  1219					      dw	EXPR
      1  1219		       23 11		      .word.w	EXPR
      0  121b					      TST	F2B2A,COMMA
      0  121b					      db	32
      1  121b		       20		      .byte.b	32
      0  121c					      db	(F2B2A-*)-1
      1  121c		       0b		      .byte.b	(F2B2A-*)-1
      0  121d					      db	COMMA,0
      1  121d		       2c 00		      .byte.b	COMMA,0
      0  121f					      CALL	EXPR
      0  121f					      db	28
      1  121f		       1c		      .byte.b	28
      0  1220					      dw	EXPR
      1  1220		       23 11		      .word.w	EXPR
      0  1222					      TST	UNKNOWNVEC,")"
      0  1222					      db	32
      1  1222		       20		      .byte.b	32
      0  1223					      db	(UNKNOWNVEC-*)-1
      1  1223		       98		      .byte.b	(UNKNOWNVEC-*)-1
      0  1224					      db	")",0
      1  1224		       29 00		      .byte.b	")",0
      0  1226					      CALLFUNC
      0  1226					      db	53
      1  1226		       35		      .byte.b	53
      0  1227					      RTN
      0  1227					      db	25
      1  1227		       19		      .byte.b	25
    386  1228
      0  1228				   F2B2A      TST	UNKNOWNVEC,")"
      0  1228					      db	32
      1  1228		       20		      .byte.b	32
      0  1229					      db	(UNKNOWNVEC-*)-1
      1  1229		       92		      .byte.b	(UNKNOWNVEC-*)-1
      0  122a					      db	")",0
      1  122a		       29 00		      .byte.b	")",0
      0  122c					      LIT	0
      0  122c					      db	27
      1  122c		       1b		      .byte.b	27
      0  122d					      dw	0
      1  122d		       00 00		      .word.w	0
      0  122f					      CALLFUNC
      0  122f					      db	53
      1  122f		       35		      .byte.b	53
      0  1230					      RTN
      0  1230					      db	25
      1  1230		       19		      .byte.b	25
    391  1231				   F2C
      0  1231					      TSTV	F0
      0  1231					      db	33
      1  1231		       21		      .byte.b	33
      0  1232					      db	(F0-*)-1
      1  1232		       02		      .byte.b	(F0-*)-1
      0  1233					      IND		;YES, GET THE VALUE.
      0  1233					      db	20
      1  1233		       14		      .byte.b	20
      0  1234					      RTN
      0  1234					      db	25
      1  1234		       19		      .byte.b	25
    395  1235				   F0
      0  1235					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1235					      db	35
      1  1235		       23		      .byte.b	35
      0  1236					      db	(F1-*)-1
      1  1236		       01		      .byte.b	(F1-*)-1
      0  1237					      RTN
      0  1237					      db	25
      1  1237		       19		      .byte.b	25
    398  1238				   F1
      0  1238					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  1238					      db	32
      1  1238		       20		      .byte.b	32
      0  1239					      db	(F2A-*)-1
      1  1239		       ad		      .byte.b	(F2A-*)-1
      0  123a					      db	"(",0
      1  123a		       28 00		      .byte.b	"(",0
      0  123c					      CALL	EXPR
      0  123c					      db	28
      1  123c		       1c		      .byte.b	28
      0  123d					      dw	EXPR
      1  123d		       23 11		      .word.w	EXPR
      0  123f					      TST	F2,")"
      0  123f					      db	32
      1  123f		       20		      .byte.b	32
      0  1240					      db	(F2-*)-1
      1  1240		       03		      .byte.b	(F2-*)-1
      0  1241					      db	")",0
      1  1241		       29 00		      .byte.b	")",0
      0  1243					      RTN
      0  1243					      db	25
      1  1243		       19		      .byte.b	25
    403  1244
    404  1244				   F2
      0  1244					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1244					      db	13
      1  1244		       0d		      .byte.b	13
      0  1245					      dw	ERR_SYNTAX
      1  1245		       05 00		      .word.w	ERR_SYNTAX
    406  1247
    407  1247		       12 47	   ILEND      equ	*
------- FILE mytb.asm
   1746  1247		       12 47	   PROGEND    equ	*
   1747  1247
   1748  1247							;=====================================================
   1749  1247							;=====================================================
   1750  1247							;=====================================================
   1751  1247							; These are storage items not in page zero.
   1752  1247							;
   1753 Udf9e					      seg.u	Data
   1754 U1247					      org	PROGEND
   1755 U1247
   1756 U1247		       00 00 00 00*mathStack  ds	STACKSIZE*2
   1757 U126f		       00	   mathStackPtr ds	1
   1758 U1270		       00 00 00 00*retStack   ds	STACKSIZE*2
   1759 U1298		       00	   retStackPtr ds	1
   1760 U1299							;callStack	ds	GOSUBSTACKSIZE*3
   1761 U1299		       00	   GoSubStackPtr ds	1
   1762 U129a		       00 00 00 00*LINBUF     ds	132
   1763 U131e		       00	   getlinx    ds	1
   1764 U131f		       00	   printtx    ds	1	;temp X for print funcs
   1765 U1320		       00	   diddigit   ds	1	;for leading zero suppression
   1766 U1321		       00	   putsy      ds	1
   1767 U1322		       00 00	   errGoto    ds	2	;where to set ILPC on err
   1768 U1324		       00 00	   MQ	      ds	2	;used for some math
   1769 U1326		       00	   sign       ds	1	;0 = positive, else negative
   1770 U1327		       00	   rtemp1     ds	1
   1771 U1328		       00 00	   random     ds	2
   1772 U132a		       00 00	   BOutVec    ds	2
   1773 U132c		       00	   tempy      ds	1	;temp y storage
   1774 U132d				  -	      if	XKIM
   1775 U132d				  -buffer     ds	BUFFER_SIZE
   1776 U132d					      endif
   1777 U132d							;
   1778 U132d							; PROGRAMEND is the end of the user's BASIC program.
   1779 U132d							; More precisely, it is one byte past the end.  Or,
   1780 U132d							; it's where the next line added to the end will be
   1781 U132d							; placed.
   1782 U132d							;
   1783 U132d		       00 00	   PROGRAMEND ds	2
   1784 U132f		       00 00	   HighMem    ds	2	;highest location
   1785 U1331		       00 00	   UsedMem    ds	2	;size of user program
   1786 U1333		       00 00	   FreeMem    ds	2	;amount of free memory
   1787 U1335							;
   1788 U1335							;=====================================================
   1789 U1335							; This is the start of the user's BASIC program space.
   1790 U1335							;
   1791 U1335							; PERSONAL GOAL: This should be no larger than $0DFF.
   1792 U1335							;		  0200-05FF = 1K
   1793 U1335							;		  0200-09FF = 2K
   1794 U1335							;		  0200-0DFF = 3K
   1795 U1335							;		  0200-11FF = 4K
   1796 U1335							;		  0200-13FF = 4.5K
   1797 U1335							;
   1798 U1335				  -	      if	FIXED
   1799 U1335				  -	      org	$2000
   1800 U1335					      endif
   1801 U1335		       13 35	   ProgramStart equ	*
   1802 U1335							;/*
   1803 U1335							;	if	CTMON65 || XKIM
   1804 U1335							;		SEG Code
   1805 U1335							;		org	AutoRun
   1806 U1335							;		dw	TBasicCold
   1807 U1335							;	endif
   1808 U1335							;*/
   1809 U1335					      end
