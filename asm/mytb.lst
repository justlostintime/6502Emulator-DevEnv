------- FILE mytb.asm LEVEL 1 PASS 4
      1 U1587				   input      processor	6502
      2 U1587 ????						;=====================================================
      3 U1587 ????						; Bob's Tiny BASIC
      4 U1587 ????						;
      5 U1587 ????						; While working on the Corsham Technologies KIM Clone
      6 U1587 ????						; project, I wanted to include a TINY BASIC since that
      7 U1587 ????						; was a highly desirable feature of early computers.
      8 U1587 ????						;
      9 U1587 ????						; Rather than negotiating copyright issues for
     10 U1587 ????						; existing BASICs, I decided to just write one from
     11 U1587 ????						; scratch.
     12 U1587 ????						;
     13 U1587 ????						; 10/07/2017
     14 U1587 ????						;
     15 U1587 ????						; This implements a stripped down Tiny BASIC
     16 U1587 ????						; interpreter using the Interpretive Language (IL)
     17 U1587 ????						; method as described in the first few issues of
     18 U1587 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U1587 ????						; to write various languages simply by changing the
     20 U1587 ????						; IL code rather than the interpreter itself.
     21 U1587 ????						;
     22 U1587 ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U1587 ????						;		* Fixed major bug in findLine that
     24 U1587 ????						;		  caused corrupted lines, crashes, etc.
     25 U1587 ????						;		* If no parameter given to RND, assume
     26 U1587 ????						;		  32766.
     27 U1587 ????						;		* No more error 5 when a program
     28 U1587 ????						;		  reaches the end without an END.
     29 U1587 ????						;
     30 U1587 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     31 U1587 ????						;		 * Add some usefull system level functions
     32 U1587 ????						;		 * allow a larger number of tiny basic formats
     33 U1587 ????						;		 * Add byte at start of line holding length
     34 U1587 ????						;		   for faster execution of goto and gosub
     35 U1587 ????						;		 * Re-added gosub
     36 U1587 ????						;		 * allow ; or , at end if print stmt
     37 U1587 ????						;		   without CRLF being added.
     38 U1587 ????						;		 * Added extended function erase to
     39 U1587 ????						;		   use the extended ctmon65 rm file
     40 U1587 ????						;		 * Fix quoted text to not have to backtrack
     41 U1587 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     42 U1587 ????						;
     43 U1587 ????						; www.corshamtech.com
     44 U1587 ????						; bob@corshamtech.com
     45 U1587 ????						; JustLostInTime@gmail.com
     46 U1587 ????						;
     47 U1587 ????						;=====================================================
     48 U1587 ????						;
     49 U1587 ????						; Create TRUE and FALSE values for conditionals.
     50 U1587 ????						;
     51 U1587 ????
     52 U1587 ????	       00 00	   FALSE      equ	0
     53 U1587 ????	       ff ff ff ff TRUE       equ	~FALSE
     54 U1587 ????						;
     55 U1587 ????						;---------------------------------------------------------
     56 U1587 ????						; One of these must be set to indicate which environment
     57 U1587 ????						; Tiny BASIC will be running in.  Here are the current
     58 U1587 ????						; environments:
     59 U1587 ????						;
     60 U1587 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     61 U1587 ????						; more K of RAM.
     62 U1587 ????						;
     63 U1587 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     64 U1587 ????						; which enhances, without replacing, the standard KIM
     65 U1587 ????						; monitor.  It gives access to routines to save/load files
     66 U1587 ????						; to a micro SD card.
     67 U1587 ????						;
     68 U1587 ????						; CTMON65 is a from-scratch monitor written for the
     69 U1587 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     70 U1587 ????						; easily be ported to other systems.  It has support for
     71 U1587 ????						; using a micro SD card for file storage/retrieval.
     72 U1587 ????						;
     73 U1587 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     74 U1587 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     75 U1587 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     76 U1587 ????						;
     77 U1587 ????						;   Need to define some macros for the dasm assembler
     78 U1587 ????						;
     79 U1587 ????				      MACRO	dw
     80 U1587 ????				      .word	{0}
     81 U1587 ????				      ENDM
     82 U1587 ????
     83 U1587 ????				      MACRO	db
     84 U1587 ????				      .byte	{0}
     85 U1587 ????				      ENDM
     86 U1587 ????
     87 U1587 ????						;
     88 U1587 ????						; If set, include disk functions.
     89 U1587 ????						;
     90 U1587 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     91 U1587 ????						;
     92 U1587 ????						; If ILTRACE is set then dump out the address of every
     93 U1587 ????						; IL opcode before executing it.
     94 U1587 ????						;
     95 U1587 ????	       00 00	   ILTRACE    equ	FALSE
     96 U1587 ????						;
     97 U1587 ????						; If FIXED is set, put the IL code and the user
     98 U1587 ????						; program space at fixed locations in memory.	This is
     99 U1587 ????						; meant only for debugging.
    100 U1587 ????						;
    101 U1587 ????	       00 00	   FIXED      equ	FALSE
    102 U1587 ????						;
    103 U1587 ????						; Sets the arithmetic stack depth.  This is *TINY*
    104 U1587 ????						; BASIC, so keep this small!
    105 U1587 ????						;
    106 U1587 ????	       00 14	   STACKSIZE  equ	20	;number of entries
    107 U1587 ????	       00 28	   ILSTACKSIZE equ	40	;number of entries in ilstack
    108 U1587 ????	       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting max is 85
    109 U1587 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 85 tasks
    110 U1587 ????	       00 14	   TASKCYCLESDEFAULT equ	20	;Default Task Switch 0-255 uses a single byte
    111 U1587 ????						;
    112 U1587 ????						; Common ASCII constants
    113 U1587 ????						;
    114 U1587 ????	       00 07	   BEL	      equ	$07
    115 U1587 ????	       00 08	   BS	      equ	$08
    116 U1587 ????	       00 09	   TAB	      equ	$09
    117 U1587 ????	       00 0a	   LF	      equ	$0A
    118 U1587 ????	       00 0d	   CR	      equ	$0D
    119 U1587 ????	       00 22	   quote      equ	$22
    120 U1587 ????	       00 20	   SPACE      equ	$20
    121 U1587 ????	       00 2c	   COMMA      equ	',
    122 U1587 ????	       00 3b	   SEMICOLON  equ	';
    123 U1587 ????	       00 3a	   COLON      equ	':
    124 U1587 ????	       00 24	   DOLLAR     equ	'$
    125 U1587 ????						;
    126 U1587 ????						; These are error codes
    127 U1587 ????						;
    128 U1587 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    129 U1587 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    130 U1587 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    131 U1587 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    132 U1587 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    133 U1587 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    134 U1587 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    135 U1587 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    136 U1587 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    137 U1587 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    138 U1587 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    139 U1587 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    140 U1587 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    141 U1587 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    142 U1587 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    143 U1587 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    144 U1587 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    145 U1587 ????						;
    146 U1587 ????						;=====================================================
    147 U1587 ????						; Zero page storage.
    148 U1587 ????						;
    149 U1587 ????				      SEG.U	Data
    150 U0040					      org	$0040
    151 U0040
    152 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    153 U0041		       00 00 00 00*variables  ds	26*2	;2 bytes, A-Z
    154 U0041		       00 75	   variablesEnd equ	*	;End of variable space
    155 U0075		       00 00	   ILPC       ds	2	;IL program counter
    156 U0077		       00 00	   dpl	      ds	2
    157 U0079		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
    158 U007b		       00	   tempIlY    ds	1	;Temp IL Y register storage
    159 U007c		       00	   offset     ds	1	;IL Offset to next inst when test fails
    160 U007d		       00	   lineLength ds	1	;Length of current line
    161 U007e							;
    162 U007e							; CURPTR is a pointer to curent BASIC line being
    163 U007e							; executed.  Always points to start of line, CUROFF
    164 U007e							; is the offset to the current character.
    165 U007e							;
    166 U007e		       00 00	   CURPTR     ds	2	;Pointer to current Basic line
    167 U0080		       00	   CUROFF     ds	1	;Current offset in Basic Line
    168 U0081							;
    169 U0081		       00 00	   GOSUBSTACK ds	2	;pointer to gosub stack
    170 U0083							;
    171 U0083
    172 U0083							;
    173 U0083							; R0 and R1 are used for arithmetic operations and
    174 U0083							; general use.
    175 U0083							;
    176 U0083		       00 00	   R0	      ds	2	;arithmetic register 0
    177 U0085		       00 00	   R1	      ds	2	;arithmetic register 1
    178 U0087							;
    179 U0087							; This is zero if in immediate mode, or non-zero
    180 U0087							; if currently running a program.  Any input from
    181 U0087							; the main loop clears this, and the XFER IL
    182 U0087							; statement will set it.
    183 U0087							;
    184 U0087		       00	   RunMode    ds	1	;Basic program is running or stop
    185 U0088							;
    186 U0088							; Used for line insertion/removal.
    187 U0088							;
    188 U0088		       00 00	   FROM       ds	2	;Used for basic prog insert/remove and print text
    189 U008a
    190 U008a							; THE ADDRESS USED BY THE PRINTER FUNCTION
    191 U008a							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    192 U008a							;
    193 U008a		       00 88	   PrtFrom    EQU	FROM
    194 U008a							;
    195 U008a							;Task Cycle Counter and reset count
    196 U008a		       00	   taskCurrentCycles ds	1
    197 U008b		       00	   taskResetValue ds	1
    198 U008c		       00	   taskCount  ds	1	; Count of active tasks
    199 U008d							;
    200 U008d							;=====================================================
    201 U008d							;
    202  1443 ????				      SEG	Code
    203  0200					      org	$0200
    204  0200							;
    205  0200							; Cold start is at $0200.  Warm start is at $0203.
    206  0200							;
    207  0200		       4c 18 02    TBasicCold jmp	cold2	;jump around vectors
    208  0203		       4c bd 02    warm       jmp	warm2	;Entry point for worm restart
    209  0206							;
    210  0206							; These are the user-supplied vectors to I/O routines.
    211  0206							; If you want, you can just patch these in the binary
    212  0206							; file, but it would be better to change the source
    213  0206							; code.
    214  0206							;
    215  0206				  -	      if	KIM
    216  0206				  -OUTCH      jmp	$1ea0	;output char in A
    217  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    218  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    219  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    220  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    221  0206					      endif
    222  0206				  -	      if	XKIM
    223  0206				  -	      include	"xkim.inc"
    224  0206				  -	      SEG	Code
    225  0206				  -OUTCH      jmp	$1ea0
    226  0206				  -GETCH      jmp	xkGETCH
    227  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    228  0206				  -OUTHEX     jmp	xkPRTBYT
    229  0206				  -MONITOR    jmp	extKIM
    230  0206				  -puts       equ	putsil
    231  0206				  -BUFFER_SIZE equ	132
    232  0206					      endif
    233  0206
    234  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 4
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 4
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U00f6 ????				      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 U008d					      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    236  0206					      SEG	Code
    237  0206							;
    238  0206		       4c 0c f0    OUTCH      jmp	cout
    239  0209		       4c 09 f0    GETCH      jmp	cin
    240  020c		       4c 18 f0    CRLF       jmp	crlf
    241  020f		       4c 1b f0    OUTHEX     jmp	HexA
    242  0212		       4c 03 f0    MONITOR    jmp	WARM
    243  0215		       4c 0f f0    ISCHAR     jmp	cstatus
    244  0215		       f0 12	   puts       equ	putsil
    245  0218					      endif
    246  0218							;
    247  0218		       20 12 f0    cold2      jsr	puts
      0  021b					      db	CR,LF
      1  021b		       0d 0a		      .byte.b	CR,LF
      0  021d					      db	"Bob's Tiny BASIC v1.0.2 IRQs"
      1  021d		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0.2 IRQs"
      0  0239					      db	CR,LF
      1  0239		       0d 0a		      .byte.b	CR,LF
      0  023b					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  023b		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  0269					      db	CR,LF,0
      1  0269		       0d 0a 00 	      .byte.b	CR,LF,0
    253  026c							;
    254  026c		       20 6a 0f 	      jsr	GetSizes	;setup the free space available
    255  026f		       ad 81 15 	      lda	HighMem
    256  0272		       e9 3c		      sbc	#GOSUBSTACKSIZE*3
    257  0274		       85 81		      sta	GOSUBSTACK
    258  0276		       ad 82 15 	      lda	HighMem+1
    259  0279		       e9 00		      sbc	#0
    260  027b		       85 82		      sta	GOSUBSTACK+1
    261  027d		       a9 08		      lda	#IL&$ff
    262  027f		       85 75		      sta	ILPC
    263  0281		       a9 11		      lda	#IL>>8
    264  0283		       85 76		      sta	ILPC+1
    265  0285							;
    266  0285		       a9 87		      lda	#ProgramStart&$ff	;user prog
    267  0287		       8d 7f 15 	      sta	PROGRAMEND
    268  028a		       a9 15		      lda	#ProgramStart>>8
    269  028c		       8d 80 15 	      sta	PROGRAMEND+1
    270  028f							;
    271  028f							; Initialize the pseudo-random number sequence...
    272  028f							;
    273  028f		       a9 5a		      lda	#$5a
    274  0291		       8d 79 15 	      sta	rtemp1
    275  0294		       a9 9d		      lda	#%10011101
    276  0296		       8d 7a 15 	      sta	random
    277  0299		       a9 5b		      lda	#%01011011
    278  029b		       8d 7b 15 	      sta	random+1
    279  029e							;
    280  029e							;   Insert a Basic irq handler for the basic Language
    281  029e		       a9 ab		      lda	#ServiceIrq&$ff
    282  02a0		       8d 00 df 	      sta	IRQvec
    283  02a3		       a9 02		      lda	#ServiceIrq>>8
    284  02a5		       8d 01 df 	      sta	IRQvec+1
    285  02a8		       4c ca 02 	      jmp	coldtwo
    286  02ab
    287  02ab							;
    288  02ab							; This is the Basic IRQ handler
    289  02ab		       48	   ServiceIrq pha
    290  02ac		       ad 44 14 	      lda	IRQStatus
    291  02af		       f0 0a		      BEQ	RetIrq
    292  02b1		       ad 45 14 	      lda	IRQPending
    293  02b4		       d0 05		      bne	RetIrq
    294  02b6		       a9 01		      lda	#1
    295  02b8		       8d 45 14 	      sta	IRQPending
    296  02bb		       68	   RetIrq     pla
    297  02bc		       40		      rti
    298  02bd							;
    299  02bd							;
    300  02bd							; This is the warm start entry point
    301  02bd							;
    302  02bd		       20 0c 02    warm2      jsr	CRLF
    303  02c0		       ad 74 15 	      lda	errGoto
    304  02c3		       85 75		      sta	ILPC
    305  02c5		       ad 75 15 	      lda	errGoto+1
    306  02c8		       85 76		      sta	ILPC+1
    307  02ca							;
    308  02ca							; And continue with both starts here
    309  02ca							;
    310  02ca		       20 9d 0f    coldtwo    jsr	SetOutConsole
    311  02cd							;
    312  02cd							; The ILTrace flag is now run-time settable.
    313  02cd							;
    314  02cd		       a9 00		      lda	#ILTRACE&$ff
    315  02cf		       85 40		      sta	ILTrace
    316  02d1							;
    317  02d1		       a9 00		      lda	#0
    318  02d3		       85 87		      sta	RunMode
    319  02d5		       8d ec 14 	      sta	LINBUF
    320  02d8							; Clear everything from the stacks
    321  02d8		       8d 99 14 	      sta	mathStackPtr
    322  02db		       8d ea 14 	      sta	retStackPtr
    323  02de		       8d eb 14 	      sta	GoSubStackPtr
    324  02e1							;
    325  02e1		       a9 ec		      lda	#LINBUF&$ff
    326  02e3		       85 7e		      sta	CURPTR
    327  02e5		       a9 14		      lda	#LINBUF>>8
    328  02e7		       85 7f		      sta	CURPTR+1	;fall through...
    329  02e9
    330  02e9							;=====================================================
    331  02e9							; This is the top of the IL interpreter.  This fetches
    332  02e9							; and executes the instruction currently pointed to
    333  02e9							; by ILPC and adjusts ILPC to point to the next
    334  02e9							; instruction to execute.
    335  02e9							;
    336  02e9		       a5 40	   NextIL     lda	ILTrace
    337  02eb		       f0 03		      beq	NextIL2
    338  02ed		       20 25 0f 	      jsr	dbgLine
    339  02f0		       a4 80	   NextIL2    ldy	CUROFF
    340  02f2		       20 1c 0f 	      jsr	SkipSpaces
    341  02f5		       84 80		      sty	CUROFF
    342  02f7							;
    343  02f7		       20 00 0c    NextILStr  jsr	getILByte
    344  02fa							;
    345  02fa							; When the handler is called, these are the conditions
    346  02fa							; of several important items:
    347  02fa							;
    348  02fa							;    (ILPC) will point to the byte AFTER the IL
    349  02fa							;    opcode being executed.
    350  02fa							;
    351  02fa							;    (CURPTR),CUROFF will point to the start of the
    352  02fa							;    next word in the input buffer.  Ie, the next word
    353  02fa							;    in the user program.
    354  02fa							;
    355  02fa		       0a		      asl
    356  02fb		       c9 8a		      cmp	#ILTBLend-ILTBL+2
    357  02fd		       90 33		      bcc	ILgood
    358  02ff							;
    359  02ff							; This handles an illegal IL opcode.  This is serious
    360  02ff							; and there's no way to recover.
    361  02ff							;
    362  02ff		       20 12 f0    ILbad      jsr	puts
      0  0302					      db	CR,LF
      1  0302		       0d 0a		      .byte.b	CR,LF
      0  0304					      db	"Illegal IL "
      1  0304		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  030f					      db	0
      1  030f		       00		      .byte.b	0
    366  0310							;
    367  0310							; Well this is awkward, we need to back up the IL
    368  0310							; by one since it no longer points to the current
    369  0310							; opcode.
    370  0310							;
    371  0310		       20 0d 0c 	      jsr	decIL
    372  0313							;
    373  0313		       a0 00		      ldy	#0
    374  0315		       b1 75		      lda	(ILPC),y
    375  0317		       20 0f 02 	      jsr	OUTHEX
    376  031a		       20 12 f0 	      jsr	puts
      0  031d					      db	" at ",0
      1  031d		       20 61 74 20*	      .byte.b	" at ",0
    378  0322		       a5 76		      lda	ILPC+1
    379  0324		       20 0f 02 	      jsr	OUTHEX
    380  0327		       a5 75		      lda	ILPC
    381  0329		       20 0f 02 	      jsr	OUTHEX
    382  032c		       20 0c 02 	      jsr	CRLF
    383  032f		       4c 12 02 	      jmp	MONITOR
    384  0332							;
    385  0332							; Just jump to the address (ILPC),y.  Have to do
    386  0332							; some goofy stuff.
    387  0332							;
    388  0332		       a8	   ILgood     tay		;move index into Y
    389  0333		       b9 40 03 	      lda	ILTBL,y
    390  0336		       85 77		      sta	dpl
    391  0338		       b9 41 03 	      lda	ILTBL+1,y
    392  033b		       85 78		      sta	dpl+1
    393  033d		       6c 77 00 	      jmp	(dpl)	;go to handler
    394  0340							;
    395  0340							;=====================================================
    396  0340							; This is the IL jump table.  The IL opcode is
    397  0340							; mulitplied by two, then looked-up in this table.
    398  0340							; There is absolutely nothing special about the order
    399  0340							; of entries here... they all decode at exactly the
    400  0340							; same speed.	However the entry number must match the
    401  0340							; values in IL.inc.
    402  0340							;
      0  0340				   ILTBL      dw	iXINIT	;0
      1  0340		       f1 03		      .word.w	iXINIT
      0  0342					      dw	iDONE	;1
      1  0342		       2f 04		      .word.w	iDONE
      0  0344					      dw	iPRS	;2
      1  0344		       4b 04		      .word.w	iPRS
      0  0346					      dw	iPRN	;3
      1  0346		       55 04		      .word.w	iPRN
      0  0348					      dw	iSPC	;4
      1  0348		       5e 04		      .word.w	iSPC
      0  034a					      dw	iNLINE	;5
      1  034a		       40 08		      .word.w	iNLINE
      0  034c					      dw	iNXT	;6
      1  034c		       66 04		      .word.w	iNXT
      0  034e					      dw	iXFER	;7
      1  034e		       92 04		      .word.w	iXFER
      0  0350					      dw	iSAV	;8
      1  0350		       bf 04		      .word.w	iSAV
      0  0352					      dw	iRSTR	;9
      1  0352		       e0 04		      .word.w	iRSTR
      0  0354					      dw	iCMPR	;10
      1  0354		       ec 04		      .word.w	iCMPR
      0  0356					      dw	iINNUM	;11
      1  0356		       4b 05		      .word.w	iINNUM
      0  0358					      dw	iFIN	;12
      1  0358		       75 05		      .word.w	iFIN
      0  035a					      dw	iERR	;13
      1  035a		       86 05		      .word.w	iERR
      0  035c					      dw	iADD	;14
      1  035c		       f7 05		      .word.w	iADD
      0  035e					      dw	iSUB	;15
      1  035e		       0d 06		      .word.w	iSUB
      0  0360					      dw	iNEG	;16
      1  0360		       23 06		      .word.w	iNEG
      0  0362					      dw	iMUL	;17
      1  0362		       3b 06		      .word.w	iMUL
      0  0364					      dw	iDIV	;18
      1  0364		       75 06		      .word.w	iDIV
      0  0366					      dw	iSTORE	;19
      1  0366		       d5 06		      .word.w	iSTORE
      0  0368					      dw	iIND	;20
      1  0368		       e8 06		      .word.w	iIND
      0  036a					      dw	iLST	;21
      1  036a		       1a 07		      .word.w	iLST
      0  036c					      dw	iINIT	;22
      1  036c		       c8 03		      .word.w	iINIT
      0  036e					      dw	iGETLINE	;23
      1  036e		       79 07		      .word.w	iGETLINE
      0  0370					      dw	iINSRT	;24
      1  0370		       85 07		      .word.w	iINSRT
      0  0372					      dw	iRTN	;25
      1  0372		       3a 08		      .word.w	iRTN
      0  0374					      dw	MONITOR	;26
      1  0374		       12 02		      .word.w	MONITOR
      0  0376					      dw	iLIT	;27
      1  0376		       53 08		      .word.w	iLIT
      0  0378					      dw	iCALL	;28
      1  0378		       46 08		      .word.w	iCALL
      0  037a					      dw	iJMP	;29
      1  037a		       49 08		      .word.w	iJMP
      0  037c					      dw	iVINIT	;30
      1  037c		       60 08		      .word.w	iVINIT
      0  037e					      dw	iERRGOTO	;31
      1  037e		       6e 08		      .word.w	iERRGOTO
      0  0380					      dw	iTST	;32
      1  0380		       7a 08		      .word.w	iTST
      0  0382					      dw	iTSTV	;33
      1  0382		       ff 08		      .word.w	iTSTV
      0  0384					      dw	iTSTL	;34
      1  0384		       29 09		      .word.w	iTSTL
      0  0386					      dw	iTSTN	;35
      1  0386		       43 09		      .word.w	iTSTN
      0  0388					      dw	iFREE	;36
      1  0388		       0f 0a		      .word.w	iFREE
      0  038a					      dw	iRANDOM	;37
      1  038a		       18 0a		      .word.w	iRANDOM
      0  038c					      dw	iABS	;38
      1  038c		       df 0a		      .word.w	iABS
    442  038e							;
    443  038e							; Disk functions.  There must be pointers
    444  038e							; to functions even if no disk is supported.
    445  038e							; Makes things easier in IL.inc.
    446  038e							;
    447  038e					      if	DISK_ACCESS
      0  038e					      dw	iOPENREAD	;39
      1  038e		       e3 0f		      .word.w	iOPENREAD
      0  0390					      dw	iOPENWRITE	;40
      1  0390		       37 10		      .word.w	iOPENWRITE
      0  0392					      dw	iDCLOSE	;41
      1  0392		       bb 10		      .word.w	iDCLOSE
      0  0394					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0394		       56 10		      .word.w	iDGETLINE
      0  0396					      dw	iDLIST	;43 Did you remeber your towel?
      1  0396		       b5 10		      .word.w	iDLIST
      0  0398					      dw	iDDIR	;44
      1  0398		       90 10		      .word.w	iDDIR
      0  039a					      dw	iRMFILE	;45
      1  039a		       11 10		      .word.w	iRMFILE
    455  039c				  -	      else
    456  039c				  -	      dw	NextIL	;39
    457  039c				  -	      dw	NextIL	;40
    458  039c				  -	      dw	NextIL	;41
    459  039c				  -	      dw	NextIL	;42
    460  039c				  -	      dw	NextIL	;43
    461  039c				  -	      dw	NextIL	;44
    462  039c				  -	      dw	NextIL	;45
    463  039c					      endif
    464  039c							;
      0  039c					      dw	iCLEARSCREEN	;46
      1  039c		       d8 0f		      .word.w	iCLEARSCREEN
      0  039e					      dw	iPOKEMEMORY	;47
      1  039e		       78 0a		      .word.w	iPOKEMEMORY
      0  03a0					      dw	iPEEKMEMORY	;48
      1  03a0		       8d 0a		      .word.w	iPEEKMEMORY
      0  03a2					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  03a2		       bf 08		      .word.w	iTSTLET
      0  03a4					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  03a4		       de 08		      .word.w	iTSTDONE
      0  03a6					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  03a6		       ba 0a		      .word.w	iGETCHAR
      0  03a8					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  03a8		       d4 0a		      .word.w	iPUTCHAR
      0  03aa					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  03aa		       a3 0a		      .word.w	iCallFunc
      0  03ac					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  03ac		       39 05		      .word.w	iBranch
      0  03ae					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  03ae		       a3 08		      .word.w	iTSTStr
      0  03b0					      dw	iSetIrq	;56	   sets the irq handler
      1  03b0		       f9 0a		      .word.w	iSetIrq
      0  03b2					      dw	iTstIrq	;57	   test if irq is pending
      1  03b2		       86 09		      .word.w	iTstIrq
      0  03b4					      dw	iRET	;58	   return from interupt
      1  03b4		       ce 04		      .word.w	iRET
      0  03b6					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  03b6		       5c 05		      .word.w	iINSTR
      0  03b8					      dw	iMOD	;60	   returns remainder of division
      1  03b8		       7e 06		      .word.w	iMOD
      0  03ba					      dw	iTaskSwitch	;61	   switch to the next BASIC program task
      1  03ba		       bd 09		      .word.w	iTaskSwitch
      0  03bc					      dw	iTaskSet	;62	   sets a line number for the start of a task
      1  03bc		       30 0b		      .word.w	iTaskSet
      0  03be					      dw	iETask	;63	   Terminates a task
      1  03be		       c4 0b		      .word.w	iETask
      0  03c0					      dw	iNTask	;64	   goto next task
      1  03c0		       bd 0b		      .word.w	iNTask
      0  03c2					      dw	iArray	;65	   Allow Variable to have a subscript
      1  03c2		       f8 06		      .word.w	iArray
      0  03c4					      dw	iTaskKill	;66	   kill a running task
      1  03c4		       b5 0b		      .word.w	iTaskKill
      0  03c6					      dw	iTaskStat	;67	   return the state of a task PID
      1  03c6		       87 0b		      .word.w	iTaskStat
    487  03c8
    488  03c8		       03 c8	   ILTBLend   equ	*
    489  03c8							;
    490  03c8							;=====================================================
    491  03c8							;=====================================================
    492  03c8							;=====================================================
    493  03c8							; This marks the start of the handlers for IL opcodes.
    494  03c8							;=====================================================
    495  03c8							;=====================================================
    496  03c8							;=====================================================
    497  03c8							;
    498  03c8							;
    499  03c8		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    500  03ca		       8d ea 14 	      sta	retStackPtr
    501  03cd		       8d eb 14 	      sta	GoSubStackPtr
    502  03d0							;
    503  03d0		       a9 87		      lda	#ProgramStart&$ff	;user prog
    504  03d2		       85 7e		      sta	CURPTR
    505  03d4		       8d 49 14 	      sta	taskTable+1
    506  03d7		       8d 7f 15 	      sta	PROGRAMEND
    507  03da		       a9 15		      lda	#ProgramStart>>8
    508  03dc		       85 7f		      sta	CURPTR+1
    509  03de		       8d 4a 14 	      sta	taskTable+2
    510  03e1		       8d 80 15 	      sta	PROGRAMEND+1
    511  03e4		       a9 01		      lda	#1
    512  03e6		       8d 48 14 	      sta	taskTable	;Mark the first slot as active
    513  03e9		       85 8c		      sta	taskCount	;there is always one task / Main task
    514  03eb		       a9 14		      lda	#TASKCYCLESDEFAULT
    515  03ed		       85 8b		      sta	taskResetValue
    516  03ef		       85 8a		      sta	taskCurrentCycles	; set up the task switch counts
    517  03f1							;
    518  03f1							; fall into XINIT...
    519  03f1							;
    520  03f1							;=====================================================
    521  03f1							; This initializes for the start of the next line of
    522  03f1							; BASIC text.
    523  03f1							;
    524  03f1		       78	   iXINIT     sei		;ensure interupts are off
    525  03f2		       a9 00		      lda	#0
    526  03f4		       8d 99 14 	      sta	mathStackPtr	;clear math stack
    527  03f7		       8d 70 14 	      sta	taskPtr	;Set the first slot
    528  03fa		       8d 45 14 	      sta	IRQPending	; reset the irq pending
    529  03fd		       8d 44 14 	      sta	IRQStatus	; Make sure irqs are off
    530  0400		       a9 01		      lda	#1
    531  0402		       85 8c		      sta	taskCount	;Number of actual tasks
    532  0404		       20 18 04 	      jsr	taskClear	;Clear the task table
    533  0407		       4c e9 02    goodExit   jmp	NextIL
    534  040a							;
    535  040a							;=====================================================
    536  040a							; This check if the escape key has been entered
    537  040a							; then changes out of run mode. z Set if esc found
    538  040a				   BreakSet
    539  040a		       20 15 02 	      jsr	ISCHAR
    540  040d		       f0 06		      beq	BreakNo
    541  040f		       20 09 02 	      jsr	GETCH
    542  0412		       c9 1b		      cmp	#$1B
    543  0414		       60		      rts
    544  0415				   BreakNo
    545  0415		       a9 01		      lda	#1
    546  0417		       60		      rts
    547  0418							;
    548  0418							;=====================================================
    549  0418							; Clear the task table
    550  0418				   taskClear
    551  0418		       98		      tya
    552  0419		       48		      pha
    553  041a		       a0 04		      ldy	#4
    554  041c		       a9 00		      lda	#0
    555  041e		       c0 28	   taskClearLoop cpy	#TASKCOUNT*4
    556  0420		       f0 0a		      beq	taskClearDone
    557  0422		       99 48 14 	      sta	taskTable,y
    558  0425		       c8		      iny
    559  0426		       c8		      iny
    560  0427		       c8		      iny
    561  0428		       c8		      iny
    562  0429		       4c 1e 04 	      jmp	taskClearLoop
    563  042c		       68	   taskClearDone pla
    564  042d		       a8		      tay
    565  042e		       60		      rts
    566  042f
    567  042f							;
    568  042f							;=====================================================
    569  042f							; Verify there is nothing else on this input line.
    570  042f							; If there is, generate an error.
    571  042f							;
    572  042f		       a4 80	   iDONE      ldy	CUROFF
    573  0431		       20 1c 0f 	      jsr	SkipSpaces
    574  0434		       b1 7e		      lda	(CURPTR),y
    575  0436		       f0 10		      beq	doneadv
    576  0438		       c9 3a		      cmp	#COLON	; is it a  ':' or eol
    577  043a		       d0 05		      bne	idoneErr
    578  043c		       84 80		      sty	CUROFF
    579  043e		       4c e9 02 	      jmp	NextIL	; continue on this line
    580  0441
    581  0441				   idoneErr
    582  0441		       a2 04		      ldx	#ERR_EXTRA_STUFF
    583  0443		       a9 00		      lda	#0
    584  0445		       4c 89 05 	      jmp	iErr2
    585  0448							;
    586  0448							; Advance to the next line
    587  0448							;
    588  0448				   doneadv
    589  0448							;		 jsr	 FindNext2
    590  0448		       4c e9 02 	      jmp	NextIL
    591  044b							;
    592  044b							;=====================================================
    593  044b							; Print the string until a closing quote
    594  044b							;
    595  044b		       a4 80	   iPRS       ldy	CUROFF
    596  044d							;
    597  044d							; Odd logic here.  The main loop skipped any leading
    598  044d							; whitespace inside the quoted text, so move back to
    599  044d							; the quote, then move forward again.
    600  044d							;
    601  044d		       20 ab 0f 	      jsr	PrtQuoted
    602  0450		       84 80		      sty	CUROFF
    603  0452		       4c e9 02 	      jmp	NextIL
    604  0455							;
    605  0455							;=====================================================
    606  0455							; Pop the top off the stack and print it as a signed
    607  0455							; decimal number.
    608  0455							;
    609  0455		       20 53 0e    iPRN       jsr	popR0
    610  0458		       20 a5 0c 	      jsr	PrintDecimal
    611  045b		       4c e9 02 	      jmp	NextIL
    612  045e							;
    613  045e							;=====================================================
    614  045e							; Space to next zone.	Currently the code does not
    615  045e							; keep track of which column the output is on, so
    616  045e							; just print a tab.
    617  045e							;
    618  045e		       a9 09	   iSPC       lda	#TAB
    619  0460		       20 06 02 	      jsr	OUTCH
    620  0463		       4c e9 02 	      jmp	NextIL
    621  0466							;
    622  0466							;=====================================================
    623  0466							; If in immediate mode, jump to the address following
    624  0466							; the NXT instruction.  Else move to the next line of
    625  0466							; user code and continue.
    626  0466							;
    627  0466		       a5 87	   iNXT       lda	RunMode
    628  0468		       d0 03		      bne	iNxtRun	;in run mode
    629  046a							;
    630  046a							; Get address and jump to it.
    631  046a							;
    632  046a		       4c 49 08 	      jmp	iJMP
    633  046d							;
    634  046d				   iNxtRun
    635  046d		       a4 80		      ldy	CUROFF
    636  046f		       20 1c 0f 	      jsr	SkipSpaces
    637  0472		       b1 7e		      lda	(CURPTR),y
    638  0474		       c9 3a		      cmp	#COLON
    639  0476		       d0 09		      bne	iNxtRunGo
    640  0478		       c8		      iny
    641  0479		       20 1c 0f 	      jsr	SkipSpaces
    642  047c		       84 80		      sty	CUROFF
    643  047e		       4c 8c 04 	      jmp	iNxtRun2
    644  0481
    645  0481				   iNxtRunGo
    646  0481		       20 86 0c 	      jsr	FindNextLine
    647  0484		       20 98 0c 	      jsr	AtEnd
    648  0487		       d0 03		      bne	iNxtRun2	;not at end
    649  0489							;
    650  0489							; At the end of the program.  Pretend an END statement
    651  0489							; was found.
    652  0489							;
    653  0489		       4c 75 05    iFINv      jmp	iFIN
    654  048c							;
    655  048c		       20 fc 0b    iNxtRun2   jsr	getILWord	;ignore next word
    656  048f		       4c e9 02 	      jmp	NextIL
    657  0492							;
    658  0492							;=====================================================
    659  0492							; XFER takes the number on top of the stack and looks
    660  0492							; for that line in the program, or the next line
    661  0492							; higher.  Ie, if it's 1 but there is no line 1, then
    662  0492							; find the next one after that.
    663  0492							;
    664  0492		       20 53 0e    iXFER      jsr	popR0
    665  0495		       20 43 0c 	      jsr	findLine
    666  0498		       20 98 0c    iXFER2     jsr	AtEnd	;at end of user program?
    667  049b		       f0 ec		      beq	iFINv
    668  049d		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    669  049f		       84 80		      sty	CUROFF
    670  04a1		       a9 ff		      lda	#$ff
    671  04a3		       85 87		      sta	RunMode
    672  04a5							;
    673  04a5							; Transfer IL to STMT.  I don't like having this
    674  04a5							; hard-coded; fix it.
    675  04a5							;
    676  04a5		       a9 16		      lda	#STMT&$ff
    677  04a7		       85 75		      sta	ILPC
    678  04a9		       a9 11		      lda	#STMT>>8
    679  04ab		       85 76		      sta	ILPC+1
    680  04ad		       4c e9 02 	      jmp	NextIL
    681  04b0							;
    682  04b0							; Run
    683  04b0							;
    684  04b0				   iXferok
    685  04b0		       a9 ff		      lda	#$ff
    686  04b2		       85 87		      sta	RunMode	;we're running
    687  04b4							;
    688  04b4							; Need a more elegant way to do this
    689  04b4							;
    690  04b4		       a9 16		      lda	#STMT&$ff
    691  04b6		       85 75		      sta	ILPC
    692  04b8		       a9 11		      lda	#STMT>>8
    693  04ba		       85 76		      sta	ILPC+1
    694  04bc		       4c e9 02 	      jmp	NextIL
    695  04bf							;
    696  04bf							;=====================================================
    697  04bf							; Save the pointer to the next line to the call stack.
    698  04bf							;
    699  04bf		       20 1c 0e    iSAV       jsr	pushLN
    700  04c2		       b0 03		      bcs	iSAVErr
    701  04c4		       4c e9 02 	      jmp	NextIL
    702  04c7
    703  04c7		       a2 0c	   iSAVErr    ldx	#12
    704  04c9		       a9 00	   iSAVErr2   lda	#0
    705  04cb		       4c 89 05 	      jmp	iErr2
    706  04ce
    707  04ce							;
    708  04ce							;=====================================================
    709  04ce							; Pop the next line from the call stack.
    710  04ce							;
    711  04ce		       20 66 0e    iRET       jsr	popLN
    712  04d1		       b0 f4		      bcs	iSAVErr
    713  04d3		       a0 03		      ldy	#3
    714  04d5		       84 80		      sty	CUROFF
    715  04d7		       a9 00		      lda	#0
    716  04d9		       8d 45 14 	      sta	IRQPending
    717  04dc		       58		      cli
    718  04dd		       4c e9 02 	      jmp	NextIL
    719  04e0							;
    720  04e0							;=====================================================
    721  04e0							; Return from IL program call
    722  04e0							;
    723  04e0		       20 66 0e    iRSTR      jsr	popLN
    724  04e3		       b0 e2		      bcs	iSAVErr
    725  04e5		       4c e9 02 	      jmp	NextIL
    726  04e8
    727  04e8		       a2 0b	   iRSTRErr   ldx	#11
    728  04ea		       d0 dd		      bne	iSAVErr2
    729  04ec							;
    730  04ec							;=====================================================
    731  04ec							; Compare items on stack.  Okay, so on input there are
    732  04ec							; three things on the stack
    733  04ec							;
    734  04ec							;    EXPR2 <- Top of stack
    735  04ec							;    OP    <- relational operator, next on stack
    736  04ec							;    EXPR1 <- last item on stack
    737  04ec							;
    738  04ec							; Comparison is: EXPR1 <operator> EXPR2
    739  04ec							;
    740  04ec							; Operator is one of...
    741  04ec							;
    742  04ec							;    2 is =
    743  04ec							;    1 is <
    744  04ec							;    3 is <=
    745  04ec							;    5 is <>
    746  04ec							;    4 is >
    747  04ec							;    6 is >=
    748  04ec							;
    749  04ec							; Those are bit-mapped:
    750  04ec							;
    751  04ec							;    xxxxxGEL
    752  04ec							;
    753  04ec							;    G = Greater than
    754  04ec							;    E = Equal
    755  04ec							;    L = Less than
    756  04ec							;
    757  04ec							; If the comparison is false, do a NXT, ie, move to the
    758  04ec							; next line and continue.  If true, continue executing
    759  04ec							; on this line.
    760  04ec							;
    761  04ec		       00 01	   REL_LT     equ	%001
    762  04ec		       00 02	   REL_EQUAL  equ	%010
    763  04ec		       00 04	   REL_GT     equ	%100
    764  04ec							;
    765  04ec		       20 8a 0e    iCMPR      jsr	popR1
    766  04ef		       20 9d 0e 	      jsr	popMQ	;operator in MQ
    767  04f2		       20 53 0e 	      jsr	popR0
    768  04f5							;
    769  04f5							; See if they are equal or not
    770  04f5							;
    771  04f5		       a5 83		      lda	R0
    772  04f7		       c5 85		      cmp	R1
    773  04f9		       d0 0a		      bne	iCMPRnoteq	;try not equal
    774  04fb		       a5 84		      lda	R0+1
    775  04fd		       c5 86		      cmp	R1+1
    776  04ff		       d0 04		      bne	iCMPRnoteq
    777  0501							;
    778  0501							; Equal, set the flag in MQ+1
    779  0501							;
    780  0501		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    781  0503		       d0 14		      bne	iCMPcom	;Exit it is equal
    782  0505							;
    783  0505							; See if EXPR1 (R0) < EXPR2 (R1)
    784  0505							; See www.6502.org/tutorials/compare_beyond.html
    785  0505							;
    786  0505				   iCMPRnoteq
    787  0505		       a5 83		      lda	R0
    788  0507		       c5 85		      cmp	R1
    789  0509		       a5 84		      lda	R0+1
    790  050b		       e5 86		      sbc	R1+1
    791  050d		       50 02		      bvc	iCMPR_2
    792  050f		       49 80		      eor	#$80
    793  0511		       30 04	   iCMPR_2    bmi	iCMPlt
    794  0513		       a9 04		      lda	#REL_GT
    795  0515		       d0 02		      bne	iCMPcom
    796  0517		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    797  0519
    798  0519		       0d 77 15    iCMPcom    ora	MQ+1	; or with original mask
    799  051c							;
    800  051c							; Now compare the end result with what the caller
    801  051c							; was looking for.
    802  051c							;
    803  051c		       2d 76 15 	      and	MQ
    804  051f		       f0 0a		      beq	iCMPno	; no match
    805  0521		       a9 01		      lda	#1
    806  0523		       85 83		      sta	R0
    807  0525		       d0 08		      bne	iCMPDone
    808  0527							;
    809  0527							; R0 > R1
    810  0527							;
    811  0527		       a9 04	   iCMPgt     lda	#REL_GT
    812  0529		       d0 ee		      bne	iCMPcom
    813  052b				   iCMPno
    814  052b		       a9 00		      lda	#0
    815  052d		       85 83		      sta	R0
    816  052f
    817  052f				   iCMPDone
    818  052f		       a9 00		      lda	#0
    819  0531		       85 84		      sta	R0+1
    820  0533		       20 09 0e 	      jsr	pushR0
    821  0536		       4c e9 02 	      jmp	NextIL
    822  0539							;
    823  0539							; if Not a match, so jump to the next line of code.
    824  0539							; Branches based upon value on top of the stack
    825  0539				   iBranch
    826  0539		       20 53 0e 	      jsr	popR0
    827  053c		       a5 83		      lda	R0
    828  053e		       05 84		      ora	R0+1
    829  0540		       f0 03		      beq	iBranchFalse	; not true
    830  0542		       4c e9 02 	      jmp	NextIL	; It is true if any value not zero
    831  0545							;
    832  0545				   iBranchFalse
    833  0545		       20 86 0c 	      jsr	FindNextLine
    834  0548		       4c 98 04 	      jmp	iXFER2
    835  054b							;
    836  054b							;=====================================================
    837  054b							; Get a line of text from the user, convert to a
    838  054b							; number, leave on top of stack.
    839  054b							;
    840  054b				   iINNUM
    841  054b		       20 1c 0e 	      jsr	pushLN
    842  054e							;
    843  054e		       a9 3f		      lda	#'?
    844  0550		       20 88 0d 	      jsr	GetLine
    845  0553		       20 11 0d 	      jsr	getDecimal
    846  0556		       20 09 0e 	      jsr	pushR0	;put onto stack
    847  0559							;
    848  0559		       4c 6f 05 	      jmp	ExitIn
    849  055c							;
    850  055c							;=====================================================
    851  055c							; Get a line of text from the user, convert to a
    852  055c							; String , leave on top of stack. up to 2 characters
    853  055c							;
    854  055c				   iINSTR
    855  055c		       20 1c 0e 	      jsr	pushLN
    856  055f		       a9 3f		      lda	#'?
    857  0561		       20 88 0d 	      jsr	GetLine
    858  0564		       b1 7e		      lda	(CURPTR),y
    859  0566		       85 83		      sta	R0
    860  0568		       a9 00		      lda	#0
    861  056a		       85 84		      sta	R0+1
    862  056c		       20 09 0e 	      jsr	pushR0	;put onto stack
    863  056f				   ExitIn
    864  056f		       20 66 0e 	      jsr	popLN
    865  0572		       4c e9 02 	      jmp	NextIL
    866  0575							;
    867  0575							;
    868  0575							;=====================================================
    869  0575							; Stop the currently running program.	Actually very
    870  0575							; simple to do... clear the RunMode flag, then set the
    871  0575							; ILPC to the standard handler and continue running.
    872  0575							;
    873  0575		       a9 00	   iFIN       lda	#0
    874  0577		       85 87		      sta	RunMode
    875  0579							;
    876  0579		       ad 74 15 	      lda	errGoto
    877  057c		       85 75		      sta	ILPC
    878  057e		       ad 75 15 	      lda	errGoto+1
    879  0581		       85 76		      sta	ILPC+1
    880  0583		       4c e9 02 	      jmp	NextIL
    881  0586							;
    882  0586							;=====================================================
    883  0586							; Handle the ERR opcode.  Following the instruction is
    884  0586							; a 16 bit error number.  Print an error message, and
    885  0586							; if we're in run mode, print the line number.  Stop
    886  0586							; program execution and return to the initial state.
    887  0586							;
    888  0586		       20 fc 0b    iERR       jsr	getILWord	;get err code
    889  0589							;
    890  0589							; Enter here with the error code in X (LSB) and A (MSB).
    891  0589							;
    892  0589		       86 83	   iErr2      stx	R0
    893  058b		       85 84		      sta	R0+1
    894  058d							;
    895  058d		       20 12 f0 	      jsr	puts
      0  0590					      db	"Error ",0
      1  0590		       45 72 72 6f*	      .byte.b	"Error ",0
    897  0597		       20 a5 0c 	      jsr	PrintDecimal
    898  059a							;
    899  059a		       a5 87		      lda	RunMode	;running?
    900  059c		       f0 40		      beq	iERR3	;nope
    901  059e		       20 12 f0 	      jsr	puts
      0  05a1					      db	" at line ",0
      1  05a1		       20 61 74 20*	      .byte.b	" at line ",0
    903  05ab		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    904  05ad				   iErr2a
    905  05ad		       b1 7e		      lda	(CURPTR),y
    906  05af		       85 83		      sta	R0
    907  05b1		       c8		      iny
    908  05b2		       b1 7e		      lda	(CURPTR),y
    909  05b4		       85 84		      sta	R0+1
    910  05b6		       20 a5 0c 	      jsr	PrintDecimal
    911  05b9		       20 12 f0 	      jsr	puts
      0  05bc					      db	" at ",0
      1  05bc		       20 61 74 20*	      .byte.b	" at ",0
    913  05c1		       a9 00		      lda	#0
    914  05c3		       85 84		      sta	R0+1
    915  05c5		       a5 80		      lda	CUROFF
    916  05c7		       18		      clc
    917  05c8		       e9 03		      sbc	#3
    918  05ca		       85 83		      sta	R0
    919  05cc		       20 a5 0c 	      jsr	PrintDecimal
    920  05cf		       20 12 f0 	      jsr	puts
      0  05d2					      db	" = $",0
      1  05d2		       20 3d 20 24*	      .byte.b	" = $",0
    922  05d7		       a4 80		      ldy	CUROFF
    923  05d9		       b1 7e		      lda	(CURPTR),y
    924  05db		       20 0f 02 	      jsr	OUTHEX
    925  05de							;
    926  05de		       20 0c 02    iERR3      jsr	CRLF
    927  05e1		       a9 00		      lda	#0
    928  05e3		       85 87		      sta	RunMode	;fall through...
    929  05e5							;
    930  05e5							;=====================================================
    931  05e5							; Reset the IL to be back at the idle loop.  Does not
    932  05e5							; clear variables so the user can see what state
    933  05e5							; the program is in.
    934  05e5							;
    935  05e5		       a9 00	   ResetIL    lda	#0
    936  05e7		       8d ea 14 	      sta	retStackPtr
    937  05ea		       ad 74 15 	      lda	errGoto
    938  05ed		       85 75		      sta	ILPC
    939  05ef		       ad 75 15 	      lda	errGoto+1
    940  05f2		       85 76		      sta	ILPC+1
    941  05f4		       4c e9 02 	      jmp	NextIL
    942  05f7							;
    943  05f7							;=====================================================
    944  05f7							; Pop two items off stack, add them, then place the
    945  05f7							; result back onto the stack.
    946  05f7							;
    947  05f7		       20 53 0e    iADD       jsr	popR0
    948  05fa		       20 8a 0e 	      jsr	popR1
    949  05fd		       18		      clc
    950  05fe		       a5 83		      lda	R0
    951  0600		       65 85		      adc	R1
    952  0602		       85 83		      sta	R0
    953  0604		       a5 84		      lda	R0+1
    954  0606		       65 86		      adc	R1+1
    955  0608		       85 84		      sta	R0+1
    956  060a		       4c 6f 06 	      jmp	pushR0nextIl
    957  060d							;
    958  060d							;=====================================================
    959  060d							; Pop two items off the stack.  Subtract the top of
    960  060d							; stack from the lower entry.
    961  060d							;
    962  060d		       20 8a 0e    iSUB       jsr	popR1
    963  0610		       20 53 0e 	      jsr	popR0
    964  0613		       38		      sec
    965  0614		       a5 83		      lda	R0
    966  0616		       e5 85		      sbc	R1
    967  0618		       85 83		      sta	R0
    968  061a		       a5 84		      lda	R0+1
    969  061c		       e5 86		      sbc	R1+1
    970  061e		       85 84		      sta	R0+1
    971  0620		       4c 6f 06 	      jmp	pushR0nextIl
    972  0623							;
    973  0623							;=====================================================
    974  0623							; Negate the top of stack.
    975  0623							;
    976  0623		       20 53 0e    iNEG       jsr	popR0
    977  0626		       a5 83		      lda	R0
    978  0628		       49 ff		      eor	#$ff
    979  062a		       85 83		      sta	R0
    980  062c		       a5 84		      lda	R0+1
    981  062e		       49 ff		      eor	#$ff
    982  0630		       85 84		      sta	R0+1
    983  0632		       e6 83		      inc	R0
    984  0634		       d0 02		      bne	iNEG2
    985  0636		       e6 84		      inc	R0+1
    986  0638		       4c 6f 06    iNEG2      jmp	pushR0nextIl
    987  063b							;
    988  063b							;=====================================================
    989  063b							; Multiply top two items on the stack, put the results
    990  063b							; on top.  This uses the algorithm documented on page
    991  063b							; 115 of "Microprocessor Programming for Computer
    992  063b							; Hobbyists" by Neill Graham.
    993  063b							;
    994  063b		       20 53 0e    iMUL       jsr	popR0	;AC
    995  063e		       20 8a 0e 	      jsr	popR1	;OP
    996  0641							;
    997  0641		       a5 83		      lda	R0
    998  0643		       8d 76 15 	      sta	MQ
    999  0646		       a5 84		      lda	R0+1
   1000  0648		       8d 77 15 	      sta	MQ+1
   1001  064b		       a9 00		      lda	#0	;clear result
   1002  064d		       85 83		      sta	R0
   1003  064f		       85 84		      sta	R0+1
   1004  0651							;
   1005  0651		       a2 10		      ldx	#16	;number of bits in value
   1006  0653		       06 83	   multloop   asl	R0
   1007  0655		       26 84		      rol	R0+1
   1008  0657		       0e 76 15 	      asl	MQ
   1009  065a		       2e 77 15 	      rol	MQ+1
   1010  065d		       90 0d		      bcc	multno	;skip add if no carry
   1011  065f							;
   1012  065f							; Add R1 back into R0
   1013  065f							;
   1014  065f		       18		      clc
   1015  0660		       a5 83		      lda	R0
   1016  0662		       65 85		      adc	R1
   1017  0664		       85 83		      sta	R0
   1018  0666		       a5 84		      lda	R0+1
   1019  0668		       65 86		      adc	R1+1
   1020  066a		       85 84		      sta	R0+1
   1021  066c							;
   1022  066c		       ca	   multno     dex		;did all bits yet?
   1023  066d		       d0 e4		      bne	multloop
   1024  066f							;
   1025  066f				   pushR0nextIl
   1026  066f		       20 09 0e 	      jsr	pushR0	;OP
   1027  0672		       4c e9 02 	      jmp	NextIL
   1028  0675							;
   1029  0675							;=====================================================
   1030  0675							; Divide the top of stack into the next to top item.
   1031  0675							; Leave results on stack.  Taken from:
   1032  0675							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1033  0675							;
   1034  0675							; R0 = R0 / R1
   1035  0675							; Remainder is in MQ
   1036  0675							;
   1037  0675		       20 91 06    iDIV       jsr	iDoDiv
   1038  0678		       20 ed 0e 	      jsr	RestoreSigns
   1039  067b		       4c 6f 06 	      jmp	pushR0nextIl
   1040  067e
   1041  067e		       20 91 06    iMOD       jsr	iDoDiv
   1042  0681		       20 ed 0e 	      jsr	RestoreSigns
   1043  0684		       ad 76 15 	      lda	MQ
   1044  0687		       85 83		      sta	R0
   1045  0689		       ad 77 15 	      lda	MQ+1
   1046  068c		       85 84		      sta	R0+1
   1047  068e		       4c 6f 06 	      jmp	pushR0nextIl
   1048  0691
   1049  0691				   iDoDiv
   1050  0691		       20 8a 0e 	      jsr	popR1
   1051  0694		       20 53 0e 	      jsr	popR0
   1052  0697							;
   1053  0697							; Check for divide by zero
   1054  0697							;
   1055  0697
   1056  0697				   iDivNoPop
   1057  0697		       a5 85		      lda	R1
   1058  0699		       05 86		      ora	R1+1
   1059  069b		       f0 31		      beq	divby0
   1060  069d							;
   1061  069d		       20 b2 0e 	      jsr	SaveSigns
   1062  06a0		       a9 00		      lda	#0	;preset remainder to 0
   1063  06a2		       8d 76 15 	      sta	MQ
   1064  06a5		       8d 77 15 	      sta	MQ+1
   1065  06a8		       a2 10		      ldx	#16	;repeat for each bit: ...
   1066  06aa				   divloop
   1067  06aa		       06 83		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1068  06ac		       26 84		      rol	R0+1
   1069  06ae		       2e 76 15 	      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1070  06b1		       2e 77 15 	      rol	MQ+1
   1071  06b4		       ad 76 15 	      lda	MQ
   1072  06b7		       38		      sec
   1073  06b8		       e5 85		      sbc	R1	;substract divisor to see if it fits in
   1074  06ba		       a8		      tay		;lb result -> Y, for we may need it later
   1075  06bb		       ad 77 15 	      lda	MQ+1
   1076  06be		       e5 86		      sbc	R1+1
   1077  06c0		       90 08		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1078  06c2
   1079  06c2		       8d 77 15 	      sta	MQ+1	;else save substraction result as new remainder,
   1080  06c5		       8c 76 15 	      sty	MQ
   1081  06c8		       e6 83		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1082  06ca
   1083  06ca		       ca	   skip       dex
   1084  06cb		       d0 dd		      bne	divloop
   1085  06cd		       60		      rts
   1086  06ce							;
   1087  06ce							; Indicate divide-by-zero error
   1088  06ce							;
   1089  06ce		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1090  06d0		       a9 00		      lda	#0
   1091  06d2		       4c 89 05 	      jmp	iErr2
   1092  06d5							;
   1093  06d5							;=====================================================
   1094  06d5							; This pops the top two items off the stack.  The top
   1095  06d5							; item is a data value and the other is an index into
   1096  06d5							; the variable table.	Save the value into that entry.
   1097  06d5							;
   1098  06d5		       20 53 0e    iSTORE     jsr	popR0	;data
   1099  06d8		       20 8a 0e 	      jsr	popR1	;index
   1100  06db		       a6 85		      ldx	R1	;get index
   1101  06dd		       a5 83		      lda	R0
   1102  06df		       95 41		      sta	variables,x
   1103  06e1		       a5 84		      lda	R0+1
   1104  06e3		       95 42		      sta	variables+1,x
   1105  06e5		       4c e9 02 	      jmp	NextIL
   1106  06e8							;
   1107  06e8							;=====================================================
   1108  06e8							; Replaces the top of stack with the variable whose
   1109  06e8							; index it represents.
   1110  06e8							;
   1111  06e8				   iIND
   1112  06e8		       20 8a 0e 	      jsr	popR1
   1113  06eb		       a6 85		      ldx	R1	;get index
   1114  06ed		       b5 41		      lda	variables,x
   1115  06ef		       85 83		      sta	R0
   1116  06f1		       b5 42		      lda	variables+1,x
   1117  06f3		       85 84		      sta	R0+1
   1118  06f5		       4c 6f 06 	      jmp	pushR0nextIl
   1119  06f8							;
   1120  06f8							;=====================================================
   1121  06f8							; Get the array index from top of stack get Current variable
   1122  06f8							; index from next on stack, add the offset
   1123  06f8							; push the result back onto the stack
   1124  06f8				   iArray
   1125  06f8		       20 53 0e 	      jsr	popR0
   1126  06fb		       20 8a 0e 	      jsr	popR1
   1127  06fe		       c6 83		      dec	R0	; Basic array index starts at 1
   1128  0700		       a5 83		      lda	R0
   1129  0702		       18		      clc
   1130  0703		       2a		      rol
   1131  0704		       65 85		      adc	R1
   1132  0706		       c9 34		      cmp	#(26*2)
   1133  0708		       b0 09		      bcs	iArrayError
   1134  070a		       85 83		      sta	R0
   1135  070c		       a5 84		      lda	R0+1
   1136  070e		       d0 03		      bne	iArrayError
   1137  0710		       4c 6f 06 	      jmp	pushR0nextIl
   1138  0713							; Get here if array index is out of range
   1139  0713				   iArrayError
   1140  0713		       a9 00		      lda	#0
   1141  0715		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1142  0717		       4c 89 05 	      jmp	iErr2
   1143  071a							;
   1144  071a							;=====================================================
   1145  071a							; List the current BASIC program in memory.  Uses R0,
   1146  071a							; tempIly, and dpl.
   1147  071a							;
   1148  071a		       20 9d 0f    iLST       jsr	SetOutConsole
   1149  071d		       a9 87	   iLST2      lda	#ProgramStart&$ff
   1150  071f		       85 77		      sta	dpl
   1151  0721		       a9 15		      lda	#ProgramStart>>8
   1152  0723		       85 78		      sta	dpl+1
   1153  0725							;
   1154  0725							; dpl/dph point to the current line.  See if we're at
   1155  0725							; the end of the program.
   1156  0725							;
   1157  0725		       a5 77	   iLSTloop   lda	dpl
   1158  0727		       cd 7f 15 	      cmp	PROGRAMEND
   1159  072a		       d0 07		      bne	iLstNotEnd
   1160  072c		       a5 78		      lda	dpl+1
   1161  072e		       cd 80 15 	      cmp	PROGRAMEND+1
   1162  0731		       f0 40		      beq	iLstdone
   1163  0733							;
   1164  0733		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
   1165  0735		       b1 77		      lda	(dpl),y	;line number LSB
   1166  0737		       85 83		      sta	R0
   1167  0739		       c8		      iny
   1168  073a		       b1 77		      lda	(dpl),y	;line number MSB
   1169  073c		       85 84		      sta	R0+1
   1170  073e		       c8		      iny
   1171  073f		       84 7b		      sty	tempIlY
   1172  0741		       20 a5 0c 	      jsr	PrintDecimal
   1173  0744		       a9 20		      lda	#SPACE
   1174  0746		       20 a8 0f 	      jsr	VOUTCH
   1175  0749		       a4 7b		      ldy	tempIlY
   1176  074b		       b1 77	   iLSTl2     lda	(dpl),y
   1177  074d		       f0 0a		      beq	iLST3	;end of this line 0 value
   1178  074f		       84 7b		      sty	tempIlY
   1179  0751		       20 a8 0f 	      jsr	VOUTCH
   1180  0754		       a4 7b		      ldy	tempIlY
   1181  0756		       c8		      iny
   1182  0757		       d0 f2		      bne	iLSTl2	;do next char
   1183  0759							;
   1184  0759							; End of this line.  Print CR/LF, then move to the
   1185  0759							; next line.
   1186  0759							;
   1187  0759		       c8	   iLST3      iny		;Move to next line
   1188  075a		       18		      clc		;Clear the carry flag
   1189  075b		       98		      tya		;Current Offset
   1190  075c		       65 77		      adc	dpl	;Add the offset to the pointer
   1191  075e		       85 77		      sta	dpl	;Save the new value
   1192  0760		       a5 78		      lda	dpl+1	;Next byte
   1193  0762		       69 00		      adc	#0	;ad in the carry if any
   1194  0764		       85 78		      sta	dpl+1	;Save it
   1195  0766							;
   1196  0766							; Have to manually do CR/LF so it uses the vectored
   1197  0766							; output function.
   1198  0766							;
   1199  0766		       a9 0d		      lda	#CR
   1200  0768		       20 a8 0f 	      jsr	VOUTCH
   1201  076b		       a9 0a		      lda	#LF
   1202  076d		       20 a8 0f 	      jsr	VOUTCH
   1203  0770		       4c 25 07 	      jmp	iLSTloop	;do next line
   1204  0773							;
   1205  0773		       20 9d 0f    iLstdone   jsr	SetOutConsole
   1206  0776		       4c e9 02 	      jmp	NextIL
   1207  0779							;
   1208  0779							;=====================================================
   1209  0779							; Get a line of text into LINBUF.  Terminate with a
   1210  0779							; null byte.
   1211  0779							;
   1212  0779		       a9 3e	   iGETLINE   lda	#'>	;prompt character
   1213  077b		       20 88 0d 	      jsr	GetLine
   1214  077e							;
   1215  077e		       a9 00		      lda	#0
   1216  0780		       85 87		      sta	RunMode
   1217  0782		       4c e9 02 	      jmp	NextIL
   1218  0785							;
   1219  0785							;=====================================================
   1220  0785							; This is called when the input buffer contains a line
   1221  0785							; typed in by the user that starts with a line number.
   1222  0785							; Insert the line into the program or delete the line
   1223  0785							; if there is nothing after the line number,
   1224  0785							;
   1225  0785		       a0 00	   iINSRT     ldy	#0
   1226  0787		       20 11 0d 	      jsr	getDecimal	;convert line #
   1227  078a		       20 1c 0f 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1228  078d		       84 7c		      sty	offset	;Save the start of the program line text
   1229  078f							;
   1230  078f							; Now find the line OR the next higher line OR the
   1231  078f							; end of the program.
   1232  078f							;
   1233  078f		       20 43 0c 	      jsr	findLine	; Look for the line number in the current program
   1234  0792							; Returns Z and curptr point to the line if found
   1235  0792							; Returns C and curptr at next higher line if not found and there is a higher line
   1236  0792							; Returns ZC clear and curptr to end of program if higher than all other lines
   1237  0792							;
   1238  0792							; If the line exists, it needs to be removed.
   1239  0792							;
   1240  0792		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1241  0794							;
   1242  0794							; Get length of line to be removed, we fall thru to here if we find a matching line
   1243  0794							;
   1244  0794							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1245  0794		       a0 00		      ldy	#0
   1246  0796		       b1 7e		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1247  0798		       a8		      tay
   1248  0799							;If it is equal we delete the line and replace it, get length
   1249  0799							;then adjust all program line after up or down depending on len of line
   1250  0799							;If next higher then just move everythimg down by length bytes
   1251  0799							;This call will return how many bytes in the line we found
   1252  0799		       84 7d		      sty	lineLength	;Save the length of the line we found
   1253  079b							;
   1254  079b							; Compute the new end of the program first.
   1255  079b							;
   1256  079b		       38		      sec		;Set the carry bit
   1257  079c		       ad 7f 15 	      lda	PROGRAMEND	;Get low byte of program end
   1258  079f		       e5 7d		      sbc	lineLength	;Subtract the length of the current line
   1259  07a1		       8d 7f 15 	      sta	PROGRAMEND	;save it
   1260  07a4		       ad 80 15 	      lda	PROGRAMEND+1
   1261  07a7		       e9 00		      sbc	#0	;Process the carry
   1262  07a9		       8d 80 15 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1263  07ac							;
   1264  07ac							; Copy CURPTR into R1 for working
   1265  07ac							;
   1266  07ac		       a5 7e		      lda	CURPTR	;Save the current position to r1 copy destination
   1267  07ae		       85 85		      sta	R1
   1268  07b0		       a5 7f		      lda	CURPTR+1
   1269  07b2		       85 86		      sta	R1+1
   1270  07b4							;
   1271  07b4							; See if we're at the end.
   1272  07b4							;
   1273  07b4		       a5 85	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1274  07b6		       cd 7f 15 	      cmp	PROGRAMEND
   1275  07b9		       d0 07		      bne	InsDelLoop
   1276  07bb		       a5 86		      lda	R1+1
   1277  07bd		       cd 80 15 	      cmp	PROGRAMEND+1
   1278  07c0		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1279  07c2							;
   1280  07c2							; Move one byte, move to next location.
   1281  07c2							;
   1282  07c2		       a4 7d	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1283  07c4		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1284  07c6		       b1 85		      lda	(R1),y
   1285  07c8		       a0 00		      ldy	#0
   1286  07ca		       91 85		      sta	(R1),y
   1287  07cc		       e6 85		      inc	R1
   1288  07ce		       d0 e4		      bne	InsDelChk
   1289  07d0		       e6 86		      inc	R1+1
   1290  07d2		       4c b4 07 	      jmp	InsDelChk	; Check if we have moved the last byte
   1291  07d5							;
   1292  07d5							; Deletion is done.
   1293  07d5							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1294  07d5							;
   1295  07d5		       a4 7c	   insert2    ldy	offset	;get back ptr	Get the current offset
   1296  07d7		       b9 ec 14 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1297  07da		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1298  07dc							;
   1299  07dc							; CURPTR points to where the line will be inserted.
   1300  07dc							;
   1301  07dc		       20 e5 0d 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1302  07df							;
   1303  07df		       ad 7f 15 	      lda	PROGRAMEND	;Load the start address for the copy
   1304  07e2							;At this point curptr still contains the location we will insert data
   1305  07e2		       85 88		      sta	FROM
   1306  07e4		       ad 80 15 	      lda	PROGRAMEND+1
   1307  07e7		       85 89		      sta	FROM+1
   1308  07e9							;
   1309  07e9		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1310  07eb		       b1 88		      lda	(FROM),y
   1311  07ed		       a4 7d		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1312  07ef		       91 88		      sta	(FROM),y	;Save the new byte
   1313  07f1							;
   1314  07f1		       a5 88		      lda	FROM	;Check if we have copies the last byte
   1315  07f3		       c5 7e		      cmp	CURPTR
   1316  07f5		       d0 06		      bne	mvUpMore
   1317  07f7		       a5 89		      lda	FROM+1
   1318  07f9		       c5 7f		      cmp	CURPTR+1
   1319  07fb		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1320  07fd							;
   1321  07fd							; Not done yet
   1322  07fd							;
   1323  07fd		       a5 88	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1324  07ff		       d0 02		      bne	mvUpMore2
   1325  0801		       c6 89		      dec	FROM+1
   1326  0803		       c6 88	   mvUpMore2  dec	FROM
   1327  0805		       4c e9 07 	      jmp	mvup1	;Loop until everything is moved
   1328  0808							;
   1329  0808							; All done with copy.
   1330  0808							;
   1331  0808		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1332  0809		       a5 7d		      lda	lineLength	;Number of bytes to copy from line buff
   1333  080b		       6d 7f 15 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1334  080e		       8d 7f 15 	      sta	PROGRAMEND
   1335  0811		       ad 80 15 	      lda	PROGRAMEND+1
   1336  0814		       69 00		      adc	#0
   1337  0816		       8d 80 15 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1338  0819							;
   1339  0819							;===================jlit use length before line newline
   1340  0819
   1341  0819		       a0 00		      ldy	#0	;Set offset of copy
   1342  081b		       a5 7d		      lda	lineLength	;We will insert the actual length of the line first
   1343  081d		       91 7e		      sta	(CURPTR),y	;Store the length
   1344  081f		       c8		      iny
   1345  0820		       a5 83		      lda	R0	;Store the line number next
   1346  0822		       91 7e		      sta	(CURPTR),y
   1347  0824		       c8		      iny
   1348  0825		       a5 84		      lda	R0+1
   1349  0827		       91 7e		      sta	(CURPTR),y
   1350  0829		       c8		      iny
   1351  082a							;
   1352  082a		       a6 7c		      ldx	offset	;Load the offset into line buffer in page zero
   1353  082c		       bd ec 14    mvUpLoop2  lda	LINBUF,x	;get a byte
   1354  082f		       91 7e		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1355  0831		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1356  0833		       e8		      inx
   1357  0834		       c8		      iny
   1358  0835		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1359  0837							;
   1360  0837		       4c e9 02    mvUpFini   jmp	NextIL
   1361  083a							;
   1362  083a							;=====================================================
   1363  083a							; Pops the top value of the ILPC stack and stores it
   1364  083a							; in ILPC.  Ie, return from an IL subroutine.
   1365  083a							;
   1366  083a		       20 30 0c    iRTN       jsr	popILPC
   1367  083d		       4c e9 02 	      jmp	NextIL
   1368  0840							;
   1369  0840							;=====================================================
   1370  0840							; NLINE print a newline
   1371  0840							;
   1372  0840		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1373  0843		       4c e9 02 	      jmp	NextIL
   1374  0846							;
   1375  0846							;=====================================================
   1376  0846							; This saves the current ILPC value on the stack, then
   1377  0846							; jumps to the address specified by the next two bytes.
   1378  0846							;
   1379  0846		       20 16 0c    iCALL      jsr	pushILPC	;save ILPC
   1380  0849							;
   1381  0849							; Jmp to a specific location in the IL code.  The new
   1382  0849							; address immediately follows the opcode.
   1383  0849							;
   1384  0849		       20 fc 0b    iJMP       jsr	getILWord
   1385  084c		       86 75		      stx	ILPC
   1386  084e		       85 76		      sta	ILPC+1
   1387  0850		       4c e9 02 	      jmp	NextIL
   1388  0853							;
   1389  0853							;=====================================================
   1390  0853							; Push the next two bytes onto the arithmetic stack.
   1391  0853							;
   1392  0853		       20 fc 0b    iLIT       jsr	getILWord
   1393  0856		       86 83		      stx	R0
   1394  0858		       85 84		      sta	R0+1
   1395  085a		       20 09 0e 	      jsr	pushR0
   1396  085d		       4c e9 02 	      jmp	NextIL
   1397  0860							;
   1398  0860							;=====================================================
   1399  0860							; Initialize all variables.  Ie, set to zero.
   1400  0860							;
   1401  0860		       a9 00	   iVINIT     lda	#0
   1402  0862		       a2 00		      ldx	#0
   1403  0864		       95 41	   Vinit2     sta	variables,x
   1404  0866		       e8		      inx
   1405  0867		       e0 34		      cpx	#variablesEnd-variables
   1406  0869		       d0 f9		      bne	Vinit2
   1407  086b		       4c e9 02 	      jmp	NextIL
   1408  086e							;
   1409  086e							;=====================================================
   1410  086e							; Set the address of the error handler.  After any
   1411  086e							; error, set to the ILPC to the specified location.
   1412  086e							;
   1413  086e		       20 fc 0b    iERRGOTO   jsr	getILWord
   1414  0871		       8e 74 15 	      stx	errGoto
   1415  0874		       8d 75 15 	      sta	errGoto+1
   1416  0877		       4c e9 02 	      jmp	NextIL
   1417  087a							;
   1418  087a							;=====================================================
   1419  087a							; TST is followed by an 8 bit signed offset, then a
   1420  087a							; null terminated string.  Compare the string against
   1421  087a							; the string starting at (CURPTR),CUROFF.  If the
   1422  087a							; strings match, continue executing the next IL
   1423  087a							; opcode.  Else, add the offset to ILPC.
   1424  087a							;
   1425  087a		       20 00 0c    iTST       jsr	getILByte
   1426  087d		       85 7c		      sta	offset
   1427  087f							;
   1428  087f		       20 f7 0d 	      jsr	saveIL	;in case of failure
   1429  0882		       a4 80		      ldy	CUROFF
   1430  0884		       84 77		      sty	dpl	;save for later
   1431  0886							;
   1432  0886		       20 00 0c    iTSTloop   jsr	getILByte	;get next char
   1433  0889		       f0 11		      beq	iTSTm	;match!
   1434  088b		       a4 77		      ldy	dpl
   1435  088d		       d1 7e		      cmp	(CURPTR),y
   1436  088f		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1437  0891		       09 20		      ora	#$20	; lets allow lowercase as well
   1438  0893		       d1 7e		      cmp	(CURPTR),y
   1439  0895		       d0 22		      bne	iTSTfail	;mismatch
   1440  0897		       c8	   iTSTUpper  iny
   1441  0898		       84 77		      sty	dpl
   1442  089a		       d0 ea		      bne	iTSTloop
   1443  089c							;
   1444  089c							; It's a match!  Clean up a bit.
   1445  089c							;
   1446  089c		       a4 77	   iTSTm      ldy	dpl
   1447  089e		       84 80		      sty	CUROFF
   1448  08a0		       4c e9 02 	      jmp	NextIL
   1449  08a3							; Test for a single quote
   1450  08a3		       20 00 0c    iTSTStr    jsr	getILByte
   1451  08a6		       85 7c		      sta	offset
   1452  08a8		       20 f7 0d 	      jsr	saveIL
   1453  08ab		       a4 80		      ldy	CUROFF
   1454  08ad		       a9 22		      lda	#'"
   1455  08af		       d1 7e		      cmp	(CURPTR),y
   1456  08b1		       d0 06		      bne	iTSTfail
   1457  08b3		       c8		      iny
   1458  08b4		       84 80		      sty	CUROFF
   1459  08b6		       4c f7 02 	      jmp	NextILStr
   1460  08b9							;
   1461  08b9							; Not a match, reset ILPC and then move to the
   1462  08b9							; offset.
   1463  08b9							;
   1464  08b9		       20 00 0e    iTSTfail   jsr	restoreIL
   1465  08bc		       4c 66 09 	      jmp	tstBranch
   1466  08bf							;
   1467  08bf							;=================================================JLIT=
   1468  08bf							; Test if we have a let statement without the let keyword
   1469  08bf		       20 00 0c    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1470  08c2		       85 7c		      sta	offset	; Save the jump offset for fails
   1471  08c4		       20 f7 0d 	      jsr	saveIL	; save to restore when done
   1472  08c7		       a4 80		      ldy	CUROFF	; Get the current offset into the buffer
   1473  08c9		       20 1c 0f 	      jsr	SkipSpaces	; move to first element on line
   1474  08cc		       84 80		      sty	CUROFF	; Just remember skipped spaces
   1475  08ce		       c8		      iny		; skip the Variable name
   1476  08cf		       20 1c 0f 	      jsr	SkipSpaces	; skip any SkipSpaces
   1477  08d2		       b1 7e		      lda	(CURPTR),y	; Get what should be an equal sign
   1478  08d4		       c9 3d		      cmp	#'=	; check if equals
   1479  08d6		       d0 e1		      bne	iTSTfail	; return it failed
   1480  08d8		       20 00 0e 	      jsr	restoreIL	; restore the IL anyway
   1481  08db		       4c e9 02 	      jmp	NextIL	; Then next instruction
   1482  08de
   1483  08de							;================================================jLIT=
   1484  08de							;Test for end of line
   1485  08de							;
   1486  08de		       20 00 0c    iTSTDONE   jsr	getILByte
   1487  08e1		       85 7c		      sta	offset
   1488  08e3		       20 f7 0d 	      jsr	saveIL
   1489  08e6		       a4 80		      ldy	CUROFF
   1490  08e8		       84 77		      sty	dpl
   1491  08ea		       20 1c 0f 	      jsr	SkipSpaces
   1492  08ed		       b1 7e		      lda	(CURPTR),y
   1493  08ef		       f0 0b		      beq	iTSTDONEtrue
   1494  08f1		       c9 3a		      cmp	#COLON
   1495  08f3		       f0 07		      beq	iTSTDONEtrue
   1496  08f5		       a4 77		      ldy	dpl
   1497  08f7		       84 80		      sty	CUROFF
   1498  08f9		       4c b9 08 	      jmp	iTSTfail
   1499  08fc							;
   1500  08fc							; Advance to the next line
   1501  08fc							;
   1502  08fc				   iTSTDONEtrue
   1503  08fc		       4c e9 02 	      jmp	NextIL
   1504  08ff							;
   1505  08ff							;=====================================================
   1506  08ff							; TSTV is followed by an 8 bit signed offset.	If the
   1507  08ff							; value at (CURPTR),CUROFF appears to be a variable
   1508  08ff							; name, move to the next IL statement.  Else, add the
   1509  08ff							; offset to ILPC.
   1510  08ff							;
   1511  08ff		       20 00 0c    iTSTV      jsr	getILByte	;offset
   1512  0902		       85 7c		      sta	offset
   1513  0904							;
   1514  0904		       a4 80		      ldy	CUROFF
   1515  0906		       20 1c 0f 	      jsr	SkipSpaces
   1516  0909		       b1 7e		      lda	(CURPTR),y
   1517  090b							;
   1518  090b		       09 20		      ora	#$20	;make lower then upper
   1519  090d		       49 20		      eor	#$20	;allow lower case here
   1520  090f		       c9 41		      cmp	#'A
   1521  0911		       90 53		      bcc	tstBranch
   1522  0913		       c9 5b		      cmp	#'Z+1
   1523  0915		       b0 4f		      bcs	tstBranch
   1524  0917							;
   1525  0917							; The condition is true, so convert to an index, push
   1526  0917							; it onto the stack and continue running.
   1527  0917							;
   1528  0917		       38		      sec
   1529  0918		       e9 41		      sbc	#'A	;index is zero based
   1530  091a		       0a		      asl		;multiply by two
   1531  091b		       85 83		      sta	R0
   1532  091d		       a9 00		      lda	#0
   1533  091f		       85 84		      sta	R0+1
   1534  0921		       20 09 0e 	      jsr	pushR0	;put index onto stack
   1535  0924		       e6 80		      inc	CUROFF	;move to next input char
   1536  0926		       4c e9 02 	      jmp	NextIL
   1537  0929							;
   1538  0929							;=====================================================
   1539  0929							; TSTL seems basically the same as TSTN, but leave the
   1540  0929							; value in R0 instead of pushing onto stack.
   1541  0929							; This tests for a valid line number
   1542  0929							;
   1543  0929		       20 00 0c    iTSTL      jsr	getILByte
   1544  092c		       85 7c		      sta	offset
   1545  092e							;
   1546  092e		       a4 80		      ldy	CUROFF
   1547  0930		       20 1c 0f 	      jsr	SkipSpaces
   1548  0933		       b1 7e		      lda	(CURPTR),y
   1549  0935							;
   1550  0935		       c9 30		      cmp	#'0
   1551  0937		       90 2d		      bcc	tstBranch
   1552  0939		       c9 3a		      cmp	#'9+1
   1553  093b		       b0 29		      bcs	tstBranch
   1554  093d							;
   1555  093d							; It's a digit, so convert to a number.
   1556  093d							;
   1557  093d		       20 11 0d 	      jsr	getDecimal
   1558  0940		       4c e9 02 	      jmp	NextIL
   1559  0943							;
   1560  0943							;=====================================================
   1561  0943							; TSTN checks for a number.  This is very simplistic;
   1562  0943							; if the character is a digit, assume it's a number.
   1563  0943							; Convert to a number and push it onto the stack.
   1564  0943							;
   1565  0943		       20 00 0c    iTSTN      jsr	getILByte
   1566  0946		       85 7c		      sta	offset
   1567  0948							;
   1568  0948		       a4 80		      ldy	CUROFF
   1569  094a		       20 1c 0f 	      jsr	SkipSpaces
   1570  094d		       b1 7e		      lda	(CURPTR),y
   1571  094f		       c9 2d		      cmp	#'-	;negative?
   1572  0951		       f0 08		      beq	iTSTN_1
   1573  0953		       c9 30		      cmp	#'0
   1574  0955		       90 0f		      bcc	tstBranch
   1575  0957		       c9 3a		      cmp	#'9+1
   1576  0959		       b0 0b		      bcs	tstBranch
   1577  095b							;
   1578  095b							; It's a digit, so convert to a number.
   1579  095b							;
   1580  095b		       20 11 0d    iTSTN_1    jsr	getDecimal
   1581  095e		       84 80		      sty	CUROFF
   1582  0960		       20 09 0e 	      jsr	pushR0	;save onto stack
   1583  0963		       4c e9 02 	      jmp	NextIL
   1584  0966
   1585  0966							;
   1586  0966							; Common jump point for all TSTx instructions that
   1587  0966							; fail to meet the requirements.  This takes the
   1588  0966							; offset and adds/subtracts to/from ILPC.
   1589  0966							;
   1590  0966		       a5 7c	   tstBranch  lda	offset	;get signed offset
   1591  0968		       10 0e		      bpl	tstPositive
   1592  096a							;
   1593  096a							; Do negative branch.	Do sign extension.
   1594  096a							;
   1595  096a		       18		      clc
   1596  096b		       65 75		      adc	ILPC
   1597  096d		       85 75		      sta	ILPC
   1598  096f		       a5 76		      lda	ILPC+1
   1599  0971		       69 ff		      adc	#$ff
   1600  0973		       85 76		      sta	ILPC+1
   1601  0975		       4c e9 02 	      jmp	NextIL	;keep going
   1602  0978							;
   1603  0978		       18	   tstPositive clc
   1604  0979		       65 75		      adc	ILPC
   1605  097b		       85 75		      sta	ILPC
   1606  097d		       a5 76		      lda	ILPC+1
   1607  097f		       69 00		      adc	#0
   1608  0981		       85 76		      sta	ILPC+1
   1609  0983		       4c e9 02 	      jmp	NextIL
   1610  0986
   1611  0986							;
   1612  0986							;====================================================
   1613  0986							; Test for IRQ pending, and test if a break key pressed
   1614  0986							; Yes I know but this handles all sorts of irq/break issues
   1615  0986							;
   1616  0986		       20 00 0c    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   1617  0989		       85 7c		      sta	offset	; Store the not true jump address offset
   1618  098b		       20 0a 04 	      jsr	BreakSet	; Check if the escape key was pressed
   1619  098e		       d0 03		      bne	irqNo	; z not set of no break found
   1620  0990		       4c 75 05 	      jmp	iFIN	; Exit out of run mode
   1621  0993		       ad 45 14    irqNo      lda	IRQPending
   1622  0996		       f0 ce		      beq	tstBranch
   1623  0998		       c9 01		      cmp	#1	; only do this if set to first time
   1624  099a		       d0 ca		      bne	tstBranch
   1625  099c		       78		      sei		; disable the interupt until ireturn resets it
   1626  099d		       ee 45 14    irqbrk     inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   1627  09a0		       20 1c 0e 	      jsr	pushLN	; Push the next line to be executed
   1628  09a3		       b0 11		      bcs	irqErra	; Check if there was an error
   1629  09a5		       ad 46 14 	      lda	IRQEntry	; Get the line number to branch to
   1630  09a8		       85 7e		      sta	CURPTR	; put line number into r0
   1631  09aa		       ad 47 14 	      lda	IRQEntry+1
   1632  09ad		       85 7f		      sta	CURPTR+1
   1633  09af		       a9 03		      lda	#3
   1634  09b1		       85 80		      sta	CUROFF
   1635  09b3		       4c e9 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   1636  09b6		       a2 0c	   irqErra    ldx	#12	; Flag any error in line number
   1637  09b8		       a9 00		      lda	#0	; stop the execution
   1638  09ba		       4c 89 05 	      jmp	iErr2
   1639  09bd							;
   1640  09bd							;================================================
   1641  09bd							; iTaskSwitch	 switch to new task if not interupt and
   1642  09bd							;		 count is excceded for task
   1643  09bd							;
   1644  09bd				   iTaskSwitch
   1645  09bd		       ad 45 14 	      lda	IRQPending	; Skip this if we are processing an irq
   1646  09c0		       d0 4a		      bne	iTaskSwitchDone
   1647  09c2		       a5 8c		      lda	taskCount
   1648  09c4		       c9 01		      cmp	#1	; if there is only one task must be main
   1649  09c6		       d0 07		      bne	tasknext	; if it some other number continue to next
   1650  09c8		       ac 70 14 	      ldy	taskPtr	; check if we have not just ended some other task
   1651  09cb		       d0 02		      bne	tasknext	; if so then do a next anyway
   1652  09cd		       f0 3d		      beq	iTaskSwitchDone	; Skip this if main is only task
   1653  09cf				   tasknext
   1654  09cf		       c6 8a		      dec	taskCurrentCycles	; Dec the current cycle count
   1655  09d1		       d0 39		      bne	iTaskSwitchDone	; Skip this if we are not end of cycle
   1656  09d3		       ac 70 14 	      ldy	taskPtr
   1657  09d6		       a5 7e		      lda	CURPTR
   1658  09d8		       99 49 14 	      sta	taskTable+1,y
   1659  09db		       a5 7f		      lda	CURPTR+1
   1660  09dd		       99 4a 14 	      sta	taskTable+2,y
   1661  09e0		       a5 80		      lda	CUROFF
   1662  09e2		       99 4b 14 	      sta	taskTable+3,y
   1663  09e5				   taskLoop
   1664  09e5		       c8		      iny
   1665  09e6		       c8		      iny
   1666  09e7		       c8		      iny
   1667  09e8		       c8		      iny
   1668  09e9		       c0 24		      cpy	#(TASKCOUNT-1)<<2
   1669  09eb		       f0 04		      beq	TaskNextChk
   1670  09ed		       90 02		      bcc	TaskNextChk
   1671  09ef		       a0 00	   TaskResetTop ldy	#0
   1672  09f1				   TaskNextChk
   1673  09f1		       b9 48 14 	      lda	taskTable,y	; there is always at least one entry in table
   1674  09f4		       f0 ef		      beq	taskLoop	; get next slot if this one empty
   1675  09f6		       b9 49 14 	      lda	taskTable+1,y
   1676  09f9		       85 7e		      sta	CURPTR
   1677  09fb		       b9 4a 14 	      lda	taskTable+2,y
   1678  09fe		       85 7f		      sta	CURPTR+1
   1679  0a00		       b9 4b 14 	      lda	taskTable+3,y
   1680  0a03		       85 80		      sta	CUROFF
   1681  0a05		       8c 70 14 	      sty	taskPtr
   1682  0a08		       a5 8b		      lda	taskResetValue
   1683  0a0a		       85 8a		      sta	taskCurrentCycles
   1684  0a0c				   iTaskSwitchDone
   1685  0a0c		       4c e9 02 	      jmp	NextIL
   1686  0a0f							;
   1687  0a0f							;=====================================================
   1688  0a0f							; This places the number of free bytes on top of the
   1689  0a0f							; stack.
   1690  0a0f							;
   1691  0a0f		       20 6a 0f    iFREE      jsr	GetSizes
   1692  0a12		       20 09 0e 	      jsr	pushR0
   1693  0a15		       4c e9 02 	      jmp	NextIL
   1694  0a18							;
   1695  0a18							;=====================================================
   1696  0a18							; Generate a random number from 0-FFFF and then MOD
   1697  0a18							; it with the value on top of stack.  Leaves number on
   1698  0a18							; stack
   1699  0a18							;
   1700  0a18		       20 8a 0e    iRANDOM    jsr	popR1	;mod value
   1701  0a1b							;
   1702  0a1b							; If the value is zero, just return a one.
   1703  0a1b							;
   1704  0a1b		       a5 85		      lda	R1
   1705  0a1d		       05 86		      ora	R1+1
   1706  0a1f		       f0 4c		      beq	irandom1
   1707  0a21							;
   1708  0a21		       ad 7b 15 	      lda	random+1
   1709  0a24		       8d 79 15 	      sta	rtemp1
   1710  0a27		       ad 7a 15 	      lda	random
   1711  0a2a		       0a		      asl
   1712  0a2b		       2e 79 15 	      rol	rtemp1
   1713  0a2e		       0a		      asl
   1714  0a2f		       2e 79 15 	      rol	rtemp1
   1715  0a32		       18		      clc
   1716  0a33		       6d 7a 15 	      adc	random
   1717  0a36		       48		      pha
   1718  0a37		       ad 79 15 	      lda	rtemp1
   1719  0a3a		       6d 7b 15 	      adc	random+1
   1720  0a3d		       8d 7b 15 	      sta	random+1
   1721  0a40		       68		      pla
   1722  0a41		       69 11		      adc	#$11
   1723  0a43		       8d 7a 15 	      sta	random
   1724  0a46		       ad 7b 15 	      lda	random+1
   1725  0a49		       69 36		      adc	#$36
   1726  0a4b		       8d 7b 15 	      sta	random+1
   1727  0a4e
   1728  0a4e		       ad 7a 15 	      lda	random
   1729  0a51		       85 83		      sta	R0
   1730  0a53		       ad 7b 15 	      lda	random+1
   1731  0a56		       29 7f		      and	#$7f	;make positive
   1732  0a58		       85 84		      sta	R0+1
   1733  0a5a							;
   1734  0a5a							; R0 contains the number and R1 contains the max value.
   1735  0a5a							;
   1736  0a5a		       20 97 06 	      jsr	iDivNoPop
   1737  0a5d		       20 ed 0e 	      jsr	RestoreSigns
   1738  0a60		       ad 76 15 	      lda	MQ
   1739  0a63		       85 83		      sta	R0
   1740  0a65		       ad 77 15 	      lda	MQ+1
   1741  0a68		       85 84		      sta	R0+1
   1742  0a6a		       4c 6f 06 	      jmp	pushR0nextIl
   1743  0a6d				   irandom1
   1744  0a6d		       a9 00		      lda	#0
   1745  0a6f		       85 84		      sta	R0+1
   1746  0a71		       a9 01		      lda	#1
   1747  0a73		       85 83		      sta	R0
   1748  0a75		       4c 6f 06 	      jmp	pushR0nextIl
   1749  0a78
   1750  0a78							; The following replaced by call to division/modulo
   1751  0a78							;iRANDOM_2	lda	R0
   1752  0a78							;		cmp	R1
   1753  0a78							;		bne	iRANDOM_1
   1754  0a78							;		lda	R0+1
   1755  0a78							;		cmp	R1+1
   1756  0a78							;		bne	iRANDOM_1	;need to subtract
   1757  0a78							;
   1758  0a78							; Subtract R1 from R0
   1759  0a78							;
   1760  0a78							;iRANDOM_sub	sec
   1761  0a78							;		lda	R0
   1762  0a78							;		sbc	R1
   1763  0a78							;		sta	R0
   1764  0a78							;		lda	R0+1
   1765  0a78							;		sbc	R1+1
   1766  0a78							;		sta	R0+1
   1767  0a78							;		jmp	iRANDOM_2
   1768  0a78							;
   1769  0a78							; See if R1 > R0.  If so, branch to subtract.
   1770  0a78							;
   1771  0a78							;iRANDOM_1	lda	R0
   1772  0a78							;		cmp	R1
   1773  0a78							;		lda	R0+1
   1774  0a78							;		sbc	R1+1
   1775  0a78							;		bvc	iRANDOM_4
   1776  0a78							;		eor	#$80
   1777  0a78							;iRANDOM_4	bpl	iRANDOM_sub
   1778  0a78							;
   1779  0a78							; All done.  Almost.  Add one, then push the result.
   1780  0a78							;
   1781  0a78							;irandom1	inc	R0
   1782  0a78							;		bne	iRANDOM_3
   1783  0a78							;		inc	R0+1
   1784  0a78							;iRANDOM_3
   1785  0a78							;		  jsr	pushR0	;return value
   1786  0a78							;		jmp	NextIL
   1787  0a78							;
   1788  0a78							; Poke a value into a memory location
   1789  0a78		       8c 7e 15    iPOKEMEMORY sty	tempy
   1790  0a7b		       20 53 0e 	      jsr	popR0
   1791  0a7e		       20 8a 0e 	      jsr	popR1
   1792  0a81		       a0 00		      ldy	#0
   1793  0a83		       a5 83		      lda	R0
   1794  0a85		       91 85		      sta	(R1),y
   1795  0a87		       ac 7e 15 	      ldy	tempy
   1796  0a8a		       4c e9 02 	      jmp	NextIL
   1797  0a8d							;
   1798  0a8d							; Get a value from a memory location
   1799  0a8d							;
   1800  0a8d		       8c 7e 15    iPEEKMEMORY sty	tempy
   1801  0a90		       20 53 0e 	      jsr	popR0
   1802  0a93		       a0 00		      ldy	#0
   1803  0a95		       b1 83		      lda	(R0),y
   1804  0a97		       ac 7e 15 	      ldy	tempy
   1805  0a9a		       85 83		      sta	R0
   1806  0a9c		       a9 00		      lda	#0
   1807  0a9e		       85 84		      sta	R0+1
   1808  0aa0		       4c 6f 06 	      jmp	pushR0nextIl
   1809  0aa3							;
   1810  0aa3							; Call to address return what ever is in a to the stack
   1811  0aa3							; func2 will load a value into a before the call
   1812  0aa3		       20 8a 0e    iCallFunc  jsr	popR1
   1813  0aa6		       a5 85		      lda	R1
   1814  0aa8		       20 b4 0a 	      jsr	iCallRtn
   1815  0aab		       85 83		      sta	R0
   1816  0aad		       a9 00		      lda	#0
   1817  0aaf		       85 84		      sta	R0+1
   1818  0ab1		       20 6f 06 	      jsr	pushR0nextIl
   1819  0ab4				   iCallRtn
   1820  0ab4		       20 53 0e 	      jsr	popR0
   1821  0ab7		       6c 83 00 	      jmp	(R0)
   1822  0aba
   1823  0aba
   1824  0aba							;===========================================jlit======
   1825  0aba							;Get a character from the terminal convert to value
   1826  0aba							;leave the number on top of the stack
   1827  0aba							;
   1828  0aba				   iGETCHAR
   1829  0aba		       20 1c 0e 	      jsr	pushLN	;Save state befor getline
   1830  0abd		       20 09 02 	      jsr	GETCH
   1831  0ac0					      if	CTMON65
   1832  0ac0		       48		      pha
   1833  0ac1		       20 0c f0 	      jsr	cout	;echo echo echo
   1834  0ac4		       68		      pla
   1835  0ac5					      endif
   1836  0ac5		       85 83		      sta	R0
   1837  0ac7		       a9 00		      lda	#0
   1838  0ac9		       85 84		      sta	R0+1
   1839  0acb		       20 09 0e 	      jsr	pushR0
   1840  0ace							;
   1841  0ace		       20 66 0e 	      jsr	popLN
   1842  0ad1		       4c e9 02 	      jmp	NextIL
   1843  0ad4							;===========================================jlit======
   1844  0ad4							;Put a character to the terminal convert to
   1845  0ad4							;
   1846  0ad4		       20 53 0e    iPUTCHAR   jsr	popR0
   1847  0ad7		       a5 83		      lda	R0
   1848  0ad9		       20 06 02 	      jsr	OUTCH
   1849  0adc		       4c e9 02 	      jmp	NextIL
   1850  0adf							;
   1851  0adf							;
   1852  0adf							;=====================================================
   1853  0adf							; Replace TOS with its absolute value.
   1854  0adf							;
   1855  0adf		       20 53 0e    iABS       jsr	popR0
   1856  0ae2		       a5 84		      lda	R0+1
   1857  0ae4		       10 10		      bpl	iABS_1	;already positive
   1858  0ae6		       49 ff		      eor	#$ff
   1859  0ae8		       85 84		      sta	R0+1
   1860  0aea		       a5 83		      lda	R0
   1861  0aec		       49 ff		      eor	#$ff
   1862  0aee		       85 83		      sta	R0
   1863  0af0		       e6 83		      inc	R0
   1864  0af2		       d0 02		      bne	iABS_1
   1865  0af4		       e6 84		      inc	R0+1
   1866  0af6		       4c 6f 06    iABS_1     jmp	pushR0nextIl
   1867  0af9
   1868  0af9							;================================================================
   1869  0af9							;Set the IRQ service rtn line number
   1870  0af9							;
   1871  0af9		       78	   iSetIrq    sei		; disable the interupts
   1872  0afa		       a9 00		      lda	#0	; Zero the Status flag
   1873  0afc		       8d 44 14 	      sta	IRQStatus
   1874  0aff		       20 53 0e 	      jsr	popR0	; get the line number
   1875  0b02		       a5 83		      lda	R0
   1876  0b04		       05 84		      ora	R0+1
   1877  0b06		       f0 1b		      beq	iSetExt	; if it is zero disable all
   1878  0b08		       20 1c 0e 	      jsr	pushLN	; Save the current line pointer
   1879  0b0b		       20 43 0c 	      jsr	findLine	; Find the IRQ func Line Pointer
   1880  0b0e		       d0 16		      bne	iSetIrqErr	; Error if exact line not ound
   1881  0b10		       a5 7f		      lda	CURPTR+1	; Copy it to the Entry pointer
   1882  0b12		       8d 47 14 	      sta	IRQEntry+1
   1883  0b15		       a5 7e		      lda	CURPTR
   1884  0b17		       8d 46 14 	      sta	IRQEntry
   1885  0b1a		       a9 01		      lda	#1	; Indicate there is an irq gosub
   1886  0b1c		       8d 44 14 	      sta	IRQStatus
   1887  0b1f		       20 66 0e 	      jsr	popLN	; Restore the old line number
   1888  0b22		       58		      cli		; Enable the interupts
   1889  0b23		       4c e9 02    iSetExt    jmp	NextIL
   1890  0b26
   1891  0b26		       20 66 0e    iSetIrqErr jsr	popLN
   1892  0b29		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   1893  0b2b		       a9 00		      lda	#0
   1894  0b2d		       4c 89 05 	      jmp	iErr2
   1895  0b30							;
   1896  0b30							;================================================================
   1897  0b30							; Task Set task number to line number to start
   1898  0b30							; Task Table structure:
   1899  0b30							;    byte 0	-   Active inactive 0 or 1
   1900  0b30							;    byte 1-2	-   Basic code line pointer
   1901  0b30							;    byte 3	-   Offset on current line
   1902  0b30		       98	   iTaskSet   tya
   1903  0b31		       48		      pha
   1904  0b32		       20 1c 0e 	      jsr	pushLN	; Store the current line number
   1905  0b35		       20 53 0e 	      jsr	popR0	; Get the line number to be saved
   1906  0b38		       a5 83		      lda	R0
   1907  0b3a		       05 84		      ora	R0+1
   1908  0b3c		       f0 44		      beq	iTaskRetCurrent
   1909  0b3e		       20 43 0c 	      jsr	findLine	; Get the offset of the line to start task at
   1910  0b41		       f0 05		      beq	iTaskCont
   1911  0b43		       68		      pla
   1912  0b44		       a8		      tay
   1913  0b45		       4c 26 0b 	      jmp	iSetIrqErr	; Bad line number provided
   1914  0b48				   iTaskCont
   1915  0b48		       20 e5 0b 	      jsr	TaskEmpty	; Find an empty slot
   1916  0b4b		       f0 29		      beq	iTaskNoEmpty	; There are no more empty slots
   1917  0b4d		       e6 8c		      inc	taskCount	; Update the number of Tasks running
   1918  0b4f		       a9 01		      lda	#1
   1919  0b51		       99 48 14 	      sta	taskTable,y	; Mark as busy/used
   1920  0b54		       a5 7e		      lda	CURPTR
   1921  0b56		       99 49 14 	      sta	taskTable+1,y
   1922  0b59		       a5 7f		      lda	CURPTR+1
   1923  0b5b		       99 4a 14 	      sta	taskTable+2,y
   1924  0b5e		       a9 03		      lda	#3	; Offset to first instruction
   1925  0b60		       99 4b 14 	      sta	taskTable+3,y
   1926  0b63		       e6 8c		      inc	taskCount
   1927  0b65				   iTaskGetCurrent
   1928  0b65		       20 66 0e 	      jsr	popLN
   1929  0b68		       98		      tya
   1930  0b69		       4a		      lsr
   1931  0b6a		       4a		      lsr
   1932  0b6b		       85 83		      sta	R0	;Get the table entry value
   1933  0b6d		       a9 00		      lda	#0
   1934  0b6f		       85 84		      sta	R0+1
   1935  0b71		       68		      pla
   1936  0b72		       a8		      tay
   1937  0b73		       4c 6f 06 	      jmp	pushR0nextIl
   1938  0b76				   iTaskNoEmpty
   1939  0b76		       20 66 0e 	      jsr	popLN
   1940  0b79		       68		      pla
   1941  0b7a		       a8		      tay
   1942  0b7b		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
   1943  0b7d		       a9 00		      lda	#0
   1944  0b7f		       4c 89 05 	      jmp	iErr2
   1945  0b82				   iTaskRetCurrent		;Get if task number is zero Current task
   1946  0b82		       ac 70 14 	      ldy	taskPtr
   1947  0b85		       d0 de		      bne	iTaskGetCurrent
   1948  0b87							;
   1949  0b87							;================================================================
   1950  0b87							; Returns task Status
   1951  0b87				   iTaskStat
   1952  0b87		       20 96 0b 	      jsr	iTaskValid
   1953  0b8a		       a9 00		      lda	#0
   1954  0b8c		       85 84		      sta	R0+1
   1955  0b8e		       b9 48 14 	      lda	taskTable,y
   1956  0b91		       85 83		      sta	R0
   1957  0b93		       4c 6f 06 	      jmp	pushR0nextIl
   1958  0b96							;
   1959  0b96							;================================================================
   1960  0b96							; Validate the task number on top of the stack
   1961  0b96		       20 53 0e    iTaskValid jsr	popR0
   1962  0b99		       a5 84		      lda	R0+1
   1963  0b9b		       d0 0d		      bne	iTaskValidErr
   1964  0b9d		       a5 83		      lda	R0
   1965  0b9f		       c9 00		      cmp	#0
   1966  0ba1		       f0 07		      beq	iTaskValidErr
   1967  0ba3		       18		      clc
   1968  0ba4		       2a		      rol
   1969  0ba5		       2a		      rol
   1970  0ba6		       c9 28		      cmp	#TASKCOUNT<<2
   1971  0ba8		       90 09		      bcc	iTaskIsValid
   1972  0baa
   1973  0baa		       68	   iTaskValidErr pla		;remove return address
   1974  0bab		       68		      pla
   1975  0bac		       a2 10		      ldx	#ERR_INVALID_PID
   1976  0bae		       a9 00		      lda	#0
   1977  0bb0		       4c 89 05 	      jmp	iErr2
   1978  0bb3
   1979  0bb3		       a8	   iTaskIsValid tay
   1980  0bb4		       60		      rts
   1981  0bb5							;
   1982  0bb5							;================================================================
   1983  0bb5							; Kill a running task, do nothing if already stopped
   1984  0bb5		       20 96 0b    iTaskKill  jsr	iTaskValid
   1985  0bb8		       a9 00		      lda	#0
   1986  0bba		       99 48 14 	      sta	taskTable,y	; Fall thru to go to next task
   1987  0bbd							;
   1988  0bbd							;================================================================
   1989  0bbd							;Skip to next task
   1990  0bbd				   iNTask
   1991  0bbd		       a9 01		      lda	#1
   1992  0bbf		       85 8a		      sta	taskCurrentCycles
   1993  0bc1		       4c e9 02 	      jmp	NextIL
   1994  0bc4							;
   1995  0bc4							;================================================================
   1996  0bc4							; Terminate a task
   1997  0bc4		       ac 70 14    iETask     ldy	taskPtr
   1998  0bc7		       c0 00		      cpy	#0
   1999  0bc9		       d0 03		      bne	iETaskCont
   2000  0bcb		       4c 75 05 	      jmp	iFIN	; if the main task does a ETASK then stop
   2001  0bce				   iETaskCont
   2002  0bce		       a9 00		      lda	#0
   2003  0bd0		       99 48 14 	      sta	taskTable,y	; mark entry as free
   2004  0bd3		       99 49 14 	      sta	taskTable+1,y	; Clear the entry in the table
   2005  0bd6		       99 4a 14 	      sta	taskTable+2,y
   2006  0bd9		       99 4b 14 	      sta	taskTable+3,y
   2007  0bdc		       c6 8c		      dec	taskCount	; reduce the number of active tasks
   2008  0bde		       85 8a		      sta	taskCurrentCycles	; Set to zero
   2009  0be0		       e6 8a		      inc	taskCurrentCycles	; Make it 1 as rtn will dec and check
   2010  0be2				   iETaskExit
   2011  0be2		       4c e9 02 	      jmp	NextIL
   2012  0be5
   2013  0be5							;
   2014  0be5							;================================================================
   2015  0be5							;Find an empty slot in the taskTable
   2016  0be5							;Return the index in y
   2017  0be5							;================================================================
   2018  0be5							;
   2019  0be5				   TaskEmpty
   2020  0be5		       a0 04		      ldy	#4	;The first slot is always the main line
   2021  0be7				   TaskLoop
   2022  0be7		       b9 48 14 	      lda	taskTable,y
   2023  0bea		       f0 0d		      beq	TaskEmptyFnd
   2024  0bec		       c8		      iny
   2025  0bed		       c8		      iny
   2026  0bee		       c8		      iny
   2027  0bef		       c8		      iny
   2028  0bf0		       c0 28		      cpy	#TASKCOUNT<<2	; Task
   2029  0bf2		       f0 02		      beq	TaskNoSlot	; No Empty Slots
   2030  0bf4		       90 f1		      bcc	TaskLoop	; Y is never zero
   2031  0bf6				   TaskNoSlot
   2032  0bf6		       a9 00		      lda	#0	; Z set if not found
   2033  0bf8		       60		      rts
   2034  0bf9				   TaskEmptyFnd
   2035  0bf9		       a9 01		      lda	#1
   2036  0bfb		       60		      rts
   2037  0bfc							;
   2038  0bfc							;=================================================================
   2039  0bfc							;
------- FILE support.asm LEVEL 2 PASS 4
      0  0bfc					      include	"support.asm"
      1  0bfc							;
      2  0bfc							;=====================================================
      3  0bfc							;=====================================================
      4  0bfc							;=====================================================
      5  0bfc							; This marks the start of support functions used by
      6  0bfc							; the IL opcodes.  These are support functions, NOT
      7  0bfc							; the IL code.
      8  0bfc							;=====================================================
      9  0bfc		       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting
     10  0bfc							;=====================================================
     11  0bfc					      Seg	Code
     12  0bfc							;=====================================================
     13  0bfc							; This gets the next two bytes pointed to by ILPC and
     14  0bfc							; returns them; X contains LSB, A contains MSB.  ILPC
     15  0bfc							; is advanced by two, and Y contains 0 on return.
     16  0bfc
     17  0bfc							;
     18  0bfc		       20 00 0c    getILWord  jsr	getILByte	;LSB
     19  0bff		       aa		      tax
     20  0c00							;
     21  0c00							;=====================================================
     22  0c00							; This gets the next byte pointed to by ILPC and
     23  0c00							; returns it in A.  On return, X is unchanged but Y
     24  0c00							; contains 0.
     25  0c00							;
     26  0c00		       a0 00	   getILByte  ldy	#0
     27  0c02		       b1 75		      lda	(ILPC),y	;get byte
     28  0c04		       08		      php		;save status
     29  0c05		       e6 75		      inc	ILPC	;inc LSB
     30  0c07		       d0 02		      bne	getILb2	;branch if no overflow
     31  0c09		       e6 76		      inc	ILPC+1	;inc MSB
     32  0c0b		       28	   getILb2    plp		;restore status
     33  0c0c		       60		      rts
     34  0c0d							;
     35  0c0d							;=====================================================
     36  0c0d							; Decrement ILPC by one.
     37  0c0d							;
     38  0c0d		       a5 75	   decIL      lda	ILPC
     39  0c0f		       d0 02		      bne	decIL2
     40  0c11		       c6 76		      dec	ILPC+1
     41  0c13		       c6 75	   decIL2     dec	ILPC
     42  0c15		       60		      rts
     43  0c16							;
     44  0c16							;=====================================================
     45  0c16							; Push the ILPC onto the return stack.  Actually, this
     46  0c16							; pushes the address of ILPC+2 since that's the next
     47  0c16							; address to execute.
     48  0c16							;
     49  0c16		       ac ea 14    pushILPC   ldy	retStackPtr
     50  0c19		       a5 75		      lda	ILPC
     51  0c1b		       18		      clc
     52  0c1c		       69 02		      adc	#2
     53  0c1e		       99 9a 14 	      sta	retStack,y
     54  0c21		       08		      php		;save C bit
     55  0c22		       c8		      iny
     56  0c23		       a5 76		      lda	ILPC+1
     57  0c25		       28		      plp		;restore C
     58  0c26		       69 00		      adc	#0
     59  0c28		       99 9a 14 	      sta	retStack,y
     60  0c2b		       c8		      iny
     61  0c2c		       8c ea 14 	      sty	retStackPtr
     62  0c2f		       60		      rts
     63  0c30							;
     64  0c30							;=====================================================
     65  0c30							; Pull the top entry from return stack and put into
     66  0c30							; ILPC.
     67  0c30							;
     68  0c30		       ac ea 14    popILPC    ldy	retStackPtr
     69  0c33		       88		      dey
     70  0c34		       b9 9a 14 	      lda	retStack,y
     71  0c37		       85 76		      sta	ILPC+1
     72  0c39		       88		      dey
     73  0c3a		       b9 9a 14 	      lda	retStack,y
     74  0c3d		       85 75		      sta	ILPC
     75  0c3f		       8c ea 14 	      sty	retStackPtr
     76  0c42		       60		      rts
     77  0c43							;
     78  0c43							;=====================================================
     79  0c43							; This searches for a specific line number that is in
     80  0c43							; R0.	There are three possible return conditions:
     81  0c43							; Line numbers are now the third byte, the first byte is now **************
     82  0c43							; a pointer to the next line, of course no longer that 53 byte
     83  0c43							; per line.
     84  0c43							;
     85  0c43							; Exact match was found:
     86  0c43							;    * Z set
     87  0c43							;    * CURPTR points to two-byte line number for that
     88  0c43							;	line.
     89  0c43							;
     90  0c43							; Next highest line found:
     91  0c43							;    * Z cleared
     92  0c43							;    * C set
     93  0c43							;    * CURPTR points to two-byte line number for that
     94  0c43							;	line.
     95  0c43							;
     96  0c43							; End of program reached:
     97  0c43							;    * Z cleared
     98  0c43							;    * C cleared
     99  0c43							;    * CURPTR points to first free byte at end of
    100  0c43							;	program.  Ie, it has save value as PROGRAMEND.
    101  0c43							;
    102  0c43							; A, X, and Y are all undefined on return.
    103  0c43							;
    104  0c43
    105  0c43				   findLine
    106  0c43		       a9 87		      lda	#ProgramStart&$ff	;Start of program -> CURPTR
    107  0c45		       85 7e		      sta	CURPTR
    108  0c47		       a9 15		      lda	#ProgramStart>>8
    109  0c49		       85 7f		      sta	CURPTR+1
    110  0c4b							;
    111  0c4b							; At end of code?
    112  0c4b							;
    113  0c4b				   iXFER1
    114  0c4b		       a5 7e		      lda	CURPTR	; chk CURPTR = END PROGRAM
    115  0c4d		       cd 7f 15 	      cmp	PROGRAMEND	; at end of program then stop run
    116  0c50		       d0 0b		      bne	xfer2	; not end
    117  0c52		       a5 7f		      lda	CURPTR+1
    118  0c54		       cd 80 15 	      cmp	PROGRAMEND+1
    119  0c57		       d0 04		      bne	xfer2	;Not at end
    120  0c59							;
    121  0c59							; Line not found and the end of the program was
    122  0c59							; reached.  Return Z and C both clear.
    123  0c59							;
    124  0c59		       a9 01		      lda	#1	;clear Z
    125  0c5b		       18		      clc		;clear C
    126  0c5c		       60		      rts
    127  0c5d							;
    128  0c5d							; Check for an exact line number match
    129  0c5d							;
    130  0c5d		       a5 83	   xfer2      lda	R0
    131  0c5f		       a0 01		      ldy	#1	; changed to skip extra length byte
    132  0c61		       d1 7e		      cmp	(CURPTR),y
    133  0c63		       d0 08		      bne	xfernotit
    134  0c65		       c8		      iny
    135  0c66		       a5 84		      lda	R0+1
    136  0c68		       d1 7e		      cmp	(CURPTR),y
    137  0c6a		       d0 01		      bne	xfernotit	; not a matching line number
    138  0c6c							;
    139  0c6c							; This is exactly the line we want.
    140  0c6c							;
    141  0c6c		       60		      rts		;it matches exactly
    142  0c6d							;
    143  0c6d							; See if this line is greater than the one we're
    144  0c6d							; searching for.
    145  0c6d							;
    146  0c6d		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    147  0c6f		       b1 7e		      lda	(CURPTR),y	;compare MSB first
    148  0c71		       c5 84		      cmp	R0+1
    149  0c73		       90 0b		      bcc	xfer3
    150  0c75		       d0 07		      bne	xfer4
    151  0c77		       88		      dey
    152  0c78		       b1 7e		      lda	(CURPTR),y	;compare LSB
    153  0c7a		       c5 83		      cmp	R0
    154  0c7c		       90 02		      bcc	xfer3
    155  0c7e							;
    156  0c7e							; This line is greater than the one we want, so
    157  0c7e							; return Z clear and C set.
    158  0c7e							;
    159  0c7e		       38	   xfer4      sec		;We found a line number greater
    160  0c7f		       60		      rts		;both conditions set
    161  0c80							;
    162  0c80							; Not the line (or droid) we're looking for.  Move to
    163  0c80							; the next line.
    164  0c80							;
    165  0c80		       20 86 0c    xfer3      jsr	FindNextLine
    166  0c83		       4c 4b 0c 	      jmp	iXFER1
    167  0c86							;
    168  0c86							;=====================================================
    169  0c86							; This advances CURPTR to the next line.  If there
    170  0c86							; are no more lines, this leaves CURPTR equal to
    171  0c86							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    172  0c86							; CURPTR is pointing to a valid line on entry.  This
    173  0c86							; pointer points to the two-byte line number.
    174  0c86							; Update this points to the 1 byte line length  ****************
    175  0c86							;
    176  0c86				   FindNextLine
    177  0c86		       a0 03		      ldy	#3	;skip line number and length byte
    178  0c88		       84 80		      sty	CUROFF	;this is the new offset
    179  0c8a		       a0 00		      ldy	#0
    180  0c8c		       b1 7e		      lda	(CURPTR),y	;Get the length
    181  0c8e		       18		      clc
    182  0c8f		       65 7e		      adc	CURPTR
    183  0c91		       85 7e		      sta	CURPTR
    184  0c93		       90 02		      bcc	FindNext4	;exit
    185  0c95		       e6 7f		      inc	CURPTR+1
    186  0c97		       60	   FindNext4  rts
    187  0c98							;
    188  0c98							;=====================================================
    189  0c98							; This compares CURPTR to PROGRAMEND and returns Z set
    190  0c98							; if they are equal, Z clear if not.
    191  0c98							;
    192  0c98		       a5 7e	   AtEnd      lda	CURPTR
    193  0c9a		       cd 7f 15 	      cmp	PROGRAMEND
    194  0c9d		       d0 05		      bne	atendexit
    195  0c9f		       a5 7f		      lda	CURPTR+1
    196  0ca1		       cd 80 15 	      cmp	PROGRAMEND+1
    197  0ca4		       60	   atendexit  rts
    198  0ca5							;
    199  0ca5							;=====================================================
    200  0ca5							; Print the contents of R0 as a signed decimal number.
    201  0ca5							; Does leading zero suppression.
    202  0ca5							;
    203  0ca5				   PrintDecimal
    204  0ca5		       a5 84		      lda	R0+1	;MSB has sign
    205  0ca7		       10 17		      bpl	pplus	;it's a positive number
    206  0ca9							;
    207  0ca9							; Negative numbers need more work.  Invert all the bits,
    208  0ca9							; then add one.
    209  0ca9							;
    210  0ca9		       a9 2d		      lda	#'-
    211  0cab		       20 a8 0f 	      jsr	VOUTCH	;print the negative sign
    212  0cae							;
    213  0cae		       a5 83		      lda	R0	;invert bits
    214  0cb0		       49 ff		      eor	#$ff
    215  0cb2		       85 83		      sta	R0
    216  0cb4		       a5 84		      lda	R0+1
    217  0cb6		       49 ff		      eor	#$ff
    218  0cb8		       85 84		      sta	R0+1
    219  0cba		       e6 83		      inc	R0	;add one
    220  0cbc		       d0 02		      bne	pplus
    221  0cbe		       e6 84		      inc	R0+1
    222  0cc0							;
    223  0cc0							; Print the value in R0 as a positive number.
    224  0cc0							;
    225  0cc0		       a2 00	   pplus      ldx	#0	;start of subtraction table
    226  0cc2		       8e 72 15 	      stx	diddigit	;no digits yet
    227  0cc5		       a0 00	   pploop     ldy	#0	;result of division
    228  0cc7		       a5 83	   pploop2    lda	R0	;LSB
    229  0cc9		       38		      sec
    230  0cca		       fd 09 0d 	      sbc	dectable,x
    231  0ccd		       85 83		      sta	R0
    232  0ccf		       a5 84		      lda	R0+1
    233  0cd1		       fd 0a 0d 	      sbc	dectable+1,x
    234  0cd4		       10 2e		      bpl	pplusok	;no underflow
    235  0cd6							;
    236  0cd6							; Else, underflow.  Add back in the LSB of the
    237  0cd6							; table to R0.
    238  0cd6							;
    239  0cd6		       18		      clc
    240  0cd7		       a5 83		      lda	R0
    241  0cd9		       7d 09 0d 	      adc	dectable,x
    242  0cdc		       85 83		      sta	R0
    243  0cde							;
    244  0cde							; Print the value in Y.  Actually, see if Y is zero and
    245  0cde							; whether any digit has been printed yet.  If Y isn't
    246  0cde							; zero or we've printed a digit, go ahead and print.
    247  0cde							;
    248  0cde		       8e 71 15 	      stx	printtx
    249  0ce1		       98		      tya
    250  0ce2		       09 00		      ora	#0	;set flags
    251  0ce4		       d0 05		      bne	pprintit	;non-zero, print
    252  0ce6							;
    253  0ce6		       ad 72 15 	      lda	diddigit
    254  0ce9		       f0 09		      beq	pprintno	;don't print
    255  0ceb							;
    256  0ceb		       98	   pprintit   tya
    257  0cec		       09 30		      ora	#'0
    258  0cee		       8d 72 15 	      sta	diddigit
    259  0cf1		       20 a8 0f 	      jsr	VOUTCH
    260  0cf4		       ae 71 15    pprintno   ldx	printtx
    261  0cf7							;
    262  0cf7							; Move to the next table entry
    263  0cf7							;
    264  0cf7		       e8		      inx
    265  0cf8		       e8		      inx
    266  0cf9		       e0 08		      cpx	#dectableend-dectable
    267  0cfb		       d0 c8		      bne	pploop	;not at end
    268  0cfd							;
    269  0cfd							; At the end.	R0 contains the final value
    270  0cfd							; to print.
    271  0cfd							;
    272  0cfd		       a5 83		      lda	R0
    273  0cff		       09 30		      ora	#'0
    274  0d01		       4c a8 0f 	      jmp	VOUTCH
    275  0d04							;
    276  0d04							; Finish doing the subtraction.
    277  0d04							;
    278  0d04		       85 84	   pplusok    sta	R0+1
    279  0d06		       c8		      iny
    280  0d07		       d0 be		      bne	pploop2
    281  0d09							;
    282  0d09							; Table of powers-of-ten
    283  0d09							;
      0  0d09				   dectable   dw	10000
      1  0d09		       10 27		      .word.w	10000
      0  0d0b					      dw	1000
      1  0d0b		       e8 03		      .word.w	1000
      0  0d0d					      dw	100
      1  0d0d		       64 00		      .word.w	100
      0  0d0f					      dw	10
      1  0d0f		       0a 00		      .word.w	10
    288  0d0f		       0d 11	   dectableend equ	*
    289  0d11							;
    290  0d11							;=====================================================
    291  0d11							; Convert an ASCII string to a number.  On input,
    292  0d11							; (CURPTR),Y points to the first digit.  This gets
    293  0d11							; digit-by-digit until finding a non-number.  Returns
    294  0d11							; Y pointing to the non-digit, and R0 contains the
    295  0d11							; number.  This does NOT check for valid ranges, so
    296  0d11							; a value like "123456789" will produce something,
    297  0d11							; but not what you had expected.
    298  0d11							;
    299  0d11		       a9 00	   getDecimal lda	#0
    300  0d13		       85 83		      sta	R0
    301  0d15		       85 84		      sta	R0+1
    302  0d17		       85 77		      sta	dpl	;temporary negative flag
    303  0d19							;
    304  0d19							; See if it's negative...
    305  0d19							;
    306  0d19		       84 13		      sty	$0013
    307  0d1b		       b1 7e		      lda	(CURPTR),y
    308  0d1d		       c9 2d		      cmp	#'-
    309  0d1f		       d0 02		      bne	getDecLoop
    310  0d21		       e6 77		      inc	dpl	;it's negative
    311  0d23							;
    312  0d23		       b1 7e	   getDecLoop lda	(CURPTR),y
    313  0d25		       c9 30		      cmp	#'0
    314  0d27		       90 36		      bcc	getDdone
    315  0d29		       c9 3a		      cmp	#'9+1
    316  0d2b		       b0 32		      bcs	getDdone
    317  0d2d		       38		      sec
    318  0d2e		       e9 30		      sbc	#'0	;convert to binary
    319  0d30		       48		      pha
    320  0d31							;
    321  0d31							; Now multiply R0 by 10.  Remember that
    322  0d31							; 2*N + 8*N = 10*N.
    323  0d31							;
    324  0d31		       06 83		      asl	R0
    325  0d33		       26 84		      rol	R0+1	;*2
    326  0d35		       a5 83		      lda	R0
    327  0d37		       85 85		      sta	R1
    328  0d39		       a5 84		      lda	R0+1
    329  0d3b		       85 86		      sta	R1+1
    330  0d3d		       06 83		      asl	R0
    331  0d3f		       26 84		      rol	R0+1	;*4
    332  0d41		       06 83		      asl	R0
    333  0d43		       26 84		      rol	R0+1	;*8
    334  0d45		       18		      clc		;now add the partial sums...
    335  0d46		       a5 83		      lda	R0	;...to get *10
    336  0d48		       65 85		      adc	R1
    337  0d4a		       85 83		      sta	R0
    338  0d4c		       a5 84		      lda	R0+1
    339  0d4e		       65 86		      adc	R1+1
    340  0d50		       85 84		      sta	R0+1
    341  0d52							;
    342  0d52							; Add in the new digit
    343  0d52							;
    344  0d52		       68		      pla
    345  0d53		       18		      clc
    346  0d54		       65 83		      adc	R0
    347  0d56		       85 83		      sta	R0
    348  0d58		       90 02		      bcc	getD2
    349  0d5a		       e6 84		      inc	R0+1
    350  0d5c							;
    351  0d5c							; Move to next character
    352  0d5c							;
    353  0d5c		       c8	   getD2      iny
    354  0d5d		       d0 c4		      bne	getDecLoop
    355  0d5f							;
    356  0d5f							; All done with digits, so now deal with it being
    357  0d5f							; negative.  If zero, then don't check for negative
    358  0d5f							; flag.  Ie, -0 is stored as 0.
    359  0d5f							;
    360  0d5f		       a5 83	   getDdone   lda	R0
    361  0d61		       05 84		      ora	R0+1
    362  0d63		       f0 16		      beq	getDone2	;zero
    363  0d65		       a5 77		      lda	dpl
    364  0d67		       f0 12		      beq	getDone2	;positive
    365  0d69							;
    366  0d69							; Invert all the bits, then add one.
    367  0d69							;
    368  0d69		       a5 83		      lda	R0
    369  0d6b		       49 ff		      eor	#$ff
    370  0d6d		       85 83		      sta	R0
    371  0d6f		       a5 84		      lda	R0+1
    372  0d71		       49 ff		      eor	#$ff
    373  0d73		       85 84		      sta	R0+1
    374  0d75							;
    375  0d75		       e6 83		      inc	R0
    376  0d77		       d0 02		      bne	getDone2
    377  0d79		       e6 84		      inc	R0+1
    378  0d7b				   getDone2
    379  0d7b		       a5 83		      lda	R0
    380  0d7d		       85 10		      sta	$0010
    381  0d7f		       a5 84		      lda	R0+1
    382  0d81		       85 11		      sta	$0011
    383  0d83		       a5 77		      lda	dpl
    384  0d85		       85 12		      sta	$012
    385  0d87
    386  0d87		       60		      rts
    387  0d88							;
    388  0d88							;=====================================================
    389  0d88							; Print the string that immediately follows the JSR to
    390  0d88							; this function.  Stops when a null byte is found,
    391  0d88							; then returns to the instruction immediately
    392  0d88							; following the null.
    393  0d88							;
    394  0d88							; Thanks to Ross Archer for this code.
    395  0d88							; http://www.6502.org/source/io/primm.htm
    396  0d88							;
    397  0d88				  -	      if	KIM
    398  0d88				  -puts       sty	putsy
    399  0d88				  -	      pla		;low part of "return" address
    400  0d88				  -			;(data start address)
    401  0d88				  -	      sta	dpl
    402  0d88				  -	      pla
    403  0d88				  -	      sta	dpl+1	;high part of "return" address
    404  0d88				  -			;(data start address)
    405  0d88				  -			;Note: we're pointing one short
    406  0d88				  -psinb      ldy	#1
    407  0d88				  -	      lda	(dpl),y	;Get next string character
    408  0d88				  -	      inc	dpl	;update the pointer
    409  0d88				  -	      bne	psinc	;if not, we're pntng to next char
    410  0d88				  -	      inc	dpl+1	;account for page crossing
    411  0d88				  -psinc      ora	#0	;Set flags according to contents of
    412  0d88				  -			;   Accumulator
    413  0d88				  -	      beq	psix1	;don't print the final NULL
    414  0d88				  -	      jsr	OUTCH	;write it out
    415  0d88				  -	      jmp	psinb	;back around
    416  0d88				  -psix1      inc	dpl
    417  0d88				  -	      bne	psix2
    418  0d88				  -	      inc	dpl+1	;account for page crossing
    419  0d88				  -psix2      ldy	putsy
    420  0d88				  -	      jmp	(dpl)	;return to byte following NULL
    421  0d88					      endif
    422  0d88							;
    423  0d88							;=====================================================
    424  0d88							; Gets a line of input into LINBUF.
    425  0d88							;
    426  0d88							; On entry:
    427  0d88							;    A contains the prompt character, or 0 if none.
    428  0d88							;
    429  0d88							; On exit:
    430  0d88							;    CURPTR points to LINBUF
    431  0d88							;    LINBUF contains the line with 0 at the end.
    432  0d88							;    Y has offset to first non-space character
    433  0d88							;    CURROFF has the same as Y.
    434  0d88							;
    435  0d88		       a2 ec	   GetLine    ldx	#LINBUF&$ff
    436  0d8a		       86 7e		      stx	CURPTR
    437  0d8c		       a2 14		      ldx	#LINBUF>>8
    438  0d8e		       86 7f		      stx	CURPTR+1
    439  0d90							;
    440  0d90							; Prompt
    441  0d90							;
    442  0d90		       48		      pha		;save for retries
    443  0d91		       68	   GetLinePr  pla		;restore
    444  0d92		       48		      pha		;save again
    445  0d93		       09 00		      ora	#0	;any prompt?
    446  0d95		       f0 08		      beq	getlinenp
    447  0d97		       20 06 02 	      jsr	OUTCH
    448  0d9a		       a9 20		      lda	#$20
    449  0d9c		       20 06 02 	      jsr	OUTCH	;space after prompt
    450  0d9f							;
    451  0d9f		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    452  0da1		       8e 70 15    getline1   stx	getlinx
    453  0da4		       20 09 02 	      jsr	GETCH
    454  0da7					      if	CTMON65
    455  0da7		       48		      pha
    456  0da8		       20 0c f0 	      jsr	cout	;echo echo echo
    457  0dab		       68		      pla
    458  0dac					      endif
    459  0dac		       c9 0d		      cmp	#CR
    460  0dae		       f0 0d		      beq	getlind	;end of line
    461  0db0		       c9 08		      cmp	#BS	;backspace?
    462  0db2		       f0 21		      beq	getlinebs
    463  0db4		       ae 70 15 	      ldx	getlinx
    464  0db7		       9d ec 14 	      sta	LINBUF,x
    465  0dba		       e8		      inx
    466  0dbb		       d0 e4		      bne	getline1
    467  0dbd							;
    468  0dbd							; CR was hit
    469  0dbd							;
    470  0dbd		       a9 00	   getlind    lda	#0
    471  0dbf		       ae 70 15 	      ldx	getlinx
    472  0dc2		       9d ec 14 	      sta	LINBUF,x
    473  0dc5		       85 80		      sta	CUROFF
    474  0dc7							;
    475  0dc7							; Output a CR/LF
    476  0dc7							;
    477  0dc7		       20 0c 02 	      jsr	CRLF
    478  0dca							;
    479  0dca							; If a blank line, prompt again.
    480  0dca							;
    481  0dca		       a0 00		      ldy	#0
    482  0dcc		       20 1c 0f 	      jsr	SkipSpaces
    483  0dcf		       b1 7e		      lda	(CURPTR),y
    484  0dd1		       f0 be		      beq	GetLinePr	;empty line
    485  0dd3		       68		      pla		;get rid of prompt char
    486  0dd4		       60		      rts
    487  0dd5							;
    488  0dd5							; Backspace was hit
    489  0dd5							;
    490  0dd5		       ae 70 15    getlinebs  ldx	getlinx
    491  0dd8		       f0 c7		      beq	getline1	;at start of line
    492  0dda		       ca		      dex
    493  0ddb		       20 12 f0 	      jsr	puts
      0  0dde					      db	27,"[K",0
      1  0dde		       1b 5b 4b 00	      .byte.b	27,"[K",0
    495  0de2		       4c a1 0d 	      jmp	getline1
    496  0de5							;
    497  0de5							;=====================================================
    498  0de5							; Count the length of the line currently in LINBUF
    499  0de5							; starting at offset Y.  Returns the length in X.  The
    500  0de5							; starting offset in Y should point past the ASCII
    501  0de5							; line number.  Also counts the trailing NULL and two
    502  0de5							; extra bytes for where the line number will be.
    503  0de5							; Update must now include leading length byte not the null at end ****************
    504  0de5							;
    505  0de5				   getLineLength
    506  0de5		       a2 00		      ldx	#0	;size
    507  0de7		       b9 ec 14    getLineL2  lda	LINBUF,y
    508  0dea		       f0 04		      beq	getLineL3
    509  0dec		       c8		      iny
    510  0ded		       e8		      inx
    511  0dee		       d0 f7		      bne	getLineL2
    512  0df0		       e8	   getLineL3  inx		;count null at end
    513  0df1		       e8		      inx		;line number LSB
    514  0df2		       e8		      inx		;MSB
    515  0df3		       e8		      inx		;change: count new leading line length
    516  0df4		       86 7d		      stx	lineLength
    517  0df6		       60		      rts
    518  0df7							;
    519  0df7							;=====================================================
    520  0df7							; Count the length of the line pointed to by CURPTR.
    521  0df7							; This also counts the line number and the terminating
    522  0df7							; null.  Ie, this string returns 8:
    523  0df7							;
    524  0df7							; <lineLow><lineHi>Hello<null>
    525  0df7							;
    526  0df7							; Another way of looking at it: add the return value
    527  0df7							; to the CURPTR and it'll point to the next line's
    528  0df7							; line number.  Returns the value in Y.
    529  0df7							; Update to ject get the leading byte length ********************
    530  0df7							;
    531  0df7							;getCURPTRLength
    532  0df7							;		ldy	CURPTR
    533  0df7							;		ldy	#3	;change: skip line number and leading length byte
    534  0df7							;getCLineL2	lda	(CURPTR),y
    535  0df7							;		beq	getCLineL3
    536  0df7							;		iny
    537  0df7							;		bne	getCLineL2
    538  0df7							;getCLineL3	iny		;count null at end
    539  0df7							;		rts
    540  0df7							;
    541  0df7							;=====================================================
    542  0df7							; This saves ILPC.  This saves to a single save area,
    543  0df7							; so it can't be called more than once.
    544  0df7							;
    545  0df7		       a5 75	   saveIL     lda	ILPC
    546  0df9		       85 79		      sta	tempIL
    547  0dfb		       a5 76		      lda	ILPC+1
    548  0dfd		       85 7a		      sta	tempIL+1
    549  0dff		       60		      rts
    550  0e00							;
    551  0e00							;=====================================================
    552  0e00							; This restores ILPC.
    553  0e00							;
    554  0e00		       a5 79	   restoreIL  lda	tempIL
    555  0e02		       85 75		      sta	ILPC
    556  0e04		       a5 7a		      lda	tempIL+1
    557  0e06		       85 76		      sta	ILPC+1
    558  0e08		       60		      rts
    559  0e09							;
    560  0e09							;=====================================================
    561  0e09							; This pushes R0 onto the stack.
    562  0e09							;
    563  0e09		       ae 99 14    pushR0     ldx	mathStackPtr
    564  0e0c		       a5 83		      lda	R0
    565  0e0e		       9d 71 14 	      sta	mathStack,x
    566  0e11		       e8		      inx
    567  0e12		       a5 84		      lda	R0+1
    568  0e14		       9d 71 14 	      sta	mathStack,x
    569  0e17		       e8		      inx
    570  0e18		       8e 99 14 	      stx	mathStackPtr
    571  0e1b		       60		      rts
    572  0e1c
    573  0e1c							;=====================================================
    574  0e1c							; This pushes curptr basic current line onto the call stack.
    575  0e1c
    576  0e1c				   pushLN
    577  0e1c		       8c 79 15 	      sty	rtemp1
    578  0e1f		       ac eb 14 	      ldy	GoSubStackPtr
    579  0e22		       98		      tya
    580  0e23		       c9 3c		      cmp	#GOSUBSTACKSIZE*3
    581  0e25		       f0 17		      beq	pusherr
    582  0e27		       a5 7e		      lda	CURPTR
    583  0e29		       91 81		      sta	(GOSUBSTACK),y
    584  0e2b		       c8		      iny
    585  0e2c		       a5 7f		      lda	CURPTR+1
    586  0e2e		       91 81		      sta	(GOSUBSTACK),y
    587  0e30		       c8		      iny
    588  0e31		       a5 80		      lda	CUROFF
    589  0e33		       91 81		      sta	(GOSUBSTACK),y
    590  0e35		       c8		      iny
    591  0e36		       8c eb 14 	      sty	GoSubStackPtr
    592  0e39		       ac 79 15 	      ldy	rtemp1
    593  0e3c		       18		      clc
    594  0e3d		       60		      rts
    595  0e3e
    596  0e3e				   pusherr
    597  0e3e		       38		      sec
    598  0e3f		       60		      rts
    599  0e40							;
    600  0e40							;=====================================================
    601  0e40							; This pushes R1 onto the stack
    602  0e40							;
    603  0e40		       ae 99 14    pushR1     ldx	mathStackPtr
    604  0e43		       a5 85		      lda	R1
    605  0e45		       9d 71 14 	      sta	mathStack,x
    606  0e48		       e8		      inx
    607  0e49		       a5 86		      lda	R1+1
    608  0e4b		       9d 71 14 	      sta	mathStack,x
    609  0e4e		       e8		      inx
    610  0e4f		       8e 99 14 	      stx	mathStackPtr
    611  0e52		       60		      rts
    612  0e53							;
    613  0e53							;=====================================================
    614  0e53							; This pops Top Of Stack and places it in R0.
    615  0e53							;
    616  0e53		       ae 99 14    popR0      ldx	mathStackPtr
    617  0e56		       ca		      dex
    618  0e57		       bd 71 14 	      lda	mathStack,x
    619  0e5a		       85 84		      sta	R0+1
    620  0e5c		       ca		      dex
    621  0e5d		       bd 71 14 	      lda	mathStack,x
    622  0e60		       85 83		      sta	R0
    623  0e62		       8e 99 14 	      stx	mathStackPtr
    624  0e65		       60		      rts
    625  0e66							;=====================================================
    626  0e66							; This pops Top Of gosub call Stack and
    627  0e66							; laces it in CURPTR.
    628  0e66							;
    629  0e66		       8c 79 15    popLN      sty	rtemp1
    630  0e69		       ac eb 14 	      ldy	GoSubStackPtr
    631  0e6c		       88		      dey
    632  0e6d		       98		      tya
    633  0e6e		       c9 ff		      cmp	#$FF
    634  0e70		       f0 16		      beq	poperr
    635  0e72		       b1 81		      lda	(GOSUBSTACK),y
    636  0e74		       85 80		      sta	CUROFF
    637  0e76		       88		      dey
    638  0e77		       b1 81		      lda	(GOSUBSTACK),y
    639  0e79		       85 7f		      sta	CURPTR+1
    640  0e7b		       88		      dey
    641  0e7c		       b1 81		      lda	(GOSUBSTACK),y
    642  0e7e		       85 7e		      sta	CURPTR
    643  0e80		       8c eb 14 	      sty	GoSubStackPtr
    644  0e83		       ac 79 15 	      ldy	rtemp1
    645  0e86		       18		      clc
    646  0e87		       60		      rts
    647  0e88		       38	   poperr     sec
    648  0e89		       60		      rts
    649  0e8a							;
    650  0e8a							;=====================================================
    651  0e8a							; This pops TOS and places it in R1.
    652  0e8a							;
    653  0e8a		       ae 99 14    popR1      ldx	mathStackPtr
    654  0e8d		       ca		      dex
    655  0e8e		       bd 71 14 	      lda	mathStack,x
    656  0e91		       85 86		      sta	R1+1
    657  0e93		       ca		      dex
    658  0e94		       bd 71 14 	      lda	mathStack,x
    659  0e97		       85 85		      sta	R1
    660  0e99		       8e 99 14 	      stx	mathStackPtr
    661  0e9c		       60		      rts
    662  0e9d							;
    663  0e9d							;=====================================================
    664  0e9d							; This pops TOS and places it in MQ.
    665  0e9d							;
    666  0e9d		       ae 99 14    popMQ      ldx	mathStackPtr
    667  0ea0		       ca		      dex
    668  0ea1		       bd 71 14 	      lda	mathStack,x
    669  0ea4		       8d 77 15 	      sta	MQ+1
    670  0ea7		       ca		      dex
    671  0ea8		       bd 71 14 	      lda	mathStack,x
    672  0eab		       8d 76 15 	      sta	MQ
    673  0eae		       8e 99 14 	      stx	mathStackPtr
    674  0eb1		       60		      rts
    675  0eb2							;
    676  0eb2							;=====================================================
    677  0eb2							; This assists with multiplication and division by
    678  0eb2							; looking at R0 and R1 and saving a flag as to what
    679  0eb2							; sign the result will be.  Math is always done on
    680  0eb2							; positive numbers, so this converts negative numbers
    681  0eb2							; into positives.  On exit, R0 and R1 are both
    682  0eb2							; positive.  If the signs were different then 'signs'
    683  0eb2							; will be non-zero.
    684  0eb2							;
    685  0eb2		       a9 00	   SaveSigns  lda	#0
    686  0eb4		       8d 78 15 	      sta	sign	;assume positive
    687  0eb7		       a5 84		      lda	R0+1	;MSB
    688  0eb9		       10 13		      bpl	SaveSigns1
    689  0ebb		       ee 78 15 	      inc	sign	;it's negative
    690  0ebe		       49 ff		      eor	#$ff	;flip bits
    691  0ec0		       85 84		      sta	R0+1
    692  0ec2		       a5 83		      lda	R0
    693  0ec4		       49 ff		      eor	#$ff
    694  0ec6		       85 83		      sta	R0
    695  0ec8		       e6 83		      inc	R0
    696  0eca		       d0 02		      bne	SaveSigns1
    697  0ecc		       e6 84		      inc	R0+1
    698  0ece		       a5 86	   SaveSigns1 lda	R1+1
    699  0ed0		       10 1a		      bpl	SaveSigns2
    700  0ed2		       48		      pha
    701  0ed3		       ad 78 15 	      lda	sign
    702  0ed6		       49 01		      eor	#1
    703  0ed8		       8d 78 15 	      sta	sign
    704  0edb		       68		      pla
    705  0edc		       49 ff		      eor	#$ff	;flip bits
    706  0ede		       85 86		      sta	R1+1
    707  0ee0		       a5 85		      lda	R1
    708  0ee2		       49 ff		      eor	#$ff
    709  0ee4		       85 85		      sta	R1
    710  0ee6		       e6 85		      inc	R1
    711  0ee8		       d0 02		      bne	SaveSigns2
    712  0eea		       e6 86		      inc	R1+1
    713  0eec		       60	   SaveSigns2 rts
    714  0eed							;
    715  0eed							;=====================================================
    716  0eed							; This looks at the value of 'signs' and will convert
    717  0eed							; both R0 and R1 to negative if set.
    718  0eed							;
    719  0eed				   RestoreSigns
    720  0eed		       ad 78 15 	      lda	sign
    721  0ef0		       f0 28		      beq	restoresigns2
    722  0ef2							;
    723  0ef2		       a5 83		      lda	R0
    724  0ef4		       d0 02		      bne	restoresigns3
    725  0ef6		       c6 84		      dec	R0+1
    726  0ef8				   restoresigns3
    727  0ef8		       c6 83		      dec	R0
    728  0efa		       a5 83		      lda	R0
    729  0efc		       49 ff		      eor	#$ff
    730  0efe		       85 83		      sta	R0
    731  0f00		       a5 84		      lda	R0+1
    732  0f02		       49 ff		      eor	#$ff
    733  0f04		       85 84		      sta	R0+1
    734  0f06							;
    735  0f06		       a5 85		      lda	R1
    736  0f08		       d0 02		      bne	restoresigns4
    737  0f0a		       c6 86		      dec	R1+1
    738  0f0c				   restoresigns4
    739  0f0c		       c6 85		      dec	R1
    740  0f0e		       a5 85		      lda	R1
    741  0f10		       49 ff		      eor	#$ff
    742  0f12		       85 85		      sta	R1
    743  0f14		       a5 86		      lda	R1+1
    744  0f16		       49 ff		      eor	#$ff
    745  0f18		       85 86		      sta	R1+1
    746  0f1a							;
    747  0f1a				   restoresigns2
    748  0f1a		       60		      rts
    749  0f1b							;
    750  0f1b							;=====================================================
    751  0f1b							; Skip over spaces.  Returns Y with the offset to
    752  0f1b							; either the last character in the line, or the first
    753  0f1b							; non-space character.
    754  0f1b							;
    755  0f1b		       c8	   skipsp2    iny
    756  0f1c		       b1 7e	   SkipSpaces lda	(CURPTR),y
    757  0f1e		       f0 04		      beq	Skip3	;end of line
    758  0f20		       c9 20		      cmp	#SPACE
    759  0f22		       f0 f7		      beq	skipsp2
    760  0f24		       60	   Skip3      rts
    761  0f25							;
    762  0f25							;=====================================================
    763  0f25							; This is some debug logic which displays the current
    764  0f25							; value of the ILPC and the line buffer.
    765  0f25							;
    766  0f25		       20 12 f0    dbgLine    jsr	puts
      0  0f28					      db	"ILPC: ",0
      1  0f28		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    768  0f2f		       a5 76		      lda	ILPC+1
    769  0f31		       20 0f 02 	      jsr	OUTHEX
    770  0f34		       a5 75		      lda	ILPC
    771  0f36		       20 0f 02 	      jsr	OUTHEX
    772  0f39		       a9 20		      lda	#SPACE
    773  0f3b		       20 06 02 	      jsr	OUTCH
    774  0f3e		       a0 00		      ldy	#0
    775  0f40		       b1 75		      lda	(ILPC),y
    776  0f42		       20 0f 02 	      jsr	OUTHEX
    777  0f45							;
    778  0f45							; Display the CURPTR value and offset
    779  0f45							;
    780  0f45		       20 12 f0 	      jsr	puts
      0  0f48					      db	", CURPTR: ",0
      1  0f48		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    782  0f53		       a5 7f		      lda	CURPTR+1
    783  0f55		       20 0f 02 	      jsr	OUTHEX
    784  0f58		       a5 7e		      lda	CURPTR
    785  0f5a		       20 0f 02 	      jsr	OUTHEX
    786  0f5d		       a9 2b		      lda	#'+
    787  0f5f		       20 06 02 	      jsr	OUTCH
    788  0f62		       a5 80		      lda	CUROFF
    789  0f64		       20 0f 02 	      jsr	OUTHEX
    790  0f67							;
    791  0f67		       4c 0c 02 	      jmp	CRLF
    792  0f6a							;
    793  0f6a							;=====================================================
    794  0f6a							; This function might go away eventually, but was
    795  0f6a							; added to provide data for other pieces of code.
    796  0f6a							; It has some ties to the operating environment that
    797  0f6a							; will need to be customized for the target system.
    798  0f6a							;
    799  0f6a				   GetSizes
    800  0f6a							;
    801  0f6a							; Here is machine specific code to get the highest
    802  0f6a							; memory location that can be used by BASIC.
    803  0f6a							;
    804  0f6a					      if	ProgramStart < $2000
    805  0f6a		       a9 ff		      lda	#$ff
    806  0f6c		       8d 81 15 	      sta	HighMem	;$13ff for KIM-1
    807  0f6f		       a9 de		      lda	#$DE	;#$13
    808  0f71		       8d 82 15 	      sta	HighMem+1
    809  0f74				  -	      else
    810  0f74				  -	      lda	#$ff
    811  0f74				  -	      sta	HighMem	;$CFFF otherwise
    812  0f74				  -	      lda	#$cf
    813  0f74				  -	      sta	HighMem+1
    814  0f74					      endif
    815  0f74							;
    816  0f74							; This computes the available memory remaining.
    817  0f74							;
    818  0f74		       38		      sec
    819  0f75		       ad 81 15 	      lda	HighMem
    820  0f78		       ed 7f 15 	      sbc	PROGRAMEND
    821  0f7b		       8d 85 15 	      sta	FreeMem
    822  0f7e		       85 83		      sta	R0
    823  0f80		       ad 82 15 	      lda	HighMem+1
    824  0f83		       ed 80 15 	      sbc	PROGRAMEND+1
    825  0f86		       8d 86 15 	      sta	FreeMem+1
    826  0f89		       85 84		      sta	R0+1
    827  0f8b							;
    828  0f8b							; This computes the size of the current user program.
    829  0f8b							;
    830  0f8b		       38		      sec
    831  0f8c		       ad 7f 15 	      lda	PROGRAMEND
    832  0f8f		       e9 87		      sbc	#ProgramStart&$ff
    833  0f91		       8d 83 15 	      sta	UsedMem
    834  0f94		       ad 80 15 	      lda	PROGRAMEND+1
    835  0f97		       e9 15		      sbc	#ProgramStart>>8
    836  0f99		       8d 84 15 	      sta	UsedMem+1
    837  0f9c							;
    838  0f9c		       60		      rts
    839  0f9d							;
    840  0f9d							;=====================================================
    841  0f9d							; Set output vector to the console output function
    842  0f9d							;
    843  0f9d				   SetOutConsole
    844  0f9d		       a9 06		      lda	#OUTCH&$ff
    845  0f9f		       8d 7c 15 	      sta	BOutVec
    846  0fa2		       a9 02		      lda	#OUTCH/256
    847  0fa4		       8d 7d 15 	      sta	BOutVec+1
    848  0fa7		       60		      rts
    849  0fa8							;
    850  0fa8							;=====================================================
    851  0fa8							; Jump to the output function in BOutVec
    852  0fa8							;
    853  0fa8		       6c 7c 15    VOUTCH     jmp	(BOutVec)
    854  0fab
    855  0fab							;====================================================
    856  0fab		       15 79	   PrtTerm    equ	rtemp1
    857  0fab
    858  0fab							; Print Y has the offset to use
    859  0fab		       a5 7e	   PrtQuoted  lda	CURPTR
    860  0fad		       85 88		      sta	PrtFrom
    861  0faf		       a5 7f		      lda	CURPTR+1
    862  0fb1		       85 89		      sta	PrtFrom+1
    863  0fb3		       a9 22		      lda	#'"
    864  0fb5		       8d 79 15 	      sta	PrtTerm
    865  0fb8		       4c c4 0f 	      jmp	PrtLoop
    866  0fbb
    867  0fbb							; Print a string pointed to by x= h, y=l terminated by a
    868  0fbb							; Return y as the length
    869  0fbb
    870  0fbb		       86 89	   PrtStr     stx	PrtFrom+1
    871  0fbd		       84 88		      sty	PrtFrom
    872  0fbf		       8d 79 15 	      sta	PrtTerm
    873  0fc2		       a0 00		      ldy	#0
    874  0fc4
    875  0fc4		       b1 88	   PrtLoop    lda	(PrtFrom),y
    876  0fc6		       cd 79 15 	      cmp	PrtTerm
    877  0fc9		       f0 0b		      beq	PrtEnd
    878  0fcb		       c9 00		      cmp	#0	; always end if 0 is found
    879  0fcd		       f0 07		      beq	PrtEnd
    880  0fcf		       20 06 02 	      jsr	OUTCH
    881  0fd2		       c8		      iny
    882  0fd3		       4c c4 0f 	      jmp	PrtLoop
    883  0fd6		       c8	   PrtEnd     iny		;return byte after the copy
    884  0fd7		       60		      rts
    885  0fd8
    886  0fd8							;====================================================
    887  0fd8							;Clear the terminal assume it is ansii or vt100
    888  0fd8							;
    889  0fd8				   iCLEARSCREEN
    890  0fd8		       20 12 f0 	      jsr	puts
      0  0fdb					      db	$1b,'[,'3,'J,0
      1  0fdb		       1b 5b 33 4a*	      .byte.b	$1b,'[,'3,'J,0
    892  0fe0		       4c e9 02 	      jmp	NextIL
------- FILE mytb.asm
   2041  0fe3					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 4
      0  0fe3					      include	"storage.asm"
      1  0fe3							;
      2  0fe3							;=====================================================
      3  0fe3							;=====================================================
      4  0fe3							;=====================================================
      5  0fe3							; This file contains the functions for saving and
      6  0fe3							; restoring programs from some sort of mass storage
      7  0fe3							; device.  This particular version is for using the
      8  0fe3							; Corsham Tech SD Card System.
      9  0fe3							;=====================================================
     10  0fe3							;=====================================================
     11  0fe3							;=====================================================
     12  0fe3
     13 Udf8e					      seg.u	Data
     14 Udf8e		       00	   diskBufLength ds	1
     15 Udf8f		       00	   diskBufOffset ds	1
     16 Udf90		       00 00 00 00*DiskFileName ds	14
     17 Udf9e
     18  0fe3					      SEG	Code
     19  0fe3
     20  0fe3							;
     21  0fe3							;=====================================================
     22  0fe3							; Open a file for reading as a program.  The next
     23  0fe3							; thing on the line should be the filename.
     24  0fe3							;
     25  0fe3				   iOPENREAD
     26  0fe3					      if	XKIM || CTMON65
     27  0fe3		       a4 80		      ldy	CUROFF
     28  0fe5		       b1 7e		      lda	(CURPTR),y
     29  0fe7		       d0 07		      bne	iOPENfn	;might be filename
     30  0fe9							;
     31  0fe9							; No filename supplied.
     32  0fe9							;
     33  0fe9		       a9 00	   iOPENnofn  lda	#0
     34  0feb		       a2 09		      ldx	#ERR_NO_FILENAME
     35  0fed		       4c 89 05 	      jmp	iErr2
     36  0ff0							;
     37  0ff0							; Add the offset into the buffer start
     38  0ff0							;
     39  0ff0		       18	   iOPENfn    clc
     40  0ff1		       98		      tya
     41  0ff2		       65 7e		      adc	CURPTR
     42  0ff4		       a8		      tay		;LSB
     43  0ff5		       a5 7f		      lda	CURPTR+1
     44  0ff7		       69 00		      adc	#0
     45  0ff9		       aa		      tax
     46  0ffa		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  0ffd		       90 07		      bcc	Ropenok	;branch if opened ok
     48  0fff							;
     49  0fff							; Open failed
     50  0fff							;
     51  0fff		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  1001		       a9 00	   Rdfail2    lda	#0
     53  1003		       4c 89 05 	      jmp	iErr2
     54  1006							;
     55  1006							; Clear counts and offsets so the next read will
     56  1006							; cause the file to be read.
     57  1006							;
     58  1006		       a9 00	   Ropenok    lda	#0
     59  1008		       8d 8f df 	      sta	diskBufOffset
     60  100b		       8d 8e df 	      sta	diskBufLength
     61  100e		       4c e9 02 	      jmp	NextIL
     62  1011					      endif
     63  1011
     64  1011							;
     65  1011							;==============================jlit 08/02/2022========
     66  1011							;Remove a file from the disk
     67  1011				   iRMFILE
     68  1011					      if	XKIM || CTMON65
     69  1011		       a4 80		      ldy	CUROFF
     70  1013		       b1 7e		      lda	(CURPTR),y
     71  1015		       f0 19		      beq	iRMnofn
     72  1017							;
     73  1017		       18		      clc
     74  1018		       98		      tya
     75  1019		       65 7e		      adc	CURPTR
     76  101b		       a8		      tay		;LSB
     77  101c		       a5 7f		      lda	CURPTR+1
     78  101e		       69 00		      adc	#0
     79  1020		       aa		      tax
     80  1021		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  1024		       90 07		      bcc	wrmOk	;branch if removed ok
     82  1026		       a9 00		      lda	#0
     83  1028		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  102a		       4c 89 05 	      jmp	iErr2
     85  102d		       4c e9 02    wrmOk      jmp	NextIL
     86  1030
     87  1030							; No filename supplied.
     88  1030							;
     89  1030		       a9 00	   iRMnofn    lda	#0
     90  1032		       a2 09		      ldx	#ERR_NO_FILENAME
     91  1034		       4c 89 05 	      jmp	iErr2
     92  1037					      endif
     93  1037							;
     94  1037							;=====================================================
     95  1037				   iOPENWRITE
     96  1037					      if	XKIM || CTMON65
     97  1037		       a4 80		      ldy	CUROFF
     98  1039		       b1 7e		      lda	(CURPTR),y
     99  103b		       f0 f3		      beq	iRMnofn
    100  103d							;
    101  103d		       18		      clc
    102  103e		       98		      tya
    103  103f		       65 7e		      adc	CURPTR
    104  1041		       a8		      tay		;LSB
    105  1042		       a5 7f		      lda	CURPTR+1
    106  1044		       69 00		      adc	#0
    107  1046		       aa		      tax
    108  1047		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  104a		       90 07		      bcc	Wopenok	;branch if opened ok
    110  104c							;
    111  104c							; Open failed
    112  104c							;
    113  104c		       a9 00	   Wdfail     lda	#0
    114  104e		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  1050		       4c 89 05 	      jmp	iErr2
    116  1053							;
    117  1053		       4c e9 02    Wopenok    jmp	NextIL
    118  1056					      endif
    119  1056							;
    120  1056							;=====================================================
    121  1056							; Gets a line of input from the disk file and puts it
    122  1056							; into LINBUF.
    123  1056							;
    124  1056							; On exit:
    125  1056							;    CURPTR points to LINBUF
    126  1056							;    LINBUF contains the line with 0 at the end.
    127  1056							;    Y has offset to first non-space character
    128  1056							;    CURROFF has the same as Y.
    129  1056							;
    130  1056				   iDGETLINE
    131  1056					      if	XKIM || CTMON65
    132  1056		       a2 ec		      ldx	#LINBUF&$ff
    133  1058		       86 7e		      stx	CURPTR
    134  105a		       a2 14		      ldx	#LINBUF>>8
    135  105c		       86 7f		      stx	CURPTR+1
    136  105e							;
    137  105e		       a2 00		      ldx	#0	;offset
    138  1060		       8e 70 15    iDgetLoop  stx	getlinx
    139  1063		       20 c1 10 	      jsr	getNextFileByte
    140  1066		       b0 16		      bcs	iGetEOF
    141  1068		       c9 0d		      cmp	#CR
    142  106a		       f0 0d		      beq	iGetEOL
    143  106c		       c9 0a		      cmp	#LF
    144  106e		       f0 09		      beq	iGetEOL
    145  1070		       ae 70 15 	      ldx	getlinx
    146  1073		       9d ec 14 	      sta	LINBUF,x
    147  1076		       e8		      inx
    148  1077		       d0 e7		      bne	iDgetLoop
    149  1079							;
    150  1079							; Handle end of line.	If the line has nothing, loop
    151  1079							; back and get another line.
    152  1079							;
    153  1079		       ae 70 15    iGetEOL    ldx	getlinx	;blank line?
    154  107c		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  107e							;
    156  107e							; This can fall through when there is a line, or
    157  107e							; called directly when EOF is encountered.
    158  107e							;
    159  107e		       ae 70 15    iGetEOF    ldx	getlinx
    160  1081		       a9 00		      lda	#0
    161  1083		       9d ec 14 	      sta	LINBUF,x
    162  1086		       85 80		      sta	CUROFF
    163  1088		       a0 00		      ldy	#0
    164  108a		       20 1c 0f 	      jsr	SkipSpaces
    165  108d		       4c e9 02 	      jmp	NextIL
    166  1090					      endif
    167  1090
    168  1090							;
    169  1090							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  1090							; DISK
    171  1090							;
    172  1090				   iDDIR
    173  1090					      if	XKIM || CTMON65
    174  1090		       20 30 f0 	      jsr	DiskDir
    175  1093							;
    176  1093							; Get/Display each entry
    177  1093							;
    178  1093		       a2 df	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  1095		       a0 90		      ldy	#DiskFileName&$ff
    180  1097		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  109a		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  109c		       20 12 f0 	      jsr	puts
      0  109f					      db	"   ",0
      1  109f		       20 20 20 00	      .byte.b	"   ",0
    184  10a3							; Print the line to the console
    185  10a3		       a2 df		      ldx	#DiskFileName/256	;pointer to buffer
    186  10a5		       a0 90		      ldy	#DiskFileName&$ff
    187  10a7		       a5 00		      lda	0
    188  10a9		       20 bb 0f 	      jsr	PrtStr	;else print name
    189  10ac		       20 18 f0 	      jsr	crlf
    190  10af
    191  10af		       4c 93 10 	      jmp	DiskDirLoop	;do next entry
    192  10b2		       4c e9 02    DiskDirEnd jmp	NextIL
    193  10b5					      endif
    194  10b5							;
    195  10b5							;=====================================================
    196  10b5							; Does a LIST to a Disk file.
    197  10b5							;
    198  10b5				   iDLIST
    199  10b5					      if	XKIM || CTMON65
    200  10b5		       20 f0 10 	      jsr	SetOutDisk
    201  10b8		       4c 1d 07 	      jmp	iLST2
    202  10bb					      endif
    203  10bb							;
    204  10bb							;=====================================================
    205  10bb							; Closes any pending disk file.  Okay to call if there
    206  10bb							; is no open file.
    207  10bb							;
    208  10bb				   iDCLOSE
    209  10bb					      if	XKIM || CTMON65
    210  10bb		       20 42 f0 	      jsr	DiskClose
    211  10be		       4c e9 02 	      jmp	NextIL
    212  10c1					      endif
    213  10c1							;
    214  10c1							;=====================================================
    215  10c1							; This gets the next byte from an open disk file.  If
    216  10c1							; there are no more bytes left, this returns C set.
    217  10c1							; Else, C is clear and A contains the character.
    218  10c1							;
    219  10c1				   getNextFileByte
    220  10c1					      if	XKIM || CTMON65
    221  10c1		       ae 8f df 	      ldx	diskBufOffset
    222  10c4		       ec 8e df 	      cpx	diskBufLength
    223  10c7		       d0 14		      bne	hasdata	;branch if still data
    224  10c9							;
    225  10c9							; There is no data left in the buffer, so read a
    226  10c9							; block from the SD system.
    227  10c9							;
    228  10c9		       a9 84		      lda	#BUFFER_SIZE
    229  10cb		       a2 df		      ldx	#buffer>>8
    230  10cd		       a0 0a		      ldy	#buffer&$ff
    231  10cf		       20 3c f0 	      jsr	DiskRead
    232  10d2		       b0 12		      bcs	getNextEof
    233  10d4							;
    234  10d4							; A contains the number of bytes actually read.
    235  10d4							;
    236  10d4		       8d 8e df 	      sta	diskBufLength	;save length
    237  10d7		       c9 00		      cmp	#0	;shouldn't happen
    238  10d9		       f0 0b		      beq	getNextEof
    239  10db							;
    240  10db		       a2 00		      ldx	#0
    241  10dd		       bd 0a df    hasdata    lda	buffer,x
    242  10e0		       e8		      inx
    243  10e1		       8e 8f df 	      stx	diskBufOffset
    244  10e4		       18		      clc
    245  10e5		       60		      rts
    246  10e6							;
    247  10e6		       a9 00	   getNextEof lda	#0
    248  10e8		       8d 8f df 	      sta	diskBufOffset
    249  10eb		       8d 8e df 	      sta	diskBufLength
    250  10ee		       38		      sec
    251  10ef		       60		      rts
    252  10f0							;
    253  10f0							;=====================================================
    254  10f0							; Set output vector to the disk output function
    255  10f0							;
    256  10f0		       a9 fb	   SetOutDisk lda	#DOUT&$ff
    257  10f2		       8d 7c 15 	      sta	BOutVec
    258  10f5		       a9 10		      lda	#DOUT/256
    259  10f7		       8d 7d 15 	      sta	BOutVec+1
    260  10fa		       60		      rts
    261  10fb							;
    262  10fb							;=====================================================
    263  10fb
    264  10fb		       8d 0a df    DOUT       sta	buffer
    265  10fe		       a9 01		      lda	#1
    266  1100		       a0 0a		      ldy	#buffer&$ff
    267  1102		       a2 df		      ldx	#buffer/256
    268  1104		       20 3f f0 	      jsr	DiskWrite
    269  1107							;
    270  1107							; need error checking here
    271  1107							;
    272  1107		       60		      rts
    273  1108					      endif
    274  1108
    275  1108
------- FILE mytb.asm
   2043  1108					      endif
------- FILE IL.inc LEVEL 2 PASS 4
      0  1108					      include	"IL.inc"
      1  1108
      2  1108							;=====================================================
      3  1108							; IL.inc
      4  1108							; These are macros for IL instructions
      5  1108							;
      6  1108					      mac	dw
      7  1108					      .word	{0}
      8  1108					      endm
      9  1108					      mac	db
     10  1108					      .byte	{0}
     11  1108					      endm
     12  1108					      macro	xinit
     13  1108					      db	0
     14  1108					      endm		;reset the il to start clear all
     15  1108							;
     16  1108					      macro	done
     17  1108					      db	1
     18  1108					      endm		;print an error if not end of line
     19  1108							;
     20  1108					      macro	prs
     21  1108					      db	2
     22  1108					      endm		;print a quoted string
     23  1108							;
     24  1108					      macro	prn
     25  1108					      db	3
     26  1108					      endm		;print a number
     27  1108							;
     28  1108					      macro	spc
     29  1108					      db	4
     30  1108					      endm		;print space til new tabstop
     31  1108							;
     32  1108					      macro	nline
     33  1108					      db	5
     34  1108					      endm		;print a new line crlf
     35  1108							;
     36  1108							; My NXT is a bit different in that it takes one
     37  1108							; parameter, which is an address.  If the BASIC
     38  1108							; program is currently running then move to the
     39  1108							; next line and continue execution.  However, if
     40  1108							; in direct mode, jump to the specified IL label.
     41  1108							;
     42  1108					      macro	nxt
     43  1108					      db	6
     44  1108					      dw	{1}	; addr
     45  1108					      endm		; addr
     46  1108							;
     47  1108					      macro	xfer
     48  1108					      db	7
     49  1108					      endm
     50  1108							;
     51  1108					      macro	sav
     52  1108					      db	8
     53  1108					      endm
     54  1108							;
     55  1108					      macro	rstr
     56  1108					      db	9
     57  1108					      endm
     58  1108							;
     59  1108					      macro	cmpr
     60  1108					      db	10
     61  1108					      endm
     62  1108							;
     63  1108					      macro	innum
     64  1108					      db	11
     65  1108					      endm
     66  1108							;
     67  1108					      macro	fin
     68  1108					      db	12
     69  1108					      endm
     70  1108							;
     71  1108							; ERR is followed by an error number.	The error
     72  1108							; code is printed along with the line number.
     73  1108							; Control is passed to the statement set with
     74  1108							; the ERRGOTO statement.
     75  1108							;
     76  1108					      macro	errmsg
     77  1108					      db	13
     78  1108					      dw	{1}	;ecode
     79  1108					      endm		;ecode
     80  1108							;
     81  1108					      macro	add
     82  1108					      db	14
     83  1108					      endm
     84  1108							;
     85  1108					      macro	sub
     86  1108					      db	15
     87  1108					      endm
     88  1108							;
     89  1108					      macro	neg
     90  1108					      db	16
     91  1108					      endm
     92  1108							;
     93  1108					      macro	mul
     94  1108					      db	17
     95  1108					      endm
     96  1108							;
     97  1108					      macro	div
     98  1108					      db	18
     99  1108					      endm
    100  1108							;
    101  1108					      macro	store
    102  1108					      db	19
    103  1108					      endm
    104  1108							;
    105  1108					      macro	ind
    106  1108					      db	20
    107  1108					      endm
    108  1108							;
    109  1108					      macro	lst
    110  1108					      db	21
    111  1108					      endm
    112  1108							;
    113  1108					      macro	init
    114  1108					      db	22
    115  1108					      endm
    116  1108							;
    117  1108					      macro	getline
    118  1108					      db	23
    119  1108					      endm
    120  1108							;
    121  1108					      macro	insert
    122  1108					      db	24
    123  1108					      endm
    124  1108							;
    125  1108					      macro	rtn
    126  1108					      db	25
    127  1108					      endm
    128  1108							;
    129  1108					      macro	exit
    130  1108					      db	26
    131  1108					      endm
    132  1108							;
    133  1108					      macro	lit
    134  1108					      db	27
    135  1108					      dw	{1}	;value
    136  1108					      endm		; value LIT
    137  1108							;
    138  1108					      macro	call
    139  1108					      db	28
    140  1108					      dw	{1}	;addr
    141  1108					      endm		;addr
    142  1108							;
    143  1108							; IJMP will set the IL PC to the specified value.
    144  1108							;
    145  1108					      macro	ijmp
    146  1108					      db	29
    147  1108					      dw	{1}	;addr
    148  1108					      endm		;addr
    149  1108							;
    150  1108					      macro	vinit
    151  1108					      db	30
    152  1108					      endm
    153  1108							;
    154  1108							; ERRGOTO sets the point in the code where the IL
    155  1108							; interpreter will go after any error.
    156  1108							;
    157  1108					      macro	errgoto
    158  1108					      db	31
    159  1108					      dw	{1}	;addr
    160  1108					      endm		;addr
    161  1108							;
    162  1108					      macro	tst
    163  1108					      db	32
    164  1108					      db	({1}-*)-1	;(addr-*)-1
    165  1108					      db	{2},0	;string,0
    166  1108					      endm		;addr,string
    167  1108							;
    168  1108					      macro	tstv
    169  1108					      db	33
    170  1108					      db	({1}-*)-1	;(addr-*)-1
    171  1108					      endm		;addr
    172  1108							;
    173  1108					      macro	tstl
    174  1108					      db	34
    175  1108					      db	({1}-*)-1	;(addr-*)-1
    176  1108					      endm		;addr
    177  1108							;
    178  1108					      macro	tstn
    179  1108					      db	35
    180  1108					      db	({1}-*)-1	;(addr-*)-1
    181  1108					      endm		;addr
    182  1108							;
    183  1108							; FREE returns the amount of free RAM on top of
    184  1108							; the stack.  This is the amount of room the user
    185  1108							; program has available.
    186  1108							;
    187  1108					      macro	free
    188  1108					      db	36
    189  1108					      endm
    190  1108							;
    191  1108							; RANDOM takes the top item off the stack and
    192  1108							; replaces it with a random number that is
    193  1108							; MOD the initial value.  Ie, if the TOS is
    194  1108							; 42 then RANDOM returns a value from 0 to 41.
    195  1108							;
    196  1108					      macro	random
    197  1108					      db	37
    198  1108					      endm
    199  1108							;
    200  1108							; ABS will replace the top of stack with the
    201  1108							; absolute value.
    202  1108							;
    203  1108					      macro	abs
    204  1108					      db	38
    205  1108					      endm
    206  1108							;
    207  1108							; OPENREAD opens a file for reading, as in getting
    208  1108							; statements from it.
    209  1108							;
    210  1108					      macro	openread
    211  1108					      db	39
    212  1108					      endm
    213  1108							;
    214  1108							; OPENWRITE opens a file for writing, as in saving
    215  1108							; the current program to it.
    216  1108							;
    217  1108					      macro	openwrite
    218  1108					      db	40
    219  1108					      endm
    220  1108							;
    221  1108							; DCLOSE closes any open disk file.
    222  1108							;
    223  1108					      macro	dclose
    224  1108					      db	41
    225  1108					      endm
    226  1108							;
    227  1108							; DGETLINE gets one line from the disk file and puts it
    228  1108							; into LINBUFF.
    229  1108							;
    230  1108					      macro	dgetline
    231  1108					      db	42
    232  1108					      endm
    233  1108							;
    234  1108							; DLIST saves the program to an open disk file.
    235  1108							;
    236  1108					      macro	dlist
    237  1108					      db	43
    238  1108					      endm
    239  1108							; DDIR list the current directory
    240  1108							;
    241  1108					      macro	ddir
    242  1108					      db	44
    243  1108					      endm
    244  1108
    245  1108							; RMFILE remove a fle from disk
    246  1108					      macro	rmfile
    247  1108					      db	45
    248  1108					      endm
    249  1108
    250  1108							; CLEARSCREEN clear the screen
    251  1108					      macro	clearscreen
    252  1108					      db	46
    253  1108					      endm
    254  1108							; POKEMEM Poke value into memory
    255  1108					      macro	pokemem
    256  1108					      db	47
    257  1108					      endm
    258  1108							; PEEKMEM peek at value in memory
    259  1108					      macro	peekmem
    260  1108					      db	48
    261  1108					      endm
    262  1108							; TSTLET Test if the statement is a let without the keyword let
    263  1108					      macro	tstlet
    264  1108					      db	49
    265  1108					      db	({1}-*)-1	;(addr-*)-1
    266  1108					      endm		;addr
    267  1108							; TSTDONE if we reach the end of a statement
    268  1108					      macro	tstdone
    269  1108					      db	50
    270  1108					      db	({1}-*)-1	;(addr-*)-1
    271  1108					      endm		;addr
    272  1108							; GETCHAR	get a character from the input line leave it in RO
    273  1108					      macro	getchar
    274  1108					      db	51
    275  1108					      endm
    276  1108							; PUTCHAR	Put a character to the terminal
    277  1108					      macro	putchar
    278  1108					      db	52
    279  1108					      endm
    280  1108							; Call		Call a machine function return a to stack
    281  1108					      macro	callfunc
    282  1108					      db	53
    283  1108					      endm
    284  1108
    285  1108							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    286  1108					      macro	ibranch
    287  1108					      db	54
    288  1108					      endm
    289  1108
    290  1108							; TSTSTR	 Tests for the open quote in a string
    291  1108					      macro	tststr
    292  1108					      db	55
    293  1108					      db	({1}-*)-1	;(addr-*)-1
    294  1108					      endm
    295  1108							; SETIRQ	Sets the line number to run when an irq happens irq 550
    296  1108					      macro	setirq
    297  1108					      db	56
    298  1108					      endm
    299  1108
    300  1108							; TSTIRQ	Test for irq pending,
    301  1108							;		if so push the IRQ LINE NUMBER into RO, onto stack
    302  1108					      macro	tstirq
    303  1108					      db	57
    304  1108					      db	({1}-*)-1	;(addr-*)-1
    305  1108					      endm
    306  1108
    307  1108							; IRET    return from interupt service
    308  1108					      macro	iret
    309  1108					      db	58
    310  1108					      endm
    311  1108
    312  1108							; INSTR   read a string from the input
    313  1108					      macro	instr
    314  1108					      db	59
    315  1108					      endm
    316  1108
    317  1108							; MODULO Returns the remainder of the division
    318  1108					      macro	modulo
    319  1108					      db	60
    320  1108					      endm
    321  1108							; Task Switch
    322  1108					      macro	taskswitch
    323  1108					      db	61
    324  1108					      endm
    325  1108							; Set a task line
    326  1108					      macro	settask
    327  1108					      db	62
    328  1108					      endm
    329  1108							; End a task
    330  1108					      macro	etask
    331  1108					      db	63
    332  1108					      endm
    333  1108							; Skip to next task
    334  1108					      macro	ntask
    335  1108					      db	64
    336  1108					      endm
    337  1108							; Subscript
    338  1108					      macro	subscript
    339  1108					      db	65
    340  1108					      endm
    341  1108							; KILL Task
    342  1108					      macro	taskkill
    343  1108					      db	66
    344  1108					      endm
    345  1108							; STAT Task
    346  1108					      macro	taskstat
    347  1108					      db	67
    348  1108					      endm
    349  1108
------- FILE mytb.asm
   2045  1108							;
   2046  1108				  -	      if	FIXED
   2047  1108				  -	      org	$1000
   2048  1108					      endif
------- FILE basic.il LEVEL 2 PASS 4
      0  1108					      include	"basic.il"
      1  1108							;LET
      2  1108							;=====================================================
      3  1108							;=====================================================
      4  1108							;=====================================================
      5  1108							; This is the IL of the BASIC (or whatever) language.
      6  1108							; Because of the way macros are implemented by as65,
      7  1108							; labels can't be on the same line as a macro
      8  1108							; invocation, so that's why labels are on separate
      9  1108							; lines.
     10  1108							;
     11  1108		       11 08	   IL	      equ	*
     12  1108
     13  1108							;THE IL CONTROL SECTION
     14  1108
     15  1108				   START
      0  1108					      INIT		;INITIALIZE
      0  1108					      db	22
      1  1108		       16		      .byte.b	22
      0  1109					      NLINE		;WRITE CRLF
      0  1109					      db	5
      1  1109		       05		      .byte.b	5
      0  110a					      ERRGOTO	CO	;where to go after an error
      0  110a					      db	31
      1  110a		       1f		      .byte.b	31
      0  110b					      dw	CO
      1  110b		       0e 11		      .word.w	CO
      0  110d					      VINIT		;clear all variables
      0  110d					      db	30
      1  110d		       1e		      .byte.b	30
     20  110e							;
     21  110e							; This is where we jump to get a line of commands or
     22  110e							; a program from the user.
     23  110e							;
     24  110e				   CO
      0  110e					      GETLINE		;WRITE PROMPT AND GET LINE
      0  110e					      db	23
      1  110e		       17		      .byte.b	23
      0  110f					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  110f					      db	34
      1  110f		       22		      .byte.b	34
      0  1110					      db	(XEC-*)-1
      1  1110		       04		      .byte.b	(XEC-*)-1
      0  1111					      INSERT		;INSERT IT (MAY BE DELETE)
      0  1111					      db	24
      1  1111		       18		      .byte.b	24
      0  1112					      IJMP	CO
      0  1112					      db	29
      1  1112		       1d		      .byte.b	29
      0  1113					      dw	CO
      1  1113		       0e 11		      .word.w	CO
     29  1115				   XEC
      0  1115					      XINIT		;INITIALIZE
      0  1115					      db	0
      1  1115		       00		      .byte.b	0
     31  1116
     32  1116							;STATEMENT EXECUTOR
     33  1116				   STMT
      0  1116					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  1116					      db	57
      1  1116		       39		      .byte.b	57
      0  1117					      db	(notirq-*)-1
      1  1117		       00		      .byte.b	(notirq-*)-1
     35  1118				   notirq
      0  1118					      TASKSWITCH		;if this is not a irq then check for task switch
      0  1118					      db	61
      1  1118		       3d		      .byte.b	61
      0  1119					      TSTLET	LET	;Test if second field is =
      0  1119					      db	49
      1  1119		       31		      .byte.b	49
      0  111a					      db	(LET-*)-1
      1  111a		       03		      .byte.b	(LET-*)-1
      0  111b					      IJMP	DOLET	;allow the default to be let
      0  111b					      db	29
      1  111b		       1d		      .byte.b	29
      0  111c					      dw	DOLET
      1  111c		       24 11		      .word.w	DOLET
     39  111e				   LET
      0  111e					      TST	S1,"LET"	;IS STATEMENT A LET
      0  111e					      db	32
      1  111e		       20		      .byte.b	32
      0  111f					      db	(S1-*)-1
      1  111f		       21		      .byte.b	(S1-*)-1
      0  1120					      db	"LET",0
      1  1120		       4c 45 54 00	      .byte.b	"LET",0
     41  1124				   DOLET
      0  1124					      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  1124					      db	33
      1  1124		       21		      .byte.b	33
      0  1125					      db	(ERRVEC-*)-1
      1  1125		       b0		      .byte.b	(ERRVEC-*)-1
      0  1126					      TST	LETBE,"["
      0  1126					      db	32
      1  1126		       20		      .byte.b	32
      0  1127					      db	(LETBE-*)-1
      1  1127		       0a		      .byte.b	(LETBE-*)-1
      0  1128					      db	"[",0
      1  1128		       5b 00		      .byte.b	"[",0
      0  112a					      CALL	EXPR
      0  112a					      db	28
      1  112a		       1c		      .byte.b	28
      0  112b					      dw	EXPR
      1  112b		       f1 12		      .word.w	EXPR
      0  112d					      TST	ERRVEC,"]"
      0  112d					      db	32
      1  112d		       20		      .byte.b	32
      0  112e					      db	(ERRVEC-*)-1
      1  112e		       a7		      .byte.b	(ERRVEC-*)-1
      0  112f					      db	"]",0
      1  112f		       5d 00		      .byte.b	"]",0
      0  1131					      SUBSCRIPT
      0  1131					      db	65
      1  1131		       41		      .byte.b	65
     47  1132				   LETBE
      0  1132					      TST	ERRVEC,"="	;(This line originally omitted)
      0  1132					      db	32
      1  1132		       20		      .byte.b	32
      0  1133					      db	(ERRVEC-*)-1
      1  1133		       a2		      .byte.b	(ERRVEC-*)-1
      0  1134					      db	"=",0
      1  1134		       3d 00		      .byte.b	"=",0
      0  1136					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  1136					      db	28
      1  1136		       1c		      .byte.b	28
      0  1137					      dw	EXPR
      1  1137		       f1 12		      .word.w	EXPR
      0  1139					      DONE		;REPORT ERROR IF NOT NEXT
      0  1139					      db	1
      1  1139		       01		      .byte.b	1
      0  113a					      STORE		;STORE RESULT
      0  113a					      db	19
      1  113a		       13		      .byte.b	19
      0  113b					      NXT	CO	;AND SEQUENCE TO NEXT
      0  113b					      db	6
      1  113b		       06		      .byte.b	6
      0  113c					      dw	CO
      1  113c		       0e 11		      .word.w	CO
      0  113e					      IJMP	STMT
      0  113e					      db	29
      1  113e		       1d		      .byte.b	29
      0  113f					      dw	STMT
      1  113f		       16 11		      .word.w	STMT
     54  1141				   S1
      0  1141					      TST	S1S1,"IRET"	;test return from interupt
      0  1141					      db	32
      1  1141		       20		      .byte.b	32
      0  1142					      db	(S1S1-*)-1
      1  1142		       10		      .byte.b	(S1S1-*)-1
      0  1143					      db	"IRET",0
      1  1143		       49 52 45 54*	      .byte.b	"IRET",0
      0  1148					      TST	S1Sa,"URN"
      0  1148					      db	32
      1  1148		       20		      .byte.b	32
      0  1149					      db	(S1Sa-*)-1
      1  1149		       04		      .byte.b	(S1Sa-*)-1
      0  114a					      db	"URN",0
      1  114a		       55 52 4e 00	      .byte.b	"URN",0
     57  114e				   S1Sa
      0  114e					      DONE		;Must be only thing on the line
      0  114e					      db	1
      1  114e		       01		      .byte.b	1
      0  114f					      IRET		;RESTORE LINE NUMBER OF CALL
      0  114f					      db	58
      1  114f		       3a		      .byte.b	58
      0  1150					      IJMP	STMT
      0  1150					      db	29
      1  1150		       1d		      .byte.b	29
      0  1151					      dw	STMT
      1  1151		       16 11		      .word.w	STMT
     61  1153
     62  1153				   S1S1
      0  1153					      TST	S1Z,"IF"	;IF STATEMENT
      0  1153					      db	32
      1  1153		       20		      .byte.b	32
      0  1154					      db	(S1Z-*)-1
      1  1154		       11		      .byte.b	(S1Z-*)-1
      0  1155					      db	"IF",0
      1  1155		       49 46 00 	      .byte.b	"IF",0
      0  1158					      CALL	EXPR	;GET EXPRESSION rel ops now valis expression 0 false, everything else true
      0  1158					      db	28
      1  1158		       1c		      .byte.b	28
      0  1159					      dw	EXPR
      1  1159		       f1 12		      .word.w	EXPR
      0  115b					      TST	S1W,"THEN"	;(This line originally omitted) not required
      0  115b					      db	32
      1  115b		       20		      .byte.b	32
      0  115c					      db	(S1W-*)-1
      1  115c		       05		      .byte.b	(S1W-*)-1
      0  115d					      db	"THEN",0
      1  115d		       54 48 45 4e*	      .byte.b	"THEN",0
     66  1162				   S1W
      0  1162					      IBRANCH		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  1162					      db	54
      1  1162		       36		      .byte.b	54
      0  1163					      IJMP	STMT
      0  1163					      db	29
      1  1163		       1d		      .byte.b	29
      0  1164					      dw	STMT
      1  1164		       16 11		      .word.w	STMT
     69  1166
     70  1166				   S1Z
      0  1166					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  1166					      db	32
      1  1166		       20		      .byte.b	32
      0  1167					      db	(S2b-*)-1
      1  1167		       18		      .byte.b	(S2b-*)-1
      0  1168					      db	"GO",0
      1  1168		       47 4f 00 	      .byte.b	"GO",0
      0  116b					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  116b					      db	32
      1  116b		       20		      .byte.b	32
      0  116c					      db	(S2-*)-1
      1  116c		       07		      .byte.b	(S2-*)-1
      0  116d					      db	"TO",0
      1  116d		       54 4f 00 	      .byte.b	"TO",0
      0  1170					      CALL	EXPR	;GET LABEL
      0  1170					      db	28
      1  1170		       1c		      .byte.b	28
      0  1171					      dw	EXPR
      1  1171		       f1 12		      .word.w	EXPR
      0  1173					      XFER		;SET UP AND JUMP
      0  1173					      db	7
      1  1173		       07		      .byte.b	7
     75  1174				   S2
      0  1174					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  1174					      db	32
      1  1174		       20		      .byte.b	32
      0  1175					      db	(ERRVEC-*)-1
      1  1175		       60		      .byte.b	(ERRVEC-*)-1
      0  1176					      db	"SUB",0
      1  1176		       53 55 42 00	      .byte.b	"SUB",0
      0  117a					      CALL	EXPR	;GET DESTINATION
      0  117a					      db	28
      1  117a		       1c		      .byte.b	28
      0  117b					      dw	EXPR
      1  117b		       f1 12		      .word.w	EXPR
      0  117d					      DONE		;ERROR IF CR NOT NEXT
      0  117d					      db	1
      1  117d		       01		      .byte.b	1
      0  117e					      SAV		;SAVE RETURN LINE
      0  117e					      db	8
      1  117e		       08		      .byte.b	8
      0  117f					      XFER		;AND JUMP
      0  117f					      db	7
      1  117f		       07		      .byte.b	7
     81  1180				   S2b
      0  1180					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  1180					      db	32
      1  1180		       20		      .byte.b	32
      0  1181					      db	(S3-*)-1
      1  1181		       1f		      .byte.b	(S3-*)-1
      0  1182					      db	"RE",0
      1  1182		       52 45 00 	      .byte.b	"RE",0
      0  1185					      TST	S2a,"T"
      0  1185					      db	32
      1  1185		       20		      .byte.b	32
      0  1186					      db	(S2a-*)-1
      1  1186		       10		      .byte.b	(S2a-*)-1
      0  1187					      db	"T",0
      1  1187		       54 00		      .byte.b	"T",0
      0  1189					      TST	S2aa,"URN"	;RETURN STATEMENT
      0  1189					      db	32
      1  1189		       20		      .byte.b	32
      0  118a					      db	(S2aa-*)-1
      1  118a		       04		      .byte.b	(S2aa-*)-1
      0  118b					      db	"URN",0
      1  118b		       55 52 4e 00	      .byte.b	"URN",0
     85  118f				   S2aa
      0  118f					      DONE		;MUST BE CR
      0  118f					      db	1
      1  118f		       01		      .byte.b	1
      0  1190					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  1190					      db	9
      1  1190		       09		      .byte.b	9
      0  1191					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1191					      db	6
      1  1191		       06		      .byte.b	6
      0  1192					      dw	CO
      1  1192		       0e 11		      .word.w	CO
      0  1194					      IJMP	STMT
      0  1194					      db	29
      1  1194		       1d		      .byte.b	29
      0  1195					      dw	STMT
      1  1195		       16 11		      .word.w	STMT
     90  1197				   S2a
      0  1197					      TST	S3,"M"	;REMark.  Skip rest of line
      0  1197					      db	32
      1  1197		       20		      .byte.b	32
      0  1198					      db	(S3-*)-1
      1  1198		       08		      .byte.b	(S3-*)-1
      0  1199					      db	"M",0
      1  1199		       4d 00		      .byte.b	"M",0
      0  119b					      NXT	CO
      0  119b					      db	6
      1  119b		       06		      .byte.b	6
      0  119c					      dw	CO
      1  119c		       0e 11		      .word.w	CO
      0  119e					      IJMP	STMT
      0  119e					      db	29
      1  119e		       1d		      .byte.b	29
      0  119f					      dw	STMT
      1  119f		       16 11		      .word.w	STMT
     94  11a1
     95  11a1				   S3
      0  11a1					      TST	S3a,"?"	; ? symonym for print
      0  11a1					      db	32
      1  11a1		       20		      .byte.b	32
      0  11a2					      db	(S3a-*)-1
      1  11a2		       05		      .byte.b	(S3a-*)-1
      0  11a3					      db	"?",0
      1  11a3		       3f 00		      .byte.b	"?",0
      0  11a5					      IJMP	S4
      0  11a5					      db	29
      1  11a5		       1d		      .byte.b	29
      0  11a6					      dw	S4
      1  11a6		       b3 11		      .word.w	S4
     98  11a8				   S3a
      0  11a8					      TST	S8,"PR"	;allow short form of print
      0  11a8					      db	32
      1  11a8		       20		      .byte.b	32
      0  11a9					      db	(S8-*)-1
      1  11a9		       36		      .byte.b	(S8-*)-1
      0  11aa					      db	"PR",0
      1  11aa		       50 52 00 	      .byte.b	"PR",0
      0  11ad					      TST	S4,"INT"	;PRINT
      0  11ad					      db	32
      1  11ad		       20		      .byte.b	32
      0  11ae					      db	(S4-*)-1
      1  11ae		       04		      .byte.b	(S4-*)-1
      0  11af					      db	"INT",0
      1  11af		       49 4e 54 00	      .byte.b	"INT",0
    101  11b3				   S4
      0  11b3					      TSTDONE	S4a	;Test if we just want crlf printed
      0  11b3					      db	50
      1  11b3		       32		      .byte.b	50
      0  11b4					      db	(S4a-*)-1
      1  11b4		       03		      .byte.b	(S4a-*)-1
      0  11b5					      IJMP	S6
      0  11b5					      db	29
      1  11b5		       1d		      .byte.b	29
      0  11b6					      dw	S6
      1  11b6		       ce 11		      .word.w	S6
    104  11b8
    105  11b8				   S4a
      0  11b8					      TSTSTR	S7	;TEST FOR QUOTED String
      0  11b8					      db	55
      1  11b8		       37		      .byte.b	55
      0  11b9					      db	(S7-*)-1
      1  11b9		       1f		      .byte.b	(S7-*)-1
      0  11ba					      PRS		;PRINT STRING
      0  11ba					      db	2
      1  11ba		       02		      .byte.b	2
    108  11bb				   S5
      0  11bb					      TST	S6A,COMMA	;IS THERE MORE?
      0  11bb					      db	32
      1  11bb		       20		      .byte.b	32
      0  11bc					      db	(S6A-*)-1
      1  11bc		       08		      .byte.b	(S6A-*)-1
      0  11bd					      db	COMMA,0
      1  11bd		       2c 00		      .byte.b	COMMA,0
      0  11bf					      SPC		;SPACE TO NEXT ZONE
      0  11bf					      db	4
      1  11bf		       04		      .byte.b	4
      0  11c0					      TSTDONE	S4	;Not end of line jump back
      0  11c0					      db	50
      1  11c0		       32		      .byte.b	50
      0  11c1					      db	(S4-*)-1
      1  11c1		       f1		      .byte.b	(S4-*)-1
      0  11c2					      IJMP	S6a	;YES JUMP BACK
      0  11c2					      db	29
      1  11c2		       1d		      .byte.b	29
      0  11c3					      dw	S6a
      1  11c3		       d0 11		      .word.w	S6a
    113  11c5							;
    114  11c5							; If a semicolon, don't do anything.
    115  11c5							;
    116  11c5				   S6A
      0  11c5					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  11c5					      db	32
      1  11c5		       20		      .byte.b	32
      0  11c6					      db	(S6-*)-1
      1  11c6		       07		      .byte.b	(S6-*)-1
      0  11c7					      db	SEMICOLON,0
      1  11c7		       3b 00		      .byte.b	SEMICOLON,0
      0  11c9					      TSTDONE	S4	;Jump Back if not end of line
      0  11c9					      db	50
      1  11c9		       32		      .byte.b	50
      0  11ca					      db	(S4-*)-1
      1  11ca		       e8		      .byte.b	(S4-*)-1
      0  11cb					      IJMP	S6a
      0  11cb					      db	29
      1  11cb		       1d		      .byte.b	29
      0  11cc					      dw	S6a
      1  11cc		       d0 11		      .word.w	S6a
    120  11ce				   S6
      0  11ce					      DONE		;ERROR IF CR NOT NEXT
      0  11ce					      db	1
      1  11ce		       01		      .byte.b	1
      0  11cf					      NLINE
      0  11cf					      db	5
      1  11cf		       05		      .byte.b	5
    123  11d0				   S6a
      0  11d0					      NXT	CO	;exit here if , or ; at end of print
      0  11d0					      db	6
      1  11d0		       06		      .byte.b	6
      0  11d1					      dw	CO
      1  11d1		       0e 11		      .word.w	CO
      0  11d3					      IJMP	STMT
      0  11d3					      db	29
      1  11d3		       1d		      .byte.b	29
      0  11d4					      dw	STMT
      1  11d4		       16 11		      .word.w	STMT
    126  11d6							;
    127  11d6							; A jump for code too far away for relative branch
    128  11d6							;
    129  11d6				   ERRVEC
      0  11d6					      IJMP	UNKNOWN
      0  11d6					      db	29
      1  11d6		       1d		      .byte.b	29
      0  11d7					      dw	UNKNOWN
      1  11d7		       ee 12		      .word.w	UNKNOWN
    131  11d9							;
    132  11d9							; Get here if there is an expression to print
    133  11d9				   S7
      0  11d9					      CALL	EXPR
      0  11d9					      db	28
      1  11d9		       1c		      .byte.b	28
      0  11da					      dw	EXPR
      1  11da		       f1 12		      .word.w	EXPR
      0  11dc					      PRN		;PRINT IT
      0  11dc					      db	3
      1  11dc		       03		      .byte.b	3
      0  11dd					      IJMP	S5	;IS THERE MORE?
      0  11dd					      db	29
      1  11dd		       1d		      .byte.b	29
      0  11de					      dw	S5
      1  11de		       bb 11		      .word.w	S5
    137  11e0							;
    138  11e0							;===========================================================
    139  11e0							; End of TASK process
    140  11e0				   S8
      0  11e0					      TST	S8G,"ETASK"	; End task
      0  11e0					      db	32
      1  11e0		       20		      .byte.b	32
      0  11e1					      db	(S8G-*)-1
      1  11e1		       0b		      .byte.b	(S8G-*)-1
      0  11e2					      db	"ETASK",0
      1  11e2		       45 54 41 53*	      .byte.b	"ETASK",0
      0  11e8					      ETASK
      0  11e8					      db	63
      1  11e8		       3f		      .byte.b	63
      0  11e9					      DONE		; Must be last thing on a line
      0  11e9					      db	1
      1  11e9		       01		      .byte.b	1
      0  11ea					      IJMP	STMT
      0  11ea					      db	29
      1  11ea		       1d		      .byte.b	29
      0  11eb					      dw	STMT
      1  11eb		       16 11		      .word.w	STMT
    145  11ed							;
    146  11ed							;===========================================================
    147  11ed							; The task gives up the rest of the cycles
    148  11ed				   S8G
      0  11ed					      TST	S8a,"NTASK"	;Next task
      0  11ed					      db	32
      1  11ed		       20		      .byte.b	32
      0  11ee					      db	(S8a-*)-1
      1  11ee		       0d		      .byte.b	(S8a-*)-1
      0  11ef					      db	"NTASK",0
      1  11ef		       4e 54 41 53*	      .byte.b	"NTASK",0
      0  11f5					      NTASK
      0  11f5					      db	64
      1  11f5		       40		      .byte.b	64
      0  11f6					      NXT	CO	;Next statement to execute
      0  11f6					      db	6
      1  11f6		       06		      .byte.b	6
      0  11f7					      dw	CO
      1  11f7		       0e 11		      .word.w	CO
      0  11f9					      IJMP	STMT
      0  11f9					      db	29
      1  11f9		       1d		      .byte.b	29
      0  11fa					      dw	STMT
      1  11fa		       16 11		      .word.w	STMT
    153  11fc							;
    154  11fc							;===========================================================
    155  11fc							; Update a memory location with a value
    156  11fc				   S8a
      0  11fc					      TST	S8b,"POKE"	;Poke a value into memory
      0  11fc					      db	32
      1  11fc		       20		      .byte.b	32
      0  11fd					      db	(S8b-*)-1
      1  11fd		       17		      .byte.b	(S8b-*)-1
      0  11fe					      db	"POKE",0
      1  11fe		       50 4f 4b 45*	      .byte.b	"POKE",0
      0  1203					      CALL	EXPR	;Get address to write to
      0  1203					      db	28
      1  1203		       1c		      .byte.b	28
      0  1204					      dw	EXPR
      1  1204		       f1 12		      .word.w	EXPR
      0  1206					      TST	UNKNOWN,COMMA	;Must have a coma
      0  1206					      db	32
      1  1206		       20		      .byte.b	32
      0  1207					      db	(UNKNOWN-*)-1
      1  1207		       e6		      .byte.b	(UNKNOWN-*)-1
      0  1208					      db	COMMA,0
      1  1208		       2c 00		      .byte.b	COMMA,0
      0  120a					      CALL	EXPR	;Get the value to poke
      0  120a					      db	28
      1  120a		       1c		      .byte.b	28
      0  120b					      dw	EXPR
      1  120b		       f1 12		      .word.w	EXPR
      0  120d					      POKEMEM
      0  120d					      db	47
      1  120d		       2f		      .byte.b	47
      0  120e					      DONE
      0  120e					      db	1
      1  120e		       01		      .byte.b	1
      0  120f					      NXT	CO	;AND SEQUENCE TO NEXT
      0  120f					      db	6
      1  120f		       06		      .byte.b	6
      0  1210					      dw	CO
      1  1210		       0e 11		      .word.w	CO
      0  1212					      IJMP	STMT
      0  1212					      db	29
      1  1212		       1d		      .byte.b	29
      0  1213					      dw	STMT
      1  1213		       16 11		      .word.w	STMT
    165  1215
    166  1215				   S8b
      0  1215					      TST	S8c,"PUTCH"	;Put a char to the terminal
      0  1215					      db	32
      1  1215		       20		      .byte.b	32
      0  1216					      db	(S8c-*)-1
      1  1216		       11		      .byte.b	(S8c-*)-1
      0  1217					      db	"PUTCH",0
      1  1217		       50 55 54 43*	      .byte.b	"PUTCH",0
      0  121d					      CALL	EXPR
      0  121d					      db	28
      1  121d		       1c		      .byte.b	28
      0  121e					      dw	EXPR
      1  121e		       f1 12		      .word.w	EXPR
      0  1220					      PUTCHAR
      0  1220					      db	52
      1  1220		       34		      .byte.b	52
      0  1221					      DONE
      0  1221					      db	1
      1  1221		       01		      .byte.b	1
      0  1222					      NXT	CO	;AND SEQUENCE TO NEXT
      0  1222					      db	6
      1  1222		       06		      .byte.b	6
      0  1223					      dw	CO
      1  1223		       0e 11		      .word.w	CO
      0  1225					      IJMP	STMT
      0  1225					      db	29
      1  1225		       1d		      .byte.b	29
      0  1226					      dw	STMT
      1  1226		       16 11		      .word.w	STMT
    173  1228				   S8c
      0  1228					      TST	S9,"CLS"	;Clear the screen
      0  1228					      db	32
      1  1228		       20		      .byte.b	32
      0  1229					      db	(S9-*)-1
      1  1229		       0b		      .byte.b	(S9-*)-1
      0  122a					      db	"CLS",0
      1  122a		       43 4c 53 00	      .byte.b	"CLS",0
      0  122e					      CLEARSCREEN
      0  122e					      db	46
      1  122e		       2e		      .byte.b	46
      0  122f					      NXT	CO	;AND SEQUENCE TO NEXT
      0  122f					      db	6
      1  122f		       06		      .byte.b	6
      0  1230					      dw	CO
      1  1230		       0e 11		      .word.w	CO
      0  1232					      IJMP	STMT
      0  1232					      db	29
      1  1232		       1d		      .byte.b	29
      0  1233					      dw	STMT
      1  1233		       16 11		      .word.w	STMT
    178  1235				   S9
      0  1235					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  1235					      db	32
      1  1235		       20		      .byte.b	32
      0  1236					      db	(S13-*)-1
      1  1236		       2a		      .byte.b	(S13-*)-1
      0  1237					      db	"INPUT",0
      1  1237		       49 4e 50 55*	      .byte.b	"INPUT",0
    180  123d				   S10
      0  123d					      TSTSTR	S10A	;If there is a string print the prompt
      0  123d					      db	55
      1  123d		       37		      .byte.b	55
      0  123e					      db	(S10A-*)-1
      1  123e		       05		      .byte.b	(S10A-*)-1
      0  123f					      PRS
      0  123f					      db	2
      1  123f		       02		      .byte.b	2
      0  1240					      TST	S10Z,SEMICOLON	;Must follow the prompt
      0  1240					      db	32
      1  1240		       20		      .byte.b	32
      0  1241					      db	(S10Z-*)-1
      1  1241		       15		      .byte.b	(S10Z-*)-1
      0  1242					      db	SEMICOLON,0
      1  1242		       3b 00		      .byte.b	SEMICOLON,0
    184  1244				   S10A
      0  1244					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  1244					      db	33
      1  1244		       21		      .byte.b	33
      0  1245					      db	(UNKNOWN-*)-1
      1  1245		       a8		      .byte.b	(UNKNOWN-*)-1
      0  1246					      TST	S10A1,DOLLAR
      0  1246					      db	32
      1  1246		       20		      .byte.b	32
      0  1247					      db	(S10A1-*)-1
      1  1247		       06		      .byte.b	(S10A1-*)-1
      0  1248					      db	DOLLAR,0
      1  1248		       24 00		      .byte.b	DOLLAR,0
      0  124a					      INSTR
      0  124a					      db	59
      1  124a		       3b		      .byte.b	59
      0  124b					      IJMP	S10A2
      0  124b					      db	29
      1  124b		       1d		      .byte.b	29
      0  124c					      dw	S10A2
      1  124c		       4f 12		      .word.w	S10A2
    189  124e				   S10A1
      0  124e					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  124e					      db	11
      1  124e		       0b		      .byte.b	11
    191  124f				   S10A2
      0  124f					      STORE		;STORE IT
      0  124f					      db	19
      1  124f		       13		      .byte.b	19
      0  1250					      TST	S11,COMMA	;IS THERE MORE?
      0  1250					      db	32
      1  1250		       20		      .byte.b	32
      0  1251					      db	(S11-*)-1
      1  1251		       08		      .byte.b	(S11-*)-1
      0  1252					      db	COMMA,0
      1  1252		       2c 00		      .byte.b	COMMA,0
      0  1254					      IJMP	S10	;YES
      0  1254					      db	29
      1  1254		       1d		      .byte.b	29
      0  1255					      dw	S10
      1  1255		       3d 12		      .word.w	S10
    195  1257				   S10Z
      0  1257					      iJMP	UNKNOWN
      0  1257					      db	29
      1  1257		       1d		      .byte.b	29
      0  1258					      dw	UNKNOWN
      1  1258		       ee 12		      .word.w	UNKNOWN
    197  125a				   S11
      0  125a					      DONE		;MUST BE CR
      0  125a					      db	1
      1  125a		       01		      .byte.b	1
      0  125b					      NXT	CO	;SEQUENCE TO NEXT
      0  125b					      db	6
      1  125b		       06		      .byte.b	6
      0  125c					      dw	CO
      1  125c		       0e 11		      .word.w	CO
      0  125e					      IJMP	STMT
      0  125e					      db	29
      1  125e		       1d		      .byte.b	29
      0  125f					      dw	STMT
      1  125f		       16 11		      .word.w	STMT
    201  1261				   S13
      0  1261					      TST	S14,"END"
      0  1261					      db	32
      1  1261		       20		      .byte.b	32
      0  1262					      db	(S14-*)-1
      1  1262		       05		      .byte.b	(S14-*)-1
      0  1263					      db	"END",0
      1  1263		       45 4e 44 00	      .byte.b	"END",0
      0  1267					      FIN
      0  1267					      db	12
      1  1267		       0c		      .byte.b	12
    204  1268
    205  1268				   S14
      0  1268					      TST	S14Z,"IRQ"	;Check if we are setting IRQ HANDLER
      0  1268					      db	32
      1  1268		       20		      .byte.b	32
      0  1269					      db	(S14Z-*)-1
      1  1269		       0f		      .byte.b	(S14Z-*)-1
      0  126a					      db	"IRQ",0
      1  126a		       49 52 51 00	      .byte.b	"IRQ",0
      0  126e					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  126e					      db	28
      1  126e		       1c		      .byte.b	28
      0  126f					      dw	EXPR
      1  126f		       f1 12		      .word.w	EXPR
      0  1271					      DONE		;must be CR
      0  1271					      db	1
      1  1271		       01		      .byte.b	1
      0  1272					      SETIRQ		;Set the line number now
      0  1272					      db	56
      1  1272		       38		      .byte.b	56
      0  1273					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  1273					      db	6
      1  1273		       06		      .byte.b	6
      0  1274					      dw	CO
      1  1274		       0e 11		      .word.w	CO
      0  1276					      IJMP	STMT
      0  1276					      db	29
      1  1276		       1d		      .byte.b	29
      0  1277					      dw	STMT
      1  1277		       16 11		      .word.w	STMT
    212  1279
    213  1279				   S14Z
      0  1279					      TST	S14S1,"KILL"	; Kill A running Task
      0  1279					      db	32
      1  1279		       20		      .byte.b	32
      0  127a					      db	(S14S1-*)-1
      1  127a		       10		      .byte.b	(S14S1-*)-1
      0  127b					      db	"KILL",0
      1  127b		       4b 49 4c 4c*	      .byte.b	"KILL",0
      0  1280					      CALL	EXPR
      0  1280					      db	28
      1  1280		       1c		      .byte.b	28
      0  1281					      dw	EXPR
      1  1281		       f1 12		      .word.w	EXPR
      0  1283					      DONE
      0  1283					      db	1
      1  1283		       01		      .byte.b	1
      0  1284					      TASKKILL
      0  1284					      db	66
      1  1284		       42		      .byte.b	66
      0  1285					      NXT	CO
      0  1285					      db	6
      1  1285		       06		      .byte.b	6
      0  1286					      dw	CO
      1  1286		       0e 11		      .word.w	CO
      0  1288					      IJMP	STMT
      0  1288					      db	29
      1  1288		       1d		      .byte.b	29
      0  1289					      dw	STMT
      1  1289		       16 11		      .word.w	STMT
    220  128b
    221  128b				   S14S1
      0  128b					      TST	S15,"LIST"	;LIST COMMAND
      0  128b					      db	32
      1  128b		       20		      .byte.b	32
      0  128c					      db	(S15-*)-1
      1  128c		       0a		      .byte.b	(S15-*)-1
      0  128d					      db	"LIST",0
      1  128d		       4c 49 53 54*	      .byte.b	"LIST",0
      0  1292					      DONE
      0  1292					      db	1
      1  1292		       01		      .byte.b	1
      0  1293					      LST
      0  1293					      db	21
      1  1293		       15		      .byte.b	21
      0  1294					      IJMP	CO
      0  1294					      db	29
      1  1294		       1d		      .byte.b	29
      0  1295					      dw	CO
      1  1295		       0e 11		      .word.w	CO
    226  1297				   S15
      0  1297					      TST	S16,"RUN"	;RUN COMMAND
      0  1297					      db	32
      1  1297		       20		      .byte.b	32
      0  1298					      db	(S16-*)-1
      1  1298		       0d		      .byte.b	(S16-*)-1
      0  1299					      db	"RUN",0
      1  1299		       52 55 4e 00	      .byte.b	"RUN",0
      0  129d					      DONE
      0  129d					      db	1
      1  129d		       01		      .byte.b	1
      0  129e					      VINIT		;clear variables
      0  129e					      db	30
      1  129e		       1e		      .byte.b	30
      0  129f					      LIT	1	;GOTO line 1
      0  129f					      db	27
      1  129f		       1b		      .byte.b	27
      0  12a0					      dw	1
      1  12a0		       01 00		      .word.w	1
      0  12a2					      XFER		;Bob's addition
      0  12a2					      db	7
      1  12a2		       07		      .byte.b	7
    232  12a3							; EXIT
      0  12a3					      IJMP	STMT	;and run!
      0  12a3					      db	29
      1  12a3		       1d		      .byte.b	29
      0  12a4					      dw	STMT
      1  12a4		       16 11		      .word.w	STMT
    234  12a6				   S16
      0  12a6					      TST	S17A,"NEW"	;clear program
      0  12a6					      db	32
      1  12a6		       20		      .byte.b	32
      0  12a7					      db	(S17A-*)-1
      1  12a7		       08		      .byte.b	(S17A-*)-1
      0  12a8					      db	"NEW",0
      1  12a8		       4e 45 57 00	      .byte.b	"NEW",0
      0  12ac					      DONE
      0  12ac					      db	1
      1  12ac		       01		      .byte.b	1
      0  12ad					      IJMP	START
      0  12ad					      db	29
      1  12ad		       1d		      .byte.b	29
      0  12ae					      dw	START
      1  12ae		       08 11		      .word.w	START
    238  12b0
    239  12b0				   S17A
      0  12b0					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  12b0					      db	32
      1  12b0		       20		      .byte.b	32
      0  12b1					      db	(S17B-*)-1
      1  12b1		       06		      .byte.b	(S17B-*)-1
      0  12b2					      db	"EXIT",0
      1  12b2		       45 58 49 54*	      .byte.b	"EXIT",0
      0  12b7					      EXIT
      0  12b7					      db	26
      1  12b7		       1a		      .byte.b	26
    242  12b8
    243  12b8							;
    244  12b8							; Commands related to saving/restoring programs
    245  12b8							; to/from mass storage.
    246  12b8							;
    247  12b8				   S17B
    248  12b8					      if	(XKIM || CTMON65) && DISK_ACCESS
    249  12b8
      0  12b8					      TST	S17C,"SAVE"
      0  12b8					      db	32
      1  12b8		       20		      .byte.b	32
      0  12b9					      db	(S17C-*)-1
      1  12b9		       0b		      .byte.b	(S17C-*)-1
      0  12ba					      db	"SAVE",0
      1  12ba		       53 41 56 45*	      .byte.b	"SAVE",0
      0  12bf					      OPENWRITE
      0  12bf					      db	40
      1  12bf		       28		      .byte.b	40
      0  12c0					      DLIST
      0  12c0					      db	43
      1  12c0		       2b		      .byte.b	43
      0  12c1					      DCLOSE
      0  12c1					      db	41
      1  12c1		       29		      .byte.b	41
      0  12c2					      IJMP	CO
      0  12c2					      db	29
      1  12c2		       1d		      .byte.b	29
      0  12c3					      dw	CO
      1  12c3		       0e 11		      .word.w	CO
    255  12c5
    256  12c5				   S17C
      0  12c5					      TST	S18,"LOAD"
      0  12c5					      db	32
      1  12c5		       20		      .byte.b	32
      0  12c6					      db	(S18-*)-1
      1  12c6		       11		      .byte.b	(S18-*)-1
      0  12c7					      db	"LOAD",0
      1  12c7		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  12cc					      OPENREAD
      0  12cc					      db	39
      1  12cc		       27		      .byte.b	39
    259  12cd				   S17CLP
      0  12cd					      DGETLINE		;get line from file
      0  12cd					      db	42
      1  12cd		       2a		      .byte.b	42
      0  12ce					      TSTL	S17EOL	;no line num means EOL
      0  12ce					      db	34
      1  12ce		       22		      .byte.b	34
      0  12cf					      db	(S17EOL-*)-1
      1  12cf		       04		      .byte.b	(S17EOL-*)-1
      0  12d0					      INSERT		;put it into the program
      0  12d0					      db	24
      1  12d0		       18		      .byte.b	24
      0  12d1					      IJMP	S17CLP	;keep going
      0  12d1					      db	29
      1  12d1		       1d		      .byte.b	29
      0  12d2					      dw	S17CLP
      1  12d2		       cd 12		      .word.w	S17CLP
    264  12d4				   S17EOL
      0  12d4					      DCLOSE		;close disk file
      0  12d4					      db	41
      1  12d4		       29		      .byte.b	41
      0  12d5					      IJMP	CO	;back to start
      0  12d5					      db	29
      1  12d5		       1d		      .byte.b	29
      0  12d6					      dw	CO
      1  12d6		       0e 11		      .word.w	CO
    267  12d8
      0  12d8				   S18	      TST	S19,"DIR"
      0  12d8					      db	32
      1  12d8		       20		      .byte.b	32
      0  12d9					      db	(S19-*)-1
      1  12d9		       08		      .byte.b	(S19-*)-1
      0  12da					      db	"DIR",0
      1  12da		       44 49 52 00	      .byte.b	"DIR",0
      0  12de					      DDIR		;Display the directory content
      0  12de					      db	44
      1  12de		       2c		      .byte.b	44
      0  12df					      IJMP	CO
      0  12df					      db	29
      1  12df		       1d		      .byte.b	29
      0  12e0					      dw	CO
      1  12e0		       0e 11		      .word.w	CO
    271  12e2					      endif
    272  12e2
      0  12e2				   S19	      TST	UNKNOWN,"ERASE"
      0  12e2					      db	32
      1  12e2		       20		      .byte.b	32
      0  12e3					      db	(UNKNOWN-*)-1
      1  12e3		       0a		      .byte.b	(UNKNOWN-*)-1
      0  12e4					      db	"ERASE",0
      1  12e4		       45 52 41 53*	      .byte.b	"ERASE",0
      0  12ea					      RMFILE		;Erase the file from the disk
      0  12ea					      db	45
      1  12ea		       2d		      .byte.b	45
      0  12eb					      IJMP	CO
      0  12eb					      db	29
      1  12eb		       1d		      .byte.b	29
      0  12ec					      dw	CO
      1  12ec		       0e 11		      .word.w	CO
    276  12ec					      endif
    277  12ee
    278  12ee							;
    279  12ee							; Else, unknown command.
    280  12ee							;
    281  12ee				   UNKNOWN
      0  12ee					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  12ee					      db	13
      1  12ee		       0d		      .byte.b	13
      0  12ef					      dw	ERR_SYNTAX
      1  12ef		       05 00		      .word.w	ERR_SYNTAX
    283  12f1
    284  12f1							;-----------------------------------------------------
    285  12f1				   EXPR
      0  12f1					      Call	EXPR2	; get the first expression
      0  12f1					      db	28
      1  12f1		       1c		      .byte.b	28
      0  12f2					      dw	EXPR2
      1  12f2		       3c 13		      .word.w	EXPR2
      0  12f4					      TST	iR0,"="
      0  12f4					      db	32
      1  12f4		       20		      .byte.b	32
      0  12f5					      db	(iR0-*)-1
      1  12f5		       08		      .byte.b	(iR0-*)-1
      0  12f6					      db	"=",0
      1  12f6		       3d 00		      .byte.b	"=",0
      0  12f8					      LIT	2	;=
      0  12f8					      db	27
      1  12f8		       1b		      .byte.b	27
      0  12f9					      dw	2
      1  12f9		       02 00		      .word.w	2
      0  12fb					      IJMP	iRFound
      0  12fb					      db	29
      1  12fb		       1d		      .byte.b	29
      0  12fc					      dw	iRFound
      1  12fc		       37 13		      .word.w	iRFound
    290  12fe				   iR0
      0  12fe					      TST	iR4,"<"
      0  12fe					      db	32
      1  12fe		       20		      .byte.b	32
      0  12ff					      db	(iR4-*)-1
      1  12ff		       1c		      .byte.b	(iR4-*)-1
      0  1300					      db	"<",0
      1  1300		       3c 00		      .byte.b	"<",0
      0  1302					      TST	iR1,"="
      0  1302					      db	32
      1  1302		       20		      .byte.b	32
      0  1303					      db	(iR1-*)-1
      1  1303		       08		      .byte.b	(iR1-*)-1
      0  1304					      db	"=",0
      1  1304		       3d 00		      .byte.b	"=",0
      0  1306					      LIT	3	;<=
      0  1306					      db	27
      1  1306		       1b		      .byte.b	27
      0  1307					      dw	3
      1  1307		       03 00		      .word.w	3
      0  1309					      IJMP	iRFound
      0  1309					      db	29
      1  1309		       1d		      .byte.b	29
      0  130a					      dw	iRFound
      1  130a		       37 13		      .word.w	iRFound
    295  130c				   iR1
      0  130c					      TST	iR3,">"
      0  130c					      db	32
      1  130c		       20		      .byte.b	32
      0  130d					      db	(iR3-*)-1
      1  130d		       08		      .byte.b	(iR3-*)-1
      0  130e					      db	">",0
      1  130e		       3e 00		      .byte.b	">",0
      0  1310					      LIT	5	;<>
      0  1310					      db	27
      1  1310		       1b		      .byte.b	27
      0  1311					      dw	5
      1  1311		       05 00		      .word.w	5
      0  1313					      IJMP	iRFound
      0  1313					      db	29
      1  1313		       1d		      .byte.b	29
      0  1314					      dw	iRFound
      1  1314		       37 13		      .word.w	iRFound
    299  1316				   iR3
      0  1316					      LIT	1	;<
      0  1316					      db	27
      1  1316		       1b		      .byte.b	27
      0  1317					      dw	1
      1  1317		       01 00		      .word.w	1
      0  1319					      IJMP	iRFound
      0  1319					      db	29
      1  1319		       1d		      .byte.b	29
      0  131a					      dw	iRFound
      1  131a		       37 13		      .word.w	iRFound
    302  131c				   iR4
      0  131c					      TST	iRDone,">"
      0  131c					      db	32
      1  131c		       20		      .byte.b	32
      0  131d					      db	(iRDone-*)-1
      1  131d		       1d		      .byte.b	(iRDone-*)-1
      0  131e					      db	">",0
      1  131e		       3e 00		      .byte.b	">",0
      0  1320					      TST	iR5,"="
      0  1320					      db	32
      1  1320		       20		      .byte.b	32
      0  1321					      db	(iR5-*)-1
      1  1321		       08		      .byte.b	(iR5-*)-1
      0  1322					      db	"=",0
      1  1322		       3d 00		      .byte.b	"=",0
      0  1324					      LIT	6	;>=
      0  1324					      db	27
      1  1324		       1b		      .byte.b	27
      0  1325					      dw	6
      1  1325		       06 00		      .word.w	6
      0  1327					      IJMP	iRFound
      0  1327					      db	29
      1  1327		       1d		      .byte.b	29
      0  1328					      dw	iRFound
      1  1328		       37 13		      .word.w	iRFound
    307  132a				   iR5
      0  132a					      TST	iR6,"<"
      0  132a					      db	32
      1  132a		       20		      .byte.b	32
      0  132b					      db	(iR6-*)-1
      1  132b		       08		      .byte.b	(iR6-*)-1
      0  132c					      db	"<",0
      1  132c		       3c 00		      .byte.b	"<",0
      0  132e					      LIT	1
      0  132e					      db	27
      1  132e		       1b		      .byte.b	27
      0  132f					      dw	1
      1  132f		       01 00		      .word.w	1
      0  1331					      IJMP	iRFound	;(This line originally omitted)
      0  1331					      db	29
      1  1331		       1d		      .byte.b	29
      0  1332					      dw	iRFound
      1  1332		       37 13		      .word.w	iRFound
    311  1334				   iR6
      0  1334					      LIT	4	;>
      0  1334					      db	27
      1  1334		       1b		      .byte.b	27
      0  1335					      dw	4
      1  1335		       04 00		      .word.w	4
    313  1337				   iRFound
      0  1337					      Call	EXPR2	; get the right side of the expression
      0  1337					      db	28
      1  1337		       1c		      .byte.b	28
      0  1338					      dw	EXPR2
      1  1338		       3c 13		      .word.w	EXPR2
      0  133a					      CMPR		; Push the value of the true false onto the stack
      0  133a					      db	10
      1  133a		       0a		      .byte.b	10
    316  133b
    317  133b				   iRDone
      0  133b					      RTN
      0  133b					      db	25
      1  133b		       19		      .byte.b	25
    319  133c
    320  133c				   EXPR2
      0  133c					      TST	E0,"-"	; Look for leading - to negate term
      0  133c					      db	32
      1  133c		       20		      .byte.b	32
      0  133d					      db	(E0-*)-1
      1  133d		       09		      .byte.b	(E0-*)-1
      0  133e					      db	"-",0
      1  133e		       2d 00		      .byte.b	"-",0
      0  1340					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  1340					      db	28
      1  1340		       1c		      .byte.b	28
      0  1341					      dw	TERM
      1  1341		       65 13		      .word.w	TERM
      0  1343					      NEG		; Make value negated
      0  1343					      db	16
      1  1343		       10		      .byte.b	16
      0  1344					      IJMP	E1	; We have Left term process operators next
      0  1344					      db	29
      1  1344		       1d		      .byte.b	29
      0  1345					      dw	E1
      1  1345		       4e 13		      .word.w	E1
    325  1347				   E0
      0  1347					      TST	E1A,"+"	; Look for a leading + for value and disgard it if found
      0  1347					      db	32
      1  1347		       20		      .byte.b	32
      0  1348					      db	(E1A-*)-1
      1  1348		       02		      .byte.b	(E1A-*)-1
      0  1349					      db	"+",0
      1  1349		       2b 00		      .byte.b	"+",0
    327  134b				   E1A
      0  134b					      CALL	TERM	; Get the left term if it was not negated
      0  134b					      db	28
      1  134b		       1c		      .byte.b	28
      0  134c					      dw	TERM
      1  134c		       65 13		      .word.w	TERM
    329  134e				   E1
      0  134e					      TST	E2,"+"	; Check if we are adding left term to something
      0  134e					      db	32
      1  134e		       20		      .byte.b	32
      0  134f					      db	(E2-*)-1
      1  134f		       09		      .byte.b	(E2-*)-1
      0  1350					      db	"+",0
      1  1350		       2b 00		      .byte.b	"+",0
      0  1352					      CALL	TERM	; if adding then get the right side term
      0  1352					      db	28
      1  1352		       1c		      .byte.b	28
      0  1353					      dw	TERM
      1  1353		       65 13		      .word.w	TERM
      0  1355					      ADD		; Add it to left term
      0  1355					      db	14
      1  1355		       0e		      .byte.b	14
      0  1356					      IJMP	E1	; look for next + or -
      0  1356					      db	29
      1  1356		       1d		      .byte.b	29
      0  1357					      dw	E1
      1  1357		       4e 13		      .word.w	E1
    334  1359				   E2
      0  1359					      TST	E3,"-"	; Check if we are subtractig something
      0  1359					      db	32
      1  1359		       20		      .byte.b	32
      0  135a					      db	(E3-*)-1
      1  135a		       09		      .byte.b	(E3-*)-1
      0  135b					      db	"-",0
      1  135b		       2d 00		      .byte.b	"-",0
      0  135d					      CALL	TERM	; get right side to subtract Diffrence
      0  135d					      db	28
      1  135d		       1c		      .byte.b	28
      0  135e					      dw	TERM
      1  135e		       65 13		      .word.w	TERM
      0  1360					      SUB		; Subtract the value
      0  1360					      db	15
      1  1360		       0f		      .byte.b	15
      0  1361					      IJMP	E1	; Look for next + or -
      0  1361					      db	29
      1  1361		       1d		      .byte.b	29
      0  1362					      dw	E1
      1  1362		       4e 13		      .word.w	E1
    339  1364				   E3			; Finish processing the expression
      0  1364					      RTN		; We are finished processing the Expression
      0  1364					      db	25
      1  1364		       19		      .byte.b	25
    341  1365							;
    342  1365							; Get one of the terms of an expression
    343  1365							;
    344  1365				   TERM
      0  1365					      CALL	FACT	; Get a value
      0  1365					      db	28
      1  1365		       1c		      .byte.b	28
      0  1366					      dw	FACT
      1  1366		       8d 13		      .word.w	FACT
    346  1368				   T0			; Check for higher precidence operators
      0  1368					      TST	T1,"*"	; Check for *
      0  1368					      db	32
      1  1368		       20		      .byte.b	32
      0  1369					      db	(T1-*)-1
      1  1369		       09		      .byte.b	(T1-*)-1
      0  136a					      db	"*",0
      1  136a		       2a 00		      .byte.b	"*",0
      0  136c					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  136c					      db	28
      1  136c		       1c		      .byte.b	28
      0  136d					      dw	FACT
      1  136d		       8d 13		      .word.w	FACT
      0  136f					      MUL		; Multiply factors
      0  136f					      db	17
      1  136f		       11		      .byte.b	17
      0  1370					      IJMP	T0	; Check for * or /
      0  1370					      db	29
      1  1370		       1d		      .byte.b	29
      0  1371					      dw	T0
      1  1371		       68 13		      .word.w	T0
    351  1373				   T1
      0  1373					      TST	T2,"/"	; Check for a division
      0  1373					      db	32
      1  1373		       20		      .byte.b	32
      0  1374					      db	(T2-*)-1
      1  1374		       09		      .byte.b	(T2-*)-1
      0  1375					      db	"/",0
      1  1375		       2f 00		      .byte.b	"/",0
      0  1377					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1377					      db	28
      1  1377		       1c		      .byte.b	28
      0  1378					      dw	FACT
      1  1378		       8d 13		      .word.w	FACT
      0  137a					      DIV		; do division
      0  137a					      db	18
      1  137a		       12		      .byte.b	18
      0  137b					      IJMP	T0	; check for more * or /
      0  137b					      db	29
      1  137b		       1d		      .byte.b	29
      0  137c					      dw	T0
      1  137c		       68 13		      .word.w	T0
    356  137e				   T2
      0  137e					      TST	T3,"%"	; Check for a division
      0  137e					      db	32
      1  137e		       20		      .byte.b	32
      0  137f					      db	(T3-*)-1
      1  137f		       09		      .byte.b	(T3-*)-1
      0  1380					      db	"%",0
      1  1380		       25 00		      .byte.b	"%",0
      0  1382					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  1382					      db	28
      1  1382		       1c		      .byte.b	28
      0  1383					      dw	FACT
      1  1383		       8d 13		      .word.w	FACT
      0  1385					      MODULO		; do division for remainder
      0  1385					      db	60
      1  1385		       3c		      .byte.b	60
      0  1386					      IJMP	T0	; check for more * or / or %
      0  1386					      db	29
      1  1386		       1d		      .byte.b	29
      0  1387					      dw	T0
      1  1387		       68 13		      .word.w	T0
    361  1389				   T3			; Finish processing the Term
      0  1389					      RTN
      0  1389					      db	25
      1  1389		       19		      .byte.b	25
    363  138a
    364  138a				   UNKNOWNVEC
      0  138a					      IJMP	UNKNOWN
      0  138a					      db	29
      1  138a		       1d		      .byte.b	29
      0  138b					      dw	UNKNOWN
      1  138b		       ee 12		      .word.w	UNKNOWN
    366  138d
    367  138d							;
    368  138d							; Factor an expression.  Always test for functions
    369  138d							; first or else they'll be confused for variables.
    370  138d							;
    371  138d				   FACT
      0  138d					      TST	F1A,"FREE()"
      0  138d					      db	32
      1  138d		       20		      .byte.b	32
      0  138e					      db	(F1A-*)-1
      1  138e		       09		      .byte.b	(F1A-*)-1
      0  138f					      db	"FREE()",0
      1  138f		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1396					      FREE
      0  1396					      db	36
      1  1396		       24		      .byte.b	36
      0  1397					      RTN
      0  1397					      db	25
      1  1397		       19		      .byte.b	25
    375  1398				   F1A
      0  1398					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1398					      db	32
      1  1398		       20		      .byte.b	32
      0  1399					      db	(F1A2-*)-1
      1  1399		       0a		      .byte.b	(F1A2-*)-1
      0  139a					      db	"GETCH()",0
      1  139a		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  13a2					      GETCHAR
      0  13a2					      db	51
      1  13a2		       33		      .byte.b	51
      0  13a3					      RTN
      0  13a3					      db	25
      1  13a3		       19		      .byte.b	25
    379  13a4				   F1A2
      0  13a4					      TST	F2AZ,"PEEK("	;Return a value from memory
      0  13a4					      db	32
      1  13a4		       20		      .byte.b	32
      0  13a5					      db	(F2AZ-*)-1
      1  13a5		       0f		      .byte.b	(F2AZ-*)-1
      0  13a6					      db	"PEEK(",0
      1  13a6		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  13ac					      CALL	EXPR	;Get the address to write to
      0  13ac					      db	28
      1  13ac		       1c		      .byte.b	28
      0  13ad					      dw	EXPR
      1  13ad		       f1 12		      .word.w	EXPR
      0  13af					      TST	UNKNOWN,")"	;Closing bracket
      0  13af					      db	32
      1  13af		       20		      .byte.b	32
      0  13b0					      db	(UNKNOWN-*)-1
      1  13b0		       3d		      .byte.b	(UNKNOWN-*)-1
      0  13b1					      db	")",0
      1  13b1		       29 00		      .byte.b	")",0
      0  13b3					      PEEKMEM
      0  13b3					      db	48
      1  13b3		       30		      .byte.b	48
      0  13b4					      RTN
      0  13b4					      db	25
      1  13b4		       19		      .byte.b	25
    385  13b5				   F2AZ
      0  13b5					      TST	F2A,"TASK("	;Check if we are setting a task start
      0  13b5					      db	32
      1  13b5		       20		      .byte.b	32
      0  13b6					      db	(F2A-*)-1
      1  13b6		       0f		      .byte.b	(F2A-*)-1
      0  13b7					      db	"TASK(",0
      1  13b7		       54 41 53 4b*	      .byte.b	"TASK(",0
      0  13bd					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  13bd					      db	28
      1  13bd		       1c		      .byte.b	28
      0  13be					      dw	EXPR
      1  13be		       f1 12		      .word.w	EXPR
      0  13c0					      TST	UNKNOWN,")"	;must be )
      0  13c0					      db	32
      1  13c0		       20		      .byte.b	32
      0  13c1					      db	(UNKNOWN-*)-1
      1  13c1		       2c		      .byte.b	(UNKNOWN-*)-1
      0  13c2					      db	")",0
      1  13c2		       29 00		      .byte.b	")",0
      0  13c4					      SETTASK		;Set the Task up and start it
      0  13c4					      db	62
      1  13c4		       3e		      .byte.b	62
      0  13c5					      RTN		;Returns the Task number
      0  13c5					      db	25
      1  13c5		       19		      .byte.b	25
    391  13c6							;
    392  13c6							; RND() is supposed to have an argument but if none
    393  13c6							; was provided, just assume a large value.
    394  13c6							;
    395  13c6				   F2A
      0  13c6					      TST	F2B,"RND("
      0  13c6					      db	32
      1  13c6		       20		      .byte.b	32
      0  13c7					      db	(F2B-*)-1
      1  13c7		       17		      .byte.b	(F2B-*)-1
      0  13c8					      db	"RND(",0
      1  13c8		       52 4e 44 28*	      .byte.b	"RND(",0
      0  13cd					      TST	F2A1,")"
      0  13cd					      db	32
      1  13cd		       20		      .byte.b	32
      0  13ce					      db	(F2A1-*)-1
      1  13ce		       07		      .byte.b	(F2A1-*)-1
      0  13cf					      db	")",0
      1  13cf		       29 00		      .byte.b	")",0
      0  13d1					      LIT	32766
      0  13d1					      db	27
      1  13d1		       1b		      .byte.b	27
      0  13d2					      dw	32766
      1  13d2		       fe 7f		      .word.w	32766
      0  13d4					      RANDOM
      0  13d4					      db	37
      1  13d4		       25		      .byte.b	37
      0  13d5					      RTN
      0  13d5					      db	25
      1  13d5		       19		      .byte.b	25
    401  13d6				   F2A1
      0  13d6					      CALL	FACT	;GET RANGE
      0  13d6					      db	28
      1  13d6		       1c		      .byte.b	28
      0  13d7					      dw	FACT
      1  13d7		       8d 13		      .word.w	FACT
      0  13d9					      TST	UNKNOWN,")"
      0  13d9					      db	32
      1  13d9		       20		      .byte.b	32
      0  13da					      db	(UNKNOWN-*)-1
      1  13da		       13		      .byte.b	(UNKNOWN-*)-1
      0  13db					      db	")",0
      1  13db		       29 00		      .byte.b	")",0
      0  13dd					      RANDOM
      0  13dd					      db	37
      1  13dd		       25		      .byte.b	37
      0  13de					      RTN
      0  13de					      db	25
      1  13de		       19		      .byte.b	25
    406  13df
    407  13df				   F2B
      0  13df					      TST	F2B2,"ABS("
      0  13df					      db	32
      1  13df		       20		      .byte.b	32
      0  13e0					      db	(F2B2-*)-1
      1  13e0		       0e		      .byte.b	(F2B2-*)-1
      0  13e1					      db	"ABS(",0
      1  13e1		       41 42 53 28*	      .byte.b	"ABS(",0
      0  13e6					      CALL	FACT	;get value
      0  13e6					      db	28
      1  13e6		       1c		      .byte.b	28
      0  13e7					      dw	FACT
      1  13e7		       8d 13		      .word.w	FACT
      0  13e9					      TST	UNKNOWNVEC,")"
      0  13e9					      db	32
      1  13e9		       20		      .byte.b	32
      0  13ea					      db	(UNKNOWNVEC-*)-1
      1  13ea		       9f		      .byte.b	(UNKNOWNVEC-*)-1
      0  13eb					      db	")",0
      1  13eb		       29 00		      .byte.b	")",0
      0  13ed					      ABS
      0  13ed					      db	38
      1  13ed		       26		      .byte.b	38
      0  13ee					      RTN
      0  13ee					      db	25
      1  13ee		       19		      .byte.b	25
    413  13ef
    414  13ef				   F2B2
      0  13ef					      TST	F2Z,"STAT("
      0  13ef					      db	32
      1  13ef		       20		      .byte.b	32
      0  13f0					      db	(F2Z-*)-1
      1  13f0		       0f		      .byte.b	(F2Z-*)-1
      0  13f1					      db	"STAT(",0
      1  13f1		       53 54 41 54*	      .byte.b	"STAT(",0
      0  13f7					      Call	EXPR
      0  13f7					      db	28
      1  13f7		       1c		      .byte.b	28
      0  13f8					      dw	EXPR
      1  13f8		       f1 12		      .word.w	EXPR
      0  13fa					      TST	UNKNOWNVEC,")"
      0  13fa					      db	32
      1  13fa		       20		      .byte.b	32
      0  13fb					      db	(UNKNOWNVEC-*)-1
      1  13fb		       8e		      .byte.b	(UNKNOWNVEC-*)-1
      0  13fc					      db	")",0
      1  13fc		       29 00		      .byte.b	")",0
      0  13fe					      TASKSTAT
      0  13fe					      db	67
      1  13fe		       43		      .byte.b	67
      0  13ff					      RTN
      0  13ff					      db	25
      1  13ff		       19		      .byte.b	25
    420  1400				   F2Z
      0  1400					      TST	F2C,"CALL("	;call machine function
      0  1400					      db	32
      1  1400		       20		      .byte.b	32
      0  1401					      db	(F2C-*)-1
      1  1401		       1f		      .byte.b	(F2C-*)-1
      0  1402					      db	"CALL(",0
      1  1402		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1408					      CALL	EXPR
      0  1408					      db	28
      1  1408		       1c		      .byte.b	28
      0  1409					      dw	EXPR
      1  1409		       f1 12		      .word.w	EXPR
      0  140b					      TST	F2B2A,COMMA
      0  140b					      db	32
      1  140b		       20		      .byte.b	32
      0  140c					      db	(F2B2A-*)-1
      1  140c		       0b		      .byte.b	(F2B2A-*)-1
      0  140d					      db	COMMA,0
      1  140d		       2c 00		      .byte.b	COMMA,0
      0  140f					      CALL	EXPR
      0  140f					      db	28
      1  140f		       1c		      .byte.b	28
      0  1410					      dw	EXPR
      1  1410		       f1 12		      .word.w	EXPR
      0  1412					      TST	UNKNOWNVEC,")"
      0  1412					      db	32
      1  1412		       20		      .byte.b	32
      0  1413					      db	(UNKNOWNVEC-*)-1
      1  1413		       76		      .byte.b	(UNKNOWNVEC-*)-1
      0  1414					      db	")",0
      1  1414		       29 00		      .byte.b	")",0
      0  1416					      CALLFUNC
      0  1416					      db	53
      1  1416		       35		      .byte.b	53
      0  1417					      RTN
      0  1417					      db	25
      1  1417		       19		      .byte.b	25
      0  1418				   F2B2A      TST	UNKNOWNVEC,")"
      0  1418					      db	32
      1  1418		       20		      .byte.b	32
      0  1419					      db	(UNKNOWNVEC-*)-1
      1  1419		       70		      .byte.b	(UNKNOWNVEC-*)-1
      0  141a					      db	")",0
      1  141a		       29 00		      .byte.b	")",0
      0  141c					      LIT	0
      0  141c					      db	27
      1  141c		       1b		      .byte.b	27
      0  141d					      dw	0
      1  141d		       00 00		      .word.w	0
      0  141f					      CALLFUNC
      0  141f					      db	53
      1  141f		       35		      .byte.b	53
      0  1420					      RTN
      0  1420					      db	25
      1  1420		       19		      .byte.b	25
    432  1421				   F2C
      0  1421					      TSTV	F0
      0  1421					      db	33
      1  1421		       21		      .byte.b	33
      0  1422					      db	(F0-*)-1
      1  1422		       0e		      .byte.b	(F0-*)-1
      0  1423					      TST	F2C1,"["
      0  1423					      db	32
      1  1423		       20		      .byte.b	32
      0  1424					      db	(F2C1-*)-1
      1  1424		       0a		      .byte.b	(F2C1-*)-1
      0  1425					      db	"[",0
      1  1425		       5b 00		      .byte.b	"[",0
      0  1427					      CALL	EXPR
      0  1427					      db	28
      1  1427		       1c		      .byte.b	28
      0  1428					      dw	EXPR
      1  1428		       f1 12		      .word.w	EXPR
      0  142a					      TST	UNKNOWNVEC,"]"
      0  142a					      db	32
      1  142a		       20		      .byte.b	32
      0  142b					      db	(UNKNOWNVEC-*)-1
      1  142b		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  142c					      db	"]",0
      1  142c		       5d 00		      .byte.b	"]",0
      0  142e					      SUBSCRIPT
      0  142e					      db	65
      1  142e		       41		      .byte.b	65
    438  142f				   F2C1
      0  142f					      IND		;YES, GET THE VALUE.
      0  142f					      db	20
      1  142f		       14		      .byte.b	20
      0  1430					      RTN
      0  1430					      db	25
      1  1430		       19		      .byte.b	25
    441  1431				   F0
      0  1431					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  1431					      db	35
      1  1431		       23		      .byte.b	35
      0  1432					      db	(F1-*)-1
      1  1432		       01		      .byte.b	(F1-*)-1
      0  1433					      RTN
      0  1433					      db	25
      1  1433		       19		      .byte.b	25
    444  1434				   F1
      0  1434					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  1434					      db	32
      1  1434		       20		      .byte.b	32
      0  1435					      db	(F2A-*)-1
      1  1435		       90		      .byte.b	(F2A-*)-1
      0  1436					      db	"(",0
      1  1436		       28 00		      .byte.b	"(",0
      0  1438					      CALL	EXPR
      0  1438					      db	28
      1  1438		       1c		      .byte.b	28
      0  1439					      dw	EXPR
      1  1439		       f1 12		      .word.w	EXPR
      0  143b					      TST	F2,")"
      0  143b					      db	32
      1  143b		       20		      .byte.b	32
      0  143c					      db	(F2-*)-1
      1  143c		       03		      .byte.b	(F2-*)-1
      0  143d					      db	")",0
      1  143d		       29 00		      .byte.b	")",0
      0  143f					      RTN
      0  143f					      db	25
      1  143f		       19		      .byte.b	25
    449  1440
    450  1440				   F2
      0  1440					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  1440					      db	13
      1  1440		       0d		      .byte.b	13
      0  1441					      dw	ERR_SYNTAX
      1  1441		       05 00		      .word.w	ERR_SYNTAX
    452  1443
    453  1443		       14 43	   ILEND      equ	*
------- FILE mytb.asm
   2050  1443		       14 43	   PROGEND    equ	*
   2051  1443
   2052  1443							;=====================================================
   2053  1443							;=====================================================
   2054  1443							;=====================================================
   2055  1443							; These are storage items not in page zero.
   2056  1443							;
   2057 Udf9e					      seg.u	Data
   2058 U1443					      org	PROGEND
   2059 U1443							;
   2060 U1443							; IRQ BASIC Code Service RTN Support
      0 U1443				   SaveIrqReg db	0	; Store current setting
      1 U1443		       00		      .byte.b	0
      0 U1444				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1 U1444		       00		      .byte.b	0
      0 U1445				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1 U1445		       00		      .byte.b	0
      0 U1446				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1 U1446		       00 00		      .byte.b	0,0
   2065 U1448							;
   2066 U1448							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2067 U1448							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2068 U1448							; Task switchs happen at the beginning of the next Basic command line
   2069 U1448							; It will not happen during an input or output operations
   2070 U1448							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2071 U1448							; Task Zero is always the root task, main line program
   2072 U1448		       00 00 00 00*taskTable  ds	TASKCOUNT*4	; Task Table Offset and pointer to Basic code, active flag
   2073 U1470		       00	   taskPtr    ds	1	; Current offset into task table 0, 3, 6,9 ...
   2074 U1471
   2075 U1471		       00 00 00 00*mathStack  ds	STACKSIZE*2	;Stack used for math expressions
   2076 U1499		       00	   mathStackPtr ds	1
   2077 U149a		       00 00 00 00*retStack   ds	ILSTACKSIZE*2	;stack used by the IL for calls and returns
   2078 U14ea		       00	   retStackPtr ds	1
   2079 U14eb							;callStack	 ds	 GOSUBSTACKSIZE*3   ; Allocated dynamically at App start
   2080 U14eb		       00	   GoSubStackPtr ds	1
   2081 U14ec
   2082 U14ec
   2083 U14ec							;
   2084 U14ec							;
   2085 U14ec		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2086 U1570		       00	   getlinx    ds	1
   2087 U1571		       00	   printtx    ds	1	;temp X for print funcs
   2088 U1572		       00	   diddigit   ds	1	;for leading zero suppression
   2089 U1573		       00	   putsy      ds	1
   2090 U1574		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2091 U1576		       00 00	   MQ	      ds	2	;used for some math
   2092 U1578		       00	   sign       ds	1	;0 = positive, else negative
   2093 U1579		       00	   rtemp1     ds	1
   2094 U157a		       00 00	   random     ds	2
   2095 U157c		       00 00	   BOutVec    ds	2
   2096 U157e		       00	   tempy      ds	1	;temp y storage
   2097 U157f				  -	      if	XKIM
   2098 U157f				  -buffer     ds	BUFFER_SIZE
   2099 U157f					      endif
   2100 U157f							;
   2101 U157f							; PROGRAMEND is the end of the user's BASIC program.
   2102 U157f							; More precisely, it is one byte past the end.  Or,
   2103 U157f							; it's where the next line added to the end will be
   2104 U157f							; placed.
   2105 U157f							;
   2106 U157f		       00 00	   PROGRAMEND ds	2
   2107 U1581		       00 00	   HighMem    ds	2	;highest location
   2108 U1583		       00 00	   UsedMem    ds	2	;size of user program
   2109 U1585		       00 00	   FreeMem    ds	2	;amount of free memory
   2110 U1587							;
   2111 U1587							;=====================================================
   2112 U1587							; This is the start of the user's BASIC program space.
   2113 U1587							;
   2114 U1587							; PERSONAL GOAL: This should be no larger than $0DFF.
   2115 U1587							;		  0200-05FF = 1K
   2116 U1587							;		  0200-09FF = 2K
   2117 U1587							;		  0200-0DFF = 3K
   2118 U1587							;		  0200-11FF = 4K
   2119 U1587							;		  0200-13FF = 4.5K
   2120 U1587							;
   2121 U1587				  -	      if	FIXED
   2122 U1587				  -	      org	$2000
   2123 U1587					      endif
   2124 U1587		       15 87	   ProgramStart equ	*
   2125 U1587							;/*
   2126 U1587							;	if	CTMON65 || XKIM
   2127 U1587							;		SEG Code
   2128 U1587							;		org	AutoRun
   2129 U1587							;		dw	TBasicCold
   2130 U1587							;	endif
   2131 U1587							;*/
   2132 U1587					      end
