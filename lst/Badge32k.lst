0001    ; VCF-MW 12 6502 Badge Software0002    ; Hardware design by Lee Hart0003    ; Software design by Daryl Rictor0004    ;0005    ; This software is free to use and modify in any non-commercial application.0006    ; Comericial use is prohibited without expressed, written permission from the author.0007    ;0008    ; Instructions to Assemble0009    ;0010    ; 1.  Open this file in the 6502 Simulator0011    ; 2.  Select "Simulator->Options from the top menu bar0012    ; 3.  On the Simulator tab:0013    ;	Select Finish running with 0xBB instruction0014    ;	Set IO area to 0x7F000015    ; 4.  On the Assember tab:0016    ;	Uncheck generate extra byte for BRK   0017    ; 5.  On the General Tab:0018    ;	Select 65C02, 65010019    ; 6.  Close Options and Assemble0020    ; 7.  Select SAVE CODE from the File menu0021    ;       Select Binary Image (*.65b) and open the options tab0022    ;       Select 0x8000 as the start address (0x8000 file size)0023    ;	close options and Save the file.0024    ; 8.  Burn the Binary Code.65b file to your EPROM and install in your badge. 0025    ; 9.  Go play!0026    ;0027    C000               	*=  $C000                    ; start at $C0000028    	.include "CRCtable.asm"      ; XMODEM CRC TABLE (these need to be page aligned, so put first)0029    
0030    ; VCF-MW 12 6502 Badge Software
0031    ; Hardware design by Lee Hart
0032    ; Software design by Daryl Rictor
0033    ;
0034    ; This software is free to use and modify in any non-commercial application.
0035    ; Comericial use is prohibited without expressed, written permission from the author.
0036    ;
0037    ;
0038    ; CRC table used by XMODEM send and receive.
0039    ;
0040    ; Those programs use indexed lookups which require these table to be
0041    ; page aligned. 
0042    ;
0043    ; There is a *= $C000 located in the sbc.asm file to ensure this is met.
0044    ;
0045    ; lo CRC lookup table
0046    Crclo
0047     .byte $00,$21,$42,$63,$84,$A5,$C6,$E7,$08,$29,$4A,$6B,$8C,$AD,$CE,$EF
0048     .byte $31,$10,$73,$52,$B5,$94,$F7,$D6,$39,$18,$7B,$5A,$BD,$9C,$FF,$DE
0049     .byte $62,$43,$20,$01,$E6,$C7,$A4,$85,$6A,$4B,$28,$09,$EE,$CF,$AC,$8D
0050     .byte $53,$72,$11,$30,$D7,$F6,$95,$B4,$5B,$7A,$19,$38,$DF,$FE,$9D,$BC
0051     .byte $C4,$E5,$86,$A7,$40,$61,$02,$23,$CC,$ED,$8E,$AF,$48,$69,$0A,$2B
0052     .byte $F5,$D4,$B7,$96,$71,$50,$33,$12,$FD,$DC,$BF,$9E,$79,$58,$3B,$1A
0053     .byte $A6,$87,$E4,$C5,$22,$03,$60,$41,$AE,$8F,$EC,$CD,$2A,$0B,$68,$49
0054     .byte $97,$B6,$D5,$F4,$13,$32,$51,$70,$9F,$BE,$DD,$FC,$1B,$3A,$59,$78
0055     .byte $88,$A9,$CA,$EB,$0C,$2D,$4E,$6F,$80,$A1,$C2,$E3,$04,$25,$46,$67
0056     .byte $B9,$98,$FB,$DA,$3D,$1C,$7F,$5E,$B1,$90,$F3,$D2,$35,$14,$77,$56
0057     .byte $EA,$CB,$A8,$89,$6E,$4F,$2C,$0D,$E2,$C3,$A0,$81,$66,$47,$24,$05
0058     .byte $DB,$FA,$99,$B8,$5F,$7E,$1D,$3C,$D3,$F2,$91,$B0,$57,$76,$15,$34
0059     .byte $4C,$6D,$0E,$2F,$C8,$E9,$8A,$AB,$44,$65,$06,$27,$C0,$E1,$82,$A3
0060     .byte $7D,$5C,$3F,$1E,$F9,$D8,$BB,$9A,$75,$54,$37,$16,$F1,$D0,$B3,$92
0061     .byte $2E,$0F,$6C,$4D,$AA,$8B,$E8,$C9,$26,$07,$64,$45,$A2,$83,$E0,$C1
0062     .byte $1F,$3E,$5D,$7C,$9B,$BA,$D9,$F8,$17,$36,$55,$74,$93,$B2,$D1,$F0 
0063    
0064    ; hi CRC lookup table
0065    Crchi
0066     .byte $00,$10,$20,$30,$40,$50,$60,$70,$81,$91,$A1,$B1,$C1,$D1,$E1,$F1
0067     .byte $12,$02,$32,$22,$52,$42,$72,$62,$93,$83,$B3,$A3,$D3,$C3,$F3,$E3
0068     .byte $24,$34,$04,$14,$64,$74,$44,$54,$A5,$B5,$85,$95,$E5,$F5,$C5,$D5
0069     .byte $36,$26,$16,$06,$76,$66,$56,$46,$B7,$A7,$97,$87,$F7,$E7,$D7,$C7
0070     .byte $48,$58,$68,$78,$08,$18,$28,$38,$C9,$D9,$E9,$F9,$89,$99,$A9,$B9
0071     .byte $5A,$4A,$7A,$6A,$1A,$0A,$3A,$2A,$DB,$CB,$FB,$EB,$9B,$8B,$BB,$AB
0072     .byte $6C,$7C,$4C,$5C,$2C,$3C,$0C,$1C,$ED,$FD,$CD,$DD,$AD,$BD,$8D,$9D
0073     .byte $7E,$6E,$5E,$4E,$3E,$2E,$1E,$0E,$FF,$EF,$DF,$CF,$BF,$AF,$9F,$8F
0074     .byte $91,$81,$B1,$A1,$D1,$C1,$F1,$E1,$10,$00,$30,$20,$50,$40,$70,$60
0075     .byte $83,$93,$A3,$B3,$C3,$D3,$E3,$F3,$02,$12,$22,$32,$42,$52,$62,$72
0076     .byte $B5,$A5,$95,$85,$F5,$E5,$D5,$C5,$34,$24,$14,$04,$74,$64,$54,$44
0077     .byte $A7,$B7,$87,$97,$E7,$F7,$C7,$D7,$26,$36,$06,$16,$66,$76,$46,$56
0078     .byte $D9,$C9,$F9,$E9,$99,$89,$B9,$A9,$58,$48,$78,$68,$18,$08,$38,$28
0079     .byte $CB,$DB,$EB,$FB,$8B,$9B,$AB,$BB,$4A,$5A,$6A,$7A,$0A,$1A,$2A,$3A
0080     .byte $FD,$ED,$DD,$CD,$BD,$AD,$9D,$8D,$7C,$6C,$5C,$4C,$3C,$2C,$1C,$0C
0081     .byte $EF,$FF,$CF,$DF,$AF,$BF,$8F,$9F,$6E,$7E,$4E,$5E,$2E,$3E,$0E,$1E 
0082    
0083    
0084    	.include "basic.asm"         ; Enhanced BASIC V2.220085    
0086    ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22
0087    
0088    ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
0089    
0090    ; 2.00	new revision numbers start here
0091    ; 2.01	fixed LCASE$() and UCASE$()
0092    ; 2.02	new get value routine done
0093    ; 2.03	changed RND() to galoise method
0094    ; 2.04	fixed SPC()
0095    ; 2.05	new get value routine fixed
0096    ; 2.06	changed USR() code
0097    ; 2.07	fixed STR$()
0098    ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
0099    ; 2.09	fixed RND()
0100    ; 2.10	integrated missed changes from an earlier version
0101    ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
0102    ; 2.21	fixed IF .. THEN RETURN to not cause error
0103    ; 2.22	fixed RND() breaking the get byte routine
0104    
0105    ; zero page use ..
0106    
0107      0000             LAB_WARM 		= $00		; BASIC warm start entry point
0108      0001             Wrmjpl 		= LAB_WARM+1; BASIC warm start vector jump low byte
0109      0002             Wrmjph 		= LAB_WARM+2; BASIC warm start vector jump high byte
0110    
0111      000A             Usrjmp		= $0A		; USR function JMP address
0112      000B             Usrjpl		= Usrjmp+1	; USR function JMP vector low byte
0113      000C             Usrjph		= Usrjmp+2	; USR function JMP vector high byte
0114      000D             Nullct		= $0D		; nulls output after each line
0115      000E             TPos			= $0E		; BASIC terminal position byte
0116      000F             TWidth		= $0F		; BASIC terminal width byte
0117      0010             Iclim			= $10		; input column limit
0118      0011             Itempl		= $11		; temporary integer low byte
0119      0012             Itemph		= Itempl+1	; temporary integer high byte
0120    
0121      0011             nums_1		= Itempl	; number to bin/hex string convert MSB
0122      0012             nums_2		= nums_1+1	; number to bin/hex string convert
0123      0013             nums_3		= nums_1+2	; number to bin/hex string convert LSB
0124    
0125      005B             Srchc			= $5B		; search character
0126      005B             Temp3			= Srchc	; temp byte used in number routines
0127      005C             Scnquo		= $5C		; scan-between-quotes flag
0128      005C             Asrch			= Scnquo	; alt search character
0129    
0130      005B             XOAw_l		= Srchc	; eXclusive OR, OR and AND word low byte
0131      005C             XOAw_h		= Scnquo	; eXclusive OR, OR and AND word high byte
0132    
0133      005D             Ibptr			= $5D		; input buffer pointer
0134      005D             Dimcnt		= Ibptr	; # of dimensions
0135      005D             Tindx			= Ibptr	; token index
0136    
0137      005E             Defdim		= $5E		; default DIM flag
0138      005F             Dtypef		= $5F		; data type flag, $FF=string, $00=numeric
0139      0060             Oquote		= $60		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
0140      0060             Gclctd		= $60		; garbage collected flag
0141      0061             Sufnxf		= $61		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
0142      0062             Imode			= $62		; input mode flag, $00=INPUT, $80=READ
0143    
0144      0063             Cflag			= $63		; comparison evaluation flag
0145    
0146      0064             TabSiz		= $64		; TAB step size (was input flag)
0147    
0148      0065             next_s		= $65		; next descriptor stack address
0149    
0150    					; these two bytes form a word pointer to the item
0151    					; currently on top of the descriptor stack
0152      0066             last_sl		= $66		; last descriptor stack address low byte
0153      0067             last_sh		= $67		; last descriptor stack address high byte (always $00)
0154    
0155      0068             des_sk		= $68		; descriptor stack start address (temp strings)
0156    
0157    ;			= $70		; End of descriptor stack
0158    
0159      0071             ut1_pl		= $71		; utility pointer 1 low byte
0160      0072             ut1_ph		= ut1_pl+1	; utility pointer 1 high byte
0161      0073             ut2_pl		= $73		; utility pointer 2 low byte
0162      0074             ut2_ph		= ut2_pl+1	; utility pointer 2 high byte
0163    
0164      0071             Temp_2		= ut1_pl	; temp byte for block move	
0165    
0166      0075             FACt_1		= $75		; FAC temp mantissa1
0167      0076             FACt_2		= FACt_1+1	; FAC temp mantissa2
0168      0077             FACt_3		= FACt_2+1	; FAC temp mantissa3
0169    
0170      0076             dims_l		= FACt_2	; array dimension size low byte
0171      0077             dims_h		= FACt_3	; array dimension size high byte
0172    
0173      0078             TempB			= $78		; temp page 0 byte
0174    
0175      0079             Smeml			= $79		; start of mem low byte		(Start-of-Basic)
0176      007A             Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
0177      007B             Svarl			= $7B		; start of vars low byte	(Start-of-Variables)
0178      007C             Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
0179      007D             Sarryl		= $7D		; var mem end low byte		(Start-of-Arrays)
0180      007E             Sarryh		= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
0181      007F             Earryl		= $7F		; array mem end low byte	(End-of-Arrays)
0182      0080             Earryh		= Earryl+1	; array mem end high byte	(End-of-Arrays)
0183      0081             Sstorl		= $81		; string storage low byte	(String storage (moving down))
0184      0082             Sstorh		= Sstorl+1	; string storage high byte	(String storage (moving down))
0185      0083             Sutill		= $83		; string utility ptr low byte
0186      0084             Sutilh		= Sutill+1	; string utility ptr high byte
0187      0085             Ememl			= $85		; end of mem low byte		(Limit-of-memory)
0188      0086             Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
0189      0087             Clinel		= $87		; current line low byte		(Basic line number)
0190      0088             Clineh		= Clinel+1	; current line high byte	(Basic line number)
0191      0089             Blinel		= $89		; break line low byte		(Previous Basic line number)
0192      008A             Blineh		= Blinel+1	; break line high byte		(Previous Basic line number)
0193    
0194      008B             Cpntrl		= $8B		; continue pointer low byte
0195      008C             Cpntrh		= Cpntrl+1	; continue pointer high byte
0196    
0197      008D             Dlinel		= $8D		; current DATA line low byte
0198      008E             Dlineh		= Dlinel+1	; current DATA line high byte
0199    
0200      008F             Dptrl			= $8F		; DATA pointer low byte
0201      0090             Dptrh			= Dptrl+1	; DATA pointer high byte
0202    
0203      0091             Rdptrl		= $91		; read pointer low byte
0204      0092             Rdptrh		= Rdptrl+1	; read pointer high byte
0205    
0206      0093             Varnm1		= $93		; current var name 1st byte
0207      0094             Varnm2		= Varnm1+1	; current var name 2nd byte
0208    
0209      0095             Cvaral		= $95		; current var address low byte
0210      0096             Cvarah		= Cvaral+1	; current var address high byte
0211    
0212      0097             Frnxtl		= $97		; var pointer for FOR/NEXT low byte
0213      0098             Frnxth		= Frnxtl+1	; var pointer for FOR/NEXT high byte
0214    
0215      0097             Tidx1			= Frnxtl	; temp line index
0216    
0217      0097             Lvarpl		= Frnxtl	; let var pointer low byte
0218      0098             Lvarph		= Frnxth	; let var pointer high byte
0219    
0220      0099             prstk			= $99		; precedence stacked flag
0221    
0222      009B             comp_f		= $9B		; compare function flag, bits 0,1 and 2 used
0223    					; bit 2 set if >
0224    					; bit 1 set if =
0225    					; bit 0 set if <
0226    
0227      009C             func_l		= $9C		; function pointer low byte
0228      009D             func_h		= func_l+1	; function pointer high byte
0229    
0230      009C             garb_l		= func_l	; garbage collection working pointer low byte
0231      009D             garb_h		= func_h	; garbage collection working pointer high byte
0232    
0233      009E             des_2l		= $9E		; string descriptor_2 pointer low byte
0234      009F             des_2h		= des_2l+1	; string descriptor_2 pointer high byte
0235    
0236      00A0             g_step		= $A0		; garbage collect step size
0237    
0238      00A1             Fnxjmp		= $A1		; jump vector for functions
0239      00A2             Fnxjpl		= Fnxjmp+1	; functions jump vector low byte
0240      00A3             Fnxjph		= Fnxjmp+2	; functions jump vector high byte
0241    
0242      00A2             g_indx		= Fnxjpl	; garbage collect temp index
0243    
0244      00A3             FAC2_r		= $A3		; FAC2 rounding byte
0245    
0246      00A4             Adatal		= $A4		; array data pointer low byte
0247      00A5             Adatah		= Adatal+1	; array data pointer high  byte
0248    
0249      00A4             Nbendl		= Adatal	; new block end pointer low byte
0250      00A5             Nbendh		= Adatah	; new block end pointer high  byte
0251    
0252      00A6             Obendl		= $A6		; old block end pointer low byte
0253      00A7             Obendh		= Obendl+1	; old block end pointer high  byte
0254    
0255      00A8             numexp		= $A8		; string to float number exponent count
0256      00A9             expcnt		= $A9		; string to float exponent count
0257    
0258      00A8             numbit		= numexp	; bit count for array element calculations
0259    
0260      00AA             numdpf		= $AA		; string to float decimal point flag
0261      00AB             expneg		= $AB		; string to float eval exponent -ve flag
0262    
0263      00AA             Astrtl		= numdpf	; array start pointer low byte
0264      00AB             Astrth		= expneg	; array start pointer high  byte
0265    
0266      00AA             Histrl		= numdpf	; highest string low byte
0267      00AB             Histrh		= expneg	; highest string high  byte
0268    
0269      00AA             Baslnl		= numdpf	; BASIC search line pointer low byte
0270      00AB             Baslnh		= expneg	; BASIC search line pointer high  byte
0271    
0272      00AA             Fvar_l		= numdpf	; find/found variable pointer low byte
0273      00AB             Fvar_h		= expneg	; find/found variable pointer high  byte
0274    
0275      00AA             Ostrtl		= numdpf	; old block start pointer low byte
0276      00AB             Ostrth		= expneg	; old block start pointer high  byte
0277    
0278      00AA             Vrschl		= numdpf	; variable search pointer low byte
0279      00AB             Vrschh		= expneg	; variable search pointer high  byte
0280    
0281      00AC             FAC1_e		= $AC		; FAC1 exponent
0282      00AD             FAC1_1		= FAC1_e+1	; FAC1 mantissa1
0283      00AE             FAC1_2		= FAC1_e+2	; FAC1 mantissa2
0284      00AF             FAC1_3		= FAC1_e+3	; FAC1 mantissa3
0285      00B0             FAC1_s		= FAC1_e+4	; FAC1 sign (b7)
0286    
0287      00AC             str_ln		= FAC1_e	; string length
0288      00AD             str_pl		= FAC1_1	; string pointer low byte
0289      00AE             str_ph		= FAC1_2	; string pointer high byte
0290    
0291      00AE             des_pl		= FAC1_2	; string descriptor pointer low byte
0292      00AF             des_ph		= FAC1_3	; string descriptor pointer high byte
0293    
0294      00AF             mids_l		= FAC1_3	; MID$ string temp length byte
0295    
0296      00B1             negnum		= $B1		; string to float eval -ve flag
0297      00B1             numcon		= $B1		; series evaluation constant count
0298    
0299      00B2             FAC1_o		= $B2		; FAC1 overflow byte
0300    
0301      00B3             FAC2_e		= $B3		; FAC2 exponent
0302      00B4             FAC2_1		= FAC2_e+1	; FAC2 mantissa1
0303      00B5             FAC2_2		= FAC2_e+2	; FAC2 mantissa2
0304      00B6             FAC2_3		= FAC2_e+3	; FAC2 mantissa3
0305      00B7             FAC2_s		= FAC2_e+4	; FAC2 sign (b7)
0306    
0307      00B8             FAC_sc		= $B8		; FAC sign comparison, Acc#1 vs #2
0308      00B9             FAC1_r		= $B9		; FAC1 rounding byte
0309    
0310      00B8             ssptr_l		= FAC_sc	; string start pointer low byte
0311      00B9             ssptr_h		= FAC1_r	; string start pointer high byte
0312    
0313      00B8             sdescr		= FAC_sc	; string descriptor pointer
0314    
0315      00BA             csidx			= $BA		; line crunch save index
0316      00BA             Asptl			= csidx	; array size/pointer low byte
0317      00BB             Aspth			= $BB		; array size/pointer high byte
0318    
0319      00BA             Btmpl			= Asptl	; BASIC pointer temp low byte
0320      00BB             Btmph			= Aspth	; BASIC pointer temp low byte
0321    
0322      00BA             Cptrl			= Asptl	; BASIC pointer temp low byte
0323      00BB             Cptrh			= Aspth	; BASIC pointer temp low byte
0324    
0325      00BA             Sendl			= Asptl	; BASIC pointer temp low byte
0326      00BB             Sendh			= Aspth	; BASIC pointer temp low byte
0327    
0328      00BC             LAB_IGBY		= $BC		; get next BASIC byte subroutine
0329    
0330      00C2             LAB_GBYT		= $C2		; get current BASIC byte subroutine
0331      00C3             Bpntrl		= $C3		; BASIC execute (get byte) pointer low byte
0332      00C4             Bpntrh		= Bpntrl+1	; BASIC execute (get byte) pointer high byte
0333    
0334    ;			= $D7		; end of get BASIC char subroutine
0335    
0336      00D8             Rbyte4		= $D8		; extra PRNG byte
0337      00D9             Rbyte1		= Rbyte4+1	; most significant PRNG byte
0338      00DA             Rbyte2		= Rbyte4+2	; middle PRNG byte
0339      00DB             Rbyte3		= Rbyte4+3	; least significant PRNG byte
0340    
0341      00DC             NmiBase		= $DC		; NMI handler enabled/setup/triggered flags
0342    					; bit	function
0343    					; ===	========
0344    					; 7	interrupt enabled
0345    					; 6	interrupt setup
0346    					; 5	interrupt happened
0347    ;			= $DD		; NMI handler addr low byte
0348    ;			= $DE		; NMI handler addr high byte
0349      00DF             IrqBase		= $DF		; IRQ handler enabled/setup/triggered flags
0350    ;			= $E0		; IRQ handler addr low byte
0351    ;			= $E1		; IRQ handler addr high byte
0352    
0353    ;			= $DE		; unused
0354    ;			= $DF		; unused
0355    ;			= $E0		; unused
0356    ;			= $E1		; unused
0357    ;			= $E2		; unused
0358    ;			= $E3		; unused
0359    ;			= $E4		; unused
0360    ;			= $E5		; unused
0361    ;			= $E6		; unused
0362    ;			= $E7		; unused
0363    ;			= $E8		; unused
0364    ;			= $E9		; unused
0365    ;			= $EA		; unused
0366    ;			= $EB		; unused
0367    ;			= $EC		; unused
0368    ;			= $ED		; unused
0369    ;			= $EE		; unused
0370    
0371      00EF             Decss			= $EF		; number to decimal string start
0372      00F0             Decssp1		= Decss+1	; number to decimal string start
0373    
0374    ;			= $FF		; decimal string end
0375    
0376    ; token values needed for BASIC
0377    
0378    ; primary command tokens (can start a statement)
0379    
0380      0080             TK_END		= $80			; END token
0381      0081             TK_FOR		= TK_END+1		; FOR token
0382      0082             TK_NEXT		= TK_FOR+1		; NEXT token
0383      0083             TK_DATA		= TK_NEXT+1		; DATA token
0384      0084             TK_INPUT		= TK_DATA+1		; INPUT token
0385      0085             TK_DIM		= TK_INPUT+1	; DIM token
0386      0086             TK_READ		= TK_DIM+1		; READ token
0387      0087             TK_LET		= TK_READ+1		; LET token
0388      0088             TK_DEC		= TK_LET+1		; DEC token
0389      0089             TK_GOTO		= TK_DEC+1		; GOTO token
0390      008A             TK_RUN		= TK_GOTO+1		; RUN token
0391      008B             TK_IF			= TK_RUN+1		; IF token
0392      008C             TK_RESTORE		= TK_IF+1		; RESTORE token
0393      008D             TK_GOSUB		= TK_RESTORE+1	; GOSUB token
0394      008E             TK_RETIRQ		= TK_GOSUB+1	; RETIRQ token
0395      008F             TK_RETNMI		= TK_RETIRQ+1	; RETNMI token
0396      0090             TK_RETURN		= TK_RETNMI+1	; RETURN token
0397      0091             TK_REM		= TK_RETURN+1	; REM token
0398      0092             TK_STOP		= TK_REM+1		; STOP token
0399      0093             TK_ON			= TK_STOP+1		; ON token
0400      0094             TK_NULL		= TK_ON+1		; NULL token
0401      0095             TK_INC		= TK_NULL+1		; INC token
0402      0096             TK_WAIT		= TK_INC+1		; WAIT token
0403      0097             TK_LOAD		= TK_WAIT+1		; LOAD token
0404      0098             TK_SAVE		= TK_LOAD+1		; SAVE token
0405      0099             TK_DEF		= TK_SAVE+1		; DEF token
0406      009A             TK_POKE		= TK_DEF+1		; POKE token
0407      009B             TK_DOKE		= TK_POKE+1		; DOKE token
0408      009C             TK_CALL		= TK_DOKE+1		; CALL token
0409      009D             TK_DO			= TK_CALL+1		; DO token
0410      009E             TK_LOOP		= TK_DO+1		; LOOP token
0411      009F             TK_PRINT		= TK_LOOP+1		; PRINT token
0412      00A0             TK_CONT		= TK_PRINT+1	; CONT token
0413      00A1             TK_LIST		= TK_CONT+1		; LIST token
0414      00A2             TK_CLEAR		= TK_LIST+1		; CLEAR token
0415      00A3             TK_NEW		= TK_CLEAR+1	; NEW token
0416      00A4             TK_WIDTH		= TK_NEW+1		; WIDTH token
0417      00A5             TK_GET		= TK_WIDTH+1	; GET token
0418      00A6             TK_SWAP		= TK_GET+1		; SWAP token
0419      00A7             TK_BITSET		= TK_SWAP+1		; BITSET token
0420      00A8             TK_BITCLR		= TK_BITSET+1	; BITCLR token
0421      00A9             TK_IRQ		= TK_BITCLR+1	; IRQ token
0422      00AA             TK_NMI		= TK_IRQ+1		; NMI token
0423      00AB             TK_SYS          = TK_NMI+1              ; SYS token *** added for SBC-2
0424    
0425    ; secondary command tokens, can't start a statement
0426    
0427      00AC             TK_TAB		= TK_SYS+1		; TAB token
0428      00AD             TK_ELSE		= TK_TAB+1		; ELSE token
0429      00AE             TK_TO			= TK_ELSE+1		; TO token
0430      00AF             TK_FN			= TK_TO+1		; FN token
0431      00B0             TK_SPC		= TK_FN+1		; SPC token
0432      00B1             TK_THEN		= TK_SPC+1		; THEN token
0433      00B2             TK_NOT		= TK_THEN+1		; NOT token
0434      00B3             TK_STEP		= TK_NOT+1		; STEP token
0435      00B4             TK_UNTIL		= TK_STEP+1		; UNTIL token
0436      00B5             TK_WHILE		= TK_UNTIL+1	; WHILE token
0437      00B6             TK_OFF		= TK_WHILE+1	; OFF token
0438    
0439    ; opperator tokens
0440    
0441      00B7             TK_PLUS		= TK_OFF+1		; + token
0442      00B8             TK_MINUS		= TK_PLUS+1		; - token
0443      00B9             TK_MUL		= TK_MINUS+1	; * token
0444      00BA             TK_DIV		= TK_MUL+1		; / token
0445      00BB             TK_POWER		= TK_DIV+1		; ^ token
0446      00BC             TK_AND		= TK_POWER+1	; AND token
0447      00BD             TK_EOR		= TK_AND+1		; EOR token
0448      00BE             TK_OR			= TK_EOR+1		; OR token
0449      00BF             TK_RSHIFT		= TK_OR+1		; RSHIFT token
0450      00C0             TK_LSHIFT		= TK_RSHIFT+1	; LSHIFT token
0451      00C1             TK_GT			= TK_LSHIFT+1	; > token
0452      00C2             TK_EQUAL		= TK_GT+1		; = token
0453      00C3             TK_LT			= TK_EQUAL+1	; < token
0454    
0455    ; functions tokens
0456    
0457      00C4             TK_SGN		= TK_LT+1		; SGN token
0458      00C5             TK_INT		= TK_SGN+1		; INT token
0459      00C6             TK_ABS		= TK_INT+1		; ABS token
0460      00C7             TK_USR		= TK_ABS+1		; USR token
0461      00C8             TK_FRE		= TK_USR+1		; FRE token
0462      00C9             TK_POS		= TK_FRE+1		; POS token
0463      00CA             TK_SQR		= TK_POS+1		; SQR token
0464      00CB             TK_RND		= TK_SQR+1		; RND token
0465      00CC             TK_LOG		= TK_RND+1		; LOG token
0466      00CD             TK_EXP		= TK_LOG+1		; EXP token
0467      00CE             TK_COS		= TK_EXP+1		; COS token
0468      00CF             TK_SIN		= TK_COS+1		; SIN token
0469      00D0             TK_TAN		= TK_SIN+1		; TAN token
0470      00D1             TK_ATN		= TK_TAN+1		; ATN token
0471      00D2             TK_PEEK		= TK_ATN+1		; PEEK token
0472      00D3             TK_DEEK		= TK_PEEK+1		; DEEK token
0473      00D4             TK_SADD		= TK_DEEK+1		; SADD token
0474      00D5             TK_LEN		= TK_SADD+1		; LEN token
0475      00D6             TK_STRS		= TK_LEN+1		; STR$ token
0476      00D7             TK_VAL		= TK_STRS+1		; VAL token
0477      00D8             TK_ASC		= TK_VAL+1		; ASC token
0478      00D9             TK_UCASES		= TK_ASC+1		; UCASE$ token
0479      00DA             TK_LCASES		= TK_UCASES+1	; LCASE$ token
0480      00DB             TK_CHRS		= TK_LCASES+1	; CHR$ token
0481      00DC             TK_HEXS		= TK_CHRS+1		; HEX$ token
0482      00DD             TK_BINS		= TK_HEXS+1		; BIN$ token
0483      00DE             TK_BITTST		= TK_BINS+1		; BITTST token
0484      00DF             TK_MAX		= TK_BITTST+1	; MAX token
0485      00E0             TK_MIN		= TK_MAX+1		; MIN token
0486      00E1             TK_PI			= TK_MIN+1		; PI token
0487      00E2             TK_TWOPI		= TK_PI+1		; TWOPI token
0488      00E3             TK_VPTR		= TK_TWOPI+1	; VARPTR token
0489      00E4             TK_LEFTS		= TK_VPTR+1		; LEFT$ token
0490      00E5             TK_RIGHTS		= TK_LEFTS+1	; RIGHT$ token
0491      00E6             TK_MIDS		= TK_RIGHTS+1	; MID$ token
0492    
0493    ; offsets from a base of X or Y
0494    
0495      0000             PLUS_0		= $00		; X or Y plus 0
0496      0001             PLUS_1		= $01		; X or Y plus 1
0497      0002             PLUS_2		= $02		; X or Y plus 2
0498      0003             PLUS_3		= $03		; X or Y plus 3
0499    
0500      0100             LAB_STAK		= $0100	; stack bottom, no offset
0501    
0502      01FE             LAB_SKFE		= LAB_STAK+$FE
0503    					; flushed stack address
0504      01FF             LAB_SKFF		= LAB_STAK+$FF
0505    					; flushed stack address
0506    
0507      0390             ccflag		= $0390		; BASIC CTRL-C flag, 00 = enabled, 01 = dis
0508      0391             ccbyte		= ccflag+1	; BASIC CTRL-C byte
0509      0392             ccnull		= ccbyte+1	; BASIC CTRL-C byte timeout
0510    
0511      0393             VEC_CC		= ccnull+1	; ctrl c check vector
0512    
0513      0395             VEC_IN		= VEC_CC+2	; input vector
0514      0397             VEC_OUT		= VEC_IN+2	; output vector
0515      0399             VEC_LD		= VEC_OUT+2	; load vector
0516      039B             VEC_SV		= VEC_LD+2	; save vector
0517    
0518    ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
0519    
0520      039D             Ibuffs		= VEC_SV+2      ; ***changed for SBC-2
0521    				; start of input buffer after IRQ/NMI code
0522      03E4             Ibuffe		= Ibuffs+$47; end of input buffer
0523    
0524      0400             Ram_base	= $0400	; start of user RAM (set as needed, should be page aligned)
0525      8000             Ram_top		= $8000	; end of user RAM+1 (set as needed, should be page aligned)
0526    
0527    ; This start can be changed to suit your system
0528    
0529    ;	*=	$C200
0530    
0531    ; BASIC cold start entry point
0532    
0533    ; new page 2 initialisation, copy block to ccflag on
0534    
0535    LAB_COLD
0536    C200  A0 0C        	LDY	#PG2_TABE-PG2_TABS-1
0537    					; byte count-1
0538    LAB_2D13
0539    C202  B9 FA E2     	LDA	PG2_TABS,Y		; get byte
0540    C205  99 90 03     	STA	ccflag,Y		; store in page 2
0541    C208  88           	DEY				; decrement count
0542    C209  10 F7        	BPL	LAB_2D13		; loop if not done
0543    
0544    C20B  A2 FF        	LDX	#$FF			; set byte
0545    C20D  86 88        	STX	Clineh		; set current line high byte (set immediate mode)
0546    C20F  9A           	TXS				; reset stack pointer
0547    
0548    C210  A9 4C        	LDA	#$4C			; code for JMP
0549    C212  85 A1        	STA	Fnxjmp		; save for jump vector for functions
0550    
0551    ; copy block from LAB_2CEE to $00BC - $00D3
0552    
0553    C214  A2 1C        	LDX	#StrTab-LAB_2CEE	; set byte count
0554    LAB_2D4E
0555    C216  BD 06 E3     	LDA	LAB_2CEE-1,X	; get byte from table
0556    C219  95 BB        	STA	LAB_IGBY-1,X	; save byte in page zero
0557    C21B  CA           	DEX				; decrement count
0558    C21C  D0 F8        	BNE	LAB_2D4E		; loop if not all done
0559    
0560    ; copy block from StrTab to $0000 - $0012
0561    
0562    LAB_GMEM
0563    C21E  A2 12        	LDX	#EndTab-StrTab-1	; set byte count-1
0564    TabLoop
0565    C220  BD 23 E3     	LDA	StrTab,X		; get byte from table
0566    C223  95 00        	STA	PLUS_0,X		; save byte in page zero
0567    C225  CA           	DEX				; decrement count
0568    C226  10 F8        	BPL	TabLoop		; loop if not all done
0569    
0570    ; set-up start values
0571    
0572    C228  A9 00        	LDA	#$00			; clear A
0573    C22A  85 DC        	STA	NmiBase		; clear NMI handler enabled flag
0574    C22C  85 DF        	STA	IrqBase		; clear IRQ handler enabled flag
0575    C22E  85 B2        	STA	FAC1_o		; clear FAC1 overflow byte
0576    C230  85 67        	STA	last_sh		; clear descriptor stack top item pointer high byte
0577    
0578    C232  A9 0E        	LDA	#$0E			; set default tab size
0579    C234  85 64        	STA	TabSiz		; save it
0580    C236  A9 03        	LDA	#$03			; set garbage collect step size for descriptor stack
0581    C238  85 A0        	STA	g_step		; save it
0582    C23A  A2 68        	LDX	#des_sk		; descriptor stack start
0583    C23C  86 65        	STX	next_s		; set descriptor stack pointer
0584    C23E  20 96 CA     	JSR	LAB_CRLF		; print CR/LF
0585    C241  A9 36        	LDA	#<LAB_MSZM		; point to memory size message (low addr)
0586    C243  A0 E3        	LDY	#>LAB_MSZM		; point to memory size message (high addr)
0587    C245  20 D7 CA     	JSR	LAB_18C3		; print null terminated string from memory
0588    C248  20 44 C4     	JSR	LAB_INLN		; print "? " and get BASIC input
0589    C24B  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
0590    C24D  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
0591    C24F  20 C2 00     	JSR	LAB_GBYT		; get last byte back
0592    
0593    C252  D0 23        	BNE	LAB_2DAA		; branch if not null (user typed something)
0594    
0595    C254  A0 00        	LDY	#$00			; else clear Y
0596    					; character was null so get memory size the hard way
0597    					; we get here with Y=0 and Itempl/h = Ram_base
0598    LAB_2D93
0599    C256  E6 11        	INC	Itempl		; increment temporary integer low byte
0600    C258  D0 08        	BNE	LAB_2D99		; branch if no overflow
0601    
0602    C25A  E6 12        	INC	Itemph		; increment temporary integer high byte
0603    C25C  A5 12        	LDA	Itemph		; get high byte
0604    C25E  C9 80        	CMP	#>Ram_top		; compare with top of RAM+1
0605    C260  F0 21        	BEQ	LAB_2DB6		; branch if match (end of user RAM)
0606    
0607    LAB_2D99
0608    C262  A9 55        	LDA	#$55			; set test byte
0609    C264  91 11        	STA	(Itempl),Y		; save via temporary integer
0610    C266  A2 4C        	ldx	#$4C			; patch to fix mirrored RAM from being counted
0611    C268  86 00                stx     $00			; Forces failure on a wrap to address $0000
0612    C26A  D1 11        	CMP	(Itempl),Y		; compare via temporary integer
0613    C26C  D0 15        	BNE	LAB_2DB6		; branch if fail
0614    
0615    C26E  0A           	ASL				; shift test byte left (now $AA)
0616    C26F  91 11        	STA	(Itempl),Y		; save via temporary integer
0617    C271  D1 11        	CMP	(Itempl),Y		; compare via temporary integer
0618    C273  F0 E1        	BEQ	LAB_2D93		; if ok go do next byte
0619    
0620    C275  D0 0C        	BNE	LAB_2DB6		; branch if fail
0621    
0622    LAB_2DAA
0623    C277  20 AA DB     	JSR	LAB_2887		; get FAC1 from string
0624    C27A  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0625    C27C  C9 98        	CMP	#$98			; compare with exponent = 2^24
0626    C27E  B0 9E        	BCS	LAB_GMEM		; if too large go try again
0627    
0628    C280  20 FB D6     	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
0629    					; (no range check)
0630    
0631    LAB_2DB6
0632    C283  A5 11        	LDA	Itempl		; get temporary integer low byte
0633    C285  A4 12        	LDY	Itemph		; get temporary integer high byte
0634    C287  C0 01        	CPY	#<Ram_base+1	; compare with start of RAM+$100 high byte
0635    C289  90 93        	BCC	LAB_GMEM		; if too small go try again
0636    
0637    
0638    ; uncomment these lines if you want to check on the high limit of memory. Note if
0639    ; Ram_top is set too low then this will fail. default is ignore it and assume the
0640    ; users know what they"re doing!
0641    
0642    ;	CPY	#>Ram_top		; compare with top of RAM high byte
0643    ;	BCC	MEM_OK		; branch if < RAM top
0644    
0645    ;	BNE	LAB_GMEM		; if too large go try again
0646    					; else was = so compare low bytes
0647    ;	CMP	#<Ram_top		; compare with top of RAM low byte
0648    ;	BEQ	MEM_OK		; branch if = RAM top
0649    
0650    ;	BCS	LAB_GMEM		; if too large go try again
0651    
0652    ;MEM_OK
0653    C28B  85 85        	STA	Ememl			; set end of mem low byte
0654    C28D  84 86        	STY	Ememh			; set end of mem high byte
0655    C28F  85 81        	STA	Sstorl		; set bottom of string space low byte
0656    C291  84 82        	STY	Sstorh		; set bottom of string space high byte
0657    
0658    C293  A0 00        	LDY	#<Ram_base		; set start addr low byte
0659    C295  A2 04        	LDX	#>Ram_base		; set start addr high byte
0660    C297  84 79        	STY	Smeml			; save start of mem low byte
0661    C299  86 7A        	STX	Smemh			; save start of mem high byte
0662    
0663    ; this line is only needed if Ram_base is not $xx00
0664    
0665    ;	LDY	#$00			; clear Y
0666    C29B  98           	TYA				; clear A
0667    C29C  91 79        	STA	(Smeml),Y		; clear first byte
0668    C29E  E6 79        	INC	Smeml			; increment start of mem low byte
0669    
0670    ; these two lines are only needed if Ram_base is $xxFF
0671    
0672    ;	BNE	LAB_2E05		; branch if no rollover
0673    
0674    ;	INC	Smemh			; increment start of mem high byte
0675    LAB_2E05
0676    C2A0  20 96 CA     	JSR	LAB_CRLF		; print CR/LF
0677    C2A3  20 54 C5     	JSR	LAB_1463		; do "NEW" and "CLEAR"
0678    C2A6  A5 85        	LDA	Ememl			; get end of mem low byte
0679    C2A8  38           	SEC				; set carry for subtract
0680    C2A9  E5 79        	SBC	Smeml			; subtract start of mem low byte
0681    C2AB  AA           	TAX				; copy to X
0682    C2AC  A5 86        	LDA	Ememh			; get end of mem high byte
0683    C2AE  E5 7A        	SBC	Smemh			; subtract start of mem high byte
0684    C2B0  20 86 DC     	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
0685    C2B3  A9 45        	LDA	#<LAB_SMSG		; point to sign-on message (low addr)
0686    C2B5  A0 E3        	LDY	#>LAB_SMSG		; point to sign-on message (high addr)
0687    C2B7  20 D7 CA     	JSR	LAB_18C3		; print null terminated string from memory
0688    C2BA  A9 5E        	LDA	#<LAB_1274		; warm start vector low byte
0689    C2BC  A0 C3        	LDY	#>LAB_1274		; warm start vector high byte
0690    C2BE  85 01        	STA	Wrmjpl		; save warm start vector low byte
0691    C2C0  84 02        	STY	Wrmjph		; save warm start vector high byte
0692    C2C2  6C 01 00     	JMP	(Wrmjpl)		; go do warm start
0693    
0694    ; open up space in memory
0695    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
0696    
0697    ; Nbendl,Nbendh - new block end address (A/Y)
0698    ; Obendl,Obendh - old block end address
0699    ; Ostrtl,Ostrth - old block start address
0700    
0701    ; returns with ..
0702    
0703    ; Nbendl,Nbendh - new block start address (high byte - $100)
0704    ; Obendl,Obendh - old block start address (high byte - $100)
0705    ; Ostrtl,Ostrth - old block start address (unchanged)
0706    
0707    LAB_11CF
0708    C2C5  20 0F C3     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
0709    					; addr to check is in AY (low/high)
0710    C2C8  85 7F        	STA	Earryl		; save new array mem end low byte
0711    C2CA  84 80        	STY	Earryh		; save new array mem end high byte
0712    
0713    ; open up space in memory
0714    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
0715    ; don't set array end
0716    
0717    LAB_11D6
0718    C2CC  38           	SEC				; set carry for subtract
0719    C2CD  A5 A6        	LDA	Obendl		; get block end low byte
0720    C2CF  E5 AA        	SBC	Ostrtl		; subtract block start low byte
0721    C2D1  A8           	TAY				; copy MOD(block length/$100) byte to Y
0722    C2D2  A5 A7        	LDA	Obendh		; get block end high byte
0723    C2D4  E5 AB        	SBC	Ostrth		; subtract block start high byte
0724    C2D6  AA           	TAX				; copy block length high byte to X
0725    C2D7  E8           	INX				; +1 to allow for count=0 exit
0726    C2D8  98           	TYA				; copy block length low byte to A
0727    C2D9  F0 24        	BEQ	LAB_120A		; branch if length low byte=0
0728    
0729    					; block is (X-1)*256+Y bytes, do the Y bytes first
0730    
0731    C2DB  38           	SEC				; set carry for add + 1, two's complement
0732    C2DC  49 FF        	EOR	#$FF			; invert low byte for subtract
0733    C2DE  65 A6        	ADC	Obendl		; add block end low byte
0734    
0735    C2E0  85 A6        	STA	Obendl		; save corrected old block end low byte
0736    C2E2  B0 03        	BCS	LAB_11F3		; branch if no underflow
0737    
0738    C2E4  C6 A7        	DEC	Obendh		; else decrement block end high byte
0739    C2E6  38           	SEC				; set carry for add + 1, two's complement
0740    LAB_11F3
0741    C2E7  98           	TYA				; get MOD(block length/$100) byte
0742    C2E8  49 FF        	EOR	#$FF			; invert low byte for subtract
0743    C2EA  65 A4        	ADC	Nbendl		; add destination end low byte
0744    C2EC  85 A4        	STA	Nbendl		; save modified new block end low byte
0745    C2EE  B0 08        	BCS	LAB_1203		; branch if no underflow
0746    
0747    C2F0  C6 A5        	DEC	Nbendh		; else decrement block end high byte
0748    C2F2  90 04        	BCC	LAB_1203		; branch always
0749    
0750    LAB_11FF
0751    C2F4  B1 A6        	LDA	(Obendl),Y		; get byte from source
0752    C2F6  91 A4        	STA	(Nbendl),Y		; copy byte to destination
0753    LAB_1203
0754    C2F8  88           	DEY				; decrement index
0755    C2F9  D0 F9        	BNE	LAB_11FF		; loop until Y=0
0756    
0757    					; now do Y=0 indexed byte
0758    C2FB  B1 A6        	LDA	(Obendl),Y		; get byte from source
0759    C2FD  91 A4        	STA	(Nbendl),Y		; save byte to destination
0760    LAB_120A
0761    C2FF  C6 A7        	DEC	Obendh		; decrement source pointer high byte
0762    C301  C6 A5        	DEC	Nbendh		; decrement destination pointer high byte
0763    C303  CA           	DEX				; decrement block count
0764    C304  D0 F2        	BNE	LAB_1203		; loop until count = $0
0765    
0766    C306  60           	RTS
0767    
0768    ; check room on stack for A bytes
0769    ; stack too deep? do OM error
0770    
0771    LAB_1212
0772    C307  85 78        	STA	TempB			; save result in temp byte
0773    C309  BA           	TSX				; copy stack
0774    C30A  E4 78        	CPX	TempB			; compare new "limit" with stack
0775    C30C  90 30        	BCC	LAB_OMER		; if stack < limit do "Out of memory" error then warm start
0776    
0777    C30E  60           	RTS
0778    
0779    ; check available memory, "Out of memory" error if no room
0780    ; addr to check is in AY (low/high)
0781    
0782    LAB_121F
0783    C30F  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
0784    C311  90 2A        	BCC	LAB_124B		; if less then exit (is ok)
0785    
0786    C313  D0 04        	BNE	LAB_1229		; skip next test if greater (tested <)
0787    
0788    					; high byte was =, now do low byte
0789    C315  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
0790    C317  90 24        	BCC	LAB_124B		; if less then exit (is ok)
0791    
0792    					; addr is > string storage ptr (oops!)
0793    LAB_1229
0794    C319  48           	PHA				; push addr low byte
0795    C31A  A2 08        	LDX	#$08			; set index to save Adatal to expneg inclusive
0796    C31C  98           	TYA				; copy addr high byte (to push on stack)
0797    
0798    					; save misc numeric work area
0799    LAB_122D
0800    C31D  48           	PHA				; push byte
0801    C31E  B5 A3        	LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
0802    C320  CA           	DEX				; decrement index
0803    C321  10 FA        	BPL	LAB_122D		; loop until all done
0804    
0805    C323  20 E3 D3     	JSR	LAB_GARB		; garbage collection routine
0806    
0807    					; restore misc numeric work area
0808    C326  A2 00        	LDX	#$00			; clear the index to restore bytes
0809    LAB_1238
0810    C328  68           	PLA				; pop byte
0811    C329  95 A4        	STA	Adatal,X		; save byte to Adatal to expneg
0812    C32B  E8           	INX				; increment index
0813    C32C  E0 08        	CPX	#$08			; compare with end + 1
0814    C32E  30 F8        	BMI	LAB_1238		; loop if more to do
0815    
0816    C330  68           	PLA				; pop addr high byte
0817    C331  A8           	TAY				; copy back to Y
0818    C332  68           	PLA				; pop addr low byte
0819    C333  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
0820    C335  90 06        	BCC	LAB_124B		; if less then exit (is ok)
0821    
0822    C337  D0 05        	BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
0823    
0824    					; high byte was =, now do low byte
0825    C339  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
0826    C33B  B0 01        	BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
0827    
0828    					; ok exit, carry clear
0829    LAB_124B
0830    C33D  60           	RTS
0831    
0832    ; do "Out of memory" error then warm start
0833    
0834    LAB_OMER
0835    C33E  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
0836    
0837    ; do error #X, then warm start
0838    
0839    LAB_XERR
0840    C340  20 96 CA     	JSR	LAB_CRLF		; print CR/LF
0841    
0842    C343  BD BE E8     	LDA	LAB_BAER,X		; get error message pointer low byte
0843    C346  BC BF E8     	LDY	LAB_BAER+1,X	; get error message pointer high byte
0844    C349  20 D7 CA     	JSR	LAB_18C3		; print null terminated string from memory
0845    
0846    C34C  20 8D C5     	JSR	LAB_1491		; flush stack and clear continue flag
0847    C34F  A9 FB        	LDA	#<LAB_EMSG		; point to " Error" low addr
0848    C351  A0 E9        	LDY	#>LAB_EMSG		; point to " Error" high addr
0849    LAB_1269
0850    C353  20 D7 CA     	JSR	LAB_18C3		; print null terminated string from memory
0851    C356  A4 88        	LDY	Clineh		; get current line high byte
0852    C358  C8           	INY				; increment it
0853    C359  F0 03        	BEQ	LAB_1274		; go do warm start (was immediate mode)
0854    
0855    					; else print line number
0856    C35B  20 7B DC     	JSR	LAB_2953		; print " in line [LINE #]"
0857    
0858    ; BASIC warm start entry point
0859    ; wait for Basic command
0860    
0861    LAB_1274
0862    					; clear ON IRQ/NMI bytes
0863    C35E  A9 00        	LDA	#$00			; clear A
0864    C360  85 DF        	STA	IrqBase		; clear enabled byte
0865    C362  85 DC        	STA	NmiBase		; clear enabled byte
0866    C364  A9 0C        	LDA	#<LAB_RMSG		; point to "Ready" message low byte
0867    C366  A0 EA        	LDY	#>LAB_RMSG		; point to "Ready" message high byte
0868    
0869    C368  20 D7 CA     	JSR	LAB_18C3		; go do print string
0870    
0871    ; wait for Basic command (no "Ready")
0872    
0873    LAB_127D
0874    C36B  20 51 C4     	JSR	LAB_1357		; call for BASIC input
0875    LAB_1280
0876    C36E  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
0877    C370  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
0878    C372  20 C2 00     	JSR	LAB_GBYT		; scan memory
0879    C375  F0 F4        	BEQ	LAB_127D		; loop while null
0880    
0881    ; got to interpret input line now ..
0882    
0883    C377  A2 FF        	LDX	#$FF			; current line to null value
0884    C379  86 88        	STX	Clineh		; set current line high byte
0885    C37B  90 06        	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
0886    
0887    					; no line number .. immediate mode
0888    C37D  20 82 C4     	JSR	LAB_13A6		; crunch keywords into Basic tokens
0889    C380  4C F7 C6     	JMP	LAB_15F6		; go scan and interpret code
0890    
0891    ; handle new BASIC line
0892    
0893    LAB_1295
0894    C383  20 59 C9     	JSR	LAB_GFPN		; get fixed-point number into temp integer
0895    C386  20 82 C4     	JSR	LAB_13A6		; crunch keywords into Basic tokens
0896    C389  84 5D        	STY	Ibptr			; save index pointer to end of crunched line
0897    C38B  20 28 C5     	JSR	LAB_SSLN		; search BASIC for temp integer line number
0898    C38E  90 44        	BCC	LAB_12E6		; branch if not found
0899    
0900    					; aroooogah! line # already exists! delete it
0901    C390  A0 01        	LDY	#$01			; set index to next line pointer high byte
0902    C392  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
0903    C394  85 72        	STA	ut1_ph		; save it
0904    C396  A5 7B        	LDA	Svarl			; get start of vars low byte
0905    C398  85 71        	STA	ut1_pl		; save it
0906    C39A  A5 AB        	LDA	Baslnh		; get found line pointer high byte
0907    C39C  85 74        	STA	ut2_ph		; save it
0908    C39E  A5 AA        	LDA	Baslnl		; get found line pointer low byte
0909    C3A0  88           	DEY				; decrement index
0910    C3A1  F1 AA        	SBC	(Baslnl),Y		; subtract next line pointer low byte
0911    C3A3  18           	CLC				; clear carry for add
0912    C3A4  65 7B        	ADC	Svarl			; add start of vars low byte
0913    C3A6  85 7B        	STA	Svarl			; save new start of vars low byte
0914    C3A8  85 73        	STA	ut2_pl		; save destination pointer low byte
0915    C3AA  A5 7C        	LDA	Svarh			; get start of vars high byte
0916    C3AC  69 FF        	ADC	#$FF			; -1 + carry
0917    C3AE  85 7C        	STA	Svarh			; save start of vars high byte
0918    C3B0  E5 AB        	SBC	Baslnh		; subtract found line pointer high byte
0919    C3B2  AA           	TAX				; copy to block count
0920    C3B3  38           	SEC				; set carry for subtract
0921    C3B4  A5 AA        	LDA	Baslnl		; get found line pointer low byte
0922    C3B6  E5 7B        	SBC	Svarl			; subtract start of vars low byte
0923    C3B8  A8           	TAY				; copy to bytes in first block count
0924    C3B9  B0 03        	BCS	LAB_12D0		; branch if overflow
0925    
0926    C3BB  E8           	INX				; increment block count (correct for =0 loop exit)
0927    C3BC  C6 74        	DEC	ut2_ph		; decrement destination high byte
0928    LAB_12D0
0929    C3BE  18           	CLC				; clear carry for add
0930    C3BF  65 71        	ADC	ut1_pl		; add source pointer low byte
0931    C3C1  90 03        	BCC	LAB_12D8		; branch if no overflow
0932    
0933    C3C3  C6 72        	DEC	ut1_ph		; else decrement source pointer high byte
0934    C3C5  18           	CLC				; clear carry
0935    
0936    					; close up memory to delete old line
0937    LAB_12D8
0938    C3C6  B1 71        	LDA	(ut1_pl),Y		; get byte from source
0939    C3C8  91 73        	STA	(ut2_pl),Y		; copy to destination
0940    C3CA  C8           	INY				; increment index
0941    C3CB  D0 F9        	BNE	LAB_12D8		; while <> 0 do this block
0942    
0943    C3CD  E6 72        	INC	ut1_ph		; increment source pointer high byte
0944    C3CF  E6 74        	INC	ut2_ph		; increment destination pointer high byte
0945    C3D1  CA           	DEX				; decrement block count
0946    C3D2  D0 F2        	BNE	LAB_12D8		; loop until all done
0947    
0948    					; got new line in buffer and no existing same #
0949    LAB_12E6
0950    C3D4  AD 9D 03     	LDA	Ibuffs		; get byte from start of input buffer
0951    C3D7  F0 3F        	BEQ	LAB_1319		; if null line just go flush stack/vars and exit
0952    
0953    					; got new line and it isn't empty line
0954    C3D9  A5 85        	LDA	Ememl			; get end of mem low byte
0955    C3DB  A4 86        	LDY	Ememh			; get end of mem high byte
0956    C3DD  85 81        	STA	Sstorl		; set bottom of string space low byte
0957    C3DF  84 82        	STY	Sstorh		; set bottom of string space high byte
0958    C3E1  A5 7B        	LDA	Svarl			; get start of vars low byte	(end of BASIC)
0959    C3E3  85 A6        	STA	Obendl		; save old block end low byte
0960    C3E5  A4 7C        	LDY	Svarh			; get start of vars high byte	(end of BASIC)
0961    C3E7  84 A7        	STY	Obendh		; save old block end high byte
0962    C3E9  65 5D        	ADC	Ibptr			; add input buffer pointer	(also buffer length)
0963    C3EB  90 01        	BCC	LAB_1301		; branch if no overflow from add
0964    
0965    C3ED  C8           	INY				; else increment high byte
0966    LAB_1301
0967    C3EE  85 A4        	STA	Nbendl		; save new block end low byte	(move to, low byte)
0968    C3F0  84 A5        	STY	Nbendh		; save new block end high byte
0969    C3F2  20 C5 C2     	JSR	LAB_11CF		; open up space in memory
0970    					; old start pointer Ostrtl,Ostrth set by the find line call
0971    C3F5  A5 7F        	LDA	Earryl		; get array mem end low byte
0972    C3F7  A4 80        	LDY	Earryh		; get array mem end high byte
0973    C3F9  85 7B        	STA	Svarl			; save start of vars low byte
0974    C3FB  84 7C        	STY	Svarh			; save start of vars high byte
0975    C3FD  A4 5D        	LDY	Ibptr			; get input buffer pointer	(also buffer length)
0976    C3FF  88           	DEY				; adjust for loop type
0977    LAB_1311
0978    C400  B9 99 03     	LDA	Ibuffs-4,Y		; get byte from crunched line
0979    C403  91 AA        	STA	(Baslnl),Y		; save it to program memory
0980    C405  88           	DEY				; decrement count
0981    C406  C0 03        	CPY	#$03			; compare with first byte-1
0982    C408  D0 F6        	BNE	LAB_1311		; continue while count <> 3
0983    
0984    C40A  A5 12        	LDA	Itemph		; get line # high byte
0985    C40C  91 AA        	STA	(Baslnl),Y		; save it to program memory
0986    C40E  88           	DEY				; decrement count
0987    C40F  A5 11        	LDA	Itempl		; get line # low byte
0988    C411  91 AA        	STA	(Baslnl),Y		; save it to program memory
0989    C413  88           	DEY				; decrement count
0990    C414  A9 FF        	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
0991    					; byte then a zero already here would stop the chain rebuild
0992    					; as it would think it was the [EOT] marker.
0993    C416  91 AA        	STA	(Baslnl),Y		; save it to program memory
0994    
0995    LAB_1319
0996    C418  20 69 C5     	JSR	LAB_1477		; reset execution to start, clear vars and flush stack
0997    C41B  A6 79        	LDX	Smeml			; get start of mem low byte
0998    C41D  A5 7A        	LDA	Smemh			; get start of mem high byte
0999    C41F  A0 01        	LDY	#$01			; index to high byte of next line pointer
1000    LAB_1325
1001    C421  86 71        	STX	ut1_pl		; set line start pointer low byte
1002    C423  85 72        	STA	ut1_ph		; set line start pointer high byte
1003    C425  B1 71        	LDA	(ut1_pl),Y		; get it
1004    C427  F0 18        	BEQ	LAB_133E		; exit if end of program
1005    
1006    ; rebuild chaining of Basic lines
1007    
1008    C429  A0 04        	LDY	#$04			; point to first code byte of line
1009    					; there is always 1 byte + [EOL] as null entries are deleted
1010    LAB_1330
1011    C42B  C8           	INY				; next code byte
1012    C42C  B1 71        	LDA	(ut1_pl),Y		; get byte
1013    C42E  D0 FB        	BNE	LAB_1330		; loop if not [EOL]
1014    
1015    C430  38           	SEC				; set carry for add + 1
1016    C431  98           	TYA				; copy end index
1017    C432  65 71        	ADC	ut1_pl		; add to line start pointer low byte
1018    C434  AA           	TAX				; copy to X
1019    C435  A0 00        	LDY	#$00			; clear index, point to this line's next line pointer
1020    C437  91 71        	STA	(ut1_pl),Y		; set next line pointer low byte
1021    C439  98           	TYA				; clear A
1022    C43A  65 72        	ADC	ut1_ph		; add line start pointer high byte + carry
1023    C43C  C8           	INY				; increment index to high byte
1024    C43D  91 71        	STA	(ut1_pl),Y		; save next line pointer low byte
1025    C43F  90 E0        	BCC	LAB_1325		; go do next line, branch always, carry clear
1026    
1027    
1028    LAB_133E
1029    C441  4C 6B C3     	JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
1030    
1031    ; print "? " and get BASIC input
1032    
1033    LAB_INLN
1034    C444  20 EF CA     	JSR	LAB_18E3		; print "?" character
1035    C447  20 EC CA     	JSR	LAB_18E0		; print " "
1036    C44A  D0 05        	BNE	LAB_1357		; call for BASIC input and return
1037    
1038    ; receive line from keyboard
1039    
1040    					; $08 as delete key (BACKSPACE on standard keyboard)
1041    LAB_134B
1042    C44C  20 F1 CA     	JSR	LAB_PRNA		; go print the character
1043    C44F  CA           	DEX				; decrement the buffer counter (delete)
1044    	.byte	$2C			; make LDX into BIT abs
1045    
1046    ; call for BASIC input (main entry point)
1047    
1048    LAB_1357
1049    C451  A2 00        	LDX	#$00			; clear BASIC line buffer pointer
1050    LAB_1359
1051    C453  20 EE E2     	JSR	V_INPT		; call scan input device
1052    C456  90 FB        	BCC	LAB_1359		; loop if no byte
1053    
1054    C458  F0 F9        	BEQ	LAB_1359		; loop until valid input (ignore NULLs)
1055    
1056    C45A  C9 07        	CMP	#$07			; compare with [BELL]
1057    C45C  F0 10        	BEQ	LAB_1378		; branch if [BELL]
1058    
1059    C45E  C9 0D        	CMP	#$0D			; compare with [CR]
1060    C460  F0 19        	BEQ	LAB_1384		; do CR/LF exit if [CR]
1061    
1062    C462  E0 00        	CPX	#$00			; compare pointer with $00
1063    C464  D0 04        	BNE	LAB_1374		; branch if not empty
1064    
1065    ; next two lines ignore any non print character and [SPACE] if input buffer empty
1066    
1067    C466  C9 21        	CMP	#$21			; compare with [SP]+1
1068    C468  90 E9        	BCC	LAB_1359		; if < ignore character
1069    
1070    LAB_1374
1071    C46A  C9 08        	CMP	#$08			; compare with [BACKSPACE] (delete last character)
1072    C46C  F0 DE        	BEQ	LAB_134B		; go delete last character
1073    
1074    LAB_1378
1075    C46E  E0 47        	CPX	#Ibuffe-Ibuffs	; compare character count with max
1076    C470  B0 0C        	BCS	LAB_138E		; skip store and do [BELL] if buffer full
1077    
1078    C472  9D 9D 03     	STA	Ibuffs,X		; else store in buffer
1079    C475  E8           	INX				; increment pointer
1080    LAB_137F
1081    C476  20 F1 CA     	JSR	LAB_PRNA		; go print the character
1082    C479  D0 D8        	BNE	LAB_1359		; always loop for next character
1083    
1084    LAB_1384
1085    C47B  4C 8D CA     	JMP	LAB_1866		; do CR/LF exit to BASIC
1086    
1087    ; announce buffer full
1088    
1089    LAB_138E
1090    C47E  A9 07        	LDA	#$07			; [BELL] character into A
1091    C480  D0 F4        	BNE	LAB_137F		; go print the [BELL] but ignore input character
1092    					; branch always
1093    
1094    ; crunch keywords into Basic tokens
1095    ; position independent buffer version ..
1096    ; faster, dictionary search version ....
1097    
1098    LAB_13A6
1099    C482  A0 FF        	LDY	#$FF			; set save index (makes for easy math later)
1100    
1101    C484  38           	SEC				; set carry for subtract
1102    C485  A5 C3        	LDA	Bpntrl		; get basic execute pointer low byte
1103    C487  E9 9D        	SBC	#<Ibuffs		; subtract input buffer start pointer
1104    C489  AA           	TAX				; copy result to X (index past line # if any)
1105    
1106    C48A  86 60        	STX	Oquote		; clear open quote/DATA flag
1107    LAB_13AC
1108    C48C  BD 9D 03     	LDA	Ibuffs,X		; get byte from input buffer
1109    C48F  F0 51        	BEQ	LAB_13EC		; if null save byte then exit
1110    
1111    C491  C9 5F        	CMP	#'_'			; compare with "_"
1112    C493  B0 4D        	BCS	LAB_13EC		; if >= go save byte then continue crunching
1113    
1114    C495  C9 3C        	CMP	#'<'			; compare with "<"
1115    C497  B0 0E        	BCS	LAB_13CC		; if >= go crunch now
1116    
1117    C499  C9 30        	CMP	#'0'			; compare with "0"
1118    C49B  B0 45        	BCS	LAB_13EC		; if >= go save byte then continue crunching
1119    
1120    C49D  85 5C        	STA	Scnquo		; save buffer byte as search character
1121    C49F  C9 22        	CMP	#$22			; is it quote character?
1122    C4A1  F0 61        	BEQ	LAB_1410		; branch if so (copy quoted string)
1123    
1124    C4A3  C9 2A        	CMP	#'*'			; compare with "*"
1125    C4A5  90 3B        	BCC	LAB_13EC		; if < go save byte then continue crunching
1126    
1127    					; else crunch now
1128    LAB_13CC
1129    C4A7  24 60        	BIT	Oquote		; get open quote/DATA token flag
1130    C4A9  70 37        	BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
1131    					; go save byte then continue crunching
1132    
1133    C4AB  86 78        	STX	TempB			; save buffer read index
1134    C4AD  84 BA        	STY	csidx			; copy buffer save index
1135    C4AF  A0 1E        	LDY	#<TAB_1STC		; get keyword first character table low address
1136    C4B1  84 73        	STY	ut2_pl		; save pointer low byte
1137    C4B3  A0 E5        	LDY	#>TAB_1STC		; get keyword first character table high address
1138    C4B5  84 74        	STY	ut2_ph		; save pointer high byte
1139    C4B7  A0 00        	LDY	#$00			; clear table pointer
1140    
1141    LAB_13D0
1142    C4B9  D1 73        	CMP	(ut2_pl),Y		; compare with keyword first character table byte
1143    C4BB  F0 05        	BEQ	LAB_13D1		; go do word_table_chr if match
1144    
1145    C4BD  90 21        	BCC	LAB_13EA		; if < keyword first character table byte go restore
1146    					; Y and save to crunched
1147    
1148    C4BF  C8           	INY				; else increment pointer
1149    C4C0  D0 F7        	BNE	LAB_13D0		; and loop (branch always)
1150    
1151    ; have matched first character of some keyword
1152    
1153    LAB_13D1
1154    C4C2  98           	TYA				; copy matching index
1155    C4C3  0A           	ASL				; *2 (bytes per pointer)
1156    C4C4  AA           	TAX				; copy to new index
1157    C4C5  BD 3C E5     	LDA	TAB_CHRT,X		; get keyword table pointer low byte
1158    C4C8  85 73        	STA	ut2_pl		; save pointer low byte
1159    C4CA  BD 3D E5     	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
1160    C4CD  85 74        	STA	ut2_ph		; save pointer high byte
1161    
1162    C4CF  A0 FF        	LDY	#$FF			; clear table pointer (make -1 for start)
1163    
1164    C4D1  A6 78        	LDX	TempB			; restore buffer read index
1165    
1166    LAB_13D6
1167    C4D3  C8           	INY				; next table byte
1168    C4D4  B1 73        	LDA	(ut2_pl),Y		; get byte from table
1169    LAB_13D8
1170    C4D6  30 08        	BMI	LAB_13EA		; all bytes matched so go save token
1171    
1172    C4D8  E8           	INX				; next buffer byte
1173    C4D9  DD 9D 03     	CMP	Ibuffs,X		; compare with byte from input buffer
1174    C4DC  F0 F5        	BEQ	LAB_13D6		; go compare next if match
1175    
1176    C4DE  D0 2B        	BNE	LAB_1417		; branch if >< (not found keyword)
1177    
1178    LAB_13EA
1179    C4E0  A4 BA        	LDY	csidx			; restore save index
1180    
1181    					; save crunched to output
1182    LAB_13EC
1183    C4E2  E8           	INX				; increment buffer index (to next input byte)
1184    C4E3  C8           	INY				; increment save index (to next output byte)
1185    C4E4  99 9D 03     	STA	Ibuffs,Y		; save byte to output
1186    C4E7  C9 00        	CMP	#$00			; set the flags, set carry
1187    C4E9  F0 32        	BEQ	LAB_142A		; do exit if was null [EOL]
1188    
1189    					; A holds token or byte here
1190    C4EB  E9 3A        	SBC	#':'			; subtract ":" (carry set by CMP #00)
1191    C4ED  F0 04        	BEQ	LAB_13FF		; branch if it was ":" (is now $00)
1192    
1193    					; A now holds token-$3A
1194    C4EF  C9 49        	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
1195    C4F1  D0 02        	BNE	LAB_1401		; branch if not DATA
1196    
1197    					; token was : or DATA
1198    LAB_13FF
1199    C4F3  85 60        	STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
1200    LAB_1401
1201    C4F5  49 57        	EOR	#TK_REM-$3A		; effectively subtract REM token offset
1202    C4F7  D0 93        	BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
1203    
1204    C4F9  85 5C        	STA	Asrch			; else was REM so set search for [EOL]
1205    
1206    					; loop for REM, "..." etc.
1207    LAB_1408
1208    C4FB  BD 9D 03     	LDA	Ibuffs,X		; get byte from input buffer
1209    C4FE  F0 E2        	BEQ	LAB_13EC		; branch if null [EOL]
1210    
1211    C500  C5 5C        	CMP	Asrch			; compare with stored character
1212    C502  F0 DE        	BEQ	LAB_13EC		; branch if match (end quote)
1213    
1214    					; entry for copy string in quotes, don't crunch
1215    LAB_1410
1216    C504  C8           	INY				; increment buffer save index
1217    C505  99 9D 03     	STA	Ibuffs,Y		; save byte to output
1218    C508  E8           	INX				; increment buffer read index
1219    C509  D0 F0        	BNE	LAB_1408		; loop while <> 0 (should never be 0!)
1220    
1221    					; not found keyword this go
1222    LAB_1417
1223    C50B  A6 78        	LDX	TempB			; compare has failed, restore buffer index (start byte!)
1224    
1225    					; now find the end of this word in the table
1226    LAB_141B
1227    C50D  B1 73        	LDA	(ut2_pl),Y		; get table byte
1228    C50F  08           	PHP				; save status
1229    C510  C8           	INY				; increment table index
1230    C511  28           	PLP				; restore byte status
1231    C512  10 F9        	BPL	LAB_141B		; if not end of keyword go do next
1232    
1233    C514  B1 73        	LDA	(ut2_pl),Y		; get byte from keyword table
1234    C516  D0 BE        	BNE	LAB_13D8		; go test next word if not zero byte (end of table)
1235    
1236    					; reached end of table with no match
1237    C518  BD 9D 03     	LDA	Ibuffs,X		; restore byte from input buffer
1238    C51B  10 C3        	BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
1239    					; go save byte in output and continue crunching
1240    
1241    					; reached [EOL]
1242    LAB_142A
1243    C51D  C8           	INY				; increment pointer
1244    C51E  C8           	INY				; increment pointer (makes it next line pointer high byte)
1245    C51F  99 9D 03     	STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
1246    C522  C8           	INY				; adjust for line copy
1247    C523  C8           	INY				; adjust for line copy
1248    C524  C8           	INY				; adjust for line copy
1249    ; add patch for when Ibuffs = $xx00 - Daryl Rictor
1250    ;	lda  Bpntrl			; text for $00
1251    ;	BNE  LAB_142P		; not $00
1252    ;	DEC	Bpntrh		; allow for increment when $xx00
1253    ;LAB_142P	
1254    ; end patch
1255    C525  C6 C3        	DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
1256    C527  60           	RTS
1257    
1258    ; search Basic for temp integer line number from start of mem
1259    
1260    LAB_SSLN
1261    C528  A5 79        	LDA	Smeml			; get start of mem low byte
1262    C52A  A6 7A        	LDX	Smemh			; get start of mem high byte
1263    
1264    ; search Basic for temp integer line number from AX
1265    ; returns carry set if found
1266    ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
1267    
1268    ; old 541 new 507
1269    
1270    LAB_SHLN
1271    C52C  A0 01        	LDY	#$01			; set index
1272    C52E  85 AA        	STA	Baslnl		; save low byte as current
1273    C530  86 AB        	STX	Baslnh		; save high byte as current
1274    C532  B1 AA        	LDA	(Baslnl),Y		; get pointer high byte from addr
1275    C534  F0 1A        	BEQ	LAB_145F		; pointer was zero so we"re done, do "not found" exit
1276    
1277    C536  A0 03        	LDY	#$03			; set index to line # high byte
1278    C538  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
1279    C53A  88           	DEY				; decrement index (point to low byte)
1280    C53B  C5 12        	CMP	Itemph		; compare with temporary integer high byte
1281    C53D  D0 04        	BNE	LAB_1455		; if <> skip low byte check
1282    
1283    C53F  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
1284    C541  C5 11        	CMP	Itempl		; compare with temporary integer low byte
1285    LAB_1455
1286    C543  B0 09        	BCS	LAB_145E		; else if temp < this line, exit (passed line#)
1287    
1288    LAB_1456
1289    C545  88           	DEY				; decrement index to next line ptr high byte
1290    C546  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
1291    C548  AA           	TAX				; copy to X
1292    C549  88           	DEY				; decrement index to next line ptr low byte
1293    C54A  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
1294    C54C  90 DE        	BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
1295    					; (carry always clear)
1296    
1297    LAB_145E
1298    C54E  F0 01        	BEQ	LAB_1460		; exit if temp = found line #, carry is set
1299    
1300    LAB_145F
1301    C550  18           	CLC				; clear found flag
1302    LAB_1460
1303    C551  60           	RTS
1304    
1305    ; perform NEW
1306    
1307    LAB_NEW
1308    C552  D0 FD        	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
1309    
1310    LAB_1463
1311    C554  A9 00        	LDA	#$00			; clear A
1312    C556  A8           	TAY				; clear Y
1313    C557  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, low byte
1314    C559  C8           	INY				; increment index
1315    C55A  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, high byte
1316    C55C  18           	CLC				; clear carry
1317    C55D  A5 79        	LDA	Smeml			; get start of mem low byte
1318    C55F  69 02        	ADC	#$02			; calculate end of BASIC low byte
1319    C561  85 7B        	STA	Svarl			; save start of vars low byte
1320    C563  A5 7A        	LDA	Smemh			; get start of mem high byte
1321    C565  69 00        	ADC	#$00			; add any carry
1322    C567  85 7C        	STA	Svarh			; save start of vars high byte
1323    
1324    ; reset execution to start, clear vars and flush stack
1325    
1326    LAB_1477
1327    C569  18           	CLC				; clear carry
1328    C56A  A5 79        	LDA	Smeml			; get start of mem low byte
1329    C56C  69 FF        	ADC	#$FF			; -1
1330    C56E  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
1331    C570  A5 7A        	LDA	Smemh			; get start of mem high byte
1332    C572  69 FF        	ADC	#$FF			; -1+carry
1333    C574  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
1334    
1335    ; "CLEAR" command gets here
1336    
1337    LAB_147A
1338    C576  A5 85        	LDA	Ememl			; get end of mem low byte
1339    C578  A4 86        	LDY	Ememh			; get end of mem high byte
1340    C57A  85 81        	STA	Sstorl		; set bottom of string space low byte
1341    C57C  84 82        	STY	Sstorh		; set bottom of string space high byte
1342    C57E  A5 7B        	LDA	Svarl			; get start of vars low byte
1343    C580  A4 7C        	LDY	Svarh			; get start of vars high byte
1344    C582  85 7D        	STA	Sarryl		; save var mem end low byte
1345    C584  84 7E        	STY	Sarryh		; save var mem end high byte
1346    C586  85 7F        	STA	Earryl		; save array mem end low byte
1347    C588  84 80        	STY	Earryh		; save array mem end high byte
1348    C58A  20 48 C7     	JSR	LAB_161A		; perform RESTORE command
1349    
1350    ; flush stack and clear continue flag
1351    
1352    LAB_1491
1353    C58D  A2 68        	LDX	#des_sk		; set descriptor stack pointer
1354    C58F  86 65        	STX	next_s		; save descriptor stack pointer
1355    C591  68           	PLA				; pull return address low byte
1356    C592  AA           	TAX				; copy return address low byte
1357    C593  68           	PLA				; pull return address high byte
1358    C594  8E FE 01     	STX	LAB_SKFE		; save to cleared stack
1359    C597  8D FF 01     	STA	LAB_SKFF		; save to cleared stack
1360    C59A  A2 FD        	LDX	#$FD			; new stack pointer
1361    C59C  9A           	TXS				; reset stack
1362    C59D  A9 00        	LDA	#$00			; clear byte
1363    C59F  85 8C        	STA	Cpntrh		; clear continue pointer high byte
1364    C5A1  85 61        	STA	Sufnxf		; clear subscript/FNX flag
1365    LAB_14A6
1366    C5A3  60           	RTS
1367    
1368    ; perform CLEAR
1369    
1370    LAB_CLEAR
1371    C5A4  F0 D0        	BEQ	LAB_147A		; if no following token go do "CLEAR"
1372    
1373    					; else there was a following token (go do syntax error)
1374    C5A6  60           	RTS
1375    
1376    ; perform LIST [n][-m]
1377    ; bigger, faster version (a _lot_ faster)
1378    
1379    LAB_LIST
1380    C5A7  90 06        	BCC	LAB_14BD		; branch if next character numeric (LIST n..)
1381    
1382    C5A9  F0 04        	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
1383    
1384    C5AB  C9 B8        	CMP	#TK_MINUS		; compare with token for -
1385    C5AD  D0 F4        	BNE	LAB_14A6		; exit if not - (LIST -m)
1386    
1387    					; LIST [[n][-m]]
1388    					; this bit sets the n , if present, as the start and end
1389    LAB_14BD
1390    C5AF  20 59 C9     	JSR	LAB_GFPN		; get fixed-point number into temp integer
1391    C5B2  20 28 C5     	JSR	LAB_SSLN		; search BASIC for temp integer line number
1392    					; (pointer in Baslnl/Baslnh)
1393    C5B5  20 C2 00     	JSR	LAB_GBYT		; scan memory
1394    C5B8  F0 0C        	BEQ	LAB_14D4		; branch if no more characters
1395    
1396    					; this bit checks the - is present
1397    C5BA  C9 B8        	CMP	#TK_MINUS		; compare with token for -
1398    C5BC  D0 93        	BNE	LAB_1460		; return if not "-" (will be Syntax error)
1399    
1400    					; LIST [n]-m
1401    					; the - was there so set m as the end value
1402    C5BE  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
1403    C5C1  20 59 C9     	JSR	LAB_GFPN		; get fixed-point number into temp integer
1404    C5C4  D0 8B        	BNE	LAB_1460		; exit if not ok
1405    
1406    LAB_14D4
1407    C5C6  A5 11        	LDA	Itempl		; get temporary integer low byte
1408    C5C8  05 12        	ORA	Itemph		; OR temporary integer high byte
1409    C5CA  D0 06        	BNE	LAB_14E2		; branch if start set
1410    
1411    C5CC  A9 FF        	LDA	#$FF			; set for -1
1412    C5CE  85 11        	STA	Itempl		; set temporary integer low byte
1413    C5D0  85 12        	STA	Itemph		; set temporary integer high byte
1414    LAB_14E2
1415    C5D2  A0 01        	LDY	#$01			; set index for line
1416    C5D4  84 60        	STY	Oquote		; clear open quote flag
1417    C5D6  20 96 CA     	JSR	LAB_CRLF		; print CR/LF
1418    C5D9  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
1419    					; pointer initially set by search at LAB_14BD
1420    C5DB  F0 3E        	BEQ	LAB_152B		; if null all done so exit
1421    C5DD  20 18 C7     	JSR	LAB_1629		; do CRTL-C check vector
1422    
1423    C5E0  C8           	INY				; increment index for line
1424    C5E1  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
1425    C5E3  AA           	TAX				; copy to X
1426    C5E4  C8           	INY				; increment index
1427    C5E5  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
1428    C5E7  C5 12        	CMP	Itemph		; compare with temporary integer high byte
1429    C5E9  D0 04        	BNE	LAB_14FF		; branch if no high byte match
1430    
1431    C5EB  E4 11        	CPX	Itempl		; compare with temporary integer low byte
1432    C5ED  F0 02        	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
1433    
1434    LAB_14FF				; else ..
1435    C5EF  B0 2A        	BCS	LAB_152B		; if greater all done so exit
1436    
1437    LAB_1501
1438    C5F1  84 97        	STY	Tidx1			; save index for line
1439    C5F3  20 86 DC     	JSR	LAB_295E		; print XA as unsigned integer
1440    C5F6  A9 20        	LDA	#$20			; space is the next character
1441    LAB_1508
1442    C5F8  A4 97        	LDY	Tidx1			; get index for line
1443    C5FA  29 7F        	AND	#$7F			; mask top out bit of character
1444    LAB_150C
1445    C5FC  20 F1 CA     	JSR	LAB_PRNA		; go print the character
1446    C5FF  C9 22        	CMP	#$22			; was it " character
1447    C601  D0 06        	BNE	LAB_1519		; branch if not
1448    
1449    					; we are either entering or leaving a pair of quotes
1450    C603  A5 60        	LDA	Oquote		; get open quote flag
1451    C605  49 FF        	EOR	#$FF			; toggle it
1452    C607  85 60        	STA	Oquote		; save it back
1453    LAB_1519
1454    C609  C8           	INY				; increment index
1455    C60A  B1 AA        	LDA	(Baslnl),Y		; get next byte
1456    C60C  D0 0E        	BNE	LAB_152E		; branch if not [EOL] (go print character)
1457    C60E  A8           	TAY				; else clear index
1458    C60F  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
1459    C611  AA           	TAX				; copy to X
1460    C612  C8           	INY				; increment index
1461    C613  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
1462    C615  86 AA        	STX	Baslnl		; set pointer to line low byte
1463    C617  85 AB        	STA	Baslnh		; set pointer to line high byte
1464    C619  D0 B7        	BNE	LAB_14E2		; go do next line if not [EOT]
1465    					; else ..
1466    LAB_152B
1467    C61B  60           	RTS
1468    
1469    LAB_152E
1470    C61C  10 DE        	BPL	LAB_150C		; just go print it if not token byte
1471    
1472    					; else was token byte so uncrunch it (maybe)
1473    C61E  24 60        	BIT	Oquote		; test the open quote flag
1474    C620  30 DA        	BMI	LAB_150C		; just go print character if open quote set
1475    
1476    C622  A2 E7        	LDX	#>LAB_KEYT		; get table address high byte
1477    C624  0A           	ASL				; *2
1478    C625  0A           	ASL				; *4
1479    C626  90 02        	BCC	LAB_152F		; branch if no carry
1480    
1481    C628  E8           	INX				; else increment high byte
1482    C629  18           	CLC				; clear carry for add
1483    LAB_152F
1484    C62A  69 22        	ADC	#<LAB_KEYT		; add low byte
1485    C62C  90 01        	BCC	LAB_1530		; branch if no carry
1486    
1487    C62E  E8           	INX				; else increment high byte
1488    LAB_1530
1489    C62F  85 73        	STA	ut2_pl		; save table pointer low byte
1490    C631  86 74        	STX	ut2_ph		; save table pointer high byte
1491    C633  84 97        	STY	Tidx1			; save index for line
1492    C635  A0 00        	LDY	#$00			; clear index
1493    C637  B1 73        	LDA	(ut2_pl),Y		; get length
1494    C639  AA           	TAX				; copy length
1495    C63A  C8           	INY				; increment index
1496    C63B  B1 73        	LDA	(ut2_pl),Y		; get 1st character
1497    C63D  CA           	DEX				; decrement length
1498    C63E  F0 B8        	BEQ	LAB_1508		; if no more characters exit and print
1499    
1500    C640  20 F1 CA     	JSR	LAB_PRNA		; go print the character
1501    C643  C8           	INY				; increment index
1502    C644  B1 73        	LDA	(ut2_pl),Y		; get keyword address low byte
1503    C646  48           	PHA				; save it for now
1504    C647  C8           	INY				; increment index
1505    C648  B1 73        	LDA	(ut2_pl),Y		; get keyword address high byte
1506    C64A  A0 00        	LDY	#$00
1507    C64C  85 74        	STA	ut2_ph		; save keyword pointer high byte
1508    C64E  68           	PLA				; pull low byte
1509    C64F  85 73        	STA	ut2_pl		; save keyword pointer low byte
1510    LAB_1540
1511    C651  B1 73        	LDA	(ut2_pl),Y		; get character
1512    C653  CA           	DEX				; decrement character count
1513    C654  F0 A2        	BEQ	LAB_1508		; if last character exit and print
1514    
1515    C656  20 F1 CA     	JSR	LAB_PRNA		; go print the character
1516    C659  C8           	INY				; increment index
1517    C65A  D0 F5        	BNE	LAB_1540		; loop for next character
1518    
1519    ; perform FOR
1520    
1521    LAB_FOR
1522    C65C  A9 80        	LDA	#$80			; set FNX
1523    C65E  85 61        	STA	Sufnxf		; set subscript/FNX flag
1524    C660  20 B8 C9     	JSR	LAB_LET		; go do LET
1525    C663  68           	PLA				; pull return address
1526    C664  68           	PLA				; pull return address
1527    C665  A9 10        	LDA	#$10			; we need 16d bytes !
1528    C667  20 07 C3     	JSR	LAB_1212		; check room on stack for A bytes
1529    C66A  20 A1 C8     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
1530    C66D  18           	CLC				; clear carry for add
1531    C66E  98           	TYA				; copy index to A
1532    C66F  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
1533    C671  48           	PHA				; push onto stack
1534    C672  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
1535    C674  69 00        	ADC	#$00			; add carry
1536    C676  48           	PHA				; push onto stack
1537    C677  A5 88        	LDA	Clineh		; get current line high byte
1538    C679  48           	PHA				; push onto stack
1539    C67A  A5 87        	LDA	Clinel		; get current line low byte
1540    C67C  48           	PHA				; push onto stack
1541    C67D  A9 AE        	LDA	#TK_TO		; get "TO" token
1542    C67F  20 F5 CD     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
1543    C682  20 D4 CC     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
1544    C685  20 D1 CC     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
1545    					; else do type mismatch
1546    C688  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
1547    C68A  09 7F        	ORA	#$7F			; set all non sign bits
1548    C68C  25 AD        	AND	FAC1_1		; and FAC1 mantissa1
1549    C68E  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
1550    C690  A9 9B        	LDA	#<LAB_159F		; set return address low byte
1551    C692  A0 C6        	LDY	#>LAB_159F		; set return address high byte
1552    C694  85 71        	STA	ut1_pl		; save return address low byte
1553    C696  84 72        	STY	ut1_ph		; save return address high byte
1554    C698  4C 88 CD     	JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
1555    
1556    LAB_159F
1557    C69B  A9 EC        	LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
1558    C69D  A0 E3        	LDY	#>LAB_259C		; set 1 pointer high addr
1559    C69F  20 81 DA     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
1560    C6A2  20 C2 00     	JSR	LAB_GBYT		; scan memory
1561    C6A5  C9 B3        	CMP	#TK_STEP		; compare with STEP token
1562    C6A7  D0 06        	BNE	LAB_15B3		; jump if not "STEP"
1563    
1564    					;.was step so ..
1565    C6A9  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
1566    C6AC  20 D1 CC     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
1567    					; else do type mismatch
1568    LAB_15B3
1569    C6AF  20 ED DA     	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
1570    C6B2  85 B0        	STA	FAC1_s		; set FAC1 sign (b7)
1571    					; this is +1 for +ve step and -1 for -ve step, in NEXT we
1572    					; compare the FOR value and the TO value and return +1 if
1573    					; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
1574    					; here (+/-1) is then compared to that result and if they
1575    					; are the same (+ve and FOR > TO or -ve and FOR < TO) then
1576    					; the loop is done
1577    C6B4  20 7D CD     	JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
1578    C6B7  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
1579    C6B9  48           	PHA				; push on stack
1580    C6BA  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
1581    C6BC  48           	PHA				; push on stack
1582    C6BD  A9 81        	LDA	#TK_FOR		; get FOR token
1583    C6BF  48           	PHA				; push on stack
1584    
1585    ; interpreter inner loop
1586    
1587    LAB_15C2
1588    C6C0  20 18 C7     	JSR	LAB_1629		; do CRTL-C check vector
1589    C6C3  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
1590    C6C5  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
1591    
1592    C6C7  A6 88        	LDX	Clineh		; continue line is $FFxx for immediate mode
1593    					; ($00xx for RUN from immediate mode)
1594    C6C9  E8           	INX				; increment it (now $00 if immediate mode)
1595    C6CA  F0 04        	BEQ	LAB_15D1		; branch if null (immediate mode)
1596    
1597    C6CC  85 8B        	STA	Cpntrl		; save continue pointer low byte
1598    C6CE  84 8C        	STY	Cpntrh		; save continue pointer high byte
1599    LAB_15D1
1600    C6D0  A0 00        	LDY	#$00			; clear index
1601    C6D2  B1 C3        	LDA	(Bpntrl),Y		; get next byte
1602    C6D4  F0 07        	BEQ	LAB_15DC		; branch if null [EOL]
1603    
1604    C6D6  C9 3A        	CMP	#':'			; compare with ":"
1605    C6D8  F0 1D        	BEQ	LAB_15F6		; branch if = (statement separator)
1606    
1607    LAB_15D9
1608    C6DA  4C 06 CE     	JMP	LAB_SNER		; else syntax error then warm start
1609    
1610    					; have reached [EOL]
1611    LAB_15DC
1612    C6DD  A0 02        	LDY	#$02			; set index
1613    C6DF  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
1614    C6E1  18           	CLC				; clear carry for no "BREAK" message
1615    C6E2  F0 56        	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
1616    					; marker)
1617    
1618    C6E4  C8           	INY				; increment index
1619    C6E5  B1 C3        	LDA	(Bpntrl),Y		; get line # low byte
1620    C6E7  85 87        	STA	Clinel		; save current line low byte
1621    C6E9  C8           	INY				; increment index
1622    C6EA  B1 C3        	LDA	(Bpntrl),Y		; get line # high byte
1623    C6EC  85 88        	STA	Clineh		; save current line high byte
1624    C6EE  98           	TYA				; A now = 4
1625    C6EF  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
1626    C6F1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
1627    C6F3  90 02        	BCC	LAB_15F6		; branch if no overflow
1628    
1629    C6F5  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
1630    LAB_15F6
1631    C6F7  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
1632    
1633    LAB_15F9
1634    C6FA  20 00 C7     	JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
1635    
1636    LAB_15FC
1637    C6FD  4C C0 C6     	JMP	LAB_15C2		; loop
1638    
1639    ; interpret BASIC code from (Bpntrl)
1640    
1641    LAB_15FF
1642    C700  F0 54        	BEQ	LAB_1628		; exit if zero [EOL]
1643    
1644    LAB_1602
1645    C702  0A           	ASL				; *2 bytes per vector and normalise token
1646    C703  B0 03        	BCS	LAB_1609		; branch if was token
1647    
1648    C705  4C B8 C9     	JMP	LAB_LET		; else go do implied LET
1649    
1650    LAB_1609
1651    ;	CMP	#(TK_TAB-$80)*2	; compare normalised token * 2 with TAB
1652    C708  C9 58        	CMP	#$58			; compare normalised token * 2 with TAB
1653    C70A  B0 CE        	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
1654    					; only tokens before TAB can start a line
1655    C70C  A8           	TAY				; copy to index
1656    C70D  B9 14 E4     	LDA	LAB_CTBL+1,Y	; get vector high byte
1657    C710  48           	PHA				; onto stack
1658    C711  B9 13 E4     	LDA	LAB_CTBL,Y		; get vector low byte
1659    C714  48           	PHA				; onto stack
1660    C715  4C BC 00     	JMP	LAB_IGBY		; jump to increment and scan memory
1661    					; then "return" to vector
1662    
1663    ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
1664    ; key press is detected.
1665    
1666    LAB_1629
1667    C718  6C 93 03     	JMP	(VEC_CC)		; ctrl c check vector
1668    
1669    ; if there was a key press it gets back here ..
1670    
1671    LAB_1636
1672    C71B  C9 03        	CMP	#$03			; compare with CTRL-C
1673    
1674    ; perform STOP
1675    
1676    LAB_STOP
1677    C71D  B0 01        	BCS	LAB_163B		; branch if token follows STOP
1678    					; else just END
1679    ; END
1680    
1681    LAB_END
1682    C71F  18           	CLC				; clear the carry, indicate a normal program end
1683    LAB_163B
1684    C720  D0 67        	BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
1685    
1686    C722  A5 C4        	LDA	Bpntrh		; get the BASIC execute pointer high byte
1687    C724  49 03        	EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
1688    C726  F0 10        	BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
1689    					; (can't continue in immediate mode)
1690    
1691    					; else ..
1692    C728  49 03        	EOR	#>Ibuffs		; correct the bits
1693    C72A  A4 C3        	LDY	Bpntrl		; get BASIC execute pointer low byte
1694    C72C  84 8B        	STY	Cpntrl		; save continue pointer low byte
1695    C72E  85 8C        	STA	Cpntrh		; save continue pointer high byte
1696    LAB_1647
1697    C730  A5 87        	LDA	Clinel		; get current line low byte
1698    C732  A4 88        	LDY	Clineh		; get current line high byte
1699    C734  85 89        	STA	Blinel		; save break line low byte
1700    C736  84 8A        	STY	Blineh		; save break line high byte
1701    LAB_164F
1702    C738  68           	PLA				; pull return address low
1703    C739  68           	PLA				; pull return address high
1704    LAB_1651
1705    C73A  90 07        	BCC	LAB_165E		; if was program end just do warm start
1706    
1707    					; else ..
1708    C73C  A9 F3        	LDA	#<LAB_BMSG		; point to "Break" low byte
1709    C73E  A0 E9        	LDY	#>LAB_BMSG		; point to "Break" high byte
1710    C740  4C 53 C3     	JMP	LAB_1269		; print "Break" and do warm start
1711    
1712    LAB_165E
1713    C743  4C 5E C3     	JMP	LAB_1274		; go do warm start
1714    
1715    ; perform RESTORE
1716    
1717    LAB_RESTORE
1718    C746  D0 0F        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
1719    
1720    LAB_161A
1721    C748  38           	SEC				; set carry for subtract
1722    C749  A5 79        	LDA	Smeml			; get start of mem low byte
1723    C74B  E9 01        	SBC	#$01			; -1
1724    C74D  A4 7A        	LDY	Smemh			; get start of mem high byte
1725    C74F  B0 01        	BCS	LAB_1624		; branch if no underflow
1726    
1727    LAB_uflow
1728    C751  88           	DEY				; else decrement high byte
1729    LAB_1624
1730    C752  85 8F        	STA	Dptrl			; save DATA pointer low byte
1731    C754  84 90        	STY	Dptrh			; save DATA pointer high byte
1732    LAB_1628
1733    C756  60           	RTS
1734    
1735    					; is RESTORE n
1736    LAB_RESTOREn
1737    C757  20 59 C9     	JSR	LAB_GFPN		; get fixed-point number into temp integer
1738    C75A  20 A4 C8     	JSR	LAB_SNBL		; scan for next BASIC line
1739    C75D  A5 88        	LDA	Clineh		; get current line high byte
1740    C75F  C5 12        	CMP	Itemph		; compare with temporary integer high byte
1741    C761  B0 0B        	BCS	LAB_reset_search	; branch if >= (start search from beginning)
1742    
1743    C763  98           	TYA				; else copy line index to A
1744    C764  38           	SEC				; set carry (+1)
1745    C765  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
1746    C767  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
1747    C769  90 07        	BCC	LAB_go_search	; branch if no overflow to high byte
1748    
1749    C76B  E8           	INX				; increment high byte
1750    C76C  B0 04        	BCS	LAB_go_search	; branch always (can never be carry clear)
1751    
1752    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
1753    
1754    LAB_reset_search
1755    C76E  A5 79        	LDA	Smeml			; get start of mem low byte
1756    C770  A6 7A        	LDX	Smemh			; get start of mem high byte
1757    
1758    ; search for line # in temp (Itempl/Itemph) from (AX)
1759    
1760    LAB_go_search
1761    
1762    C772  20 2C C5     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
1763    C775  B0 03        	BCS	LAB_line_found	; if carry set go set pointer
1764    
1765    C777  4C 76 C8     	JMP	LAB_16F7		; else go do "Undefined statement" error
1766    
1767    LAB_line_found
1768    					; carry already set for subtract
1769    C77A  A5 AA        	LDA	Baslnl		; get pointer low byte
1770    C77C  E9 01        	SBC	#$01			; -1
1771    C77E  A4 AB        	LDY	Baslnh		; get pointer high byte
1772    C780  B0 D0        	BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
1773    
1774    C782  90 CD        	BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
1775    					; return (branch always)
1776    
1777    ; perform NULL
1778    
1779    LAB_NULL
1780    C784  20 90 D6     	JSR	LAB_GTBY		; get byte parameter
1781    C787  86 0D        	STX	Nullct		; save new NULL count
1782    LAB_167A
1783    C789  60           	RTS
1784    
1785    ; perform CONT
1786    
1787    LAB_CONT
1788    C78A  D0 FD        	BNE	LAB_167A		; if following byte exit to do syntax error
1789    
1790    C78C  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
1791    C78E  D0 05        	BNE	LAB_166C		; go do continue if we can
1792    
1793    C790  A2 1E        	LDX	#$1E			; error code $1E ("Can't continue" error)
1794    C792  4C 40 C3     	JMP	LAB_XERR		; do error #X, then warm start
1795    
1796    					; we can continue so ..
1797    LAB_166C
1798    C795  A9 93        	LDA	#TK_ON		; set token for ON
1799    C797  20 18 E1     	JSR	LAB_IRQ		; set IRQ flags
1800    C79A  A9 93        	LDA	#TK_ON		; set token for ON
1801    C79C  20 1B E1     	JSR	LAB_NMI		; set NMI flags
1802    
1803    C79F  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
1804    C7A1  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
1805    C7A3  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
1806    C7A5  A5 89        	LDA	Blinel		; get break line low byte
1807    C7A7  A4 8A        	LDY	Blineh		; get break line high byte
1808    C7A9  85 87        	STA	Clinel		; set current line low byte
1809    C7AB  84 88        	STY	Clineh		; set current line high byte
1810    C7AD  60           	RTS
1811    
1812    ; perform RUN
1813    
1814    LAB_RUN
1815    C7AE  D0 03        	BNE	LAB_1696		; branch if RUN n
1816    C7B0  4C 69 C5     	JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
1817    					; return
1818    
1819    ; does RUN n
1820    
1821    LAB_1696
1822    C7B3  20 76 C5     	JSR	LAB_147A		; go do "CLEAR"
1823    C7B6  F0 2E        	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
1824    
1825    ; perform DO
1826    
1827    LAB_DO
1828    C7B8  A9 05        	LDA	#$05			; need 5 bytes for DO
1829    C7BA  20 07 C3     	JSR	LAB_1212		; check room on stack for A bytes
1830    C7BD  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
1831    C7BF  48           	PHA				; push on stack
1832    C7C0  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
1833    C7C2  48           	PHA				; push on stack
1834    C7C3  A5 88        	LDA	Clineh		; get current line high byte
1835    C7C5  48           	PHA				; push on stack
1836    C7C6  A5 87        	LDA	Clinel		; get current line low byte
1837    C7C8  48           	PHA				; push on stack
1838    C7C9  A9 9D        	LDA	#TK_DO		; token for DO
1839    C7CB  48           	PHA				; push on stack
1840    C7CC  20 C2 00     	JSR	LAB_GBYT		; scan memory
1841    C7CF  4C C0 C6     	JMP	LAB_15C2		; go do interpreter inner loop
1842    
1843    ; perform GOSUB
1844    
1845    LAB_GOSUB
1846    C7D2  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
1847    C7D4  20 07 C3     	JSR	LAB_1212		; check room on stack for A bytes
1848    C7D7  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
1849    C7D9  48           	PHA				; push on stack
1850    C7DA  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
1851    C7DC  48           	PHA				; push on stack
1852    C7DD  A5 88        	LDA	Clineh		; get current line high byte
1853    C7DF  48           	PHA				; push on stack
1854    C7E0  A5 87        	LDA	Clinel		; get current line low byte
1855    C7E2  48           	PHA				; push on stack
1856    C7E3  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
1857    C7E5  48           	PHA				; push on stack
1858    LAB_16B0
1859    C7E6  20 C2 00     	JSR	LAB_GBYT		; scan memory
1860    C7E9  20 EF C7     	JSR	LAB_GOTO		; perform GOTO n
1861    C7EC  4C C0 C6     	JMP	LAB_15C2		; go do interpreter inner loop
1862    					; (can't RTS, we used the stack!)
1863    
1864    ; perform GOTO
1865    
1866    LAB_GOTO
1867    C7EF  20 59 C9     	JSR	LAB_GFPN		; get fixed-point number into temp integer
1868    C7F2  20 A4 C8     	JSR	LAB_SNBL		; scan for next BASIC line
1869    C7F5  A5 88        	LDA	Clineh		; get current line high byte
1870    C7F7  C5 12        	CMP	Itemph		; compare with temporary integer high byte
1871    C7F9  B0 0B        	BCS	LAB_16D0		; branch if >= (start search from beginning)
1872    
1873    C7FB  98           	TYA				; else copy line index to A
1874    C7FC  38           	SEC				; set carry (+1)
1875    C7FD  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
1876    C7FF  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
1877    C801  90 07        	BCC	LAB_16D4		; branch if no overflow to high byte
1878    
1879    C803  E8           	INX				; increment high byte
1880    C804  B0 04        	BCS	LAB_16D4		; branch always (can never be carry)
1881    
1882    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
1883    
1884    LAB_16D0
1885    C806  A5 79        	LDA	Smeml			; get start of mem low byte
1886    C808  A6 7A        	LDX	Smemh			; get start of mem high byte
1887    
1888    ; search for line # in temp (Itempl/Itemph) from (AX)
1889    
1890    LAB_16D4
1891    C80A  20 2C C5     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
1892    C80D  90 67        	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
1893    					; (unspecified statement)
1894    
1895    					; carry already set for subtract
1896    C80F  A5 AA        	LDA	Baslnl		; get pointer low byte
1897    C811  E9 01        	SBC	#$01			; -1
1898    C813  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
1899    C815  A5 AB        	LDA	Baslnh		; get pointer high byte
1900    C817  E9 00        	SBC	#$00			; subtract carry
1901    C819  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
1902    LAB_16E5
1903    C81B  60           	RTS
1904    
1905    LAB_DONOK
1906    C81C  A2 22        	LDX	#$22			; error code $22 ("LOOP without DO" error)
1907    C81E  4C 40 C3     	JMP	LAB_XERR		; do error #X, then warm start
1908    
1909    ; perform LOOP
1910    
1911    LAB_LOOP
1912    C821  A8           	TAY				; save following token
1913    C822  BA           	TSX				; copy stack pointer
1914    C823  BD 03 01     	LDA	LAB_STAK+3,X	; get token byte from stack
1915    C826  C9 9D        	CMP	#TK_DO		; compare with DO token
1916    C828  D0 F2        	BNE	LAB_DONOK		; branch if no matching DO
1917    
1918    C82A  E8           	INX				; dump calling routine return address
1919    C82B  E8           	INX				; dump calling routine return address
1920    C82C  9A           	TXS				; correct stack
1921    C82D  98           	TYA				; get saved following token back
1922    C82E  F0 20        	BEQ	LoopAlways		; if no following token loop forever
1923    					; (stack pointer in X)
1924    
1925    C830  C9 3A        	CMP	#':'			; could be ":"
1926    C832  F0 1C        	BEQ	LoopAlways		; if :... loop forever
1927    
1928    C834  E9 B4        	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
1929    C836  AA           	TAX				; copy to X (if it was UNTIL then Y will be correct)
1930    C837  F0 04        	BEQ	DoRest		; branch if was UNTIL
1931    
1932    C839  CA           	DEX				; decrement result
1933    C83A  D0 62        	BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
1934    					; only if the token was WHILE will this fail
1935    
1936    C83C  CA           	DEX				; set invert result byte
1937    DoRest
1938    C83D  86 98        	STX	Frnxth		; save invert result byte
1939    C83F  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
1940    C842  20 E5 CC     	JSR	LAB_EVEX		; evaluate expression
1941    C845  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
1942    C847  F0 02        	BEQ	DoCmp			; if =0 go do straight compare
1943    
1944    C849  A9 FF        	LDA	#$FF			; else set all bits
1945    DoCmp
1946    C84B  BA           	TSX				; copy stack pointer
1947    C84C  45 98        	EOR	Frnxth		; EOR with invert byte
1948    C84E  D0 1A        	BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
1949    
1950    					; loop condition wasn't met so do it again
1951    LoopAlways
1952    C850  BD 02 01     	LDA	LAB_STAK+2,X	; get current line low byte
1953    C853  85 87        	STA	Clinel		; save current line low byte
1954    C855  BD 03 01     	LDA	LAB_STAK+3,X	; get current line high byte
1955    C858  85 88        	STA	Clineh		; save current line high byte
1956    C85A  BD 04 01     	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
1957    C85D  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
1958    C85F  BD 05 01     	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
1959    C862  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
1960    C864  20 C2 00     	JSR	LAB_GBYT		; scan memory
1961    C867  4C C0 C6     	JMP	LAB_15C2		; go do interpreter inner loop
1962    
1963    					; clear stack and back to interpreter loop
1964    LoopDone
1965    C86A  E8           	INX				; dump DO token
1966    C86B  E8           	INX				; dump current line low byte
1967    C86C  E8           	INX				; dump current line high byte
1968    C86D  E8           	INX				; dump BASIC execute pointer low byte
1969    C86E  E8           	INX				; dump BASIC execute pointer high byte
1970    C86F  9A           	TXS				; correct stack
1971    C870  4C 90 C8     	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
1972    
1973    ; do the return without gosub error
1974    
1975    LAB_16F4
1976    C873  A2 04        	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)
1977    	.byte	$2C			; makes next line BIT LAB_0EA2
1978    
1979    LAB_16F7				; do undefined statement error
1980    C876  A2 0E        	LDX	#$0E			; error code $0E ("Undefined statement" error)
1981    C878  4C 40 C3     	JMP	LAB_XERR		; do error #X, then warm start
1982    
1983    ; perform RETURN
1984    
1985    LAB_RETURN
1986    C87B  D0 9E        	BNE	LAB_16E5		; exit if following token (to allow syntax error)
1987    
1988    LAB_16E8
1989    C87D  68           	PLA				; dump calling routine return address
1990    C87E  68           	PLA				; dump calling routine return address
1991    C87F  68           	PLA				; pull token
1992    C880  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
1993    C882  D0 EF        	BNE	LAB_16F4		; branch if no matching GOSUB
1994    
1995    LAB_16FF
1996    C884  68           	PLA				; pull current line low byte
1997    C885  85 87        	STA	Clinel		; save current line low byte
1998    C887  68           	PLA				; pull current line high byte
1999    C888  85 88        	STA	Clineh		; save current line high byte
2000    C88A  68           	PLA				; pull BASIC execute pointer low byte
2001    C88B  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
2002    C88D  68           	PLA				; pull BASIC execute pointer high byte
2003    C88E  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
2004    
2005    					; now do the DATA statement as we could be returning into
2006    					; the middle of an ON <var> GOSUB n,m,p,q line
2007    					; (the return address used by the DATA statement is the one
2008    					; pushed before the GOSUB was executed!)
2009    
2010    ; perform DATA
2011    
2012    LAB_DATA
2013    C890  20 A1 C8     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
2014    
2015    					; set BASIC execute pointer
2016    LAB_170F
2017    C893  98           	TYA				; copy index to A
2018    C894  18           	CLC				; clear carry for add
2019    C895  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
2020    C897  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
2021    C899  90 02        	BCC	LAB_1719		; skip next if no carry
2022    
2023    C89B  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
2024    LAB_1719
2025    C89D  60           	RTS
2026    
2027    LAB_16FC
2028    C89E  4C 06 CE     	JMP	LAB_SNER		; do syntax error then warm start
2029    
2030    ; scan for next BASIC statement ([:] or [EOL])
2031    ; returns Y as index to [:] or [EOL]
2032    
2033    LAB_SNBS
2034    C8A1  A2 3A        	LDX	#':'			; set look for character = ":"
2035    	.byte	$2C			; makes next line BIT $00A2
2036    
2037    ; scan for next BASIC line
2038    ; returns Y as index to [EOL]
2039    
2040    LAB_SNBL
2041    C8A4  A2 00        	LDX	#$00			; set alt search character = [EOL]
2042    C8A6  A0 00        	LDY	#$00			; set search character = [EOL]
2043    C8A8  84 5C        	STY	Asrch			; store search character
2044    LAB_1725
2045    C8AA  8A           	TXA				; get alt search character
2046    C8AB  45 5C        	EOR	Asrch			; toggle search character, effectively swap with $00
2047    C8AD  85 5C        	STA	Asrch			; save swapped search character
2048    LAB_172D
2049    C8AF  B1 C3        	LDA	(Bpntrl),Y		; get next byte
2050    C8B1  F0 EA        	BEQ	LAB_1719		; exit if null [EOL]
2051    
2052    C8B3  C5 5C        	CMP	Asrch			; compare with search character
2053    C8B5  F0 E6        	BEQ	LAB_1719		; exit if found
2054    
2055    C8B7  C8           	INY				; increment index
2056    C8B8  C9 22        	CMP	#$22			; compare current character with open quote
2057    C8BA  D0 F3        	BNE	LAB_172D		; if not open quote go get next character
2058    
2059    C8BC  F0 EC        	BEQ	LAB_1725		; if found go swap search character for alt search character
2060    
2061    ; perform IF
2062    
2063    LAB_IF
2064    C8BE  20 E5 CC     	JSR	LAB_EVEX		; evaluate the expression
2065    C8C1  20 C2 00     	JSR	LAB_GBYT		; scan memory
2066    C8C4  C9 B1        	CMP	#TK_THEN		; compare with THEN token
2067    C8C6  F0 11        	BEQ	LAB_174B		; if it was THEN go do IF
2068    
2069    					; wasn't IF .. THEN so must be IF .. GOTO
2070    C8C8  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
2071    C8CA  D0 D2        	BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
2072    
2073    C8CC  A6 C3        	LDX	Bpntrl		; save the basic pointer low byte
2074    C8CE  A4 C4        	LDY	Bpntrh		; save the basic pointer high byte
2075    C8D0  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
2076    C8D3  B0 C9        	BCS	LAB_16FC		; if not numeric go do syntax error
2077    
2078    C8D5  86 C3        	STX	Bpntrl		; restore the basic pointer low byte
2079    C8D7  84 C4        	STY	Bpntrh		; restore the basic pointer high byte
2080    LAB_174B
2081    C8D9  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
2082    C8DB  F0 1B        	BEQ	LAB_174E		; if the result was zero go look for an ELSE
2083    
2084    C8DD  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
2085    C8E0  B0 03        	BCS	LAB_174D		; if not numeric go do var or keyword
2086    
2087    LAB_174C
2088    C8E2  4C EF C7     	JMP	LAB_GOTO		; else was numeric so do GOTO n
2089    
2090    					; is var or keyword
2091    LAB_174D
2092    C8E5  C9 90        	CMP	#TK_RETURN		; compare the byte with the token for RETURN
2093    C8E7  D0 03        	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
2094    					; and return to this code to process any following code
2095    
2096    C8E9  4C 02 C7     	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
2097    					; but don't return here
2098    
2099    LAB_174G
2100    C8EC  20 00 C7     	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
2101    
2102    ; the IF was executed and there may be a following ELSE so the code needs to return
2103    ; here to check and ignore the ELSE if present
2104    
2105    C8EF  A0 00        	LDY	#$00			; clear the index
2106    C8F1  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
2107    C8F3  C9 AD        	CMP	#TK_ELSE		; compare it with the token for ELSE
2108    C8F5  F0 99        	BEQ	LAB_DATA		; if ELSE ignore the following statement
2109    
2110    ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
2111    ; following ELSE will, correctly, cause a syntax error
2112    
2113    C8F7  60           	RTS				; else return to the interpreter inner loop
2114    
2115    ; perform ELSE after IF
2116    
2117    LAB_174E
2118    C8F8  A0 00        	LDY	#$00			; clear the BASIC byte index
2119    C8FA  A2 01        	LDX	#$01			; clear the nesting depth
2120    LAB_1750
2121    C8FC  C8           	INY				; increment the BASIC byte index
2122    C8FD  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
2123    C8FF  F0 0F        	BEQ	LAB_1753		; if EOL go add the pointer and return
2124    
2125    C901  C9 8B        	CMP	#TK_IF		; compare the byte with the token for IF
2126    C903  D0 03        	BNE	LAB_1752		; if not IF token skip the depth increment
2127    
2128    C905  E8           	INX				; else increment the nesting depth ..
2129    C906  D0 F4        	BNE	LAB_1750		; .. and continue looking
2130    
2131    LAB_1752
2132    C908  C9 AD        	CMP	#TK_ELSE		; compare the byte with the token for ELSE
2133    C90A  D0 F0        	BNE	LAB_1750		; if not ELSE token continue looking
2134    
2135    C90C  CA           	DEX				; was ELSE so decrement the nesting depth
2136    C90D  D0 ED        	BNE	LAB_1750		; loop if still nested
2137    
2138    C90F  C8           	INY				; increment the BASIC byte index past the ELSE
2139    
2140    ; found the matching ELSE, now do <{n|statement}>
2141    
2142    LAB_1753
2143    C910  98           	TYA				; else copy line index to A
2144    C911  18           	CLC				; clear carry for add
2145    C912  65 C3        	ADC	Bpntrl		; add the BASIC execute pointer low byte
2146    C914  85 C3        	STA	Bpntrl		; save the BASIC execute pointer low byte
2147    C916  90 02        	BCC	LAB_1754		; branch if no overflow to high byte
2148    
2149    C918  E6 C4        	INC	Bpntrh		; else increment the BASIC execute pointer high byte
2150    LAB_1754
2151    C91A  20 C2 00     	JSR	LAB_GBYT		; scan memory
2152    C91D  90 C3        	BCC	LAB_174C		; if numeric do GOTO n
2153    					; the code will return to the interpreter loop at the
2154    					; tail end of the GOTO <n>
2155    
2156    C91F  4C 00 C7     	JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
2157    					; the code will return to the interpreter loop at the
2158    					; tail end of the <statement>
2159    
2160    ; perform REM, skip (rest of) line
2161    
2162    LAB_REM
2163    C922  20 A4 C8     	JSR	LAB_SNBL		; scan for next BASIC line
2164    C925  4C 93 C8     	JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
2165    
2166    LAB_16FD
2167    C928  4C 06 CE     	JMP	LAB_SNER		; do syntax error then warm start
2168    
2169    ; perform ON
2170    
2171    LAB_ON
2172    C92B  C9 A9        	CMP	#TK_IRQ		; was it IRQ token ?
2173    C92D  D0 03        	BNE	LAB_NOIN		; if not go check NMI
2174    
2175    C92F  4C 3C E1     	JMP	LAB_SIRQ		; else go set-up IRQ
2176    
2177    LAB_NOIN
2178    C932  C9 AA        	CMP	#TK_NMI		; was it NMI token ?
2179    C934  D0 03        	BNE	LAB_NONM		; if not go do normal ON command
2180    
2181    C936  4C 40 E1     	JMP	LAB_SNMI		; else go set-up NMI
2182    
2183    LAB_NONM
2184    C939  20 90 D6     	JSR	LAB_GTBY		; get byte parameter
2185    C93C  48           	PHA				; push GOTO/GOSUB token
2186    C93D  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
2187    C93F  F0 04        	BEQ	LAB_176B		; branch if GOSUB
2188    
2189    C941  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
2190    LAB_1767
2191    C943  D0 E3        	BNE	LAB_16FD		; if not GOTO do syntax error then warm start
2192    
2193    
2194    ; next character was GOTO or GOSUB
2195    
2196    LAB_176B
2197    C945  C6 AF        	DEC	FAC1_3		; decrement index (byte value)
2198    C947  D0 04        	BNE	LAB_1773		; branch if not zero
2199    
2200    C949  68           	PLA				; pull GOTO/GOSUB token
2201    C94A  4C 02 C7     	JMP	LAB_1602		; go execute it
2202    
2203    LAB_1773
2204    C94D  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
2205    C950  20 59 C9     	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
2206    					; (we could LDX #"," and JSR LAB_SNBL+2, then we
2207    					; just BNE LAB_176B for the loop. should be quicker ..
2208    					; no we can't, what if we meet a colon or [EOL]?)
2209    C953  C9 2C        	CMP	#$2C			; compare next character with ","
2210    C955  F0 EE        	BEQ	LAB_176B		; loop if ","
2211    
2212    LAB_177E
2213    C957  68           	PLA				; else pull keyword token (run out of options)
2214    					; also dump +/-1 pointer low byte and exit
2215    LAB_177F
2216    C958  60           	RTS
2217    
2218    ; takes n * 106 + 11 cycles where n is the number of digits
2219    
2220    ; get fixed-point number into temp integer
2221    
2222    LAB_GFPN
2223    C959  A2 00        	LDX	#$00			; clear reg
2224    C95B  86 11        	STX	Itempl		; clear temporary integer low byte
2225    LAB_1785
2226    C95D  86 12        	STX	Itemph		; save temporary integer high byte
2227    C95F  B0 F7        	BCS	LAB_177F		; return if carry set, end of scan, character was
2228    					; not 0-9
2229    
2230    C961  E0 19        	CPX	#$19			; compare high byte with $19
2231    C963  A8           	TAY				; ensure Zb = 0 if the branch is taken
2232    C964  B0 DD        	BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
2233    					; bit does *$0A, = 64000, compare at target will fail
2234    					; and do syntax error
2235    
2236    C966  E9 2F        	SBC	#'0'-1		; subtract "0", $2F + carry, from byte
2237    C968  A8           	TAY				; copy binary digit
2238    C969  A5 11        	LDA	Itempl		; get temporary integer low byte
2239    C96B  0A           	ASL				; *2 low byte
2240    C96C  26 12        	ROL	Itemph		; *2 high byte
2241    C96E  0A           	ASL				; *2 low byte
2242    C96F  26 12        	ROL	Itemph		; *2 high byte, *4
2243    C971  65 11        	ADC	Itempl		; + low byte, *5
2244    C973  85 11        	STA	Itempl		; save it
2245    C975  8A           	TXA				; get high byte copy to A
2246    C976  65 12        	ADC	Itemph		; + high byte, *5
2247    C978  06 11        	ASL	Itempl		; *2 low byte, *10d
2248    C97A  2A           	ROL				; *2 high byte, *10d
2249    C97B  AA           	TAX				; copy high byte back to X
2250    C97C  98           	TYA				; get binary digit back
2251    C97D  65 11        	ADC	Itempl		; add number low byte
2252    C97F  85 11        	STA	Itempl		; save number low byte
2253    C981  90 01        	BCC	LAB_17B3		; if no overflow to high byte get next character
2254    
2255    C983  E8           	INX				; else increment high byte
2256    LAB_17B3
2257    C984  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
2258    C987  4C 5D C9     	JMP	LAB_1785		; loop for next character
2259    
2260    ; perform DEC
2261    
2262    LAB_DEC
2263    C98A  A9 F0        	LDA	#<LAB_2AFD		; set -1 pointer low byte
2264    	.byte	$2C			; BIT abs to skip the LDA below
2265    
2266    ; perform INC
2267    
2268    LAB_INC
2269    C98D  A9 EC        	LDA	#<LAB_259C		; set 1 pointer low byte
2270    LAB_17B5
2271    C98F  48           	PHA				; save +/-1 pointer low byte
2272    LAB_17B7
2273    C990  20 AE CF     	JSR	LAB_GVAR		; get var address
2274    C993  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
2275    C995  30 1E        	BMI	IncrErr		; exit if string
2276    
2277    C997  85 97        	STA	Lvarpl		; save var address low byte
2278    C999  84 98        	STY	Lvarph		; save var address high byte
2279    C99B  20 81 DA     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
2280    C99E  68           	PLA				; get +/-1 pointer low byte
2281    C99F  48           	PHA				; save +/-1 pointer low byte
2282    C9A0  A0 E3        	LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
2283    C9A2  20 C2 D7     	JSR	LAB_246C		; add (AY) to FAC1
2284    C9A5  20 A7 DA     	JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
2285    
2286    C9A8  20 C2 00     	JSR	LAB_GBYT		; scan memory
2287    C9AB  C9 2C        	CMP	#','			; compare with ","
2288    C9AD  D0 A8        	BNE	LAB_177E		; exit if not "," (either end or error)
2289    
2290    					; was "," so another INCR variable to do
2291    C9AF  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
2292    C9B2  4C 90 C9     	JMP	LAB_17B7		; go do next var
2293    
2294    IncrErr
2295    C9B5  4C E0 CC     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
2296    
2297    ; perform LET
2298    
2299    LAB_LET
2300    C9B8  20 AE CF     	JSR	LAB_GVAR		; get var address
2301    C9BB  85 97        	STA	Lvarpl		; save var address low byte
2302    C9BD  84 98        	STY	Lvarph		; save var address high byte
2303    C9BF  A9 C2        	LDA	#TK_EQUAL		; get = token
2304    C9C1  20 F5 CD     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
2305    C9C4  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
2306    C9C6  48           	PHA				; push data type flag
2307    C9C7  20 E5 CC     	JSR	LAB_EVEX		; evaluate expression
2308    C9CA  68           	PLA				; pop data type flag
2309    C9CB  2A           	ROL				; set carry if type = string
2310    C9CC  20 D7 CC     	JSR	LAB_CKTM		; type match check, set C for string
2311    C9CF  D0 03        	BNE	LAB_17D5		; branch if string
2312    
2313    C9D1  4C A7 DA     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
2314    
2315    ; string LET
2316    
2317    LAB_17D5
2318    C9D4  A0 02        	LDY	#$02			; set index to pointer high byte
2319    C9D6  B1 AE        	LDA	(des_pl),Y		; get string pointer high byte
2320    C9D8  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
2321    C9DA  90 17        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
2322    
2323    C9DC  D0 07        	BNE	LAB_17E6		; branch if >
2324    					; else was equal so compare low bytes
2325    C9DE  88           	DEY				; decrement index
2326    C9DF  B1 AE        	LDA	(des_pl),Y		; get pointer low byte
2327    C9E1  C5 81        	CMP	Sstorl		; compare bottom of string space low byte
2328    C9E3  90 0E        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
2329    
2330    					; pointer was >= to bottom of string space pointer
2331    LAB_17E6
2332    C9E5  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
2333    C9E7  C4 7C        	CPY	Svarh			; compare start of vars high byte
2334    C9E9  90 08        	BCC	LAB_17F4		; branch if less (descriptor is on stack)
2335    
2336    C9EB  D0 0D        	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
2337    
2338    					; else high bytes were equal so ..
2339    C9ED  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
2340    C9EF  C5 7B        	CMP	Svarl			; compare start of vars low byte
2341    C9F1  B0 07        	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
2342    
2343    LAB_17F4
2344    C9F3  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
2345    C9F5  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
2346    C9F7  4C 10 CA     	JMP	LAB_1811		; clean stack, copy descriptor to variable and return
2347    
2348    					; make space and copy string
2349    LAB_17FB
2350    C9FA  A0 00        	LDY	#$00			; index to length
2351    C9FC  B1 AE        	LDA	(des_pl),Y		; get string length
2352    C9FE  20 36 D3     	JSR	LAB_209C		; copy string
2353    CA01  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
2354    CA03  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
2355    CA05  85 B8        	STA	ssptr_l		; save descriptor pointer low byte
2356    CA07  84 B9        	STY	ssptr_h		; save descriptor pointer high byte
2357    CA09  20 15 D5     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
2358    CA0C  A9 AC        	LDA	#<FAC1_e		; set descriptor pointer low byte
2359    CA0E  A0 00        	LDY	#>FAC1_e		; get descriptor pointer high byte
2360    
2361    					; clean stack and assign value to string variable
2362    LAB_1811
2363    CA10  85 9E        	STA	des_2l		; save descriptor_2 pointer low byte
2364    CA12  84 9F        	STY	des_2h		; save descriptor_2 pointer high byte
2365    CA14  20 77 D5     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
2366    CA17  A0 00        	LDY	#$00			; index to length
2367    CA19  B1 9E        	LDA	(des_2l),Y		; get string length
2368    CA1B  91 97        	STA	(Lvarpl),Y		; copy to let string variable
2369    CA1D  C8           	INY				; index to string pointer low byte
2370    CA1E  B1 9E        	LDA	(des_2l),Y		; get string pointer low byte
2371    CA20  91 97        	STA	(Lvarpl),Y		; copy to let string variable
2372    CA22  C8           	INY				; index to string pointer high byte
2373    CA23  B1 9E        	LDA	(des_2l),Y		; get string pointer high byte
2374    CA25  91 97        	STA	(Lvarpl),Y		; copy to let string variable
2375    CA27  60           	RTS
2376    
2377    ; perform GET
2378    
2379    LAB_GET
2380    CA28  20 AE CF     	JSR	LAB_GVAR		; get var address
2381    CA2B  85 97        	STA	Lvarpl		; save var address low byte
2382    CA2D  84 98        	STY	Lvarph		; save var address high byte
2383    CA2F  20 04 E1     	JSR	INGET			; get input byte
2384    CA32  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
2385    CA34  30 07        	BMI	LAB_GETS		; go get string character
2386    
2387    					; was numeric get
2388    CA36  A8           	TAY				; copy character to Y
2389    CA37  20 6A D2     	JSR	LAB_1FD0		; convert Y to byte in FAC1
2390    CA3A  4C A7 DA     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
2391    
2392    LAB_GETS
2393    CA3D  48           	PHA				; save character
2394    CA3E  A9 01        	LDA	#$01			; string is single byte
2395    CA40  B0 01        	BCS	LAB_IsByte		; branch if byte received
2396    
2397    CA42  68           	PLA				; string is null
2398    LAB_IsByte
2399    CA43  20 3E D3     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
2400    					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
2401    CA46  F0 05        	BEQ	LAB_NoSt		; skip store if null string
2402    
2403    CA48  68           	PLA				; get character back
2404    CA49  A0 00        	LDY	#$00			; clear index
2405    CA4B  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
2406    LAB_NoSt
2407    CA4D  20 89 D3     	JSR	LAB_RTST		; check for space on descriptor stack then put address
2408    					; and length on descriptor stack and update stack pointers
2409    
2410    CA50  4C D4 C9     	JMP	LAB_17D5		; do string LET and return
2411    
2412    ; perform PRINT
2413    
2414    LAB_1829
2415    CA53  20 DA CA     	JSR	LAB_18C6		; print string from Sutill/Sutilh
2416    LAB_182C
2417    CA56  20 C2 00     	JSR	LAB_GBYT		; scan memory
2418    
2419    ; PRINT
2420    
2421    LAB_PRINT
2422    CA59  F0 3B        	BEQ	LAB_CRLF		; if nothing following just print CR/LF
2423    
2424    LAB_1831
2425    CA5B  C9 AC        	CMP	#TK_TAB		; compare with TAB( token
2426    CA5D  F0 56        	BEQ	LAB_18A2		; go do TAB/SPC
2427    
2428    CA5F  C9 B0        	CMP	#TK_SPC		; compare with SPC( token
2429    CA61  F0 52        	BEQ	LAB_18A2		; go do TAB/SPC
2430    
2431    CA63  C9 2C        	CMP	#','			; compare with ","
2432    CA65  F0 38        	BEQ	LAB_188B		; go do move to next TAB mark
2433    
2434    CA67  C9 3B        	CMP	#';'			; compare with ";"
2435    CA69  F0 66        	BEQ	LAB_18BD		; if ";" continue with PRINT processing
2436    
2437    CA6B  20 E5 CC     	JSR	LAB_EVEX		; evaluate expression
2438    CA6E  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
2439    CA70  30 E1        	BMI	LAB_1829		; branch if string
2440    
2441    CA72  20 99 DC     	JSR	LAB_296E		; convert FAC1 to string
2442    CA75  20 48 D3     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
2443    CA78  A0 00        	LDY	#$00			; clear index
2444    
2445    ; don't check fit if terminal width byte is zero
2446    
2447    CA7A  A5 0F        	LDA	TWidth		; get terminal width byte
2448    CA7C  F0 0A        	BEQ	LAB_185E		; skip check if zero
2449    
2450    CA7E  38           	SEC				; set carry for subtract
2451    CA7F  E5 0E        	SBC	TPos			; subtract terminal position
2452    CA81  F1 AE        	SBC	(des_pl),Y		; subtract string length
2453    CA83  B0 03        	BCS	LAB_185E		; branch if less than terminal width
2454    
2455    CA85  20 96 CA     	JSR	LAB_CRLF		; else print CR/LF
2456    LAB_185E
2457    CA88  20 DA CA     	JSR	LAB_18C6		; print string from Sutill/Sutilh
2458    CA8B  F0 C9        	BEQ	LAB_182C		; always go continue processing line
2459    
2460    ; CR/LF return to BASIC from BASIC input handler
2461    
2462    LAB_1866
2463    CA8D  A9 00        	LDA	#$00			; clear byte
2464    CA8F  9D 9D 03     	STA	Ibuffs,X		; null terminate input
2465    CA92  A2 9D        	LDX	#<Ibuffs		; set X to buffer start-1 low byte
2466    CA94  A0 03        	LDY	#>Ibuffs		; set Y to buffer start-1 high byte
2467    
2468    ; print CR/LF
2469    
2470    LAB_CRLF
2471    CA96  A9 0D        	LDA	#$0D			; load [CR]
2472    CA98  20 F1 CA     	JSR	LAB_PRNA		; go print the character
2473    CA9B  A9 0A        	LDA	#$0A			; load [LF]
2474    CA9D  D0 52        	BNE	LAB_PRNA		; go print the character and return, branch always
2475    
2476    LAB_188B
2477    CA9F  A5 0E        	LDA	TPos			; get terminal position
2478    CAA1  C5 10        	CMP	Iclim			; compare with input column limit
2479    CAA3  90 05        	BCC	LAB_1897		; branch if less
2480    
2481    CAA5  20 96 CA     	JSR	LAB_CRLF		; else print CR/LF (next line)
2482    CAA8  D0 27        	BNE	LAB_18BD		; continue with PRINT processing (branch always)
2483    
2484    LAB_1897
2485    CAAA  38           	SEC				; set carry for subtract
2486    LAB_1898
2487    CAAB  E5 64        	SBC	TabSiz		; subtract TAB size
2488    CAAD  B0 FC        	BCS	LAB_1898		; loop if result was +ve
2489    
2490    CAAF  49 FF        	EOR	#$FF			; complement it
2491    CAB1  69 01        	ADC	#$01			; +1 (twos complement)
2492    CAB3  D0 12        	BNE	LAB_18B6		; always print A spaces (result is never $00)
2493    
2494    					; do TAB/SPC
2495    LAB_18A2
2496    CAB5  48           	PHA				; save token
2497    CAB6  20 8D D6     	JSR	LAB_SGBY		; scan and get byte parameter
2498    CAB9  C9 29        	CMP	#$29			; is next character )
2499    CABB  D0 7B        	BNE	LAB_1910		; if not do syntax error then warm start
2500    
2501    CABD  68           	PLA				; get token back
2502    CABE  C9 AC        	CMP	#TK_TAB		; was it TAB ?
2503    CAC0  D0 06        	BNE	LAB_18B7		; if not go do SPC
2504    
2505    					; calculate TAB offset
2506    CAC2  8A           	TXA				; copy integer value to A
2507    CAC3  E5 0E        	SBC	TPos			; subtract terminal position
2508    CAC5  90 0A        	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
2509    
2510    					; print A spaces
2511    LAB_18B6
2512    CAC7  AA           	TAX				; copy result to X
2513    LAB_18B7
2514    CAC8  8A           	TXA				; set flags on size for SPC
2515    CAC9  F0 06        	BEQ	LAB_18BD		; branch if result was = $0, already here
2516    
2517    					; print X spaces
2518    LAB_18BA
2519    CACB  20 EC CA     	JSR	LAB_18E0		; print " "
2520    CACE  CA           	DEX				; decrement count
2521    CACF  D0 FA        	BNE	LAB_18BA		; loop if not all done
2522    
2523    					; continue with PRINT processing
2524    LAB_18BD
2525    CAD1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
2526    CAD4  D0 85        	BNE	LAB_1831		; if more to print go do it
2527    
2528    CAD6  60           	RTS
2529    
2530    ; print null terminated string from memory
2531    
2532    LAB_18C3
2533    CAD7  20 48 D3     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
2534    
2535    ; print string from Sutill/Sutilh
2536    
2537    LAB_18C6
2538    CADA  20 42 D5     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
2539    					; space returns with A = length, X=$71=pointer low byte,
2540    					; Y=$72=pointer high byte
2541    CADD  A0 00        	LDY	#$00			; reset index
2542    CADF  AA           	TAX				; copy length to X
2543    CAE0  F0 49        	BEQ	LAB_188C		; exit (RTS) if null string
2544    
2545    LAB_18CD
2546    
2547    CAE2  B1 71        	LDA	(ut1_pl),Y		; get next byte
2548    CAE4  20 F1 CA     	JSR	LAB_PRNA		; go print the character
2549    CAE7  C8           	INY				; increment index
2550    CAE8  CA           	DEX				; decrement count
2551    CAE9  D0 F7        	BNE	LAB_18CD		; loop if not done yet
2552    
2553    CAEB  60           	RTS
2554    
2555    					; Print single format character
2556    ; print " "
2557    
2558    LAB_18E0
2559    CAEC  A9 20        	LDA	#$20			; load " "
2560    	.byte	$2C			; change next line to BIT LAB_3FA9
2561    
2562    ; print "?" character
2563    
2564    LAB_18E3
2565    CAEF  A9 3F        	LDA	#$3F			; load "?" character
2566    
2567    ; print character in A
2568    ; now includes the null handler
2569    ; also includes infinite line length code
2570    ; note! some routines expect this one to exit with Zb=0
2571    
2572    LAB_PRNA
2573    CAF1  C9 20        	CMP	#' '			; compare with " "
2574    CAF3  90 19        	BCC	LAB_18F9		; branch if less (non printing)
2575    
2576    					; else printable character
2577    CAF5  48           	PHA				; save the character
2578    
2579    ; don't check fit if terminal width byte is zero
2580    
2581    CAF6  A5 0F        	LDA	TWidth		; get terminal width
2582    CAF8  D0 0A        	BNE	LAB_18F0		; branch if not zero (not infinite length)
2583    
2584    ; is "infinite line" so check TAB position
2585    
2586    CAFA  A5 0E        	LDA	TPos			; get position
2587    CAFC  E5 64        	SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
2588    CAFE  D0 0B        	BNE	LAB_18F7		; skip reset if different
2589    
2590    CB00  85 0E        	STA	TPos			; else reset position
2591    CB02  F0 07        	BEQ	LAB_18F7		; go print character
2592    
2593    LAB_18F0
2594    CB04  C5 0E        	CMP	TPos			; compare with terminal character position
2595    CB06  D0 03        	BNE	LAB_18F7		; branch if not at end of line
2596    
2597    CB08  20 96 CA     	JSR	LAB_CRLF		; else print CR/LF
2598    LAB_18F7
2599    CB0B  E6 0E        	INC	TPos			; increment terminal position
2600    CB0D  68           	PLA				; get character back
2601    LAB_18F9
2602    CB0E  20 F1 E2     	JSR	V_OUTP		; output byte via output vector
2603    CB11  C9 0D        	CMP	#$0D			; compare with [CR]
2604    CB13  D0 14        	BNE	LAB_188A		; branch if not [CR]
2605    
2606    					; else print nullct nulls after the [CR]
2607    CB15  86 78        	STX	TempB			; save buffer index
2608    CB17  A6 0D        	LDX	Nullct		; get null count
2609    CB19  F0 0A        	BEQ	LAB_1886		; branch if no nulls
2610    
2611    CB1B  A9 00        	LDA	#$00			; load [NULL]
2612    LAB_1880
2613    CB1D  20 F1 CA     	JSR	LAB_PRNA		; go print the character
2614    CB20  CA           	DEX				; decrement count
2615    CB21  D0 FA        	BNE	LAB_1880		; loop if not all done
2616    
2617    CB23  A9 0D        	LDA	#$0D			; restore the character (and set the flags)
2618    LAB_1886
2619    CB25  86 0E        	STX	TPos			; clear terminal position (X always = zero when we get here)
2620    CB27  A6 78        	LDX	TempB			; restore buffer index
2621    LAB_188A
2622    CB29  29 FF        	AND	#$FF			; set the flags
2623    LAB_188C
2624    CB2B  60           	RTS
2625    
2626    ; handle bad input data
2627    
2628    LAB_1904
2629    CB2C  A5 62        	LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
2630    CB2E  10 0B        	BPL	LAB_1913		; branch if INPUT (go do redo)
2631    
2632    CB30  A5 8D        	LDA	Dlinel		; get current DATA line low byte
2633    CB32  A4 8E        	LDY	Dlineh		; get current DATA line high byte
2634    CB34  85 87        	STA	Clinel		; save current line low byte
2635    CB36  84 88        	STY	Clineh		; save current line high byte
2636    LAB_1910
2637    CB38  4C 06 CE     	JMP	LAB_SNER		; do syntax error then warm start
2638    
2639    					; mode was INPUT
2640    LAB_1913
2641    CB3B  A9 27        	LDA	#<LAB_REDO		; point to redo message (low addr)
2642    CB3D  A0 EA        	LDY	#>LAB_REDO		; point to redo message (high addr)
2643    CB3F  20 D7 CA     	JSR	LAB_18C3		; print null terminated string from memory
2644    CB42  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
2645    CB44  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
2646    CB46  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
2647    CB48  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
2648    CB4A  60           	RTS
2649    
2650    ; perform INPUT
2651    
2652    LAB_INPUT
2653    CB4B  C9 22        	CMP	#$22			; compare next byte with open quote
2654    CB4D  D0 0B        	BNE	LAB_1934		; branch if no prompt string
2655    
2656    CB4F  20 C2 CD     	JSR	LAB_1BC1		; print "..." string
2657    CB52  A9 3B        	LDA	#$3B			; load A with ";"
2658    CB54  20 F5 CD     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
2659    CB57  20 DA CA     	JSR	LAB_18C6		; print string from Sutill/Sutilh
2660    
2661    					; done with prompt, now get data
2662    LAB_1934
2663    CB5A  20 6E D2     	JSR	LAB_CKRN		; check not Direct, back here if ok
2664    CB5D  20 44 C4     	JSR	LAB_INLN		; print "? " and get BASIC input
2665    CB60  A9 00        	LDA	#$00			; set mode = INPUT
2666    CB62  CD 9D 03     	CMP	Ibuffs		; test first byte in buffer
2667    CB65  D0 0A        	BNE	LAB_1953		; branch if not null input
2668    
2669    CB67  18           	CLC				; was null input so clear carry to exit program
2670    CB68  4C 30 C7     	JMP	LAB_1647		; go do BREAK exit
2671    
2672    ; perform READ
2673    
2674    LAB_READ
2675    CB6B  A6 8F        	LDX	Dptrl			; get DATA pointer low byte
2676    CB6D  A4 90        	LDY	Dptrh			; get DATA pointer high byte
2677    CB6F  A9 80        	LDA	#$80			; set mode = READ
2678    
2679    LAB_1953
2680    CB71  85 62        	STA	Imode			; set input mode flag, $00=INPUT, $80=READ
2681    CB73  86 91        	STX	Rdptrl		; save READ pointer low byte
2682    CB75  84 92        	STY	Rdptrh		; save READ pointer high byte
2683    
2684    					; READ or INPUT next variable from list
2685    LAB_195B
2686    CB77  20 AE CF     	JSR	LAB_GVAR		; get (var) address
2687    CB7A  85 97        	STA	Lvarpl		; save address low byte
2688    CB7C  84 98        	STY	Lvarph		; save address high byte
2689    CB7E  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
2690    CB80  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
2691    CB82  85 11        	STA	Itempl		; save as temporary integer low byte
2692    CB84  84 12        	STY	Itemph		; save as temporary integer high byte
2693    CB86  A6 91        	LDX	Rdptrl		; get READ pointer low byte
2694    CB88  A4 92        	LDY	Rdptrh		; get READ pointer high byte
2695    CB8A  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
2696    CB8C  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
2697    CB8E  20 C2 00     	JSR	LAB_GBYT		; scan memory
2698    CB91  D0 11        	BNE	LAB_1988		; branch if not null
2699    
2700    					; pointer was to null entry
2701    CB93  24 62        	BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
2702    CB95  30 65        	BMI	LAB_19DD		; branch if READ
2703    
2704    					; mode was INPUT
2705    CB97  20 EF CA     	JSR	LAB_18E3		; print "?" character (double ? for extended input)
2706    CB9A  20 44 C4     	JSR	LAB_INLN		; print "? " and get BASIC input
2707    CB9D  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
2708    CB9F  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
2709    LAB_1985
2710    CBA1  20 C2 00     	JSR	LAB_GBYT		; scan memory
2711    LAB_1988
2712    CBA4  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
2713    CBA6  10 24        	BPL	LAB_19B0		; branch if numeric
2714    
2715    					; else get string
2716    CBA8  85 5B        	STA	Srchc			; save search character
2717    CBAA  C9 22        	CMP	#$22			; was it " ?
2718    CBAC  F0 07        	BEQ	LAB_1999		; branch if so
2719    
2720    CBAE  A9 3A        	LDA	#':'			; else search character is ":"
2721    CBB0  85 5B        	STA	Srchc			; set new search character
2722    CBB2  A9 2C        	LDA	#','			; other search character is ","
2723    CBB4  18           	CLC				; clear carry for add
2724    LAB_1999
2725    CBB5  85 5C        	STA	Asrch			; set second search character
2726    CBB7  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
2727    CBB9  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
2728    
2729    CBBB  69 00        	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
2730    CBBD  90 01        	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
2731    
2732    CBBF  C8           	INY				; else increment high byte
2733    LAB_19A4
2734    CBC0  20 4E D3     	JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
2735    CBC3  20 D3 D6     	JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
2736    CBC6  20 D4 C9     	JSR	LAB_17D5		; go do string LET
2737    CBC9  4C D2 CB     	JMP	LAB_19B6		; go check string terminator
2738    
2739    					; get numeric INPUT
2740    LAB_19B0
2741    CBCC  20 AA DB     	JSR	LAB_2887		; get FAC1 from string
2742    CBCF  20 A7 DA     	JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
2743    LAB_19B6
2744    CBD2  20 C2 00     	JSR	LAB_GBYT		; scan memory
2745    CBD5  F0 0A        	BEQ	LAB_19C5		; branch if null (last entry)
2746    
2747    CBD7  C9 2C        	CMP	#','			; else compare with ","
2748    CBD9  F0 03        	BEQ	LAB_19C2		; branch if ","
2749    
2750    CBDB  4C 2C CB     	JMP	LAB_1904		; else go handle bad input data
2751    
2752    					; got good input data
2753    LAB_19C2
2754    CBDE  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
2755    LAB_19C5
2756    CBE1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
2757    CBE3  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
2758    CBE5  85 91        	STA	Rdptrl		; save for now
2759    CBE7  84 92        	STY	Rdptrh		; save for now
2760    CBE9  A5 11        	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
2761    CBEB  A4 12        	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
2762    CBED  85 C3        	STA	Bpntrl		; set BASIC execute pointer low byte
2763    CBEF  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
2764    CBF1  20 C2 00     	JSR	LAB_GBYT		; scan memory
2765    CBF4  F0 2C        	BEQ	LAB_1A03		; if null go do extra ignored message
2766    
2767    CBF6  20 02 CE     	JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
2768    CBF9  4C 77 CB     	JMP	LAB_195B		; go INPUT next variable from list
2769    
2770    					; find next DATA statement or do "Out of DATA" error
2771    LAB_19DD
2772    CBFC  20 A1 C8     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
2773    CBFF  C8           	INY				; increment index
2774    CC00  AA           	TAX				; copy character ([:] or [EOL])
2775    CC01  D0 12        	BNE	LAB_19F6		; branch if [:]
2776    
2777    CC03  A2 06        	LDX	#$06			; set for "Out of DATA" error
2778    CC05  C8           	INY				; increment index, now points to next line pointer high byte
2779    CC06  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
2780    CC08  F0 73        	BEQ	LAB_1A54		; branch if end (eventually does error X)
2781    
2782    CC0A  C8           	INY				; increment index
2783    CC0B  B1 C3        	LDA	(Bpntrl),Y		; get next line # low byte
2784    CC0D  85 8D        	STA	Dlinel		; save current DATA line low byte
2785    CC0F  C8           	INY				; increment index
2786    CC10  B1 C3        	LDA	(Bpntrl),Y		; get next line # high byte
2787    CC12  C8           	INY				; increment index
2788    CC13  85 8E        	STA	Dlineh		; save current DATA line high byte
2789    LAB_19F6
2790    CC15  B1 C3        	LDA	(Bpntrl),Y		; get byte
2791    CC17  C8           	INY				; increment index
2792    CC18  AA           	TAX				; copy to X
2793    CC19  20 93 C8     	JSR	LAB_170F		; set BASIC execute pointer
2794    CC1C  E0 83        	CPX	#TK_DATA		; compare with "DATA" token
2795    CC1E  F0 81        	BEQ	LAB_1985		; was "DATA" so go do next READ
2796    
2797    CC20  D0 DA        	BNE	LAB_19DD		; go find next statement if not "DATA"
2798    
2799    ; end of INPUT/READ routine
2800    
2801    LAB_1A03
2802    CC22  A5 91        	LDA	Rdptrl		; get temp READ pointer low byte
2803    CC24  A4 92        	LDY	Rdptrh		; get temp READ pointer high byte
2804    CC26  A6 62        	LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
2805    CC28  10 03        	BPL	LAB_1A0E		; branch if INPUT
2806    
2807    CC2A  4C 52 C7     	JMP	LAB_1624		; save AY as DATA pointer and return
2808    
2809    					; we were getting INPUT
2810    LAB_1A0E
2811    CC2D  A0 00        	LDY	#$00			; clear index
2812    CC2F  B1 91        	LDA	(Rdptrl),Y		; get next byte
2813    CC31  D0 01        	BNE	LAB_1A1B		; error if not end of INPUT
2814    
2815    CC33  60           	RTS
2816    
2817    					; user typed too much
2818    LAB_1A1B
2819    CC34  A9 16        	LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
2820    CC36  A0 EA        	LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
2821    CC38  4C D7 CA     	JMP	LAB_18C3		; print null terminated string from memory and return
2822    
2823    ; search the stack for FOR activity
2824    ; exit with z=1 if FOR else exit with z=0
2825    
2826    LAB_11A1
2827    CC3B  BA           	TSX				; copy stack pointer
2828    CC3C  E8           	INX				; +1 pass return address
2829    CC3D  E8           	INX				; +2 pass return address
2830    CC3E  E8           	INX				; +3 pass calling routine return address
2831    CC3F  E8           	INX				; +4 pass calling routine return address
2832    LAB_11A6
2833    CC40  BD 01 01     	LDA	LAB_STAK+1,X	; get token byte from stack
2834    CC43  C9 81        	CMP	#TK_FOR		; is it FOR token
2835    CC45  D0 21        	BNE	LAB_11CE		; exit if not FOR token
2836    
2837    					; was FOR token
2838    CC47  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
2839    CC49  D0 0A        	BNE	LAB_11BB		; branch if not null
2840    
2841    CC4B  BD 02 01     	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
2842    CC4E  85 97        	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
2843    CC50  BD 03 01     	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
2844    CC53  85 98        	STA	Frnxth		; save var pointer for FOR/NEXT high byte
2845    LAB_11BB
2846    CC55  DD 03 01     	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
2847    CC58  D0 07        	BNE	LAB_11C7		; branch if no match
2848    
2849    CC5A  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
2850    CC5C  DD 02 01     	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
2851    CC5F  F0 07        	BEQ	LAB_11CE		; exit if match found
2852    
2853    LAB_11C7
2854    CC61  8A           	TXA				; copy index
2855    CC62  18           	CLC				; clear carry for add
2856    CC63  69 10        	ADC	#$10			; add FOR stack use size
2857    CC65  AA           	TAX				; copy back to index
2858    CC66  D0 D8        	BNE	LAB_11A6		; loop if not at start of stack
2859    
2860    LAB_11CE
2861    CC68  60           	RTS
2862    
2863    ; perform NEXT
2864    
2865    LAB_NEXT
2866    CC69  D0 04        	BNE	LAB_1A46		; branch if NEXT var
2867    
2868    CC6B  A0 00        	LDY	#$00			; else clear Y
2869    CC6D  F0 03        	BEQ	LAB_1A49		; branch always (no variable to search for)
2870    
2871    ; NEXT var
2872    
2873    LAB_1A46
2874    CC6F  20 AE CF     	JSR	LAB_GVAR		; get variable address
2875    LAB_1A49
2876    CC72  85 97        	STA	Frnxtl		; store variable pointer low byte
2877    CC74  84 98        	STY	Frnxth		; store variable pointer high byte
2878    					; (both cleared if no variable defined)
2879    CC76  20 3B CC     	JSR	LAB_11A1		; search the stack for FOR activity
2880    CC79  F0 04        	BEQ	LAB_1A56		; branch if found
2881    
2882    CC7B  A2 00        	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
2883    LAB_1A54
2884    CC7D  F0 63        	BEQ	LAB_1ABE		; do error #X, then warm start
2885    
2886    LAB_1A56
2887    CC7F  9A           	TXS				; set stack pointer, X set by search, dumps return addresses
2888    
2889    CC80  8A           	TXA				; copy stack pointer
2890    CC81  38           	SEC				; set carry for subtract
2891    CC82  E9 F7        	SBC	#$F7			; point to TO var
2892    CC84  85 73        	STA	ut2_pl		; save pointer to TO var for compare
2893    CC86  69 FB        	ADC	#$FB			; point to STEP var
2894    
2895    CC88  A0 01        	LDY	#>LAB_STAK		; point to stack page high byte
2896    CC8A  20 81 DA     	JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
2897    CC8D  BA           	TSX				; get stack pointer back
2898    CC8E  BD 08 01     	LDA	LAB_STAK+8,X	; get step sign
2899    CC91  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
2900    CC93  A5 97        	LDA	Frnxtl		; get FOR variable pointer low byte
2901    CC95  A4 98        	LDY	Frnxth		; get FOR variable pointer high byte
2902    CC97  20 C2 D7     	JSR	LAB_246C		; add (FOR variable) to FAC1
2903    CC9A  20 A7 DA     	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
2904    CC9D  A0 01        	LDY	#>LAB_STAK		; point to stack page high byte
2905    CC9F  20 1D DB     	JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
2906    CCA2  BA           	TSX				; get stack pointer back
2907    CCA3  DD 08 01     	CMP	LAB_STAK+8,X	; compare step sign
2908    CCA6  F0 17        	BEQ	LAB_1A9B		; branch if = (loop complete)
2909    
2910    					; loop back and do it all again
2911    CCA8  BD 0D 01     	LDA	LAB_STAK+$0D,X	; get FOR line low byte
2912    CCAB  85 87        	STA	Clinel		; save current line low byte
2913    CCAD  BD 0E 01     	LDA	LAB_STAK+$0E,X	; get FOR line high byte
2914    CCB0  85 88        	STA	Clineh		; save current line high byte
2915    CCB2  BD 10 01     	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
2916    CCB5  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
2917    CCB7  BD 0F 01     	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
2918    CCBA  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
2919    LAB_1A98
2920    CCBC  4C C0 C6     	JMP	LAB_15C2		; go do interpreter inner loop
2921    
2922    					; loop complete so carry on
2923    LAB_1A9B
2924    CCBF  8A           	TXA				; stack copy to A
2925    CCC0  69 0F        	ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
2926    CCC2  AA           	TAX				; copy back to index
2927    CCC3  9A           	TXS				; copy to stack pointer
2928    CCC4  20 C2 00     	JSR	LAB_GBYT		; scan memory
2929    CCC7  C9 2C        	CMP	#','			; compare with ","
2930    CCC9  D0 F1        	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
2931    
2932    					; was "," so another NEXT variable to do
2933    CCCB  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
2934    CCCE  20 6F CC     	JSR	LAB_1A46		; do NEXT (var)
2935    
2936    ; evaluate expression and check is numeric, else do type mismatch
2937    
2938    LAB_EVNM
2939    CCD1  20 E5 CC     	JSR	LAB_EVEX		; evaluate expression
2940    
2941    ; check if source is numeric, else do type mismatch
2942    
2943    LAB_CTNM
2944    CCD4  18           	CLC				; destination is numeric
2945    	.byte	$24			; makes next line BIT $38
2946    
2947    ; check if source is string, else do type mismatch
2948    
2949    LAB_CTST
2950    CCD6  38           	SEC				; required type is string
2951    
2952    ; type match check, set C for string, clear C for numeric
2953    
2954    LAB_CKTM
2955    CCD7  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
2956    CCD9  30 03        	BMI	LAB_1ABA		; branch if data type is string
2957    
2958    					; else data type was numeric
2959    CCDB  B0 03        	BCS	LAB_1ABC		; if required type is string do type mismatch error
2960    LAB_1AB9
2961    CCDD  60           	RTS
2962    
2963    					; data type was string, now check required type
2964    LAB_1ABA
2965    CCDE  B0 FD        	BCS	LAB_1AB9		; exit if required type is string
2966    
2967    					; else do type mismatch error
2968    LAB_1ABC
2969    CCE0  A2 18        	LDX	#$18			; error code $18 ("Type mismatch" error)
2970    LAB_1ABE
2971    CCE2  4C 40 C3     	JMP	LAB_XERR		; do error #X, then warm start
2972    
2973    ; evaluate expression
2974    
2975    LAB_EVEX
2976    CCE5  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
2977    CCE7  D0 02        	BNE	LAB_1AC7		; skip next if not zero
2978    
2979    CCE9  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
2980    LAB_1AC7
2981    CCEB  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
2982    
2983    LAB_EVEZ
2984    CCED  A9 00        	LDA	#$00			; set null precedence (flag done)
2985    LAB_1ACC
2986    CCEF  48           	PHA				; push precedence byte
2987    CCF0  A9 02        	LDA	#$02			; 2 bytes
2988    CCF2  20 07 C3     	JSR	LAB_1212		; check room on stack for A bytes
2989    CCF5  20 D1 CD     	JSR	LAB_GVAL		; get value from line
2990    CCF8  A9 00        	LDA	#$00			; clear A
2991    CCFA  85 9B        	STA	comp_f		; clear compare function flag
2992    LAB_1ADB
2993    CCFC  20 C2 00     	JSR	LAB_GBYT		; scan memory
2994    LAB_1ADE
2995    CCFF  38           	SEC				; set carry for subtract
2996    CD00  E9 C1        	SBC	#TK_GT		; subtract token for > (lowest comparison function)
2997    CD02  90 17        	BCC	LAB_1AFA		; branch if < TK_GT
2998    
2999    CD04  C9 03        	CMP	#$03			; compare with ">" to "<" tokens
3000    CD06  B0 13        	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
3001    
3002    					; was token for > = or < (A = 0, 1 or 2)
3003    CD08  C9 01        	CMP	#$01			; compare with token for =
3004    CD0A  2A           	ROL				; *2, b0 = carry (=1 if token was = or <)
3005    					; (A = 0, 3 or 5)
3006    CD0B  49 01        	EOR	#$01			; toggle b0
3007    					; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
3008    CD0D  45 9B        	EOR	comp_f		; EOR with compare function flag bits
3009    CD0F  C5 9B        	CMP	comp_f		; compare with compare function flag
3010    CD11  90 67        	BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
3011    					; was more than one <, = or >)
3012    
3013    CD13  85 9B        	STA	comp_f		; save new compare function flag
3014    CD15  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
3015    CD18  4C FF CC     	JMP	LAB_1ADE		; go do next character
3016    
3017    					; token is < ">" or > "<" tokens
3018    LAB_1AFA
3019    CD1B  A6 9B        	LDX	comp_f		; get compare function flag
3020    CD1D  D0 2C        	BNE	LAB_1B2A		; branch if compare function
3021    
3022    CD1F  B0 79        	BCS	LAB_1B78		; go do functions
3023    
3024    					; else was <  TK_GT so is operator or lower
3025    CD21  69 0A        	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
3026    CD23  90 75        	BCC	LAB_1B78		; branch if < + operator
3027    
3028    					; carry was set so token was +, -, *, /, ^, AND, OR or EOR
3029    CD25  D0 07        	BNE	LAB_1B0B		; branch if not + token
3030    
3031    CD27  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
3032    CD29  10 03        	BPL	LAB_1B0B		; branch if not string
3033    
3034    					; will only be $00 if type is string and token was +
3035    CD2B  4C D8 D4     	JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
3036    					; is in line, and return
3037    
3038    LAB_1B0B
3039    CD2E  85 71        	STA	ut1_pl		; save it
3040    CD30  0A           	ASL				; *2
3041    CD31  65 71        	ADC	ut1_pl		; *3
3042    CD33  A8           	TAY				; copy to index
3043    LAB_1B13
3044    CD34  68           	PLA				; pull previous precedence
3045    CD35  D9 F7 E4     	CMP	LAB_OPPT,Y		; compare with precedence byte
3046    CD38  B0 65        	BCS	LAB_1B7D		; branch if A >=
3047    
3048    CD3A  20 D4 CC     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
3049    LAB_1B1C
3050    CD3D  48           	PHA				; save precedence
3051    LAB_1B1D
3052    CD3E  20 66 CD     	JSR	LAB_1B43		; get vector, execute function then continue evaluation
3053    CD41  68           	PLA				; restore precedence
3054    CD42  A4 99        	LDY	prstk			; get precedence stacked flag
3055    CD44  10 19        	BPL	LAB_1B3C		; branch if stacked values
3056    
3057    CD46  AA           	TAX				; copy precedence (set flags)
3058    CD47  F0 76        	BEQ	LAB_1B9D		; exit if done
3059    
3060    CD49  D0 5D        	BNE	LAB_1B86		; else pop FAC2 and return, branch always
3061    
3062    LAB_1B2A
3063    CD4B  26 5F        	ROL	Dtypef		; shift data type flag into Cb
3064    CD4D  8A           	TXA				; copy compare function flag
3065    CD4E  85 5F        	STA	Dtypef		; clear data type flag, X is 0xxx xxxx
3066    CD50  2A           	ROL				; shift data type into compare function byte b0
3067    CD51  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
3068    CD53  D0 02        	BNE	LAB_1B34		; branch if no underflow
3069    
3070    CD55  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
3071    LAB_1B34
3072    CD57  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
3073      000C             TK_LT_PLUS	= TK_LT-TK_PLUS
3074    CD59  A0 24        	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
3075    CD5B  85 9B        	STA	comp_f		; save new compare function flag
3076    CD5D  D0 D5        	BNE	LAB_1B13		; branch always
3077    
3078    LAB_1B3C
3079    CD5F  D9 F7 E4     	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
3080    CD62  B0 44        	BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
3081    
3082    CD64  90 D7        	BCC	LAB_1B1C		; branch always
3083    
3084    ;.get vector, execute function then continue evaluation
3085    
3086    LAB_1B43
3087    CD66  B9 F9 E4     	LDA	LAB_OPPT+2,Y	; get function vector high byte
3088    CD69  48           	PHA				; onto stack
3089    CD6A  B9 F8 E4     	LDA	LAB_OPPT+1,Y	; get function vector low byte
3090    CD6D  48           	PHA				; onto stack
3091    					; now push sign, round FAC1 and put on stack
3092    CD6E  20 7D CD     	JSR	LAB_1B5B		; function will return here, then the next RTS will call
3093    					; the function
3094    CD71  A5 9B        	LDA	comp_f		; get compare function flag
3095    CD73  48           	PHA				; push compare evaluation byte
3096    CD74  B9 F7 E4     	LDA	LAB_OPPT,Y		; get precedence byte
3097    CD77  4C EF CC     	JMP	LAB_1ACC		; continue evaluating expression
3098    
3099    LAB_1B53
3100    CD7A  4C 06 CE     	JMP	LAB_SNER		; do syntax error then warm start
3101    
3102    ; push sign, round FAC1 and put on stack
3103    
3104    LAB_1B5B
3105    CD7D  68           	PLA				; get return addr low byte
3106    CD7E  85 71        	STA	ut1_pl		; save it
3107    CD80  E6 71        	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
3108    					; note! no check is made on the high byte! if the calling
3109    					; routine assembles to a page edge then this all goes
3110    					; horribly wrong !!!
3111    CD82  68           	PLA				; get return addr high byte
3112    CD83  85 72        	STA	ut1_ph		; save it
3113    CD85  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
3114    CD87  48           	PHA				; push sign
3115    
3116    ; round FAC1 and put on stack
3117    
3118    LAB_1B66
3119    CD88  20 DD DA     	JSR	LAB_27BA		; round FAC1
3120    CD8B  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
3121    CD8D  48           	PHA				; push on stack
3122    CD8E  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
3123    CD90  48           	PHA				; push on stack
3124    CD91  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
3125    CD93  48           	PHA				; push on stack
3126    CD94  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
3127    CD96  48           	PHA				; push on stack
3128    CD97  6C 71 00     	JMP	(ut1_pl)		; return, sort of
3129    
3130    ; do functions
3131    
3132    LAB_1B78
3133    CD9A  A0 FF        	LDY	#$FF			; flag function
3134    CD9C  68           	PLA				; pull precedence byte
3135    LAB_1B7B
3136    CD9D  F0 20        	BEQ	LAB_1B9D		; exit if done
3137    
3138    LAB_1B7D
3139    CD9F  C9 64        	CMP	#$64			; compare previous precedence with $64
3140    CDA1  F0 03        	BEQ	LAB_1B84		; branch if was $64 (< function)
3141    
3142    CDA3  20 D4 CC     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
3143    LAB_1B84
3144    CDA6  84 99        	STY	prstk			; save precedence stacked flag
3145    
3146    					; pop FAC2 and return
3147    LAB_1B86
3148    CDA8  68           	PLA				; pop byte
3149    CDA9  4A           	LSR				; shift out comparison evaluation lowest bit
3150    CDAA  85 63        	STA	Cflag			; save comparison evaluation flag
3151    CDAC  68           	PLA				; pop exponent
3152    CDAD  85 B3        	STA	FAC2_e		; save FAC2 exponent
3153    CDAF  68           	PLA				; pop mantissa1
3154    CDB0  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
3155    CDB2  68           	PLA				; pop mantissa2
3156    CDB3  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
3157    CDB5  68           	PLA				; pop mantissa3
3158    CDB6  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
3159    CDB8  68           	PLA				; pop sign
3160    CDB9  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
3161    CDBB  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
3162    CDBD  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
3163    LAB_1B9D
3164    CDBF  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
3165    CDC1  60           	RTS
3166    
3167    ; print "..." string to string util area
3168    
3169    LAB_1BC1
3170    CDC2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
3171    CDC4  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
3172    CDC6  69 00        	ADC	#$00			; add carry to low byte
3173    CDC8  90 01        	BCC	LAB_1BCA		; branch if no overflow
3174    
3175    CDCA  C8           	INY				; increment high byte
3176    LAB_1BCA
3177    CDCB  20 48 D3     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
3178    CDCE  4C D3 D6     	JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
3179    
3180    ; get value from line
3181    
3182    LAB_GVAL
3183    CDD1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
3184    CDD4  B0 03        	BCS	LAB_1BAC		; branch if not numeric character
3185    
3186    					; else numeric string found (e.g. 123)
3187    LAB_1BA9
3188    CDD6  4C AA DB     	JMP	LAB_2887		; get FAC1 from string and return
3189    
3190    ; get value from line .. continued
3191    
3192    					; wasn't a number so ..
3193    LAB_1BAC
3194    CDD9  AA           	TAX				; set the flags
3195    CDDA  30 2F        	BMI	LAB_1BD0		; if -ve go test token values
3196    
3197    					; else it is either a string, number, variable or (<expr>)
3198    CDDC  C9 24        	CMP	#'$'			; compare with "$"
3199    CDDE  F0 F6        	BEQ	LAB_1BA9		; branch if "$", hex number
3200    
3201    CDE0  C9 25        	CMP	#'%'			; else compare with "%"
3202    CDE2  F0 F2        	BEQ	LAB_1BA9		; branch if "%", binary number
3203    
3204    CDE4  C9 2E        	CMP	#'.'			; compare with "."
3205    CDE6  F0 EE        	BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
3206    
3207    					; it wasn't any sort of number so ..
3208    CDE8  C9 22        	CMP	#$22			; compare with "
3209    CDEA  F0 D6        	BEQ	LAB_1BC1		; branch if open quote
3210    
3211    					; wasn't any sort of number so ..
3212    
3213    ; evaluate expression within parentheses
3214    
3215    CDEC  C9 28        	CMP	#'('			; compare with "("
3216    CDEE  D0 4F        	BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
3217    
3218    LAB_1BF7
3219    CDF0  20 ED CC     	JSR	LAB_EVEZ		; evaluate expression, no decrement
3220    
3221    ; all the "scan for" routines return the character after the sought character
3222    
3223    ; scan for ")" , else do syntax error then warm start
3224    
3225    LAB_1BFB
3226    CDF3  A9 29        	LDA	#$29			; load A with ")"
3227    
3228    ; scan for CHR$(A) , else do syntax error then warm start
3229    
3230    LAB_SCCA
3231    CDF5  A0 00        	LDY	#$00			; clear index
3232    CDF7  D1 C3        	CMP	(Bpntrl),Y		; check next byte is = A
3233    CDF9  D0 0B        	BNE	LAB_SNER		; if not do syntax error then warm start
3234    
3235    CDFB  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then return
3236    
3237    ; scan for "(" , else do syntax error then warm start
3238    
3239    LAB_1BFE
3240    CDFE  A9 28        	LDA	#$28			; load A with "("
3241    CE00  D0 F3        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
3242    					; (branch always)
3243    
3244    ; scan for "," , else do syntax error then warm start
3245    
3246    LAB_1C01
3247    CE02  A9 2C        	LDA	#$2C			; load A with ","
3248    CE04  D0 EF        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
3249    					; (branch always)
3250    
3251    ; syntax error then warm start
3252    
3253    LAB_SNER
3254    CE06  A2 02        	LDX	#$02			; error code $02 ("Syntax" error)
3255    CE08  4C 40 C3     	JMP	LAB_XERR		; do error #X, then warm start
3256    
3257    ; get value from line .. continued
3258    ; do tokens
3259    
3260    LAB_1BD0
3261    CE0B  C9 B8        	CMP	#TK_MINUS		; compare with token for -
3262    CE0D  F0 29        	BEQ	LAB_1C11		; branch if - token (do set-up for functions)
3263    
3264    					; wasn't -n so ..
3265    CE0F  C9 B7        	CMP	#TK_PLUS		; compare with token for +
3266    CE11  F0 BE        	BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
3267    
3268    CE13  C9 B2        	CMP	#TK_NOT		; compare with token for NOT
3269    CE15  D0 13        	BNE	LAB_1BE7		; branch if not token for NOT
3270    
3271    					; was NOT token
3272      000B             TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
3273    CE17  A0 21        	LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
3274    CE19  D0 1F        	BNE	LAB_1C13		; do set-up for function then execute (branch always)
3275    
3276    ; do = compare
3277    
3278    LAB_EQUAL
3279    CE1B  20 AA D0     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
3280    CE1E  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
3281    CE20  49 FF        	EOR	#$FF			; invert it
3282    CE22  A8           	TAY				; copy it
3283    CE23  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
3284    CE25  49 FF        	EOR	#$FF			; invert it
3285    CE27  4C 5D D2     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
3286    
3287    ; get value from line .. continued
3288    
3289    					; wasn't +, -, or NOT so ..
3290    LAB_1BE7
3291    CE2A  C9 AF        	CMP	#TK_FN		; compare with token for FN
3292    CE2C  D0 03        	BNE	LAB_1BEE		; branch if not token for FN
3293    
3294    CE2E  4C B8 D2     	JMP	LAB_201E		; go evaluate FNx
3295    
3296    ; get value from line .. continued
3297    
3298    					; wasn't +, -, NOT or FN so ..
3299    LAB_1BEE
3300    CE31  E9 C4        	SBC	#TK_SGN		; subtract with token for SGN
3301    CE33  B0 19        	BCS	LAB_1C27		; if a function token go do it
3302    
3303    CE35  4C 06 CE     	JMP	LAB_SNER		; else do syntax error
3304    
3305    ; set-up for functions
3306    
3307    LAB_1C11
3308      000A             TK_GT_PLUS	= TK_GT-TK_PLUS
3309    CE38  A0 1E        	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
3310    LAB_1C13
3311    CE3A  68           	PLA				; dump return address low byte
3312    CE3B  68           	PLA				; dump return address high byte
3313    CE3C  4C 3E CD     	JMP	LAB_1B1D		; execute function then continue evaluation
3314    
3315    ; variable name set-up
3316    ; get (var), return value in FAC_1 and $ flag
3317    
3318    LAB_1C18
3319    CE3F  20 AE CF     	JSR	LAB_GVAR		; get (var) address
3320    CE42  85 AE        	STA	FAC1_2		; save address low byte in FAC1 mantissa2
3321    CE44  84 AF        	STY	FAC1_3		; save address high byte in FAC1 mantissa3
3322    CE46  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
3323    CE48  30 03        	BMI	LAB_1C25		; if string then return (does RTS)
3324    
3325    LAB_1C24
3326    CE4A  4C 81 DA     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
3327    
3328    LAB_1C25
3329    CE4D  60           	RTS
3330    
3331    ; get value from line .. continued
3332    ; only functions left so ..
3333    
3334    ; set up function references
3335    
3336    ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
3337    ; to process function calls. now the function vector is computed and pushed on the stack
3338    ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
3339    ; is calculated and the routine called, if not this routine just does RTS. whichever
3340    ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
3341    ; the function code
3342    
3343    ; this also removes some less than elegant code that was used to bypass type checking
3344    ; for functions that returned strings
3345    
3346    LAB_1C27
3347    CE4E  0A           	ASL				; *2 (2 bytes per function address)
3348    CE4F  A8           	TAY				; copy to index
3349    
3350    CE50  B9 B2 E4     	LDA	LAB_FTBM,Y		; get function jump vector high byte
3351    CE53  48           	PHA				; push functions jump vector high byte
3352    CE54  B9 B1 E4     	LDA	LAB_FTBL,Y		; get function jump vector low byte
3353    CE57  48           	PHA				; push functions jump vector low byte
3354    
3355    CE58  B9 6C E4     	LDA	LAB_FTPM,Y		; get function pre process vector high byte
3356    CE5B  F0 05        	BEQ	LAB_1C56		; skip pre process if null vector
3357    
3358    CE5D  48           	PHA				; push functions pre process vector high byte
3359    CE5E  B9 6B E4     	LDA	LAB_FTPL,Y		; get function pre process vector low byte
3360    CE61  48           	PHA				; push functions pre process vector low byte
3361    
3362    LAB_1C56
3363    CE62  60           	RTS				; do function, or pre process, call
3364    
3365    ; process string expression in parenthesis
3366    
3367    LAB_PPFS
3368    CE63  20 F0 CD     	JSR	LAB_1BF7		; process expression in parenthesis
3369    CE66  4C D6 CC     	JMP	LAB_CTST		; check if source is string then do function,
3370    					; else do type mismatch
3371    
3372    ; process numeric expression in parenthesis
3373    
3374    LAB_PPFN
3375    CE69  20 F0 CD     	JSR	LAB_1BF7		; process expression in parenthesis
3376    CE6C  4C D4 CC     	JMP	LAB_CTNM		; check if source is numeric then do function,
3377    					; else do type mismatch
3378    
3379    ; set numeric data type and increment BASIC execute pointer
3380    
3381    LAB_PPBI
3382    CE6F  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
3383    CE71  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then do function
3384    
3385    ; process string for LEFT$, RIGHT$ or MID$
3386    
3387    LAB_LRMS
3388    CE74  20 ED CC     	JSR	LAB_EVEZ		; evaluate (should be string) expression
3389    CE77  20 02 CE     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
3390    CE7A  20 D6 CC     	JSR	LAB_CTST		; check if source is string, else do type mismatch
3391    
3392    CE7D  68           	PLA				; get function jump vector low byte
3393    CE7E  AA           	TAX				; save functions jump vector low byte
3394    CE7F  68           	PLA				; get function jump vector high byte
3395    CE80  A8           	TAY				; save functions jump vector high byte
3396    CE81  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
3397    CE83  48           	PHA				; push string pointer high byte
3398    CE84  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
3399    CE86  48           	PHA				; push string pointer low byte
3400    CE87  98           	TYA				; get function jump vector high byte back
3401    CE88  48           	PHA				; save functions jump vector high byte
3402    CE89  8A           	TXA				; get function jump vector low byte back
3403    CE8A  48           	PHA				; save functions jump vector low byte
3404    CE8B  20 90 D6     	JSR	LAB_GTBY		; get byte parameter
3405    CE8E  8A           	TXA				; copy byte parameter to A
3406    CE8F  60           	RTS				; go do function
3407    
3408    ; process numeric expression(s) for BIN$ or HEX$
3409    
3410    LAB_BHSS
3411    CE90  20 ED CC     	JSR	LAB_EVEZ		; process expression
3412    CE93  20 D4 CC     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
3413    CE96  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
3414    CE98  C9 98        	CMP	#$98			; compare with exponent = 2^24
3415    CE9A  B0 20        	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
3416    
3417    CE9C  20 54 DB     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
3418    CE9F  A2 02        	LDX	#$02			; 3 bytes to do
3419    LAB_CFAC
3420    CEA1  B5 AD        	LDA	FAC1_1,X		; get byte from FAC1
3421    CEA3  95 11        	STA	nums_1,X		; save byte to temp
3422    CEA5  CA           	DEX				; decrement index
3423    CEA6  10 F9        	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
3424    
3425    CEA8  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
3426    CEAB  A2 00        	LDX	#$00			; set default to no leading "0"s
3427    CEAD  C9 29        	CMP	#')'			; compare with close bracket
3428    CEAF  F0 0A        	BEQ	LAB_1C54		; if ")" go do rest of function
3429    
3430    CEB1  20 E2 D6     	JSR	LAB_SCGB		; scan for "," and get byte
3431    CEB4  20 C2 00     	JSR	LAB_GBYT		; get last byte back
3432    CEB7  C9 29        	CMP	#')'			; is next character )
3433    CEB9  D0 01        	BNE	LAB_BHER		; if not ")" go do error
3434    
3435    LAB_1C54
3436    CEBB  60           	RTS				; else do function
3437    
3438    LAB_BHER
3439    CEBC  4C 2D D1     	JMP	LAB_FCER		; do function call error then warm start
3440    
3441    ; perform EOR
3442    
3443    ; added operator format is the same as AND or OR, precedence is the same as OR
3444    
3445    ; this bit worked first time but it took a while to sort out the operator table
3446    ; pointers and offsets afterwards!
3447    
3448    LAB_EOR
3449    CEBF  20 E6 CE     	JSR	GetFirst		; get first integer expression (no sign check)
3450    CEC2  45 5B        	EOR	XOAw_l		; EOR with expression 1 low byte
3451    CEC4  A8           	TAY				; save in Y
3452    CEC5  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
3453    CEC7  45 5C        	EOR	XOAw_h		; EOR with expression 1 high byte
3454    CEC9  4C 5D D2     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
3455    
3456    ; perform OR
3457    
3458    LAB_OR
3459    CECC  20 E6 CE     	JSR	GetFirst		; get first integer expression (no sign check)
3460    CECF  05 5B        	ORA	XOAw_l		; OR with expression 1 low byte
3461    CED1  A8           	TAY				; save in Y
3462    CED2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
3463    CED4  05 5C        	ORA	XOAw_h		; OR with expression 1 high byte
3464    CED6  4C 5D D2     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
3465    
3466    ; perform AND
3467    
3468    LAB_AND
3469    CED9  20 E6 CE     	JSR	GetFirst		; get first integer expression (no sign check)
3470    CEDC  25 5B        	AND	XOAw_l		; AND with expression 1 low byte
3471    CEDE  A8           	TAY				; save in Y
3472    CEDF  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
3473    CEE1  25 5C        	AND	XOAw_h		; AND with expression 1 high byte
3474    CEE3  4C 5D D2     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
3475    
3476    ; get first value for OR, AND or EOR
3477    
3478    GetFirst
3479    CEE6  20 AA D0     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
3480    CEE9  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
3481    CEEB  85 5C        	STA	XOAw_h		; save it
3482    CEED  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
3483    CEEF  85 5B        	STA	XOAw_l		; save it
3484    CEF1  20 C7 D7     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
3485    CEF4  20 AA D0     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
3486    CEF7  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
3487    LAB_1C95
3488    CEF9  60           	RTS
3489    
3490    ; perform comparisons
3491    
3492    ; do < compare
3493    
3494    LAB_LTHAN
3495    CEFA  20 D7 CC     	JSR	LAB_CKTM		; type match check, set C for string
3496    CEFD  B0 13        	BCS	LAB_1CAE		; branch if string
3497    
3498    					; do numeric < compare
3499    CEFF  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
3500    CF01  09 7F        	ORA	#$7F			; set all non sign bits
3501    CF03  25 B4        	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
3502    CF05  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
3503    CF07  A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
3504    CF09  A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
3505    CF0B  20 1B DB     	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
3506    CF0E  AA           	TAX				; copy result
3507    CF0F  4C 43 CF     	JMP	LAB_1CE1		; go evaluate result
3508    
3509    					; do string < compare
3510    LAB_1CAE
3511    CF12  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
3512    CF14  C6 9B        	DEC	comp_f		; clear < bit in compare function flag
3513    CF16  20 42 D5     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
3514    					; space returns with A = length, X=pointer low byte,
3515    					; Y=pointer high byte
3516    CF19  85 AC        	STA	str_ln		; save length
3517    CF1B  86 AD        	STX	str_pl		; save string pointer low byte
3518    CF1D  84 AE        	STY	str_ph		; save string pointer high byte
3519    CF1F  A5 B5        	LDA	FAC2_2		; get descriptor pointer low byte
3520    CF21  A4 B6        	LDY	FAC2_3		; get descriptor pointer high byte
3521    CF23  20 46 D5     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
3522    					; returns with A = length, X=pointer low byte,
3523    					; Y=pointer high byte
3524    CF26  86 B5        	STX	FAC2_2		; save string pointer low byte
3525    CF28  84 B6        	STY	FAC2_3		; save string pointer high byte
3526    CF2A  AA           	TAX				; copy length
3527    CF2B  38           	SEC				; set carry for subtract
3528    CF2C  E5 AC        	SBC	str_ln		; subtract string 1 length
3529    CF2E  F0 08        	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
3530    
3531    CF30  A9 01        	LDA	#$01			; set str 1 length > string 2 length
3532    CF32  90 04        	BCC	LAB_1CD6		; branch if so
3533    
3534    CF34  A6 AC        	LDX	str_ln		; get string 1 length
3535    CF36  A9 FF        	LDA	#$FF			; set str 1 length < string 2 length
3536    LAB_1CD6
3537    CF38  85 B0        	STA	FAC1_s		; save length compare
3538    CF3A  A0 FF        	LDY	#$FF			; set index
3539    CF3C  E8           	INX				; adjust for loop
3540    LAB_1CDB
3541    CF3D  C8           	INY				; increment index
3542    CF3E  CA           	DEX				; decrement count
3543    CF3F  D0 07        	BNE	LAB_1CE6		; branch if still bytes to do
3544    
3545    CF41  A6 B0        	LDX	FAC1_s		; get length compare back
3546    LAB_1CE1
3547    CF43  30 0F        	BMI	LAB_1CF2		; branch if str 1 < str 2
3548    
3549    CF45  18           	CLC				; flag str 1 <= str 2
3550    CF46  90 0C        	BCC	LAB_1CF2		; go evaluate result
3551    
3552    LAB_1CE6
3553    CF48  B1 B5        	LDA	(FAC2_2),Y		; get string 2 byte
3554    CF4A  D1 AD        	CMP	(FAC1_1),Y		; compare with string 1 byte
3555    CF4C  F0 EF        	BEQ	LAB_1CDB		; loop if bytes =
3556    
3557    CF4E  A2 FF        	LDX	#$FF			; set str 1 < string 2
3558    CF50  B0 02        	BCS	LAB_1CF2		; branch if so
3559    
3560    CF52  A2 01        	LDX	#$01			;  set str 1 > string 2
3561    LAB_1CF2
3562    CF54  E8           	INX				; x = 0, 1 or 2
3563    CF55  8A           	TXA				; copy to A
3564    CF56  2A           	ROL				; *2 (1, 2 or 4)
3565    CF57  25 63        	AND	Cflag			; AND with comparison evaluation flag
3566    CF59  F0 02        	BEQ	LAB_1CFB		; branch if 0 (compare is false)
3567    
3568    CF5B  A9 FF        	LDA	#$FF			; else set result true
3569    LAB_1CFB
3570    CF5D  4C FE DA     	JMP	LAB_27DB		; save A as integer byte and return
3571    
3572    LAB_1CFE
3573    CF60  20 02 CE     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
3574    
3575    ; perform DIM
3576    
3577    LAB_DIM
3578    CF63  AA           	TAX				; copy "DIM" flag to X
3579    CF64  20 B3 CF     	JSR	LAB_1D10		; search for variable
3580    CF67  20 C2 00     	JSR	LAB_GBYT		; scan memory
3581    CF6A  D0 F4        	BNE	LAB_1CFE		; scan for "," and loop if not null
3582    
3583    CF6C  60           	RTS
3584    
3585    ; perform << (left shift)
3586    
3587    LAB_LSHIFT
3588    CF6D  20 A3 CF     	JSR	GetPair		; get integer expression and byte (no sign check)
3589    CF70  A5 AE        	LDA	FAC1_2		; get expression high byte
3590    CF72  A6 78        	LDX	TempB			; get shift count
3591    CF74  F0 22        	BEQ	NoShift		; branch if zero
3592    
3593    CF76  E0 10        	CPX	#$10			; compare bit count with 16d
3594    CF78  B0 23        	BCS	TooBig		; branch if >=
3595    
3596    Ls_loop
3597    CF7A  06 AF        	ASL	FAC1_3		; shift low byte
3598    CF7C  2A           	ROL				; shift high byte
3599    CF7D  CA           	DEX				; decrement bit count
3600    CF7E  D0 FA        	BNE	Ls_loop		; loop if shift not complete
3601    
3602    CF80  A4 AF        	LDY	FAC1_3		; get expression low byte
3603    CF82  4C 5D D2     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
3604    
3605    ; perform >> (right shift)
3606    
3607    LAB_RSHIFT
3608    CF85  20 A3 CF     	JSR	GetPair		; get integer expression and byte (no sign check)
3609    CF88  A5 AE        	LDA	FAC1_2		; get expression high byte
3610    CF8A  A6 78        	LDX	TempB			; get shift count
3611    CF8C  F0 0A        	BEQ	NoShift		; branch if zero
3612    
3613    CF8E  E0 10        	CPX	#$10			; compare bit count with 16d
3614    CF90  B0 0B        	BCS	TooBig		; branch if >=
3615    
3616    Rs_loop
3617    CF92  4A           	LSR				; shift high byte
3618    CF93  66 AF        	ROR	FAC1_3		; shift low byte
3619    CF95  CA           	DEX				; decrement bit count
3620    CF96  D0 FA        	BNE	Rs_loop		; loop if shift not complete
3621    
3622    NoShift
3623    CF98  A4 AF        	LDY	FAC1_3		; get expression low byte
3624    CF9A  4C 5D D2     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
3625    
3626    TooBig
3627    CF9D  A9 00        	LDA	#$00			; clear high byte
3628    CF9F  A8           	TAY				; copy to low byte
3629    CFA0  4C 5D D2     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
3630    
3631    GetPair
3632    CFA3  20 93 D6     	JSR	LAB_EVBY		; evaluate byte expression, result in X
3633    CFA6  86 78        	STX	TempB			; save it
3634    CFA8  20 C7 D7     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
3635    CFAB  4C AA D0     	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
3636    
3637    ; search for variable
3638    
3639    ; return pointer to variable in Cvaral/Cvarah
3640    
3641    LAB_GVAR
3642    CFAE  A2 00        	LDX	#$00			; set DIM flag = $00
3643    CFB0  20 C2 00     	JSR	LAB_GBYT		; scan memory (1st character)
3644    LAB_1D10
3645    CFB3  86 5E        	STX	Defdim		; save DIM flag
3646    LAB_1D12
3647    CFB5  85 93        	STA	Varnm1		; save 1st character
3648    CFB7  29 7F        	AND	#$7F			; clear FN flag bit
3649    CFB9  20 22 D0     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
3650    CFBC  B0 03        	BCS	LAB_1D1F		; branch if ok
3651    
3652    CFBE  4C 06 CE     	JMP	LAB_SNER		; else syntax error then warm start
3653    
3654    					; was variable name so ..
3655    LAB_1D1F
3656    CFC1  A2 00        	LDX	#$00			; clear 2nd character temp
3657    CFC3  86 5F        	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
3658    CFC5  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (2nd character)
3659    CFC8  90 05        	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
3660    
3661    					; 2nd character wasn't "0" to "9" so ..
3662    CFCA  20 22 D0     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
3663    CFCD  90 0B        	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
3664    
3665    LAB_1D2D
3666    CFCF  AA           	TAX				; copy 2nd character
3667    
3668    					; ignore further (valid) characters in the variable name
3669    LAB_1D2E
3670    CFD0  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (3rd character)
3671    CFD3  90 FB        	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
3672    
3673    CFD5  20 22 D0     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
3674    CFD8  B0 F6        	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
3675    
3676    					; check if string variable
3677    LAB_1D38
3678    CFDA  C9 24        	CMP	#'$'			; compare with "$"
3679    CFDC  D0 0B        	BNE	LAB_1D47		; branch if not string
3680    
3681    ; to introduce a new variable type (% suffix for integers say) then this branch
3682    ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
3683    
3684    					; type is string
3685    CFDE  A9 FF        	LDA	#$FF			; set data type = string
3686    CFE0  85 5F        	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
3687    CFE2  8A           	TXA				; get 2nd character back
3688    CFE3  09 80        	ORA	#$80			; set top bit (indicate string var)
3689    CFE5  AA           	TAX				; copy back to 2nd character temp
3690    CFE6  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
3691    
3692    ; after we have determined the variable type we need to come back here to determine
3693    ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
3694    
3695    
3696    LAB_1D47				; gets here with character after var name in A
3697    CFE9  86 94        	STX	Varnm2		; save 2nd character
3698    CFEB  05 61        	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
3699    CFED  C9 28        	CMP	#'('			; compare with "("
3700    CFEF  D0 03        	BNE	LAB_1D53		; branch if not "("
3701    
3702    CFF1  4C BC D0     	JMP	LAB_1E17		; go find, or make, array
3703    
3704    ; either find or create var
3705    ; var name (1st two characters only!) is in Varnm1,Varnm2
3706    
3707    					; variable name wasn't var(... so look for plain var
3708    LAB_1D53
3709    CFF4  A9 00        	LDA	#$00			; clear A
3710    CFF6  85 61        	STA	Sufnxf		; clear subscript/FNX flag
3711    CFF8  A5 7B        	LDA	Svarl			; get start of vars low byte
3712    CFFA  A6 7C        	LDX	Svarh			; get start of vars high byte
3713    CFFC  A0 00        	LDY	#$00			; clear index
3714    LAB_1D5D
3715    CFFE  86 AB        	STX	Vrschh		; save search address high byte
3716    LAB_1D5F
3717    D000  85 AA        	STA	Vrschl		; save search address low byte
3718    D002  E4 7E        	CPX	Sarryh		; compare high address with var space end
3719    D004  D0 04        	BNE	LAB_1D69		; skip next compare if <>
3720    
3721    					; high addresses were = so compare low addresses
3722    D006  C5 7D        	CMP	Sarryl		; compare low address with var space end
3723    D008  F0 2C        	BEQ	LAB_1D8B		; if not found go make new var
3724    
3725    LAB_1D69
3726    D00A  A5 93        	LDA	Varnm1		; get 1st character of var to find
3727    D00C  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 1st character
3728    D00E  D0 08        	BNE	LAB_1D77		; branch if no match
3729    
3730    					; 1st characters match so compare 2nd characters
3731    D010  A5 94        	LDA	Varnm2		; get 2nd character of var to find
3732    D012  C8           	INY				; index to point to variable name 2nd character
3733    D013  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 2nd character
3734    D015  F0 69        	BEQ	LAB_1DD7		; branch if match (found var)
3735    
3736    D017  88           	DEY				; else decrement index (now = $00)
3737    LAB_1D77
3738    D018  18           	CLC				; clear carry for add
3739    D019  A5 AA        	LDA	Vrschl		; get search address low byte
3740    D01B  69 06        	ADC	#$06			; +6 (offset to next var name)
3741    D01D  90 E1        	BCC	LAB_1D5F		; loop if no overflow to high byte
3742    
3743    D01F  E8           	INX				; else increment high byte
3744    D020  D0 DC        	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
3745    
3746    ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
3747    
3748    LAB_CASC
3749    D022  C9 61        	CMP	#'a'			; compare with "a"
3750    D024  B0 0A        	BCS	LAB_1D83		; go check <"z"+1
3751    
3752    ; check byte, return C=0 if<"A" or >"Z"
3753    
3754    LAB_1D82
3755    D026  C9 41        	CMP	#'A'			; compare with "A"
3756    D028  90 05        	BCC	LAB_1D8A		; exit if less
3757    
3758    					; carry is set
3759    D02A  E9 5B        	SBC	#$5B			; subtract "Z"+1
3760    D02C  38           	SEC				; set carry
3761    D02D  E9 A5        	SBC	#$A5			; subtract $A5 (restore byte)
3762    					; carry clear if byte>$5A
3763    LAB_1D8A
3764    D02F  60           	RTS
3765    
3766    LAB_1D83
3767    D030  E9 7B        	SBC	#$7B			; subtract "z"+1
3768    D032  38           	SEC				; set carry
3769    D033  E9 85        	SBC	#$85			; subtract $85 (restore byte)
3770    					; carry clear if byte>$7A
3771    D035  60           	RTS
3772    
3773    					; reached end of variable mem without match
3774    					; .. so create new variable
3775    LAB_1D8B
3776    D036  68           	PLA				; pop return address low byte
3777    D037  48           	PHA				; push return address low byte
3778      CE41             LAB_1C18p2	= LAB_1C18+2
3779    D038  C9 41        	CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
3780    D03A  D0 05        	BNE	LAB_1D98		; if not get (var) go create new var
3781    
3782    ; This will only drop through if the call was from LAB_1C18 and is only called
3783    ; from there if it is searching for a variable from the RHS of a LET a=b statement
3784    ; it prevents the creation of variables not assigned a value.
3785    
3786    ; value returned by this is either numeric zero (exponent byte is $00) or null string
3787    ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
3788    
3789    ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
3790    
3791    ; this is where you would put the undefined variable error call e.g.
3792    
3793    ;					; variable doesn't exist so flag error
3794    ;	LDX	#$24			; error code $24 ("undefined variable" error)
3795    ;	JMP	LAB_XERR		; do error #X then warm start
3796    
3797    ; the above code has been tested and works a treat! (it replaces the three code lines
3798    ; below)
3799    
3800    					; else return dummy null value
3801    D03C  A9 ED        	LDA	#<LAB_1D96		; low byte point to $00,$00
3802    					; (uses part of misc constants table)
3803    D03E  A0 E3        	LDY	#>LAB_1D96		; high byte point to $00,$00
3804    D040  60           	RTS
3805    
3806    					; create new numeric variable
3807    LAB_1D98
3808    D041  A5 7D        	LDA	Sarryl		; get var mem end low byte
3809    D043  A4 7E        	LDY	Sarryh		; get var mem end high byte
3810    D045  85 AA        	STA	Ostrtl		; save old block start low byte
3811    D047  84 AB        	STY	Ostrth		; save old block start high byte
3812    D049  A5 7F        	LDA	Earryl		; get array mem end low byte
3813    D04B  A4 80        	LDY	Earryh		; get array mem end high byte
3814    D04D  85 A6        	STA	Obendl		; save old block end low byte
3815    D04F  84 A7        	STY	Obendh		; save old block end high byte
3816    D051  18           	CLC				; clear carry for add
3817    D052  69 06        	ADC	#$06			; +6 (space for one var)
3818    D054  90 01        	BCC	LAB_1DAE		; branch if no overflow to high byte
3819    
3820    D056  C8           	INY				; else increment high byte
3821    LAB_1DAE
3822    D057  85 A4        	STA	Nbendl		; set new block end low byte
3823    D059  84 A5        	STY	Nbendh		; set new block end high byte
3824    D05B  20 C5 C2     	JSR	LAB_11CF		; open up space in memory
3825    D05E  A5 A4        	LDA	Nbendl		; get new start low byte
3826    D060  A4 A5        	LDY	Nbendh		; get new start high byte (-$100)
3827    D062  C8           	INY				; correct high byte
3828    D063  85 7D        	STA	Sarryl		; save new var mem end low byte
3829    D065  84 7E        	STY	Sarryh		; save new var mem end high byte
3830    D067  A0 00        	LDY	#$00			; clear index
3831    D069  A5 93        	LDA	Varnm1		; get var name 1st character
3832    D06B  91 AA        	STA	(Vrschl),Y		; save var name 1st character
3833    D06D  C8           	INY				; increment index
3834    D06E  A5 94        	LDA	Varnm2		; get var name 2nd character
3835    D070  91 AA        	STA	(Vrschl),Y		; save var name 2nd character
3836    D072  A9 00        	LDA	#$00			; clear A
3837    D074  C8           	INY				; increment index
3838    D075  91 AA        	STA	(Vrschl),Y		; initialise var byte
3839    D077  C8           	INY				; increment index
3840    D078  91 AA        	STA	(Vrschl),Y		; initialise var byte
3841    D07A  C8           	INY				; increment index
3842    D07B  91 AA        	STA	(Vrschl),Y		; initialise var byte
3843    D07D  C8           	INY				; increment index
3844    D07E  91 AA        	STA	(Vrschl),Y		; initialise var byte
3845    
3846    					; found a match for var ((Vrschl) = ptr)
3847    LAB_1DD7
3848    D080  A5 AA        	LDA	Vrschl		; get var address low byte
3849    D082  18           	CLC				; clear carry for add
3850    D083  69 02        	ADC	#$02			; +2 (offset past var name bytes)
3851    D085  A4 AB        	LDY	Vrschh		; get var address high byte
3852    D087  90 01        	BCC	LAB_1DE1		; branch if no overflow from add
3853    
3854    D089  C8           	INY				; else increment high byte
3855    LAB_1DE1
3856    D08A  85 95        	STA	Cvaral		; save current var address low byte
3857    D08C  84 96        	STY	Cvarah		; save current var address high byte
3858    D08E  60           	RTS
3859    
3860    ; set-up array pointer (Adatal/h) to first element in array
3861    ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
3862    
3863    LAB_1DE6
3864    D08F  A5 5D        	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
3865    D091  0A           	ASL				; *2 (also clears the carry !)
3866    D092  69 05        	ADC	#$05			; +5 (result is 7, 9 or 11 here)
3867    D094  65 AA        	ADC	Astrtl		; add array start pointer low byte
3868    D096  A4 AB        	LDY	Astrth		; get array pointer high byte
3869    D098  90 01        	BCC	LAB_1DF2		; branch if no overflow
3870    
3871    D09A  C8           	INY				; else increment high byte
3872    LAB_1DF2
3873    D09B  85 A4        	STA	Adatal		; save array data pointer low byte
3874    D09D  84 A5        	STY	Adatah		; save array data pointer high byte
3875    D09F  60           	RTS
3876    
3877    ; evaluate integer expression
3878    
3879    LAB_EVIN
3880    D0A0  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
3881    D0A3  20 D1 CC     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
3882    					; else do type mismatch
3883    
3884    ; evaluate integer expression (no check)
3885    
3886    LAB_EVPI
3887    D0A6  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
3888    D0A8  30 0D        	BMI	LAB_1E12		; do function call error if -ve
3889    
3890    ; evaluate integer expression (no sign check)
3891    
3892    LAB_EVIR
3893    D0AA  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
3894    D0AC  C9 90        	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
3895    D0AE  90 09        	BCC	LAB_1E14		; branch if n<2^16 (is ok)
3896    
3897    D0B0  A9 F4        	LDA	#<LAB_1DF7		; set pointer low byte to -32768
3898    D0B2  A0 E3        	LDY	#>LAB_1DF7		; set pointer high byte to -32768
3899    D0B4  20 1B DB     	JSR	LAB_27F8		; compare FAC1 with (AY)
3900    LAB_1E12
3901    D0B7  D0 74        	BNE	LAB_FCER		; if <> do function call error then warm start
3902    
3903    LAB_1E14
3904    D0B9  4C 54 DB     	JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
3905    
3906    ; find or make array
3907    
3908    LAB_1E17
3909    D0BC  A5 5E        	LDA	Defdim		; get DIM flag
3910    D0BE  48           	PHA				; push it
3911    D0BF  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
3912    D0C1  48           	PHA				; push it
3913    D0C2  A0 00        	LDY	#$00			; clear dimensions count
3914    
3915    ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
3916    
3917    LAB_1E1F
3918    D0C4  98           	TYA				; copy dimensions count
3919    D0C5  48           	PHA				; save it
3920    D0C6  A5 94        	LDA	Varnm2		; get array name 2nd byte
3921    D0C8  48           	PHA				; save it
3922    D0C9  A5 93        	LDA	Varnm1		; get array name 1st byte
3923    D0CB  48           	PHA				; save it
3924    D0CC  20 A0 D0     	JSR	LAB_EVIN		; evaluate integer expression
3925    D0CF  68           	PLA				; pull array name 1st byte
3926    D0D0  85 93        	STA	Varnm1		; restore array name 1st byte
3927    D0D2  68           	PLA				; pull array name 2nd byte
3928    D0D3  85 94        	STA	Varnm2		; restore array name 2nd byte
3929    D0D5  68           	PLA				; pull dimensions count
3930    D0D6  A8           	TAY				; restore it
3931    D0D7  BA           	TSX				; copy stack pointer
3932    D0D8  BD 02 01     	LDA	LAB_STAK+2,X	; get DIM flag
3933    D0DB  48           	PHA				; push it
3934    D0DC  BD 01 01     	LDA	LAB_STAK+1,X	; get data type flag
3935    D0DF  48           	PHA				; push it
3936    D0E0  A5 AE        	LDA	FAC1_2		; get this dimension size high byte
3937    D0E2  9D 02 01     	STA	LAB_STAK+2,X	; stack before flag bytes
3938    D0E5  A5 AF        	LDA	FAC1_3		; get this dimension size low byte
3939    D0E7  9D 01 01     	STA	LAB_STAK+1,X	; stack before flag bytes
3940    D0EA  C8           	INY				; increment dimensions count
3941    D0EB  20 C2 00     	JSR	LAB_GBYT		; scan memory
3942    D0EE  C9 2C        	CMP	#','			; compare with ","
3943    D0F0  F0 D2        	BEQ	LAB_1E1F		; if found go do next dimension
3944    
3945    D0F2  84 5D        	STY	Dimcnt		; store dimensions count
3946    D0F4  20 F3 CD     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
3947    D0F7  68           	PLA				; pull data type flag
3948    D0F8  85 5F        	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
3949    D0FA  68           	PLA				; pull DIM flag
3950    D0FB  85 5E        	STA	Defdim		; restore DIM flag
3951    D0FD  A6 7D        	LDX	Sarryl		; get array mem start low byte
3952    D0FF  A5 7E        	LDA	Sarryh		; get array mem start high byte
3953    
3954    ; now check to see if we are at the end of array memory (we would be if there were
3955    ; no arrays).
3956    
3957    LAB_1E5C
3958    D101  86 AA        	STX	Astrtl		; save as array start pointer low byte
3959    D103  85 AB        	STA	Astrth		; save as array start pointer high byte
3960    D105  C5 80        	CMP	Earryh		; compare with array mem end high byte
3961    D107  D0 04        	BNE	LAB_1E68		; branch if not reached array mem end
3962    
3963    D109  E4 7F        	CPX	Earryl		; else compare with array mem end low byte
3964    D10B  F0 39        	BEQ	LAB_1EA1		; go build array if not found
3965    
3966    					; search for array
3967    LAB_1E68
3968    D10D  A0 00        	LDY	#$00			; clear index
3969    D10F  B1 AA        	LDA	(Astrtl),Y		; get array name first byte
3970    D111  C8           	INY				; increment index to second name byte
3971    D112  C5 93        	CMP	Varnm1		; compare with this array name first byte
3972    D114  D0 06        	BNE	LAB_1E77		; branch if no match
3973    
3974    D116  A5 94        	LDA	Varnm2		; else get this array name second byte
3975    D118  D1 AA        	CMP	(Astrtl),Y		; compare with array name second byte
3976    D11A  F0 16        	BEQ	LAB_1E8D		; array found so branch
3977    
3978    					; no match
3979    LAB_1E77
3980    D11C  C8           	INY				; increment index
3981    D11D  B1 AA        	LDA	(Astrtl),Y		; get array size low byte
3982    D11F  18           	CLC				; clear carry for add
3983    D120  65 AA        	ADC	Astrtl		; add array start pointer low byte
3984    D122  AA           	TAX				; copy low byte to X
3985    D123  C8           	INY				; increment index
3986    D124  B1 AA        	LDA	(Astrtl),Y		; get array size high byte
3987    D126  65 AB        	ADC	Astrth		; add array mem pointer high byte
3988    D128  90 D7        	BCC	LAB_1E5C		; if no overflow go check next array
3989    
3990    ; do array bounds error
3991    
3992    LAB_1E85
3993    D12A  A2 10        	LDX	#$10			; error code $10 ("Array bounds" error)
3994    	.byte	$2C			; makes next bit BIT LAB_08A2
3995    
3996    ; do function call error
3997    
3998    LAB_FCER
3999    D12D  A2 08        	LDX	#$08			; error code $08 ("Function call" error)
4000    LAB_1E8A
4001    D12F  4C 40 C3     	JMP	LAB_XERR		; do error #X, then warm start
4002    
4003    					; found array, are we trying to dimension it?
4004    LAB_1E8D
4005    D132  A2 12        	LDX	#$12			; set error $12 ("Double dimension" error)
4006    D134  A5 5E        	LDA	Defdim		; get DIM flag
4007    D136  D0 F7        	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
4008    					; start
4009    
4010    ; found the array and we"re not dimensioning it so we must find an element in it
4011    
4012    D138  20 8F D0     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
4013    					; (Astrtl,Astrth points to start of array)
4014    D13B  A5 5D        	LDA	Dimcnt		; get dimensions count
4015    D13D  A0 04        	LDY	#$04			; set index to array's # of dimensions
4016    D13F  D1 AA        	CMP	(Astrtl),Y		; compare with no of dimensions
4017    D141  D0 E7        	BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
4018    					; dimensions" error here .. if we want a different
4019    					; error message
4020    
4021    D143  4C C9 D1     	JMP	LAB_1F28		; found array so go get element
4022    					; (could jump to LAB_1F28 as all LAB_1F24 does is take
4023    					; Dimcnt and save it at (Astrtl),Y which is already the
4024    					; same or we would have taken the BNE)
4025    
4026    					; array not found, so build it
4027    LAB_1EA1
4028    D146  20 8F D0     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
4029    					; (Astrtl,Astrth points to start of array)
4030    D149  20 0F C3     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
4031    					; addr to check is in AY (low/high)
4032    D14C  A0 00        	LDY	#$00			; clear Y (don't need to clear A)
4033    D14E  84 BB        	STY	Aspth			; clear array data size high byte
4034    D150  A5 93        	LDA	Varnm1		; get variable name 1st byte
4035    D152  91 AA        	STA	(Astrtl),Y		; save array name 1st byte
4036    D154  C8           	INY				; increment index
4037    D155  A5 94        	LDA	Varnm2		; get variable name 2nd byte
4038    D157  91 AA        	STA	(Astrtl),Y		; save array name 2nd byte
4039    D159  A5 5D        	LDA	Dimcnt		; get dimensions count
4040    D15B  A0 04        	LDY	#$04			; index to dimension count
4041    D15D  84 BA        	STY	Asptl			; set array data size low byte (four bytes per element)
4042    D15F  91 AA        	STA	(Astrtl),Y		; set array's dimensions count
4043    
4044    					; now calculate the size of the data space for the array
4045    D161  18           	CLC				; clear carry for add (clear on subsequent loops)
4046    LAB_1EC0
4047    D162  A2 0B        	LDX	#$0B			; set default dimension value low byte
4048    D164  A9 00        	LDA	#$00			; set default dimension value high byte
4049    D166  24 5E        	BIT	Defdim		; test default DIM flag
4050    D168  50 07        	BVC	LAB_1ED0		; branch if b6 of Defdim is clear
4051    
4052    D16A  68           	PLA				; else pull dimension value low byte
4053    D16B  69 01        	ADC	#$01			; +1 (allow for zeroeth element)
4054    D16D  AA           	TAX				; copy low byte to X
4055    D16E  68           	PLA				; pull dimension value high byte
4056    D16F  69 00        	ADC	#$00			; add carry from low byte
4057    
4058    LAB_1ED0
4059    D171  C8           	INY				; index to dimension value high byte
4060    D172  91 AA        	STA	(Astrtl),Y		; save dimension value high byte
4061    D174  C8           	INY				; index to dimension value high byte
4062    D175  8A           	TXA				; get dimension value low byte
4063    D176  91 AA        	STA	(Astrtl),Y		; save dimension value low byte
4064    D178  20 18 D2     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
4065    D17B  86 BA        	STX	Asptl			; save array data size low byte
4066    D17D  85 BB        	STA	Aspth			; save array data size high byte
4067    D17F  A4 71        	LDY	ut1_pl		; restore index (saved by subroutine)
4068    D181  C6 5D        	DEC	Dimcnt		; decrement dimensions count
4069    D183  D0 DD        	BNE	LAB_1EC0		; loop while not = 0
4070    
4071    D185  65 A5        	ADC	Adatah		; add size high byte to first element high byte
4072    					; (carry is always clear here)
4073    D187  B0 5D        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
4074    
4075    D189  85 A5        	STA	Adatah		; save end of array high byte
4076    D18B  A8           	TAY				; copy end high byte to Y
4077    D18C  8A           	TXA				; get array size low byte
4078    D18D  65 A4        	ADC	Adatal		; add array start low byte
4079    D18F  90 03        	BCC	LAB_1EF3		; branch if no carry
4080    
4081    D191  C8           	INY				; else increment end of array high byte
4082    D192  F0 52        	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
4083    
4084    					; set-up mostly complete, now zero the array
4085    LAB_1EF3
4086    D194  20 0F C3     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
4087    					; addr to check is in AY (low/high)
4088    D197  85 7F        	STA	Earryl		; save array mem end low byte
4089    D199  84 80        	STY	Earryh		; save array mem end high byte
4090    D19B  A9 00        	LDA	#$00			; clear byte for array clear
4091    D19D  E6 BB        	INC	Aspth			; increment array size high byte (now block count)
4092    D19F  A4 BA        	LDY	Asptl			; get array size low byte (now index to block)
4093    D1A1  F0 05        	BEQ	LAB_1F07		; branch if low byte = $00
4094    
4095    LAB_1F02
4096    D1A3  88           	DEY				; decrement index (do 0 to n-1)
4097    D1A4  91 A4        	STA	(Adatal),Y		; zero byte
4098    D1A6  D0 FB        	BNE	LAB_1F02		; loop until this block done
4099    
4100    LAB_1F07
4101    D1A8  C6 A5        	DEC	Adatah		; decrement array pointer high byte
4102    D1AA  C6 BB        	DEC	Aspth			; decrement block count high byte
4103    D1AC  D0 F5        	BNE	LAB_1F02		; loop until all blocks done
4104    
4105    D1AE  E6 A5        	INC	Adatah		; correct for last loop
4106    D1B0  38           	SEC				; set carry for subtract
4107    D1B1  A0 02        	LDY	#$02			; index to array size low byte
4108    D1B3  A5 7F        	LDA	Earryl		; get array mem end low byte
4109    D1B5  E5 AA        	SBC	Astrtl		; subtract array start low byte
4110    D1B7  91 AA        	STA	(Astrtl),Y		; save array size low byte
4111    D1B9  C8           	INY				; index to array size high byte
4112    D1BA  A5 80        	LDA	Earryh		; get array mem end high byte
4113    D1BC  E5 AB        	SBC	Astrth		; subtract array start high byte
4114    D1BE  91 AA        	STA	(Astrtl),Y		; save array size high byte
4115    D1C0  A5 5E        	LDA	Defdim		; get default DIM flag
4116    D1C2  D0 53        	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
4117    
4118    					; else, find element
4119    D1C4  C8           	INY				; index to # of dimensions
4120    
4121    LAB_1F24
4122    D1C5  B1 AA        	LDA	(Astrtl),Y		; get array's dimension count
4123    D1C7  85 5D        	STA	Dimcnt		; save it
4124    
4125    ; we have found, or built, the array. now we need to find the element
4126    
4127    LAB_1F28
4128    D1C9  A9 00        	LDA	#$00			; clear byte
4129    D1CB  85 BA        	STA	Asptl			; clear array data pointer low byte
4130    LAB_1F2C
4131    D1CD  85 BB        	STA	Aspth			; save array data pointer high byte
4132    D1CF  C8           	INY				; increment index (point to array bound high byte)
4133    D1D0  68           	PLA				; pull array index low byte
4134    D1D1  AA           	TAX				; copy to X
4135    D1D2  85 AE        	STA	FAC1_2		; save index low byte to FAC1 mantissa2
4136    D1D4  68           	PLA				; pull array index high byte
4137    D1D5  85 AF        	STA	FAC1_3		; save index high byte to FAC1 mantissa3
4138    D1D7  D1 AA        	CMP	(Astrtl),Y		; compare with array bound high byte
4139    D1D9  90 0E        	BCC	LAB_1F48		; branch if within bounds
4140    
4141    D1DB  D0 06        	BNE	LAB_1F42		; if outside bounds do array bounds error
4142    
4143    					; else high byte was = so test low bytes
4144    D1DD  C8           	INY				; index to array bound low byte
4145    D1DE  8A           	TXA				; get array index low byte
4146    D1DF  D1 AA        	CMP	(Astrtl),Y		; compare with array bound low byte
4147    D1E1  90 07        	BCC	LAB_1F49		; branch if within bounds
4148    
4149    LAB_1F42
4150    D1E3  4C 2A D1     	JMP	LAB_1E85		; else do array bounds error
4151    
4152    LAB_1F45
4153    D1E6  4C 3E C3     	JMP	LAB_OMER		; do "Out of memory" error then warm start
4154    
4155    LAB_1F48
4156    D1E9  C8           	INY				; index to array bound low byte
4157    LAB_1F49
4158    D1EA  A5 BB        	LDA	Aspth			; get array data pointer high byte
4159    D1EC  05 BA        	ORA	Asptl			; OR with array data pointer low byte
4160    D1EE  F0 0A        	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
4161    
4162    D1F0  20 18 D2     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
4163    D1F3  8A           	TXA				; get result low byte
4164    D1F4  65 AE        	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
4165    D1F6  AA           	TAX				; save result low byte
4166    D1F7  98           	TYA				; get result high byte
4167    D1F8  A4 71        	LDY	ut1_pl		; restore index
4168    LAB_1F5A
4169    D1FA  65 AF        	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
4170    D1FC  86 BA        	STX	Asptl			; save array data pointer low byte
4171    D1FE  C6 5D        	DEC	Dimcnt		; decrement dimensions count
4172    D200  D0 CB        	BNE	LAB_1F2C		; loop if dimensions still to do
4173    
4174    D202  06 BA        	ASL	Asptl			; array data pointer low byte * 2
4175    D204  2A           	ROL				; array data pointer high byte * 2
4176    D205  06 BA        	ASL	Asptl			; array data pointer low byte * 4
4177    D207  2A           	ROL				; array data pointer high byte * 4
4178    D208  A8           	TAY				; copy high byte
4179    D209  A5 BA        	LDA	Asptl			; get low byte
4180    D20B  65 A4        	ADC	Adatal		; add array data start pointer low byte
4181    D20D  85 95        	STA	Cvaral		; save as current var address low byte
4182    D20F  98           	TYA				; get high byte back
4183    D210  65 A5        	ADC	Adatah		; add array data start pointer high byte
4184    D212  85 96        	STA	Cvarah		; save as current var address high byte
4185    D214  A8           	TAY				; copy high byte to Y
4186    D215  A5 95        	LDA	Cvaral		; get current var address low byte
4187    LAB_1F7B
4188    D217  60           	RTS
4189    
4190    ; does XY = (Astrtl),Y * (Asptl)
4191    
4192    LAB_1F7C
4193    D218  84 71        	STY	ut1_pl		; save index
4194    D21A  B1 AA        	LDA	(Astrtl),Y		; get dimension size low byte
4195    D21C  85 76        	STA	dims_l		; save dimension size low byte
4196    D21E  88           	DEY				; decrement index
4197    D21F  B1 AA        	LDA	(Astrtl),Y		; get dimension size high byte
4198    D221  85 77        	STA	dims_h		; save dimension size high byte
4199    
4200    D223  A9 10        	LDA	#$10			; count = $10 (16 bit multiply)
4201    D225  85 A8        	STA	numbit		; save bit count
4202    D227  A2 00        	LDX	#$00			; clear result low byte
4203    D229  A0 00        	LDY	#$00			; clear result high byte
4204    LAB_1F8F
4205    D22B  8A           	TXA				; get result low byte
4206    D22C  0A           	ASL				; *2
4207    D22D  AA           	TAX				; save result low byte
4208    D22E  98           	TYA				; get result high byte
4209    D22F  2A           	ROL				; *2
4210    D230  A8           	TAY				; save result high byte
4211    D231  B0 B3        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
4212    
4213    D233  06 BA        	ASL	Asptl			; shift multiplier low byte
4214    D235  26 BB        	ROL	Aspth			; shift multiplier high byte
4215    D237  90 0B        	BCC	LAB_1FA8		; skip add if no carry
4216    
4217    D239  18           	CLC				; else clear carry for add
4218    D23A  8A           	TXA				; get result low byte
4219    D23B  65 76        	ADC	dims_l		; add dimension size low byte
4220    D23D  AA           	TAX				; save result low byte
4221    D23E  98           	TYA				; get result high byte
4222    D23F  65 77        	ADC	dims_h		; add dimension size high byte
4223    D241  A8           	TAY				; save result high byte
4224    D242  B0 A2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
4225    
4226    LAB_1FA8
4227    D244  C6 A8        	DEC	numbit		; decrement bit count
4228    D246  D0 E3        	BNE	LAB_1F8F		; loop until all done
4229    
4230    D248  60           	RTS
4231    
4232    ; perform FRE()
4233    
4234    LAB_FRE
4235    D249  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
4236    D24B  10 03        	BPL	LAB_1FB4		; branch if numeric
4237    
4238    D24D  20 42 D5     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
4239    					; space returns with A = length, X=$71=pointer low byte,
4240    					; Y=$72=pointer high byte
4241    
4242    					; FRE(n) was numeric so do this
4243    LAB_1FB4
4244    D250  20 E3 D3     	JSR	LAB_GARB		; go do garbage collection
4245    D253  38           	SEC				; set carry for subtract
4246    D254  A5 81        	LDA	Sstorl		; get bottom of string space low byte
4247    D256  E5 7F        	SBC	Earryl		; subtract array mem end low byte
4248    D258  A8           	TAY				; copy result to Y
4249    D259  A5 82        	LDA	Sstorh		; get bottom of string space high byte
4250    D25B  E5 80        	SBC	Earryh		; subtract array mem end high byte
4251    
4252    ; save and convert integer AY to FAC1
4253    
4254    LAB_AYFC
4255    D25D  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
4256    D25F  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
4257    D261  84 AE        	STY	FAC1_2		; save FAC1 mantissa2
4258    D263  A2 90        	LDX	#$90			; set exponent=2^16 (integer)
4259    D265  4C 06 DB     	JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
4260    
4261    ; perform POS()
4262    
4263    LAB_POS
4264    D268  A4 0E        	LDY	TPos			; get terminal position
4265    
4266    ; convert Y to byte in FAC1
4267    
4268    LAB_1FD0
4269    D26A  A9 00        	LDA	#$00			; clear high byte
4270    D26C  F0 EF        	BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
4271    
4272    ; check not Direct (used by DEF and INPUT)
4273    
4274    LAB_CKRN
4275    D26E  A6 88        	LDX	Clineh		; get current line high byte
4276    D270  E8           	INX				; increment it
4277    D271  D0 A4        	BNE	LAB_1F7B		; return if can continue not direct mode
4278    
4279    					; else do illegal direct error
4280    LAB_1FD9
4281    D273  A2 16        	LDX	#$16			; error code $16 ("Illegal direct" error)
4282    LAB_1FDB
4283    D275  4C 40 C3     	JMP	LAB_XERR		; go do error #X, then warm start
4284    
4285    ; perform DEF
4286    
4287    LAB_DEF
4288    D278  20 A9 D2     	JSR	LAB_200B		; check FNx syntax
4289    D27B  85 9C        	STA	func_l		; save function pointer low byte
4290    D27D  84 9D        	STY	func_h		; save function pointer high byte
4291    D27F  20 6E D2     	JSR	LAB_CKRN		; check not Direct (back here if ok)
4292    D282  20 FE CD     	JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
4293    D285  A9 80        	LDA	#$80			; set flag for FNx
4294    D287  85 61        	STA	Sufnxf		; save subscript/FNx flag
4295    D289  20 AE CF     	JSR	LAB_GVAR		; get (var) address
4296    D28C  20 D4 CC     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
4297    D28F  20 F3 CD     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
4298    D292  A9 C2        	LDA	#TK_EQUAL		; get = token
4299    D294  20 F5 CD     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
4300    D297  A5 96        	LDA	Cvarah		; get current var address high byte
4301    D299  48           	PHA				; push it
4302    D29A  A5 95        	LDA	Cvaral		; get current var address low byte
4303    D29C  48           	PHA				; push it
4304    D29D  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
4305    D29F  48           	PHA				; push it
4306    D2A0  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
4307    D2A2  48           	PHA				; push it
4308    D2A3  20 90 C8     	JSR	LAB_DATA		; go perform DATA
4309    D2A6  4C 18 D3     	JMP	LAB_207A		; put execute pointer and variable pointer into function
4310    					; and return
4311    
4312    ; check FNx syntax
4313    
4314    LAB_200B
4315    D2A9  A9 AF        	LDA	#TK_FN		; get FN" token
4316    D2AB  20 F5 CD     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
4317    					; return character after A
4318    D2AE  09 80        	ORA	#$80			; set FN flag bit
4319    D2B0  85 61        	STA	Sufnxf		; save FN flag so array variable test fails
4320    D2B2  20 B5 CF     	JSR	LAB_1D12		; search for FN variable
4321    D2B5  4C D4 CC     	JMP	LAB_CTNM		; check if source is numeric and return, else do type
4322    					; mismatch
4323    
4324    					; Evaluate FNx
4325    LAB_201E
4326    D2B8  20 A9 D2     	JSR	LAB_200B		; check FNx syntax
4327    D2BB  48           	PHA				; push function pointer low byte
4328    D2BC  98           	TYA				; copy function pointer high byte
4329    D2BD  48           	PHA				; push function pointer high byte
4330    D2BE  20 FE CD     	JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
4331    D2C1  20 E5 CC     	JSR	LAB_EVEX		; evaluate expression
4332    D2C4  20 F3 CD     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
4333    D2C7  20 D4 CC     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
4334    D2CA  68           	PLA				; pop function pointer high byte
4335    D2CB  85 9D        	STA	func_h		; restore it
4336    D2CD  68           	PLA				; pop function pointer low byte
4337    D2CE  85 9C        	STA	func_l		; restore it
4338    D2D0  A2 20        	LDX	#$20			; error code $20 ("Undefined function" error)
4339    D2D2  A0 03        	LDY	#$03			; index to variable pointer high byte
4340    D2D4  B1 9C        	LDA	(func_l),Y		; get variable pointer high byte
4341    D2D6  F0 9D        	BEQ	LAB_1FDB		; if zero go do undefined function error
4342    
4343    D2D8  85 96        	STA	Cvarah		; save variable address high byte
4344    D2DA  88           	DEY				; index to variable address low byte
4345    D2DB  B1 9C        	LDA	(func_l),Y		; get variable address low byte
4346    D2DD  85 95        	STA	Cvaral		; save variable address low byte
4347    D2DF  AA           	TAX				; copy address low byte
4348    
4349    					; now stack the function variable value before use
4350    D2E0  C8           	INY				; index to mantissa_3
4351    LAB_2043
4352    D2E1  B1 95        	LDA	(Cvaral),Y		; get byte from variable
4353    D2E3  48           	PHA				; stack it
4354    D2E4  88           	DEY				; decrement index
4355    D2E5  10 FA        	BPL	LAB_2043		; loop until variable stacked
4356    
4357    D2E7  A4 96        	LDY	Cvarah		; get variable address high byte
4358    D2E9  20 AB DA     	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
4359    					; (function variable), return Y=0, always
4360    D2EC  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
4361    D2EE  48           	PHA				; push it
4362    D2EF  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
4363    D2F1  48           	PHA				; push it
4364    D2F2  B1 9C        	LDA	(func_l),Y		; get function execute pointer low byte
4365    D2F4  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
4366    D2F6  C8           	INY				; index to high byte
4367    D2F7  B1 9C        	LDA	(func_l),Y		; get function execute pointer high byte
4368    D2F9  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
4369    D2FB  A5 96        	LDA	Cvarah		; get variable address high byte
4370    D2FD  48           	PHA				; push it
4371    D2FE  A5 95        	LDA	Cvaral		; get variable address low byte
4372    D300  48           	PHA				; push it
4373    D301  20 D1 CC     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
4374    					; else do type mismatch
4375    D304  68           	PLA				; pull variable address low byte
4376    D305  85 9C        	STA	func_l		; save variable address low byte
4377    D307  68           	PLA				; pull variable address high byte
4378    D308  85 9D        	STA	func_h		; save variable address high byte
4379    D30A  20 C2 00     	JSR	LAB_GBYT		; scan memory
4380    D30D  F0 03        	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
4381    
4382    D30F  4C 06 CE     	JMP	LAB_SNER		; else syntax error then warm start
4383    
4384    ; restore Bpntrl,Bpntrh and function variable from stack
4385    
4386    LAB_2074
4387    D312  68           	PLA				; pull BASIC execute pointer low byte
4388    D313  85 C3        	STA	Bpntrl		; restore BASIC execute pointer low byte
4389    D315  68           	PLA				; pull BASIC execute pointer high byte
4390    D316  85 C4        	STA	Bpntrh		; restore BASIC execute pointer high byte
4391    
4392    ; put execute pointer and variable pointer into function
4393    
4394    LAB_207A
4395    D318  A0 00        	LDY	#$00			; clear index
4396    D31A  68           	PLA				; pull BASIC execute pointer low byte
4397    D31B  91 9C        	STA	(func_l),Y		; save to function
4398    D31D  C8           	INY				; increment index
4399    D31E  68           	PLA				; pull BASIC execute pointer high byte
4400    D31F  91 9C        	STA	(func_l),Y		; save to function
4401    D321  C8           	INY				; increment index
4402    D322  68           	PLA				; pull current var address low byte
4403    D323  91 9C        	STA	(func_l),Y		; save to function
4404    D325  C8           	INY				; increment index
4405    D326  68           	PLA				; pull current var address high byte
4406    D327  91 9C        	STA	(func_l),Y		; save to function
4407    D329  60           	RTS
4408    
4409    ; perform STR$()
4410    
4411    LAB_STRS
4412    D32A  20 D4 CC     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
4413    D32D  20 99 DC     	JSR	LAB_296E		; convert FAC1 to string
4414    D330  A9 F0        	LDA	#<Decssp1		; set result string low pointer
4415    D332  A0 00        	LDY	#>Decssp1		; set result string high pointer
4416    D334  F0 12        	BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
4417    
4418    ; Do string vector
4419    ; copy des_pl/h to des_2l/h and make string space A bytes long
4420    
4421    LAB_209C
4422    D336  A6 AE        	LDX	des_pl		; get descriptor pointer low byte
4423    D338  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
4424    D33A  86 9E        	STX	des_2l		; save descriptor pointer low byte
4425    D33C  84 9F        	STY	des_2h		; save descriptor pointer high byte
4426    
4427    ; make string space A bytes long
4428    ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
4429    
4430    LAB_MSSP
4431    D33E  20 B1 D3     	JSR	LAB_2115		; make space in string memory for string A long
4432    					; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
4433    D341  86 AD        	STX	str_pl		; save string pointer low byte
4434    D343  84 AE        	STY	str_ph		; save string pointer high byte
4435    D345  85 AC        	STA	str_ln		; save length
4436    D347  60           	RTS
4437    
4438    ; Scan, set up string
4439    ; print " terminated string to Sutill/Sutilh
4440    
4441    LAB_20AE
4442    D348  A2 22        	LDX	#$22			; set terminator to "
4443    D34A  86 5B        	STX	Srchc			; set search character (terminator 1)
4444    D34C  86 5C        	STX	Asrch			; set terminator 2
4445    
4446    ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
4447    ; source is AY
4448    
4449    LAB_20B4
4450    D34E  85 B8        	STA	ssptr_l		; store string start low byte
4451    D350  84 B9        	STY	ssptr_h		; store string start high byte
4452    D352  85 AD        	STA	str_pl		; save string pointer low byte
4453    D354  84 AE        	STY	str_ph		; save string pointer high byte
4454    D356  A0 FF        	LDY	#$FF			; set length to -1
4455    LAB_20BE
4456    D358  C8           	INY				; increment length
4457    D359  B1 B8        	LDA	(ssptr_l),Y		; get byte from string
4458    D35B  F0 0C        	BEQ	LAB_20CF		; exit loop if null byte [EOS]
4459    
4460    D35D  C5 5B        	CMP	Srchc			; compare with search character (terminator 1)
4461    D35F  F0 04        	BEQ	LAB_20CB		; branch if terminator
4462    
4463    D361  C5 5C        	CMP	Asrch			; compare with terminator 2
4464    D363  D0 F3        	BNE	LAB_20BE		; loop if not terminator 2
4465    
4466    LAB_20CB
4467    D365  C9 22        	CMP	#$22			; compare with "
4468    D367  F0 01        	BEQ	LAB_20D0		; branch if " (carry set if = !)
4469    
4470    LAB_20CF
4471    D369  18           	CLC				; clear carry for add (only if [EOL] terminated string)
4472    LAB_20D0
4473    D36A  84 AC        	STY	str_ln		; save length in FAC1 exponent
4474    D36C  98           	TYA				; copy length to A
4475    D36D  65 B8        	ADC	ssptr_l		; add string start low byte
4476    D36F  85 BA        	STA	Sendl			; save string end low byte
4477    D371  A6 B9        	LDX	ssptr_h		; get string start high byte
4478    D373  90 01        	BCC	LAB_20DC		; branch if no low byte overflow
4479    
4480    D375  E8           	INX				; else increment high byte
4481    LAB_20DC
4482    D376  86 BB        	STX	Sendh			; save string end high byte
4483    D378  A5 B9        	LDA	ssptr_h		; get string start high byte
4484    D37A  C9 04        	CMP	#>Ram_base		; compare with start of program memory
4485    D37C  B0 0B        	BCS	LAB_RTST		; branch if not in utility area
4486    
4487    					; string in utility area, move to string memory
4488    D37E  98           	TYA				; copy length to A
4489    D37F  20 36 D3     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
4490    					; long
4491    D382  A6 B8        	LDX	ssptr_l		; get string start low byte
4492    D384  A4 B9        	LDY	ssptr_h		; get string start high byte
4493    D386  20 23 D5     	JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
4494    
4495    ; check for space on descriptor stack then ..
4496    ; put string address and length on descriptor stack and update stack pointers
4497    
4498    LAB_RTST
4499    D389  A6 65        	LDX	next_s		; get string stack pointer
4500    D38B  E0 71        	CPX	#des_sk+$09		; compare with max+1
4501    D38D  D0 05        	BNE	LAB_20F8		; branch if space on string stack
4502    
4503    					; else do string too complex error
4504    D38F  A2 1C        	LDX	#$1C			; error code $1C ("String too complex" error)
4505    LAB_20F5
4506    D391  4C 40 C3     	JMP	LAB_XERR		; do error #X, then warm start
4507    
4508    ; put string address and length on descriptor stack and update stack pointers
4509    
4510    LAB_20F8
4511    D394  A5 AC        	LDA	str_ln		; get string length
4512    D396  95 00        	STA	PLUS_0,X		; put on string stack
4513    D398  A5 AD        	LDA	str_pl		; get string pointer low byte
4514    D39A  95 01        	STA	PLUS_1,X		; put on string stack
4515    D39C  A5 AE        	LDA	str_ph		; get string pointer high byte
4516    D39E  95 02        	STA	PLUS_2,X		; put on string stack
4517    D3A0  A0 00        	LDY	#$00			; clear Y
4518    D3A2  86 AE        	STX	des_pl		; save string descriptor pointer low byte
4519    D3A4  84 AF        	STY	des_ph		; save string descriptor pointer high byte (always $00)
4520    D3A6  88           	DEY				; Y = $FF
4521    D3A7  84 5F        	STY	Dtypef		; save data type flag, $FF=string
4522    D3A9  86 66        	STX	last_sl		; save old stack pointer (current top item)
4523    D3AB  E8           	INX				; update stack pointer
4524    D3AC  E8           	INX				; update stack pointer
4525    D3AD  E8           	INX				; update stack pointer
4526    D3AE  86 65        	STX	next_s		; save new top item value
4527    D3B0  60           	RTS
4528    
4529    ; Build descriptor
4530    ; make space in string memory for string A long
4531    ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
4532    
4533    LAB_2115
4534    D3B1  46 60        	LSR	Gclctd		; clear garbage collected flag (b7)
4535    
4536    					; make space for string A long
4537    LAB_2117
4538    D3B3  48           	PHA				; save string length
4539    D3B4  49 FF        	EOR	#$FF			; complement it
4540    D3B6  38           	SEC				; set carry for subtract (twos comp add)
4541    D3B7  65 81        	ADC	Sstorl		; add bottom of string space low byte (subtract length)
4542    D3B9  A4 82        	LDY	Sstorh		; get bottom of string space high byte
4543    D3BB  B0 01        	BCS	LAB_2122		; skip decrement if no underflow
4544    
4545    D3BD  88           	DEY				; decrement bottom of string space high byte
4546    LAB_2122
4547    D3BE  C4 80        	CPY	Earryh		; compare with array mem end high byte
4548    D3C0  90 11        	BCC	LAB_2137		; do out of memory error if less
4549    
4550    D3C2  D0 04        	BNE	LAB_212C		; if not = skip next test
4551    
4552    D3C4  C5 7F        	CMP	Earryl		; compare with array mem end low byte
4553    D3C6  90 0B        	BCC	LAB_2137		; do out of memory error if less
4554    
4555    LAB_212C
4556    D3C8  85 81        	STA	Sstorl		; save bottom of string space low byte
4557    D3CA  84 82        	STY	Sstorh		; save bottom of string space high byte
4558    D3CC  85 83        	STA	Sutill		; save string utility ptr low byte
4559    D3CE  84 84        	STY	Sutilh		; save string utility ptr high byte
4560    D3D0  AA           	TAX				; copy low byte to X
4561    D3D1  68           	PLA				; get string length back
4562    D3D2  60           	RTS
4563    
4564    LAB_2137
4565    D3D3  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
4566    D3D5  A5 60        	LDA	Gclctd		; get garbage collected flag
4567    D3D7  30 B8        	BMI	LAB_20F5		; if set then do error code X
4568    
4569    D3D9  20 E3 D3     	JSR	LAB_GARB		; else go do garbage collection
4570    D3DC  A9 80        	LDA	#$80			; flag for garbage collected
4571    D3DE  85 60        	STA	Gclctd		; set garbage collected flag
4572    D3E0  68           	PLA				; pull length
4573    D3E1  D0 D0        	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
4574    
4575    ; garbage collection routine
4576    
4577    LAB_GARB
4578    D3E3  A6 85        	LDX	Ememl			; get end of mem low byte
4579    D3E5  A5 86        	LDA	Ememh			; get end of mem high byte
4580    
4581    ; re-run routine from last ending
4582    
4583    LAB_214B
4584    D3E7  86 81        	STX	Sstorl		; set string storage low byte
4585    D3E9  85 82        	STA	Sstorh		; set string storage high byte
4586    D3EB  A0 00        	LDY	#$00			; clear index
4587    D3ED  84 9D        	STY	garb_h		; clear working pointer high byte (flag no strings to move)
4588    D3EF  A5 7F        	LDA	Earryl		; get array mem end low byte
4589    D3F1  A6 80        	LDX	Earryh		; get array mem end high byte
4590    D3F3  85 AA        	STA	Histrl		; save as highest string low byte
4591    D3F5  86 AB        	STX	Histrh		; save as highest string high byte
4592    D3F7  A9 68        	LDA	#des_sk		; set descriptor stack pointer
4593    D3F9  85 71        	STA	ut1_pl		; save descriptor stack pointer low byte
4594    D3FB  84 72        	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
4595    LAB_2161
4596    D3FD  C5 65        	CMP	next_s		; compare with descriptor stack pointer
4597    D3FF  F0 05        	BEQ	LAB_216A		; branch if =
4598    
4599    D401  20 67 D4     	JSR	LAB_21D7		; go garbage collect descriptor stack
4600    D404  F0 F7        	BEQ	LAB_2161		; loop always
4601    
4602    					; done stacked strings, now do string vars
4603    LAB_216A
4604    D406  06 A0        	ASL	g_step		; set step size = $06
4605    D408  A5 7B        	LDA	Svarl			; get start of vars low byte
4606    D40A  A6 7C        	LDX	Svarh			; get start of vars high byte
4607    D40C  85 71        	STA	ut1_pl		; save as pointer low byte
4608    D40E  86 72        	STX	ut1_ph		; save as pointer high byte
4609    LAB_2176
4610    D410  E4 7E        	CPX	Sarryh		; compare start of arrays high byte
4611    D412  D0 04        	BNE	LAB_217E		; branch if no high byte match
4612    
4613    D414  C5 7D        	CMP	Sarryl		; else compare start of arrays low byte
4614    D416  F0 05        	BEQ	LAB_2183		; branch if = var mem end
4615    
4616    LAB_217E
4617    D418  20 61 D4     	JSR	LAB_21D1		; go garbage collect strings
4618    D41B  F0 F3        	BEQ	LAB_2176		; loop always
4619    
4620    					; done string vars, now do string arrays
4621    LAB_2183
4622    D41D  85 A4        	STA	Nbendl		; save start of arrays low byte as working pointer
4623    D41F  86 A5        	STX	Nbendh		; save start of arrays high byte as working pointer
4624    D421  A9 04        	LDA	#$04			; set step size
4625    D423  85 A0        	STA	g_step		; save step size
4626    LAB_218B
4627    D425  A5 A4        	LDA	Nbendl		; get pointer low byte
4628    D427  A6 A5        	LDX	Nbendh		; get pointer high byte
4629    LAB_218F
4630    D429  E4 80        	CPX	Earryh		; compare with array mem end high byte
4631    D42B  D0 04        	BNE	LAB_219A		; branch if not at end
4632    
4633    D42D  C5 7F        	CMP	Earryl		; else compare with array mem end low byte
4634    D42F  F0 75        	BEQ	LAB_2216		; tidy up and exit if at end
4635    
4636    LAB_219A
4637    D431  85 71        	STA	ut1_pl		; save pointer low byte
4638    D433  86 72        	STX	ut1_ph		; save pointer high byte
4639    D435  A0 02        	LDY	#$02			; set index
4640    D437  B1 71        	LDA	(ut1_pl),Y		; get array size low byte
4641    D439  65 A4        	ADC	Nbendl		; add start of this array low byte
4642    D43B  85 A4        	STA	Nbendl		; save start of next array low byte
4643    D43D  C8           	INY				; increment index
4644    D43E  B1 71        	LDA	(ut1_pl),Y		; get array size high byte
4645    D440  65 A5        	ADC	Nbendh		; add start of this array high byte
4646    D442  85 A5        	STA	Nbendh		; save start of next array high byte
4647    D444  A0 01        	LDY	#$01			; set index
4648    D446  B1 71        	LDA	(ut1_pl),Y		; get name second byte
4649    D448  10 DB        	BPL	LAB_218B		; skip if not string array
4650    
4651    ; was string array so ..
4652    
4653    D44A  A0 04        	LDY	#$04			; set index
4654    D44C  B1 71        	LDA	(ut1_pl),Y		; get # of dimensions
4655    D44E  0A           	ASL				; *2
4656    D44F  69 05        	ADC	#$05			; +5 (array header size)
4657    D451  20 99 D4     	JSR	LAB_2208		; go set up for first element
4658    LAB_21C4
4659    D454  E4 A5        	CPX	Nbendh		; compare with start of next array high byte
4660    D456  D0 04        	BNE	LAB_21CC		; branch if <> (go do this array)
4661    
4662    D458  C5 A4        	CMP	Nbendl		; else compare element pointer low byte with next array
4663    					; low byte
4664    D45A  F0 CD        	BEQ	LAB_218F		; if equal then go do next array
4665    
4666    LAB_21CC
4667    D45C  20 67 D4     	JSR	LAB_21D7		; go defrag array strings
4668    D45F  F0 F3        	BEQ	LAB_21C4		; go do next array string (loop always)
4669    
4670    ; defrag string variables
4671    ; enter with XA = variable pointer
4672    ; return with XA = next variable pointer
4673    
4674    LAB_21D1
4675    D461  C8           	INY				; increment index (Y was $00)
4676    D462  B1 71        	LDA	(ut1_pl),Y		; get var name byte 2
4677    D464  10 30        	BPL	LAB_2206		; if not string, step pointer to next var and return
4678    
4679    D466  C8           	INY				; else increment index
4680    LAB_21D7
4681    D467  B1 71        	LDA	(ut1_pl),Y		; get string length
4682    D469  F0 2B        	BEQ	LAB_2206		; if null, step pointer to next string and return
4683    
4684    D46B  C8           	INY				; else increment index
4685    D46C  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte
4686    D46E  AA           	TAX				; copy to X
4687    D46F  C8           	INY				; increment index
4688    D470  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte
4689    D472  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
4690    D474  90 06        	BCC	LAB_21EC		; branch if less
4691    
4692    D476  D0 1E        	BNE	LAB_2206		; if greater, step pointer to next string and return
4693    
4694    					; high bytes were = so compare low bytes
4695    D478  E4 81        	CPX	Sstorl		; compare bottom of string space low byte
4696    D47A  B0 1A        	BCS	LAB_2206		; if >=, step pointer to next string and return
4697    
4698    					; string pointer is < string storage pointer (pos in mem)
4699    LAB_21EC
4700    D47C  C5 AB        	CMP	Histrh		; compare to highest string high byte
4701    D47E  90 17        	BCC	LAB_2207		; if <, step pointer to next string and return
4702    
4703    D480  D0 04        	BNE	LAB_21F6		; if > update pointers, step to next and return
4704    
4705    					; high bytes were = so compare low bytes
4706    D482  E4 AA        	CPX	Histrl		; compare to highest string low byte
4707    D484  90 11        	BCC	LAB_2207		; if <, step pointer to next string and return
4708    
4709    					; string is in string memory space
4710    LAB_21F6
4711    D486  86 AA        	STX	Histrl		; save as new highest string low byte
4712    D488  85 AB        	STA	Histrh		; save as new highest string high byte
4713    D48A  A5 71        	LDA	ut1_pl		; get start of vars(descriptors) low byte
4714    D48C  A6 72        	LDX	ut1_ph		; get start of vars(descriptors) high byte
4715    D48E  85 9C        	STA	garb_l		; save as working pointer low byte
4716    D490  86 9D        	STX	garb_h		; save as working pointer high byte
4717    D492  88           	DEY				; decrement index DIFFERS
4718    D493  88           	DEY				; decrement index (should point to descriptor start)
4719    D494  84 A2        	STY	g_indx		; save index pointer
4720    
4721    					; step pointer to next string
4722    LAB_2206
4723    D496  18           	CLC				; clear carry for add
4724    LAB_2207
4725    D497  A5 A0        	LDA	g_step		; get step size
4726    LAB_2208
4727    D499  65 71        	ADC	ut1_pl		; add pointer low byte
4728    D49B  85 71        	STA	ut1_pl		; save pointer low byte
4729    D49D  90 02        	BCC	LAB_2211		; branch if no overflow
4730    
4731    D49F  E6 72        	INC	ut1_ph		; else increment high byte
4732    LAB_2211
4733    D4A1  A6 72        	LDX	ut1_ph		; get pointer high byte
4734    D4A3  A0 00        	LDY	#$00			; clear Y
4735    D4A5  60           	RTS
4736    
4737    ; search complete, now either exit or set-up and move string
4738    
4739    LAB_2216
4740    D4A6  C6 A0        	DEC	g_step		; decrement step size (now $03 for descriptor stack)
4741    D4A8  A6 9D        	LDX	garb_h		; get string to move high byte
4742    D4AA  F0 F5        	BEQ	LAB_2211		; exit if nothing to move
4743    
4744    D4AC  A4 A2        	LDY	g_indx		; get index byte back (points to descriptor)
4745    D4AE  18           	CLC				; clear carry for add
4746    D4AF  B1 9C        	LDA	(garb_l),Y		; get string length
4747    D4B1  65 AA        	ADC	Histrl		; add highest string low byte
4748    D4B3  85 A6        	STA	Obendl		; save old block end low pointer
4749    D4B5  A5 AB        	LDA	Histrh		; get highest string high byte
4750    D4B7  69 00        	ADC	#$00			; add any carry
4751    D4B9  85 A7        	STA	Obendh		; save old block end high byte
4752    D4BB  A5 81        	LDA	Sstorl		; get bottom of string space low byte
4753    D4BD  A6 82        	LDX	Sstorh		; get bottom of string space high byte
4754    D4BF  85 A4        	STA	Nbendl		; save new block end low byte
4755    D4C1  86 A5        	STX	Nbendh		; save new block end high byte
4756    D4C3  20 CC C2     	JSR	LAB_11D6		; open up space in memory, don't set array end
4757    D4C6  A4 A2        	LDY	g_indx		; get index byte
4758    D4C8  C8           	INY				; point to descriptor low byte
4759    D4C9  A5 A4        	LDA	Nbendl		; get string pointer low byte
4760    D4CB  91 9C        	STA	(garb_l),Y		; save new string pointer low byte
4761    D4CD  AA           	TAX				; copy string pointer low byte
4762    D4CE  E6 A5        	INC	Nbendh		; correct high byte (move sets high byte -1)
4763    D4D0  A5 A5        	LDA	Nbendh		; get new string pointer high byte
4764    D4D2  C8           	INY				; point to descriptor high byte
4765    D4D3  91 9C        	STA	(garb_l),Y		; save new string pointer high byte
4766    D4D5  4C E7 D3     	JMP	LAB_214B		; re-run routine from last ending
4767    					; (but don't collect this string)
4768    
4769    ; concatenate
4770    ; add strings, string 1 is in descriptor des_pl, string 2 is in line
4771    
4772    LAB_224D
4773    D4D8  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
4774    D4DA  48           	PHA				; put on stack
4775    D4DB  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
4776    D4DD  48           	PHA				; put on stack
4777    D4DE  20 D1 CD     	JSR	LAB_GVAL		; get value from line
4778    D4E1  20 D6 CC     	JSR	LAB_CTST		; check if source is string, else do type mismatch
4779    D4E4  68           	PLA				; get descriptor pointer low byte back
4780    D4E5  85 B8        	STA	ssptr_l		; set pointer low byte
4781    D4E7  68           	PLA				; get descriptor pointer high byte back
4782    D4E8  85 B9        	STA	ssptr_h		; set pointer high byte
4783    D4EA  A0 00        	LDY	#$00			; clear index
4784    D4EC  B1 B8        	LDA	(ssptr_l),Y		; get length_1 from descriptor
4785    D4EE  18           	CLC				; clear carry for add
4786    D4EF  71 AE        	ADC	(des_pl),Y		; add length_2
4787    D4F1  90 05        	BCC	LAB_226D		; branch if no overflow
4788    
4789    D4F3  A2 1A        	LDX	#$1A			; else set error code $1A ("String too long" error)
4790    D4F5  4C 40 C3     	JMP	LAB_XERR		; do error #X, then warm start
4791    
4792    LAB_226D
4793    D4F8  20 36 D3     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
4794    					; long
4795    D4FB  20 15 D5     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
4796    D4FE  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
4797    D500  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
4798    D502  20 46 D5     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
4799    					; returns with A = length, ut1_pl = pointer low byte,
4800    					; ut1_ph = pointer high byte
4801    D505  20 27 D5     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
4802    D508  A5 B8        	LDA	ssptr_l		;.set descriptor pointer low byte
4803    D50A  A4 B9        	LDY	ssptr_h		;.set descriptor pointer high byte
4804    D50C  20 46 D5     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
4805    					; returns with A = length, X=ut1_pl=pointer low byte,
4806    					; Y=ut1_ph=pointer high byte
4807    D50F  20 89 D3     	JSR	LAB_RTST		; check for space on descriptor stack then put string
4808    					; address and length on descriptor stack and update stack
4809    					; pointers
4810    D512  4C FC CC     	JMP	LAB_1ADB		;.continue evaluation
4811    
4812    ; copy string from descriptor (sdescr) to (Sutill)
4813    
4814    LAB_228A
4815    D515  A0 00        	LDY	#$00			; clear index
4816    D517  B1 B8        	LDA	(sdescr),Y		; get string length
4817    D519  48           	PHA				; save on stack
4818    D51A  C8           	INY				; increment index
4819    D51B  B1 B8        	LDA	(sdescr),Y		; get source string pointer low byte
4820    D51D  AA           	TAX				; copy to X
4821    D51E  C8           	INY				; increment index
4822    D51F  B1 B8        	LDA	(sdescr),Y		; get source string pointer high byte
4823    D521  A8           	TAY				; copy to Y
4824    D522  68           	PLA				; get length back
4825    
4826    ; store string A bytes long from YX to (Sutill)
4827    
4828    LAB_2298
4829    D523  86 71        	STX	ut1_pl		; save source string pointer low byte
4830    D525  84 72        	STY	ut1_ph		; save source string pointer high byte
4831    
4832    ; store string A bytes long from (ut1_pl) to (Sutill)
4833    
4834    LAB_229C
4835    D527  AA           	TAX				; copy length to index (don't count with Y)
4836    D528  F0 14        	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
4837    
4838    D52A  A0 00        	LDY	#$00			; zero pointer (copy forward)
4839    LAB_22A0
4840    D52C  B1 71        	LDA	(ut1_pl),Y		; get source byte
4841    D52E  91 83        	STA	(Sutill),Y		; save destination byte
4842    
4843    D530  C8           	INY				; increment index
4844    D531  CA           	DEX				; decrement counter
4845    D532  D0 F8        	BNE	LAB_22A0		; loop while <> 0
4846    
4847    D534  98           	TYA				; restore length from Y
4848    LAB_22A9
4849    D535  18           	CLC				; clear carry for add
4850    D536  65 83        	ADC	Sutill		; add string utility ptr low byte
4851    D538  85 83        	STA	Sutill		; save string utility ptr low byte
4852    D53A  90 02        	BCC	LAB_22B2		; branch if no carry
4853    
4854    D53C  E6 84        	INC	Sutilh		; else increment string utility ptr high byte
4855    LAB_22B2
4856    D53E  60           	RTS
4857    
4858    ; evaluate string
4859    
4860    LAB_EVST
4861    D53F  20 D6 CC     	JSR	LAB_CTST		; check if source is string, else do type mismatch
4862    
4863    ; pop string off descriptor stack, or from top of string space
4864    ; returns with A = length, X=pointer low byte, Y=pointer high byte
4865    
4866    LAB_22B6
4867    D542  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
4868    D544  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
4869    
4870    ; pop (YA) descriptor off stack or from top of string space
4871    ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
4872    
4873    LAB_22BA
4874    D546  85 71        	STA	ut1_pl		; save descriptor pointer low byte
4875    D548  84 72        	STY	ut1_ph		; save descriptor pointer high byte
4876    D54A  20 77 D5     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
4877    D54D  08           	PHP				; save status flags
4878    D54E  A0 00        	LDY	#$00			; clear index
4879    D550  B1 71        	LDA	(ut1_pl),Y		; get length from string descriptor
4880    D552  48           	PHA				; put on stack
4881    D553  C8           	INY				; increment index
4882    D554  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
4883    D556  AA           	TAX				; copy to X
4884    D557  C8           	INY				; increment index
4885    D558  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
4886    D55A  A8           	TAY				; copy to Y
4887    D55B  68           	PLA				; get string length back
4888    D55C  28           	PLP				; restore status
4889    D55D  D0 13        	BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
4890    
4891    D55F  C4 82        	CPY	Sstorh		; compare bottom of string space high byte
4892    D561  D0 0F        	BNE	LAB_22E6		; branch if <>
4893    
4894    D563  E4 81        	CPX	Sstorl		; else compare bottom of string space low byte
4895    D565  D0 0B        	BNE	LAB_22E6		; branch if <>
4896    
4897    D567  48           	PHA				; save string length
4898    D568  18           	CLC				; clear carry for add
4899    D569  65 81        	ADC	Sstorl		; add bottom of string space low byte
4900    D56B  85 81        	STA	Sstorl		; save bottom of string space low byte
4901    D56D  90 02        	BCC	LAB_22E5		; skip increment if no overflow
4902    
4903    D56F  E6 82        	INC	Sstorh		; increment bottom of string space high byte
4904    LAB_22E5
4905    D571  68           	PLA				; restore string length
4906    LAB_22E6
4907    D572  86 71        	STX	ut1_pl		; save string pointer low byte
4908    D574  84 72        	STY	ut1_ph		; save string pointer high byte
4909    D576  60           	RTS
4910    
4911    ; clean descriptor stack, YA = pointer
4912    ; checks if AY is on the descriptor stack, if so does a stack discard
4913    
4914    LAB_22EB
4915    D577  C4 67        	CPY	last_sh		; compare pointer high byte
4916    D579  D0 0C        	BNE	LAB_22FB		; exit if <>
4917    
4918    D57B  C5 66        	CMP	last_sl		; compare pointer low byte
4919    D57D  D0 08        	BNE	LAB_22FB		; exit if <>
4920    
4921    D57F  85 65        	STA	next_s		; save descriptor stack pointer
4922    D581  E9 03        	SBC	#$03			; -3
4923    D583  85 66        	STA	last_sl		; save low byte -3
4924    D585  A0 00        	LDY	#$00			; clear high byte
4925    LAB_22FB
4926    D587  60           	RTS
4927    
4928    ; perform CHR$()
4929    
4930    LAB_CHRS
4931    D588  20 93 D6     	JSR	LAB_EVBY		; evaluate byte expression, result in X
4932    D58B  8A           	TXA				; copy to A
4933    D58C  48           	PHA				; save character
4934    D58D  A9 01        	LDA	#$01			; string is single byte
4935    D58F  20 3E D3     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
4936    					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
4937    D592  68           	PLA				; get character back
4938    D593  A0 00        	LDY	#$00			; clear index
4939    D595  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
4940    D597  4C 89 D3     	JMP	LAB_RTST		; check for space on descriptor stack then put string
4941    					; address and length on descriptor stack and update stack
4942    					; pointers
4943    
4944    ; perform LEFT$()
4945    
4946    LAB_LEFT
4947    D59A  48           	PHA				; push byte parameter
4948    D59B  20 FB D5     	JSR	LAB_236F		; pull string data and byte parameter from stack
4949    					; return pointer in des_2l/h, byte in A (and X), Y=0
4950    D59E  D1 9E        	CMP	(des_2l),Y		; compare byte parameter with string length
4951    D5A0  98           	TYA				; clear A
4952    D5A1  F0 09        	BEQ	LAB_2316		; go do string copy (branch always)
4953    
4954    ; perform RIGHT$()
4955    
4956    LAB_RIGHT
4957    D5A3  48           	PHA				; push byte parameter
4958    D5A4  20 FB D5     	JSR	LAB_236F		; pull string data and byte parameter from stack
4959    					; return pointer in des_2l/h, byte in A (and X), Y=0
4960    D5A7  18           	CLC				; clear carry for add-1
4961    D5A8  F1 9E        	SBC	(des_2l),Y		; subtract string length
4962    D5AA  49 FF        	EOR	#$FF			; invert it (A=LEN(expression$)-l)
4963    
4964    LAB_2316
4965    D5AC  90 04        	BCC	LAB_231C		; branch if string length > byte parameter
4966    
4967    D5AE  B1 9E        	LDA	(des_2l),Y		; else make parameter = length
4968    D5B0  AA           	TAX				; copy to byte parameter copy
4969    D5B1  98           	TYA				; clear string start offset
4970    LAB_231C
4971    D5B2  48           	PHA				; save string start offset
4972    LAB_231D
4973    D5B3  8A           	TXA				; copy byte parameter (or string length if <)
4974    LAB_231E
4975    D5B4  48           	PHA				; save string length
4976    D5B5  20 3E D3     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
4977    					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
4978    D5B8  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
4979    D5BA  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
4980    D5BC  20 46 D5     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
4981    					; returns with A = length, X=ut1_pl=pointer low byte,
4982    					; Y=ut1_ph=pointer high byte
4983    D5BF  68           	PLA				; get string length back
4984    D5C0  A8           	TAY				; copy length to Y
4985    D5C1  68           	PLA				; get string start offset back
4986    D5C2  18           	CLC				; clear carry for add
4987    D5C3  65 71        	ADC	ut1_pl		; add start offset to string start pointer low byte
4988    D5C5  85 71        	STA	ut1_pl		; save string start pointer low byte
4989    D5C7  90 02        	BCC	LAB_2335		; branch if no overflow
4990    
4991    D5C9  E6 72        	INC	ut1_ph		; else increment string start pointer high byte
4992    LAB_2335
4993    D5CB  98           	TYA				; copy length to A
4994    D5CC  20 27 D5     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
4995    D5CF  4C 89 D3     	JMP	LAB_RTST		; check for space on descriptor stack then put string
4996    					; address and length on descriptor stack and update stack
4997    					; pointers
4998    
4999    ; perform MID$()
5000    
5001    LAB_MIDS
5002    D5D2  48           	PHA				; push byte parameter
5003    D5D3  A9 FF        	LDA	#$FF			; set default length = 255
5004    D5D5  85 AF        	STA	mids_l		; save default length
5005    D5D7  20 C2 00     	JSR	LAB_GBYT		; scan memory
5006    D5DA  C9 29        	CMP	#')'			; compare with ")"
5007    D5DC  F0 06        	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
5008    
5009    D5DE  20 02 CE     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
5010    D5E1  20 90 D6     	JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
5011    LAB_2358
5012    D5E4  20 FB D5     	JSR	LAB_236F		; pull string data and byte parameter from stack
5013    					; return pointer in des_2l/h, byte in A (and X), Y=0
5014    D5E7  CA           	DEX				; decrement start index
5015    D5E8  8A           	TXA				; copy to A
5016    D5E9  48           	PHA				; save string start offset
5017    D5EA  18           	CLC				; clear carry for sub-1
5018    D5EB  A2 00        	LDX	#$00			; clear output string length
5019    D5ED  F1 9E        	SBC	(des_2l),Y		; subtract string length
5020    D5EF  B0 C2        	BCS	LAB_231D		; if start>string length go do null string
5021    
5022    D5F1  49 FF        	EOR	#$FF			; complement -length
5023    D5F3  C5 AF        	CMP	mids_l		; compare byte parameter
5024    D5F5  90 BD        	BCC	LAB_231E		; if length>remaining string go do RIGHT$
5025    
5026    D5F7  A5 AF        	LDA	mids_l		; get length byte
5027    D5F9  B0 B9        	BCS	LAB_231E		; go do string copy (branch always)
5028    
5029    ; pull string data and byte parameter from stack
5030    ; return pointer in des_2l/h, byte in A (and X), Y=0
5031    
5032    LAB_236F
5033    D5FB  20 F3 CD     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
5034    D5FE  68           	PLA				; pull return address low byte (return address)
5035    D5FF  85 A2        	STA	Fnxjpl		; save functions jump vector low byte
5036    D601  68           	PLA				; pull return address high byte (return address)
5037    D602  85 A3        	STA	Fnxjph		; save functions jump vector high byte
5038    D604  68           	PLA				; pull byte parameter
5039    D605  AA           	TAX				; copy byte parameter to X
5040    D606  68           	PLA				; pull string pointer low byte
5041    D607  85 9E        	STA	des_2l		; save it
5042    D609  68           	PLA				; pull string pointer high byte
5043    D60A  85 9F        	STA	des_2h		; save it
5044    D60C  A0 00        	LDY	#$00			; clear index
5045    D60E  8A           	TXA				; copy byte parameter
5046    D60F  F0 79        	BEQ	LAB_23A8		; if null do function call error then warm start
5047    
5048    D611  E6 A2        	INC	Fnxjpl		; increment function jump vector low byte
5049    					; (JSR pushes return addr-1. this is all very nice
5050    					; but will go tits up if either call is on a page
5051    					; boundary!)
5052    D613  6C A2 00     	JMP	(Fnxjpl)		; in effect, RTS
5053    
5054    ; perform LCASE$()
5055    
5056    LAB_LCASE
5057    D616  20 3F D5     	JSR	LAB_EVST		; evaluate string
5058    D619  85 AC        	STA	str_ln		; set string length
5059    D61B  A8           	TAY				; copy length to Y
5060    D61C  F0 38        	BEQ	NoString		; branch if null string
5061    
5062    D61E  20 3E D3     	JSR	LAB_MSSP		; make string space A bytes long A=length,
5063    					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
5064    D621  86 AD        	STX	str_pl		; save string pointer low byte
5065    D623  84 AE        	STY	str_ph		; save string pointer high byte
5066    D625  A8           	TAY				; get string length back
5067    
5068    LC_loop
5069    D626  88           	DEY				; decrement index
5070    D627  B1 71        	LDA	(ut1_pl),Y		; get byte from string
5071    D629  20 26 D0     	JSR	LAB_1D82		; is character "A" to "Z"
5072    D62C  90 02        	BCC	NoUcase		; branch if not upper case alpha
5073    
5074    D62E  09 20        	ORA	#$20			; convert upper to lower case
5075    NoUcase
5076    D630  91 83        	STA	(Sutill),Y		; save byte back to string
5077    D632  98           	TYA				; test index
5078    D633  D0 F1        	BNE	LC_loop		; loop if not all done
5079    
5080    D635  F0 1F        	BEQ	NoString		; tidy up and exit, branch always
5081    
5082    ; perform UCASE$()
5083    
5084    LAB_UCASE
5085    D637  20 3F D5     	JSR	LAB_EVST		; evaluate string
5086    D63A  85 AC        	STA	str_ln		; set string length
5087    D63C  A8           	TAY				; copy length to Y
5088    D63D  F0 17        	BEQ	NoString		; branch if null string
5089    
5090    D63F  20 3E D3     	JSR	LAB_MSSP		; make string space A bytes long A=length,
5091    					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
5092    D642  86 AD        	STX	str_pl		; save string pointer low byte
5093    D644  84 AE        	STY	str_ph		; save string pointer high byte
5094    D646  A8           	TAY				; get string length back
5095    
5096    UC_loop
5097    D647  88           	DEY				; decrement index
5098    D648  B1 71        	LDA	(ut1_pl),Y		; get byte from string
5099    D64A  20 22 D0     	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
5100    D64D  90 02        	BCC	NoLcase		; branch if not alpha
5101    
5102    D64F  29 DF        	AND	#$DF			; convert lower to upper case
5103    NoLcase
5104    D651  91 83        	STA	(Sutill),Y		; save byte back to string
5105    D653  98           	TYA				; test index
5106    D654  D0 F1        	BNE	UC_loop		; loop if not all done
5107    
5108    NoString
5109    D656  4C 89 D3     	JMP	LAB_RTST		; check for space on descriptor stack then put string
5110    					; address and length on descriptor stack and update stack
5111    					; pointers
5112    
5113    ; perform SADD()
5114    
5115    LAB_SADD
5116    D659  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
5117    D65C  20 AE CF     	JSR	LAB_GVAR		; get var address
5118    
5119    D65F  20 F3 CD     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
5120    D662  20 D6 CC     	JSR	LAB_CTST		; check if source is string, else do type mismatch
5121    
5122    D665  A0 02        	LDY	#$02			; index to string pointer high byte
5123    D667  B1 95        	LDA	(Cvaral),Y		; get string pointer high byte
5124    D669  AA           	TAX				; copy string pointer high byte to X
5125    D66A  88           	DEY				; index to string pointer low byte
5126    D66B  B1 95        	LDA	(Cvaral),Y		; get string pointer low byte
5127    D66D  A8           	TAY				; copy string pointer low byte to Y
5128    D66E  8A           	TXA				; copy string pointer high byte to A
5129    D66F  4C 5D D2     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
5130    
5131    ; perform LEN()
5132    
5133    LAB_LENS
5134    D672  20 78 D6     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
5135    D675  4C 6A D2     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
5136    
5137    ; evaluate string, get length in Y
5138    
5139    LAB_ESGL
5140    D678  20 3F D5     	JSR	LAB_EVST		; evaluate string
5141    D67B  A8           	TAY				; copy length to Y
5142    D67C  60           	RTS
5143    
5144    ; perform ASC()
5145    
5146    LAB_ASC
5147    D67D  20 78 D6     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
5148    D680  F0 08        	BEQ	LAB_23A8		; if null do function call error then warm start
5149    
5150    D682  A0 00        	LDY	#$00			; set index to first character
5151    D684  B1 71        	LDA	(ut1_pl),Y		; get byte
5152    D686  A8           	TAY				; copy to Y
5153    D687  4C 6A D2     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
5154    
5155    ; do function call error then warm start
5156    
5157    LAB_23A8
5158    D68A  4C 2D D1     	JMP	LAB_FCER		; do function call error then warm start
5159    
5160    ; scan and get byte parameter
5161    
5162    LAB_SGBY
5163    D68D  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
5164    
5165    ; get byte parameter
5166    
5167    LAB_GTBY
5168    D690  20 D1 CC     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
5169    					; else do type mismatch
5170    
5171    ; evaluate byte expression, result in X
5172    
5173    LAB_EVBY
5174    D693  20 A6 D0     	JSR	LAB_EVPI		; evaluate integer expression (no check)
5175    
5176    D696  A4 AE        	LDY	FAC1_2		; get FAC1 mantissa2
5177    D698  D0 F0        	BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
5178    
5179    D69A  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
5180    D69C  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
5181    
5182    ; perform VAL()
5183    
5184    LAB_VAL
5185    D69F  20 78 D6     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
5186    D6A2  D0 03        	BNE	LAB_23C5		; branch if not null string
5187    
5188    					; string was null so set result = $00
5189    D6A4  4C 54 D8     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
5190    
5191    LAB_23C5
5192    D6A7  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
5193    D6A9  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
5194    D6AB  86 BA        	STX	Btmpl			; save BASIC execute pointer low byte
5195    D6AD  84 BB        	STY	Btmph			; save BASIC execute pointer high byte
5196    D6AF  A6 71        	LDX	ut1_pl		; get string pointer low byte
5197    D6B1  86 C3        	STX	Bpntrl		; save as BASIC execute pointer low byte
5198    D6B3  18           	CLC				; clear carry
5199    D6B4  65 71        	ADC	ut1_pl		; add string length
5200    D6B6  85 73        	STA	ut2_pl		; save string end low byte
5201    D6B8  A5 72        	LDA	ut1_ph		; get string pointer high byte
5202    D6BA  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
5203    D6BC  69 00        	ADC	#$00			; add carry to high byte
5204    D6BE  85 74        	STA	ut2_ph		; save string end high byte
5205    D6C0  A0 00        	LDY	#$00			; set index to $00
5206    D6C2  B1 73        	LDA	(ut2_pl),Y		; get string end +1 byte
5207    D6C4  48           	PHA				; push it
5208    D6C5  98           	TYA				; clear A
5209    D6C6  91 73        	STA	(ut2_pl),Y		; terminate string with $00
5210    D6C8  20 C2 00     	JSR	LAB_GBYT		; scan memory
5211    D6CB  20 AA DB     	JSR	LAB_2887		; get FAC1 from string
5212    D6CE  68           	PLA				; restore string end +1 byte
5213    D6CF  A0 00        	LDY	#$00			; set index to zero
5214    D6D1  91 73        	STA	(ut2_pl),Y		; put string end byte back
5215    
5216    ; restore BASIC execute pointer from temp (Btmpl/Btmph)
5217    
5218    LAB_23F3
5219    D6D3  A6 BA        	LDX	Btmpl			; get BASIC execute pointer low byte back
5220    D6D5  A4 BB        	LDY	Btmph			; get BASIC execute pointer high byte back
5221    D6D7  86 C3        	STX	Bpntrl		; save BASIC execute pointer low byte
5222    D6D9  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
5223    D6DB  60           	RTS
5224    
5225    ; get two parameters for POKE or WAIT
5226    
5227    LAB_GADB
5228    D6DC  20 D1 CC     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
5229    					; else do type mismatch
5230    D6DF  20 F5 D6     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
5231    
5232    ; scan for "," and get byte, else do Syntax error then warm start
5233    
5234    LAB_SCGB
5235    D6E2  20 02 CE     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
5236    D6E5  A5 12        	LDA	Itemph		; save temporary integer high byte
5237    D6E7  48           	PHA				; on stack
5238    D6E8  A5 11        	LDA	Itempl		; save temporary integer low byte
5239    D6EA  48           	PHA				; on stack
5240    D6EB  20 90 D6     	JSR	LAB_GTBY		; get byte parameter
5241    D6EE  68           	PLA				; pull low byte
5242    D6EF  85 11        	STA	Itempl		; restore temporary integer low byte
5243    D6F1  68           	PLA				; pull high byte
5244    D6F2  85 12        	STA	Itemph		; restore temporary integer high byte
5245    D6F4  60           	RTS
5246    
5247    ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
5248    ; -ve and converts it into a right truncated integer in Itempl and Itemph
5249    
5250    ; save unsigned 16 bit integer part of FAC1 in temporary integer
5251    
5252    LAB_F2FX
5253    D6F5  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
5254    D6F7  C9 98        	CMP	#$98			; compare with exponent = 2^24
5255    D6F9  B0 8F        	BCS	LAB_23A8		; if >= do function call error then warm start
5256    
5257    LAB_F2FU
5258    D6FB  20 54 DB     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
5259    D6FE  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
5260    D700  A4 AF        	LDY	FAC1_3		; get FAC1 mantissa3
5261    D702  84 11        	STY	Itempl		; save temporary integer low byte
5262    D704  85 12        	STA	Itemph		; save temporary integer high byte
5263    D706  60           	RTS
5264    
5265    ; perform PEEK()
5266    
5267    LAB_PEEK
5268    D707  20 F5 D6     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
5269    D70A  A2 00        	LDX	#$00			; clear index
5270    D70C  A1 11        	LDA	(Itempl,X)		; get byte via temporary integer (addr)
5271    D70E  A8           	TAY				; copy byte to Y
5272    D70F  4C 6A D2     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
5273    
5274    ; perform POKE
5275    
5276    LAB_POKE
5277    D712  20 DC D6     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
5278    D715  8A           	TXA				; copy byte argument to A
5279    D716  A2 00        	LDX	#$00			; clear index
5280    D718  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
5281    D71A  60           	RTS
5282    
5283    ; perform DEEK()
5284    
5285    LAB_DEEK
5286    D71B  20 F5 D6     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
5287    D71E  A2 00        	LDX	#$00			; clear index
5288    D720  A1 11        	LDA	(Itempl,X)		; PEEK low byte
5289    D722  A8           	TAY				; copy to Y
5290    D723  E6 11        	INC	Itempl		; increment pointer low byte
5291    D725  D0 02        	BNE	Deekh			; skip high increment if no rollover
5292    
5293    D727  E6 12        	INC	Itemph		; increment pointer high byte
5294    Deekh
5295    D729  A1 11        	LDA	(Itempl,X)		; PEEK high byte
5296    D72B  4C 5D D2     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
5297    
5298    ; perform DOKE
5299    
5300    LAB_DOKE
5301    D72E  20 D1 CC     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
5302    					; else do type mismatch
5303    D731  20 F5 D6     	JSR	LAB_F2FX		; convert floating-to-fixed
5304    
5305    D734  84 97        	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
5306    D736  85 98        	STA	Frnxth		; save pointer high byte
5307    
5308    D738  20 02 CE     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
5309    D73B  20 D1 CC     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
5310    					; else do type mismatch
5311    D73E  20 F5 D6     	JSR	LAB_F2FX		; convert floating-to-fixed
5312    
5313    D741  98           	TYA				; copy value low byte (float to fixed returns word in AY)
5314    D742  A2 00        	LDX	#$00			; clear index
5315    D744  81 97        	STA	(Frnxtl,X)		; POKE low byte
5316    D746  E6 97        	INC	Frnxtl		; increment pointer low byte
5317    D748  D0 02        	BNE	Dokeh			; skip high increment if no rollover
5318    
5319    D74A  E6 98        	INC	Frnxth		; increment pointer high byte
5320    Dokeh
5321    D74C  A5 12        	LDA	Itemph		; get value high byte
5322    D74E  81 97        	STA	(Frnxtl,X)		; POKE high byte
5323    D750  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
5324    
5325    ; perform SWAP
5326    
5327    LAB_SWAP
5328    D753  20 AE CF     	JSR	LAB_GVAR		; get var1 address
5329    D756  85 97        	STA	Lvarpl		; save var1 address low byte
5330    D758  84 98        	STY	Lvarph		; save var1 address high byte
5331    D75A  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
5332    D75C  48           	PHA				; save data type flag
5333    
5334    D75D  20 02 CE     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
5335    D760  20 AE CF     	JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
5336    D763  68           	PLA				; pull var1 data type flag
5337    D764  45 5F        	EOR	Dtypef		; compare with var2 data type
5338    D766  10 10        	BPL	SwapErr		; exit if not both the same type
5339    
5340    D768  A0 03        	LDY	#$03			; four bytes to swap (either value or descriptor+1)
5341    SwapLp
5342    D76A  B1 97        	LDA	(Lvarpl),Y		; get byte from var1
5343    D76C  AA           	TAX				; save var1 byte
5344    D76D  B1 95        	LDA	(Cvaral),Y		; get byte from var2
5345    D76F  91 97        	STA	(Lvarpl),Y		; save byte to var1
5346    D771  8A           	TXA				; restore var1 byte
5347    D772  91 95        	STA	(Cvaral),Y		; save byte to var2
5348    D774  88           	DEY				; decrement index
5349    D775  10 F3        	BPL	SwapLp		; loop until done
5350    
5351    D777  60           	RTS
5352    
5353    SwapErr
5354    D778  4C E0 CC     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
5355    
5356    ; perform CALL
5357    
5358    LAB_CALL
5359    D77B  20 D1 CC     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
5360    					; else do type mismatch
5361    D77E  20 F5 D6     	JSR	LAB_F2FX		; convert floating-to-fixed
5362    D781  A9 D7        	LDA	#>CallExit		; set return address high byte
5363    D783  48           	PHA				; put on stack
5364    D784  A9 89        	LDA	#<CallExit-1	; set return address low byte
5365    D786  48           	PHA				; put on stack
5366    D787  6C 11 00     	JMP	(Itempl)		; do indirect jump to user routine
5367    
5368    ; if the called routine exits correctly then it will return to here. this will then get
5369    ; the next byte for the interpreter and return
5370    
5371    CallExit
5372    D78A  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
5373    
5374    ; perform WAIT
5375    
5376    LAB_WAIT
5377    D78D  20 DC D6     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
5378    D790  86 97        	STX	Frnxtl		; save byte
5379    D792  A2 00        	LDX	#$00			; clear mask
5380    D794  20 C2 00     	JSR	LAB_GBYT		; scan memory
5381    D797  F0 03        	BEQ	LAB_2441		; skip if no third argument
5382    
5383    D799  20 E2 D6     	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
5384    LAB_2441
5385    D79C  86 98        	STX	Frnxth		; save EOR argument
5386    LAB_2445
5387    D79E  B1 11        	LDA	(Itempl),Y		; get byte via temporary integer (addr)
5388    D7A0  45 98        	EOR	Frnxth		; EOR with second argument (mask)
5389    D7A2  25 97        	AND	Frnxtl		; AND with first argument (byte)
5390    D7A4  F0 F8        	BEQ	LAB_2445		; loop if result is zero
5391    
5392    LAB_244D
5393    D7A6  60           	RTS
5394    
5395    ; perform subtraction, FAC1 from (AY)
5396    
5397    LAB_2455
5398    D7A7  20 8F D9     	JSR	LAB_264D		; unpack memory (AY) into FAC2
5399    
5400    ; perform subtraction, FAC1 from FAC2
5401    
5402    LAB_SUBTRACT
5403    D7AA  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
5404    D7AC  49 FF        	EOR	#$FF			; complement it
5405    D7AE  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
5406    D7B0  45 B7        	EOR	FAC2_s		; EOR with FAC2 sign (b7)
5407    D7B2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
5408    D7B4  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
5409    D7B6  4C C5 D7     	JMP	LAB_ADD		; go add FAC2 to FAC1
5410    
5411    ; perform addition
5412    
5413    LAB_2467
5414    D7B9  20 DE D8     	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
5415    D7BC  90 4D        	BCC	LAB_24A8		;.go subtract mantissas
5416    
5417    ; add 0.5 to FAC1
5418    
5419    LAB_244E
5420    D7BE  A9 F5        	LDA	#<LAB_2A96		; set 0.5 pointer low byte
5421    D7C0  A0 E3        	LDY	#>LAB_2A96		; set 0.5 pointer high byte
5422    
5423    ; add (AY) to FAC1
5424    
5425    LAB_246C
5426    D7C2  20 8F D9     	JSR	LAB_264D		; unpack memory (AY) into FAC2
5427    
5428    ; add FAC2 to FAC1
5429    
5430    LAB_ADD
5431    D7C5  D0 10        	BNE	LAB_2474		; branch if FAC1 was not zero
5432    
5433    ; copy FAC2 to FAC1
5434    
5435    LAB_279B
5436    D7C7  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
5437    
5438    ; save FAC1 sign and copy ABS(FAC2) to FAC1
5439    
5440    LAB_279D
5441    D7C9  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
5442    D7CB  A2 04        	LDX	#$04			; 4 bytes to copy
5443    LAB_27A1
5444    D7CD  B5 B2        	LDA	FAC1_o,X		; get byte from FAC2,X
5445    D7CF  95 AB        	STA	FAC1_e-1,X		; save byte at FAC1,X
5446    D7D1  CA           	DEX				; decrement count
5447    D7D2  D0 F9        	BNE	LAB_27A1		; loop if not all done
5448    
5449    D7D4  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
5450    D7D6  60           	RTS
5451    
5452    					; FAC1 is non zero
5453    LAB_2474
5454    D7D7  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
5455    D7D9  86 A3        	STX	FAC2_r		; save as FAC2 rounding byte
5456    D7DB  A2 B3        	LDX	#FAC2_e		; set index to FAC2 exponent addr
5457    D7DD  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
5458    LAB_247C
5459    D7DF  A8           	TAY				; copy exponent
5460    D7E0  F0 C4        	BEQ	LAB_244D		; exit if zero
5461    
5462    D7E2  38           	SEC				; set carry for subtract
5463    D7E3  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
5464    D7E5  F0 24        	BEQ	LAB_24A8		; branch if = (go add mantissa)
5465    
5466    D7E7  90 12        	BCC	LAB_2498		; branch if <
5467    
5468    					; FAC2>FAC1
5469    D7E9  84 AC        	STY	FAC1_e		; save FAC1 exponent
5470    D7EB  A4 B7        	LDY	FAC2_s		; get FAC2 sign (b7)
5471    D7ED  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
5472    D7EF  49 FF        	EOR	#$FF			; complement A
5473    D7F1  69 00        	ADC	#$00			; +1 (twos complement, carry is set)
5474    D7F3  A0 00        	LDY	#$00			; clear Y
5475    D7F5  84 A3        	STY	FAC2_r		; clear FAC2 rounding byte
5476    D7F7  A2 AC        	LDX	#FAC1_e		; set index to FAC1 exponent addr
5477    D7F9  D0 04        	BNE	LAB_249C		; branch always
5478    
5479    LAB_2498
5480    D7FB  A0 00        	LDY	#$00			; clear Y
5481    D7FD  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
5482    LAB_249C
5483    D7FF  C9 F9        	CMP	#$F9			; compare exponent diff with $F9
5484    D801  30 B6        	BMI	LAB_2467		; branch if range $79-$F8
5485    
5486    D803  A8           	TAY				; copy exponent difference to Y
5487    D804  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
5488    D806  56 01        	LSR	PLUS_1,X		; shift FAC? mantissa1
5489    D808  20 F5 D8     	JSR	LAB_2592		; shift FACX Y times right
5490    
5491    					; exponents are equal now do mantissa subtract
5492    LAB_24A8
5493    D80B  24 B8        	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
5494    D80D  10 4C        	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
5495    
5496    D80F  A0 AC        	LDY	#FAC1_e		; set index to FAC1 exponent addr
5497    D811  E0 B3        	CPX	#FAC2_e		; compare X to FAC2 exponent addr
5498    D813  F0 02        	BEQ	LAB_24B4		; branch if =
5499    
5500    D815  A0 B3        	LDY	#FAC2_e		; else set index to FAC2 exponent addr
5501    
5502    					; subtract smaller from bigger (take sign of bigger)
5503    LAB_24B4
5504    D817  38           	SEC				; set carry for subtract
5505    D818  49 FF        	EOR	#$FF			; ones complement A
5506    D81A  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
5507    D81C  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
5508    D81E  B9 03 00     	LDA	PLUS_3,Y		; get FACY mantissa3
5509    D821  F5 03        	SBC	PLUS_3,X		; subtract FACX mantissa3
5510    D823  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
5511    D825  B9 02 00     	LDA	PLUS_2,Y		; get FACY mantissa2
5512    D828  F5 02        	SBC	PLUS_2,X		; subtract FACX mantissa2
5513    D82A  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
5514    D82C  B9 01 00     	LDA	PLUS_1,Y		; get FACY mantissa1
5515    D82F  F5 01        	SBC	PLUS_1,X		; subtract FACX mantissa1
5516    D831  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
5517    
5518    ; do ABS and normalise FAC1
5519    
5520    LAB_24D0
5521    D833  B0 03        	BCS	LAB_24D5		; branch if number is +ve
5522    
5523    D835  20 9A D8     	JSR	LAB_2537		; negate FAC1
5524    
5525    ; normalise FAC1
5526    
5527    LAB_24D5
5528    D838  A0 00        	LDY	#$00			; clear Y
5529    D83A  98           	TYA				; clear A
5530    D83B  18           	CLC				; clear carry for add
5531    LAB_24D9
5532    D83C  A6 AD        	LDX	FAC1_1		; get FAC1 mantissa1
5533    D83E  D0 3E        	BNE	LAB_251B		; if not zero normalise FAC1
5534    
5535    D840  A6 AE        	LDX	FAC1_2		; get FAC1 mantissa2
5536    D842  86 AD        	STX	FAC1_1		; save FAC1 mantissa1
5537    D844  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
5538    D846  86 AE        	STX	FAC1_2		; save FAC1 mantissa2
5539    D848  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
5540    D84A  86 AF        	STX	FAC1_3		; save FAC1 mantissa3
5541    D84C  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
5542    D84E  69 08        	ADC	#$08			; add x to exponent offset
5543    D850  C9 18        	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
5544    D852  D0 E8        	BNE	LAB_24D9		; loop if not max
5545    
5546    ; clear FAC1 exponent and sign
5547    
5548    LAB_24F1
5549    D854  A9 00        	LDA	#$00			; clear A
5550    LAB_24F3
5551    D856  85 AC        	STA	FAC1_e		; set FAC1 exponent
5552    
5553    ; save FAC1 sign
5554    
5555    LAB_24F5
5556    D858  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
5557    D85A  60           	RTS
5558    
5559    ; add FAC2 mantissa to FAC1 mantissa
5560    
5561    LAB_24F8
5562    D85B  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
5563    D85D  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
5564    D85F  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
5565    D861  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
5566    D863  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
5567    D865  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
5568    D867  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
5569    D869  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
5570    D86B  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
5571    D86D  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
5572    D86F  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
5573    D871  B0 1A        	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
5574    
5575    D873  60           	RTS				; else just exit
5576    
5577    LAB_2511
5578    D874  69 01        	ADC	#$01			; add 1 to exponent offset
5579    D876  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
5580    D878  26 AF        	ROL	FAC1_3		; shift FAC1 mantissa3
5581    D87A  26 AE        	ROL	FAC1_2		; shift FAC1 mantissa2
5582    D87C  26 AD        	ROL	FAC1_1		; shift FAC1 mantissa1
5583    
5584    ; normalise FAC1
5585    
5586    LAB_251B
5587    D87E  10 F4        	BPL	LAB_2511		; loop if not normalised
5588    
5589    D880  38           	SEC				; set carry for subtract
5590    D881  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
5591    D883  B0 CF        	BCS	LAB_24F1		; branch if underflow (set result = $0)
5592    
5593    D885  49 FF        	EOR	#$FF			; complement exponent
5594    D887  69 01        	ADC	#$01			; +1 (twos complement)
5595    D889  85 AC        	STA	FAC1_e		; save FAC1 exponent
5596    
5597    ; test and normalise FAC1 for C=0/1
5598    
5599    LAB_2528
5600    D88B  90 0C        	BCC	LAB_2536		; exit if no overflow
5601    
5602    ; normalise FAC1 for C=1
5603    
5604    LAB_252A
5605    D88D  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
5606    D88F  F0 36        	BEQ	LAB_2564		; if zero do overflow error and warm start
5607    
5608    D891  66 AD        	ROR	FAC1_1		; shift FAC1 mantissa1
5609    D893  66 AE        	ROR	FAC1_2		; shift FAC1 mantissa2
5610    D895  66 AF        	ROR	FAC1_3		; shift FAC1 mantissa3
5611    D897  66 B9        	ROR	FAC1_r		; shift FAC1 rounding byte
5612    LAB_2536
5613    D899  60           	RTS
5614    
5615    ; negate FAC1
5616    
5617    LAB_2537
5618    D89A  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
5619    D89C  49 FF        	EOR	#$FF			; complement it
5620    D89E  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
5621    
5622    ; twos complement FAC1 mantissa
5623    
5624    LAB_253D
5625    D8A0  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
5626    D8A2  49 FF        	EOR	#$FF			; complement it
5627    D8A4  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
5628    D8A6  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
5629    D8A8  49 FF        	EOR	#$FF			; complement it
5630    D8AA  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
5631    D8AC  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
5632    D8AE  49 FF        	EOR	#$FF			; complement it
5633    D8B0  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
5634    D8B2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
5635    D8B4  49 FF        	EOR	#$FF			; complement it
5636    D8B6  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
5637    D8B8  E6 B9        	INC	FAC1_r		; increment FAC1 rounding byte
5638    D8BA  D0 0A        	BNE	LAB_2563		; exit if no overflow
5639    
5640    ; increment FAC1 mantissa
5641    
5642    LAB_2559
5643    D8BC  E6 AF        	INC	FAC1_3		; increment FAC1 mantissa3
5644    D8BE  D0 06        	BNE	LAB_2563		; finished if no rollover
5645    
5646    D8C0  E6 AE        	INC	FAC1_2		; increment FAC1 mantissa2
5647    D8C2  D0 02        	BNE	LAB_2563		; finished if no rollover
5648    
5649    D8C4  E6 AD        	INC	FAC1_1		; increment FAC1 mantissa1
5650    LAB_2563
5651    D8C6  60           	RTS
5652    
5653    ; do overflow error (overflow exit)
5654    
5655    LAB_2564
5656    D8C7  A2 0A        	LDX	#$0A			; error code $0A ("Overflow" error)
5657    D8C9  4C 40 C3     	JMP	LAB_XERR		; do error #X, then warm start
5658    
5659    ; shift FCAtemp << A+8 times
5660    
5661    LAB_2569
5662    D8CC  A2 74        	LDX	#FACt_1-1		; set offset to FACtemp
5663    LAB_256B
5664    D8CE  B4 03        	LDY	PLUS_3,X		; get FACX mantissa3
5665    D8D0  84 B9        	STY	FAC1_r		; save as FAC1 rounding byte
5666    D8D2  B4 02        	LDY	PLUS_2,X		; get FACX mantissa2
5667    D8D4  94 03        	STY	PLUS_3,X		; save FACX mantissa3
5668    D8D6  B4 01        	LDY	PLUS_1,X		; get FACX mantissa1
5669    D8D8  94 02        	STY	PLUS_2,X		; save FACX mantissa2
5670    D8DA  A4 B2        	LDY	FAC1_o		; get FAC1 overflow byte
5671    D8DC  94 01        	STY	PLUS_1,X		; save FACX mantissa1
5672    
5673    ; shift FACX -A times right (> 8 shifts)
5674    
5675    LAB_257B
5676    D8DE  69 08        	ADC	#$08			; add 8 to shift count
5677    D8E0  30 EC        	BMI	LAB_256B		; go do 8 shift if still -ve
5678    
5679    D8E2  F0 EA        	BEQ	LAB_256B		; go do 8 shift if zero
5680    
5681    D8E4  E9 08        	SBC	#$08			; else subtract 8 again
5682    D8E6  A8           	TAY				; save count to Y
5683    D8E7  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
5684    D8E9  B0 12        	BCS	LAB_259A		;.
5685    
5686    LAB_2588
5687    D8EB  16 01        	ASL	PLUS_1,X		; shift FACX mantissa1
5688    D8ED  90 02        	BCC	LAB_258E		; branch if +ve
5689    
5690    D8EF  F6 01        	INC	PLUS_1,X		; this sets b7 eventually
5691    LAB_258E
5692    D8F1  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
5693    D8F3  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
5694    
5695    ; shift FACX Y times right
5696    
5697    LAB_2592
5698    D8F5  76 02        	ROR	PLUS_2,X		; shift FACX mantissa2
5699    D8F7  76 03        	ROR	PLUS_3,X		; shift FACX mantissa3
5700    D8F9  6A           	ROR				; shift FACX rounding byte
5701    D8FA  C8           	INY				; increment exponent diff
5702    D8FB  D0 EE        	BNE	LAB_2588		; branch if range adjust not complete
5703    
5704    LAB_259A
5705    D8FD  18           	CLC				; just clear it
5706    D8FE  60           	RTS
5707    
5708    ; perform LOG()
5709    
5710    LAB_LOG
5711    D8FF  20 ED DA     	JSR	LAB_27CA		; test sign and zero
5712    D902  F0 02        	BEQ	LAB_25C4		; if zero do function call error then warm start
5713    
5714    D904  10 03        	BPL	LAB_25C7		; skip error if +ve
5715    
5716    LAB_25C4
5717    D906  4C 2D D1     	JMP	LAB_FCER		; do function call error then warm start (-ve)
5718    
5719    LAB_25C7
5720    D909  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
5721    D90B  E9 7F        	SBC	#$7F			; normalise it
5722    D90D  48           	PHA				; save it
5723    D90E  A9 80        	LDA	#$80			; set exponent to zero
5724    D910  85 AC        	STA	FAC1_e		; save FAC1 exponent
5725    D912  A9 75        	LDA	#<LAB_25AD		; set 1/root2 pointer low byte
5726    D914  A0 E3        	LDY	#>LAB_25AD		; set 1/root2 pointer high byte
5727    D916  20 C2 D7     	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
5728    D919  A9 79        	LDA	#<LAB_25B1		; set root2 pointer low byte
5729    D91B  A0 E3        	LDY	#>LAB_25B1		; set root2 pointer high byte
5730    D91D  20 05 DA     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
5731    D920  A9 EC        	LDA	#<LAB_259C		; set 1 pointer low byte
5732    D922  A0 E3        	LDY	#>LAB_259C		; set 1 pointer high byte
5733    D924  20 A7 D7     	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
5734    D927  A9 68        	LDA	#<LAB_25A0		; set pointer low byte to counter
5735    D929  A0 E3        	LDY	#>LAB_25A0		; set pointer high byte to counter
5736    D92B  20 55 DE     	JSR	LAB_2B6E		; ^2 then series evaluation
5737    D92E  A9 7D        	LDA	#<LAB_25B5		; set -0.5 pointer low byte
5738    D930  A0 E3        	LDY	#>LAB_25B5		; set -0.5 pointer high byte
5739    D932  20 C2 D7     	JSR	LAB_246C		; add (AY) to FAC1
5740    D935  68           	PLA				; restore FAC1 exponent
5741    D936  20 49 DC     	JSR	LAB_2912		; evaluate new ASCII digit
5742    D939  A9 81        	LDA	#<LAB_25B9		; set LOG(2) pointer low byte
5743    D93B  A0 E3        	LDY	#>LAB_25B9		; set LOG(2) pointer high byte
5744    
5745    ; do convert AY, FCA1*(AY)
5746    
5747    LAB_25FB
5748    D93D  20 8F D9     	JSR	LAB_264D		; unpack memory (AY) into FAC2
5749    LAB_MULTIPLY
5750    D940  F0 4C        	BEQ	LAB_264C		; exit if zero
5751    
5752    D942  20 B5 D9     	JSR	LAB_2673		; test and adjust accumulators
5753    D945  A9 00        	LDA	#$00			; clear A
5754    D947  85 75        	STA	FACt_1		; clear temp mantissa1
5755    D949  85 76        	STA	FACt_2		; clear temp mantissa2
5756    D94B  85 77        	STA	FACt_3		; clear temp mantissa3
5757    D94D  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
5758    D94F  20 64 D9     	JSR	LAB_2622		; go do shift/add FAC2
5759    D952  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
5760    D954  20 64 D9     	JSR	LAB_2622		; go do shift/add FAC2
5761    D957  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
5762    D959  20 64 D9     	JSR	LAB_2622		; go do shift/add FAC2
5763    D95C  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
5764    D95E  20 69 D9     	JSR	LAB_2627		; go do shift/add FAC2
5765    D961  4C 72 DA     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
5766    
5767    LAB_2622
5768    D964  D0 03        	BNE	LAB_2627		; branch if byte <> zero
5769    
5770    D966  4C CC D8     	JMP	LAB_2569		; shift FCAtemp << A+8 times
5771    
5772    					; else do shift and add
5773    LAB_2627
5774    D969  4A           	LSR				; shift byte
5775    D96A  09 80        	ORA	#$80			; set top bit (mark for 8 times)
5776    LAB_262A
5777    D96C  A8           	TAY				; copy result
5778    D96D  90 13        	BCC	LAB_2640		; skip next if bit was zero
5779    
5780    D96F  18           	CLC				; clear carry for add
5781    D970  A5 77        	LDA	FACt_3		; get temp mantissa3
5782    D972  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
5783    D974  85 77        	STA	FACt_3		; save temp mantissa3
5784    D976  A5 76        	LDA	FACt_2		; get temp mantissa2
5785    D978  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
5786    D97A  85 76        	STA	FACt_2		; save temp mantissa2
5787    D97C  A5 75        	LDA	FACt_1		; get temp mantissa1
5788    D97E  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
5789    D980  85 75        	STA	FACt_1		; save temp mantissa1
5790    LAB_2640
5791    D982  66 75        	ROR	FACt_1		; shift temp mantissa1
5792    D984  66 76        	ROR	FACt_2		; shift temp mantissa2
5793    D986  66 77        	ROR	FACt_3		; shift temp mantissa3
5794    D988  66 B9        	ROR	FAC1_r		; shift temp rounding byte
5795    D98A  98           	TYA				; get byte back
5796    D98B  4A           	LSR				; shift byte
5797    D98C  D0 DE        	BNE	LAB_262A		; loop if all bits not done
5798    
5799    LAB_264C
5800    D98E  60           	RTS
5801    
5802    ; unpack memory (AY) into FAC2
5803    
5804    LAB_264D
5805    D98F  85 71        	STA	ut1_pl		; save pointer low byte
5806    D991  84 72        	STY	ut1_ph		; save pointer high byte
5807    D993  A0 03        	LDY	#$03			; 4 bytes to get (0-3)
5808    D995  B1 71        	LDA	(ut1_pl),Y		; get mantissa3
5809    D997  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
5810    D999  88           	DEY				; decrement index
5811    D99A  B1 71        	LDA	(ut1_pl),Y		; get mantissa2
5812    D99C  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
5813    D99E  88           	DEY				; decrement index
5814    D99F  B1 71        	LDA	(ut1_pl),Y		; get mantissa1+sign
5815    D9A1  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
5816    D9A3  45 B0        	EOR	FAC1_s		; EOR with FAC1 sign (b7)
5817    D9A5  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
5818    D9A7  A5 B7        	LDA	FAC2_s		; recover FAC2 sign (b7)
5819    D9A9  09 80        	ORA	#$80			; set 1xxx xxx (set normal bit)
5820    D9AB  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
5821    D9AD  88           	DEY				; decrement index
5822    D9AE  B1 71        	LDA	(ut1_pl),Y		; get exponent byte
5823    D9B0  85 B3        	STA	FAC2_e		; save FAC2 exponent
5824    D9B2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
5825    D9B4  60           	RTS
5826    
5827    ; test and adjust accumulators
5828    
5829    LAB_2673
5830    D9B5  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
5831    LAB_2675
5832    D9B7  F0 1D        	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
5833    
5834    D9B9  18           	CLC				; clear carry for add
5835    D9BA  65 AC        	ADC	FAC1_e		; add FAC1 exponent
5836    D9BC  90 04        	BCC	LAB_2680		; branch if sum of exponents <$0100
5837    
5838    D9BE  30 31        	BMI	LAB_269B		; do overflow error
5839    
5840    D9C0  18           	CLC				; clear carry for the add
5841    	.byte	$2C			; makes next line BIT $1410
5842    LAB_2680
5843    D9C2  10 12        	BPL	LAB_2696		; if +ve go handle underflow
5844    
5845    D9C4  69 80        	ADC	#$80			; adjust exponent
5846    D9C6  85 AC        	STA	FAC1_e		; save FAC1 exponent
5847    D9C8  D0 03        	BNE	LAB_268B		; branch if not zero
5848    
5849    D9CA  4C 58 D8     	JMP	LAB_24F5		; save FAC1 sign and return
5850    
5851    LAB_268B
5852    D9CD  A5 B8        	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
5853    D9CF  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
5854    LAB_268F
5855    D9D1  60           	RTS
5856    
5857    ; handle overflow and underflow
5858    
5859    LAB_2690
5860    D9D2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
5861    D9D4  10 1B        	BPL	LAB_269B		; do overflow error
5862    
5863    					; handle underflow
5864    LAB_2696
5865    D9D6  68           	PLA				; pop return address low byte
5866    D9D7  68           	PLA				; pop return address high byte
5867    D9D8  4C 54 D8     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
5868    
5869    ; multiply by 10
5870    
5871    LAB_269E
5872    D9DB  20 CE DA     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
5873    D9DE  AA           	TAX				; copy exponent (set the flags)
5874    D9DF  F0 F0        	BEQ	LAB_268F		; exit if zero
5875    
5876    D9E1  18           	CLC				; clear carry for add
5877    D9E2  69 02        	ADC	#$02			; add two to exponent (*4)
5878    D9E4  B0 0B        	BCS	LAB_269B		; do overflow error if > $FF
5879    
5880    D9E6  A2 00        	LDX	#$00			; clear byte
5881    D9E8  86 B8        	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
5882    D9EA  20 DF D7     	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
5883    D9ED  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*10)
5884    D9EF  D0 E0        	BNE	LAB_268F		; if non zero just do RTS
5885    
5886    LAB_269B
5887    D9F1  4C C7 D8     	JMP	LAB_2564		; do overflow error and warm start
5888    
5889    ; divide by 10
5890    
5891    LAB_26B9
5892    D9F4  20 CE DA     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
5893    D9F7  A9 FD        	LDA	#<LAB_26B5		; set pointer to 10d low addr
5894    D9F9  A0 E3        	LDY	#>LAB_26B5		; set pointer to 10d high addr
5895    D9FB  A2 00        	LDX	#$00			; clear sign
5896    
5897    ; divide by (AY) (X=sign)
5898    
5899    LAB_26C2
5900    D9FD  86 B8        	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
5901    D9FF  20 81 DA     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
5902    DA02  4C 08 DA     	JMP	LAB_DIVIDE		; do FAC2/FAC1
5903    
5904    					; Perform divide-by
5905    ; convert AY and do (AY)/FAC1
5906    
5907    LAB_26CA
5908    DA05  20 8F D9     	JSR	LAB_264D		; unpack memory (AY) into FAC2
5909    
5910    					; Perform divide-into
5911    LAB_DIVIDE
5912    DA08  F0 63        	BEQ	LAB_2737		; if zero go do /0 error
5913    
5914    DA0A  20 DD DA     	JSR	LAB_27BA		; round FAC1
5915    DA0D  A9 00        	LDA	#$00			; clear A
5916    DA0F  38           	SEC				; set carry for subtract
5917    DA10  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
5918    DA12  85 AC        	STA	FAC1_e		; save FAC1 exponent
5919    DA14  20 B5 D9     	JSR	LAB_2673		; test and adjust accumulators
5920    DA17  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
5921    DA19  F0 D6        	BEQ	LAB_269B		; if zero do overflow error
5922    
5923    DA1B  A2 FF        	LDX	#$FF			; set index for pre increment
5924    DA1D  A9 01        	LDA	#$01			; set bit to flag byte save
5925    LAB_26E4
5926    DA1F  A4 B4        	LDY	FAC2_1		; get FAC2 mantissa1
5927    DA21  C4 AD        	CPY	FAC1_1		; compare FAC1 mantissa1
5928    DA23  D0 0A        	BNE	LAB_26F4		; branch if <>
5929    
5930    DA25  A4 B5        	LDY	FAC2_2		; get FAC2 mantissa2
5931    DA27  C4 AE        	CPY	FAC1_2		; compare FAC1 mantissa2
5932    DA29  D0 04        	BNE	LAB_26F4		; branch if <>
5933    
5934    DA2B  A4 B6        	LDY	FAC2_3		; get FAC2 mantissa3
5935    DA2D  C4 AF        	CPY	FAC1_3		; compare FAC1 mantissa3
5936    LAB_26F4
5937    DA2F  08           	PHP				; save FAC2-FAC1 compare status
5938    DA30  2A           	ROL				; shift the result byte
5939    DA31  90 0E        	BCC	LAB_2702		; if no carry skip the byte save
5940    
5941    DA33  A0 01        	LDY	#$01			; set bit to flag byte save
5942    DA35  E8           	INX				; else increment the index to FACt
5943    DA36  E0 02        	CPX	#$02			; compare with the index to FACt_3
5944    DA38  30 04        	BMI	LAB_2701		; if not last byte just go save it
5945    
5946    DA3A  D0 28        	BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
5947    					; return
5948    
5949    DA3C  A0 40        	LDY	#$40			; set bit to flag byte save for the rounding byte
5950    LAB_2701
5951    DA3E  95 75        	STA	FACt_1,X		; write result byte to FACt_1 + index
5952    DA40  98           	TYA				; copy the next save byte flag
5953    LAB_2702
5954    DA41  28           	PLP				; restore FAC2-FAC1 compare status
5955    DA42  90 14        	BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
5956    
5957    DA44  A8           	TAY				; save FAC2-FAC1 compare status
5958    DA45  A5 B6        	LDA	FAC2_3		; get FAC2 mantissa3
5959    DA47  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
5960    DA49  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
5961    DA4B  A5 B5        	LDA	FAC2_2		; get FAC2 mantissa2
5962    DA4D  E5 AE        	SBC	FAC1_2		; subtract FAC1 mantissa2
5963    DA4F  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
5964    DA51  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
5965    DA53  E5 AD        	SBC	FAC1_1		; subtract FAC1 mantissa1
5966    DA55  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
5967    DA57  98           	TYA				; restore FAC2-FAC1 compare status
5968    
5969    					; FAC2 = FAC2*2
5970    LAB_2704
5971    DA58  06 B6        	ASL	FAC2_3		; shift FAC2 mantissa3
5972    DA5A  26 B5        	ROL	FAC2_2		; shift FAC2 mantissa2
5973    DA5C  26 B4        	ROL	FAC2_1		; shift FAC2 mantissa1
5974    DA5E  B0 CF        	BCS	LAB_26F4		; loop with no compare
5975    
5976    DA60  30 BD        	BMI	LAB_26E4		; loop with compare
5977    
5978    DA62  10 CB        	BPL	LAB_26F4		; loop always with no compare
5979    
5980    ; do A<<6, save as FAC1 rounding byte, normalise and return
5981    
5982    LAB_272B
5983    DA64  4A           	LSR				; shift b1 - b0 ..
5984    DA65  6A           	ROR				; ..
5985    DA66  6A           	ROR				; .. to b7 - b6
5986    DA67  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
5987    DA69  28           	PLP				; dump FAC2-FAC1 compare status
5988    DA6A  4C 72 DA     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
5989    
5990    ; do "Divide by zero" error
5991    
5992    LAB_2737
5993    DA6D  A2 14        	LDX	#$14			; error code $14 ("Divide by zero" error)
5994    DA6F  4C 40 C3     	JMP	LAB_XERR		; do error #X, then warm start
5995    
5996    ; copy temp to FAC1 and normalise
5997    
5998    LAB_273C
5999    DA72  A5 75        	LDA	FACt_1		; get temp mantissa1
6000    DA74  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
6001    DA76  A5 76        	LDA	FACt_2		; get temp mantissa2
6002    DA78  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
6003    DA7A  A5 77        	LDA	FACt_3		; get temp mantissa3
6004    DA7C  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
6005    DA7E  4C 38 D8     	JMP	LAB_24D5		; normalise FAC1 and return
6006    
6007    ; unpack memory (AY) into FAC1
6008    
6009    LAB_UFAC
6010    DA81  85 71        	STA	ut1_pl		; save pointer low byte
6011    DA83  84 72        	STY	ut1_ph		; save pointer high byte
6012    DA85  A0 03        	LDY	#$03			; 4 bytes to do
6013    DA87  B1 71        	LDA	(ut1_pl),Y		; get last byte
6014    DA89  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
6015    DA8B  88           	DEY				; decrement index
6016    DA8C  B1 71        	LDA	(ut1_pl),Y		; get last-1 byte
6017    DA8E  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
6018    DA90  88           	DEY				; decrement index
6019    DA91  B1 71        	LDA	(ut1_pl),Y		; get second byte
6020    DA93  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
6021    DA95  09 80        	ORA	#$80			; set 1xxx xxxx (add normal bit)
6022    DA97  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
6023    DA99  88           	DEY				; decrement index
6024    DA9A  B1 71        	LDA	(ut1_pl),Y		; get first byte (exponent)
6025    DA9C  85 AC        	STA	FAC1_e		; save FAC1 exponent
6026    DA9E  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
6027    DAA0  60           	RTS
6028    
6029    ; pack FAC1 into Adatal
6030    
6031    LAB_276E
6032    DAA1  A2 A4        	LDX	#<Adatal		; set pointer low byte
6033    LAB_2770
6034    DAA3  A0 00        	LDY	#>Adatal		; set pointer high byte
6035    DAA5  F0 04        	BEQ	LAB_2778		; pack FAC1 into (XY) and return
6036    
6037    ; pack FAC1 into (Lvarpl)
6038    
6039    LAB_PFAC
6040    DAA7  A6 97        	LDX	Lvarpl		; get destination pointer low byte
6041    DAA9  A4 98        	LDY	Lvarph		; get destination pointer high byte
6042    
6043    ; pack FAC1 into (XY)
6044    
6045    LAB_2778
6046    DAAB  20 DD DA     	JSR	LAB_27BA		; round FAC1
6047    DAAE  86 71        	STX	ut1_pl		; save pointer low byte
6048    DAB0  84 72        	STY	ut1_ph		; save pointer high byte
6049    DAB2  A0 03        	LDY	#$03			; set index
6050    DAB4  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
6051    DAB6  91 71        	STA	(ut1_pl),Y		; store in destination
6052    DAB8  88           	DEY				; decrement index
6053    DAB9  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
6054    DABB  91 71        	STA	(ut1_pl),Y		; store in destination
6055    DABD  88           	DEY				; decrement index
6056    DABE  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
6057    DAC0  09 7F        	ORA	#$7F			; set bits x111 1111
6058    DAC2  25 AD        	AND	FAC1_1		; AND in FAC1 mantissa1
6059    DAC4  91 71        	STA	(ut1_pl),Y		; store in destination
6060    DAC6  88           	DEY				; decrement index
6061    DAC7  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
6062    DAC9  91 71        	STA	(ut1_pl),Y		; store in destination
6063    DACB  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
6064    DACD  60           	RTS
6065    
6066    ; round and copy FAC1 to FAC2
6067    
6068    LAB_27AB
6069    DACE  20 DD DA     	JSR	LAB_27BA		; round FAC1
6070    
6071    ; copy FAC1 to FAC2
6072    
6073    LAB_27AE
6074    DAD1  A2 05        	LDX	#$05			; 5 bytes to copy
6075    LAB_27B0
6076    DAD3  B5 AB        	LDA	FAC1_e-1,X		; get byte from FAC1,X
6077    DAD5  95 B2        	STA	FAC1_o,X		; save byte at FAC2,X
6078    DAD7  CA           	DEX				; decrement count
6079    DAD8  D0 F9        	BNE	LAB_27B0		; loop if not all done
6080    
6081    DADA  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
6082    LAB_27B9
6083    DADC  60           	RTS
6084    
6085    ; round FAC1
6086    
6087    LAB_27BA
6088    DADD  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
6089    DADF  F0 FB        	BEQ	LAB_27B9		; exit if zero
6090    
6091    DAE1  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
6092    DAE3  90 F7        	BCC	LAB_27B9		; exit if no overflow
6093    
6094    ; round FAC1 (no check)
6095    
6096    LAB_27C2
6097    DAE5  20 BC D8     	JSR	LAB_2559		; increment FAC1 mantissa
6098    DAE8  D0 F2        	BNE	LAB_27B9		; branch if no overflow
6099    
6100    DAEA  4C 8D D8     	JMP	LAB_252A		; normalise FAC1 for C=1 and return
6101    
6102    ; get FAC1 sign
6103    ; return A=FF,C=1/-ve A=01,C=0/+ve
6104    
6105    LAB_27CA
6106    DAED  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
6107    DAEF  F0 09        	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
6108    
6109    ; return A=FF,C=1/-ve A=01,C=0/+ve
6110    ; no = 0 check
6111    
6112    LAB_27CE
6113    DAF1  A5 B0        	LDA	FAC1_s		; else get FAC1 sign (b7)
6114    
6115    ; return A=FF,C=1/-ve A=01,C=0/+ve
6116    ; no = 0 check, sign in A
6117    
6118    LAB_27D0
6119    DAF3  2A           	ROL				; move sign bit to carry
6120    DAF4  A9 FF        	LDA	#$FF			; set byte for -ve result
6121    DAF6  B0 02        	BCS	LAB_27D7		; return if sign was set (-ve)
6122    
6123    DAF8  A9 01        	LDA	#$01			; else set byte for +ve result
6124    LAB_27D7
6125    DAFA  60           	RTS
6126    
6127    ; perform SGN()
6128    
6129    LAB_SGN
6130    DAFB  20 ED DA     	JSR	LAB_27CA		; get FAC1 sign
6131    					; return A=$FF/-ve A=$01/+ve
6132    ; save A as integer byte
6133    
6134    LAB_27DB
6135    DAFE  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
6136    DB00  A9 00        	LDA	#$00			; clear A
6137    DB02  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
6138    DB04  A2 88        	LDX	#$88			; set exponent
6139    
6140    ; set exp=X, clearFAC1 mantissa3 and normalise
6141    
6142    LAB_27E3
6143    DB06  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
6144    DB08  49 FF        	EOR	#$FF			; complement it
6145    DB0A  2A           	ROL				; sign bit into carry
6146    
6147    ; set exp=X, clearFAC1 mantissa3 and normalise
6148    
6149    LAB_STFA
6150    DB0B  A9 00        	LDA	#$00			; clear A
6151    DB0D  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
6152    DB0F  86 AC        	STX	FAC1_e		; set FAC1 exponent
6153    DB11  85 B9        	STA	FAC1_r		; clear FAC1 rounding byte
6154    DB13  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
6155    DB15  4C 33 D8     	JMP	LAB_24D0		; do ABS and normalise FAC1
6156    
6157    ; perform ABS()
6158    
6159    LAB_ABS
6160    DB18  46 B0        	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
6161    DB1A  60           	RTS
6162    
6163    ; compare FAC1 with (AY)
6164    ; returns A=$00 if FAC1 = (AY)
6165    ; returns A=$01 if FAC1 > (AY)
6166    ; returns A=$FF if FAC1 < (AY)
6167    
6168    LAB_27F8
6169    DB1B  85 73        	STA	ut2_pl		; save pointer low byte
6170    LAB_27FA
6171    DB1D  84 74        	STY	ut2_ph		; save pointer high byte
6172    DB1F  A0 00        	LDY	#$00			; clear index
6173    DB21  B1 73        	LDA	(ut2_pl),Y		; get exponent
6174    DB23  C8           	INY				; increment index
6175    DB24  AA           	TAX				; copy (AY) exponent to X
6176    DB25  F0 C6        	BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
6177    					; A=FF,C=1/-ve A=01,C=0/+ve
6178    
6179    DB27  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
6180    DB29  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
6181    DB2B  30 C4        	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
6182    					; A=01,C=0/+ve and return
6183    
6184    DB2D  E4 AC        	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
6185    DB2F  D0 1A        	BNE	LAB_2828		; branch if different
6186    
6187    DB31  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
6188    DB33  09 80        	ORA	#$80			; normalise top bit
6189    DB35  C5 AD        	CMP	FAC1_1		; compare with FAC1 mantissa1
6190    DB37  D0 12        	BNE	LAB_2828		; branch if different
6191    
6192    DB39  C8           	INY				; increment index
6193    DB3A  B1 73        	LDA	(ut2_pl),Y		; get mantissa2
6194    DB3C  C5 AE        	CMP	FAC1_2		; compare with FAC1 mantissa2
6195    DB3E  D0 0B        	BNE	LAB_2828		; branch if different
6196    
6197    DB40  C8           	INY				; increment index
6198    DB41  A9 7F        	LDA	#$7F			; set for 1/2 value rounding byte
6199    DB43  C5 B9        	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
6200    DB45  B1 73        	LDA	(ut2_pl),Y		; get mantissa3
6201    DB47  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
6202    DB49  F0 28        	BEQ	LAB_2850		; exit if mantissa3 equal
6203    
6204    ; gets here if number <> FAC1
6205    
6206    LAB_2828
6207    DB4B  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
6208    DB4D  90 02        	BCC	LAB_282E		; branch if FAC1 > (AY)
6209    
6210    DB4F  49 FF        	EOR	#$FF			; else toggle FAC1 sign
6211    LAB_282E
6212    DB51  4C F3 DA     	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
6213    
6214    ; convert FAC1 floating-to-fixed
6215    
6216    LAB_2831
6217    DB54  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
6218    DB56  F0 4A        	BEQ	LAB_287F		; if zero go clear FAC1 and return
6219    
6220    DB58  38           	SEC				; set carry for subtract
6221    DB59  E9 98        	SBC	#$98			; subtract maximum integer range exponent
6222    DB5B  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
6223    DB5D  10 09        	BPL	LAB_2845		; branch if FAC1 +ve
6224    
6225    					; FAC1 was -ve
6226    DB5F  AA           	TAX				; copy subtracted exponent
6227    DB60  A9 FF        	LDA	#$FF			; overflow for -ve number
6228    DB62  85 B2        	STA	FAC1_o		; set FAC1 overflow byte
6229    DB64  20 A0 D8     	JSR	LAB_253D		; twos complement FAC1 mantissa
6230    DB67  8A           	TXA				; restore subtracted exponent
6231    LAB_2845
6232    DB68  A2 AC        	LDX	#FAC1_e		; set index to FAC1
6233    DB6A  C9 F9        	CMP	#$F9			; compare exponent result
6234    DB6C  10 06        	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
6235    
6236    DB6E  20 DE D8     	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
6237    DB71  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
6238    LAB_2850
6239    DB73  60           	RTS
6240    
6241    ; shift FAC1 A times right
6242    
6243    LAB_2851
6244    DB74  A8           	TAY				; copy shift count
6245    DB75  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
6246    DB77  29 80        	AND	#$80			; mask sign bit only (x000 0000)
6247    DB79  46 AD        	LSR	FAC1_1		; shift FAC1 mantissa1
6248    DB7B  05 AD        	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
6249    DB7D  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
6250    DB7F  20 F5 D8     	JSR	LAB_2592		; shift FAC1 Y times right
6251    DB82  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
6252    DB84  60           	RTS
6253    
6254    ; perform INT()
6255    
6256    LAB_INT
6257    DB85  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
6258    DB87  C9 98        	CMP	#$98			; compare with max int
6259    DB89  B0 1E        	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
6260    
6261    DB8B  20 54 DB     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
6262    DB8E  84 B9        	STY	FAC1_r		; save FAC1 rounding byte
6263    DB90  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
6264    DB92  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
6265    DB94  49 80        	EOR	#$80			; toggle FAC1 sign
6266    DB96  2A           	ROL				; shift into carry
6267    DB97  A9 98        	LDA	#$98			; set new exponent
6268    DB99  85 AC        	STA	FAC1_e		; save FAC1 exponent
6269    DB9B  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
6270    DB9D  85 5B        	STA	Temp3			; save for EXP() function
6271    DB9F  4C 33 D8     	JMP	LAB_24D0		; do ABS and normalise FAC1
6272    
6273    ; clear FAC1 and return
6274    
6275    LAB_287F
6276    DBA2  85 AD        	STA	FAC1_1		; clear FAC1 mantissa1
6277    DBA4  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
6278    DBA6  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
6279    DBA8  A8           	TAY				; clear Y
6280    LAB_2886
6281    DBA9  60           	RTS
6282    
6283    ; get FAC1 from string
6284    ; this routine now handles hex and binary values from strings
6285    ; starting with "$" and "%" respectively
6286    
6287    LAB_2887
6288    DBAA  A0 00        	LDY	#$00			; clear Y
6289    DBAC  84 5F        	STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
6290    DBAE  A2 09        	LDX	#$09			; set index
6291    LAB_288B
6292    DBB0  94 A8        	STY	numexp,X		; clear byte
6293    DBB2  CA           	DEX				; decrement index
6294    DBB3  10 FB        	BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
6295    
6296    DBB5  90 7F        	BCC	LAB_28FE		; branch if 1st character numeric
6297    
6298    ; get FAC1 from string .. first character wasn't numeric
6299    
6300    DBB7  C9 2D        	CMP	#'-'			; else compare with "-"
6301    DBB9  D0 04        	BNE	LAB_289A		; branch if not "-"
6302    
6303    DBBB  86 B1        	STX	negnum		; set flag for -ve number (X = $FF)
6304    DBBD  F0 04        	BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
6305    
6306    ; get FAC1 from string .. first character wasn't numeric or -
6307    
6308    LAB_289A
6309    DBBF  C9 2B        	CMP	#'+'			; else compare with "+"
6310    DBC1  D0 05        	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
6311    
6312    ; was "+" or "-" to start, so get next character
6313    
6314    LAB_289C
6315    DBC3  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
6316    DBC6  90 6E        	BCC	LAB_28FE		; branch if numeric character
6317    
6318    ; code here for hex and binary numbers
6319    
6320    LAB_289D
6321    DBC8  C9 24        	CMP	#'$'			; else compare with "$"
6322    DBCA  D0 03        	BNE	LAB_NHEX		; branch if not "$"
6323    
6324    DBCC  4C 72 E0     	JMP	LAB_CHEX		; branch if "$"
6325    
6326    LAB_NHEX
6327    DBCF  C9 25        	CMP	#'%'			; else compare with "%"
6328    DBD1  D0 08        	BNE	LAB_28A3		; branch if not "%" (continue original code)
6329    
6330    DBD3  4C A0 E0     	JMP	LAB_CBIN		; branch if "%"
6331    
6332    LAB_289E
6333    DBD6  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
6334    LAB_28A1
6335    DBD9  90 5B        	BCC	LAB_28FE		; branch if numeric character
6336    
6337    ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
6338    
6339    LAB_28A3
6340    DBDB  C9 2E        	CMP	#'.'			; else compare with "."
6341    DBDD  F0 2E        	BEQ	LAB_28D5		; branch if "."
6342    
6343    ; get FAC1 from string .. character wasn't numeric, -, + or .
6344    
6345    DBDF  C9 45        	CMP	#'E'			; else compare with "E"
6346    DBE1  D0 30        	BNE	LAB_28DB		; branch if not "E"
6347    
6348    					; was "E" so evaluate exponential part
6349    DBE3  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
6350    DBE6  90 17        	BCC	LAB_28C7		; branch if numeric character
6351    
6352    DBE8  C9 B8        	CMP	#TK_MINUS		; else compare with token for -
6353    DBEA  F0 0E        	BEQ	LAB_28C2		; branch if token for -
6354    
6355    DBEC  C9 2D        	CMP	#'-'			; else compare with "-"
6356    DBEE  F0 0A        	BEQ	LAB_28C2		; branch if "-"
6357    
6358    DBF0  C9 B7        	CMP	#TK_PLUS		; else compare with token for +
6359    DBF2  F0 08        	BEQ	LAB_28C4		; branch if token for +
6360    
6361    DBF4  C9 2B        	CMP	#'+'			; else compare with "+"
6362    DBF6  F0 04        	BEQ	LAB_28C4		; branch if "+"
6363    
6364    DBF8  D0 07        	BNE	LAB_28C9		; branch always
6365    
6366    LAB_28C2
6367    DBFA  66 AB        	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
6368    LAB_28C4
6369    DBFC  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
6370    LAB_28C7
6371    DBFF  90 5B        	BCC	LAB_2925		; branch if numeric character
6372    
6373    LAB_28C9
6374    DC01  24 AB        	BIT	expneg		; test exponent -ve flag
6375    DC03  10 0E        	BPL	LAB_28DB		; if +ve go evaluate exponent
6376    
6377    					; else do exponent = -exponent 
6378    DC05  A9 00        	LDA	#$00			; clear result
6379    DC07  38           	SEC				; set carry for subtract
6380    DC08  E5 A9        	SBC	expcnt		; subtract exponent byte
6381    DC0A  4C 15 DC     	JMP	LAB_28DD		; go evaluate exponent
6382    
6383    LAB_28D5
6384    DC0D  66 AA        	ROR	numdpf		; set decimal point flag
6385    DC0F  24 AA        	BIT	numdpf		; test decimal point flag
6386    DC11  50 C3        	BVC	LAB_289E		; branch if only one decimal point so far
6387    
6388    					; evaluate exponent
6389    LAB_28DB
6390    DC13  A5 A9        	LDA	expcnt		; get exponent count byte
6391    LAB_28DD
6392    DC15  38           	SEC				; set carry for subtract
6393    DC16  E5 A8        	SBC	numexp		; subtract numerator exponent
6394    DC18  85 A9        	STA	expcnt		; save exponent count byte
6395    DC1A  F0 12        	BEQ	LAB_28F6		; branch if no adjustment
6396    
6397    DC1C  10 09        	BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
6398    
6399    					; else go do FAC1/10^(0-expcnt)
6400    LAB_28E6
6401    DC1E  20 F4 D9     	JSR	LAB_26B9		; divide by 10
6402    DC21  E6 A9        	INC	expcnt		; increment exponent count byte
6403    DC23  D0 F9        	BNE	LAB_28E6		; loop until all done
6404    
6405    DC25  F0 07        	BEQ	LAB_28F6		; branch always
6406    
6407    LAB_28EF
6408    DC27  20 DB D9     	JSR	LAB_269E		; multiply by 10
6409    DC2A  C6 A9        	DEC	expcnt		; decrement exponent count byte
6410    DC2C  D0 F9        	BNE	LAB_28EF		; loop until all done
6411    
6412    LAB_28F6
6413    DC2E  A5 B1        	LDA	negnum		; get -ve flag
6414    DC30  30 01        	BMI	LAB_28FB		; if -ve do - FAC1 and return
6415    
6416    DC32  60           	RTS
6417    
6418    ; do - FAC1 and return
6419    
6420    LAB_28FB
6421    DC33  4C F8 DD     	JMP	LAB_GTHAN		; do - FAC1 and return
6422    
6423    ; do unsigned FAC1*10+number
6424    
6425    LAB_28FE
6426    DC36  48           	PHA				; save character
6427    DC37  24 AA        	BIT	numdpf		; test decimal point flag
6428    DC39  10 02        	BPL	LAB_2905		; skip exponent increment if not set
6429    
6430    DC3B  E6 A8        	INC	numexp		; else increment number exponent
6431    LAB_2905
6432    DC3D  20 DB D9     	JSR	LAB_269E		; multiply FAC1 by 10
6433    DC40  68           	PLA				; restore character
6434    DC41  29 0F        	AND	#$0F			; convert to binary
6435    DC43  20 49 DC     	JSR	LAB_2912		; evaluate new ASCII digit
6436    DC46  4C D6 DB     	JMP	LAB_289E		; go do next character
6437    
6438    ; evaluate new ASCII digit
6439    
6440    LAB_2912
6441    DC49  48           	PHA				; save digit
6442    DC4A  20 CE DA     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
6443    DC4D  68           	PLA				; restore digit
6444    DC4E  20 FE DA     	JSR	LAB_27DB		; save A as integer byte
6445    DC51  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
6446    DC53  45 B0        	EOR	FAC1_s		; toggle with FAC1 sign (b7)
6447    DC55  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
6448    DC57  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
6449    DC59  4C C5 D7     	JMP	LAB_ADD		; add FAC2 to FAC1 and return
6450    
6451    ; evaluate next character of exponential part of number
6452    
6453    LAB_2925
6454    DC5C  A5 A9        	LDA	expcnt		; get exponent count byte
6455    DC5E  C9 0A        	CMP	#$0A			; compare with 10 decimal
6456    DC60  90 09        	BCC	LAB_2934		; branch if less
6457    
6458    DC62  A9 64        	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
6459    DC64  24 AB        	BIT	expneg		; test exponent -ve flag
6460    DC66  30 0E        	BMI	LAB_2942		; branch if -ve
6461    
6462    DC68  4C C7 D8     	JMP	LAB_2564		; else do overflow error
6463    
6464    LAB_2934
6465    DC6B  0A           	ASL				; * 2
6466    DC6C  0A           	ASL				; * 4
6467    DC6D  65 A9        	ADC	expcnt		; * 5
6468    DC6F  0A           	ASL				; * 10
6469    DC70  A0 00        	LDY	#$00			; set index
6470    DC72  71 C3        	ADC	(Bpntrl),Y		; add character (will be $30 too much!)
6471    DC74  E9 2F        	SBC	#'0'-1		; convert character to binary
6472    LAB_2942
6473    DC76  85 A9        	STA	expcnt		; save exponent count byte
6474    DC78  4C FC DB     	JMP	LAB_28C4		; go get next character
6475    
6476    ; print " in line [LINE #]"
6477    
6478    LAB_2953
6479    DC7B  A9 02        	LDA	#<LAB_LMSG		; point to " in line " message low byte
6480    DC7D  A0 EA        	LDY	#>LAB_LMSG		; point to " in line " message high byte
6481    DC7F  20 D7 CA     	JSR	LAB_18C3		; print null terminated string from memory
6482    
6483    					; print Basic line #
6484    DC82  A5 88        	LDA	Clineh		; get current line high byte
6485    DC84  A6 87        	LDX	Clinel		; get current line low byte
6486    
6487    ; print XA as unsigned integer
6488    
6489    LAB_295E
6490    DC86  85 AD        	STA	FAC1_1		; save low byte as FAC1 mantissa1
6491    DC88  86 AE        	STX	FAC1_2		; save high byte as FAC1 mantissa2
6492    DC8A  A2 90        	LDX	#$90			; set exponent to 16d bits
6493    DC8C  38           	SEC				; set integer is +ve flag
6494    DC8D  20 0B DB     	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
6495    DC90  A0 00        	LDY	#$00			; clear index
6496    DC92  98           	TYA				; clear A
6497    DC93  20 A6 DC     	JSR	LAB_297B		; convert FAC1 to string, skip sign character save
6498    DC96  4C D7 CA     	JMP	LAB_18C3		; print null terminated string from memory and return
6499    
6500    ; convert FAC1 to ASCII string result in (AY)
6501    ; not any more, moved scratchpad to page 0
6502    
6503    LAB_296E
6504    DC99  A0 01        	LDY	#$01			; set index = 1
6505    DC9B  A9 20        	LDA	#$20			; character = " " (assume +ve)
6506    DC9D  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
6507    DC9F  10 02        	BPL	LAB_2978		; branch if +ve
6508    
6509    DCA1  A9 2D        	LDA	#$2D			; else character = "-"
6510    LAB_2978
6511    DCA3  99 EF 00     	STA	Decss,Y		; save leading character (" " or "-")
6512    LAB_297B
6513    DCA6  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
6514    DCA8  84 BA        	STY	Sendl			; save index
6515    DCAA  C8           	INY				; increment index
6516    DCAB  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
6517    DCAD  D0 05        	BNE	LAB_2989		; branch if FAC1<>0
6518    
6519    					; exponent was $00 so FAC1 is 0
6520    DCAF  A9 30        	LDA	#'0'			; set character = "0"
6521    DCB1  4C B2 DD     	JMP	LAB_2A89		; save last character, [EOT] and exit
6522    
6523    					; FAC1 is some non zero value
6524    LAB_2989
6525    DCB4  A9 00        	LDA	#$00			; clear (number exponent count)
6526    DCB6  E0 81        	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
6527    
6528    DCB8  B0 09        	BCS	LAB_299A		; branch if FAC1=>1
6529    
6530    					; FAC1<1
6531    DCBA  A9 8D        	LDA	#<LAB_294F		; set pointer low byte to 1,000,000
6532    DCBC  A0 E3        	LDY	#>LAB_294F		; set pointer high byte to 1,000,000
6533    DCBE  20 3D D9     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
6534    DCC1  A9 FA        	LDA	#$FA			; set number exponent count (-6)
6535    LAB_299A
6536    DCC3  85 A8        	STA	numexp		; save number exponent count
6537    LAB_299C
6538    DCC5  A9 89        	LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
6539    DCC7  A0 E3        	LDY	#>LAB_294B		; set pointer high byte to 999999.4375
6540    DCC9  20 1B DB     	JSR	LAB_27F8		; compare FAC1 with (AY)
6541    DCCC  F0 1E        	BEQ	LAB_29C3		; exit if FAC1 = (AY)
6542    
6543    DCCE  10 12        	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
6544    
6545    					; FAC1 < (AY)
6546    LAB_29A7
6547    DCD0  A9 85        	LDA	#<LAB_2947		; set pointer low byte to 99999.9375
6548    DCD2  A0 E3        	LDY	#>LAB_2947		; set pointer high byte to 99999.9375
6549    DCD4  20 1B DB     	JSR	LAB_27F8		; compare FAC1 with (AY)
6550    DCD7  F0 02        	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
6551    
6552    DCD9  10 0E        	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
6553    
6554    					; FAC1 <= (AY)
6555    LAB_29B2
6556    DCDB  20 DB D9     	JSR	LAB_269E		; multiply by 10
6557    DCDE  C6 A8        	DEC	numexp		; decrement number exponent count
6558    DCE0  D0 EE        	BNE	LAB_29A7		; go test again (branch always)
6559    
6560    LAB_29B9
6561    DCE2  20 F4 D9     	JSR	LAB_26B9		; divide by 10
6562    DCE5  E6 A8        	INC	numexp		; increment number exponent count
6563    DCE7  D0 DC        	BNE	LAB_299C		; go test again (branch always)
6564    
6565    ; now we have just the digits to do
6566    
6567    LAB_29C0
6568    DCE9  20 BE D7     	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
6569    LAB_29C3
6570    DCEC  20 54 DB     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
6571    DCEF  A2 01        	LDX	#$01			; set default digits before dp = 1
6572    DCF1  A5 A8        	LDA	numexp		; get number exponent count
6573    DCF3  18           	CLC				; clear carry for add
6574    DCF4  69 07        	ADC	#$07			; up to 6 digits before point
6575    DCF6  30 09        	BMI	LAB_29D8		; if -ve then 1 digit before dp
6576    
6577    DCF8  C9 08        	CMP	#$08			; A>=8 if n>=1E6
6578    DCFA  B0 06        	BCS	LAB_29D9		; branch if >= $08
6579    
6580    					; carry is clear
6581    DCFC  69 FF        	ADC	#$FF			; take 1 from digit count
6582    DCFE  AA           	TAX				; copy to A
6583    DCFF  A9 02        	LDA	#$02			;.set exponent adjust
6584    LAB_29D8
6585    DD01  38           	SEC				; set carry for subtract
6586    LAB_29D9
6587    DD02  E9 02        	SBC	#$02			; -2
6588    DD04  85 A9        	STA	expcnt		;.save exponent adjust
6589    DD06  86 A8        	STX	numexp		; save digits before dp count
6590    DD08  8A           	TXA				; copy to A
6591    DD09  F0 02        	BEQ	LAB_29E4		; branch if no digits before dp
6592    
6593    DD0B  10 13        	BPL	LAB_29F7		; branch if digits before dp
6594    
6595    LAB_29E4
6596    DD0D  A4 BA        	LDY	Sendl			; get output string index
6597    DD0F  A9 2E        	LDA	#$2E			; character "."
6598    DD11  C8           	INY				; increment index
6599    DD12  99 EF 00     	STA	Decss,Y		; save to output string
6600    DD15  8A           	TXA				;.
6601    DD16  F0 06        	BEQ	LAB_29F5		;.
6602    
6603    DD18  A9 30        	LDA	#'0'			; character "0"
6604    DD1A  C8           	INY				; increment index
6605    DD1B  99 EF 00     	STA	Decss,Y		; save to output string
6606    LAB_29F5
6607    DD1E  84 BA        	STY	Sendl			; save output string index
6608    LAB_29F7
6609    DD20  A0 00        	LDY	#$00			; clear index (point to 100,000)
6610    DD22  A2 80        	LDX	#$80			; 
6611    LAB_29FB
6612    DD24  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
6613    DD26  18           	CLC				; clear carry for add
6614    DD27  79 03 E4     	ADC	LAB_2A9C,Y		; add -ve LSB
6615    DD2A  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
6616    DD2C  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
6617    DD2E  79 02 E4     	ADC	LAB_2A9B,Y		; add -ve NMSB
6618    DD31  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
6619    DD33  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
6620    DD35  79 01 E4     	ADC	LAB_2A9A,Y		; add -ve MSB
6621    DD38  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
6622    DD3A  E8           	INX				; 
6623    DD3B  B0 04        	BCS	LAB_2A18		; 
6624    
6625    DD3D  10 E5        	BPL	LAB_29FB		; not -ve so try again
6626    
6627    DD3F  30 02        	BMI	LAB_2A1A		; 
6628    
6629    LAB_2A18
6630    DD41  30 E1        	BMI	LAB_29FB		; 
6631    
6632    LAB_2A1A
6633    DD43  8A           	TXA				; 
6634    DD44  90 04        	BCC	LAB_2A21		; 
6635    
6636    DD46  49 FF        	EOR	#$FF			; 
6637    DD48  69 0A        	ADC	#$0A			; 
6638    LAB_2A21
6639    DD4A  69 2F        	ADC	#'0'-1		; add "0"-1 to result
6640    DD4C  C8           	INY				; increment index ..
6641    DD4D  C8           	INY				; .. to next less ..
6642    DD4E  C8           	INY				; .. power of ten
6643    DD4F  84 95        	STY	Cvaral		; save as current var address low byte
6644    DD51  A4 BA        	LDY	Sendl			; get output string index
6645    DD53  C8           	INY				; increment output string index
6646    DD54  AA           	TAX				; copy character to X
6647    DD55  29 7F        	AND	#$7F			; mask out top bit
6648    DD57  99 EF 00     	STA	Decss,Y		; save to output string
6649    DD5A  C6 A8        	DEC	numexp		; decrement # of characters before the dp
6650    DD5C  D0 06        	BNE	LAB_2A3B		; branch if still characters to do
6651    
6652    					; else output the point
6653    DD5E  A9 2E        	LDA	#$2E			; character "."
6654    DD60  C8           	INY				; increment output string index
6655    DD61  99 EF 00     	STA	Decss,Y		; save to output string
6656    LAB_2A3B
6657    DD64  84 BA        	STY	Sendl			; save output string index
6658    DD66  A4 95        	LDY	Cvaral		; get current var address low byte
6659    DD68  8A           	TXA				; get character back
6660    DD69  49 FF        	EOR	#$FF			; 
6661    DD6B  29 80        	AND	#$80			; 
6662    DD6D  AA           	TAX				; 
6663    DD6E  C0 12        	CPY	#$12			; compare index with max
6664    DD70  D0 B2        	BNE	LAB_29FB		; loop if not max
6665    
6666    					; now remove trailing zeroes
6667    DD72  A4 BA        	LDY	Sendl			; get output string index
6668    LAB_2A4B
6669    DD74  B9 EF 00     	LDA	Decss,Y		; get character from output string
6670    DD77  88           	DEY				; decrement output string index
6671    DD78  C9 30        	CMP	#'0'			; compare with "0"
6672    DD7A  F0 F8        	BEQ	LAB_2A4B		; loop until non "0" character found
6673    
6674    DD7C  C9 2E        	CMP	#'.'			; compare with "."
6675    DD7E  F0 01        	BEQ	LAB_2A58		; branch if was dp
6676    
6677    					; restore last character
6678    DD80  C8           	INY				; increment output string index
6679    LAB_2A58
6680    DD81  A9 2B        	LDA	#$2B			; character "+"
6681    DD83  A6 A9        	LDX	expcnt		; get exponent count
6682    DD85  F0 2E        	BEQ	LAB_2A8C		; if zero go set null terminator and exit
6683    
6684    					; exponent isn't zero so write exponent
6685    DD87  10 08        	BPL	LAB_2A68		; branch if exponent count +ve
6686    
6687    DD89  A9 00        	LDA	#$00			; clear A
6688    DD8B  38           	SEC				; set carry for subtract
6689    DD8C  E5 A9        	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
6690    DD8E  AA           	TAX				; copy exponent count to X
6691    DD8F  A9 2D        	LDA	#'-'			; character "-"
6692    LAB_2A68
6693    DD91  99 F1 00     	STA	Decss+2,Y		; save to output string
6694    DD94  A9 45        	LDA	#$45			; character "E"
6695    DD96  99 F0 00     	STA	Decss+1,Y		; save exponent sign to output string
6696    DD99  8A           	TXA				; get exponent count back
6697    DD9A  A2 2F        	LDX	#'0'-1		; one less than "0" character
6698    DD9C  38           	SEC				; set carry for subtract
6699    LAB_2A74
6700    DD9D  E8           	INX				; increment 10's character
6701    DD9E  E9 0A        	SBC	#$0A			;.subtract 10 from exponent count
6702    DDA0  B0 FB        	BCS	LAB_2A74		; loop while still >= 0
6703    
6704    DDA2  69 3A        	ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
6705    DDA4  99 F3 00     	STA	Decss+4,Y		; save to output string
6706    DDA7  8A           	TXA				; copy 10's character
6707    DDA8  99 F2 00     	STA	Decss+3,Y		; save to output string
6708    DDAB  A9 00        	LDA	#$00			; set null terminator
6709    DDAD  99 F4 00     	STA	Decss+5,Y		; save to output string
6710    DDB0  F0 08        	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
6711    
6712    					; save last character, [EOT] and exit
6713    LAB_2A89
6714    DDB2  99 EF 00     	STA	Decss,Y		; save last character to output string
6715    
6716    					; set null terminator and exit
6717    LAB_2A8C
6718    DDB5  A9 00        	LDA	#$00			; set null terminator
6719    DDB7  99 F0 00     	STA	Decss+1,Y		; save after last character
6720    
6721    					; set string pointer (AY) and exit
6722    LAB_2A91
6723    DDBA  A9 F0        	LDA	#<Decssp1		; set result string low pointer
6724    DDBC  A0 00        	LDY	#>Decssp1		; set result string high pointer
6725    DDBE  60           	RTS
6726    
6727    ; perform power function
6728    
6729    LAB_POWER
6730    DDBF  F0 42        	BEQ	LAB_EXP		; go do  EXP()
6731    
6732    DDC1  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
6733    DDC3  D0 03        	BNE	LAB_2ABF		; branch if FAC2<>0
6734    
6735    DDC5  4C 56 D8     	JMP	LAB_24F3		; clear FAC1 exponent and sign and return
6736    
6737    LAB_2ABF
6738    DDC8  A2 9C        	LDX	#<func_l		; set destination pointer low byte
6739    DDCA  A0 00        	LDY	#>func_l		; set destination pointer high byte
6740    DDCC  20 AB DA     	JSR	LAB_2778		; pack FAC1 into (XY)
6741    DDCF  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
6742    DDD1  10 0F        	BPL	LAB_2AD9		; branch if FAC2>0
6743    
6744    					; else FAC2 is -ve and can only be raised to an
6745    					; integer power which gives an x +j0 result
6746    DDD3  20 85 DB     	JSR	LAB_INT		; perform INT
6747    DDD6  A9 9C        	LDA	#<func_l		; set source pointer low byte
6748    DDD8  A0 00        	LDY	#>func_l		; set source pointer high byte
6749    DDDA  20 1B DB     	JSR	LAB_27F8		; compare FAC1 with (AY)
6750    DDDD  D0 03        	BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
6751    					; this will leave FAC1 -ve and cause a Function Call
6752    					; error when LOG() is called
6753    
6754    DDDF  98           	TYA				; clear sign b7
6755    DDE0  A4 5B        	LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
6756    					; for possible later negation, b0
6757    LAB_2AD9
6758    DDE2  20 C9 D7     	JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
6759    DDE5  98           	TYA				; copy sign back ..
6760    DDE6  48           	PHA				; .. and save it
6761    DDE7  20 FF D8     	JSR	LAB_LOG		; do LOG(n)
6762    DDEA  A9 9C        	LDA	#<garb_l		; set pointer low byte
6763    DDEC  A0 00        	LDY	#>garb_l		; set pointer high byte
6764    DDEE  20 3D D9     	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
6765    DDF1  20 03 DE     	JSR	LAB_EXP		; go do EXP(n)
6766    DDF4  68           	PLA				; pull sign from stack
6767    DDF5  4A           	LSR				; b0 is to be tested, shift to Cb
6768    DDF6  90 0A        	BCC	LAB_2AF9		; if no bit then exit
6769    
6770    					; Perform negation
6771    ; do - FAC1
6772    
6773    LAB_GTHAN
6774    DDF8  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
6775    DDFA  F0 06        	BEQ	LAB_2AF9		; exit if FAC1_e = $00
6776    
6777    DDFC  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
6778    DDFE  49 FF        	EOR	#$FF			; complement it
6779    DE00  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
6780    LAB_2AF9
6781    DE02  60           	RTS
6782    
6783    ; perform EXP()	(x^e)
6784    
6785    LAB_EXP
6786    DE03  A9 91        	LDA	#<LAB_2AFA		; set 1.443 pointer low byte
6787    DE05  A0 E3        	LDY	#>LAB_2AFA		; set 1.443 pointer high byte
6788    DE07  20 3D D9     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
6789    DE0A  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
6790    DE0C  69 50        	ADC	#$50			; +$50/$100
6791    DE0E  90 03        	BCC	LAB_2B2B		; skip rounding if no carry
6792    
6793    DE10  20 E5 DA     	JSR	LAB_27C2		; round FAC1 (no check)
6794    LAB_2B2B
6795    DE13  85 A3        	STA	FAC2_r		; save FAC2 rounding byte
6796    DE15  20 D1 DA     	JSR	LAB_27AE		; copy FAC1 to FAC2
6797    DE18  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
6798    DE1A  C9 88        	CMP	#$88			; compare with EXP limit (256d)
6799    DE1C  90 03        	BCC	LAB_2B39		; branch if less
6800    
6801    LAB_2B36
6802    DE1E  20 D2 D9     	JSR	LAB_2690		; handle overflow and underflow
6803    LAB_2B39
6804    DE21  20 85 DB     	JSR	LAB_INT		; perform INT
6805    DE24  A5 5B        	LDA	Temp3			; get mantissa 3 from INT() function
6806    DE26  18           	CLC				; clear carry for add
6807    DE27  69 81        	ADC	#$81			; normalise +1
6808    DE29  F0 F3        	BEQ	LAB_2B36		; if $00 go handle overflow
6809    
6810    DE2B  38           	SEC				; set carry for subtract
6811    DE2C  E9 01        	SBC	#$01			; now correct for exponent
6812    DE2E  48           	PHA				; save FAC2 exponent
6813    
6814    					; swap FAC1 and FAC2
6815    DE2F  A2 04        	LDX	#$04			; 4 bytes to do
6816    LAB_2B49
6817    DE31  B5 B3        	LDA	FAC2_e,X		; get FAC2,X
6818    DE33  B4 AC        	LDY	FAC1_e,X		; get FAC1,X
6819    DE35  95 AC        	STA	FAC1_e,X		; save FAC1,X
6820    DE37  94 B3        	STY	FAC2_e,X		; save FAC2,X
6821    DE39  CA           	DEX				; decrement count/index
6822    DE3A  10 F5        	BPL	LAB_2B49		; loop if not all done
6823    
6824    DE3C  A5 A3        	LDA	FAC2_r		; get FAC2 rounding byte
6825    DE3E  85 B9        	STA	FAC1_r		; save as FAC1 rounding byte
6826    DE40  20 AA D7     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
6827    DE43  20 F8 DD     	JSR	LAB_GTHAN		; do - FAC1
6828    DE46  A9 95        	LDA	#<LAB_2AFE		; set counter pointer low byte
6829    DE48  A0 E3        	LDY	#>LAB_2AFE		; set counter pointer high byte
6830    DE4A  20 6B DE     	JSR	LAB_2B84		; go do series evaluation
6831    DE4D  A9 00        	LDA	#$00			; clear A
6832    DE4F  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
6833    DE51  68           	PLA				;.get saved FAC2 exponent
6834    DE52  4C B7 D9     	JMP	LAB_2675		; test and adjust accumulators and return
6835    
6836    ; ^2 then series evaluation
6837    
6838    LAB_2B6E
6839    DE55  85 BA        	STA	Cptrl			; save count pointer low byte
6840    DE57  84 BB        	STY	Cptrh			; save count pointer high byte
6841    DE59  20 A1 DA     	JSR	LAB_276E		; pack FAC1 into Adatal
6842    DE5C  A9 A4        	LDA	#<Adatal		; set pointer low byte (Y already $00)
6843    DE5E  20 3D D9     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
6844    DE61  20 6F DE     	JSR	LAB_2B88		; go do series evaluation
6845    DE64  A9 A4        	LDA	#<Adatal		; pointer to original # low byte
6846    DE66  A0 00        	LDY	#>Adatal		; pointer to original # high byte
6847    DE68  4C 3D D9     	JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
6848    
6849    ; series evaluation
6850    
6851    LAB_2B84
6852    DE6B  85 BA        	STA	Cptrl			; save count pointer low byte
6853    DE6D  84 BB        	STY	Cptrh			; save count pointer high byte
6854    LAB_2B88
6855    DE6F  A2 A8        	LDX	#<numexp		; set pointer low byte
6856    DE71  20 A3 DA     	JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
6857    DE74  B1 BA        	LDA	(Cptrl),Y		; get constants count
6858    DE76  85 B1        	STA	numcon		; save constants count
6859    DE78  A4 BA        	LDY	Cptrl			; get count pointer low byte
6860    DE7A  C8           	INY				; increment it (now constants pointer)
6861    DE7B  98           	TYA				; copy it
6862    DE7C  D0 02        	BNE	LAB_2B97		; skip next if no overflow
6863    
6864    DE7E  E6 BB        	INC	Cptrh			; else increment high byte
6865    LAB_2B97
6866    DE80  85 BA        	STA	Cptrl			; save low byte
6867    DE82  A4 BB        	LDY	Cptrh			; get high byte
6868    LAB_2B9B
6869    DE84  20 3D D9     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
6870    DE87  A5 BA        	LDA	Cptrl			; get constants pointer low byte
6871    DE89  A4 BB        	LDY	Cptrh			; get constants pointer high byte
6872    DE8B  18           	CLC				; clear carry for add
6873    DE8C  69 04        	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
6874    DE8E  90 01        	BCC	LAB_2BA8		; skip next if no overflow
6875    
6876    DE90  C8           	INY				; increment high byte
6877    LAB_2BA8
6878    DE91  85 BA        	STA	Cptrl			; save pointer low byte
6879    DE93  84 BB        	STY	Cptrh			; save pointer high byte
6880    DE95  20 C2 D7     	JSR	LAB_246C		; add (AY) to FAC1
6881    DE98  A9 A8        	LDA	#<numexp		; set pointer low byte to partial @ numexp
6882    DE9A  A0 00        	LDY	#>numexp		; set pointer high byte to partial @ numexp
6883    DE9C  C6 B1        	DEC	numcon		; decrement constants count
6884    DE9E  D0 E4        	BNE	LAB_2B9B		; loop until all done
6885    
6886    DEA0  60           	RTS
6887    
6888    ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
6889    ; to get 19th next number in sequence after seed n. This version of the PRNG uses
6890    ; the Galois method and a sample of 65536 bytes produced gives the following values.
6891    
6892    ; Entropy = 7.997442 bits per byte
6893    ; Optimum compression would reduce these 65536 bytes by 0 percent
6894    
6895    ; Chi square distribution for 65536 samples is 232.01, and
6896    ; randomly would exceed this value 75.00 percent of the time
6897    
6898    ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
6899    ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
6900    ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
6901    
6902    LAB_RND
6903    DEA1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
6904    DEA3  F0 07        	BEQ	NextPRN		; do next random # if zero
6905    
6906    					; else get seed into random number store
6907    DEA5  A2 D8        	LDX	#Rbyte4		; set PRNG pointer low byte
6908    DEA7  A0 00        	LDY	#$00			; set PRNG pointer high byte
6909    DEA9  20 AB DA     	JSR	LAB_2778		; pack FAC1 into (XY)
6910    NextPRN
6911    DEAC  A2 AF        	LDX	#$AF			; set EOR byte
6912    DEAE  A0 13        	LDY	#$13			; do this nineteen times
6913    LoopPRN
6914    DEB0  06 D9        	ASL	Rbyte1		; shift PRNG most significant byte
6915    DEB2  26 DA        	ROL	Rbyte2		; shift PRNG middle byte
6916    DEB4  26 DB        	ROL	Rbyte3		; shift PRNG least significant byte
6917    DEB6  26 D8        	ROL	Rbyte4		; shift PRNG extra byte
6918    DEB8  90 05        	BCC	Ninc1			; branch if bit 32 clear
6919    
6920    DEBA  8A           	TXA				; set EOR byte
6921    DEBB  45 D9        	EOR	Rbyte1		; EOR PRNG extra byte
6922    DEBD  85 D9        	STA	Rbyte1		; save new PRNG extra byte
6923    Ninc1
6924    DEBF  88           	DEY				; decrement loop count
6925    DEC0  D0 EE        	BNE	LoopPRN		; loop if not all done
6926    
6927    DEC2  A2 02        	LDX	#$02			; three bytes to copy
6928    CopyPRNG
6929    DEC4  B5 D9        	LDA	Rbyte1,X		; get PRNG byte
6930    DEC6  95 AD        	STA	FAC1_1,X		; save FAC1 byte
6931    DEC8  CA           	DEX
6932    DEC9  10 F9        	BPL	CopyPRNG		; loop if not complete
6933    
6934    DECB  A9 80        	LDA	#$80			; set the exponent
6935    DECD  85 AC        	STA	FAC1_e		; save FAC1 exponent
6936    
6937    DECF  0A           	ASL				; clear A
6938    DED0  85 B0        	STA	FAC1_s		; save FAC1 sign
6939    
6940    DED2  4C 38 D8     	JMP	LAB_24D5		; normalise FAC1 and return
6941    
6942    ; perform COS()
6943    
6944    LAB_COS
6945    DED5  A9 B2        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
6946    DED7  A0 E3        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
6947    DED9  20 C2 D7     	JSR	LAB_246C		; add (AY) to FAC1
6948    
6949    ; perform SIN()
6950    
6951    LAB_SIN
6952    DEDC  20 CE DA     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
6953    DEDF  A9 C7        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
6954    DEE1  A0 E3        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
6955    DEE3  A6 B7        	LDX	FAC2_s		; get FAC2 sign (b7)
6956    DEE5  20 FD D9     	JSR	LAB_26C2		; divide by (AY) (X=sign)
6957    DEE8  20 CE DA     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
6958    DEEB  20 85 DB     	JSR	LAB_INT		; perform INT
6959    DEEE  A9 00        	LDA	#$00			; clear byte
6960    DEF0  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
6961    DEF2  20 AA D7     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
6962    DEF5  A9 F9        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
6963    DEF7  A0 E3        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
6964    DEF9  20 A7 D7     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
6965    DEFC  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
6966    DEFE  48           	PHA				; save FAC1 sign
6967    DEFF  10 0D        	BPL	LAB_2C35		; branch if +ve
6968    
6969    					; FAC1 sign was -ve
6970    DF01  20 BE D7     	JSR	LAB_244E		; add 0.5 to FAC1
6971    DF04  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
6972    DF06  30 09        	BMI	LAB_2C38		; branch if -ve
6973    
6974    DF08  A5 63        	LDA	Cflag			; get comparison evaluation flag
6975    DF0A  49 FF        	EOR	#$FF			; toggle flag
6976    DF0C  85 63        	STA	Cflag			; save comparison evaluation flag
6977    LAB_2C35
6978    DF0E  20 F8 DD     	JSR	LAB_GTHAN		; do - FAC1
6979    LAB_2C38
6980    DF11  A9 F9        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
6981    DF13  A0 E3        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
6982    DF15  20 C2 D7     	JSR	LAB_246C		; add (AY) to FAC1
6983    DF18  68           	PLA				; restore FAC1 sign
6984    DF19  10 03        	BPL	LAB_2C45		; branch if was +ve
6985    
6986    					; else correct FAC1
6987    DF1B  20 F8 DD     	JSR	LAB_GTHAN		; do - FAC1
6988    LAB_2C45
6989    DF1E  A9 B6        	LDA	#<LAB_2C84		; set pointer low byte to counter
6990    DF20  A0 E3        	LDY	#>LAB_2C84		; set pointer high byte to counter
6991    DF22  4C 55 DE     	JMP	LAB_2B6E		; ^2 then series evaluation and return
6992    
6993    ; perform TAN()
6994    
6995    LAB_TAN
6996    DF25  20 A1 DA     	JSR	LAB_276E		; pack FAC1 into Adatal
6997    DF28  A9 00        	LDA	#$00			; clear byte
6998    DF2A  85 63        	STA	Cflag			; clear comparison evaluation flag
6999    DF2C  20 DC DE     	JSR	LAB_SIN		; go do SIN(n)
7000    DF2F  A2 9C        	LDX	#<func_l		; set sin(n) pointer low byte
7001    DF31  A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
7002    DF33  20 AB DA     	JSR	LAB_2778		; pack FAC1 into (XY)
7003    DF36  A9 A4        	LDA	#<Adatal		; set n pointer low addr
7004    DF38  A0 00        	LDY	#>Adatal		; set n pointer high addr
7005    DF3A  20 81 DA     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
7006    DF3D  A9 00        	LDA	#$00			; clear byte
7007    DF3F  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
7008    DF41  A5 63        	LDA	Cflag			; get comparison evaluation flag
7009    DF43  20 4D DF     	JSR	LAB_2C74		; save flag and go do series evaluation
7010    
7011    DF46  A9 9C        	LDA	#<func_l		; set sin(n) pointer low byte
7012    DF48  A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
7013    DF4A  4C 05 DA     	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
7014    
7015    LAB_2C74
7016    DF4D  48           	PHA				; save comparison evaluation flag
7017    DF4E  4C 0E DF     	JMP	LAB_2C35		; go do series evaluation
7018    
7019    ; perform USR()
7020    
7021    LAB_USR
7022    DF51  20 0A 00     	JSR	Usrjmp		; call user code
7023    DF54  4C F3 CD     	JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
7024    
7025    ; perform ATN()
7026    
7027    LAB_ATN
7028    DF57  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
7029    DF59  48           	PHA				; save sign
7030    DF5A  10 03        	BPL	LAB_2CA1		; branch if +ve
7031    
7032    DF5C  20 F8 DD     	JSR	LAB_GTHAN		; else do - FAC1
7033    LAB_2CA1
7034    DF5F  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
7035    DF61  48           	PHA				; push exponent
7036    DF62  C9 81        	CMP	#$81			; compare with 1
7037    DF64  90 07        	BCC	LAB_2CAF		; branch if FAC1<1
7038    
7039    DF66  A9 EC        	LDA	#<LAB_259C		; set 1 pointer low byte
7040    DF68  A0 E3        	LDY	#>LAB_259C		; set 1 pointer high byte
7041    DF6A  20 05 DA     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
7042    LAB_2CAF
7043    DF6D  A9 CB        	LDA	#<LAB_2CC9		; set pointer low byte to counter
7044    DF6F  A0 E3        	LDY	#>LAB_2CC9		; set pointer high byte to counter
7045    DF71  20 55 DE     	JSR	LAB_2B6E		; ^2 then series evaluation
7046    DF74  68           	PLA				; restore old FAC1 exponent
7047    DF75  C9 81        	CMP	#$81			; compare with 1
7048    DF77  90 07        	BCC	LAB_2CC2		; branch if FAC1<1
7049    
7050    DF79  A9 B2        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
7051    DF7B  A0 E3        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
7052    DF7D  20 A7 D7     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
7053    LAB_2CC2
7054    DF80  68           	PLA				; restore FAC1 sign
7055    DF81  10 16        	BPL	LAB_2D04		; exit if was +ve
7056    
7057    DF83  4C F8 DD     	JMP	LAB_GTHAN		; else do - FAC1 and return
7058    
7059    ; perform BITSET
7060    
7061    LAB_BITSET
7062    DF86  20 DC D6     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
7063    DF89  E0 08        	CPX	#$08			; only 0 to 7 are allowed
7064    DF8B  B0 20        	BCS	FCError		; branch if > 7
7065    
7066    DF8D  A9 00        	LDA	#$00			; clear A
7067    DF8F  38           	SEC				; set the carry
7068    S_Bits
7069    DF90  2A           	ROL				; shift bit
7070    DF91  CA           	DEX				; decrement bit number
7071    DF92  10 FC        	BPL	S_Bits		; loop if still +ve
7072    
7073    DF94  E8           	INX				; make X = $00
7074    DF95  01 11        	ORA	(Itempl,X)		; or with byte via temporary integer (addr)
7075    DF97  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
7076    LAB_2D04
7077    DF99  60           	RTS
7078    
7079    ; perform BITCLR
7080    
7081    LAB_BITCLR
7082    DF9A  20 DC D6     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
7083    DF9D  E0 08        	CPX	#$08			; only 0 to 7 are allowed
7084    DF9F  B0 0C        	BCS	FCError		; branch if > 7
7085    
7086    DFA1  A9 FF        	LDA	#$FF			; set A
7087    S_Bitc
7088    DFA3  2A           	ROL				; shift bit
7089    DFA4  CA           	DEX				; decrement bit number
7090    DFA5  10 FC        	BPL	S_Bitc		; loop if still +ve
7091    
7092    DFA7  E8           	INX				; make X = $00
7093    DFA8  21 11        	AND	(Itempl,X)		; and with byte via temporary integer (addr)
7094    DFAA  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
7095    DFAC  60           	RTS
7096    
7097    FCError
7098    DFAD  4C 2D D1     	JMP	LAB_FCER		; do function call error then warm start
7099    
7100    ; perform BITTST()
7101    
7102    LAB_BTST
7103    DFB0  20 BC 00     	JSR	LAB_IGBY		; increment BASIC pointer
7104    DFB3  20 DC D6     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
7105    DFB6  E0 08        	CPX	#$08			; only 0 to 7 are allowed
7106    DFB8  B0 F3        	BCS	FCError		; branch if > 7
7107    
7108    DFBA  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
7109    DFBD  C9 29        	CMP	#')'			; is next character ")"
7110    DFBF  F0 03        	BEQ	TST_OK		; if ")" go do rest of function
7111    
7112    DFC1  4C 06 CE     	JMP	LAB_SNER		; do syntax error then warm start
7113    
7114    TST_OK
7115    DFC4  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
7116    DFC7  A9 00        	LDA	#$00			; clear A
7117    DFC9  38           	SEC				; set the carry
7118    T_Bits
7119    DFCA  2A           	ROL				; shift bit
7120    DFCB  CA           	DEX				; decrement bit number
7121    DFCC  10 FC        	BPL	T_Bits		; loop if still +ve
7122    
7123    DFCE  E8           	INX				; make X = $00
7124    DFCF  21 11        	AND	(Itempl,X)		; AND with byte via temporary integer (addr)
7125    DFD1  F0 02        	BEQ	LAB_NOTT		; branch if zero (already correct)
7126    
7127    DFD3  A9 FF        	LDA	#$FF			; set for -1 result
7128    LAB_NOTT
7129    DFD5  4C FE DA     	JMP	LAB_27DB		; go do SGN tail
7130    
7131    ; perform BIN$()
7132    
7133    LAB_BINS
7134    DFD8  E0 19        	CPX	#$19			; max + 1
7135    DFDA  B0 48        	BCS	BinFErr		; exit if too big ( > or = )
7136    
7137    DFDC  86 78        	STX	TempB			; save # of characters ($00 = leading zero remove)
7138    DFDE  A9 18        	LDA	#$18			; need A byte long space
7139    DFE0  20 3E D3     	JSR	LAB_MSSP		; make string space A bytes long
7140    DFE3  A0 17        	LDY	#$17			; set index
7141    DFE5  A2 18        	LDX	#$18			; character count
7142    NextB1
7143    DFE7  46 11        	LSR	nums_1		; shift highest byte
7144    DFE9  66 12        	ROR	nums_2		; shift middle byte
7145    DFEB  66 13        	ROR	nums_3		; shift lowest byte bit 0 to carry
7146    DFED  8A           	TXA				; load with "0"/2
7147    DFEE  2A           	ROL				; shift in carry
7148    DFEF  91 AD        	STA	(str_pl),Y		; save to temp string + index
7149    DFF1  88           	DEY				; decrement index
7150    DFF2  10 F3        	BPL	NextB1		; loop if not done
7151    
7152    DFF4  A5 78        	LDA	TempB			; get # of characters
7153    DFF6  F0 0A        	BEQ	EndBHS		; branch if truncate
7154    
7155    DFF8  AA           	TAX				; copy length to X
7156    DFF9  38           	SEC				; set carry for add !
7157    DFFA  49 FF        	EOR	#$FF			; 1's complement
7158    DFFC  69 18        	ADC	#$18			; add 24d
7159    DFFE  F0 1C        	BEQ	GoPr2			; if zero print whole string
7160    
7161    E000  D0 0F        	BNE	GoPr1			; else go make output string
7162    	
7163    ; this is the exit code and is also used by HEX$()
7164    ; truncate string to remove leading "0"s
7165    
7166    EndBHS
7167    E002  A8           	TAY				; clear index (A=0, X=length here)
7168    NextB2
7169    E003  B1 AD        	LDA	(str_pl),Y		; get character from string
7170    E005  C9 30        	CMP	#'0'			; compare with "0"
7171    E007  D0 07        	BNE	GoPr			; if not "0" then go print string from here
7172    
7173    E009  CA           	DEX				; decrement character count
7174    E00A  F0 03        	BEQ	GoPr3			; if zero then end of string so go print it
7175    
7176    E00C  C8           	INY				; else increment index
7177    E00D  10 F4        	BPL	NextB2		; loop always
7178    
7179    ; make fixed length output string - ignore overflows!
7180    
7181    GoPr3
7182    E00F  E8           	INX				; need at least 1 character
7183    GoPr
7184    E010  98           	TYA				; copy result
7185    GoPr1
7186    E011  18           	CLC				; clear carry for add
7187    E012  65 AD        	ADC	str_pl		; add low address
7188    E014  85 AD        	STA	str_pl		; save low address
7189    E016  A9 00        	LDA	#$00			; do high byte
7190    E018  65 AE        	ADC	str_ph		; add high address
7191    E01A  85 AE        	STA	str_ph		; save high address
7192    GoPr2
7193    E01C  86 AC        	STX	str_ln		; X holds string length
7194    E01E  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
7195    E021  4C 89 D3     	JMP	LAB_RTST		; check for space on descriptor stack then put address
7196    					; and length on descriptor stack and update stack pointers
7197    
7198    BinFErr
7199    E024  4C 2D D1     	JMP	LAB_FCER		; do function call error then warm start
7200    
7201    ; perform HEX$()
7202    
7203    LAB_HEXS
7204    E027  E0 07        	CPX	#$07			; max + 1
7205    E029  B0 F9        	BCS	BinFErr		; exit if too big ( > or = )
7206    
7207    E02B  86 78        	STX	TempB			; save # of characters
7208    
7209    E02D  A9 06        	LDA	#$06			; need 6 bytes for string
7210    E02F  20 3E D3     	JSR	LAB_MSSP		; make string space A bytes long
7211    E032  A0 05        	LDY	#$05			; set string index
7212    
7213    E034  F8           	SED				; need decimal mode for nibble convert
7214    E035  A5 13        	LDA	nums_3		; get lowest byte
7215    E037  20 55 E0     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
7216    E03A  A5 12        	LDA	nums_2		; get middle byte
7217    E03C  20 55 E0     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
7218    E03F  A5 11        	LDA	nums_1		; get highest byte
7219    E041  20 55 E0     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
7220    E044  D8           	CLD				; back to binary
7221    
7222    E045  A2 06        	LDX	#$06			; character count
7223    E047  A5 78        	LDA	TempB			; get # of characters
7224    E049  F0 B7        	BEQ	EndBHS		; branch if truncate
7225    
7226    E04B  AA           	TAX				; copy length to X
7227    E04C  38           	SEC				; set carry for add !
7228    E04D  49 FF        	EOR	#$FF			; 1's complement
7229    E04F  69 06        	ADC	#$06			; add 6d
7230    E051  F0 C9        	BEQ	GoPr2			; if zero print whole string
7231    
7232    E053  D0 BC        	BNE	GoPr1			; else go make output string (branch always)
7233    
7234    ; convert A to ASCII hex byte and output .. note set decimal mode before calling
7235    
7236    LAB_A2HX
7237    E055  AA           	TAX				; save byte
7238    E056  29 0F        	AND	#$0F			; mask off top bits
7239    E058  20 60 E0     	JSR	LAB_AL2X		; convert low nibble to ASCII and output
7240    E05B  8A           	TXA				; get byte back
7241    E05C  4A           	LSR				; /2	shift high nibble to low nibble
7242    E05D  4A           	LSR				; /4
7243    E05E  4A           	LSR				; /8
7244    E05F  4A           	LSR				; /16
7245    LAB_AL2X
7246    E060  C9 0A        	CMP	#$0A			; set carry for +1 if >9
7247    E062  69 30        	ADC	#'0'			; add ASCII "0"
7248    E064  91 AD        	STA	(str_pl),Y		; save to temp string
7249    E066  88           	DEY				; decrement counter
7250    E067  60           	RTS
7251    
7252    LAB_NLTO
7253    E068  85 AC        	STA	FAC1_e		; save FAC1 exponent
7254    E06A  A9 00        	LDA	#$00			; clear sign compare
7255    LAB_MLTE
7256    E06C  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
7257    E06E  8A           	TXA				; restore character
7258    E06F  20 49 DC     	JSR	LAB_2912		; evaluate new ASCII digit
7259    
7260    ; gets here if the first character was "$" for hex
7261    ; get hex number
7262    
7263    LAB_CHEX
7264    E072  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
7265    E075  90 0A        	BCC	LAB_ISHN		; branch if numeric character
7266    
7267    E077  09 20        	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
7268    E079  E9 61        	SBC	#'a'			; subtract "a" (carry set here)
7269    E07B  C9 06        	CMP	#$06			; compare normalised with $06 (max+1)
7270    E07D  B0 2A        	BCS	LAB_EXCH		; exit if >"f" or <"0"
7271    
7272    E07F  69 0A        	ADC	#$0A			; convert to nibble
7273    LAB_ISHN
7274    E081  29 0F        	AND	#$0F			; convert to binary
7275    E083  AA           	TAX				; save nibble
7276    E084  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
7277    E086  F0 E4        	BEQ	LAB_MLTE		; skip multiply if zero
7278    
7279    E088  69 04        	ADC	#$04			; add four to exponent (*16 - carry clear here)
7280    E08A  90 DC        	BCC	LAB_NLTO		; if no overflow do evaluate digit
7281    
7282    LAB_MLTO
7283    E08C  4C C7 D8     	JMP	LAB_2564		; do overflow error and warm start
7284    
7285    LAB_NXCH
7286    E08F  AA           	TAX				; save bit
7287    E090  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
7288    E092  F0 06        	BEQ	LAB_MLBT		; skip multiply if zero
7289    
7290    E094  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*2)
7291    E096  F0 F4        	BEQ	LAB_MLTO		; do overflow error if = $00
7292    
7293    E098  A9 00        	LDA	#$00			; clear sign compare
7294    LAB_MLBT
7295    E09A  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
7296    E09C  8A           	TXA				; restore bit
7297    E09D  20 49 DC     	JSR	LAB_2912		; evaluate new ASCII digit
7298    
7299    ; gets here if the first character was  "%" for binary
7300    ; get binary number
7301    
7302    LAB_CBIN
7303    E0A0  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
7304    E0A3  49 30        	EOR	#'0'			; convert "0" to 0 etc.
7305    E0A5  C9 02        	CMP	#$02			; compare with max+1
7306    E0A7  90 E6        	BCC	LAB_NXCH		; branch exit if < 2
7307    
7308    LAB_EXCH
7309    E0A9  4C 2E DC     	JMP	LAB_28F6		; evaluate -ve flag and return
7310    
7311    ; ctrl-c check routine. includes limited "life" byte save for INGET routine
7312    ; now also the code that checks to see if an interrupt has occurred
7313    
7314    CTRLC
7315    E0AC  AD 90 03     	LDA	ccflag		; get [CTRL-C] check flag
7316    E0AF  D0 18        	BNE	LAB_FBA2		; exit if inhibited
7317    
7318    E0B1  20 EE E2     	JSR	V_INPT		; scan input device
7319    E0B4  90 0B        	BCC	LAB_FBA0		; exit if buffer empty
7320    
7321    E0B6  8D 91 03     	STA	ccbyte		; save received byte
7322    E0B9  A2 20        	LDX	#$20			; "life" timer for bytes
7323    E0BB  8E 92 03     	STX	ccnull		; set countdown
7324    E0BE  4C 1B C7     	JMP	LAB_1636		; return to BASIC
7325    
7326    LAB_FBA0
7327    E0C1  AE 92 03     	LDX	ccnull		; get countdown byte
7328    E0C4  F0 03        	BEQ	LAB_FBA2		; exit if finished
7329    
7330    E0C6  CE 92 03     	DEC	ccnull		; else decrement countdown
7331    LAB_FBA2
7332    E0C9  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
7333    E0CB  20 D4 E0     	JSR	LAB_CKIN		; go check interrupt
7334    E0CE  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
7335    E0D0  20 D4 E0     	JSR	LAB_CKIN		; go check interrupt
7336    LAB_CRTS
7337    E0D3  60           	RTS
7338    
7339    ; check whichever interrupt is indexed by X
7340    
7341    LAB_CKIN
7342    E0D4  B5 00        	LDA	PLUS_0,X		; get interrupt flag byte
7343    E0D6  10 FB        	BPL	LAB_CRTS		; branch if interrupt not enabled
7344    
7345    ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
7346    ; automatically enable the interrupt when we exit
7347    
7348    E0D8  0A           	ASL				; move happened bit to setup bit
7349    E0D9  29 40        	AND	#$40			; mask happened bits
7350    E0DB  F0 F6        	BEQ	LAB_CRTS		; if no interrupt then exit
7351    
7352    E0DD  95 00        	STA	PLUS_0,X		; save interrupt flag byte
7353    
7354    E0DF  8A           	TXA				; copy index ..
7355    E0E0  A8           	TAY				; .. to Y
7356    
7357    E0E1  68           	PLA				; dump return address low byte, call from CTRL-C
7358    E0E2  68           	PLA				; dump return address high byte
7359    
7360    E0E3  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
7361    E0E5  20 07 C3     	JSR	LAB_1212		; check room on stack for A bytes
7362    E0E8  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
7363    E0EA  48           	PHA				; push on stack
7364    E0EB  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
7365    E0ED  48           	PHA				; push on stack
7366    E0EE  A5 88        	LDA	Clineh		; get current line high byte
7367    E0F0  48           	PHA				; push on stack
7368    E0F1  A5 87        	LDA	Clinel		; get current line low byte
7369    E0F3  48           	PHA				; push on stack
7370    E0F4  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
7371    E0F6  48           	PHA				; push on stack
7372    
7373    E0F7  B9 01 00     	LDA	PLUS_1,Y		; get interrupt code pointer low byte
7374    E0FA  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
7375    E0FC  B9 02 00     	LDA	PLUS_2,Y		; get interrupt code pointer high byte
7376    E0FF  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
7377    
7378    E101  4C C0 C6     	JMP	LAB_15C2		; go do interpreter inner loop
7379    					; can't RTS, we used the stack! the RTS from the ctrl-c
7380    					; check will be taken when the RETIRQ/RETNMI/RETURN is
7381    					; executed at the end of the subroutine
7382    
7383    ; get byte from input device, no waiting
7384    ; returns with carry set if byte in A
7385    
7386    INGET
7387    E104  20 EE E2     	JSR	V_INPT		; call scan input device
7388    E107  B0 09        	BCS	LAB_FB95		; if byte go reset timer
7389    
7390    E109  AD 92 03     	LDA	ccnull		; get countdown
7391    E10C  F0 09        	BEQ	LAB_FB96		; exit if empty
7392    
7393    E10E  AD 91 03     	LDA	ccbyte		; get last received byte
7394    E111  38           	SEC				; flag we got a byte
7395    LAB_FB95
7396    E112  A2 00        	LDX	#$00			; clear X
7397    E114  8E 92 03     	STX	ccnull		; clear timer because we got a byte
7398    LAB_FB96
7399    E117  60           	RTS
7400    
7401    ; these routines only enable the interrupts if the set-up flag is set
7402    ; if not they have no effect
7403    
7404    ; perform IRQ {ON|OFF|CLEAR}
7405    
7406    LAB_IRQ
7407    E118  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
7408    	.byte	$2C			; make next line BIT abs.
7409    
7410    ; perform NMI {ON|OFF|CLEAR}
7411    
7412    LAB_NMI
7413    E11B  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
7414    E11D  C9 93        	CMP	#TK_ON		; compare with token for ON
7415    E11F  F0 11        	BEQ	LAB_INON		; go turn on interrupt
7416    
7417    E121  C9 B6        	CMP	#TK_OFF		; compare with token for OFF
7418    E123  F0 07        	BEQ	LAB_IOFF		; go turn off interrupt
7419    
7420    E125  49 A2        	EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
7421    E127  F0 0E        	BEQ	LAB_INEX		; go clear interrupt flags and return
7422    
7423    E129  4C 06 CE     	JMP	LAB_SNER		; do syntax error then warm start
7424    
7425    LAB_IOFF
7426    E12C  A9 7F        	LDA	#$7F			; clear A
7427    E12E  35 00        	AND	PLUS_0,X		; AND with interrupt setup flag
7428    E130  10 05        	BPL	LAB_INEX		; go clear interrupt enabled flag and return
7429    
7430    LAB_INON
7431    E132  B5 00        	LDA	PLUS_0,X		; get interrupt setup flag
7432    E134  0A           	ASL				; Shift bit to enabled flag
7433    E135  15 00        	ORA	PLUS_0,X		; OR with flag byte
7434    LAB_INEX
7435    E137  95 00        	STA	PLUS_0,X		; save interrupt flag byte
7436    E139  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer and return
7437    
7438    ; these routines set up the pointers and flags for the interrupt routines
7439    ; note that the interrupts are also enabled by these commands
7440    
7441    ; perform ON IRQ
7442    
7443    LAB_SIRQ
7444    E13C  58           	CLI				; enable interrupts
7445    E13D  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
7446    	.byte	$2C			; make next line BIT abs.
7447    
7448    ; perform ON NMI
7449    
7450    LAB_SNMI
7451    E140  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
7452    
7453    E142  86 78        	STX	TempB			; save interrupt pointer
7454    E144  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (past token)
7455    E147  20 59 C9     	JSR	LAB_GFPN		; get fixed-point number into temp integer
7456    E14A  A5 79        	LDA	Smeml			; get start of mem low byte
7457    E14C  A6 7A        	LDX	Smemh			; get start of mem high byte
7458    E14E  20 2C C5     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
7459    E151  B0 03        	BCS	LAB_LFND		; if carry set go set-up interrupt
7460    
7461    E153  4C 76 C8     	JMP	LAB_16F7		; else go do "Undefined statement" error and warm start
7462    
7463    LAB_LFND
7464    E156  A6 78        	LDX	TempB			; get interrupt pointer
7465    E158  A5 AA        	LDA	Baslnl		; get pointer low byte
7466    E15A  E9 01        	SBC	#$01			; -1 (carry already set for subtract)
7467    E15C  95 01        	STA	PLUS_1,X		; save as interrupt pointer low byte
7468    E15E  A5 AB        	LDA	Baslnh		; get pointer high byte
7469    E160  E9 00        	SBC	#$00			; subtract carry
7470    E162  95 02        	STA	PLUS_2,X		; save as interrupt pointer high byte
7471    
7472    E164  A9 C0        	LDA	#$C0			; set interrupt enabled/setup bits
7473    E166  95 00        	STA	PLUS_0,X		; set interrupt flags
7474    LAB_IRTS
7475    E168  60           	RTS
7476    
7477    ; return from IRQ service, restores the enabled flag.
7478    
7479    ; perform RETIRQ
7480    
7481    LAB_RETIRQ
7482    E169  D0 FD        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
7483    
7484    E16B  A5 DF        	LDA	IrqBase		; get interrupt flags
7485    E16D  0A           	ASL				; copy setup to enabled (b7)
7486    E16E  05 DF        	ORA	IrqBase		; OR in setup flag
7487    E170  85 DF        	STA	IrqBase		; save enabled flag
7488    E172  4C 7D C8     	JMP	LAB_16E8		; go do rest of RETURN
7489    
7490    ; return from NMI service, restores the enabled flag.
7491    
7492    ; perform RETNMI
7493    
7494    LAB_RETNMI
7495    E175  D0 F1        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
7496    
7497    E177  A5 DC        	LDA	NmiBase		; get set-up flag
7498    E179  0A           	ASL				; copy setup to enabled (b7)
7499    E17A  05 DC        	ORA	NmiBase		; OR in setup flag
7500    E17C  85 DC        	STA	NmiBase		; save enabled flag
7501    E17E  4C 7D C8     	JMP	LAB_16E8		; go do rest of RETURN
7502    
7503    ; MAX() MIN() pre process
7504    
7505    LAB_MMPP
7506    E181  20 ED CC     	JSR	LAB_EVEZ		; process expression
7507    E184  4C D4 CC     	JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
7508    
7509    ; perform MAX()
7510    
7511    LAB_MAX
7512    E187  20 B5 E1     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
7513    					; pull FAC2 and compare with FAC1
7514    E18A  10 FB        	BPL	LAB_MAX		; branch if no swap to do
7515    
7516    E18C  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
7517    E18E  09 80        	ORA	#$80			; set top bit (clear sign from compare)
7518    E190  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
7519    E192  20 C7 D7     	JSR	LAB_279B		; copy FAC2 to FAC1
7520    E195  F0 F0        	BEQ	LAB_MAX		; go do next (branch always)
7521    
7522    ; perform MIN()
7523    
7524    LAB_MIN
7525    E197  20 B5 E1     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
7526    					; pull FAC2 and compare with FAC1
7527    E19A  30 FB        	BMI	LAB_MIN		; branch if no swap to do
7528    
7529    E19C  F0 F9        	BEQ	LAB_MIN		; branch if no swap to do
7530    
7531    E19E  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
7532    E1A0  09 80        	ORA	#$80			; set top bit (clear sign from compare)
7533    E1A2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
7534    E1A4  20 C7 D7     	JSR	LAB_279B		; copy FAC2 to FAC1
7535    E1A7  F0 EE        	BEQ	LAB_MIN		; go do next (branch always)
7536    
7537    ; exit routine. don't bother returning to the loop code
7538    ; check for correct exit, else so syntax error
7539    
7540    LAB_MMEC
7541    E1A9  C9 29        	CMP	#')'			; is it end of function?
7542    E1AB  D0 05        	BNE	LAB_MMSE		; if not do MAX MIN syntax error
7543    
7544    E1AD  68           	PLA				; dump return address low byte
7545    E1AE  68           	PLA				; dump return address high byte
7546    E1AF  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
7547    
7548    LAB_MMSE
7549    E1B2  4C 06 CE     	JMP	LAB_SNER		; do syntax error then warm start
7550    
7551    ; check for next, evaluate and return or exit
7552    ; this is the routine that does most of the work
7553    
7554    LAB_PHFA
7555    E1B5  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
7556    E1B8  C9 2C        	CMP	#','			; is there more ?
7557    E1BA  D0 ED        	BNE	LAB_MMEC		; if not go do end check
7558    
7559    					; push FAC1
7560    E1BC  20 DD DA     	JSR	LAB_27BA		; round FAC1
7561    E1BF  A5 B0        	LDA	FAC1_s		; get FAC1 sign
7562    E1C1  09 7F        	ORA	#$7F			; set all non sign bits
7563    E1C3  25 AD        	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
7564    E1C5  48           	PHA				; push on stack
7565    E1C6  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
7566    E1C8  48           	PHA				; push on stack
7567    E1C9  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
7568    E1CB  48           	PHA				; push on stack
7569    E1CC  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
7570    E1CE  48           	PHA				; push on stack
7571    
7572    E1CF  20 BC 00     	JSR	LAB_IGBY		; scan and get next BASIC byte (after ",")
7573    E1D2  20 D1 CC     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
7574    					; else do type mismatch
7575    
7576    					; pop FAC2 (MAX/MIN expression so far)
7577    E1D5  68           	PLA				; pop exponent
7578    E1D6  85 B3        	STA	FAC2_e		; save FAC2 exponent
7579    E1D8  68           	PLA				; pop mantissa3
7580    E1D9  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
7581    E1DB  68           	PLA				; pop mantissa1
7582    E1DC  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
7583    E1DE  68           	PLA				; pop sign/mantissa1
7584    E1DF  85 B4        	STA	FAC2_1		; save FAC2 sign/mantissa1
7585    E1E1  85 B7        	STA	FAC2_s		; save FAC2 sign
7586    
7587    					; compare FAC1 with (packed) FAC2
7588    E1E3  A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
7589    E1E5  A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
7590    E1E7  4C 1B DB     	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
7591    					; returns A=$00 if FAC1 = (AY)
7592    					; returns A=$01 if FAC1 > (AY)
7593    					; returns A=$FF if FAC1 < (AY)
7594    
7595    ; perform WIDTH
7596    
7597    LAB_WDTH
7598    E1EA  C9 2C        	CMP	#','			; is next byte ","
7599    E1EC  F0 1B        	BEQ	LAB_TBSZ		; if so do tab size
7600    
7601    E1EE  20 90 D6     	JSR	LAB_GTBY		; get byte parameter
7602    E1F1  8A           	TXA				; copy width to A
7603    E1F2  F0 0A        	BEQ	LAB_NSTT		; branch if set for infinite line
7604    
7605    E1F4  E0 10        	CPX	#$10			; else make min width = 16d
7606    E1F6  90 45        	BCC	TabErr		; if less do function call error and exit
7607    
7608    ; this next compare ensures that we can't exit WIDTH via an error leaving the
7609    ; tab size greater than the line length.
7610    
7611    E1F8  E4 64        	CPX	TabSiz		; compare with tab size
7612    E1FA  B0 02        	BCS	LAB_NSTT		; branch if >= tab size
7613    
7614    E1FC  86 64        	STX	TabSiz		; else make tab size = terminal width
7615    LAB_NSTT
7616    E1FE  86 0F        	STX	TWidth		; set the terminal width
7617    E200  20 C2 00     	JSR	LAB_GBYT		; get BASIC byte back
7618    E203  F0 1A        	BEQ	WExit			; exit if no following
7619    
7620    E205  C9 2C        	CMP	#','			; else is it ","
7621    E207  D0 A9        	BNE	LAB_MMSE		; if not do syntax error
7622    
7623    LAB_TBSZ
7624    E209  20 8D D6     	JSR	LAB_SGBY		; scan and get byte parameter
7625    E20C  8A           	TXA				; copy TAB size
7626    E20D  30 2E        	BMI	TabErr		; if >127 do function call error and exit
7627    
7628    E20F  E0 01        	CPX	#$01			; compare with min-1
7629    E211  90 2A        	BCC	TabErr		; if <=1 do function call error and exit
7630    
7631    E213  A5 0F        	LDA	TWidth		; set flags for width
7632    E215  F0 06        	BEQ	LAB_SVTB		; skip check if infinite line
7633    
7634    E217  E4 0F        	CPX	TWidth		; compare TAB with width
7635    E219  F0 02        	BEQ	LAB_SVTB		; ok if =
7636    
7637    E21B  B0 20        	BCS	TabErr		; branch if too big
7638    
7639    LAB_SVTB
7640    E21D  86 64        	STX	TabSiz		; save TAB size
7641    
7642    ; calculate tab column limit from TAB size. The Iclim is set to the last tab
7643    ; position on a line that still has at least one whole tab width between it
7644    ; and the end of the line.
7645    
7646    WExit
7647    E21F  A5 0F        	LDA	TWidth		; get width
7648    E221  F0 06        	BEQ	LAB_SULP		; branch if infinite line
7649    
7650    E223  C5 64        	CMP	TabSiz		; compare with tab size
7651    E225  B0 03        	BCS	LAB_WDLP		; branch if >= tab size
7652    
7653    E227  85 64        	STA	TabSiz		; else make tab size = terminal width
7654    LAB_SULP
7655    E229  38           	SEC				; set carry for subtract
7656    LAB_WDLP
7657    E22A  E5 64        	SBC	TabSiz		; subtract tab size
7658    E22C  B0 FC        	BCS	LAB_WDLP		; loop while no borrow
7659    
7660    E22E  65 64        	ADC	TabSiz		; add tab size back
7661    E230  18           	CLC				; clear carry for add
7662    E231  65 64        	ADC	TabSiz		; add tab size back again
7663    E233  85 10        	STA	Iclim			; save for now
7664    E235  A5 0F        	LDA	TWidth		; get width back
7665    E237  38           	SEC				; set carry for subtract
7666    E238  E5 10        	SBC	Iclim			; subtract remainder
7667    E23A  85 10        	STA	Iclim			; save tab column limit
7668    LAB_NOSQ
7669    E23C  60           	RTS
7670    
7671    TabErr
7672    E23D  4C 2D D1     	JMP	LAB_FCER		; do function call error then warm start
7673    
7674    ; perform SQR()
7675    
7676    LAB_SQR
7677    E240  A5 B0        	LDA	FAC1_s		; get FAC1 sign
7678    E242  30 F9        	BMI	TabErr		; if -ve do function call error
7679    
7680    E244  A5 AC        	LDA	FAC1_e		; get exponent
7681    E246  F0 F4        	BEQ	LAB_NOSQ		; if zero just return
7682    
7683    					; else do root
7684    E248  20 CE DA     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
7685    E24B  A9 00        	LDA	#$00			; clear A
7686    
7687    E24D  85 77        	STA	FACt_3		; clear remainder
7688    E24F  85 76        	STA	FACt_2		; ..
7689    E251  85 75        	STA	FACt_1		; ..
7690    E253  85 78        	STA	TempB			; ..
7691    
7692    E255  85 AF        	STA	FAC1_3		; clear root
7693    E257  85 AE        	STA	FAC1_2		; ..
7694    E259  85 AD        	STA	FAC1_1		; ..
7695    
7696    E25B  A2 18        	LDX	#$18			; 24 pairs of bits to do
7697    E25D  A5 B3        	LDA	FAC2_e		; get exponent
7698    E25F  4A           	LSR				; check odd/even
7699    E260  B0 0E        	BCS	LAB_SQE2		; if odd only 1 shift first time
7700    
7701    LAB_SQE1
7702    E262  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
7703    E264  26 B5        	ROL	FAC2_2		; ..
7704    E266  26 B4        	ROL	FAC2_1		; ..
7705    E268  26 77        	ROL	FACt_3		; .. into remainder
7706    E26A  26 76        	ROL	FACt_2		; ..
7707    E26C  26 75        	ROL	FACt_1		; ..
7708    E26E  26 78        	ROL	TempB			; .. never overflows
7709    LAB_SQE2
7710    E270  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
7711    E272  26 B5        	ROL	FAC2_2		; ..
7712    E274  26 B4        	ROL	FAC2_1		; ..
7713    E276  26 77        	ROL	FACt_3		; .. into remainder
7714    E278  26 76        	ROL	FACt_2		; ..
7715    E27A  26 75        	ROL	FACt_1		; ..
7716    E27C  26 78        	ROL	TempB			; .. never overflows
7717    
7718    E27E  06 AF        	ASL	FAC1_3		; root = root * 2
7719    E280  26 AE        	ROL	FAC1_2		; ..
7720    E282  26 AD        	ROL	FAC1_1		; .. never overflows
7721    
7722    E284  A5 AF        	LDA	FAC1_3		; get root low byte
7723    E286  2A           	ROL				; *2
7724    E287  85 5B        	STA	Temp3			; save partial low byte
7725    E289  A5 AE        	LDA	FAC1_2		; get root low mid byte
7726    E28B  2A           	ROL				; *2
7727    E28C  85 5C        	STA	Temp3+1		; save partial low mid byte
7728    E28E  A5 AD        	LDA	FAC1_1		; get root high mid byte
7729    E290  2A           	ROL				; *2
7730    E291  85 5D        	STA	Temp3+2		; save partial high mid byte
7731    E293  A9 00        	LDA	#$00			; get root high byte (always $00)
7732    E295  2A           	ROL				; *2
7733    E296  85 5E        	STA	Temp3+3		; save partial high byte
7734    
7735    					; carry clear for subtract +1
7736    E298  A5 77        	LDA	FACt_3		; get remainder low byte
7737    E29A  E5 5B        	SBC	Temp3			; subtract partial low byte
7738    E29C  85 5B        	STA	Temp3			; save partial low byte
7739    
7740    E29E  A5 76        	LDA	FACt_2		; get remainder low mid byte
7741    E2A0  E5 5C        	SBC	Temp3+1		; subtract partial low mid byte
7742    E2A2  85 5C        	STA	Temp3+1		; save partial low mid byte
7743    
7744    E2A4  A5 75        	LDA	FACt_1		; get remainder high mid byte
7745    E2A6  E5 5D        	SBC	Temp3+2		; subtract partial high mid byte
7746    E2A8  A8           	TAY				; copy partial high mid byte
7747    
7748    E2A9  A5 78        	LDA	TempB			; get remainder high byte
7749    E2AB  E5 5E        	SBC	Temp3+3		; subtract partial high byte
7750    E2AD  90 0E        	BCC	LAB_SQNS		; skip sub if remainder smaller
7751    
7752    E2AF  85 78        	STA	TempB			; save remainder high byte
7753    
7754    E2B1  84 75        	STY	FACt_1		; save remainder high mid byte
7755    
7756    E2B3  A5 5C        	LDA	Temp3+1		; get remainder low mid byte
7757    E2B5  85 76        	STA	FACt_2		; save remainder low mid byte
7758    
7759    E2B7  A5 5B        	LDA	Temp3			; get partial low byte
7760    E2B9  85 77        	STA	FACt_3		; save remainder low byte
7761    
7762    E2BB  E6 AF        	INC	FAC1_3		; increment root low byte (never any rollover)
7763    LAB_SQNS
7764    E2BD  CA           	DEX				; decrement bit pair count
7765    E2BE  D0 A2        	BNE	LAB_SQE1		; loop if not all done
7766    
7767    E2C0  38           	SEC				; set carry for subtract
7768    E2C1  A5 B3        	LDA	FAC2_e		; get exponent
7769    E2C3  E9 80        	SBC	#$80			; normalise
7770    E2C5  6A           	ROR				; /2 and re-bias to $80
7771    E2C6  69 00        	ADC	#$00			; add bit zero back in (allow for half shift)
7772    E2C8  85 AC        	STA	FAC1_e		; save it
7773    E2CA  4C 38 D8     	JMP	LAB_24D5		; normalise FAC1 and return
7774    
7775    ; perform VARPTR()
7776    
7777    LAB_VARPTR
7778    E2CD  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
7779    E2D0  20 AE CF     	JSR	LAB_GVAR		; get var address
7780    E2D3  20 F3 CD     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
7781    E2D6  A4 95        	LDY	Cvaral		; get var address low byte
7782    E2D8  A5 96        	LDA	Cvarah		; get var address high byte
7783    E2DA  4C 5D D2     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
7784    
7785    ; perform PI
7786    
7787    LAB_PI
7788    E2DD  A9 C7        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
7789    E2DF  A0 E3        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
7790    E2E1  20 81 DA     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
7791    E2E4  C6 AC        	DEC	FAC1_e		; make result = PI
7792    E2E6  60           	RTS
7793    
7794    ; perform TWOPI
7795    
7796    LAB_TWOPI
7797    E2E7  A9 C7        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
7798    E2E9  A0 E3        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
7799    E2EB  4C 81 DA     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
7800    
7801    ; system dependant i/o vectors
7802    ; these are in RAM and are set by the monitor at start-up
7803    
7804    V_INPT
7805    E2EE  6C 95 03     	JMP	(VEC_IN)		; non halting scan input device
7806    V_OUTP
7807    E2F1  6C 97 03     	JMP	(VEC_OUT)		; send byte to output device
7808    V_LOAD
7809    E2F4  6C 99 03     	JMP	(VEC_LD)		; load BASIC program
7810    V_SAVE
7811    E2F7  6C 9B 03     	JMP	(VEC_SV)		; save BASIC program
7812    
7813    ; The rest are tables messages and code for RAM
7814    
7815    ; the rest of the code is tables and BASIC start-up code
7816    
7817    PG2_TABS
7818    	.byte	$00			; ctrl-c flag		-	$00 = enabled
7819    	.byte	$00			; ctrl-c byte		-	GET needs this
7820    	.byte	$00			; ctrl-c byte timeout	-	GET needs this
7821    	.word	CTRLC			; ctrl c check vector
7822    	.word	Serial_Scan		; non halting key input	-	monitor to set this
7823    	.word	Serial_Output		; output vector		-	monitor to set this
7824    	.word	Pload			; load vector		-	monitor to set this
7825    	.word	Psave			; save vector		-	monitor to set this
7826    PG2_TABE
7827    
7828    ; character get subroutine for zero page
7829    
7830    ; For a 1.8432MHz 6502 including the JSR and RTS
7831    ; fastest (>=":")	=  29 cycles =  15.7uS
7832    ; slowest (<":")	=  40 cycles =  21.7uS
7833    ; space skip	= +21 cycles = +11.4uS
7834    ; inc across page	=  +4 cycles =  +2.2uS
7835    
7836    ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
7837    ; block is copied to it's destination, any non zero page address will do at assembly
7838    ; time, to assemble a three byte instruction.
7839    
7840    ; page 0 initialisation table from $BC
7841    ; increment and scan memory
7842    
7843    LAB_2CEE
7844    E307  E6 C3        	INC	Bpntrl		; increment BASIC execute pointer low byte
7845    E309  D0 02        	BNE	LAB_2CF4		; branch if no carry
7846    					; else
7847    E30B  E6 C4        	INC	Bpntrh		; increment BASIC execute pointer high byte
7848    
7849    ; page 0 initialisation table from $C2
7850    ; scan memory
7851    
7852    LAB_2CF4
7853    E30D  AD FF FF     	LDA	$FFFF			; get byte to scan (addr set by call routine)
7854    E310  C9 AD        	CMP	#TK_ELSE		; compare with the token for ELSE
7855    E312  F0 0E        	BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
7856    
7857    E314  C9 3A        	CMP	#':'			; compare with ":"
7858    E316  B0 0A        	BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
7859    
7860    E318  C9 20        	CMP	#' '			; compare with " "
7861    E31A  F0 EB        	BEQ	LAB_2CEE		; if " " go do next
7862    
7863    E31C  38           	SEC				; set carry for SBC
7864    E31D  E9 30        	SBC	#'0'			; subtract "0"
7865    E31F  38           	SEC				; set carry for SBC
7866    E320  E9 D0        	SBC	#$D0			; subtract -"0"
7867    					; clear carry if byte = "0"-"9"
7868    LAB_2D05
7869    E322  60           	RTS
7870    
7871    ; page zero initialisation table $00-$12 inclusive
7872    
7873    StrTab
7874    	.byte	$4C			; JMP opcode
7875    	.word LAB_COLD		; initial warm start vector (cold start)
7876    
7877    	.byte	$00			; these bytes are not used by BASIC
7878    	.word	$0000			; 
7879    	.word	$0000			; 
7880    	.word	$0000			; 
7881    
7882    	.byte	$4C			; JMP opcode
7883    	.word	LAB_FCER		; initial user function vector ("Function call" error)
7884    	.byte	$00			; default NULL count
7885    	.byte	$00			; clear terminal position
7886    	.byte	$00			; default terminal width byte
7887    	.byte	$F2			; default limit for TAB = 14
7888    	.word	Ram_base		; start of user RAM
7889    EndTab
7890    
7891    LAB_MSZM
7892    	.byte	$0D,$0A,"Memory size ",$00
7893    
7894    LAB_SMSG
7895    	.byte	" Bytes free",$0D,$0A,$0A
7896    	.byte	"Enhanced BASIC 2.22",$0A,$00
7897    
7898    ; numeric constants and series
7899    
7900    					; constants and series for LOG(n)
7901    LAB_25A0
7902    	.byte	$02			; counter
7903    	.byte	$80,$19,$56,$62	; 0.59898
7904    	.byte	$80,$76,$22,$F3	; 0.96147
7905    ;##	.byte	$80,$76,$22,$F1	; 0.96147
7906    	.byte	$82,$38,$AA,$40	; 2.88539
7907    ;##	.byte	$82,$38,$AA,$45	; 2.88539
7908    
7909    LAB_25AD
7910    	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
7911    LAB_25B1
7912    	.byte	$81,$35,$04,$F3	; 1.41421	root 2
7913    LAB_25B5
7914    	.byte	$80,$80,$00,$00	; -0.5
7915    LAB_25B9
7916    	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
7917    
7918    					; numeric PRINT constants
7919    LAB_2947
7920    	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
7921    LAB_294B
7922    	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
7923    LAB_294F
7924    	.byte	$94,$74,$24,$00	; 1000000
7925    
7926    					; EXP(n) constants and series
7927    LAB_2AFA
7928    	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
7929    LAB_2AFE
7930    	.byte	$06			; counter
7931    	.byte	$74,$63,$90,$8C	; 2.17023e-4
7932    	.byte	$77,$23,$0C,$AB	; 0.00124
7933    	.byte	$7A,$1E,$94,$00	; 0.00968
7934    	.byte	$7C,$63,$42,$80	; 0.05548
7935    	.byte	$7E,$75,$FE,$D0	; 0.24023
7936    	.byte	$80,$31,$72,$15	; 0.69315
7937    	.byte	$81,$00,$00,$00	; 1.00000
7938    
7939    ;##	.byte	$07			; counter
7940    ;##	.byte	$74,$94,$2E,$40	; -1/7! (-1/5040)
7941    ;##	.byte	$77,$2E,$4F,$70	;  1/6! ( 1/720)
7942    ;##	.byte	$7A,$88,$02,$6E	; -1/5! (-1/120)
7943    ;##	.byte	$7C,$2A,$A0,$E6	;  1/4! ( 1/24)
7944    ;##	.byte	$7E,$AA,$AA,$50	; -1/3! (-1/6)
7945    ;##	.byte	$7F,$7F,$FF,$FF	;  1/2! ( 1/2)
7946    ;##	.byte	$81,$80,$00,$00	; -1/1! (-1/1)
7947    ;##	.byte	$81,$00,$00,$00	;  1/0! ( 1/1)
7948    
7949    					; trigonometric constants and series
7950    LAB_2C78
7951    	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
7952    LAB_2C84
7953    	.byte	$04			; counter
7954    	.byte	$86,$1E,$D7,$FB	; 39.7109
7955    ;##	.byte	$86,$1E,$D7,$BA	; 39.7109
7956    	.byte	$87,$99,$26,$65	;-76.575
7957    ;##	.byte	$87,$99,$26,$64	;-76.575
7958    	.byte	$87,$23,$34,$58	; 81.6022
7959    	.byte	$86,$A5,$5D,$E1	;-41.3417
7960    ;##	.byte	$86,$A5,$5D,$E0	;-41.3417
7961    LAB_2C7C
7962    	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
7963    ;##	.byte	$83,$49,$0F,$DA	; 6.28319 (2*pi) as floating #
7964    
7965    LAB_2CC9
7966    	.byte	$08			; counter
7967    	.byte	$78,$3A,$C5,$37	; 0.00285
7968    	.byte	$7B,$83,$A2,$5C	;-0.0160686
7969    	.byte	$7C,$2E,$DD,$4D	; 0.0426915
7970    	.byte	$7D,$99,$B0,$1E	;-0.0750429
7971    	.byte	$7D,$59,$ED,$24	; 0.106409
7972    	.byte	$7E,$91,$72,$00	;-0.142036
7973    	.byte	$7E,$4C,$B9,$73	; 0.199926
7974    	.byte	$7F,$AA,$AA,$53	;-0.333331
7975    
7976    ;##	.byte	$08			; counter
7977    ;##	.byte	$78,$3B,$D7,$4A	; 1/17
7978    ;##	.byte	$7B,$84,$6E,$02	;-1/15
7979    ;##	.byte	$7C,$2F,$C1,$FE	; 1/13
7980    ;##	.byte	$7D,$9A,$31,$74	;-1/11
7981    ;##	.byte	$7D,$5A,$3D,$84	; 1/9
7982    ;##	.byte	$7E,$91,$7F,$C8	;-1/7
7983    ;##	.byte	$7E,$4C,$BB,$E4	; 1/5
7984    ;##	.byte	$7F,$AA,$AA,$6C	;-1/3
7985    
7986      E3ED             LAB_1D96	= *+1			; $00,$00 used for undefined variables
7987    LAB_259C
7988    	.byte	$81,$00,$00,$00	; 1.000000, used for INC
7989    LAB_2AFD
7990    	.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
7991    
7992    					; misc constants
7993    LAB_1DF7
7994    	.byte	$90			;-32768 (uses first three bytes from 0.5)
7995    LAB_2A96
7996    	.byte	$80,$00,$00,$00	; 0.5
7997    LAB_2C80
7998    	.byte	$7F,$00,$00,$00	; 0.25
7999    LAB_26B5
8000    	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
8001    
8002    ; This table is used in converting numbers to ASCII.
8003    
8004    LAB_2A9A
8005      E402             LAB_2A9B = LAB_2A9A+1
8006      E403             LAB_2A9C = LAB_2A9B+1
8007    	.byte	$FE,$79,$60		; -100000
8008    	.byte	$00,$27,$10		; 10000
8009    	.byte	$FF,$FC,$18		; -1000
8010    	.byte	$00,$00,$64		; 100
8011    	.byte	$FF,$FF,$F6		; -10
8012    	.byte	$00,$00,$01		; 1
8013    
8014    LAB_CTBL
8015    	.word	LAB_END-1		; END
8016    	.word	LAB_FOR-1		; FOR
8017    	.word	LAB_NEXT-1		; NEXT
8018    	.word	LAB_DATA-1		; DATA
8019    	.word	LAB_INPUT-1		; INPUT
8020    	.word	LAB_DIM-1		; DIM
8021    	.word	LAB_READ-1		; READ
8022    	.word	LAB_LET-1		; LET
8023    	.word	LAB_DEC-1		; DEC			new command
8024    	.word	LAB_GOTO-1		; GOTO
8025    	.word	LAB_RUN-1		; RUN
8026    	.word	LAB_IF-1		; IF
8027    	.word	LAB_RESTORE-1	; RESTORE		modified command
8028    	.word	LAB_GOSUB-1		; GOSUB
8029    	.word	LAB_RETIRQ-1	; RETIRQ		new command
8030    	.word	LAB_RETNMI-1	; RETNMI		new command
8031    	.word	LAB_RETURN-1	; RETURN
8032    	.word	LAB_REM-1		; REM
8033    	.word	LAB_STOP-1		; STOP
8034    	.word	LAB_ON-1		; ON			modified command
8035    	.word	LAB_NULL-1		; NULL		modified command
8036    	.word	LAB_INC-1		; INC			new command
8037    	.word	LAB_WAIT-1		; WAIT
8038    	.word	V_LOAD-1		; LOAD
8039    	.word	V_SAVE-1		; SAVE
8040    	.word	LAB_DEF-1		; DEF
8041    	.word	LAB_POKE-1		; POKE
8042    	.word	LAB_DOKE-1		; DOKE		new command
8043    	.word	LAB_CALL-1		; CALL		new command
8044    	.word	LAB_DO-1		; DO			new command
8045    	.word	LAB_LOOP-1		; LOOP		new command
8046    	.word	LAB_PRINT-1		; PRINT
8047    	.word	LAB_CONT-1		; CONT
8048    	.word	LAB_LIST-1		; LIST
8049    	.word	LAB_CLEAR-1		; CLEAR
8050    	.word	LAB_NEW-1		; NEW
8051    	.word	LAB_WDTH-1		; WIDTH		new command
8052    	.word	LAB_GET-1		; GET			new command
8053    	.word	LAB_SWAP-1		; SWAP		new command
8054    	.word	LAB_BITSET-1	; BITSET		new command
8055    	.word	LAB_BITCLR-1	; BITCLR		new command
8056    	.word	LAB_IRQ-1		; IRQ			new command
8057    	.word	LAB_NMI-1		; NMI			new command
8058    	.word   SYSjmp-1                ; SYS         *** added for SBC-2
8059    
8060    ; function pre process routine table
8061    
8062    LAB_FTPL
8063      E46C             LAB_FTPM	= LAB_FTPL+$01
8064    	.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
8065    	.word	LAB_PPFN-1		; INT(n)		"
8066    	.word	LAB_PPFN-1		; ABS(n)		"
8067    	.word	LAB_EVEZ-1		; USR(x)	process any expression
8068    	.word	LAB_1BF7-1		; FRE(x)		"
8069    	.word	LAB_1BF7-1		; POS(x)		"
8070    	.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
8071    	.word	LAB_PPFN-1		; RND(n)		"
8072    	.word	LAB_PPFN-1		; LOG(n)		"
8073    	.word	LAB_PPFN-1		; EXP(n)		"
8074    	.word	LAB_PPFN-1		; COS(n)		"
8075    	.word	LAB_PPFN-1		; SIN(n)		"
8076    	.word	LAB_PPFN-1		; TAN(n)		"
8077    	.word	LAB_PPFN-1		; ATN(n)		"
8078    	.word	LAB_PPFN-1		; PEEK(n)		"
8079    	.word	LAB_PPFN-1		; DEEK(n)		"
8080    	.word	$0000			; SADD()	none
8081    	.word	LAB_PPFS-1		; LEN($)	process string expression in ()
8082    	.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
8083    	.word	LAB_PPFS-1		; VAL($)	process string expression in ()
8084    	.word	LAB_PPFS-1		; ASC($)		"
8085    	.word	LAB_PPFS-1		; UCASE$($)		"
8086    	.word	LAB_PPFS-1		; LCASE$($)		"
8087    	.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
8088    	.word	LAB_BHSS-1		; HEX$(n)		"
8089    	.word	LAB_BHSS-1		; BIN$(n)		"
8090    	.word	$0000			; BITTST()	none
8091    	.word	LAB_MMPP-1		; MAX()	process numeric expression
8092    	.word	LAB_MMPP-1		; MIN()		"
8093    	.word	LAB_PPBI-1		; PI		advance pointer
8094    	.word	LAB_PPBI-1		; TWOPI		"
8095    	.word	$0000			; VARPTR()	none
8096    	.word	LAB_LRMS-1		; LEFT$()	process string expression
8097    	.word	LAB_LRMS-1		; RIGHT$()		"
8098    	.word	LAB_LRMS-1		; MID$()		"
8099    
8100    ; action addresses for functions
8101    
8102    LAB_FTBL
8103      E4B2             LAB_FTBM	= LAB_FTBL+$01
8104    	.word	LAB_SGN-1		; SGN()
8105    	.word	LAB_INT-1		; INT()
8106    	.word	LAB_ABS-1		; ABS()
8107    	.word	LAB_USR-1		; USR()
8108    	.word	LAB_FRE-1		; FRE()
8109    	.word	LAB_POS-1		; POS()
8110    	.word	LAB_SQR-1		; SQR()
8111    	.word	LAB_RND-1		; RND()		modified function
8112    	.word	LAB_LOG-1		; LOG()
8113    	.word	LAB_EXP-1		; EXP()
8114    	.word	LAB_COS-1		; COS()
8115    	.word	LAB_SIN-1		; SIN()
8116    	.word	LAB_TAN-1		; TAN()
8117    	.word	LAB_ATN-1		; ATN()
8118    	.word	LAB_PEEK-1		; PEEK()
8119    	.word	LAB_DEEK-1		; DEEK()		new function
8120    	.word	LAB_SADD-1		; SADD()		new function
8121    	.word	LAB_LENS-1		; LEN()
8122    	.word	LAB_STRS-1		; STR$()
8123    	.word	LAB_VAL-1		; VAL()
8124    	.word	LAB_ASC-1		; ASC()
8125    	.word	LAB_UCASE-1		; UCASE$()		new function
8126    	.word	LAB_LCASE-1		; LCASE$()		new function
8127    	.word	LAB_CHRS-1		; CHR$()
8128    	.word	LAB_HEXS-1		; HEX$()		new function
8129    	.word	LAB_BINS-1		; BIN$()		new function
8130    	.word	LAB_BTST-1		; BITTST()		new function
8131    	.word	LAB_MAX-1		; MAX()		new function
8132    	.word	LAB_MIN-1		; MIN()		new function
8133    	.word	LAB_PI-1		; PI			new function
8134    	.word	LAB_TWOPI-1		; TWOPI		new function
8135    	.word	LAB_VARPTR-1	; VARPTR()		new function
8136    	.word	LAB_LEFT-1		; LEFT$()
8137    	.word	LAB_RIGHT-1		; RIGHT$()
8138    	.word	LAB_MIDS-1		; MID$()
8139    
8140    ; hierarchy and action addresses for operator
8141    
8142    LAB_OPPT
8143    	.byte	$79			; +
8144    	.word	LAB_ADD-1
8145    	.byte	$79			; -
8146    	.word	LAB_SUBTRACT-1
8147    	.byte	$7B			; *
8148    	.word	LAB_MULTIPLY-1
8149    	.byte	$7B			; /
8150    	.word	LAB_DIVIDE-1
8151    	.byte	$7F			; ^
8152    	.word	LAB_POWER-1
8153    	.byte	$50			; AND
8154    	.word	LAB_AND-1
8155    	.byte	$46			; EOR			new operator
8156    	.word	LAB_EOR-1
8157    	.byte	$46			; OR
8158    	.word	LAB_OR-1
8159    	.byte	$56			; >>			new operator
8160    	.word	LAB_RSHIFT-1
8161    	.byte	$56			; <<			new operator
8162    	.word	LAB_LSHIFT-1
8163    	.byte	$7D			; >
8164    	.word	LAB_GTHAN-1
8165    	.byte	$5A			; =
8166    	.word	LAB_EQUAL-1
8167    	.byte	$64			; <
8168    	.word	LAB_LTHAN-1
8169    
8170    ; keywords start with ..
8171    ; this is the first character table and must be in alphabetic order
8172    
8173    TAB_1STC
8174    	.byte	"*"
8175    	.byte	"+"
8176    	.byte	"-"
8177    	.byte	"/"
8178    	.byte	"<"
8179    	.byte	"="
8180    	.byte	">"
8181    	.byte	"?"
8182    	.byte	"A"
8183    	.byte	"B"
8184    	.byte	"C"
8185    	.byte	"D"
8186    	.byte	"E"
8187    	.byte	"F"
8188    	.byte	"G"
8189    	.byte	"H"
8190    	.byte	"I"
8191    	.byte	"L"
8192    	.byte	"M"
8193    	.byte	"N"
8194    	.byte	"O"
8195    	.byte	"P"
8196    	.byte	"R"
8197    	.byte	"S"
8198    	.byte	"T"
8199    	.byte	"U"
8200    	.byte	"V"
8201    	.byte	"W"
8202    	.byte	"^"
8203    	.byte	$00			; table terminator
8204    
8205    ; pointers to keyword tables
8206    
8207    TAB_CHRT
8208    	.word	TAB_STAR		; table for "*"
8209    	.word	TAB_PLUS		; table for "+"
8210    	.word	TAB_MNUS		; table for "-"
8211    	.word	TAB_SLAS		; table for "/"
8212    	.word	TAB_LESS		; table for "<"
8213    	.word	TAB_EQUL		; table for "="
8214    	.word	TAB_MORE		; table for ">"
8215    	.word	TAB_QEST		; table for "?"
8216    	.word	TAB_ASCA		; table for "A"
8217    	.word	TAB_ASCB		; table for "B"
8218    	.word	TAB_ASCC		; table for "C"
8219    	.word	TAB_ASCD		; table for "D"
8220    	.word	TAB_ASCE		; table for "E"
8221    	.word	TAB_ASCF		; table for "F"
8222    	.word	TAB_ASCG		; table for "G"
8223    	.word	TAB_ASCH		; table for "H"
8224    	.word	TAB_ASCI		; table for "I"
8225    	.word	TAB_ASCL		; table for "L"
8226    	.word	TAB_ASCM		; table for "M"
8227    	.word	TAB_ASCN		; table for "N"
8228    	.word	TAB_ASCO		; table for "O"
8229    	.word	TAB_ASCP		; table for "P"
8230    	.word	TAB_ASCR		; table for "R"
8231    	.word	TAB_ASCS		; table for "S"
8232    	.word	TAB_ASCT		; table for "T"
8233    	.word	TAB_ASCU		; table for "U"
8234    	.word	TAB_ASCV		; table for "V"
8235    	.word	TAB_ASCW		; table for "W"
8236    	.word	TAB_POWR		; table for "^"
8237    
8238    ; tables for each start character, note if a longer keyword with the same start
8239    ; letters as a shorter one exists then it must come first, else the list is in
8240    ; alphabetical order as follows ..
8241    
8242    ; [keyword,token
8243    ; [keyword,token]]
8244    ; end marker (#$00)
8245    
8246    TAB_STAR
8247    	.byte TK_MUL,$00		; *
8248    TAB_PLUS
8249    	.byte TK_PLUS,$00		; +
8250    TAB_MNUS
8251    	.byte TK_MINUS,$00	; -
8252    TAB_SLAS
8253    	.byte TK_DIV,$00		; /
8254    TAB_LESS
8255    LBB_LSHIFT
8256    	.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
8257    	.byte TK_LT			; <
8258    	.byte	$00
8259    TAB_EQUL
8260    	.byte TK_EQUAL,$00	; =
8261    TAB_MORE
8262    LBB_RSHIFT
8263    	.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
8264    	.byte TK_GT			; >
8265    	.byte	$00
8266    TAB_QEST
8267    	.byte TK_PRINT,$00	; ?
8268    TAB_ASCA
8269    LBB_ABS
8270    	.byte	"BS(",TK_ABS	; ABS(
8271    LBB_AND
8272    	.byte	"ND",TK_AND		; AND
8273    LBB_ASC
8274    	.byte	"SC(",TK_ASC	; ASC(
8275    LBB_ATN
8276    	.byte	"TN(",TK_ATN	; ATN(
8277    	.byte	$00
8278    TAB_ASCB
8279    LBB_BINS
8280    	.byte	"IN$(",TK_BINS	; BIN$(
8281    LBB_BITCLR
8282    	.byte	"ITCLR",TK_BITCLR	; BITCLR
8283    LBB_BITSET
8284    	.byte	"ITSET",TK_BITSET	; BITSET
8285    LBB_BITTST
8286    	.byte	"ITTST(",TK_BITTST
8287    					; BITTST(
8288    	.byte	$00
8289    TAB_ASCC
8290    LBB_CALL
8291    	.byte	"ALL",TK_CALL	; CALL
8292    LBB_CHRS
8293    	.byte	"HR$(",TK_CHRS	; CHR$(
8294    LBB_CLEAR
8295    	.byte	"LEAR",TK_CLEAR	; CLEAR
8296    LBB_CONT
8297    	.byte	"ONT",TK_CONT	; CONT
8298    LBB_COS
8299    	.byte	"OS(",TK_COS	; COS(
8300    	.byte	$00
8301    TAB_ASCD
8302    LBB_DATA
8303    	.byte	"ATA",TK_DATA	; DATA
8304    LBB_DEC
8305    	.byte	"EC",TK_DEC		; DEC
8306    LBB_DEEK
8307    	.byte	"EEK(",TK_DEEK	; DEEK(
8308    LBB_DEF
8309    	.byte	"EF",TK_DEF		; DEF
8310    LBB_DIM
8311    	.byte	"IM",TK_DIM		; DIM
8312    LBB_DOKE
8313    	.byte	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
8314    LBB_DO
8315    	.byte	"O",TK_DO		; DO
8316    	.byte	$00
8317    TAB_ASCE
8318    LBB_ELSE
8319    	.byte	"LSE",TK_ELSE	; ELSE
8320    LBB_END
8321    	.byte	"ND",TK_END		; END
8322    LBB_EOR
8323    	.byte	"OR",TK_EOR		; EOR
8324    LBB_EXP
8325    	.byte	"XP(",TK_EXP	; EXP(
8326    	.byte	$00
8327    TAB_ASCF
8328    LBB_FN
8329    	.byte	"N",TK_FN		; FN
8330    LBB_FOR
8331    	.byte	"OR",TK_FOR		; FOR
8332    LBB_FRE
8333    	.byte	"RE(",TK_FRE	; FRE(
8334    	.byte	$00
8335    TAB_ASCG
8336    LBB_GET
8337    	.byte	"ET",TK_GET		; GET
8338    LBB_GOSUB
8339    	.byte	"OSUB",TK_GOSUB	; GOSUB
8340    LBB_GOTO
8341    	.byte	"OTO",TK_GOTO	; GOTO
8342    	.byte	$00
8343    TAB_ASCH
8344    LBB_HEXS
8345    	.byte	"EX$(",TK_HEXS	; HEX$(
8346    	.byte	$00
8347    TAB_ASCI
8348    LBB_IF
8349    	.byte	"F",TK_IF		; IF
8350    LBB_INC
8351    	.byte	"NC",TK_INC		; INC
8352    LBB_INPUT
8353    	.byte	"NPUT",TK_INPUT	; INPUT
8354    LBB_INT
8355    	.byte	"NT(",TK_INT	; INT(
8356    LBB_IRQ
8357    	.byte	"RQ",TK_IRQ		; IRQ
8358    	.byte	$00
8359    TAB_ASCL
8360    LBB_LCASES
8361    	.byte	"CASE$(",TK_LCASES
8362    					; LCASE$(
8363    LBB_LEFTS
8364    	.byte	"EFT$(",TK_LEFTS	; LEFT$(
8365    LBB_LEN
8366    	.byte	"EN(",TK_LEN	; LEN(
8367    LBB_LET
8368    	.byte	"ET",TK_LET		; LET
8369    LBB_LIST
8370    	.byte	"IST",TK_LIST	; LIST
8371    LBB_LOAD
8372    	.byte	"OAD",TK_LOAD	; LOAD
8373    LBB_LOG
8374    	.byte	"OG(",TK_LOG	; LOG(
8375    LBB_LOOP
8376    	.byte	"OOP",TK_LOOP	; LOOP
8377    	.byte	$00
8378    TAB_ASCM
8379    LBB_MAX
8380    	.byte	"AX(",TK_MAX	; MAX(
8381    LBB_MIDS
8382    	.byte	"ID$(",TK_MIDS	; MID$(
8383    LBB_MIN
8384    	.byte	"IN(",TK_MIN	; MIN(
8385    	.byte	$00
8386    TAB_ASCN
8387    LBB_NEW
8388    	.byte	"EW",TK_NEW		; NEW
8389    LBB_NEXT
8390    	.byte	"EXT",TK_NEXT	; NEXT
8391    LBB_NMI
8392    	.byte	"MI",TK_NMI		; NMI
8393    LBB_NOT
8394    	.byte	"OT",TK_NOT		; NOT
8395    LBB_NULL
8396    	.byte	"ULL",TK_NULL	; NULL
8397    	.byte	$00
8398    TAB_ASCO
8399    LBB_OFF
8400    	.byte	"FF",TK_OFF		; OFF
8401    LBB_ON
8402    	.byte	"N",TK_ON		; ON
8403    LBB_OR
8404    	.byte	"R",TK_OR		; OR
8405    	.byte	$00
8406    TAB_ASCP
8407    LBB_PEEK
8408    	.byte	"EEK(",TK_PEEK	; PEEK(
8409    LBB_PI
8410    	.byte	"I",TK_PI		; PI
8411    LBB_POKE
8412    	.byte	"OKE",TK_POKE	; POKE
8413    LBB_POS
8414    	.byte	"OS(",TK_POS	; POS(
8415    LBB_PRINT
8416    	.byte	"RINT",TK_PRINT	; PRINT
8417    	.byte	$00
8418    TAB_ASCR
8419    LBB_READ
8420    	.byte	"EAD",TK_READ	; READ
8421    LBB_REM
8422    	.byte	"EM",TK_REM		; REM
8423    LBB_RESTORE
8424    	.byte	"ESTORE",TK_RESTORE
8425    					; RESTORE
8426    LBB_RETIRQ
8427    	.byte	"ETIRQ",TK_RETIRQ	; RETIRQ
8428    LBB_RETNMI
8429    	.byte	"ETNMI",TK_RETNMI	; RETNMI
8430    LBB_RETURN
8431    	.byte	"ETURN",TK_RETURN	; RETURN
8432    LBB_RIGHTS
8433    	.byte	"IGHT$(",TK_RIGHTS
8434    					; RIGHT$(
8435    LBB_RND
8436    	.byte	"ND(",TK_RND	; RND(
8437    LBB_RUN
8438    	.byte	"UN",TK_RUN		; RUN
8439    	.byte	$00
8440    TAB_ASCS
8441    LBB_SADD
8442    	.byte	"ADD(",TK_SADD	; SADD(
8443    LBB_SAVE
8444    	.byte	"AVE",TK_SAVE	; SAVE
8445    LBB_SGN
8446    	.byte	"GN(",TK_SGN	; SGN(
8447    LBB_SIN
8448    	.byte	"IN(",TK_SIN	; SIN(
8449    LBB_SPC
8450    	.byte	"PC(",TK_SPC	; SPC(
8451    LBB_SQR
8452    	.byte	"QR(",TK_SQR	; SQR(
8453    LBB_STEP
8454    	.byte	"TEP",TK_STEP	; STEP
8455    LBB_STOP
8456    	.byte	"TOP",TK_STOP	; STOP
8457    LBB_STRS
8458    	.byte	"TR$(",TK_STRS	; STR$(
8459    LBB_SWAP
8460    	.byte	"WAP",TK_SWAP	; SWAP
8461    LBB_SYS
8462    	.byte   "YS", TK_SYS    ; SYS    *** added for SBC-2
8463    	.byte	$00
8464    TAB_ASCT
8465    LBB_TAB
8466    	.byte	"AB(",TK_TAB	; TAB(
8467    LBB_TAN
8468    	.byte	"AN(",TK_TAN	; TAN(
8469    LBB_THEN
8470    	.byte	"HEN",TK_THEN	; THEN
8471    LBB_TO
8472    	.byte	"O",TK_TO		; TO
8473    LBB_TWOPI
8474    	.byte	"WOPI",TK_TWOPI	; TWOPI
8475    	.byte	$00
8476    TAB_ASCU
8477    LBB_UCASES
8478    	.byte	"CASE$(",TK_UCASES
8479    					; UCASE$(
8480    LBB_UNTIL
8481    	.byte	"NTIL",TK_UNTIL	; UNTIL
8482    LBB_USR
8483    	.byte	"SR(",TK_USR	; USR(
8484    	.byte	$00
8485    TAB_ASCV
8486    LBB_VAL
8487    	.byte	"AL(",TK_VAL	; VAL(
8488    LBB_VPTR
8489    	.byte	"ARPTR(",TK_VPTR	; VARPTR(
8490    	.byte	$00
8491    TAB_ASCW
8492    LBB_WAIT
8493    	.byte	"AIT",TK_WAIT	; WAIT
8494    LBB_WHILE
8495    	.byte	"HILE",TK_WHILE	; WHILE
8496    LBB_WIDTH
8497    	.byte	"IDTH",TK_WIDTH	; WIDTH
8498    	.byte	$00
8499    TAB_POWR
8500    	.byte	TK_POWER,$00	; ^
8501    
8502    ; new decode table for LIST
8503    ; Table is ..
8504    ; byte - keyword length, keyword first character
8505    ; word - pointer to rest of keyword from dictionary
8506    
8507    ; note if length is 1 then the pointer is ignored
8508    
8509    LAB_KEYT
8510    	.byte	3,"E"
8511    	.word	LBB_END		; END
8512    	.byte	3,"F"
8513    	.word	LBB_FOR		; FOR
8514    	.byte	4,"N"
8515    	.word	LBB_NEXT		; NEXT
8516    	.byte	4,"D"
8517    	.word	LBB_DATA		; DATA
8518    	.byte	5,"I"
8519    	.word	LBB_INPUT		; INPUT
8520    	.byte	3,"D"
8521    	.word	LBB_DIM		; DIM
8522    	.byte	4,"R"
8523    	.word	LBB_READ		; READ
8524    	.byte	3,"L"
8525    	.word	LBB_LET		; LET
8526    	.byte	3,"D"
8527    	.word	LBB_DEC		; DEC
8528    	.byte	4,"G"
8529    	.word	LBB_GOTO		; GOTO
8530    	.byte	3,"R"
8531    	.word	LBB_RUN		; RUN
8532    	.byte	2,"I"
8533    	.word	LBB_IF		; IF
8534    	.byte	7,"R"
8535    	.word	LBB_RESTORE		; RESTORE
8536    	.byte	5,"G"
8537    	.word	LBB_GOSUB		; GOSUB
8538    	.byte	6,"R"
8539    	.word	LBB_RETIRQ		; RETIRQ
8540    	.byte	6,"R"
8541    	.word	LBB_RETNMI		; RETNMI
8542    	.byte	6,"R"
8543    	.word	LBB_RETURN		; RETURN
8544    	.byte	3,"R"
8545    	.word	LBB_REM		; REM
8546    	.byte	4,"S"
8547    	.word	LBB_STOP		; STOP
8548    	.byte	2,"O"
8549    	.word	LBB_ON		; ON
8550    	.byte	4,"N"
8551    	.word	LBB_NULL		; NULL
8552    	.byte	3,"I"
8553    	.word	LBB_INC		; INC
8554    	.byte	4,"W"
8555    	.word	LBB_WAIT		; WAIT
8556    	.byte	4,"L"
8557    	.word	LBB_LOAD		; LOAD
8558    	.byte	4,"S"
8559    	.word	LBB_SAVE		; SAVE
8560    	.byte	3,"D"
8561    	.word	LBB_DEF		; DEF
8562    	.byte	4,"P"
8563    	.word	LBB_POKE		; POKE
8564    	.byte	4,"D"
8565    	.word	LBB_DOKE		; DOKE
8566    	.byte	4,"C"
8567    	.word	LBB_CALL		; CALL
8568    	.byte	2,"D"
8569    	.word	LBB_DO		; DO
8570    	.byte	4,"L"
8571    	.word	LBB_LOOP		; LOOP
8572    	.byte	5,"P"
8573    	.word	LBB_PRINT		; PRINT
8574    	.byte	4,"C"
8575    	.word	LBB_CONT		; CONT
8576    	.byte	4,"L"
8577    	.word	LBB_LIST		; LIST
8578    	.byte	5,"C"
8579    	.word	LBB_CLEAR		; CLEAR
8580    	.byte	3,"N"
8581    	.word	LBB_NEW		; NEW
8582    	.byte	5,"W"
8583    	.word	LBB_WIDTH		; WIDTH
8584    	.byte	3,"G"
8585    	.word	LBB_GET		; GET
8586    	.byte	4,"S"
8587    	.word	LBB_SWAP		; SWAP
8588    	.byte	6,"B"
8589    	.word	LBB_BITSET		; BITSET
8590    	.byte	6,"B"
8591    	.word	LBB_BITCLR		; BITCLR
8592    	.byte	3,"I"
8593    	.word	LBB_IRQ		; IRQ
8594    	.byte	3,"N"
8595    	.word	LBB_NMI		; NMI
8596    	.byte	3,"S"			;
8597    	.word	LBB_SYS			; SYS   *** Added for SBC-2
8598    
8599    
8600    ; secondary commands (can't start a statement)
8601    
8602    	.byte	4,"T"
8603    	.word	LBB_TAB		; TAB
8604    	.byte	4,"E"
8605    	.word	LBB_ELSE		; ELSE
8606    	.byte	2,"T"
8607    	.word	LBB_TO		; TO
8608    	.byte	2,"F"
8609    	.word	LBB_FN		; FN
8610    	.byte	4,"S"
8611    	.word	LBB_SPC		; SPC
8612    	.byte	4,"T"
8613    	.word	LBB_THEN		; THEN
8614    	.byte	3,"N"
8615    	.word	LBB_NOT		; NOT
8616    	.byte	4,"S"
8617    	.word	LBB_STEP		; STEP
8618    	.byte	5,"U"
8619    	.word	LBB_UNTIL		; UNTIL
8620    	.byte	5,"W"
8621    	.word	LBB_WHILE		; WHILE
8622    	.byte	3,"O"
8623    	.word	LBB_OFF		; OFF
8624    
8625    ; opperators
8626    
8627    	.byte	1,"+"
8628    	.word	$0000			; +
8629    	.byte	1,"-"
8630    	.word	$0000			; -
8631    	.byte	1,"*"
8632    	.word	$0000			; *
8633    	.byte	1,"/"
8634    	.word	$0000			; /
8635    	.byte	1,"^"
8636    	.word	$0000			; ^
8637    	.byte	3,"A"
8638    	.word	LBB_AND		; AND
8639    	.byte	3,"E"
8640    	.word	LBB_EOR		; EOR
8641    	.byte	2,"O"
8642    	.word	LBB_OR		; OR
8643    	.byte	2,">"
8644    	.word	LBB_RSHIFT		; >>
8645    	.byte	2,"<"
8646    	.word	LBB_LSHIFT		; <<
8647    	.byte	1,">"
8648    	.word	$0000			; >
8649    	.byte	1,"="
8650    	.word	$0000			; =
8651    	.byte	1,"<"
8652    	.word	$0000			; <
8653    
8654    ; functions
8655    
8656    	.byte	4,"S"			;
8657    	.word	LBB_SGN		; SGN
8658    	.byte	4,"I"			;
8659    	.word	LBB_INT		; INT
8660    	.byte	4,"A"			;
8661    	.word	LBB_ABS		; ABS
8662    	.byte	4,"U"			;
8663    	.word	LBB_USR		; USR
8664    	.byte	4,"F"			;
8665    	.word	LBB_FRE		; FRE
8666    	.byte	4,"P"			;
8667    	.word	LBB_POS		; POS
8668    	.byte	4,"S"			;
8669    	.word	LBB_SQR		; SQR
8670    	.byte	4,"R"			;
8671    	.word	LBB_RND		; RND
8672    	.byte	4,"L"			;
8673    	.word	LBB_LOG		; LOG
8674    	.byte	4,"E"			;
8675    	.word	LBB_EXP		; EXP
8676    	.byte	4,"C"			;
8677    	.word	LBB_COS		; COS
8678    	.byte	4,"S"			;
8679    	.word	LBB_SIN		; SIN
8680    	.byte	4,"T"			;
8681    	.word	LBB_TAN		; TAN
8682    	.byte	4,"A"			;
8683    	.word	LBB_ATN		; ATN
8684    	.byte	5,"P"			;
8685    	.word	LBB_PEEK		; PEEK
8686    	.byte	5,"D"			;
8687    	.word	LBB_DEEK		; DEEK
8688    	.byte	5,"S"			;
8689    	.word	LBB_SADD		; SADD
8690    	.byte	4,"L"			;
8691    	.word	LBB_LEN		; LEN
8692    	.byte	5,"S"			;
8693    	.word	LBB_STRS		; STR$
8694    	.byte	4,"V"			;
8695    	.word	LBB_VAL		; VAL
8696    	.byte	4,"A"			;
8697    	.word	LBB_ASC		; ASC
8698    	.byte	7,"U"			;
8699    	.word	LBB_UCASES		; UCASE$
8700    	.byte	7,"L"			;
8701    	.word	LBB_LCASES		; LCASE$
8702    	.byte	5,"C"			;
8703    	.word	LBB_CHRS		; CHR$
8704    	.byte	5,"H"			;
8705    	.word	LBB_HEXS		; HEX$
8706    	.byte	5,"B"			;
8707    	.word	LBB_BINS		; BIN$
8708    	.byte	7,"B"			;
8709    	.word	LBB_BITTST		; BITTST
8710    	.byte	4,"M"			;
8711    	.word	LBB_MAX		; MAX
8712    	.byte	4,"M"			;
8713    	.word	LBB_MIN		; MIN
8714    	.byte	2,"P"			;
8715    	.word	LBB_PI		; PI
8716    	.byte	5,"T"			;
8717    	.word	LBB_TWOPI		; TWOPI
8718    	.byte	7,"V"			;
8719    	.word	LBB_VPTR		; VARPTR
8720    	.byte	6,"L"			;
8721    	.word	LBB_LEFTS		; LEFT$
8722    	.byte	7,"R"			;
8723    	.word	LBB_RIGHTS		; RIGHT$
8724    	.byte	5,"M"			;
8725    	.word	LBB_MIDS		; MID$
8726    
8727    ; BASIC messages, mostly error messages
8728    
8729    LAB_BAER
8730    	.word	ERR_NF		;$00 NEXT without FOR
8731    	.word	ERR_SN		;$02 syntax
8732    	.word	ERR_RG		;$04 RETURN without GOSUB
8733    	.word	ERR_OD		;$06 out of data
8734    	.word	ERR_FC		;$08 function call
8735    	.word	ERR_OV		;$0A overflow
8736    	.word	ERR_OM		;$0C out of memory
8737    	.word	ERR_US		;$0E undefined statement
8738    	.word	ERR_BS		;$10 array bounds
8739    	.word	ERR_DD		;$12 double dimension array
8740    	.word	ERR_D0		;$14 divide by 0
8741    	.word	ERR_ID		;$16 illegal direct
8742    	.word	ERR_TM		;$18 type mismatch
8743    	.word	ERR_LS		;$1A long string
8744    	.word	ERR_ST		;$1C string too complex
8745    	.word	ERR_CN		;$1E continue error
8746    	.word	ERR_UF		;$20 undefined function
8747    	.word ERR_LD		;$22 LOOP without DO
8748    
8749    ; I may implement these two errors to force definition of variables and
8750    ; dimensioning of arrays before use.
8751    
8752    ;	.word ERR_UV		;$24 undefined variable
8753    
8754    ; the above error has been tested and works (see code and comments below LAB_1D8B)
8755    
8756    ;	.word ERR_UA		;$26 undimensioned array
8757    
8758    ERR_NF	.byte	"NEXT without FOR",$00
8759    ERR_SN	.byte	"Syntax",$00
8760    ERR_RG	.byte	"RETURN without GOSUB",$00
8761    ERR_OD	.byte	"Out of DATA",$00
8762    ERR_FC	.byte	"Function call",$00
8763    ERR_OV	.byte	"Overflow",$00
8764    ERR_OM	.byte	"Out of memory",$00
8765    ERR_US	.byte	"Undefined statement",$00
8766    ERR_BS	.byte	"Array bounds",$00
8767    ERR_DD	.byte	"Double dimension",$00
8768    ERR_D0	.byte	"Divide by zero",$00
8769    ERR_ID	.byte	"Illegal direct",$00
8770    ERR_TM	.byte	"Type mismatch",$00
8771    ERR_LS	.byte	"String too long",$00
8772    ERR_ST	.byte	"String too complex",$00
8773    ERR_CN	.byte	"Can't continue",$00
8774    ERR_UF	.byte	"Undefined function",$00
8775    ERR_LD	.byte	"LOOP without DO",$00
8776    
8777    ;ERR_UV	.byte	"Undefined variable",$00
8778    
8779    ; the above error has been tested and works (see code and comments below LAB_1D8B)
8780    
8781    ;ERR_UA	.byte	"Undimensioned array",$00
8782    
8783    LAB_BMSG	.byte	$0D,$0A,"Break",$00
8784    LAB_EMSG	.byte	" Error",$00
8785    LAB_LMSG	.byte	" in line ",$00
8786    LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
8787    
8788    LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
8789    LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
8790    
8791    AA_end_basic
8792    AA_end_basic
8793    	.include "basldsv.asm"	     ; EH-BASIC load & save support8794    
8795    ; VCF-MW 12 6502 Badge Software
8796    ; Hardware design by Lee Hart
8797    ; Software design by Daryl Rictor
8798    ;
8799    ; This software is free to use and modify in any non-commercial application.
8800    ; Comericial use is prohibited without expressed, written permission from the author.
8801    ;
8802    ;******** LOAD & SAVE PATCH FOR ENHANCED BASIC ON 65C02 Simulator
8803    ;
8804    ; Typing SAVE will caclulate start address and end address of the BASIC program and then initiate an XMODEM Send command.  
8805    ;Upon completion of the transfer, you are returned to BASIC.
8806    ;
8807    ; To load a saved program, type LOAD and an XMODEM Receive command is started.  Upon completion, you are 
8808    ; returned to BASIC.  You can type LIST to see your program.
8809    ;
8810    ; If any file transfer errors occur, it is best to retry the commmand.
8811    ;
8812    ;
8813    
8814      003A             Fptr 		= 	$3a			; this value must match the xmodem.asm value for ptr!
8815      003C             Feofp		=	$3c			; this value must match the xmodem.asm value for eofp!
8816    
8817    ;
8818    ; SAVE command
8819    ;
8820    EA3A  20 71 EA     Psave		jsr	Pscan			; finds start and end of the program
8821    EA3D  A6 79        		ldx	Smeml			;
8822    EA3F  A5 7A        		lda	Smemh			; get start address of BASIC program
8823    EA41  86 3A        		stx	Fptr			;
8824    EA43  85 3B        		sta	Fptr+1			; save in xmodem pointer 
8825    EA45  A6 11        		ldx	Itempl			;
8826    EA47  A5 12        		lda	Itemph			; get end address of BASIC program
8827    EA49  86 3C        		stx	Feofp			; 
8828    EA4B  85 3D        		sta	Feofp+1			; save in xmodem pointer
8829    EA4D  4C 98 FD     		jmp	XModemSend		; do XMODEM send andreturn to BASIC
8830    
8831    ;
8832    ; LOAD command
8833    ;
8834    EA50  A5 79        Pload		lda	Smeml			; get start address
8835    EA52  85 3C        		sta	Feofp			; put it in XMODEM pointer
8836    EA54  A5 7A        		lda	Smemh			;
8837    EA56  85 3D        		sta	Feofp+1			;
8838    EA58  20 3D FE     		jsr	XModemRcv		; call XMODEM receive
8839    EA5B  20 71 EA     		jsr	Pscan			; find end of program
8840    EA5E  A5 11        		lda	Itempl			; set variable and string pointers
8841    EA60  85 7B        		sta	Svarl			; to end of file
8842    EA62  85 7D        		sta	Sarryl			; this clears
8843    EA64  85 7F        		sta	Earryl			; both variable sets
8844    EA66  A5 12        		lda	Itemph			; so RUN is fresh.
8845    EA68  85 7C        		sta	Svarh			;
8846    EA6A  85 7E        		sta	Sarryh			;
8847    EA6C  85 80        		sta	Earryh			;
8848    EA6E  4C 18 C4     		JMP	LAB_1319		; Return to BASIC (RTS from thissubroutine call is accounted for)
8849    
8850    ;
8851    ; Scan BASIC RAM to find start and end addresses
8852    ;
8853    EA71  A5 79        Pscan		lda	Smeml			; get start address
8854    EA73  85 11              		sta	Itempl			; temp pointer
8855    EA75  A5 7A              		lda	Smemh			;
8856    EA77  85 12              		sta	Itemph			;
8857    EA79  A0 00        Pscan1		ldy	#$00			; index = 0
8858    EA7B  B1 11        		lda	(Itempl),y		; get first BASIC line (will be pointer to next line or 0)
8859    EA7D  D0 13        		bne	Pscan2			; non zero means a line is present
8860    EA7F  C8           		iny   				;
8861    EA80  B1 11        		lda	(Itempl),y		; get second byte (high byte of pointer or 0)
8862    EA82  D0 0E        		bne	Pscan2			; non zero means a line is present
8863    EA84  18           		clc				; double $00 = end of program
8864    EA85  A9 02        		lda	#$02			; adjust pointer to end of double $00's
8865    EA87  65 11        		adc	Itempl			; by adding 2
8866    EA89  85 11        		sta	Itempl			;
8867    EA8B  A9 00        		lda	#$00			;
8868    EA8D  65 12        		adc	Itemph			;
8869    EA8F  85 12        		sta	Itemph			;
8870    EA91  60           		rts				; done
8871    EA92  A0 00        Pscan2		ldy	#$00			; reset index
8872    EA94  B1 11        		lda	(Itempl),y		; get low byte of pointer 
8873    EA96  AA           		tax				; move to x
8874    EA97  C8           		iny				; point to second byte
8875    EA98  B1 11        		lda	(Itempl),y		; get high byte
8876    EA9A  85 12        		sta	Itemph			; set temp pointer to new line
8877    EA9C  86 11        		stx	Itempl			;
8878    EA9E  80 D9        		bra	Pscan1			; repeat scan 
8879    		bra	Pscan1			; repeat scan 
8880          	.include "serial.asm"	     ; Software UART (9600,n,8,1)8881    
8882    ; VCF-MW 12 6502 Badge Software
8883    ; Hardware design by Lee Hart
8884    ; Software design by Daryl Rictor
8885    ;
8886    ; This software is free to use and modify in any non-commercial application.
8887    ; Comericial use is prohibited without expressed, written permission from the author.
8888    ;
8889    ;------------------------------------------------------------------
8890    ; Bit-banged 9600,N,8,1 Serial I/O using 2MHz 65C02                |
8891    ;                                                                  |  
8892    ; Written by Daryl Rictor     5-18-2017                            |  
8893    ;------------------------------------------------------------------
8894    ;
8895    ; IRQ serial Input
8896    ;
8897    ;  2MHz clock / 9600 bits per seconds = 208.33 clocks per bit.
8898    ;
8899    ; State byte
8900    ; 9 = new byte, this is the start bit
8901    ; 1-8 = bytes 1 - 8 of data
8902    ; 0 = stop bit
8903    ; ff = reset to 9, store byte, and exit
8904    ;
8905    
8906      0200             Serbuf		=	$200		; 128 byte buffer
8907      00EA             Bufin		=	$EA		; zp pointer
8908      00EB             Bufout		=	$EB		; zp pointer
8909      00EC             State		= 	$EC		; IRQ state machine pointer
8910      00ED             Byte		= 	$ED		; temp received data byte
8911      00E1             Dout 		= 	$E1		; ZP temp value
8912      F0FE             Port 		= 	$F0FE		; data port address ( G R Y LED's get cycled with this)
8913    ;LS		=	$80		; defined in font.asm based on bit position
8914    
8915    ;---------------------------------------------------------------------
8916    ; IRQ-based serial data input  (IRQ pin is used for RX data)
8917    ;
8918    ; Incoming data is stored in a 128 byte ring buffer.  If the buffer gets
8919    ; full, the last byte received will overwrite the last byte in the buffer.
8920    ; No error is generated for this condition.
8921    ;---------------------------------------------------------------------
8922    EAA0  A5 EC        IRQ		lda	State		; get current state
8923    EAA2  C9 09        		cmp	#9		; start bit = 9
8924    EAA4  F0 12        		beq	Startbit	; if 0, go to start of new byte	 
8925    EAA6  68           		pla			; discard acc
8926    EAA7  68           		pla			; discard IRQ status
8927    EAA8  68           		pla			; discard IRQ return address
8928    EAA9  68           		pla			;  "       "    "      "	
8929    EAAA  18           		clc			; set bit to 0
8930    EAAB  66 ED        		ror	Byte		; save in received byte
8931    EAAD  C6 EC        		dec	State		; set state to next bit
8932    EAAF  30 1E        		bmi	Stopbit		; yes
8933    EAB1  A6 00        		ldx	$00		; 3 cycle delay
8934    EAB3  A2 1A        		ldx	#26		; init 1 bit time delay 26
8935    EAB5  EA           		nop			; 2 cycles
8936    EAB6  80 05        		bra	Sb1		; 3 cycles get ready for next bit
8937    EAB8  DA           Startbit	phx			; save X register
8938    EAB9  C6 EC        		dec	State		; set to bit 1 
8939    EABB  A2 34        		ldx	#52		; init 1.5 bit time delay 52
8940    EABD  CA           Sb1		dex			; do time delay loop
8941    EABE  D0 FD        		bne	Sb1		; loop unitl x = 0
8942    EAC0  58           		cli			; enable IRQ in the center of the next bit
8943    EAC1  EA           		nop			; give IRQ time to react
8944    EAC2  EA           		nop			; safety delay
8945    EAC3  EA           		nop			; safety delay
8946    EAC4  38           		sec			; set bit to 1 (no IRQ happened)
8947    EAC5  66 ED        		ror	Byte		; save in received byte 
8948    EAC7  A2 24        		ldx	#36		; 1 bit delay 36
8949    EAC9  EA           		nop			; 2 cycles
8950    EACA  EA           		nop			; 2 cycles
8951    EACB  C6 EC        Sb3		dec	State		; set state to next bit
8952    EACD  10 EE        		bpl	Sb1		; No, get ready for the next bit
8953    EACF  26 ED        Stopbit		ROL	Byte		; put data back and put stop bit in C
8954    EAD1  90 12        		bcc	Stoperr		; stop was 0, bad byte, ignore
8955    EAD3  A6 EA        		LDX	Bufin		; get pointer
8956    EAD5  A5 ED        		LDA	Byte		; get data
8957    EAD7  9D 00 02     		STA	Serbuf,x	; safe in buffer
8958    EADA  8A           		txa			; save old pointer
8959    EADB  1A           		ina			; adjust pointer
8960    EADC  29 7F        		and	#$7F		; limit to 128 bytes
8961    EADE  C5 EB        		cmp	Bufout		; check for full buffer		
8962    EAE0  D0 01        		BNE	Stopcont	; not full
8963    EAE2  8A           		txa			; full, don't advance pointer
8964    EAE3  85 EA        Stopcont	sta	Bufin		; save pointer	
8965    EAE5  A9 09        Stoperr		lda	#9		; state = start bit
8966    EAE7  85 EC        		sta	State		; reset state for next byte
8967    EAE9  FA           		plx			; restore X register
8968    EAEA  68           		pla			; restore Acc register
8969    EAEB  40           		rti			; go back to interrupted program			; go back to interrupted program
8970    
8971    ;---------------------------------------------------------------------
8972    ;  Bit-bang Serial data out using bit 7 of LED port
8973    ;---------------------------------------------------------------------
8974    Output
8975    Serial_Output
8976    EAEC  85 E1        SEND		STA 	Dout		; save data to ZP
8977    EAEE  48           		pha			; Save Acc
8978    EAEF  DA                   	phx			; save X
8979    EAF0  5A                   	phy			; save Y
8980    EAF1  A2 08        		LDX 	#8		; bit counter
8981    EAF3  A5 E1        		LDA 	Dout		; get port data
8982    EAF5  29 7F        		AND 	#$FF-LS		; mask bit 7 (SER OUT)
8983    EAF7  8D FE F0     		STA 	Port		; send Start bit
8984    EAFA  EA           		NOP			;
8985    EAFB  4C FE EA     		JMP	A1		; 5 cycle delay
8986    EAFE  A0 24        A1		LDY 	#36		; 1 bit time delay
8987    EB00  88           A2		DEY			;
8988    EB01  D0 FD        		BNE  	A2		; delay loop
8989    EB03  A5 E1        		LDA 	Dout		; get port data
8990    EB05  29 7F        		AND 	#$FF-LS		; mask bit 7 (SER OUT)
8991    EB07  66 E1        		ROR 	Dout		; get next data bit in C flag
8992    EB09  90 05        		BCC  	A4		; if zero, we're set
8993    EB0B  09 80        		ORA 	#LS		; change bit 7 to 1
8994    EB0D  4C 12 EB     		JMP	A3		; delay
8995    EB10  EA           A4		NOP			; delay
8996    EB11  EA           		NOP			; delay
8997    EB12  8D FE F0     A3		STA 	Port		; write data bit to SER OUT
8998    EB15  CA           		DEX			; dec bit counter
8999    EB16  D0 E6        		BNE  	A1		; next bit
9000    EB18  A0 26        		LDY	#38		; 
9001    EB1A  4C 1D EB     		JMP	A5		; 3 cyc delay
9002    EB1D  88           A5		DEY			;
9003    EB1E  D0 FD        		BNE	A5		;
9004    EB20  A5 E1        		LDA 	Dout		; get port data
9005    EB22  09 80        		ORA 	#LS		; set SER OUT bit to 1
9006    EB24  8D FE F0     		STA 	Port		; send stop bit
9007    EB27  A0 26        		ldy	#38		; delay for stop bit
9008    EB29  88           A6		dey			;
9009    EB2A  D0 FD        		bne	A6		;
9010    EB2C  7A                   	ply			; restore Y		
9011    EB2D  FA           	        plx			; restore X
9012    EB2E  68           		pla			; restore A
9013    EB2F  60           		RTS			; done
9014    
9015    ;=================================================================
9016    ; System Functions
9017    ;=================================================================
9018    ;
9019    ; serial_init = initialize the serial IO
9020    ;
9021    ; serial_input = wait for receieved character and return in A
9022    ;
9023    ; serial_scan = scan for key, return C=0 if no key, C=1 for key with key in A
9024    ;
9025    ; serial_output = send a character out the serial port (located above)
9026    ;
9027    ; ----------------------------------------------------------------
9028    ; Initialization of serial IO
9029    Serial_Init
9030    EB30  A9 09        		lda	#9		; state = start bit
9031    EB32  85 EC        		sta	State		; reset state for next byte
9032    EB34  64 EA        		STZ	Bufin		;
9033    EB36  64 EB        		stz	Bufout		;
9034    EB38  60           		rts			; done
9035    
9036    ; ----------------------------------------------------------------
9037    ; Wait for Character to be received
9038    ;
9039    Input_Chr
9040    Serial_Input	
9041    EB39  20 4F FD     Sin1		jsr 	LED_scan	; refresh LED display
9042    EB3C  A5 EB        		lda	Bufout		; get buffer output
9043    EB3E  C5 EA        		cmp	Bufin		; compare with buffer input
9044    EB40  F0 F7        		beq	Sin1		; nothing to get yet
9045    EB42  DA           		phx			; save X
9046    EB43  AA           		tax			; move pointer to X
9047    EB44  1A           		ina			; adjust pointer
9048    EB45  29 7F        		and	#$7F		; limit size to 128 bytes
9049    EB47  85 EB        		sta	Bufout		; save pointer
9050    EB49  BD 00 02     		lda	Serbuf,x	; get data
9051    EB4C  FA           		plx			; restore X
9052    EB4D  09 00        		ora	#$00		; set flags for data byte
9053    EB4F  60           		rts			; done
9054    
9055    ; ----------------------------------------------------------------
9056    ; Scan for character (non-waiting)
9057    
9058    Scan_Input
9059    EB50  20 4F FD     Serial_Scan	jsr 	LED_scan	; refresh LED display
9060    EB53  A5 EB        Serial_ScanQ	lda	Bufout		; get buffer output
9061    EB55  C5 EA        		cmp	Bufin		; compare with buffer input
9062    EB57  18           		clc			; set no data flag
9063    EB58  F0 0E        		beq	Sscan1		; nothing, return carry clear
9064    EB5A  DA           		phx			; save X
9065    EB5B  AA           		tax			; move pointer to X
9066    EB5C  1A           		ina			; adjust pointer
9067    EB5D  29 7F        		and	#$7F		; limit size to 128 bytes
9068    EB5F  85 EB        		sta	Bufout		; save pointer
9069    EB61  BD 00 02     		lda	Serbuf,x	; get data
9070    EB64  FA           		plx			; restore X
9071    EB65  38           		sec			; set data received flag
9072    EB66  09 00        		ora	#$00		; set flags for data byte
9073    EB68  60           Sscan1		rts			; done
9074    
9075    
9076     	.include "sbcos.asm"         ; ML Montor 9077    
9078    ; VCF-MW 12 6502 Badge Software
9079    ; Hardware design by Lee Hart
9080    ; Software design by Daryl Rictor
9081    ;
9082    ; This software is free to use and modify in any non-commercial application.
9083    ; Comericial use is prohibited without expressed, written permission from the author.
9084    ;
9085    ;---------------------------------------------------------------------
9086    ;  SBC Firmware V5.2, 2-24-2018, by Daryl Rictor
9087    ;
9088    ;*********************************************************************       
9089    ;  local Zero-page variables
9090    ;
9091      0032             Prompt         =     $32               ; 1 byte   
9092      0033             Linecnt        =     $33               ; 1 byte
9093      0034             Modejmp        =     $34               ; 1 byte
9094      0035             Hexdigcnt      =     $35               ; 1 byte
9095      0036             OPCtxtptr      =     $36               ; 1 byte
9096      0037             Memchr         =     $37               ; 1 byte
9097      0038             Startaddr      =     $38               ; 2 bytes
9098      0039             Startaddr_H    =     $39
9099      003A             Addrptr        =     $3a               ; 2 bytes
9100      003B             Addrptr_H       =    $3b
9101      003C             Hexdigits      =     $3c               ; 2 bytes
9102      003D             Hexdigits_H    =     $3d
9103      003E             Memptr         =     $3e               ; 2 bytes
9104      003F             Memptr_H       =     $3f
9105    ;
9106    ; Local Non-Zero Page Variables
9107    ;
9108      0300             Buffer         =     $0300             ; keybd input buffer (127 chrs max)
9109    ;               
9110    ; *************************************************************************
9111    ; kernal commands
9112    ; *************************************************************************
9113    ; Print2Byte   - prints AAXX hex digits
9114    ; Print1Byte   - prints AA hex digits
9115    ; PrintDig     - prints A hex nibble (low 4 bits)
9116    ; Print_CR     - prints a CR (ASCII 13)and LF (ASCII 10)
9117    ; PrintXSP     - prints # of spaces in X Reg
9118    ; Print2SP     - prints 2 spaces
9119    ; Print1SP     - prints 1 space
9120    ; Input_assem  - Alternate input prompt for Assember
9121    ; Input        - print <CR> and prompt then get a line of input, store at buffer
9122    ; Input_Chr    - get one byte from input port, waits for input
9123    ; Scan_Input   - Checks for an input character (no waiting)
9124    ; Output       - send one byte to the output port
9125    ; Bell         - send ctrl-g (bell) to output port
9126    ; *************************************************************************
9127    ;
9128    
9129    EB69  48           Print_CR       PHA                     ; Save Acc
9130    EB6A  A9 0D                       LDA   #$0D              ; "cr"
9131    EB6C  20 EC EA                    JSR   Output            ; send it
9132    EB6F  A9 0A                       LDA   #$0A              ; "lf"
9133    EB71  20 EC EA                    JSR   Output            ; send it
9134    EB74  68                          PLA                     ; Restore Acc
9135    EB75  60                          RTS                     ; 
9136    
9137    EB76  20 7A EB     Print2Byte     JSR   Print1Byte        ;  prints AAXX hex digits
9138    EB79  8A                          TXA                     ;
9139    EB7A  48           Print1Byte     PHA                     ;  prints AA hex digits
9140    EB7B  4A                          LSR                     ;  MOVE UPPER NIBBLE TO LOWER
9141    EB7C  4A                          LSR                     ;
9142    EB7D  4A                          LSR                     ;
9143    EB7E  4A                          LSR                     ;
9144    EB7F  20 83 EB                    JSR   PrintDig          ;
9145    EB82  68                          PLA                     ;
9146    EB83  5A           PrintDig       PHY                     ;  prints A hex nibble (low 4 bits)
9147    EB84  29 0F                       AND   #$0F              ;
9148    EB86  A8                          TAY                     ;
9149    EB87  B9 AA F2                    LDA   Hexdigdata,Y      ;
9150    EB8A  7A                          PLY                     ;
9151    EB8B  4C EC EA                    jmp   Output            ;
9152    EB8E  20 9A EB     PrintXSP1      JSR   Print1SP          ;
9153    EB91  CA                          dex                     ;
9154    EB92  E0 00        PrintXSP       cpx   #$00              ;
9155    EB94  D0 F8                       bne   PrintXSP1         ;
9156    EB96  60                          rts                     ;
9157    EB97  20 9A EB     Print2SP       jsr   Print1SP          ; print 2 SPACES
9158    EB9A  A9 20        Print1SP       lda   #$20              ; print 1 SPACE
9159    EB9C  4C EC EA                    jmp   Output            ;
9160    ;
9161    EB9F  A9 21        Input_Assem    lda   #$21              ; Assembler Prompt "!"
9162                   .byte $2c               ; mask out next line to bypass 
9163    EBA2  A9 3E        Input          lda   #$3E              ; Monitor Prompt ">"
9164    EBA4  85 32                       sta   Prompt            ; save prompt chr 
9165    EBA6  20 69 EB     Input1         jsr   Print_CR          ; New Line
9166    EBA9  A5 32                       lda   Prompt            ; get prompt
9167    EBAB  20 EC EA                    jsr   Output            ; Print Prompt
9168    EBAE  A0 FF                       ldy   #$ff              ; pointer
9169    EBB0  20 39 EB     InputWait      jsr   Input_Chr         ; get a character
9170    EBB3  C9 20                       cmp   #$20              ; is ctrl char?
9171    EBB5  B0 3A                       BCS   InputSave         ; no, echo chr 
9172    EBB7  C9 0D                       cmp   #$0d              ; cr
9173    EBB9  F0 41                       Beq   InputDone         ; done
9174    EBBB  C9 1B                       cmp   #$1B              ; esc
9175    EBBD  F0 E7                       beq   Input1            ; cancel and new line
9176    EBBF  C9 08                       cmp   #$08              ; bs
9177    EBC1  F0 06                       beq   Backspace         ;
9178    EBC3  C9 09                       cmp   #$09              ; TAB key
9179    EBC5  F0 18                       beq   Tabkey            ;
9180    EBC7  80 E7                       bra   InputWait         ; ignore other keys
9181    EBC9  C0 FF        Backspace      cpy   #$ff              ;
9182    EBCB  F0 E3                       beq   InputWait         ; nothing to do
9183    EBCD  88                          dey                     ; remove last char
9184    EBCE  A9 08                       Lda   #$08              ; backup one space
9185    EBD0  20 EC EA                    jsr   Output            ;
9186    EBD3  A9 20                       Lda   #$20              ; Print space (destructive BS)
9187    EBD5  20 EC EA                    jsr   Output            ;
9188    EBD8  A9 08                       Lda   #$08              ; backup one space
9189    EBDA  20 EC EA                    jsr   Output            ;
9190    EBDD  80 D1                       BRA   InputWait         ; ready for next key
9191    EBDF  A9 20        Tabkey         lda   #$20              ; convert tab to space
9192    EBE1  C8                          iny                     ; move cursor
9193    EBE2  30 19                       bmi   InputTooLong      ; line too long?
9194    EBE4  99 00 03                    sta   Buffer,y          ; no, save space in buffer
9195    EBE7  20 EC EA                    jsr   Output            ; print the space too
9196    EBEA  98                          tya                     ; test to see if tab is on multiple of 8
9197    EBEB  29 07                       and   #$07              ; mask remainder of cursor/8
9198    EBED  D0 F0                       bne   Tabkey            ; not done, add another space
9199    EBEF  80 BF                       bra   InputWait         ; done. 
9200    EBF1  C8           InputSave      INY                     ;
9201    EBF2  30 09                       BMI   InputTooLong      ; get next char (up to 127)
9202    EBF4  99 00 03                    STA   Buffer,y          ;
9203    EBF7  20 EC EA                    JSR   Output            ; OutputCharacter
9204    EBFA  80 B4                       BRA   InputWait         ;
9205    EBFC  C8           InputDone      INY                     ;
9206    EBFD  A9 0D        InputTooLong   LDA   #$0d              ; force CR at end of 128 characters 
9207    EBFF  99 00 03                    sta   Buffer,y          ;
9208    EC02  20 EC EA                    JSR   Output            ;
9209    ;               lda   #$0a              ; lf Char   
9210    ;               JSR   Output            ;
9211    EC05  60                          RTS                     ;
9212    ;
9213    ;Input_chr      jmp   serial_input      ;
9214    ;Scan_input     jmp   serial_scan       ; 
9215    ;Output         jmp   serial_output     ;
9216    ;
9217    EC06  A9 07        Bell           LDA  #$07               ; Ctrl G Bell
9218    EC08  4C EC EA                    jmp  Output             ; 
9219    ;
9220    ;*************************************************************************
9221    ;     
9222    ;  Monitor Program 
9223    ;
9224    ;**************************************************************************
9225    MonitorBoot    
9226    EC0B  20 A5 EC                    JSR   Version           ;
9227    EC0E  20 06 EC     BRKjmp         jsr   Bell              ; beep ready
9228    SYSjmp                                 ; Added for EhBASIC
9229    EC11  A2 FF        Monitor        LDX   #$FF              ; 
9230    EC13  9A                          TXS                     ;  Init the stack
9231    EC14  20 A2 EB                    JSR   Input             ;  line input
9232    EC17  A9 00                       LDA   #$00              ;
9233    EC19  A8                          TAY                     ;  set to 1st character in line
9234    EC1A  85 33                       sta   Linecnt           ; normal list vs range list 
9235    EC1C  85 37        Mon01          STA   Memchr            ;
9236    EC1E  64 3C        Mon02          STZ   Hexdigits         ;  holds parsed hex
9237    EC20  64 3D                       STZ   Hexdigits+1       ;
9238    EC22  20 4D EC                    JSR   ParseHexDig       ;  Get any Hex chars
9239    EC25  A2 12                       LDX   #CmdCount         ;  get # of cmds currently used
9240    EC27  C9 61                       CMP   #$61              ;   ucase
9241    EC29  90 02                       BCC   Mon08             ;
9242    EC2B  E9 20                       SBC   #$20              ;
9243    EC2D  DD BA F2     Mon08          CMP   CmdAscii,X        ;  is non hex cmd chr?
9244    EC30  F0 05                       BEQ   Mon09             ;  yes x= cmd number
9245    EC32  CA                          DEX                     ;
9246    EC33  10 F8                       BPL   Mon08             ;
9247    EC35  80 DA                       BRA   Monitor           ;  no
9248    EC37  DA           Mon09          PHX                     ;  save command
9249    EC38  5A                          PHY                     ;  Save input line pointer
9250    EC39  8A                          TXA                     ;
9251    EC3A  0A                          ASL                     ;  ptr * 2
9252    EC3B  AA                          TAX                     ;  
9253    EC3C  20 4A EC                    JSR   Mon10             ;  Execute cmd
9254    EC3F  7A                          PLY                     ;
9255    EC40  FA                          PLX                     ;
9256    EC41  F0 CE                       BEQ   Monitor           ;  done
9257    EC43  BD F3 F2                    LDA   Cmdseccode,X      ;  
9258    EC46  30 D6                       BMI   Mon02             ;
9259    EC48  80 D2                       BRA   Mon01             ;
9260    EC4A  7C CD F2     Mon10          JMP   (Cmdjmptbl,X)     ;
9261    ;--------------- Routines used by the Monitor commands ----------------------
9262    EC4D  64 35        ParseHexDig    STZ   Hexdigcnt         ;  cntr
9263    EC4F  80 0E                       BRA   ParseHex05        ;
9264    EC51  8A           ParseHex03     TXA                     ;  parse hex dig
9265    EC52  A2 04                       LDX   #$04              ;  
9266    EC54  06 3C        ParseHex04     ASL   Hexdigits         ;
9267    EC56  26 3D                       ROL   Hexdigits+1       ;
9268    EC58  CA                          DEX                     ;
9269    EC59  D0 F9                       BNE   ParseHex04        ;
9270    EC5B  04 3C                       TSB   Hexdigits         ;
9271    EC5D  C6 35                       DEC   Hexdigcnt         ;
9272    EC5F  B9 00 03     ParseHex05     LDA   Buffer,Y          ;
9273    EC62  C9 61                       CMP   #$61              ;   ucase
9274    EC64  90 02                       BCC   ParseHex06        ;
9275    EC66  E9 20                       SBC   #$20              ;
9276    EC68  A2 0F        ParseHex06     LDX   #$0F              ;   is hex chr?
9277    EC6A  C8                          INY                     ;
9278    EC6B  DD AA F2     ParseHex07     CMP   Hexdigdata,X      ;
9279    EC6E  F0 E1                       BEQ   ParseHex03        ;   yes
9280    EC70  CA                          DEX                     ;
9281    EC71  10 F8                       BPL   ParseHex07        ;
9282    EC73  60                          RTS                     ; Stored in HexDigits if HexDigCnt <> 0
9283    ;
9284    EC74  A9 24        Help_cmd       lda   #<HelpTxt         ;  lower byte - Menu of Commands
9285    EC76  85 3A                       sta   Addrptr           ;
9286    EC78  A9 F6                       lda   #>HelpTxt         ;  upper byte
9287    EC7A  85 3B                       sta   Addrptr+1         ;
9288    EC7C  80 0F                       bra   Help_cmd3         ;
9289    EC7E  C9 7E        Help_cmd4      cmp   #$7e              ;  "~" (used for new line)
9290    EC80  F0 05                       beq   Help_cmd1         ;
9291    EC82  20 EC EA                    jsr   Output            ;
9292    EC85  80 03                       bra   Help_cmd2         ;
9293    EC87  20 69 EB     Help_cmd1      jsr   Print_CR          ;     
9294    EC8A  20 57 ED     Help_cmd2      jsr   Inc_addrptr       ;
9295    EC8D  B2 3A        Help_cmd3      lda   (Addrptr)         ;
9296    EC8F  D0 ED                       bne   Help_cmd4         ;
9297    EC91  60           Lrts           rts                     ;
9298    EC92  C0 01        Power_cmd      cpy   #$01              ; Power command must be P*
9299    EC94  D0 FB                       bne   Lrts              ; invalid format, exit
9300    EC96  B9 00 03                    lda   Buffer, y         ; get second character
9301    EC99  C9 2A                       cmp   #'*'              ; is it *?
9302    EC9B  D0 F4                       bne   Lrts              ; invalid format, exit
9303    EC9D  78                          sei                     ; disable IRQ
9304    EC9E  A9 FF                       lda   #$FF              ;
9305    ECA0  8D FF F0                    sta   $F0FF             ; turn off LED display
9306    ECA3  80 FE        PowerLP        bra   PowerLP           ; endless loop
9307    ECA5  20 69 EB     Version        jsr   Print_CR          ; 
9308    ECA8  A2 FF                       ldx   #$FF              ; set txt pointer
9309    ECAA  A9 0D                       lda   #$0d              ; 
9310    ECAC  E8           PortReadyMsg   inx                     ;
9311    ECAD  20 EC EA                    JSR   Output            ; put character to Port
9312    ECB0  BD EF FB                    lda   Porttxt,x         ; get message text
9313    ECB3  D0 F7                       bne   PortReadyMsg      ; 
9314    ECB5  60                          rts                     ;
9315    ;
9316    ECB6  20 BF EC     Excute_cmd     jsr   Exe1              ;
9317    ECB9  A2 FF                       ldx   #$FF              ; reset stack
9318    ECBB  9A                          txs                     ;
9319    ECBC  4C 11 EC                    jmp   Monitor           ;
9320    ECBF  6C 3C 00     Exe1           JMP   (Hexdigits)       ;
9321    ;
9322    ECC2  A6 3C        DOT_cmd        LDX   Hexdigits         ; move address to addrptr
9323    ECC4  A5 3D                       LDA   Hexdigits+1       ;
9324    ECC6  86 3A                       STX   Addrptr           ;
9325    ECC8  85 3B                       STA   Addrptr+1         ;
9326    ECCA  E6 33                       inc   Linecnt           ; range list command
9327    ECCC  60                          RTS                     ;
9328    ;
9329    ECCD  C0 01        CR_cmd         CPY   #$01              ;
9330    ECCF  D0 0C                       BNE   SP_cmd            ;
9331    ECD1  A5 3A                       LDA   Addrptr           ; CR alone - move addrptr to hexdigits
9332    ECD3  09 0F                       ORA   #$0F              ;  to simulate entering an address
9333    ECD5  85 3C                       STA   Hexdigits         ; *** change 07 to 0f for 16 byte/line
9334    ECD7  A5 3B                       LDA   Addrptr+1         ;
9335    ECD9  85 3D                       STA   Hexdigits+1       ;
9336    ECDB  80 17                       BRA   SP_cmd2           ;
9337    ECDD  A5 35        SP_cmd         LDA   Hexdigcnt         ; Space command entry
9338    ECDF  F0 5A                       BEQ   SP_cmd5           ; any digits to process? no - done
9339    ECE1  A6 37                       LDX   Memchr            ; yes - is sec cmd code 0 ? yes - 
9340    ECE3  F0 0A                       BEQ   SP_cmd1           ; yes - 
9341    ECE5  CA                          DEX                     ; Is sec cmd = 1?       
9342    ECE6  F0 1C                       BEQ   SP_cmd3           ;       yes - is sec cmd code 1 ?
9343    ECE8  A5 3C                       LDA   Hexdigits         ;             no - ":" cmd processed
9344    ECEA  92 3A                       STA   (Addrptr)         ;
9345    ECEC  4C 57 ED                    JMP   Inc_addrptr       ; set to next address and return
9346    ECEF  20 C2 EC     SP_cmd1        JSR   DOT_cmd           ; sec dig = 0  move address to addrptr
9347    ECF2  80 10                       BRA   SP_cmd3           ;
9348    ECF4  A5 3A        SP_cmd2        LDA   Addrptr           ; CR cmd entry 
9349    ECF6  89 0F                       BIT   #$0F              ; *** changed 07 to 0F for 16 bytes/line
9350    ECF8  F0 0A                       BEQ   SP_cmd3           ; if 16, print new line
9351    ECFA  C0 00                       cpy   #$00              ; if TXT cmd, don"t print the - or spaces between chrs
9352    ECFC  F0 46                       beq   TXT_cmd1          ;
9353    ECFE  89 07                       BIT   #$07              ; if 8, print -
9354    ED00  F0 11                       BEQ   SP_cmd33          ;
9355    ED02  80 19                       BRA   SP_cmd4           ; else print next byte
9356    ED04  20 69 EB     SP_cmd3        JSR   Print_CR          ; "." cmd - display address and data 
9357    ED07  20 50 EB                    jsr   Scan_Input        ; see if brk requested
9358    ED0A  B0 2D                       bcs   SP_brk            ; if so, stop 
9359    ED0C  A5 3B                       LDA   Addrptr+1         ; print address
9360    ED0E  A6 3A                       LDX   Addrptr           ;
9361    ED10  20 76 EB                    JSR   Print2Byte        ;
9362    ED13  A9 20        SP_cmd33       LDA   #$20              ; " " print 1 - 16 bytes of data
9363    ED15  20 EC EA                    JSR   Output            ;
9364    ED18  A9 2D                       LDA   #$2D              ; "-"
9365    ED1A  20 EC EA                    JSR   Output            ;
9366    ED1D  A9 20        SP_cmd4        LDA   #$20              ; " " 
9367    ED1F  20 EC EA                    JSR   Output            ;
9368    ED22  C0 00                       cpy   #$00              ;
9369    ED24  F0 1E                       beq   TXT_cmd1          ;
9370    ED26  B2 3A                       LDA   (Addrptr)         ;
9371    ED28  20 7A EB                    JSR   Print1Byte        ;
9372    ED2B  38           SP_cmd44       SEC                     ;  checks if range done
9373    ED2C  A5 3A                       LDA   Addrptr           ;
9374    ED2E  E5 3C                       SBC   Hexdigits         ;
9375    ED30  A5 3B                       LDA   Addrptr+1         ;
9376    ED32  E5 3D                       SBC   Hexdigits+1       ;
9377    ED34  20 57 ED                    jsr   Inc_addrptr       ;
9378    ED37  90 BB                       BCC   SP_cmd2           ; loop until range done
9379    ED39  64 37        SP_brk         STZ   Memchr            ; reset sec cmd code
9380    ED3B  60           SP_cmd5        RTS                     ; done or no digits to process
9381    ;
9382    ED3C  5A           TXT_cmd        PHY                     ;
9383    ED3D  A0 00                       ldy   #$00              ;
9384    ED3F  20 DD EC                    jsr   SP_cmd            ;
9385    ED42  7A                          PLY                     ;
9386    ED43  60                          RTS                     ;
9387    ED44  B2 3A        TXT_cmd1       LDA   (Addrptr)         ;
9388    ED46  29 7F                       AND   #$7F              ;
9389    ED48  C9 7F                       CMP   #$7F              ;
9390    ED4A  F0 04                       BEQ   TXT_cmd2          ;
9391    ED4C  C9 20                       CMP   #$20              ; " "
9392    ED4E  B0 02                       BCS   TXT_cmd3          ;
9393    ED50  A9 2E        TXT_cmd2       LDA   #$2E              ; "." use "." if not printable char
9394    ED52  20 EC EA     TXT_cmd3       JSR   Output            ;
9395    ED55  80 D4                       BRA   SP_cmd44          ;
9396    ;
9397    ED57  E6 3A        Inc_addrptr    INC   Addrptr           ;  increments addrptr
9398    ED59  D0 02                       BNE   Inc_addr1         ;
9399    ED5B  E6 3B                       INC   Addrptr+1         ;
9400    ED5D  60           Inc_addr1      RTS                     ;
9401    ;
9402    ED5E  A5 33        Insert_cmd     lda   Linecnt           ;  "I" cmd code
9403    ED60  F0 3E                       beq   Insert_3          ; abort if no . cmd entered
9404    ED62  38                          sec                     ;
9405    ED63  A5 3C                       lda   Hexdigits         ;
9406    ED65  E5 3A                       sbc   Addrptr           ;
9407    ED67  AA                          tax                     ;
9408    ED68  A5 3D                       lda   Hexdigits+1       ;
9409    ED6A  E5 3B                       sbc   Addrptr+1         ;
9410    ED6C  A8                          tay                     ;
9411    ED6D  90 31                       bcc   Insert_3          ;
9412    ED6F  18                          clc                     ;
9413    ED70  8A                          txa                     ;
9414    ED71  65 3E                       adc   Memptr            ;
9415    ED73  85 3C                       sta   Hexdigits         ;
9416    ED75  98                          tya                     ;
9417    ED76  65 3F                       adc   Memptr+1          ;
9418    ED78  85 3D                       sta   Hexdigits+1       ;
9419    ED7A  B2 3E        Insert_0       LDA   (Memptr)          ;
9420    ED7C  92 3C                       STA   (Hexdigits)       ;
9421    ED7E  A9 FF                       lda   #$FF              ;
9422    ED80  C6 3C                       DEC   Hexdigits         ;  
9423    ED82  C5 3C                       cmp   Hexdigits         ;  
9424    ED84  D0 02                       BNE   Insert_1          ;
9425    ED86  C6 3D                       DEC   Hexdigits+1       ;
9426    ED88  C6 3E        Insert_1       dec   Memptr            ;  
9427    ED8A  C5 3E                       cmp   Memptr            ;
9428    ED8C  D0 02                       bne   Insert_2          ;
9429    ED8E  C6 3F                       dec   Memptr+1          ;
9430    ED90  38           Insert_2       SEC                     ;  
9431    ED91  A5 3E                       LDA   Memptr            ;
9432    ED93  E5 3A                       SBC   Addrptr           ;
9433    ED95  A5 3F                       LDA   Memptr+1          ;
9434    ED97  E5 3B                       SBC   Addrptr+1         ;
9435    ED99  90 05                       bcc   Insert_3          ;
9436    ED9B  20 50 EB                    jsr   Scan_Input        ; see if brk requested
9437    ED9E  90 DA                       bcc   Insert_0          ; if so, stop List
9438    EDA0  60           Insert_3       RTS                     ;
9439    ;
9440    EDA1  A5 33        Move_cmd       lda   Linecnt           ; *** any changes to this routine affect EEPROM_WR too!!!
9441    EDA3  D0 0D                       bne   Move_cmd3         ; abort if no . cmd was used
9442    EDA5  60           Move_brk       RTS                     ;
9443    EDA6  E6 3A        Move_cmd1      INC   Addrptr           ;  increments addrptr
9444    EDA8  D0 02                       BNE   Move_cmd2         ;
9445    EDAA  E6 3B                       INC   Addrptr+1         ;
9446    EDAC  E6 3C        Move_cmd2      inc   Hexdigits         ;  "M" cmd code
9447    EDAE  D0 02                       bne   Move_cmd3         ;
9448    EDB0  E6 3D                       inc   Hexdigits+1       ;
9449    EDB2  38           Move_cmd3      SEC                     ;  checks if range done
9450    EDB3  A5 3E                       LDA   Memptr            ;
9451    EDB5  E5 3A                       SBC   Addrptr           ;
9452    EDB7  A5 3F                       LDA   Memptr+1          ;
9453    EDB9  E5 3B                       SBC   Addrptr+1         ;
9454    EDBB  90 E8                       BCC   Move_brk          ;  exit if range done
9455    EDBD  20 50 EB                    jsr   Scan_Input        ; see if brk requested
9456    EDC0  B0 E3                       bcs   Move_brk          ; 
9457    EDC2  B2 3A                       LDA   (Addrptr)         ;  Moves one byte
9458    EDC4  92 3C                       STA   (Hexdigits)       ;
9459    EDC6  80 DE                       BRA   Move_cmd1         ; (zapped after move from eeprom_wr)
9460    ;
9461    EDC8  A6 3C        Dest_cmd       LDX   Hexdigits         ;  ">" cmd code
9462    EDCA  A5 3D                       LDA   Hexdigits+1       ;
9463    EDCC  86 3E                       STX   Memptr            ;  move address to memptr
9464    EDCE  85 3F                       STA   Memptr+1          ;
9465    EDD0  60                          RTS                     ;  
9466                                           ;
9467    EDD1  A5 33        LIST_cmd       lda   Linecnt           ;  Check for normal/range
9468    EDD3  F0 29                       beq   List_cmd_1        ;  0 = normal  1=range 
9469    EDD5  A5 3A                       LDA   Addrptr           ;  Dissassemble range of code
9470    EDD7  A6 3B                       LDX   Addrptr+1         ;  move addrptr to startaddr
9471    EDD9  85 38                       STA   Startaddr         ;
9472    EDDB  86 39                       STX   Startaddr+1       ;
9473    EDDD  38           List_range     sec                     ;
9474    EDDE  A5 38                       lda   Startaddr         ;
9475    EDE0  E5 3A                       sbc   Addrptr           ;
9476    EDE2  A5 39                       lda   Startaddr+1       ; 
9477    EDE4  E5 3B                       sbc   Addrptr+1         ;
9478    EDE6  90 15                       bcc   List_done         ;
9479    EDE8  20 16 EE                    jsr   List_line         ;  list one line
9480    EDEB  20 50 EB                    jsr   Scan_Input        ; see if brk requested
9481    EDEE  B0 0D                       bcs   List_done         ; if so, stop List
9482    EDF0  38                          SEC                     ;  checks if range done
9483    EDF1  A5 3C                       LDA   Hexdigits         ;
9484    EDF3  E5 38                       SBC   Startaddr         ;
9485    EDF5  A5 3D                       LDA   Hexdigits+1       ;
9486    EDF7  E5 39                       SBC   Startaddr+1       ;
9487    EDF9  B0 E2                       BCS   List_range        ;  if not, loop until done
9488    EDFB  64 33                       stz   Linecnt           ;
9489    EDFD  60           List_done      RTS                     ;
9490    EDFE  A5 35        List_cmd_1     LDA   Hexdigcnt         ; Dissassemble one page of cmds
9491    EE00  F0 08                       BEQ   List1             ; followed with more pages 
9492    EE02  A6 3C                       LDX   Hexdigits         ;
9493    EE04  A5 3D                       LDA   Hexdigits+1       ;
9494    EE06  86 38                       STX   Startaddr         ;
9495    EE08  85 39                       STA   Startaddr+1       ;
9496    EE0A  A9 14        List1          LDA   #$14              ; one page of dissassembly
9497    EE0C  85 33                       STA   Linecnt           ;
9498    EE0E  20 16 EE     List2          JSR   List_line         ;
9499    EE11  C6 33                       DEC   Linecnt           ;
9500    EE13  D0 F9                       BNE   List2             ;
9501    EE15  60                          RTS                     ;
9502    EE16  20 69 EB     List_line      JSR   Print_CR          ; 
9503    EE19  20 28 EE                    JSR   List_one          ; one line of dissassembly
9504    EE1C  18                          CLC                     ;
9505    EE1D  A5 38                       LDA   Startaddr         ; inc address pointer to next cmd
9506    EE1F  65 35                       ADC   Hexdigcnt         ;
9507    EE21  85 38                       STA   Startaddr         ;
9508    EE23  90 02                       BCC   List3             ;
9509    EE25  E6 39                       INC   Startaddr+1       ;
9510    EE27  60           List3          RTS                     ;
9511    EE28  B2 38        List_one       LDA   (Startaddr)       ; Dissassemble one CMD from Startaddr
9512    EE2A  AA                          TAX                     ; Initialize List Cmd pointers
9513    EE2B  BD 06 F3                    LDA   OPCtxtidx,X       ;
9514    EE2E  85 36                       STA   OPCtxtptr         ;
9515    EE30  BD 06 F4                    LDA   OPCaddmode,X      ;
9516    EE33  29 0F                       AND   #$0F              ; mask out psuedo-modes
9517    EE35  85 34                       STA   Modejmp           ;
9518    EE37  AA                          TAX                     ;
9519    EE38  BD 06 F5                    LDA   ModeByteCnt,X     ;
9520    EE3B  85 35                       STA   Hexdigcnt         ;
9521    EE3D  A5 39                       LDA   Startaddr+1       ;
9522    EE3F  A6 38                       LDX   Startaddr         ;
9523    EE41  20 76 EB                    JSR   Print2Byte        ; print address 
9524    EE44  A9 2D                       LDA   #$2D              ;  "-"
9525    EE46  20 EC EA                    JSR   Output            ;
9526    EE49  20 97 EB                    JSR   Print2SP          ; print "  "
9527    EE4C  A2 01                       LDX   #$01              ;---------
9528    EE4E  A0 00        List4          LDY   #$00              ;print up to 3 ascii chars...
9529    EE50  C4 35        List5          CPY   Hexdigcnt         ;  two spaces...
9530    EE52  B0 0B                       BCS   List6             ;  up to three hex chars...
9531    EE54  B1 38                       LDA   (Startaddr),Y     ;  two spaces
9532    EE56  E0 00                       CPX   #$00              ;
9533    EE58  D0 0E                       BNE   List8             ;
9534    EE5A  20 7A EB                    JSR   Print1Byte        ;
9535    EE5D  80 07                       BRA   List7             ;
9536    EE5F  E0 00        List6          CPX   #$00              ;
9537    EE61  D0 03                       BNE   List7             ;
9538    EE63  20 97 EB                    JSR   Print2SP          ;
9539    EE66  A9 20        List7          LDA   #$20              ; " "
9540    EE68  29 7F        List8          AND   #$7F              ;
9541    EE6A  C9 7F                       CMP   #$7F              ;
9542    EE6C  F0 04                       BEQ   List9             ;
9543    EE6E  C9 20                       CMP   #$20              ; " "
9544    EE70  B0 02                       BCS   List10            ;
9545    EE72  A9 2E        List9          LDA   #$2E              ; "." use "." if not printable char
9546    EE74  20 EC EA     List10         JSR   Output            ;
9547    EE77  C8                          INY                     ;
9548    EE78  C0 03                       CPY   #$03              ;
9549    EE7A  90 D4                       BCC   List5             ;
9550    EE7C  20 97 EB                    JSR   Print2SP          ;
9551    EE7F  CA                          DEX                     ;
9552    EE80  F0 CC                       BEQ   List4             ;---------
9553    EE82  A5 36                       LDA   OPCtxtptr         ; get opcode text
9554    EE84  0A                          ASL                     ;
9555    EE85  65 36                       ADC   OPCtxtptr         ;
9556    EE87  AA                          TAX                     ;
9557    EE88  A0 FD                       LDY   #$FD              ;
9558    EE8A  BD 46 F5     List11         LDA   OPCTxtData,X      ;
9559    EE8D  20 EC EA                    JSR   Output            ; print opcode text
9560    EE90  E8                          INX                     ;
9561    EE91  C8                          INY                     ;
9562    EE92  D0 F6                       BNE   List11            ;
9563    EE94  A5 36                       LDA   OPCtxtptr         ;
9564    EE96  C9 42                       CMP   #$42              ; 4chr opcodes start
9565    EE98  30 19                       BMI   List12		   ;
9566    EE9A  C9 46                       CMP   #$46              ; the .xx cmds
9567    EE9C  10 15                       BPL   List12            ; 
9568    EE9E  B2 38                       lda   (Startaddr)	   ; get opcode of 4byte code
9569    EEA0  4A                          lsr
9570    EEA1  4A                          lsr
9571    EEA2  4A                          lsr
9572    EEA3  4A                          lsr
9573    EEA4  29 07                       AND   #$07              ; strip last 3 bits
9574    EEA6  09 30                       ora   #$30              ; add CHR '0'
9575    EEA8  20 EC EA                    jsr   Output            ; print it
9576    EEAB  A9 20                       lda   #$20              ; " "
9577    EEAD  20 EC EA                    jsr   Output            ; 
9578    EEB0  4C B6 EE                    jmp   List13            ;
9579    EEB3  20 97 EB     List12         JSR   Print2SP          ;
9580    EEB6  A5 34        List13         LDA   Modejmp           ; setup to print operand
9581    EEB8  0A                          ASL                     ;
9582    EEB9  AA                          TAX                     ;
9583    EEBA  7C 16 F5                    JMP   (ModeJmpTbl,X)    ; goto operand printing command
9584    
9585    EEBD  A9 23        IMM_mode       LDA   #$23              ; print #$HH
9586    EEBF  20 EC EA                    JSR   Output            ;
9587    EEC2  A9 24        ZP_mode        LDA   #$24              ; print $HH
9588    EEC4  20 EC EA                    JSR   Output            ;
9589    EEC7  A0 01                       LDY   #$01              ;
9590    EEC9  B1 38        Byte_mode      LDA   (Startaddr),Y     ;
9591    EECB  4C 7A EB                    JMP   Print1Byte        ;
9592    EECE  20 C2 EE     ZP_X_mode      JSR   ZP_mode           ; print $HH,X
9593    EED1  A9 2C        X_mode         LDA   #$2C              ; print ,X
9594    EED3  20 EC EA                    JSR   Output            ;
9595    EED6  A9 58                       LDA   #$58              ; 
9596    EED8  4C EC EA                    JMP   Output            ;
9597    EEDB  20 C2 EE     ZP_Y_mode      JSR   ZP_mode           ; print $HH,Y
9598    EEDE  A9 2C        Y_mode         LDA   #$2C              ; Print ,Y
9599    EEE0  20 EC EA                    JSR   Output            ;
9600    EEE3  A9 59                       LDA   #$59              ; 
9601    EEE5  4C EC EA                    JMP   Output            ;
9602    EEE8  20 2E EF     INDZP_mode     JSR   IND0_mode         ; Print ($HH)
9603    EEEB  20 C2 EE                    JSR   ZP_mode           ;
9604    EEEE  A9 29        IND1_mode      LDA   #$29              ; Print )
9605    EEF0  4C EC EA                    JMP   Output            ;
9606    EEF3  20 2E EF     INDZP_X_mode   JSR   IND0_mode         ; Print ($HH,X)
9607    EEF6  20 C2 EE                    JSR   ZP_mode           ;
9608    EEF9  20 D1 EE                    JSR   X_mode            ;
9609    EEFC  80 F0                       BRA   IND1_mode         ;
9610    EEFE  20 E8 EE     INDZP_Y_mode   JSR   INDZP_mode        ; Print ($HH),Y
9611    EF01  80 DB                       BRA   Y_mode            ;
9612    EF03  A9 24        ABS_mode       LDA   #$24              ; Print $HHHH
9613    EF05  20 EC EA                    JSR   Output            ;
9614    EF08  A0 02                       LDY   #$02              ;
9615    EF0A  20 C9 EE                    JSR   Byte_mode         ;
9616    EF0D  88                          DEY                     ;
9617    EF0E  80 B9                       BRA   Byte_mode         ;
9618    EF10  20 03 EF     ABS_X_mode     JSR   ABS_mode          ; Print $HHHH,X
9619    EF13  80 BC                       BRA   X_mode            ;
9620    EF15  20 03 EF     ABS_Y_mode     JSR   ABS_mode          ; Print $HHHH,Y
9621    EF18  80 C4                       BRA   Y_mode            ;
9622    EF1A  20 2E EF     INDABS_mode    JSR   IND0_mode         ; Print ($HHHH)
9623    EF1D  20 03 EF                    JSR   ABS_mode          ;
9624    EF20  80 CC                       BRA   IND1_mode         ;
9625    EF22  20 2E EF     INDABSX_mode   JSR   IND0_mode         ; Print ($HHHH,X)
9626    EF25  20 03 EF                    JSR   ABS_mode          ;
9627    EF28  20 D1 EE                    JSR   X_mode            ;
9628    EF2B  80 C1                       BRA   IND1_mode         ;
9629    EF2D  60           IMPLIED_mode   RTS                     ; Implied/Accumulator mode 
9630    EF2E  A9 28        IND0_mode      LDA   #$28              ; Print (
9631    EF30  4C EC EA                    JMP   Output            ;
9632    EF33  20 C2 EE     BBREL_mode     JSR   ZP_mode           ;
9633    EF36  A9 2C                       LDA   #$2C              ; Print ,
9634    EF38  20 EC EA                    JSR   Output            ;
9635    EF3B  A9 24                       LDA   #$24              ; Print $
9636    EF3D  20 EC EA                    JSR   Output            ;
9637    EF40  A0 02                       LDY   #$02              ;
9638    EF42  B1 38                       LDA   (Startaddr),Y     ;
9639    EF44  85 37                       STA   Memchr            ;
9640    EF46  18                          CLC                     ;
9641    EF47  A5 38                       LDA   Startaddr         ;
9642    EF49  69 03                       ADC   #$03              ;
9643    EF4B  4C 5E EF                    JMP   REL_mode0         ;
9644    EF4E  A9 24        REL_mode       LDA   #$24              ; Print $HHHH as Relative Branch
9645    EF50  20 EC EA                    JSR   Output            ;
9646    EF53  A0 01                       LDY   #$01              ;
9647    EF55  B1 38                       LDA   (Startaddr),Y     ;
9648    EF57  85 37                       STA   Memchr            ;
9649    EF59  18                          CLC                     ;
9650    EF5A  A5 38                       LDA   Startaddr         ;
9651    EF5C  69 02                       ADC   #$02              ;
9652    EF5E  AA           REL_mode0      TAX                     ;
9653    EF5F  A5 39                       LDA   Startaddr+1       ;
9654    EF61  69 00                       ADC   #$00              ;
9655    EF63  A8                          TAY                     ;
9656    EF64  18                          CLC                     ;
9657    EF65  8A                          TXA                     ;
9658    EF66  65 37                       ADC   Memchr            ;
9659    EF68  AA                          TAX                     ;
9660    EF69  98                          TYA                     ;
9661    EF6A  A4 37                       LDY   Memchr            ;
9662    EF6C  10 01                       BPL   Rel_mode1         ;
9663    EF6E  3A                          DEA                     ;
9664    EF6F  69 00        Rel_mode1      ADC   #$00              ;
9665    EF71  4C 76 EB                    JMP   Print2Byte        ;
9666    ;
9667    ;mini assembler code
9668    ;
9669    EF74  BA           Assem_Init     tsx                     ;
9670    EF75  E8                          inx                     ;
9671    EF76  E8                          inx                     ;
9672    EF77  E8                          inx                     ;
9673    EF78  E8                          inx                     ;
9674    EF79  9E 00 01                    stz   $0100,x           ;
9675    EF7C  20 A5 EC                    jsr   Version           ;  show version and ? prompt
9676    EF7F  4C A2 EF                    jmp   Assembler         ;
9677    EF82  A9 5D        Asm_Help       lda   #<AsmHelpTxt      ;  lower byte - Menu of Commands
9678    EF84  85 3A                       sta   Addrptr           ;
9679    EF86  A9 FA                       lda   #>AsmHelpTxt      ;  upper byte
9680    EF88  85 3B                       sta   Addrptr+1         ;
9681    EF8A  80 0F                       bra   AsmHelp3          ;
9682    EF8C  C9 7E        AsmHelp4       cmp   #$7e              ;  "~"
9683    EF8E  F0 05                       beq   AsmHelp1          ;
9684    EF90  20 EC EA                    jsr   Output            ;
9685    EF93  80 03                       bra   AsmHelp2          ;
9686    EF95  20 69 EB     AsmHelp1       jsr   Print_CR          ;     
9687    EF98  20 57 ED     AsmHelp2       jsr   Inc_addrptr       ;
9688    EF9B  B2 3A        AsmHelp3       lda   (Addrptr)         ;
9689    EF9D  D0 ED                       bne   AsmHelp4          ;
9690    EF9F  20 70 F2                    jsr   Opcode_List       ;  
9691    
9692    EFA2  A2 FF        Assembler      LDX   #$FF              ;
9693    EFA4  9A                          TXS                     ; init stack
9694    EFA5  64 35                       stz   Hexdigcnt         ;
9695    EFA7  20 9F EB                    jsr   Input_Assem       ;
9696    EFAA  A0 00                       ldy   #$00              ; beginning of input line
9697    EFAC  AD 00 03                    lda   Buffer            ;
9698    EFAF  C9 0D                       cmp   #$0d              ; Enter = done 
9699    EFB1  D0 03                       bne   Asm01             ;
9700    EFB3  4C 11 EC                    JMP   Monitor           ; exit assembler
9701    EFB6  C9 3F        Asm01          cmp   #$3f              ; "?" Print Help
9702    EFB8  F0 C8                       beq   Asm_Help          ;
9703    EFBA  C9 20                       cmp   #$20              ; space
9704    EFBC  F0 3B                       beq   Asm_opfetch       ;
9705    EFBE  C9 3B                       cmp   #$3b              ;  ";" ignore line
9706    EFC0  F0 E0                       beq   Assembler         ;
9707    EFC2  C9 4C                       cmp   #$4C              ;  "L" list
9708    EFC4  F0 2C                       beq   Asm_list          ;
9709    EFC6  C9 24                       cmp   #$24              ;  "$" ignore this
9710    EFC8  D0 01                       bne   Asm02             ;
9711    EFCA  C8                          iny                     ;
9712    EFCB  64 3C        Asm02          STZ   Hexdigits         ;  holds parsed hex
9713    EFCD  64 3D                       STZ   Hexdigits+1       ;
9714    EFCF  20 4D EC                    JSR   ParseHexDig       ;  get Hex Chars 
9715    EFD2  A6 35                       LDX   Hexdigcnt         ;
9716    EFD4  F0 08                       Beq   Asm_err           ;
9717    EFD6  C9 4C                       cmp   #$4C              ; "L" do list               ???
9718    EFD8  F0 1A                       Beq   Asm_list1         ;
9719    EFDA  C9 20                       cmp   #$20              ; Space
9720    EFDC  F0 1B                       Beq   Asm_opfetch       ;
9721    EFDE  98           Asm_err        tya                     ;  get line pointer
9722    EFDF  AA                          tax                     ;
9723    EFE0  A9 0A                       lda   #$0a              ; LF move down one line
9724    EFE2  20 EC EA                    jsr   Output            ;
9725    EFE5  20 92 EB                    jsr   PrintXSP          ; move to where error occured
9726    EFE8  A9 5E                       lda   #$5E              ; "^"                       ???
9727    EFEA  20 EC EA                    jsr   Output            ; mark it 
9728    EFED  20 06 EC                    jsr   Bell              ; 
9729    EFF0  80 B0                       bra   Assembler         ;
9730    EFF2  64 35        Asm_list       stz   Hexdigcnt         ;
9731    EFF4  20 FE ED     Asm_list1      jsr   List_cmd_1        ;
9732    EFF7  80 A9        Asm_hop        bra   Assembler         ;
9733    EFF9  A5 35        Asm_opfetch    lda   Hexdigcnt         ;
9734    EFFB  F0 0A                       beq   Asm_op01          ; no address change
9735    EFFD  A6 3C                       LDX   Hexdigits         ;
9736    EFFF  A5 3D                       LDA   Hexdigits+1       ;
9737    F001  86 3A                       STX   Addrptr           ;
9738    F003  85 3B                       STA   Addrptr+1         ;
9739    F005  88                          dey                     ;
9740    F006  C8           Asm_stripSP    iny                     ;
9741    F007  B9 00 03     Asm_op01       lda   Buffer,y          ;
9742    F00A  C9 20                       cmp   #$20              ; strip spaces
9743    F00C  F0 F8                       beq   Asm_stripSP       ;
9744    F00E  C9 0D                       cmp   #$0d              ; done
9745    F010  F0 E5                       beq   Asm_hop           ;
9746    F012  C9 3B                       cmp   #$3b              ; ";" comment char done
9747    F014  F0 E1                       beq   Asm_hop           ;
9748    F016  A2 00                       ldx   #$00              ;
9749    F018  86 36                       stx   OPCtxtptr         ;
9750    F01A  84 33                       sty   Linecnt           ;
9751    F01C  A4 33        Asm_opclp      ldy   Linecnt           ;
9752    F01E  A5 36                       lda   OPCtxtptr         ;
9753    F020  0A                          ASL                     ;
9754    F021  65 36                       adc   OPCtxtptr         ;
9755    F023  AA                          tax                     ;
9756    F024  B9 00 03                    lda   Buffer,y          ;
9757    F027  C8                          iny                     ;
9758    F028  DD 46 F5                    cmp   OPCTxtData,x      ;
9759    F02B  D0 14                       bne   Asm_getnext       ;
9760    F02D  B9 00 03                    lda   Buffer,y          ;
9761    F030  E8                          inx                     ;
9762    F031  C8                          iny                     ;
9763    F032  DD 46 F5                    cmp   OPCTxtData,x      ;
9764    F035  D0 0A                       bne   Asm_getnext       ;
9765    F037  B9 00 03                    lda   Buffer,y          ;
9766    F03A  E8                          inx                     ;
9767    F03B  C8                          iny                     ;
9768    F03C  DD 46 F5                    cmp   OPCTxtData,x      ;
9769    F03F  F0 0C                       beq   Asm_goodop        ;
9770    F041  A6 36        Asm_getnext    ldx   OPCtxtptr         ;
9771    F043  E8                          inx                     ;
9772    F044  86 36                       stx   OPCtxtptr         ;
9773    F046  E0 4A                       cpx   #$4A              ; last one? then err
9774    F048  D0 D2                       bne   Asm_opclp
9775    F04A  4C DE EF     Asm_err2       jmp   Asm_err
9776    F04D  A9 00        Asm_goodop     lda   #$00
9777    F04F  85 34                       sta   Modejmp           ; 
9778    F051  C6 34                       dec   Modejmp           ; init to FF for () check
9779    F053  85 3C                       sta   Hexdigits         ; and Byte holder
9780    F055  85 3D                       sta   Hexdigits+1       ; 
9781    F057  85 35                       sta   Hexdigcnt         ;
9782    F059  A6 36                       ldx   OPCtxtptr         ;
9783    F05B  E0 42                       cpx   #$42              ; 
9784    F05D  30 18                       bmi   Asm_goodSP        ; not a 4 chr opcode
9785    F05F  E0 46                       cpx   #$46              
9786    F061  10 14                       bpl   Asm_goodSP        ; not a 4 chr opcode
9787    F063  B9 00 03                    lda   Buffer,y          ; get next chr
9788    F066  C8                          iny                     ; advance pointer
9789    F067  C9 38                       cmp   #$38              ; 
9790    F069  10 DF                       bpl   Asm_err2          ; not chr "0"-"7"
9791    F06B  C9 30                       cmp   #$30
9792    F06D  30 DB                       bmi   Asm_err2          ; not chr "0"-"7"
9793    F06F  0A                          ASL
9794    F070  0A                          ASL
9795    F071  0A                          ASL
9796    F072  0A                          ASL
9797    F073  85 39                       sta   Startaddr_H       ; temp holder for 4th chr opcode
9798    F075  A9 80                       LDA   #$80              ; flag for 
9799    F077  BE 00 03     Asm_goodSP     ldx   Buffer,y          ; get next operand char
9800    F07A  C8                          iny                     ; point to next operand chr
9801    F07B  E0 20                       cpx   #$20              ;  sp
9802    F07D  D0 24                       bne   Asm_goodSP2
9803    F07F  C9 80                       cmp   #$80
9804    F081  30 F4                       bmi   Asm_goodSP
9805    F083  A6 36        Asm_goodSP1    ldx   OPCtxtptr         ; check if its a BBRx or BBSx opcode
9806    F085  E0 44                       cpx   #$44              ; 
9807    F087  10 EE                       bpl   Asm_goodSP        ;
9808    F089  A6 35                       ldx   Hexdigcnt         ;
9809    F08B  F0 EA                       beq   Asm_goodSP        ;
9810    F08D  C9 D0                       cmp   #$D0              ; already have zp & rel?
9811    F08F  10 E6                       bpl   Asm_goodSP        ; we don't care then
9812    F091  C9 C0                       cmp   #$C0              ; already got a zp address?
9813    F093  10 B5                       bpl   Asm_err2          ; then error
9814    F095  A6 3D                       ldx   Hexdigits+1
9815    F097  D0 B1                       bne   Asm_err2          ; not zero page
9816    F099  A6 3C                       ldx   Hexdigits
9817    F09B  86 38                       stx   Startaddr         ; temp zp value for BBRx & BBSx cmds 
9818    F09D  09 40                       ora   #$40              ; mark zp address fetched
9819    F09F  29 F7                       and   #$F7              ; mask out zp address found
9820    F0A1  80 D4                       bra   Asm_goodSP        ; get next chr
9821    F0A3  E0 0D        Asm_goodSP2    cpx   #$0d              ;  CR
9822    F0A5  D0 03                       bne   Asm_eol
9823    F0A7  4C 61 F1     Asm_jmp1       jmp   Asm_modesrch
9824    F0AA  E0 3B        Asm_eol        cpx   #$3b              ;  ";"
9825    F0AC  F0 F9                       beq   Asm_jmp1
9826    F0AE  48                          pha
9827    F0AF  A5 36                       lda   OPCtxtptr
9828    F0B1  C9 46                       cmp   #$46              ; normal opcode if <=45h
9829    F0B3  30 44                       bmi   Asm_opnd1
9830    F0B5  D0 19                       bne   Asm_xtra1
9831    F0B7  E0 24                       cpx   #$24              ; $ .db pseudo-opcode
9832    F0B9  F0 01                       beq   Asm_db1
9833    F0BB  88                          dey
9834    F0BC  20 4D EC     Asm_db1        jsr   ParseHexDig
9835    F0BF  FA                          plx
9836    F0C0  A6 35                       ldx   Hexdigcnt
9837    F0C2  F0 86                       beq   Asm_err2          ; no digits retrieved
9838    F0C4  A0 00                       ldy   #$00
9839    F0C6  A9 01                       lda   #$01
9840    F0C8  48                          PHA
9841    F0C9  A5 3C                       lda   Hexdigits
9842    F0CB  91 3A                       sta   (Addrptr),y
9843    F0CD  4C FC F1                    jmp   Asm_save
9844    F0D0  C9 47        Asm_xtra1      cmp   #$47              ; .dw pseudo-opcode
9845    F0D2  D0 1E                       bne   Asm_xtra2 
9846    F0D4  E0 24                       cpx   #$24              ; $
9847    F0D6  F0 01                       beq   Asm_dw1
9848    F0D8  88                          dey
9849    F0D9  20 4D EC     Asm_dw1        jsr   ParseHexDig
9850    F0DC  FA                          plx
9851    F0DD  A6 35                       ldx   Hexdigcnt
9852    F0DF  F0 7D                       beq   Asm_err1          ; no digits retrieved
9853    F0E1  A0 00                       ldy   #$00
9854    F0E3  A9 02                       lda   #$02
9855    F0E5  48                          PHA
9856    F0E6  A5 3C                       lda   Hexdigits
9857    F0E8  91 3A                       sta   (Addrptr),y
9858    F0EA  A5 3D                       lda   Hexdigits+1
9859    F0EC  C8                          iny
9860    F0ED  91 3A                       sta   (Addrptr),y
9861    F0EF  4C FC F1                    jmp   Asm_save
9862    F0F2  C9 48        Asm_xtra2      cmp   #$48              ; .ds pseudo-opcode
9863    F0F4  D0 68                       bne   Asm_err1 
9864    F0F6  4C 42 F2                    jmp   Asm_txt
9865    F0F9  68           Asm_opnd1      pla
9866    F0FA  E0 23                       cpx   #$23              ;  #    20
9867    F0FC  D0 05                       bne   Asm_parse01
9868    F0FE  09 20                       ora   #$20
9869    F100  4C 77 F0                    jmp   Asm_goodSP 
9870    F103  E0 28        Asm_parse01    cpx   #$28              ;  (   04
9871    F105  D0 0B                       bne   Asm_parse02
9872    F107  09 04                       ora   #$04
9873    F109  A6 34                       ldx   Modejmp
9874    F10B  10 51                       bpl   Asm_err1          ;  more than one ( 
9875    F10D  E6 34                       inc   Modejmp
9876    F10F  4C 77 F0                    jmp   Asm_goodSP 
9877    F112  E0 29        Asm_parse02    cpx   #$29              ;  )
9878    F114  D0 09                       bne   Asm_parse03
9879    F116  A6 34                       ldx   Modejmp
9880    F118  D0 44                       bne   Asm_err1          ;  ) without (
9881    F11A  E6 34                       inc   Modejmp
9882    F11C  4C 77 F0                    jmp   Asm_goodSP 
9883    F11F  E0 2C        Asm_parse03    cpx   #$2C              ;  ,
9884    F121  D0 1E                       bne   Asm_parse04
9885    F123  BE 00 03                    ldx   Buffer,y
9886    F126  E0 58                       cpx   #$58              ;  X        02
9887    F128  D0 06                       bne   Asm_parse31
9888    F12A  09 02                       ora   #$02
9889    F12C  C8                          iny
9890    F12D  4C 77 F0                    jmp   Asm_goodSP
9891    F130  E0 59        Asm_parse31    cpx   #$59              ;  Y        01 
9892    F132  F0 07                       beq   Asm_parse32
9893    F134  C9 80                       cmp   #$80              ;  is BBRx or BBSx cmd active?
9894    F136  30 26                       bmi   Asm_err1          ;  , without X or Y or 4byte opcode      
9895    F138  4C 83 F0                    jmp   Asm_goodSP1       ;  save zp address
9896    F13B  09 01        Asm_parse32    ora   #$01
9897    F13D  C8                          iny
9898    F13E  4C 77 F0                    jmp   Asm_goodSP 
9899    F141  E0 24        Asm_parse04    cpx   #$24              ;  $
9900    F143  F0 01                       beq   Asm_parse42       ;   
9901    F145  88                          dey                     ; not #$(),X,Y  so try Hexdig, if not err
9902    F146  48           Asm_parse42    pha
9903    F147  20 4D EC                    jsr   ParseHexDig
9904    F14A  88                          dey                     ; adjust input line pointer
9905    F14B  68                          pla
9906    F14C  A6 35                       ldx   Hexdigcnt
9907    F14E  F0 0E                       beq   Asm_err1          ; no digits retrieved
9908    F150  A6 3D                       ldx   Hexdigits+1    
9909    F152  D0 05                       bne   Asm_parse41
9910    F154  09 08                       ora   #$08              ; <256               08
9911    F156  4C 77 F0                    jmp   Asm_goodSP
9912    F159  09 10        Asm_parse41    ora   #$10              ; 2 bytes            10 
9913    F15B  4C 77 F0                    jmp   Asm_goodSP 
9914    F15E  4C DE EF     Asm_err1       jmp   Asm_err
9915    F161  A2 0F        Asm_modesrch   ldx   #$0F              ; # of modes
9916    F163  DD 36 F5     Asm_modeS1     cmp   Asm_ModeLst,x
9917    F166  F0 05                       beq   Asm_modefnd 
9918    F168  CA                          dex   
9919    F169  10 F8                       bpl   Asm_modeS1
9920    F16B  80 F1                       bra   Asm_err1          ; invalid Mode
9921    F16D  86 37        Asm_modefnd    stx   Memchr            ; save mode
9922    F16F  C9 80                       cmp   #$80              ; is it 4 chr opcode?
9923    F171  30 05                       bmi   Asm_opcsrch       ;no
9924    F173  8A                          txa
9925    F174  05 39                       ora   Startaddr_H       ; adjust the psuedo mode               
9926    F176  85 37                       sta   Memchr            ; set proper mode
9927    F178  A2 00        Asm_opcsrch    ldx   #$00
9928    F17A  BD 06 F3     Asm_opcsrch1   lda   OPCtxtidx,x
9929    F17D  C5 36                       cmp   OPCtxtptr
9930    F17F  D0 07                       bne   Asm_srchNxt   
9931    F181  BD 06 F4                    lda   OPCaddmode,x
9932    F184  C5 37                       cmp   Memchr
9933    F186  F0 2D                       beq   Asm_OpcFnd
9934    F188  E8           Asm_srchNxt    inx
9935    F189  D0 EF                       bne   Asm_opcsrch1 
9936    F18B  A5 37                       lda   Memchr            ;
9937    F18D  C9 02                       cmp   #$02              ; ZP
9938    F18F  D0 06                       bne   Asm_srchAlt 
9939    F191  A9 01                       LDA   #$01              ; ABS
9940    F193  85 37                       sta   Memchr
9941    F195  80 E1                       bra   Asm_opcsrch
9942    F197  C9 01        Asm_srchAlt    cmp   #$01              ; ABS
9943    F199  D0 06                       bne   Asm_srchA0
9944    F19B  A9 0A                       LDA   #$0A              ; REL
9945    F19D  85 37                       sta   Memchr
9946    F19F  80 D7                       bra   Asm_opcsrch
9947    F1A1  C9 0D        Asm_srchA0     cmp   #$0d              ;  ind zp
9948    F1A3  D0 06                       bne   Asm_srchA1
9949    F1A5  A9 0B                       LDA   #$0b              ; ind Abs
9950    F1A7  85 37                       sta   Memchr
9951    F1A9  80 CD                       bra   Asm_opcsrch
9952    F1AB  C9 07        Asm_srchA1     cmp   #$07              ; zp,y
9953    F1AD  D0 AF                       bne   Asm_err1          ; no more modes to try, bad mode err
9954    F1AF  A9 09                       LDA   #$09              ; ABS,y
9955    F1B1  85 37                       sta   Memchr
9956    F1B3  80 C3                       bra   Asm_opcsrch
9957    F1B5  A5 37        Asm_OpcFnd     lda   Memchr
9958    F1B7  29 0F                       and   #$0F              ; mask out psuedo modes
9959    F1B9  85 37                       sta   Memchr            ;
9960    F1BB  C9 0E                       CMP   #$0E              ; BBR mode?
9961    F1BD  D0 0B                       bne   Asm_OpcFnd0       ;
9962    F1BF  20 09 F2                    jsr   Asm_BRelCalc      ;
9963    F1C2  85 3D                       sta   Hexdigits_H       ;
9964    F1C4  A5 38                       lda   Startaddr         ;
9965    F1C6  85 3C                       sta   Hexdigits         ;
9966    F1C8  80 07                       bra   Asm_OpcFnd1       ;   
9967    F1CA  C9 0A        Asm_OpcFnd0    cmp   #$0A              ; is Rel Mode?
9968    F1CC  D0 03                       bne   Asm_OpcFnd1 
9969    F1CE  20 21 F2                    jsr   Asm_RelCalc       ; adjust rel address
9970    F1D1  A0 00        Asm_OpcFnd1    ldy   #$00
9971    F1D3  8A                          txa
9972    F1D4  91 3A                       sta   (Addrptr),y
9973    F1D6  C8                          iny
9974    F1D7  A6 37                       ldx   Memchr            ; 
9975    F1D9  BD 06 F5                    lda   ModeByteCnt,x
9976    F1DC  48                          PHA                     ; Save # of bytes
9977    F1DD  C9 01                       cmp   #$01
9978    F1DF  F0 10                       beq   Asm_echoL
9979    F1E1  A5 3C                       lda   Hexdigits
9980    F1E3  91 3A                       sta   (Addrptr),y
9981    F1E5  C8                          iny
9982    F1E6  BD 06 F5                    lda   ModeByteCnt,x
9983    F1E9  C9 02                       cmp   #$02
9984    F1EB  F0 04                       beq   Asm_echoL
9985    F1ED  A5 3D                       lda   Hexdigits+1
9986    F1EF  91 3A                       sta   (Addrptr),y
9987    F1F1  A5 3A        Asm_echoL      lda   Addrptr
9988    F1F3  85 38                       sta   Startaddr
9989    F1F5  A5 3B                       lda   Addrptr+1
9990    F1F7  85 39                       sta   Startaddr+1
9991    F1F9  20 28 EE                    jsr   List_one
9992    F1FC  18           Asm_save       clc
9993    F1FD  68                          PLA
9994    F1FE  65 3A                       adc   Addrptr
9995    F200  85 3A                       sta   Addrptr
9996    F202  90 02                       bcc   Asm_done
9997    F204  E6 3B                       inc   Addrptr+1
9998    F206  4C A2 EF     Asm_done       jmp   Assembler
9999    F209  20 10 F2     Asm_BRelCalc   jsr   Asm_RelSub
10000    F20C  E9 03                       sbc   #$03
10001    F20E  80 16                       bra   Asm_Relc1
10002    F210  38           Asm_RelSub     sec
10003    F211  A5 3C                       lda   Hexdigits
10004    F213  E5 3A                       sbc   Addrptr
10005    F215  85 3E                       sta   Memptr
10006    F217  A5 3D                       lda   Hexdigits+1
10007    F219  E5 3B                       sbc   Addrptr+1
10008    F21B  85 3F                       sta   Memptr+1
10009    F21D  38                          sec
10010    F21E  A5 3E                       lda   Memptr
10011    F220  60                          rts 
10012    F221  20 10 F2     Asm_RelCalc    jsr   Asm_RelSub
10013    F224  E9 02                       sbc   #$02
10014    F226  85 3E        Asm_Relc1      sta   Memptr
10015    F228  B0 02                       bcs   Asm_relC2
10016    F22A  C6 3F                       dec   Memptr+1
10017    F22C  A5 3F        Asm_relC2      lda   Memptr+1               
10018    F22E  F0 0B                       beq   Asm_relC4         ; positive
10019    F230  C9 FF                       cmp   #$FF              ; negative
10020    F232  D0 0B                       bne   Asm_txtErr
10021    F234  A5 3E                       lda   Memptr
10022    F236  10 07                       bpl   Asm_txtErr
10023    F238  85 3C        Asm_relC3      sta   Hexdigits
10024    F23A  60                          rts
10025    F23B  A5 3E        Asm_relC4      lda   Memptr
10026    F23D  10 F9                       bpl   Asm_relC3
10027    F23F  4C DE EF     Asm_txtErr     jmp   Asm_err
10028    F242  FA           Asm_txt        plx                     ; process the .ds pseudo-opcode
10029    F243  88                          dey
10030    F244  98                          tya
10031    F245  AA                          tax
10032    F246  A0 FE                       ldy   #$fe
10033    F248  C8           Asm_txt1       iny
10034    F249  BD 00 03     Asm_txt2       lda   Buffer,x          ; get next operand char
10035    F24C  E8                          inx                     ; point to next operand chr
10036    F24D  C9 0D                       cmp   #$0d              ;  CR
10037    F24F  F0 1A                       beq   Asm_txt9
10038    F251  C9 27                       cmp   #$27              ; "
10039    F253  D0 06                       bne   Asm_txt3
10040    F255  C0 FF                       cpy   #$ff              ; opening " found?
10041    F257  D0 12                       bne   Asm_txt9          ; no, closing, so done
10042    F259  80 ED                       bra   Asm_txt1          ; yes, get first text chr
10043    F25B  C0 FF        Asm_txt3       cpy   #$ff              ; already found opening "?
10044    F25D  F0 04                       beq   Asm_txt4          ; 
10045    F25F  91 3A                       sta   (Addrptr),y       ; yes, save chr
10046    F261  80 E5                       bra   Asm_txt1
10047    F263  C9 20        Asm_txt4       cmp   #$20              ; no, if not a space, then err
10048    F265  F0 E2                       beq   Asm_txt2
10049    F267  8A                          txa
10050    F268  A8                          tay
10051    F269  80 D4                       bra   Asm_txtErr
10052    F26B  98           Asm_txt9       tya
10053    F26C  48                          pha
10054    F26D  4C FC F1                    jmp   Asm_save
10055    ;
10056    F270  A0 49        Opcode_List    ldy   #$49              ; Number of Opcodes (64)
10057    F272  A2 00                       ldx   #$00              ; pointer to characters
10058    F274  8A           Opcode_List1   txa                     ; 
10059    F275  29 0F                       and   #$0F              ; Print CR after each 16 opcodes 
10060    F277  D0 03                       bne   Opcode_List2      ; not divisible by 16
10061    F279  20 69 EB                    jsr   Print_CR          ;
10062    F27C  BD 46 F5     Opcode_List2   lda   OPCTxtData,x      ; get opcode chr data
10063    F27F  20 EC EA                    jsr   Output            ; print 1st char
10064    F282  E8                          inx                     ;
10065    F283  BD 46 F5                    lda   OPCTxtData,x      ; 
10066    F286  20 EC EA                    jsr   Output            ; print 2nd char
10067    F289  E8                          inx                     ;
10068    F28A  BD 46 F5                    lda   OPCTxtData,x      ;
10069    F28D  20 EC EA                    jsr   Output            ; print 3rd char
10070    F290  E8                          inx                     ;
10071    F291  C0 08                       cpy   #$08              ; 
10072    F293  10 09                       bpl   Opcode_List3      ; not 4 byte code
10073    F295  C0 04                       cpy   #$04              ;
10074    F297  30 05                       bmi   Opcode_List3      ;
10075    F299  A9 78                       lda   #$78              ; add 'x'
10076    F29B  20 EC EA                    jsr   Output            ; for RMBx, SMBx,BBRx, & BBSx
10077    F29E  A9 20        Opcode_List3   lda   #$20              ; print space
10078    F2A0  20 EC EA                    jsr   Output            ;
10079    F2A3  88                          dey                     ;
10080    F2A4  D0 CE                       bne   Opcode_List1      ; 
10081    F2A6  20 69 EB                    jsr   Print_CR          ; one last CR-LF
10082    F2A9  60                          rts                     ;
10083    ;
10084    ;-----------DATA TABLES ------------------------------------------------
10085    ;
10086    Hexdigdata     .byte "0123456789ABCDEF";hex char table 
10087    ;     
10088      0012             CmdCount       =$12                    ; number of commands to scan for
10089    CmdAscii       .byte $0D               ; 0 enter    cmd codes
10090                   .byte $20               ; 1 SPACE
10091                   .byte $2E               ; 2 .
10092                   .byte $3A               ; 3 :
10093                   .byte $3E               ; 4 >  
10094                   .byte $3f               ; 5 ? - Help
10095                   .byte $21               ; 6 ! - Assembler
10096                   .byte $47               ; 7 g - Go
10097                   .byte $49               ; 8 i - Insert
10098                   .byte $4C               ; 9 l - List
10099                   .byte $4D               ; A m - Move
10100                   .byte $50               ; B p - Power off
10101                   .byte $51               ; C q - Query memory (text dump)
10102                   .byte $53               ; D s - Set LED text display
10103                   .byte $40               ; E @ - Cold Start Basic
10104                   .byte $23               ; F # - Warm Start Basic
10105                   .byte $55	       ;10 U - Uploader
10106                   .byte $56               ;11 v - Version
10107                   .byte $58               ;12 x - xmodemSend 
10108    
10109    ;     
10110    Cmdjmptbl      .word CR_cmd            ; 0  enter   cmd jmp table
10111                   .word SP_cmd            ; 1   space
10112                   .word DOT_cmd           ; 2    .
10113                   .word DOT_cmd           ; 3    :
10114                   .word Dest_cmd          ; 4    >  
10115                   .word Help_cmd          ; 5    ?
10116                   .word Assem_Init        ; 6    !
10117                   .word Excute_cmd        ; 7    g
10118                   .word Insert_cmd        ; 8    i
10119                   .word LIST_cmd          ; 9    l
10120                   .word Move_cmd          ; A    m
10121                   .word Power_cmd         ; B    p
10122                   .word TXT_cmd           ; C    q
10123                   .word SLED_cmd          ; D    s 
10124                   .word LAB_COLD          ; E    @
10125                   .word LAB_WARM          ; F    #
10126                   .WORD XModemRcv         ;10    u
10127                   .word Version           ;11    v
10128                   .word XModemSend        ;12    x    
10129    
10130    ;     
10131    Cmdseccode     .byte $00               ; 0   enter       secondary command table
10132                   .byte $FF               ; 1   sp
10133                   .byte $01               ; 2   .
10134                   .byte $02               ; 3   :
10135                   .byte $00               ; 4   > 
10136                   .byte $00               ; 5   ?
10137                   .byte $00               ; 6   !
10138                   .byte $00               ; 7   g
10139                   .byte $00               ; 8   i
10140                   .byte $00               ; 9   l
10141                   .byte $00               ; A   m
10142                   .byte $00               ; B   p
10143                   .byte $00               ; C   q
10144                   .byte $00               ; D   s
10145                   .byte $00               ; E   @
10146                   .byte $00               ; F   #
10147                   .byte $00               ;10   u
10148                   .byte $00               ;11   v
10149                   .byte $00               ;12   x
10150    
10151    ;
10152    ;     
10153    OPCtxtidx      .byte $0B               ;0   operand text index
10154                   .byte $23               ;1
10155                   .byte $49               ;2
10156                   .byte $49               ;3
10157                   .byte $3B               ;4
10158                   .byte $23               ;5
10159                   .byte $02               ;6
10160                   .byte $44               ;7
10161                   .byte $25               ;8
10162                   .byte $23               ;9
10163                   .byte $02               ;A
10164                   .byte $49               ;B
10165                   .byte $3B               ;C
10166                   .byte $23               ;D
10167                   .byte $02               ;E
10168                   .byte $42               ;F
10169                   .byte $09               ;10
10170                   .byte $23               ;11
10171                   .byte $23               ;12
10172                   .byte $49               ;13
10173                   .byte $3A               ;14
10174                   .byte $23               ;15
10175                   .byte $02               ;16
10176                   .byte $44               ;17
10177                   .byte $0E               ;18
10178                   .byte $23               ;19
10179                   .byte $19               ;1A
10180                   .byte $49               ;1B
10181                   .byte $3A               ;1C
10182                   .byte $23               ;1D
10183                   .byte $02               ;1E
10184                   .byte $42               ;1F
10185                   .byte $1D               ;20
10186                   .byte $01               ;21
10187                   .byte $49               ;22
10188                   .byte $49               ;23
10189                   .byte $06               ;24
10190                   .byte $01               ;25
10191                   .byte $2C               ;26
10192                   .byte $44               ;27
10193                   .byte $29               ;28
10194                   .byte $01               ;29
10195                   .byte $2C               ;2A
10196                   .byte $49               ;2B
10197                   .byte $06               ;2C
10198                   .byte $01               ;2D
10199                   .byte $2C               ;2E
10200                   .byte $42               ;2F
10201                   .byte $07               ;30
10202                   .byte $01               ;31
10203                   .byte $01               ;32
10204                   .byte $49               ;33
10205                   .byte $06               ;34
10206                   .byte $01               ;35
10207                   .byte $2C               ;36
10208                   .byte $44               ;37
10209                   .byte $31               ;38
10210                   .byte $01               ;39
10211                   .byte $15               ;3A
10212                   .byte $49               ;3B
10213                   .byte $06               ;3C
10214                   .byte $01               ;3D
10215                   .byte $2C               ;3E
10216                   .byte $42               ;3F
10217                   .byte $2E               ;40
10218                   .byte $18               ;41
10219                   .byte $49               ;42
10220                   .byte $49               ;43
10221                   .byte $49               ;44
10222                   .byte $18               ;45
10223                   .byte $21               ;46
10224                   .byte $44               ;47
10225                   .byte $24               ;48
10226                   .byte $18               ;49
10227                   .byte $21               ;4A
10228                   .byte $49               ;4B
10229                   .byte $1C               ;4C
10230                   .byte $18               ;4D
10231                   .byte $21               ;4E
10232                   .byte $42               ;4F
10233                   .byte $0C               ;50
10234                   .byte $18               ;51
10235                   .byte $18               ;52
10236                   .byte $49               ;53
10237                   .byte $49               ;54
10238                   .byte $18               ;55
10239                   .byte $21               ;56
10240                   .byte $44               ;57
10241                   .byte $10               ;58
10242                   .byte $18               ;59
10243                   .byte $27               ;5A
10244                   .byte $49               ;5B
10245                   .byte $49               ;5C
10246                   .byte $18               ;5D
10247                   .byte $21               ;5E
10248                   .byte $42               ;5F
10249                   .byte $2F               ;60
10250                   .byte $00               ;61
10251                   .byte $49               ;62
10252                   .byte $49               ;63
10253                   .byte $37               ;64
10254                   .byte $00               ;65
10255                   .byte $2D               ;66
10256                   .byte $44               ;67
10257                   .byte $28               ;68
10258                   .byte $00               ;69
10259                   .byte $2D               ;6A
10260                   .byte $49               ;6B
10261                   .byte $1C               ;6C
10262                   .byte $00               ;6D
10263                   .byte $2D               ;6E
10264                   .byte $42               ;6F
10265                   .byte $0D               ;70
10266                   .byte $00               ;71
10267                   .byte $00               ;72
10268                   .byte $49               ;73
10269                   .byte $37               ;74
10270                   .byte $00               ;75
10271                   .byte $2D               ;76
10272                   .byte $44               ;77
10273                   .byte $33               ;78
10274                   .byte $00               ;79
10275                   .byte $2B               ;7A
10276                   .byte $49               ;7B
10277                   .byte $1C               ;7C
10278                   .byte $00               ;7D
10279                   .byte $2D               ;7E
10280                   .byte $42               ;7F
10281                   .byte $0A               ;80
10282                   .byte $34               ;81
10283                   .byte $49               ;82
10284                   .byte $49               ;83
10285                   .byte $36               ;84
10286                   .byte $34               ;85
10287                   .byte $35               ;86
10288                   .byte $45               ;87
10289                   .byte $17               ;88
10290                   .byte $06               ;89
10291                   .byte $3D               ;8A
10292                   .byte $49               ;8B
10293                   .byte $36               ;8C
10294                   .byte $34               ;8D
10295                   .byte $35               ;8E
10296                   .byte $43               ;8F
10297                   .byte $03               ;90
10298                   .byte $34               ;91
10299                   .byte $34               ;92
10300                   .byte $49               ;93
10301                   .byte $36               ;94
10302                   .byte $34               ;95
10303                   .byte $35               ;96
10304                   .byte $45               ;97
10305                   .byte $3F               ;98
10306                   .byte $34               ;99
10307                   .byte $3E               ;9A
10308                   .byte $49               ;9B
10309                   .byte $37               ;9C
10310                   .byte $34               ;9D
10311                   .byte $37               ;9E
10312                   .byte $43               ;9F
10313                   .byte $20               ;A0
10314                   .byte $1E               ;A1
10315                   .byte $1F               ;A2
10316                   .byte $49               ;A3
10317                   .byte $20               ;A4
10318                   .byte $1E               ;A5
10319                   .byte $1F               ;A6
10320                   .byte $45               ;A7
10321                   .byte $39               ;A8
10322                   .byte $1E               ;A9
10323                   .byte $38               ;AA
10324                   .byte $49               ;AB
10325                   .byte $20               ;AC
10326                   .byte $1E               ;AD
10327                   .byte $1F               ;AE
10328                   .byte $43               ;AF
10329                   .byte $04               ;B0
10330                   .byte $1E               ;B1
10331                   .byte $1E               ;B2
10332                   .byte $49               ;B3
10333                   .byte $20               ;B4
10334                   .byte $1E               ;B5
10335                   .byte $1F               ;B6
10336                   .byte $45               ;B7
10337                   .byte $11               ;B8
10338                   .byte $1E               ;B9
10339                   .byte $3C               ;BA
10340                   .byte $49               ;BB
10341                   .byte $20               ;BC
10342                   .byte $1E               ;BD
10343                   .byte $1F               ;BE
10344                   .byte $43               ;BF
10345                   .byte $14               ;C0
10346                   .byte $12               ;C1
10347                   .byte $49               ;C2
10348                   .byte $49               ;C3
10349                   .byte $14               ;C4
10350                   .byte $12               ;C5
10351                   .byte $15               ;C6
10352                   .byte $45               ;C7
10353                   .byte $1B               ;C8
10354                   .byte $12               ;C9
10355                   .byte $16               ;CA
10356                   .byte $40               ;CB
10357                   .byte $14               ;CC
10358                   .byte $12               ;CD
10359                   .byte $15               ;CE
10360                   .byte $43               ;CF
10361                   .byte $08               ;D0
10362                   .byte $12               ;D1
10363                   .byte $12               ;D2
10364                   .byte $49               ;D3
10365                   .byte $49               ;D4
10366                   .byte $12               ;D5
10367                   .byte $15               ;D6
10368                   .byte $45               ;D7
10369                   .byte $0F               ;D8
10370                   .byte $12               ;D9
10371                   .byte $26               ;DA
10372                   .byte $41               ;DB
10373                   .byte $49               ;DC
10374                   .byte $12               ;DD
10375                   .byte $15               ;DE
10376                   .byte $43               ;DF
10377                   .byte $13               ;E0
10378                   .byte $30               ;E1
10379                   .byte $49               ;E2
10380                   .byte $49               ;E3
10381                   .byte $13               ;E4
10382                   .byte $30               ;E5
10383                   .byte $19               ;E6
10384                   .byte $45               ;E7
10385                   .byte $1A               ;E8
10386                   .byte $30               ;E9
10387                   .byte $22               ;EA
10388                   .byte $49               ;EB
10389                   .byte $13               ;EC
10390                   .byte $30               ;ED
10391                   .byte $19               ;EE
10392                   .byte $43               ;EF
10393                   .byte $05               ;F0
10394                   .byte $30               ;F1
10395                   .byte $30               ;F2
10396                   .byte $49               ;F3
10397                   .byte $49               ;F4
10398                   .byte $30               ;F5
10399                   .byte $19               ;F6
10400                   .byte $45               ;F7
10401                   .byte $32               ;F8
10402                   .byte $30               ;F9
10403                   .byte $2A               ;FA
10404                   .byte $49               ;FB
10405                   .byte $49               ;FC
10406                   .byte $30               ;FD
10407                   .byte $19               ;FE
10408                   .byte $43               ;FF
10409    ;     
10410    OPCaddmode     .byte $03               ;0   opcode address mode
10411                   .byte $04               ;1
10412                   .byte $03               ;2
10413                   .byte $03               ;3
10414                   .byte $02               ;4
10415                   .byte $02               ;5
10416                   .byte $02               ;6
10417                   .byte $0F               ;7
10418                   .byte $03               ;8
10419                   .byte $00               ;9
10420                   .byte $03               ;A
10421                   .byte $03               ;B
10422                   .byte $01               ;C
10423                   .byte $01               ;D
10424                   .byte $01               ;E
10425                   .byte $0E               ;F
10426                   .byte $0A               ;10
10427                   .byte $05               ;11
10428                   .byte $0D               ;12
10429                   .byte $03               ;13
10430                   .byte $02               ;14
10431                   .byte $06               ;15
10432                   .byte $06               ;16
10433                   .byte $1F               ;17
10434                   .byte $03               ;18
10435                   .byte $09               ;19
10436                   .byte $03               ;1A
10437                   .byte $03               ;1B
10438                   .byte $01               ;1C
10439                   .byte $08               ;1D
10440                   .byte $08               ;1E
10441                   .byte $1E               ;1F
10442                   .byte $01               ;20
10443                   .byte $04               ;21
10444                   .byte $03               ;22
10445                   .byte $03               ;23
10446                   .byte $02               ;24
10447                   .byte $02               ;25
10448                   .byte $02               ;26
10449                   .byte $2F               ;27
10450                   .byte $03               ;28
10451                   .byte $00               ;29
10452                   .byte $03               ;2A
10453                   .byte $03               ;2B
10454                   .byte $01               ;2C
10455                   .byte $01               ;2D
10456                   .byte $01               ;2E
10457                   .byte $2E               ;2F
10458                   .byte $0A               ;30
10459                   .byte $05               ;31
10460                   .byte $0D               ;32
10461                   .byte $03               ;33
10462                   .byte $06               ;34
10463                   .byte $06               ;35
10464                   .byte $06               ;36
10465                   .byte $3F               ;37
10466                   .byte $03               ;38
10467                   .byte $09               ;39
10468                   .byte $03               ;3A
10469                   .byte $03               ;3B
10470                   .byte $08               ;3C
10471                   .byte $08               ;3D
10472                   .byte $08               ;3E
10473                   .byte $3E               ;3F
10474                   .byte $03               ;40
10475                   .byte $04               ;41
10476                   .byte $03               ;42
10477                   .byte $03               ;43
10478                   .byte $03               ;44
10479                   .byte $02               ;45
10480                   .byte $02               ;46
10481                   .byte $4F               ;47
10482                   .byte $03               ;48
10483                   .byte $00               ;49
10484                   .byte $03               ;4A
10485                   .byte $03               ;4B
10486                   .byte $01               ;4C
10487                   .byte $01               ;4D
10488                   .byte $01               ;4E
10489                   .byte $4E               ;4F
10490                   .byte $0A               ;50
10491                   .byte $05               ;51
10492                   .byte $0D               ;52
10493                   .byte $03               ;53
10494                   .byte $03               ;54
10495                   .byte $06               ;55
10496                   .byte $06               ;56
10497                   .byte $5F               ;57
10498                   .byte $03               ;58
10499                   .byte $09               ;59
10500                   .byte $03               ;5A
10501                   .byte $03               ;5B
10502                   .byte $03               ;5C
10503                   .byte $08               ;5D
10504                   .byte $08               ;5E
10505                   .byte $5E               ;5F
10506                   .byte $03               ;60
10507                   .byte $04               ;61
10508                   .byte $03               ;62
10509                   .byte $03               ;63
10510                   .byte $02               ;64
10511                   .byte $02               ;65
10512                   .byte $02               ;66
10513                   .byte $6F               ;67
10514                   .byte $03               ;68
10515                   .byte $00               ;69
10516                   .byte $03               ;6A
10517                   .byte $03               ;6B
10518                   .byte $0B               ;6C
10519                   .byte $01               ;6D
10520                   .byte $01               ;6E
10521                   .byte $6E               ;6F
10522                   .byte $0A               ;70
10523                   .byte $05               ;71
10524                   .byte $0D               ;72
10525                   .byte $03               ;73
10526                   .byte $06               ;74
10527                   .byte $06               ;75
10528                   .byte $06               ;76
10529                   .byte $7F               ;77
10530                   .byte $03               ;78
10531                   .byte $09               ;79
10532                   .byte $03               ;7A
10533                   .byte $03               ;7B
10534                   .byte $0C               ;7C
10535                   .byte $08               ;7D
10536                   .byte $08               ;7E
10537                   .byte $7E               ;7F
10538                   .byte $0A               ;80
10539                   .byte $04               ;81
10540                   .byte $03               ;82
10541                   .byte $03               ;83
10542                   .byte $02               ;84
10543                   .byte $02               ;85
10544                   .byte $02               ;86
10545                   .byte $0F               ;87
10546                   .byte $03               ;88
10547                   .byte $00               ;89
10548                   .byte $03               ;8A
10549                   .byte $03               ;8B
10550                   .byte $01               ;8C
10551                   .byte $01               ;8D
10552                   .byte $01               ;8E
10553                   .byte $0E               ;8F
10554                   .byte $0A               ;90
10555                   .byte $05               ;91
10556                   .byte $0D               ;92
10557                   .byte $03               ;93
10558                   .byte $06               ;94
10559                   .byte $06               ;95
10560                   .byte $07               ;96
10561                   .byte $1F               ;97
10562                   .byte $03               ;98
10563                   .byte $09               ;99
10564                   .byte $03               ;9A
10565                   .byte $03               ;9B
10566                   .byte $01               ;9C
10567                   .byte $08               ;9D
10568                   .byte $08               ;9E
10569                   .byte $1E               ;9F
10570                   .byte $00               ;A0
10571                   .byte $04               ;A1    changed from 0d to 04
10572                   .byte $00               ;A2
10573                   .byte $03               ;A3
10574                   .byte $02               ;A4
10575                   .byte $02               ;A5
10576                   .byte $02               ;A6
10577                   .byte $2F               ;A7
10578                   .byte $03               ;A8
10579                   .byte $00               ;A9
10580                   .byte $03               ;AA
10581                   .byte $03               ;AB
10582                   .byte $01               ;AC
10583                   .byte $01               ;AD
10584                   .byte $01               ;AE
10585                   .byte $2E               ;AF
10586                   .byte $0A               ;B0
10587                   .byte $05               ;B1
10588                   .byte $0D               ;B2     
10589                   .byte $03               ;B3
10590                   .byte $06               ;B4
10591                   .byte $06               ;B5
10592                   .byte $07               ;B6
10593                   .byte $3F               ;B7
10594                   .byte $03               ;B8
10595                   .byte $09               ;B9
10596                   .byte $03               ;BA
10597                   .byte $03               ;BB
10598                   .byte $08               ;BC
10599                   .byte $08               ;BD
10600                   .byte $09               ;BE
10601                   .byte $3E               ;BF
10602                   .byte $00               ;C0
10603                   .byte $04               ;C1
10604                   .byte $03               ;C2
10605                   .byte $03               ;C3
10606                   .byte $02               ;C4
10607                   .byte $02               ;C5
10608                   .byte $02               ;C6
10609                   .byte $4F               ;C7
10610                   .byte $03               ;C8
10611                   .byte $00               ;C9
10612                   .byte $03               ;CA
10613                   .byte $03               ;CB
10614                   .byte $01               ;CC
10615                   .byte $01               ;CD
10616                   .byte $01               ;CE
10617                   .byte $4E               ;CF
10618                   .byte $0A               ;D0
10619                   .byte $05               ;D1
10620                   .byte $0D               ;D2
10621                   .byte $03               ;D3
10622                   .byte $03               ;D4
10623                   .byte $06               ;D5
10624                   .byte $06               ;D6
10625                   .byte $5F               ;D7
10626                   .byte $03               ;D8
10627                   .byte $09               ;D9
10628                   .byte $03               ;DA
10629                   .byte $03               ;DB
10630                   .byte $03               ;DC
10631                   .byte $08               ;DD
10632                   .byte $08               ;DE
10633                   .byte $5E               ;DF
10634                   .byte $00               ;E0
10635                   .byte $04               ;E1
10636                   .byte $03               ;E2
10637                   .byte $03               ;E3
10638                   .byte $02               ;E4
10639                   .byte $02               ;E5
10640                   .byte $02               ;E6
10641                   .byte $6F               ;E7
10642                   .byte $03               ;E8
10643                   .byte $00               ;E9
10644                   .byte $03               ;EA
10645                   .byte $03               ;EB
10646                   .byte $01               ;EC
10647                   .byte $01               ;ED
10648                   .byte $01               ;EE
10649                   .byte $6E               ;EF
10650                   .byte $0A               ;F0
10651                   .byte $05               ;F1
10652                   .byte $0D               ;F2
10653                   .byte $03               ;F3
10654                   .byte $03               ;F4
10655                   .byte $06               ;F5
10656                   .byte $06               ;F6
10657                   .byte $7F               ;F7
10658                   .byte $03               ;F8
10659                   .byte $09               ;F9
10660                   .byte $03               ;FA
10661                   .byte $03               ;FB
10662                   .byte $03               ;FC
10663                   .byte $08               ;FD
10664                   .byte $08               ;FE
10665                   .byte $7E               ;FF
10666    ;     
10667    ;
10668    ModeByteCnt    .byte $02               ;0  opcode mode byte count
10669                   .byte $03               ;1
10670                   .byte $02               ;2
10671                   .byte $01               ;3
10672                   .byte $02               ;4
10673                   .byte $02               ;5
10674                   .byte $02               ;6
10675                   .byte $02               ;7
10676                   .byte $03               ;8
10677                   .byte $03               ;9
10678                   .byte $02               ;A
10679                   .byte $03               ;B
10680                   .byte $03               ;C
10681                   .byte $02               ;D
10682                   .byte $03               ;E
10683                   .byte $02               ;F 
10684    ;     
10685    ;
10686    ModeJmpTbl     .word IMM_mode          ;0  Operand print table
10687                   .word ABS_mode          ;1
10688                   .word ZP_mode           ;2
10689                   .word IMPLIED_mode      ;3
10690                   .word INDZP_X_mode      ;4
10691                   .word INDZP_Y_mode      ;5
10692                   .word ZP_X_mode         ;6
10693                   .word ZP_Y_mode         ;7
10694                   .word ABS_X_mode        ;8
10695                   .word ABS_Y_mode        ;9
10696                   .word REL_mode          ;a
10697                   .word INDABS_mode       ;b
10698                   .word INDABSX_mode      ;c
10699                   .word INDZP_mode        ;d
10700    		   .word BBREL_mode        ;e
10701                   .word ZP_mode           ;f  dup of ZP for RMB,SMB cmds
10702    ;
10703    ;
10704    Asm_ModeLst    .byte $28               ;0 IMM_mode
10705                   .byte $10               ;1 ABS_mode
10706                   .byte $08               ;2 ZP_mode
10707                   .byte $00               ;3 IMPLIED_mode
10708                   .byte $0E               ;4 INDZP_X_mode
10709                   .byte $0D               ;5 INDZP_Y_mode
10710                   .byte $0A               ;6 ZP_X_mode
10711                   .byte $09               ;7 ZP_Y_mode
10712                   .byte $12               ;8 ABS_X_mode
10713                   .byte $11               ;9 ABS_Y_mode
10714                   .byte $40               ;A REL_mode   Never set!!!
10715                   .byte $14               ;B INDABS_mode
10716                   .byte $16               ;C INDABSX_mode
10717                   .byte $0C               ;D INDZP_mode
10718                   .byte $D0               ;E BBREL_mode
10719                   .byte $88               ;F used for RMBx & SMBx 
10720    ;
10721    ;              
10722    OPCTxtData     .byte "ADC"             ;0
10723                   .byte "AND"             ;1
10724                   .byte "ASL"             ;2
10725                   .byte "BCC"             ;3
10726                   .byte "BCS"             ;4
10727                   .byte "BEQ"             ;5
10728                   .byte "BIT"             ;6
10729                   .byte "BMI"             ;7
10730                   .byte "BNE"             ;8
10731                   .byte "BPL"             ;9
10732                   .byte "BRA"             ;A
10733                   .byte "BRK"             ;B
10734                   .byte "BVC"             ;C
10735                   .byte "BVS"             ;D
10736                   .byte "CLC"             ;E
10737                   .byte "CLD"             ;F
10738                   .byte "CLI"             ;10
10739                   .byte "CLV"             ;11
10740                   .byte "CMP"             ;12
10741                   .byte "CPX"             ;13
10742                   .byte "CPY"             ;14
10743                   .byte "DEC"             ;15
10744                   .byte "DEX"             ;16
10745                   .byte "DEY"             ;17
10746                   .byte "EOR"             ;18
10747                   .byte "INC"             ;19
10748                   .byte "INX"             ;1A
10749                   .byte "INY"             ;1B
10750                   .byte "JMP"             ;1C
10751                   .byte "JSR"             ;1D
10752                   .byte "LDA"             ;1E
10753                   .byte "LDX"             ;1F
10754                   .byte "LDY"             ;20
10755                   .byte "LSR"             ;21
10756                   .byte "NOP"             ;22
10757                   .byte "ORA"             ;23
10758                   .byte "PHA"             ;24
10759                   .byte "PHP"             ;25
10760                   .byte "PHX"             ;26
10761                   .byte "PHY"             ;27
10762                   .byte "PLA"             ;28
10763                   .byte "PLP"             ;29
10764                   .byte "PLX"             ;2A
10765                   .byte "PLY"             ;2B
10766                   .byte "ROL"             ;2C
10767                   .byte "ROR"             ;2D
10768                   .byte "RTI"             ;2E
10769                   .byte "RTS"             ;2F
10770                   .byte "SBC"             ;30
10771                   .byte "SEC"             ;31
10772                   .byte "SED"             ;32
10773                   .byte "SEI"             ;33
10774                   .byte "STA"             ;34
10775                   .byte "STX"             ;35
10776                   .byte "STY"             ;36
10777                   .byte "STZ"             ;37
10778                   .byte "TAX"             ;38
10779                   .byte "TAY"             ;39
10780                   .byte "TRB"             ;3A
10781                   .byte "TSB"             ;3B
10782                   .byte "TSX"             ;3C
10783                   .byte "TXA"             ;3D
10784                   .byte "TXS"             ;3E
10785                   .byte "TYA"             ;3F
10786                   .byte "WAI"             ;40
10787                   .byte "STP"             ;41
10788                   .byte "BBR"             ;42 4Byte Opcodes
10789                   .byte "BBS"             ;43
10790                   .byte "RMB"             ;44
10791                   .byte "SMB"             ;45
10792                   .byte ".DB"             ;46 define 1 byte for assembler
10793                   .byte ".DW"             ;47 define 1 word for assembler
10794                   .byte ".DS"             ;48 define a string block for assembler
10795                   .byte "???"             ;49 for invalid opcode
10796    ;
10797    ;
10798    HelpTxt        .byte "~Commands are :~"
10799                   .byte "Syntax = {} required, [] optional, HHHH hex address, DD hex data~"
10800                   .byte "~"
10801                   .byte "[HHHH][ HHHH]{Return} - Hex dump address(s)(up to 16 if no address entered)~"
10802                   .byte "[HHHH]{.HHHH}{Return} - Hex dump address range (16 per line)~"
10803                   .byte "[HHHH]{:DD}[ DD]{Return} - Change data bytes~"
10804                   .byte "[HHHH]{G}{Return} - Execute a program (use RTS to return to monitor)~"
10805                   .byte "{HHHH.HHHH>HHHH{I}{Return} - move range at 2nd HHHH down to 1st to 3rd HHHH~"
10806                   .byte "[HHHH]{L}{Return} - List (disassemble) 20 program lines~"
10807                   .byte "[HHHH]{.HHHH}{L}{Return} - Dissassemble range~"
10808                   .byte "{HHHH.HHHH>HHHH{M}{Return} - Move range at 1st HHHH thru 2nd to 3rd HHHH~"
10809                   .byte "[HHHH][ HHHH]{Q}{Return} - Text dump address(s)~"
10810                   .byte "[HHHH]{.HHHH}{Q}{Return} - Text dump address range (16 per line)~"
10811                   .byte "{S}[up to 32 text characters]{Return} - Set 32 byte LED message~"
10812                   .byte "[HHHH]{U}{Return} - Upload File from PC to SBC (Xmodem/CRC)~"
10813                   .byte "[HHHH.HHHH]{X}{Return} - Download File from SBC to PC (Xmodem/CRC)~"
10814                   .byte "{V}{Return} - Monitor Version~"
10815                   .byte "{P*}{Return} - Protected Power Down~"
10816                   .byte "{!}{Return} - Enter Assembler~"
10817                   .byte "{@}{Return} - Cold-Start EhBASIC~"
10818                   .byte "{#}{Return} - Warm-Start EhBASIC~"
10819                   .byte "{?}{Return} - Print commands~~"
10820                   .byte $00
10821    AsmHelpTxt     .byte "~Commands are :~"
10822                   .byte "Syntax = {} required, [] optional~"
10823                   .byte "HHHH=hex address, OPC=Opcode, DD=hex data, '_'=Space Bar or Tab~"
10824                   .byte "'$' is optional, all values are HEX.~"
10825                   .byte "Any input after a 'semi-colon' is ignored.~"
10826                   .byte "~"
10827                   .byte "{HHHH}{Return} - Set input address~"
10828                   .byte "[HHHH][_]{OPC}[_][#($DD_HHHH,X),Y]{Return} - Assemble line~"
10829                   .byte "[HHHH]{L}{Return} - List (disassemble) 20 program lines~"
10830                   .byte "{Return} - Exit Assembler~"
10831                   .byte "{?}{Return} - Print commands~~"
10832                   .byte $00
10833    ;
10834    Porttxt        .byte "65C02 Monitor v5.2 (2-24-18)"
10835                   .byte  $0d, $0a
10836                   .byte "with EhBASIC (c) Lee Davison" 
10837                   .byte  $0d, $0a
10838                   .byte "(Press ? for help)"
10839                   .byte $00
10840    ;
10841    ;end of file
10842    ;end of file
10843    	.include "font.asm"          ; LED font tables10844    
10845    ; VCF-MW 12 6502 Badge Software
10846    ; Hardware design by Lee Hart
10847    ; Software design by Daryl Rictor
10848    ;
10849    ; This software is free to use and modify in any non-commercial application.
10850    ; Comericial use is prohibited without expressed, written permission from the author.
10851    ;
10852    ;   ========================
10853    ;  | VCF Board LED mapping  |       
10854    ;   ========================
10855    ;
10856    ;--------------------------------
10857    ;
10858    ; 7-segment LED label
10859    ;      ___           
10860    ;   F | A | B          
10861    ;     |___| 
10862    ;   E | G | C
10863    ;     |___| 
10864    ;       D    
10865    ;--------------------------------
10866    ;
10867    ;  Badge LED data bits as wired           
10868    ;  3   2 1   0 x   4 x
10869    ;  G   G G   R R   Y Y
10870    ; 
10871    ;--------------------------------
10872    ;
10873    ;  Column Scan Address bits as wired
10874    ;   0  1  2  3  4  5  6      7    
10875    ;   8  8  8  8  8  8  8   RGB LED's    
10876    ;
10877    ;--------------------------------
10878    ;
10879    ; Column Scan code table
10880    ; Note - these are Active-Low outputs
10881    ;
10882    LED_COL	.byte	$FD, $FB, $F7, $EF, $DF, $BF, $7F, $FE
10883    ;
10884    ;--------------------------------
10885    ;
10886    ; Segment mapping to IO port
10887    ;
10888    ; data bits as wired
10889    ; 76543210
10890    ; SGCADEFB
10891    ; conversion to upside down
10892    ; SGFDABCE
10893    ;
10894    ;--------------------------------
10895    ;
10896    ; Actual mapping to Badge upside down display
10897    ;
10898      0008             LA = $08				; Segment A
10899      0004             LB = $04				; Segment B
10900      0002             LC = $02				; Segment C
10901      0010             LD = $10				; Segment D
10902      0001             LE = $01				; Segment E
10903      0020             LF = $20				; Segment F
10904      0040             LG = $40				; Segment G
10905      0080             LS = $80				; serial IO pin
10906    ;
10907    ;--------------------------------
10908    ;
10909    FONT_TABLE					
10910    ;
10911    ; LS is added to all characters to keep the Serial output inactive (High).
10912    ; This table is in ASCII order starting with $20 - Space and ending at $7F
10913    ;
10914    	.byte LS			; space
10915     	.byte LS+LE+LF			; !
10916    	.byte LS+LF+LB			; "
10917    	.byte LS+LF+LB+LA+LG		; #
10918    	.byte LS+LD+LF+LA+LC		; $
10919    	.byte LS+LB+LG			; %
10920    	.byte LS+LD+LB+LG		; &
10921    	.byte LS+LF			; '
10922    	.byte LS+LD+LE+LF+LA		; (
10923    	.byte LS+LD+LB+LA+LC		; )
10924    	.byte LS+LF+LA			; *
10925    	.byte LS+LE+LF+LG		; +
10926    	.byte LS+LD+LC			; ,
10927    	.byte LS+LG			; -
10928    	.byte LS+LD			; .
10929    	.byte LS+LE+LB+LG		; /
10930    	.byte LS+LD+LE+LF+LB+LA+LC	; 0
10931    	.byte LS+LB+LC			; 1
10932    	.byte LS+LD+LE+LB+LA+LG		; 2
10933    	.byte LS+LD+LB+LA+LG+LC		; 3
10934    	.byte LS+LF+LB+LG+LC		; 4
10935    	.byte LS+LD+LF+LA+LG+LC		; 5
10936    	.byte LS+LD+LE+LF+LA+LG+LC	; 6
10937    	.byte LS+LB+LA+LC		; 7
10938    	.byte LS+LD+LE+LF+LB+LA+LG+LC	; 8
10939    	.byte LS+LF+LB+LA+LG+LC		; 9
10940    	.byte LS+LD+LA			; :
10941    	.byte LS+LD+LA+LC		; ;
10942    	.byte LS+LD+LE			; <
10943    	.byte LS+LD+LG			; =
10944    	.byte LS+LD+LC			; >
10945    	.byte LS+LE+LB+LA+LG		; ?
10946    	.byte LS+LD+LE+LB+LA+LG+LC	; @
10947    	.byte LS+LE+LF+LB+LA+LG+LC	; A
10948    	.byte LS+LD+LE+LF+LG+LC		; B
10949    	.byte LS+LD+LE+LF+LA		; C
10950    	.byte LS+LD+LE+LB+LG+LC		; D
10951    	.byte LS+LD+LE+LF+LA+LG		; E
10952    	.byte LS+LE+LF+LA+LG		; F
10953    	.byte LS+LD+LE+LF+LA+LC		; G
10954    	.byte LS+LE+LF+LB+LG+LC		; H
10955    	.byte LS+LB+LC			; I
10956    	.byte LS+LD+LE+LB+LC		; J
10957    	.byte LS+LE+LF+LB+LG		; K
10958    	.byte LS+LD+LE+LF		; L
10959    	.byte LS+LE+LB+LG+LC		; M
10960    	.byte LS+LE+LF+LB+LA+LC		; N
10961    	.byte LS+LD+LE+LF+LB+LA+LC	; O
10962    	.byte LS+LE+LF+LB+LA+LG		; P
10963    	.byte LS+LF+LB+LA+LG+LC		; Q
10964    	.byte LS+LE+LG			; R
10965    	.byte LS+LD+LF+LA+LG+LC		; S
10966    	.byte LS+LE+LF+LA		; T
10967    	.byte LS+LD+LE+LF+LB+LC		; U
10968    	.byte LS+LD+LE+LF+LB+LC		; V
10969    	.byte LS+LD+LE+LF+LB+LC		; W
10970    	.byte LS+LG+LC			; X
10971    	.byte LS+LD+LF+LB+LG+LC		; Y
10972    	.byte LS+LD+LE+LB+LA		; Z
10973    	.byte LS+LD+LE+LF+LA		; [
10974    	.byte LS+LF+LG+LC		; \
10975    	.byte LS+LD+LB+LA+LC		; ]
10976    	.byte LS+LF+LB+LA		; ^
10977    	.byte LS+LD			; _
10978    	.byte LS+LB			; `
10979    	.byte LS+LD+LE+LB+LA+LG+LC	; a
10980    	.byte LS+LD+LE+LF+LG+LC		; b
10981    	.byte LS+LD+LE+LG		; c
10982    	.byte LS+LD+LE+LB+LG+LC		; d
10983    	.byte LS+LD+LE+LF+LB+LA+LG	; e
10984    	.byte LS+LE+LF+LA+LG		; f
10985    	.byte LS+LD+LF+LB+LA+LG+LC	; g
10986    	.byte LS+LE+LF+LG+LC		; h
10987    	.byte LS+LC			; i
10988    	.byte LS+LD+LE+LB+LC		; j
10989    	.byte LS+LE+LF+LB+LG		; k
10990    	.byte LS+LE+LF			; l
10991    	.byte LS+LE+LB+LG+LC		; m
10992    	.byte LS+LE+LG+LC		; n
10993    	.byte LS+LD+LE+LG+LC		; o
10994    	.byte LS+LE+LF+LB+LA+LG		; p
10995    	.byte LS+LF+LB+LA+LG+LC		; q
10996    	.byte LS+LE+LG			; r
10997    	.byte LS+LD+LF+LA+LG+LC		; s
10998    	.byte LS+LD+LE+LF+LG		; t
10999    	.byte LS+LD+LE+LC		; u
11000    	.byte LS+LD+LE+LC		; v
11001    	.byte LS+LD+LE+LC		; w
11002    	.byte LS+LG+LC			; x
11003    	.byte LS+LD+LF+LB+LG+LC		; y
11004    	.byte LS+LD+LE+LB+LA		; z
11005    	.byte LS+LD+LE+LF+LA		; {
11006    	.byte LS+LE+LF			; |
11007    	.byte LS+LD+LB+LA+LC		; }
11008    	.byte LS+LD+LA+LG		; ~
11009    	.byte LS+LD+LE+LB+LG+LC		; 
11010    
11011    
11012    	.include "LEDdrive.asm"      ; LED driver11013    
11014    ; VCF-MW 12 6502 Badge Software
11015    ; Hardware design by Lee Hart
11016    ; Software design by Daryl Rictor
11017    ;
11018    ; This software is free to use and modify in any non-commercial application.
11019    ; Comericial use is prohibited without expressed, written permission from the author.
11020    ;
11021    ;-------------------------------
11022    ; LED driver for VCF-MW 12      |
11023    ;                               |
11024    ; by Daryl Rictor  May 17, 2017 |
11025    ;-------------------------------
11026    	
11027      02A0             Lbuff		=	$2A0		; text storage for LED 32 bytes max
11028      02C0             LDbuff		=	$2C0		; descrete LED bit pattern buffer 32 bits max
11029      00E2             Lptr		= 	$E2		; LED pointer
11030      00E3             Ldig		=	$E3		; digit counter
11031      00E4             Lscn		=	$E4		; 16 bit scan speed delay
11032      00E5             Lscl		=	$E5		; scroll speed
11033      00E6             Lscnc		=	$E6		; scan counter
11034      00E7             Lsclc		=	$E7		; scroll counter
11035      00E8             LEDchk1		=	$E8		; config checksum 1
11036      00E9             LEDchk2		=	$E9		; config checksum 2
11037    
11038      F000             LEDIO		=	$f000		; IO address base for LED display
11039    
11040      0070             LSCAN		=	$70		; constant scan speed
11041      0010             LSCROLL		=	$10		; constant scroll speed
11042    
11043    Ldef 		.byte	"6502 bAdGE For VCF              " ; default message
11044    ;
11045    ; Config a 5 bit binary counter on the descrete LED's
11046    ;
11047    ;LDdef		.byte	$80, $90, $81, $91, $82, $92, $83, $93, $84, $94, $85, $95, $86, $96, $87, $97 
11048    ;		.byte	$88, $98, $89, $99, $8a, $9a, $8b, $9b, $8c, $9c, $8d, $9d, $8e, $9e, $8f, $9f  
11049    ;
11050    ; Scan back and forth, aka Knightrider, on the descrete LED's
11051    ;
11052    LDdef		.byte	$88, $84, $82, $81, $90, $81, $82, $84, $88, $84, $82, $81, $90, $81, $82, $84
11053    		.byte	$88, $84, $82, $81, $90, $81, $82, $84, $88, $84, $82, $81, $90, $81, $82, $84
11054    		
11055    
11056    ;----------------------------------------------------------------------------
11057    FCE6  A5 E8        LED_Init	lda	LEDchk1		; check if we have already initialized the video buffer
11058    FCE8  C9 A5        		cmp	#$A5		; first checksum byte = $A5
11059    FCEA  D0 06        		bne	Linit2		; if not a match, we will initialize the checksums and buffer
11060    FCEC  A5 E9        		lda	LEDchk2		;
11061    FCEE  C9 5A        		cmp	#$5A		; second checksum is $5A
11062    FCF0  F0 20        		beq	Linit3		; match, initialize just buffer pointers and shift counter 
11063    FCF2  A9 A5        Linit2		lda	#$A5		; init first checksum
11064    FCF4  85 E8        		sta	LEDchk1		;
11065    FCF6  A9 5A        		lda	#$5A		; init second checksum
11066    FCF8  85 E9        		sta	LEDchk2		; 
11067    FCFA  A0 1F        		ldy	#$1F		; store default display in buffer 32 bytes
11068    FCFC  B9 A6 FC     Linit1		lda	Ldef,y		; text
11069    FCFF  38           		sec			; set carry for subtraction
11070    FD00  E9 20        		sbc	#$20		; adjust ASCII code
11071    FD02  AA           		tax			; move to pointer
11072    FD03  BD 46 FC     		lda	FONT_TABLE, x	; get ASCII character font
11073    FD06  99 A0 02     		sta	Lbuff,y		; save in buffer
11074    FD09  B9 C6 FC     		lda	LDdef, y	; get descrete LED
11075    FD0C  99 C0 02     		sta	LDbuff, y	; save in buffer
11076    FD0F  88           		dey			; get next character
11077    FD10  10 EA        		bpl	Linit1		; loop until all 32 done 
11078    FD12  64 E2        Linit3		STZ	Lptr		; clear pointer
11079    FD14  A9 70        		lda	#LSCAN
11080    FD16  85 E4        		sta	Lscn		; Set scan speed
11081    FD18  85 E6        		sta	Lscnc		; init counter
11082    FD1A  A9 10        		lda	#LSCROLL	; set high byte scroll delay
11083    FD1C  85 E5        		sta	Lscl		; save it	
11084    FD1E  85 E7        		sta	Lsclc		; clear scroll counter 
11085    FD20  60           		rts			; done
11086    
11087    ;----------------------------------------------------------------------------
11088    ; call this to input a text message and convert it to the font codes
11089    ;
11090    FD21  A2 00        SLED_cmd	ldx	#$00		; buffer pointer
11091    FD23  B9 00 03     Sled1		lda	Buffer, y	; get first character
11092    FD26  C9 0D        		cmp	#$0D		; is it EOL
11093    FD28  F0 18        		beq	Sled_eol	; yes
11094    FD2A  DA           		phx			; save x
11095    FD2B  38           		sec			; adjust ASCII
11096    FD2C  E9 20        		sbc	#$20		; - 32
11097    FD2E  AA           		tax			; set pointer
11098    FD2F  BD 46 FC     		lda	FONT_TABLE,x	; get font byte
11099    FD32  FA           		plx			; restore x
11100    FD33  9D A0 02     		sta	Lbuff,x		; save font to buffer
11101    FD36  C8           		iny			; move input buffer pointer
11102    FD37  E8           		inx			; move display buffer pointer
11103    FD38  E0 20        		cpx	#$20		; have we done 32 bytes?
11104    FD3A  D0 E7        		bne	Sled1		; not yet, get next character	
11105    FD3C  A9 0D        		lda	#$0D		; load CR code
11106    FD3E  8D 01 03     		sta	Buffer+1	; ensure rest of text is ignored
11107    FD41  60           		rts			; done
11108    FD42  A9 80        Sled_eol	lda	#$80		; LED space chr font byte
11109    FD44  9D A0 02     Sled2		sta	Lbuff, x	; save to disaply buffer
11110    FD47  E8           		inx			; inc dispaly buffer
11111    FD48  E0 20        		cpx	#$20		; fill rest of buffer
11112    FD4A  D0 F8        		bne	Sled2		;	
11113    FD4C  4C 11 EC     		jmp	Monitor		; done, bypass Monitor command processing
11114    					; and just start with a new line
11115    
11116    ;----------------------------------------------------------------------------
11117    ; call this to complete 1 digit scan.
11118    ; call repeatedly to refresh entire display and scroll
11119    ; This gets called while waiting for user input via the Monitor's IO routines.
11120    ;
11121    FD4F  C6 E6        LED_scan	dec	Lscnc		; decrement scan counter		
11122    FD51  D0 44        		bne	Led_sfin3	; not ready yet
11123    FD53  48           		pha			; save a
11124    FD54  DA           		phx			; save x
11125    FD55  5A           		phy			; save y	
11126    FD56  A6 E4        		ldx	Lscn		; get scan speed
11127    FD58  86 E6        		stx	Lscnc		; reset on-time delay
11128    FD5A  F0 38        		beq	Led_sfin2	; disable LED refresh if 0
11129    FD5C  A6 E3        		ldx	Ldig		; digit counter
11130    FD5E  BD 3E FC     		lda	LED_COL, x	; get Column mask
11131    FD61  A8           		tay			; save mask in Y
11132    FD62  8A           		txa			; get digit counter
11133    FD63  18           		clc			; clear carry for add
11134    FD64  65 E2        		adc	Lptr		; add character pointer
11135    FD66  29 1F        		and	#$1F		; wrap if larger than 32 characters
11136    FD68  AA           		tax			; set up pointer to data
11137    FD69  A5 E3        		lda	Ldig		; digit counter
11138    FD6B  C9 07        		cmp	#$07		; is it the descrete LED's
11139    FD6D  F0 05        		beq	Led_sdesc	; go to descrete LED update
11140    FD6F  BD A0 02     		lda	Lbuff, x	; get LED scan code
11141    FD72  80 03        		bra	Led_sfin	; skip next cmd
11142    FD74  BD C0 02     Led_sdesc	lda	LDbuff, x	; get descrete LED code
11143    FD77  99 00 F0     Led_sfin	sta	LEDIO,y		; update LED display
11144    FD7A  A5 E3        		lda	Ldig		; get LED pointer
11145    FD7C  1A           		ina			; set to next LED
11146    FD7D  29 07        		and	#$07		; wrap if beyond 7
11147    FD7F  85 E3        		sta	Ldig		; save it
11148    FD81  D0 11        		bne	Led_sfin2	; all done
11149    FD83  C6 E7        		dec	Lsclc		; dec scroll counter
11150    FD85  D0 0D        		bne	Led_sfin2	; not ready yet
11151    FD87  A5 E5        		lda	Lscl		; done with scroll delay
11152    FD89  85 E7        		sta	Lsclc		; restore scroll counter	
11153    FD8B  F0 07        		beq	Led_sfin2	; if scroll delay =0, don't scroll
11154    FD8D  A5 E2        		lda	Lptr		; get character pointer
11155    FD8F  1A           		ina			; scroll one to the left
11156    FD90  29 1F        		and	#$1F		; mask to 32 characters
11157    FD92  85 E2        		sta	Lptr		; save it
11158    FD94  7A           Led_sfin2	ply			; restore y
11159    FD95  FA           		plx			; restore x
11160    FD96  68           		pla			; restore a
11161    FD97  60           Led_sfin3	rts			; done
11162    ;----------------------------------------------------------------------------
11163    ;----------------------------------------------------------------------------
11164    	.include "xmodem.asm"        ; Xmodem-CRC downloader11165    
11166    ; VCF-MW 12 6502 Badge Software
11167    ; Hardware design by Lee Hart
11168    ; Software design by Daryl Rictor
11169    ;
11170    ; This software is free to use and modify in any non-commercial application.
11171    ; Comericial use is prohibited without expressed, written permission from the author.
11172    ;
11173    ; XMODEM/CRC Sender/Receiver for the 65C02
11174    ;
11175    ; By Daryl Rictor Aug 2002
11176    ;
11177    ; A simple file transfer program to allow transfers between the SBC and a 
11178    ; console device utilizing the x-modem/CRC transfer protocol.  Requires 
11179    ; ~1200 bytes of either RAM or ROM, 132 bytes of RAM for the receive buffer,
11180    ; and 12 bytes of zero page RAM for variable storage.
11181    ;
11182    ;**************************************************************************
11183    ; This implementation of XMODEM/CRC does NOT conform strictly to the 
11184    ; XMODEM protocol standard in that it (1) does not accurately time character
11185    ; reception or (2) fall back to the Checksum mode.
11186    
11187    ; (1) For timing, it uses a crude timing loop to provide approximate
11188    ; delays.  These have been calibrated against a 1MHz CPU clock.  I have
11189    ; found that CPU clock speed of up to 5MHz also work but may not in
11190    ; every case.  Windows HyperTerminal worked quite well at both speeds!
11191    ;
11192    ; (2) Most modern terminal programs support XMODEM/CRC which can detect a
11193    ; wider range of transmission errors so the fallback to the simple checksum
11194    ; calculation was not implemented to save space.
11195    ;**************************************************************************
11196    ;
11197    ; Files transferred via XMODEM-CRC will have the load address contained in
11198    ; the first two bytes in little-endian format:  
11199    ;  FIRST BLOCK
11200    ;     offset(0) = lo(load start address),
11201    ;     offset(1) = hi(load start address)
11202    ;     offset(2) = data byte (0)
11203    ;     offset(n) = data byte (n-2)
11204    ;
11205    ; Subsequent blocks
11206    ;     offset(n) = data byte (n)
11207    ;
11208    ; One note, XMODEM send 128 byte blocks.  If the block of memory that
11209    ; you wish to save is smaller than the 128 byte block boundary, then
11210    ; the last block will be padded with zeros.  Upon reloading, the
11211    ; data will be written back to the original location.  In addition, the
11212    ; padded zeros WILL also be written into RAM, which could overwrite other
11213    ; data.   
11214    ;
11215    ;-------------------------- The Code ----------------------------
11216    ;
11217    ; zero page variables (adjust these to suit your needs)
11218    ;
11219    ;
11220      0035             Lastblk		=	$35		; flag for last block
11221      0036             Blkno		=	$36		; block number 
11222      0037             Errcnt		=	$37		; error counter 10 is the limit
11223      0037             Bflag		=	$37		; block flag 
11224    
11225      0038             Crc		=	$38		; CRC lo byte  (two byte variable)
11226      0039             Crch		=	$39		; CRC hi byte  
11227    
11228      003A             Ptr		=	$3a		; data pointer (two byte variable)
11229      003B             Ptrh		=	$3b		;   "    "
11230    
11231      003C             Eofp		=	$3c		; end of file address pointer (2 bytes)
11232      003D             Eofph		=	$3d		;  "	"	"	"
11233    
11234      003E             Retry		=	$3e		; retry counter 
11235      003F             Retry2		=	$3f		; 2nd counter
11236    
11237    ;
11238    ;
11239    ; non-zero page variables and buffers
11240    ;
11241    ;
11242      0300             Rbuff		=	$0300      	; temp 132 byte receive buffer 
11243    					;(place anywhere, page aligned)
11244    ;
11245    ;
11246    ;  tables and constants
11247    ;
11248    ;
11249    ; The crclo & crchi labels are used to point to a lookup table to calculate
11250    ; the CRC for the 128 byte data blocks.  There are two implementations of these
11251    ; tables.  One is to use the tables included (defined towards the end of this
11252    ; file) and the other is to build them at run-time.  If building at run-time,
11253    ; then these two labels will need to be un-commented and declared in RAM.
11254    ;
11255    ;crclo		=	$7D00      	; Two 256-byte tables for quick lookup
11256    ;crchi		= 	$7E00      	; (should be page-aligned for speed)
11257    ;
11258    ;
11259    ;
11260    ; XMODEM Control Character Constants
11261      0001             SOH		=	$01		; start block
11262      0004             EOT		=	$04		; end of text marker
11263      0006             ACK		=	$06		; good block acknowledged
11264      0015             NAK		=	$15		; bad block acknowledged
11265      0018             CAN		=	$18		; cancel (not standard, not supported)
11266      000D             CR		=	$0d		; carriage return
11267      000A             LLF		=	$0a		; line feed
11268      001B             ESC		=	$1b		; ESC to exit
11269    
11270    ;
11271    ;^^^^^^^^^^^^^^^^^^^^^^ Start of Program ^^^^^^^^^^^^^^^^^^^^^^
11272    ;
11273    ; Xmodem/CRC transfer routines
11274    ; By Daryl Rictor, August 8, 2002
11275    ;
11276    ; v1.0  released on Aug 8, 2002.
11277    ;
11278    ;
11279    ;		*= 	$FA00		; Start of program (adjust to your needs)
11280    ;
11281    ; Enter this routine with the beginning address stored in the zero page address
11282    ; pointed to by ptr & ptrh and the ending address stored in the zero page address
11283    ; pointed to by eofp & eofph.
11284    ;
11285    ;
11286    FD98  20 0F FF     XModemSend	jsr	PrintMsg	; send prompt and info
11287    FD9B  64 37        		stz	Errcnt		; error counter set to 0
11288    FD9D  64 35        		stz	Lastblk		; set flag to false
11289    FD9F  64 36        		stz	Blkno		; set block # to 0
11290    FDA1  A9 FF        Wait4CRC	lda	#$ff		; 3 seconds
11291    FDA3  85 3F        		sta	Retry2		;
11292    FDA5  20 F4 FE     		jsr	GetByte		;
11293    FDA8  90 F7        		bcc	Wait4CRC	; wait for something to come in...
11294    FDAA  C9 43        		cmp	#'C'		; is it the "C" to start a CRC xfer?
11295    FDAC  F0 07        		beq	LdBuffer	; yes
11296    FDAE  C9 1B        		cmp	#ESC		; is it a cancel? <Esc> Key
11297    FDB0  D0 EF        		bne	Wait4CRC	; No, wait for another character
11298    FDB2  4C 34 FE     		jmp	PrtAbort	; Print abort msg and exit
11299    FDB5  A5 35        LdBuffer	lda	Lastblk		; Was the last block sent?
11300    FDB7  F0 03        		beq	LdBuff0		; no, send the next one	
11301    FDB9  4C 3A FE     		jmp 	Done		; yes, we're done
11302    FDBC  A2 02        LdBuff0		ldx	#$02		; init pointers
11303    FDBE  A0 00        		ldy	#$00		;
11304    FDC0  E6 36        		inc	Blkno		; inc block counter
11305    FDC2  A5 36        		lda	Blkno		; 
11306    FDC4  8D 00 03     		sta	Rbuff		; save in 1st byte of buffer
11307    FDC7  49 FF        		eor	#$FF		; 
11308    FDC9  8D 01 03     		sta	Rbuff+1		; save 1's comp of blkno next
11309    
11310    FDCC  B1 3A        LdBuff1		lda	(Ptr),y		; save 128 bytes of data
11311    FDCE  9D 00 03     		sta	Rbuff,x		;
11312    FDD1  38           LdBuff2		sec			; 
11313    FDD2  A5 3C        		lda	Eofp		;
11314    FDD4  E5 3A        		sbc	Ptr		; Are we at the last address?
11315    FDD6  D0 14        		bne	LdBuff4		; no, inc pointer and continue
11316    FDD8  A5 3D        		lda	Eofph		;
11317    FDDA  E5 3B        		sbc	Ptrh		;
11318    FDDC  D0 0E        		bne	LdBuff4		; 
11319    FDDE  E6 35        		inc	Lastblk		; Yes, Set last byte flag
11320    FDE0  E8           LdBuff3		inx			;
11321    FDE1  E0 82        		cpx	#$82		; Are we at the end of the 128 byte block?
11322    FDE3  F0 12        		beq	SCalcCRC	; Yes, calc CRC
11323    FDE5  A9 00        		lda	#$00		; Fill rest of 128 bytes with $00
11324    FDE7  9D 00 03     		sta	Rbuff,x		;
11325    FDEA  F0 F4        		beq	LdBuff3		; Branch always
11326    
11327    FDEC  E6 3A        LdBuff4		inc	Ptr		; Inc address pointer
11328    FDEE  D0 02        		bne	LdBuff5		;
11329    FDF0  E6 3B        		inc	Ptrh		;
11330    FDF2  E8           LdBuff5		inx			;
11331    FDF3  E0 82        		cpx	#$82		; last byte in block?
11332    FDF5  D0 D5        		bne	LdBuff1		; no, get the next
11333    FDF7  20 A3 FF     SCalcCRC	jsr 	CalcCRC
11334    FDFA  A5 39        		lda	Crch		; save Hi byte of CRC to buffer
11335    FDFC  99 00 03     		sta	Rbuff,y		;
11336    FDFF  C8           		iny			;
11337    FE00  A5 38        		lda	Crc		; save lo byte of CRC to buffer
11338    FE02  99 00 03     		sta	Rbuff,y		;
11339    FE05  A2 00        Resend		ldx	#$00		;
11340    FE07  A9 01        		lda	#SOH
11341    FE09  20 EC EA     		jsr	Output		; send SOH
11342    FE0C  BD 00 03     SendBlk		lda	Rbuff,x		; Send 132 bytes in buffer to the console
11343    FE0F  20 EC EA     		jsr	Output		;
11344    FE12  E8           		inx			;
11345    FE13  E0 84        		cpx	#$84		; last byte?
11346    FE15  D0 F5        		bne	SendBlk		; no, get next
11347    FE17  A9 FF        		lda	#$FF		; yes, set 3 second delay 
11348    FE19  85 3F        		sta	Retry2		; and
11349    FE1B  20 F4 FE     		jsr	GetByte		; Wait for Ack/Nack
11350    FE1E  90 0C        		bcc	Seterror	; No chr received after 3 seconds, resend
11351    FE20  C9 06        		cmp	#ACK		; Chr received... is it:
11352    FE22  F0 91        		beq	LdBuffer	; ACK, send next block
11353    FE24  C9 15        		cmp	#NAK		; 
11354    FE26  F0 04        		beq	Seterror	; NAK, inc errors and resend
11355    FE28  C9 1B        		cmp	#ESC		;
11356    FE2A  F0 08        		beq	PrtAbort	; Esc pressed to abort
11357    					; fall through to error counter
11358    FE2C  E6 37        Seterror	inc	Errcnt		; Inc error counter
11359    FE2E  A5 37        		lda	Errcnt		; 
11360    FE30  C9 0A        		cmp	#$0A		; are there 10 errors? (Xmodem spec for failure)
11361    FE32  D0 D1        		bne	Resend		; no, resend block
11362    FE34  20 05 FF     PrtAbort	jsr	Flush		; yes, too many errors, flush buffer,
11363    FE37  4C 53 FF     		jmp	Print_Err	; print error msg and exit
11364    FE3A  4C 73 FF     Done		Jmp	Print_Good	; All Done..Print msg and exit
11365    ;
11366    ;
11367    ;
11368    
11369    FE3D  20 0F FF     XModemRcv	jsr	PrintMsg	; send prompt and info
11370    FE40  A9 01        		lda	#$01		;
11371    FE42  85 36        		sta	Blkno		; set block # to 1
11372    FE44  A5 3C        		lda	Eofp		; get start address from Monitor command
11373    FE46  85 3A        		sta	Ptr		; Hexdigits
11374    FE48  A5 3D        		lda	Eofp+1		; and save to our pointer
11375    FE4A  85 3B        		sta	Ptr+1		;
11376    FE4C  A9 43        StartCrc	lda	#'C'		; "C" start with CRC mode
11377    FE4E  20 EC EA     		jsr	Output		; send it
11378    FE51  A9 FF        		lda	#$FF		;
11379    FE53  85 3F        		sta	Retry2		; set loop counter for ~3 sec delay
11380    FE55  A9 00        		lda	#$00		;
11381    FE57  85 38                       	sta	Crc		;
11382    FE59  85 39        		sta	Crch		; init CRC value	
11383    FE5B  20 F4 FE     		jsr	GetByte		; wait for input
11384    FE5E  B0 0B                       	bcs	GotByte		; byte received, process it
11385    FE60  90 EA        		bcc	StartCrc	; resend "C"
11386    
11387    FE62  A9 FF        StartBlk	lda	#$FF		; 
11388    FE64  85 3F        		sta	Retry2		; set loop counter for ~3 sec delay
11389    FE66  20 F4 FE     		jsr	GetByte		; get first byte of block
11390    FE69  90 F7        		bcc	StartBlk	; timed out, keep waiting...
11391    FE6B  C9 1B        GotByte		cmp	#ESC		; quitting?
11392    FE6D  D0 03                        bne	GotByte1	; no
11393    FE6F  4C 53 FF     		jmp	Print_Err	; print err and return
11394    FE72  C9 01        GotByte1        cmp	#SOH		; start of block?
11395    FE74  F0 07        		beq	BegBlk		; yes
11396    FE76  C9 04        		cmp	#EOT		;
11397    FE78  D0 45        		bne	BadCrc		; Not SOH or EOT, so flush buffer & send NAK	
11398    FE7A  4C E8 FE     		jmp	RDone		; EOT - all done!
11399    FE7D  A2 00        BegBlk		ldx	#$00		;
11400    FE7F  A9 FF        GetBlk		lda	#$ff		; 3 sec window to receive characters
11401    FE81  85 3F        		sta 	Retry2		;
11402    FE83  20 F4 FE     GetBlk1		jsr	GetByte		; get next character
11403    FE86  90 37        		bcc	BadCrc		; chr rcv error, flush and send NAK
11404    FE88  9D 00 03     GetBlk2		sta	Rbuff,x		; good char, save it in the rcv buffer
11405    FE8B  E8           		inx			; inc buffer pointer	
11406    FE8C  E0 84        		cpx	#$84		; <01> <FE> <128 bytes> <CRCH> <CRCL>
11407    FE8E  D0 EF        		bne	GetBlk		; get 132 characters
11408    FE90  A2 00        		ldx	#$00		;
11409    FE92  BD 00 03     		lda	Rbuff,x		; get block # from buffer
11410    FE95  C5 36        		cmp	Blkno		; compare to expected block #	
11411    FE97  F0 06        		beq	GoodBlk1	; matched!
11412    FE99  20 53 FF     		jsr	Print_Err	; Unexpected block number - abort	
11413    FE9C  4C 05 FF     		jmp	Flush		; mismatched - flush buffer and return
11414    FE9F  49 FF        GoodBlk1	eor	#$ff		; 1's comp of block #
11415    FEA1  E8           		inx			;
11416    FEA2  DD 00 03     		cmp	Rbuff,x		; compare with expected 1's comp of block #
11417    FEA5  F0 06        		beq	GoodBlk2 	; matched!
11418    FEA7  20 53 FF     		jsr	Print_Err	; Unexpected block number - abort	
11419    FEAA  4C 05 FF     		jmp 	Flush		; mismatched - flush buffer and return
11420    FEAD  20 A3 FF     GoodBlk2	jsr	CalcCRC		; calc CRC
11421    FEB0  B9 00 03     		lda	Rbuff,y		; get hi CRC from buffer
11422    FEB3  C5 39        		cmp	Crch		; compare to calculated hi CRC
11423    FEB5  D0 08        		bne	BadCrc		; bad crc, send NAK
11424    FEB7  C8           		iny			;
11425    FEB8  B9 00 03     		lda	Rbuff,y		; get lo CRC from buffer
11426    FEBB  C5 38        		cmp	Crc		; compare to calculated lo CRC
11427    FEBD  F0 0B        		beq	GoodCrc		; good CRC
11428    FEBF  20 05 FF     BadCrc		jsr	Flush		; flush the input port
11429    FEC2  A9 15        		lda	#NAK		;
11430    FEC4  20 EC EA     		jsr	Output		; send NAK to resend block
11431    FEC7  4C 62 FE     		jmp	StartBlk	; start over, get the block again			
11432    FECA  A2 02        GoodCrc		ldx	#$02		;
11433    FECC  A0 00        CopyBlk		ldy	#$00		; set offset to zero
11434    FECE  BD 00 03     CopyBlk3	lda	Rbuff,x		; get data byte from buffer
11435    FED1  91 3A        		sta	(Ptr),y		; save to target
11436    FED3  E6 3A        		inc	Ptr		; point to next address
11437    FED5  D0 02        		bne	CopyBlk4	; did it step over page boundary?
11438    FED7  E6 3B        		inc	Ptr+1		; adjust high address for page crossing
11439    FED9  E8           CopyBlk4	inx			; point to next data byte
11440    FEDA  E0 82        		cpx	#$82		; is it the last byte
11441    FEDC  D0 F0        		bne	CopyBlk3	; no, get the next one
11442    FEDE  E6 36        IncBlk		inc	Blkno		; done.  Inc the block #
11443    FEE0  A9 06        		lda	#ACK		; send ACK
11444    FEE2  20 EC EA     		jsr	Output		;
11445    FEE5  4C 62 FE     		jmp	StartBlk	; get next block
11446    
11447    FEE8  A9 06        RDone		lda	#ACK		; last block, send ACK and exit.
11448    FEEA  20 EC EA     		jsr	Output		;
11449    FEED  20 05 FF     		jsr	Flush		; get leftover characters, if any
11450    FEF0  20 73 FF     		jsr	Print_Good	;
11451    FEF3  60           		rts			;
11452    ;
11453    ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11454    ;=========================================================================
11455    ;
11456    ; subroutines
11457    ;
11458    ;
11459    ;
11460    GetByte		;lda	#$00		; wait for chr input and cycle timing loop
11461    FEF4  64 3E        		stz	Retry		; set low value of timing loop
11462    FEF6  20 53 EB     StartCrcLp	jsr	Serial_ScanQ	; get chr from serial port, don't wait, no LED update
11463    FEF9  B0 09        		bcs	GetByte1	; got one, so exit
11464    FEFB  C6 3E        		dec   	Retry		; no character received, so dec counter
11465    FEFD  D0 F7        		bne	StartCrcLp	;
11466    FEFF  C6 3F        		dec	Retry2		; dec hi byte of counter
11467    FF01  D0 F3        		bne	StartCrcLp	; look for character again
11468    FF03  18           		clc			; if loop times out, CLC, else SEC and return
11469    FF04  60           GetByte1	rts			; with character in "A"
11470    ;
11471    FF05  A9 70        Flush		lda	#$70		; flush receive buffer
11472    FF07  85 3F        		sta	Retry2		; flush until empty for ~1 sec.
11473    FF09  20 F4 FE     Flush1		jsr	GetByte		; read the port
11474    FF0C  B0 F7        		bcs	Flush		; if chr recvd, wait for another
11475    FF0E  60           		rts			; else done
11476    ;
11477    FF0F  A2 00        PrintMsg	ldx	#$00		; PRINT starting message
11478    FF11  BD 1D FF     PrtMsg1		lda   	Msg,x		
11479    FF14  F0 06        		beq	PrtMsg2			
11480    FF16  20 EC EA     		jsr	Output
11481    FF19  E8           		inx
11482    FF1A  D0 F5        		bne	PrtMsg1
11483    FF1C  60           PrtMsg2		rts
11484    Msg		.byte	"Begin XMODEM/CRC transfer.  Press <Esc> to abort..."
11485    		.BYTE  	CR, LLF
11486                   	.byte   0
11487    ;
11488    FF53  A2 00        Print_Err	ldx	#$00		; PRINT Error message
11489    FF55  BD 61 FF     PrtErr1		lda   	ErrMsg,x
11490    FF58  F0 06        		beq	PrtErr2
11491    FF5A  20 EC EA     		jsr	Output
11492    FF5D  E8           		inx
11493    FF5E  D0 F5        		bne	PrtErr1
11494    FF60  60           PrtErr2		rts
11495    ErrMsg		.byte 	"Transfer Error!"
11496    		.BYTE  	CR, LLF
11497                    .byte   0
11498    ;
11499    FF73  A2 00        Print_Good	ldx	#$00		; PRINT Good Transfer message
11500    FF75  BD 81 FF     Prtgood1	lda   	GoodMsg,x
11501    FF78  F0 06        		beq	Prtgood2
11502    FF7A  20 EC EA     		jsr	Output
11503    FF7D  E8           		inx
11504    FF7E  D0 F5        		bne	Prtgood1
11505    FF80  60           Prtgood2	rts
11506    GoodMsg		.byte	EOT,CR,LLF,EOT,CR,LLF,EOT,CR,LLF,CR,LLF
11507    		.byte 	"Transfer Successful!"
11508    		.BYTE  	CR, LLF
11509                    .byte   0
11510    ;
11511    ;
11512    ;=========================================================================
11513    ;
11514    ;
11515    ;  CRC subroutines 
11516    ;
11517    ;
11518    FFA3  A9 00        CalcCRC		lda	#$00		; yes, calculate the CRC for the 128 bytes
11519    FFA5  85 38        		sta	Crc		;
11520    FFA7  85 39        		sta	Crch		;
11521    FFA9  A0 02        		ldy	#$02		;
11522    FFAB  B9 00 03     CalcCRC1	lda	Rbuff,y		;
11523    FFAE  45 39        		eor 	Crc+1 		; Quick CRC computation with lookup tables
11524    FFB0  AA                  		tax		 	; updates the two bytes at crc & crc+1
11525    FFB1  A5 38               		lda 	Crc		; with the byte send in the "A" register
11526    FFB3  5D 00 C1            		eor 	Crchi,X
11527    FFB6  85 39               		sta 	Crc+1
11528    FFB8  BD 00 C0           	 	lda 	Crclo,X
11529    FFBB  85 38               		sta 	Crc
11530    FFBD  C8           		iny			;
11531    FFBE  C0 82        		cpy	#$82		; done yet?
11532    FFC0  D0 E9        		bne	CalcCRC1	; no, get next
11533    FFC2  60           		rts			; y=82 on exit
11534    
11535    
11536    
11537    	.include "reset.asm"         ; Reset & IRQ handler11538    
11539    ; VCF-MW 12 6502 Badge Software
11540    ; Hardware design by Lee Hart
11541    ; Software design by Daryl Rictor
11542    ;
11543    ; This software is free to use and modify in any non-commercial application.
11544    ; Comericial use is prohibited without expressed, written permission from the author.
11545    ;
11546    ;****************************************************************************
11547    ; Reset, Interrupt, & Break Handlers
11548    ;****************************************************************************
11549    
11550    ;--------------Reset handler----------------------------------------------
11551    FFC3  78           Reset          SEI                     ; diable interupts
11552    FFC4  D8                          CLD                     ; clear decimal mode                      
11553    FFC5  A2 FF                       LDX   #$FF              ;
11554    FFC7  9A                          TXS                     ; init stack pointer
11555    FFC8  20 30 EB                    jsr   Serial_Init       ; init serial port
11556    FFCB  20 E6 FC                    jsr   LED_Init          ; init LED driver	
11557    FFCE  A9 00        	       lda   #$00              ; Clear registers
11558    FFD0  A8                          TAY                     ;
11559    FFD1  AA                          TAX                     ;
11560    FFD2  18                          CLC                     ; clear flags
11561    FFD3  D8                          CLD                     ; clear decimal mode
11562    FFD4  58                          CLI                     ; enable IRQ's
11563    FFD5  4C 0B EC                    JMP  MonitorBoot        ; Monitor for cold reset                       
11564    FFD8  40           NMIjump	       RTI                     ; NMI null routine	
11565    FFD9  48           Interrupt      PHA                     ; save A
11566    FFDA  DA                          PHX                     ; save X
11567    FFDB  BA                          TSX                     ; get stack pointer
11568    FFDC  BD 03 01                    LDA   $0103,X           ; load INT-P Reg off stack
11569    FFDF  29 10                       AND   #$10              ; mask BRK
11570    FFE1  D0 E0                       bne   Reset             ; BRK, do Reset code
11571    FFE3  FA                          plx                     ; restore x 
11572    FFE4  4C A0 EA                    jmp   IRQ               ; do IRQ code
11573    
11574    ;
11575    ;  NMIjmp      =     $FFFA             
11576    ;  RESjmp      =     $FFFC             
11577    ;  INTjmp      =     $FFFE             
11578    
11579    FFFA                              *=    $FFFA
11580                   .word  NMIjump          ; NMI jump vector
11581                   .word  Reset            ; RES jump vector
11582                   .word  Interrupt        ; IRQ jump vector
11583    ;end of file
11584    ;end of file
11585    11586    
11587    