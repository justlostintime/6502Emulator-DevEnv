------- FILE mytb.asm LEVEL 1 PASS 6
      1 U4337				   input      processor	6502
      2 U4337 ????						;=====================================================
      3 U4337 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U4337 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U4337 ????						; Free Time. Now abiut 6K Full OS features.
      6 U4337 ????						;
      7 U4337 ????						; While working on the Corsham Technologies KIM Clone
      8 U4337 ????						; project, I wanted to include a TINY BASIC since that
      9 U4337 ????						; was a highly desirable feature of early computers.
     10 U4337 ????						;
     11 U4337 ????						; Rather than negotiating copyright issues for
     12 U4337 ????						; existing BASICs, I decided to just write one from
     13 U4337 ????						; scratch.
     14 U4337 ????						;
     15 U4337 ????						; 10/07/2017
     16 U4337 ????						;
     17 U4337 ????						; This implements a stripped down Tiny BASIC
     18 U4337 ????						; interpreter using the Interpretive Language (IL)
     19 U4337 ????						; method as described in the first few issues of
     20 U4337 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U4337 ????						; to write various languages simply by changing the
     22 U4337 ????						; IL code rather than the interpreter itself.
     23 U4337 ????						;
     24 U4337 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U4337 ????						;		* Fixed major bug in findLine that
     26 U4337 ????						;		  caused corrupted lines, crashes, etc.
     27 U4337 ????						;		* If no parameter given to RND, assume
     28 U4337 ????						;		  32766.
     29 U4337 ????						;		* No more error 5 when a program
     30 U4337 ????						;		  reaches the end without an END.
     31 U4337 ????						;
     32 U4337 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U4337 ????						;		 * Unexpanded version to play with everything
     34 U4337 ????						;		 * Add some usefull system level functions
     35 U4337 ????						;		 * allow a larger number of tiny basic formats
     36 U4337 ????						;		 * Add byte at start of line holding length
     37 U4337 ????						;		   for faster execution of goto and gosub
     38 U4337 ????						;		 * Re-added gosub
     39 U4337 ????						;		 * allow ; or , at end if print stmt
     40 U4337 ????						;		   without CRLF being added.
     41 U4337 ????						;		 * Added extended function erase to
     42 U4337 ????						;		   use the extended ctmon65 rm file
     43 U4337 ????						;		 * Fix quoted text to not have to backtrack
     44 U4337 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U4337 ????						;		 * Add concurrency features
     46 U4337 ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U4337 ????						;
     48 U4337 ????						; 10/31/2023 v0.5 Justlostintime@gmail.com
     49 U4337 ????						;		 * Inline in il some var load value instead of calling
     50 U4337 ????						;
     51 U4337 ????						; www.corshamtech.com
     52 U4337 ????						; bob@corshamtech.com
     53 U4337 ????						; JustLostInTime@gmail.com
     54 U4337 ????						;
     55 U4337 ????						;=====================================================
     56 U4337 ????						;
     57 U4337 ????						; Create TRUE and FALSE values for conditionals.
     58 U4337 ????						;
     59 U4337 ????
     60 U4337 ????	       00 00	   FALSE      equ	0
     61 U4337 ????	       ff ff ff ff TRUE       equ	~FALSE
     62 U4337 ????						;
     63 U4337 ????						;---------------------------------------------------------
     64 U4337 ????						; One of these must be set to indicate which environment
     65 U4337 ????						; Tiny BASIC will be running in.  Here are the current
     66 U4337 ????						; environments:
     67 U4337 ????						;
     68 U4337 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     69 U4337 ????						; more K of RAM.
     70 U4337 ????						;
     71 U4337 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     72 U4337 ????						; which enhances, without replacing, the standard KIM
     73 U4337 ????						; monitor.  It gives access to routines to save/load files
     74 U4337 ????						; to a micro SD card.
     75 U4337 ????						;
     76 U4337 ????						; CTMON65 is a from-scratch monitor written for the
     77 U4337 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     78 U4337 ????						; easily be ported to other systems.  It has support for
     79 U4337 ????						; using a micro SD card for file storage/retrieval.
     80 U4337 ????						;
     81 U4337 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     82 U4337 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     83 U4337 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     84 U4337 ????	       ff ff ff ff IL_DEBUG_TEXT equ	TRUE	;Print out as text IL instructions
     85 U4337 ????						;
     86 U4337 ????						;   Need to define some macros for the dasm assembler
     87 U4337 ????						;
     88 U4337 ????				      MACRO	dw
     89 U4337 ????				      .word	{0}
     90 U4337 ????				      ENDM
     91 U4337 ????
     92 U4337 ????				      MACRO	db
     93 U4337 ????				      .byte	{0}
     94 U4337 ????				      ENDM
     95 U4337 ????
     96 U4337 ????						;
     97 U4337 ????						; If set, include disk functions.
     98 U4337 ????						;
     99 U4337 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
    100 U4337 ????						;
    101 U4337 ????						; If ILTRACE is set then dump out the address of every
    102 U4337 ????						; IL opcode before executing it.
    103 U4337 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    104 U4337 ????						;
    105 U4337 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    106 U4337 ????						;
    107 U4337 ????						; If FIXED is set, put the IL code and the user
    108 U4337 ????						; program space at fixed locations in memory.	This is
    109 U4337 ????						; meant only for debugging.
    110 U4337 ????						;
    111 U4337 ????	       00 00	   FIXED      equ	FALSE
    112 U4337 ????
    113 U4337 ????	       00 0f	   terminalIOblockLen equ	[TerminalIOblockEnd - TerminalIOblock]
    114 U4337 ????
    115 U4337 ????						;
    116 U4337 ????						; Sets the arithmetic stack depth.  This is *TINY*
    117 U4337 ????						; BASIC, so keep this small!
    118 U4337 ????						;
    119 U4337 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    120 U4337 ????	       00 32	   ILSTACKSIZE equ	50	;number of entries in ilstack
    121 U4337 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    122 U4337 ????	       00 25	   VARIABLESSIZE equ	37	;26 variables + 1 for exit code + 10 entries (20bytes) for ioblock
    123 U4337 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    124 U4337 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    125 U4337 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    126 U4337 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    127 U4337 ????
    128 U4337 ????	       00 36	   taskSTDIN  equ	[[VARIABLESSIZE - 10]*2]	;io vector
    129 U4337 ????	       00 38	   taskSTDOUT equ	[[[VARIABLESSIZE - 10]*2]+2]	;io vector
    130 U4337 ????
    131 U4337 ????	       00 3f	   taskIOinPort equ	[[[VARIABLESSIZE - 10]*2]+4+5]	;Offset into the ioblock
    132 U4337 ????	       00 3b	   taskIOoutPort equ	[[[VARIABLESSIZE - 10]*2]+4+1]	;Offset into the ioblock
    133 U4337 ????	       00 46	   taskIOstatusPort equ	[[[VARIABLESSIZE - 10]*2]+4+12]	;Offset into the ioblock
    134 U4337 ????						;
    135 U4337 ????						; Gosub entry types
    136 U4337 ????
    137 U4337 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    138 U4337 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    139 U4337 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    140 U4337 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    141 U4337 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    142 U4337 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    143 U4337 ????						; 0 byte is the original stack offset, byte 1 is the parameter count
    144 U4337 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    145 U4337 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    146 U4337 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    147 U4337 ????						;
    148 U4337 ????						; Common ASCII constants
    149 U4337 ????						;
    150 U4337 ????	       00 07	   BEL	      equ	$07
    151 U4337 ????	       00 08	   BS	      equ	$08
    152 U4337 ????	       00 09	   TAB	      equ	$09
    153 U4337 ????	       00 0a	   LF	      equ	$0A
    154 U4337 ????	       00 0d	   CR	      equ	$0D
    155 U4337 ????	       00 22	   quote      equ	$22
    156 U4337 ????	       00 20	   SPACE      equ	$20
    157 U4337 ????	       00 2c	   COMMA      equ	',
    158 U4337 ????	       00 3b	   SEMICOLON  equ	';
    159 U4337 ????	       00 3a	   COLON      equ	':
    160 U4337 ????	       00 24	   DOLLAR     equ	'$
    161 U4337 ????						;
    162 U4337 ????						; These are error codes
    163 U4337 ????						;
    164 U4337 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    165 U4337 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    166 U4337 ????	       00 02	   ERR_UNDER  equ	2	;The Math stack underflow
    167 U4337 ????	       00 03	   ERR_OVER   equ	3	;The Math stack overflow
    168 U4337 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    169 U4337 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    170 U4337 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    171 U4337 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    172 U4337 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    173 U4337 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    174 U4337 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    175 U4337 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    176 U4337 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;the gosub Stack overflow
    177 U4337 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    178 U4337 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    179 U4337 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    180 U4337 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    181 U4337 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    182 U4337 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    183 U4337 ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    184 U4337 ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    185 U4337 ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    186 U4337 ????	       00 16	   ERR_EXPECTVAR equ	22	;Expected a variable name or definition
    187 U4337 ????	       00 17	   ERR_CLOSINGBRACKET equ	23	;Expected a closing bracket
    188 U4337 ????	       00 18	   ERR_MISSINGEQUALSIGN equ	24	;Expected an equal sign for assignment
    189 U4337 ????	       00 19	   ERR_FUNCTION_EXPECTED_PARAMETERS equ	25	;Function expected parameters
    190 U4337 ????	       00 1a	   ERR_EXPECTED_OPENING_BRACKET equ	26	;Expected opening bracket [ or (
    191 U4337 ????						;
    192 U4337 ????						;=====================================================
    193 U4337 ????						; Zero page storage.
    194 U4337 ????						;
    195 U00f6 ????				      SEG.U	ZEROPAGE
    196 U0040					      org	$0040
    197 U0040
    198 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    199 U0041
    200 U0041							; The context is used to locate a task switch
    201 U0041							; it copies from here till all task fields are saved/swapped
    202 U0041							; The max number of tasks is 256 / context length
    203 U0041							; All positions POS values are plus one task table incldues
    204 U0041							; a leading status byte .
    205 U0041							;
    206 U0041		       00 41	   CONTEXT    equ	*
    207 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    208 U0041
    209 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    210 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    211 U0043
    212 U0043		       00 00	   ILPC       ds	2	; IL program counter
    213 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    214 U0047		       00	   ILSTACKPTR ds	1
    215 U0048
    216 U0048
    217 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    218 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    219 U004a
    220 U004a
    221 U004a		       00	   MATHSTACKPTR ds	1
    222 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    223 U004b
    224 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    225 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT + 1	; Get the offset to the gosub/msg stack
    226 U004d
    227 U004d
    228 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    229 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    230 U004e
    231 U004e
    232 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    233 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    234 U004f							;
    235 U004f							; CURPTR is a pointer to curent BASIC line being
    236 U004f							; executed.  Always points to start of line, CUROFF
    237 U004f							; is the offset to the current character.
    238 U004f							; The order of these fields is important
    239 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    240 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    241 U0052							;
    242 U0052							;The order of these fields in important
    243 U0052
    244 U0052							;
    245 U0052							; R0, R1 and MQ are used for arithmetic operations and
    246 U0052							; general use.
    247 U0052							;
    248 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    249 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    250 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    251 U0056		       00 00	   MQ	      ds	2	;used for some math
    252 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    253 U0058		       00 59	   REGISTERSEND equ	*
    254 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    255 U0059
    256 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    257 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    258 U0059
    259 U0059		       00 00	   dpl	      ds	2	; Used as a pointer to call il instructions
    260 U005b							;
    261 U005b							; This is zero if in immediate mode, or non-zero
    262 U005b							; if currently running a program.  Any input from
    263 U005b							; the main loop clears this, and the XFER IL
    264 U005b							; statement will set it.
    265 U005b							;
    266 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    267 U005c							;
    268 U005c							; Used for line insertion/removal.
    269 U005c							;
    270 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    271 U005e
    272 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    273 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    274 U005e							;
    275 U005e		       00 00	   PrtFrom    ds	2	; FROM
    276 U0060
    277 U0060							;
    278 U0060							;=====================================================
    279 U0060							;
    280  3661 ????				      SEG	Code
    281  0200					      org	$0200
    282  0200							;
    283  0200							; Cold start is at $0200.  Warm start is at $0203.
    284  0200							;
    285  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    286  0203		       4c 82 02    warm       jmp	warm2	;Entry point for worm restart
    287  0206							;
    288  0206							; These are the user-supplied vectors to I/O routines.
    289  0206							; If you want, you can just patch these in the binary
    290  0206							; file, but it would be better to change the source
    291  0206							; code.
    292  0206							;
    293  0206				  -	      if	KIM
    294  0206				  -OUTCH      jmp	$1ea0	;output char in A
    295  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    296  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    297  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    298  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    299  0206					      endif
    300  0206				  -	      if	XKIM
    301  0206				  -	      include	"xkim.inc"
    302  0206				  -	      SEG	Code
    303  0206				  -OUTCH      jmp	$1ea0
    304  0206				  -GETCH      jmp	xkGETCH
    305  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    306  0206				  -OUTHEX     jmp	xkPRTBYT
    307  0206				  -MONITOR    jmp	extKIM
    308  0206				  -puts       equ	putsil
    309  0206				  -BUFFER_SIZE equ	132
    310  0206					      endif
    311  0206
    312  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0060					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    314 Udf8e
    315  0206					      SEG	Code
    316  0206							;
    317  0206		       f0 0c	   OUTCH      equ	cout
    318  0206		       f0 09	   GETCH      equ	cin
    319  0206		       2d 6f	   CRLF       equ	tbcrlf
    320  0206		       21 90	   OUTHEX     equ	HexToOut
    321  0206		       f0 03	   MONITOR    equ	WARM
    322  0206		       f0 0f	   ISCHAR     equ	cstatus
    323  0206		       21 ad	   puts       equ	tbputs
    324  0206					      endif
    325  0206							;
    326  0206		       20 b6 2e    cold2      jsr	SetOutConsole
    327  0209		       20 c3 2e 	      jsr	SetInConsole
    328  020c		       20 ad 21 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      0  0241					      db	CR,LF,0
      1  0241		       0d 0a 00 	      .byte.b	CR,LF,0
    332  0244							;
    333  0244		       20 a1 23 	      jsr	MemInit	;setup the free space available
    334  0247
    335  0247		       a9 01	   calcstack  lda	#1
    336  0249		       8d b3 37 	      sta	taskCounter	; Initialize number of tasks to 1
    337  024c		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    338  024e		       8d b5 36 	      sta	taskTable	; mark the main task as active
    339  0251		       20 ee 25 	      jsr	taskSetStacks	; setup all the task stacks/Variables, Init task io block
    340  0254		       a9 f3		      lda	#IL&$ff
    341  0256		       85 43		      sta	ILPC
    342  0258		       a9 31		      lda	#IL>>8
    343  025a		       85 44		      sta	ILPC+1
    344  025c							;
    345  025c							;		  lda	  ProgramStart		     ; user prog
    346  025c							;		  sta	  ProgramEnd
    347  025c							;		  lda	  ProgramStart+1
    348  025c							;		  sta	  ProgramEnd+1
    349  025c							;
    350  025c
    351  025c							;  Init time slices defaults
    352  025c		       a9 02		      lda	#TASKCYCLESHIGH
    353  025e		       8d b2 37 	      sta	taskResetValue+1
    354  0261		       a9 ff		      lda	#TASKCYCLESDEFAULT
    355  0263		       8d b1 37 	      sta	taskResetValue
    356  0266							;
    357  0266							; Initialize the pseudo-random number sequence...
    358  0266							;
    359  0266		       a9 5a		      lda	#$5a
    360  0268		       8d 1d 43 	      sta	rtemp1
    361  026b		       a9 9d		      lda	#%10011101
    362  026d		       8d 1f 43 	      sta	random
    363  0270		       a9 5b		      lda	#%01011011
    364  0272		       8d 20 43 	      sta	random+1
    365  0275							;
    366  0275							;   Insert a Basic irq handler for the basic Language
    367  0275		       a9 33		      lda	#ServiceIrq&$ff
    368  0277		       8d 00 df 	      sta	IRQvec
    369  027a		       a9 1a		      lda	#ServiceIrq>>8
    370  027c		       8d 01 df 	      sta	IRQvec+1
    371  027f		       4c 95 02 	      jmp	coldtwo
    372  0282
    373  0282							;
    374  0282							;
    375  0282							; This is the warm start entry point
    376  0282							;
    377  0282		       20 b6 2e    warm2      jsr	SetOutConsole
    378  0285		       20 c3 2e 	      jsr	SetInConsole
    379  0288		       20 6f 2d 	      jsr	CRLF
    380  028b		       ad 1a 43 	      lda	errGoto
    381  028e		       85 43		      sta	ILPC
    382  0290		       ad 1b 43 	      lda	errGoto+1
    383  0293		       85 44		      sta	ILPC+1
    384  0295							;
    385  0295							; And continue with both starts here
    386  0295							;
    387  0295				   coldtwo
    388  0295							;
    389  0295							; The ILTrace flag is now run-time settable.
    390  0295							;
    391  0295		       a9 00		      lda	#ILTRACE&$ff
    392  0297		       85 40		      sta	ILTrace
    393  0299							;
    394  0299
    395  0299		       a9 00		      lda	#0
    396  029b		       85 5b		      sta	RunMode
    397  029d		       8d 90 42 	      sta	LINBUF
    398  02a0
    399  02a0							; Clear everything from the stacks
    400  02a0
    401  02a0		       8d 27 43 	      sta	taskIOPending	; No one waiting for io
    402  02a3		       8d 28 43 	      sta	taskRDPending	; No one waiting for bg io
    403  02a6
    404  02a6		       20 6a 26 	      jsr	taskReset
    405  02a9							;
    406  02a9		       a9 90		      lda	#LINBUF&$ff
    407  02ab		       85 4f		      sta	CURPTR
    408  02ad		       a9 42		      lda	#LINBUF>>8
    409  02af		       85 50		      sta	CURPTR+1	;fall through...
    410  02b1
    411  02b1							;=====================================================
    412  02b1							; This is the top of the IL interpreter.  This fetches
    413  02b1							; and executes the instruction currently pointed to
    414  02b1							; by ILPC and adjusts ILPC to point to the next
    415  02b1							; instruction to execute.
    416  02b1							;
    417  02b1				   NextIL
    418  02b1		       ba		      tsx		; Get the stack pointer value
    419  02b2		       e0 ff		      cpx	#$FF	; Should be empty
    420  02b4		       d0 29		      bne	ILbad	; Halt and catch fire now!
    421  02b6
    422  02b6		       ce af 37 	      dec	taskCurrentCycles
    423  02b9		       d0 03		      bne	NextIlNow
    424  02bb		       20 93 26 	      jsr	iTaskSwitch	;check for a task switch
    425  02be		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    426  02c0		       f0 03		      beq	NextIL2	;Skip if no bits set
    427  02c2
    428  02c2		       20 00 2e 	      jsr	dbgLine	;Print the IL trace information
    429  02c5
    430  02c5		       a4 51	   NextIL2    ldy	CUROFF
    431  02c7							;		  jsr	  SkipSpaces	       ; no longer needed as tokenizer takes care of this
    432  02c7							;		  sty	  CUROFF
    433  02c7							;Task IO Management
    434  02c7		       ad 28 43 	      lda	taskRDPending	; if it is zero then Nothing pending
    435  02ca		       f0 08		      beq	NextILStr
    436  02cc		       20 a8 2b 	      jsr	ReadLine	; else Pending and poll keyboard
    437  02cf		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    438  02d1		       ce 28 43 	      dec	taskRDPending	; Carry is set if CR has been recieved
    439  02d4							;
    440  02d4		       20 2b 2a    NextILStr  jsr	getILByte
    441  02d7							;
    442  02d7							; When the handler is called, these are the conditions
    443  02d7							; of several important items:
    444  02d7							;
    445  02d7							;    (ILPC) will point to the byte AFTER the IL
    446  02d7							;    opcode being executed.
    447  02d7							;
    448  02d7							;    (CURPTR),CUROFF will point to the start of the
    449  02d7							;    next word in the input buffer.  Ie, the next word
    450  02d7							;    in the user program.
    451  02d7							;
    452  02d7		       18		      clc		; Clear carry before shift
    453  02d8		       0a		      asl		; valid for 0-127
    454  02d9		       b0 04		      bcs	ILbad	; Out of range
    455  02db		       aa		      tax		; Move value to x
      0  02dc					      db	$7c	; jmp (ILTBL,X) ; dasm does not support 65c02 inst
      1  02dc		       7c		      .byte.b	$7c
      0  02dd					      dw	ILTBL	; Actual IL table address
      1  02dd		       20 03		      .word.w	ILTBL
    458  02df
    459  02df							;		asl
    460  02df							;		cmp	#ILTBLend-ILTBL+2
    461  02df							;		bcc	ILgood
    462  02df							;
    463  02df							; This handles an illegal IL opcode.  This is serious
    464  02df							; and there's no way to recover.
    465  02df							;
    466  02df				   iBadOP
    467  02df		       20 ad 21    ILbad      jsr	puts
      0  02e2					      db	CR,LF
      1  02e2		       0d 0a		      .byte.b	CR,LF
      0  02e4					      db	"Illegal IL "
      1  02e4		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02ef					      db	0
      1  02ef		       00		      .byte.b	0
    471  02f0							;
    472  02f0							; Well this is awkward, we need to back up the IL
    473  02f0							; by one since it no longer points to the current
    474  02f0							; opcode.
    475  02f0							;
    476  02f0		       20 38 2a 	      jsr	decIL
    477  02f3							;
    478  02f3		       a0 00		      ldy	#0
    479  02f5		       b1 43		      lda	(ILPC),y
    480  02f7		       20 90 21 	      jsr	OUTHEX
    481  02fa		       20 ad 21 	      jsr	puts
      0  02fd					      db	" at ",0
      1  02fd		       20 61 74 20*	      .byte.b	" at ",0
    483  0302		       a5 44		      lda	ILPC+1
    484  0304		       20 90 21 	      jsr	OUTHEX
    485  0307		       a5 43		      lda	ILPC
    486  0309		       20 90 21 	      jsr	OUTHEX
    487  030c		       20 6f 2d 	      jsr	CRLF
    488  030f		       4c 03 f0 	      jmp	MONITOR
    489  0312							;
    490  0312							; Just jump to the address (ILPC),y.  Have to do
    491  0312							; some goofy stuff.
    492  0312							;
    493  0312		       a8	   ILgood     tay		;move index into Y
    494  0313		       b9 20 03 	      lda	ILTBL,y
    495  0316		       85 59		      sta	dpl
    496  0318		       b9 21 03 	      lda	ILTBL+1,y
    497  031b		       85 5a		      sta	dpl+1
    498  031d		       6c 59 00 	      jmp	(dpl)	;go to handler
    499  0320							;
    500  0320							;=====================================================
    501  0320							; This is the IL jump table.  The IL opcode is
    502  0320							; mulitplied by two, then looked-up in this table.
    503  0320							; There is absolutely nothing special about the order
    504  0320							; of entries here... they all decode at exactly the
    505  0320							; same speed.	However the entry number must match the
    506  0320							; values in IL.inc.
    507  0320							;
    508  0320				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0320					      include	"ilvectortable.asm"
      1  0320					      seg	Code
      2  0320				   ILTBL1
      0  0320					      dw	iXINIT	;0
      1  0320		       58 04		      .word.w	iXINIT
      0  0322					      dw	iDONE	;1
      1  0322		       75 04		      .word.w	iDONE
      0  0324					      dw	iPRS	;2
      1  0324		       8c 04		      .word.w	iPRS
      0  0326					      dw	iPRN	;3
      1  0326		       94 04		      .word.w	iPRN
      0  0328					      dw	iSPC	;4
      1  0328		       9d 04		      .word.w	iSPC
      0  032a					      dw	iNLINE	;5
      1  032a		       44 09		      .word.w	iNLINE
      0  032c					      dw	iNXT	;6
      1  032c		       a5 04		      .word.w	iNXT
      0  032e					      dw	iXFER	;7
      1  032e		       e7 04		      .word.w	iXFER
      0  0330					      dw	iSAV	;8
      1  0330		       05 05		      .word.w	iSAV
      0  0332					      dw	iRSTR	;9
      1  0332		       69 25		      .word.w	iRSTR
      0  0334					      dw	iCMPR	;10
      1  0334		       4b 05		      .word.w	iCMPR
      0  0336					      dw	iINNUM	;11
      1  0336		       ca 05		      .word.w	iINNUM
      0  0338					      dw	iFIN	;12
      1  0338		       02 06		      .word.w	iFIN
      0  033a					      dw	iERR	;13
      1  033a		       16 06		      .word.w	iERR
      0  033c					      dw	iADD	;14
      1  033c		       9f 06		      .word.w	iADD
      0  033e					      dw	iSUB	;15
      1  033e		       b5 06		      .word.w	iSUB
      0  0340					      dw	iNEG	;16
      1  0340		       cb 06		      .word.w	iNEG
      0  0342					      dw	iMUL	;17
      1  0342		       e3 06		      .word.w	iMUL
      0  0344					      dw	iDIV	;18
      1  0344		       23 07		      .word.w	iDIV
      0  0346					      dw	iSTORE	;19
      1  0346		       7b 07		      .word.w	iSTORE
      0  0348					      dw	iIND	;20
      1  0348		       99 07		      .word.w	iIND
      0  034a					      dw	iLST	;21
      1  034a		       3a 08		      .word.w	iLST
      0  034c					      dw	iINIT	;22
      1  034c		       20 04		      .word.w	iINIT
      0  034e					      dw	iGETLINE	;23
      1  034e		       70 08		      .word.w	iGETLINE
      0  0350					      dw	iINSRT	;24
      1  0350		       8d 08		      .word.w	iINSRT
      0  0352					      dw	iRTN	;25
      1  0352		       3e 09		      .word.w	iRTN
      0  0354					      dw	MONITOR	;26
      1  0354		       03 f0		      .word.w	MONITOR
      0  0356					      dw	iLIT	;27
      1  0356		       68 09		      .word.w	iLIT
      0  0358					      dw	iCALL	;28
      1  0358		       4a 09		      .word.w	iCALL
      0  035a					      dw	iJMP	;29
      1  035a		       56 09		      .word.w	iJMP
      0  035c					      dw	iVINIT	;30
      1  035c		       8d 09		      .word.w	iVINIT
      0  035e					      dw	iERRGOTO	;31
      1  035e		       96 09		      .word.w	iERRGOTO
      0  0360					      dw	iTST	;32
      1  0360		       a2 09		      .word.w	iTST
      0  0362					      dw	iTSTV	;33
      1  0362		       c7 0a		      .word.w	iTSTV
      0  0364					      dw	iTSTL	;34
      1  0364		       6d 0b		      .word.w	iTSTL
      0  0366					      dw	iTSTN	;35
      1  0366		       88 0b		      .word.w	iTSTN
      0  0368					      dw	iFREE	;36
      1  0368		       41 0c		      .word.w	iFREE
      0  036a					      dw	iRANDOM	;37
      1  036a		       47 0c		      .word.w	iRANDOM
      0  036c					      dw	iABS	;38
      1  036c		       18 0d		      .word.w	iABS
     42  036e							;
     43  036e							; Disk functions.  There must be pointers
     44  036e							; to functions even if no disk is supported.
     45  036e							; Makes things easier in IL.inc.
     46  036e							;
     47  036e					      if	DISK_ACCESS
      0  036e					      dw	iOPENREAD	;39
      1  036e		       0f 30		      .word.w	iOPENREAD
      0  0370					      dw	iOPENWRITE	;40
      1  0370		       70 30		      .word.w	iOPENWRITE
      0  0372					      dw	iDCLOSE	;41
      1  0372		       04 31		      .word.w	iDCLOSE
      0  0374					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0374		       92 30		      .word.w	iDGETLINE
      0  0376					      dw	iDLIST	;43 Did you remember your towel?
      1  0376		       fe 30		      .word.w	iDLIST
      0  0378					      dw	iDDIR	;44
      1  0378		       d9 30		      .word.w	iDDIR
      0  037a					      dw	iRMFILE	;45
      1  037a		       5e 30		      .word.w	iRMFILE
     55  037c				  -	      else
     56  037c				  -	      dw	NextIL	;39
     57  037c				  -	      dw	NextIL	;40
     58  037c				  -	      dw	NextIL	;41
     59  037c				  -	      dw	NextIL	;42
     60  037c				  -	      dw	NextIL	;43
     61  037c				  -	      dw	NextIL	;44
     62  037c				  -	      dw	NextIL	;45
     63  037c					      endif
     64  037c							;
      0  037c					      dw	iCLEARSCREEN	;46
      1  037c		       d0 2e		      .word.w	iCLEARSCREEN
      0  037e					      dw	iPOKEMEMORY	;47
      1  037e		       a5 0c		      .word.w	iPOKEMEMORY
      0  0380					      dw	iPEEKMEMORY	;48
      1  0380		       ba 0c		      .word.w	iPEEKMEMORY
      0  0382					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0382		       e9 09		      .word.w	iTSTLET
      0  0384					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0384		       6e 0a		      .word.w	iTSTDONE
      0  0386					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0386		       e7 0c		      .word.w	iGETCHAR
      0  0388					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0388		       fb 0c		      .word.w	iPUTCHAR
      0  038a					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  038a		       d0 0c		      .word.w	iCallFunc
      0  038c					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  038c		       98 05		      .word.w	iBranch
      0  038e					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  038e		       cc 09		      .word.w	iTSTStr
      0  0390					      dw	iSetIrq	;56	   sets the irq handler
      1  0390		       bf 0d		      .word.w	iSetIrq
      0  0392					      dw	iTstIrq	;57	   test if irq is pending
      1  0392		       ff 0b		      .word.w	iTstIrq
      0  0394					      dw	iRET	;58	   return from interupt
      1  0394		       39 05		      .word.w	iRET
      0  0396					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0396		       e3 05		      .word.w	iINSTR
      0  0398					      dw	iMOD	;60	   returns remainder of division
      1  0398		       2c 07		      .word.w	iMOD
      0  039a					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  039a		       e7 26		      .word.w	iTaskSet
      0  039c					      dw	iETask	;62	   Terminates a task
      1  039c		       24 28		      .word.w	iETask
      0  039e					      dw	iNTask	;63	   goto next task
      1  039e		       d7 27		      .word.w	iNTask
     83  03a0				   ILTBL2
      0  03a0					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a0		       b8 07		      .word.w	iArray
      0  03a2					      dw	iTaskKill	;65	   kill a running task
      1  03a2		       cf 27		      .word.w	iTaskKill
      0  03a4					      dw	iTaskStat	;66	   return the state of a task PID
      1  03a4		       a3 27		      .word.w	iTaskStat
      0  03a6					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03a6		       06 0d		      .word.w	iHexOut
      0  03a8					      dw	iReadComplete	;68	   Called after a background read completes
      1  03a8		       b4 05		      .word.w	iReadComplete
      0  03aa					      dw	iReadStart	;69	   Called to start a background read request
      1  03aa		       aa 05		      .word.w	iReadStart
      0  03ac					      dw	iStartIO	;70	   Lock task until io complete
      1  03ac		       07 28		      .word.w	iStartIO
      0  03ae					      dw	iEndIO	;71	   release task lock for io
      1  03ae		       0d 28		      .word.w	iEndIO
      0  03b0					      dw	iLogNot	;72	   Logical not
      1  03b0		       71 0d		      .word.w	iLogNot
      0  03b2					      dw	iLogOr	;73	   Logical Or
      1  03b2		       47 0d		      .word.w	iLogOr
      0  03b4					      dw	iLogAnd	;74	   Logical And
      1  03b4		       32 0d		      .word.w	iLogAnd
      0  03b6					      dw	iLogXor	;75	   Logical Xor
      1  03b6		       5c 0d		      .word.w	iLogXor
      0  03b8					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03b8		       e2 27		      .word.w	iWTASK
      0  03ba					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03ba		       18 28		      .word.w	iTASKPID
      0  03bc					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03bc		       fd 0d		      .word.w	iTRACEPROG
      0  03be					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03be		       7c 2d		      .word.w	idbgBasic
      0  03c0					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c0		       04 29		      .word.w	iIPCS
      0  03c2					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c2		       1b 29		      .word.w	iIPCR
      0  03c4					      dw	iIPCC	;82	   Check if any message available for task
      1  03c4		       2f 29		      .word.w	iIPCC
      0  03c6					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03c6		       3c 29		      .word.w	iIPCIO
      0  03c8					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03c8		       cf 24		      .word.w	iPushMathStack
      0  03ca					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03ca		       ff 24		      .word.w	iPopMathStack
      0  03cc					      dw	iSaveMathStack	;86	   Save all math info
      1  03cc		       1c 25		      .word.w	iSaveMathStack
      0  03ce					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03ce		       3b 25		      .word.w	iRestoreMathStack
      0  03d0					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d0		       ec 24		      .word.w	iIncParmCount
      0  03d2					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d2		       44 28		      .word.w	iTaskGetMathStack
      0  03d4					      dw	iTaskEnable	;90	   enable a suspended task
      1  03d4		       71 27		      .word.w	iTaskEnable
      0  03d6					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03d6		       8b 27		      .word.w	iTaskSuspend
      0  03d8					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03d8		       5e 28		      .word.w	iTaskPutMathPtr
      0  03da					      dw	iTSTVT	;93	   test for another tasks variable
      1  03da		       be 0a		      .word.w	iTSTVT
      0  03dc					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03dc		       60 09		      .word.w	iSetR2
      0  03de					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03de		       17 05		      .word.w	iStk2Tmp
      0  03e0					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e0		       28 05		      .word.w	iTmp2Stk
      0  03e2					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e2		       0a 0a		      .word.w	iTSTBYTE
      0  03e4					      dw	iINCVAR	;98	   Increment variable
      1  03e4		       90 0a		      .word.w	iINCVAR
      0  03e6					      dw	iDECVAR	;99	   Decrement variable
      1  03e6		       a8 0a		      .word.w	iDECVAR
      0  03e8					      dw	iSLICE	;100	   set the time slice for tasks
      1  03e8		       97 28		      .word.w	iSLICE
      0  03ea					      dw	iTSTB	;101	   Test if byte equals
      1  03ea		       29 0a		      .word.w	iTSTB
      0  03ec					      dw	iTSTW	;102	   Test If word equals
      1  03ec		       44 0a		      .word.w	iTSTW
      0  03ee					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03ee		       46 1f		      .word.w	iOnGoto
      0  03f0					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03f0		       77 1f		      .word.w	iTSTRELOP
      0  03f2					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03f2		       cb 04		      .word.w	iRepeatLine
      0  03f4					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch if is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03f4		       9e 1f		      .word.w	iTSTBRANCH
      0  03f6					      dw	iFastXfer	;107	   move top of stack to curptr
      1  03f6		       d2 04		      .word.w	iFastXfer
      0  03f8					      dw	iSetTerminal	;108	   Set the Io Terminal to be used by print and input statements
      1  03f8		       52 2f		      .word.w	iSetTerminal
      0  03fa					      dw	iINDB	;109	   fetch a single byte from memory indirect
      1  03fa		       a6 07		      .word.w	iINDB
      0  03fc					      dw	iSetBlock	;110	   Set a block or words or byte to a value 16 bit length
      1  03fc		       f6 23		      .word.w	iSetBlock
      0  03fe					      dw	iCopyBlock	;111	   Copy a block or memory from one location to another 16 bit length
      1  03fe		       4c 24		      .word.w	iCopyBlock
      0  0400					      dw	iCmpBlock	;112	   Compare to parts of memory
      1  0400		       80 24		      .word.w	iCmpBlock
      0  0402					      dw	iShift	;113	   Shift left 0 or right 1
      1  0402		       95 0d		      .word.w	iShift
      0  0404					      dw	iTimer	;114	   Start/Stop/Set timer and enable disable system irq
      1  0404		       74 19		      .word.w	iTimer
    135  0406
      0  0406					      dw	iBadOP	;115	   Invalid IL op code
      1  0406		       df 02		      .word.w	iBadOP
      0  0408					      dw	iBadOP	;116	   Invalid IL op code
      1  0408		       df 02		      .word.w	iBadOP
      0  040a					      dw	iBadOP	;117	   Invalid IL op code
      1  040a		       df 02		      .word.w	iBadOP
      0  040c					      dw	iBadOP	;118	   Invalid IL op code
      1  040c		       df 02		      .word.w	iBadOP
      0  040e					      dw	iBadOP	;119	   Invalid IL op code
      1  040e		       df 02		      .word.w	iBadOP
      0  0410					      dw	iBadOP	;120	   Invalid IL op code
      1  0410		       df 02		      .word.w	iBadOP
      0  0412					      dw	iBadOP	;121	   Invalid IL op code
      1  0412		       df 02		      .word.w	iBadOP
      0  0414					      dw	iBadOP	;122	   Invalid IL op code
      1  0414		       df 02		      .word.w	iBadOP
      0  0416					      dw	iBadOP	;123	   Invalid IL op code
      1  0416		       df 02		      .word.w	iBadOP
      0  0418					      dw	iBadOP	;124	   Invalid IL op code
      1  0418		       df 02		      .word.w	iBadOP
      0  041a					      dw	iBadOP	;125	   Invalid IL op code
      1  041a		       df 02		      .word.w	iBadOP
      0  041c					      dw	iBadOP	;126	   Invalid IL op code
      1  041c		       df 02		      .word.w	iBadOP
      0  041e					      dw	iBadOP	;127	   Invalid IL op code
      1  041e		       df 02		      .word.w	iBadOP
    149  0420
    150  0420
    151  0420
    152  0420
------- FILE mytb.asm
    510  0420		       04 20	   ILTBLend   equ	*
    511  0420
    512  0420							;
    513  0420							;=====================================================
    514  0420							;=====================================================
    515  0420							;=====================================================
    516  0420							; This marks the start of the handlers for IL opcodes.
    517  0420							;=====================================================
    518  0420							;=====================================================
    519  0420							;=====================================================
    520  0420							;
    521  0420							;
    522  0420		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    523  0422		       85 47		      sta	ILSTACKPTR
    524  0424		       85 4a		      sta	MATHSTACKPTR
    525  0426		       85 4d		      sta	GOSUBSTACKPTR
    526  0428		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    527  042a		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    528  042c							;
    529  042c		       ad 2d 43 	      lda	ProgramStart	; user prog
    530  042f		       85 4f		      sta	CURPTR
    531  0431		       8d b6 36 	      sta	taskTable+1
    532  0434		       8d 2f 43 	      sta	ProgramEnd
    533  0437		       ad 2e 43 	      lda	ProgramStart+1
    534  043a		       85 50		      sta	CURPTR+1
    535  043c		       8d b7 36 	      sta	taskTable+2
    536  043f		       8d 30 43 	      sta	ProgramEnd+1
    537  0442		       a9 80		      lda	#TASKACTIVE
    538  0444		       8d b5 36 	      sta	taskTable	;Mark the first slot as active
    539  0447		       a9 01		      lda	#1
    540  0449		       8d b3 37 	      sta	taskCounter	;there is always one task / Main task
    541  044c		       ad b1 37 	      lda	taskResetValue
    542  044f		       8d af 37 	      sta	taskCurrentCycles	; set up the task switch counts
    543  0452		       ad b2 37 	      lda	taskResetValue+1
    544  0455		       8d b0 37 	      sta	taskCurrentCycles+1
    545  0458							;
    546  0458							; fall into XINIT...
    547  0458							;
    548  0458							;=====================================================
    549  0458							; This initializes for the start of the next line of
    550  0458							; BASIC text.
    551  0458							;
    552  0458		       78	   iXINIT     sei		; ensure interupts are off
    553  0459		       20 6a 26 	      jsr	taskReset	; Clear the task table
    554  045c		       a9 00		      lda	#0	; Clear the irq flags
    555  045e		       8d b8 19 	      sta	IRQPending	; reset the irq pending
    556  0461		       8d b7 19 	      sta	IRQStatus	; Make sure irqs are off
    557  0464
    558  0464		       4c b1 02    goodExit   jmp	NextIL
    559  0467							;
    560  0467							;=====================================================
    561  0467							; This check if the escape key has been entered
    562  0467							; then changes out of run mode. z Set if esc found
    563  0467				   BreakSet
    564  0467		       20 0f f0 	      jsr	ISCHAR
    565  046a		       f0 06		      beq	BreakNo
    566  046c		       20 58 1a 	      jsr	VGETCH
    567  046f		       c9 1b		      cmp	#$1B
    568  0471		       60		      rts
    569  0472				   BreakNo
    570  0472		       a9 01		      lda	#1
    571  0474		       60		      rts
    572  0475
    573  0475							;
    574  0475
    575  0475							;=====================================================
    576  0475							; Verify there is nothing else on this input line.
    577  0475							; If there is, generate an error.
    578  0475							;
    579  0475		       a4 51	   iDONE      ldy	CUROFF
    580  0477		       b1 4f		      lda	(CURPTR),y
    581  0479		       f0 0e		      beq	doneadv
    582  047b		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    583  047d		       d0 03		      bne	idoneErr
    584  047f							;		  sty	  CUROFF
    585  047f		       4c b1 02 	      jmp	NextIL	; continue on this line
    586  0482
    587  0482				   idoneErr
    588  0482		       a2 04		      ldx	#ERR_EXTRA_STUFF
    589  0484		       a9 00		      lda	#0
    590  0486		       4c 7d 06 	      jmp	iErr2
    591  0489							;
    592  0489							; Advance to the next line
    593  0489							;
    594  0489				   doneadv
    595  0489		       4c b1 02 	      jmp	NextIL
    596  048c							;
    597  048c							;=====================================================
    598  048c							; Print the string until a closing quote
    599  048c							;
    600  048c				   iPRS
    601  048c		       20 d0 21 	      jsr	PrtQuoted
    602  048f		       84 51		      sty	CUROFF
    603  0491		       4c b1 02 	      jmp	NextIL
    604  0494							;
    605  0494							;=====================================================
    606  0494							; Pop the top off the stack and print it as a signed
    607  0494							; decimal number.
    608  0494							;
    609  0494				   iPRN
    610  0494		       20 b6 2c 	      jsr	popR0
    611  0497		       20 dc 20 	      jsr	PrintDecimal
    612  049a		       4c b1 02 	      jmp	NextIL
    613  049d							;
    614  049d							;=====================================================
    615  049d							; Space to next zone.	Currently the code does not
    616  049d							; keep track of which column the output is on, so
    617  049d							; just print a tab.
    618  049d							;
    619  049d				   iSPC
    620  049d		       a9 09		      lda	#TAB
    621  049f		       20 55 1a 	      jsr	VOUTCH
    622  04a2		       4c b1 02 	      jmp	NextIL
    623  04a5							;
    624  04a5							;=====================================================
    625  04a5							; If in immediate mode, jump to the address following
    626  04a5							; the NXT instruction.  Else move to the next line of
    627  04a5							; user code and continue.
    628  04a5							;
    629  04a5		       a5 5b	   iNXT       lda	RunMode
    630  04a7		       d0 03		      bne	iNxtRun	;in run mode
    631  04a9							;
    632  04a9							; Get address and jump to it.
    633  04a9							;
    634  04a9		       4c 56 09 	      jmp	iJMP
    635  04ac							;
    636  04ac				   iNxtRun
    637  04ac		       a4 51		      ldy	CUROFF
    638  04ae		       b1 4f		      lda	(CURPTR),y
    639  04b0		       c9 e6		      cmp	#oColon
    640  04b2		       d0 06		      bne	iNxtRunGo
    641  04b4		       c8		      iny
    642  04b5		       84 51		      sty	CUROFF
    643  04b7		       4c c5 04 	      jmp	iNxtRun2
    644  04ba
    645  04ba				   iNxtRunGo
    646  04ba		       20 b5 2a 	      jsr	FindNextLine
    647  04bd		       20 c9 2a 	      jsr	AtEnd
    648  04c0		       d0 03		      bne	iNxtRun2	;not at end
    649  04c2							;
    650  04c2							; At the end of the program.  Pretend an END statement
    651  04c2							; was found.
    652  04c2							;
    653  04c2		       4c 02 06    iFINv      jmp	iFIN
    654  04c5							;
    655  04c5		       20 27 2a    iNxtRun2   jsr	getILWord	;ignore next word
    656  04c8		       4c b1 02 	      jmp	NextIL
    657  04cb							;=====================================================
    658  04cb							;Repeat the same line against
    659  04cb		       a0 03	   iRepeatLine ldy	#3
    660  04cd		       84 51		      sty	CUROFF
    661  04cf		       4c b1 02 	      jmp	NextIL
    662  04d2							;
    663  04d2							;=====================================================
    664  04d2							; XFER takes the number on top of the stack and looks
    665  04d2							; for that line in the program, or the next line
    666  04d2							; higher.  Ie, if it's 1 but there is no line 1, then
    667  04d2							; find the next one after that.
    668  04d2							;
    669  04d2				   iFastXfer
    670  04d2		       20 ce 2c 	      jsr	popR1	; get type of transfer
    671  04d5		       a5 54		      lda	R1
    672  04d7		       f0 0e		      beq	iXFER
    673  04d9
    674  04d9		       20 b6 2c 	      jsr	popR0	; get where to transfer
    675  04dc				   FastFastXfer
    676  04dc		       a5 52		      lda	R0
    677  04de		       85 4f		      sta	CURPTR
    678  04e0		       a5 53		      lda	R0+1
    679  04e2		       85 50		      sta	CURPTR+1
    680  04e4		       4c ed 04 	      jmp	iXFER2
    681  04e7
    682  04e7				   iXFER
    683  04e7		       20 b6 2c 	      jsr	popR0
    684  04ea		       20 70 2a 	      jsr	findLine
    685  04ed
    686  04ed				   iXFER2
    687  04ed		       20 c9 2a 	      jsr	AtEnd	;at end of user program?
    688  04f0		       f0 d0		      beq	iFINv
    689  04f2
    690  04f2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    691  04f4		       84 51		      sty	CUROFF
    692  04f6
    693  04f6							;		  lda	  #$ff
    694  04f6							;		  sta	  RunMode
    695  04f6							;
    696  04f6							; Transfer IL to STMT.  I don't like having this
    697  04f6							; hard-coded; fix it.
    698  04f6							;
    699  04f6							;		  lda	  #STMT&$ff
    700  04f6							;		  sta	  ILPC
    701  04f6							;		  lda	  #STMT>>8
    702  04f6							;		  sta	  ILPC+1
    703  04f6							;		  jmp	  NextIL
    704  04f6							;
    705  04f6							; Run
    706  04f6							;
    707  04f6				   iXferok
    708  04f6		       a9 ff		      lda	#$ff
    709  04f8		       85 5b		      sta	RunMode	;we're running
    710  04fa							;
    711  04fa							; Need a more elegant way to do this
    712  04fa							;
    713  04fa		       a9 01		      lda	#STMT&$ff
    714  04fc		       85 43		      sta	ILPC
    715  04fe		       a9 32		      lda	#STMT>>8
    716  0500		       85 44		      sta	ILPC+1
    717  0502		       4c b1 02 	      jmp	NextIL
    718  0505							;
    719  0505							;=====================================================
    720  0505							; Save the pointer to the next line to the call stack.
    721  0505							;
    722  0505		       20 2b 2a    iSAV       jsr	getILByte	; load type of gosub
    723  0508		       20 3e 2c 	      jsr	pushLN	; Type passed in A
    724  050b		       b0 03		      bcs	iSAVErr
    725  050d		       4c b1 02 	      jmp	NextIL
    726  0510
    727  0510		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    728  0512		       a9 00	   iSAVErr2   lda	#0
    729  0514		       4c 7d 06 	      jmp	iErr2
    730  0517							;====================================================
    731  0517							; Move stack top to and from temp area
    732  0517				   iStk2Tmp
    733  0517		       20 b6 2c 	      jsr	popR0
    734  051a		       a5 52		      lda	R0
    735  051c		       a0 48		      ldy	#TASKEXITCODE	; can also be used as temp
    736  051e		       91 41		      sta	(VARIABLES),y
    737  0520		       c8		      iny
    738  0521		       a5 53		      lda	R0+1
    739  0523		       91 41		      sta	(VARIABLES),y
    740  0525		       4c b1 02 	      jmp	NextIL
    741  0528
    742  0528		       a0 48	   iTmp2Stk   ldy	#TASKEXITCODE
    743  052a		       b1 41		      lda	(VARIABLES),y
    744  052c		       85 52		      sta	R0
    745  052e		       c8		      iny
    746  052f		       b1 41		      lda	(VARIABLES),y
    747  0531		       85 53		      sta	R0+1
    748  0533		       20 24 2c 	      jsr	pushR0
    749  0536		       4c b1 02 	      jmp	NextIL
    750  0539							;
    751  0539							;=====================================================
    752  0539							; Pop the next line from the call stack. IRQ return
    753  0539							;
    754  0539		       20 67 2c    iRET       jsr	popLN
    755  053c		       b0 d2		      bcs	iSAVErr
    756  053e		       a0 03		      ldy	#3
    757  0540		       84 51		      sty	CUROFF
    758  0542		       a9 00		      lda	#0
    759  0544		       8d b8 19 	      sta	IRQPending
    760  0547		       58		      cli
    761  0548		       4c b1 02 	      jmp	NextIL
    762  054b							;
    763  054b							;=====================================================
    764  054b							; Compare items on stack.  Okay, so on input there are
    765  054b							; three things on the stack
    766  054b							;
    767  054b							;    EXPR2 <- Top of stack
    768  054b							;    OP    <- relational operator, next on stack
    769  054b							;    EXPR1 <- last item on stack
    770  054b							;
    771  054b							; Comparison is: EXPR1 <operator> EXPR2
    772  054b							;
    773  054b							; Operator is one of...
    774  054b							;
    775  054b							;    2 is =
    776  054b							;    1 is <
    777  054b							;    3 is <=
    778  054b							;    5 is <>
    779  054b							;    4 is >
    780  054b							;    6 is >=
    781  054b							;
    782  054b							; Those are bit-mapped:
    783  054b							;
    784  054b							;    xxxxxGEL
    785  054b							;
    786  054b							;    G = Greater than
    787  054b							;    E = Equal
    788  054b							;    L = Less than
    789  054b							;
    790  054b							; If the comparison is false, do a NXT, ie, move to the
    791  054b							; next line and continue.  If true, continue executing
    792  054b							; on this line.
    793  054b							;
    794  054b		       00 01	   REL_LT     equ	%001
    795  054b		       00 02	   REL_EQUAL  equ	%010
    796  054b		       00 04	   REL_GT     equ	%100
    797  054b							;
    798  054b		       20 ce 2c    iCMPR      jsr	popR1
    799  054e		       20 e5 2c 	      jsr	popMQ	;operator in MQ
    800  0551		       20 b6 2c 	      jsr	popR0
    801  0554		       20 5d 05 	      jsr	iCMPRsub
    802  0557		       20 24 2c 	      jsr	pushR0
    803  055a		       4c b1 02 	      jmp	NextIL
    804  055d							;
    805  055d							; See if they are equal or not
    806  055d							;
    807  055d				   iCMPRsub		; Called by internal functions
    808  055d
    809  055d		       a5 52		      lda	R0
    810  055f		       c5 54		      cmp	R1
    811  0561		       d0 0a		      bne	iCMPRnoteq	;try not equal
    812  0563		       a5 53		      lda	R0+1
    813  0565		       c5 55		      cmp	R1+1
    814  0567		       d0 04		      bne	iCMPRnoteq
    815  0569							;
    816  0569							; Equal, set the flag in MQ+1
    817  0569							;
    818  0569		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    819  056b		       d0 14		      bne	iCMPcom	;Exit it is equal
    820  056d							;
    821  056d							; See if EXPR1 (R0) < EXPR2 (R1)
    822  056d							; See www.6502.org/tutorials/compare_beyond.html
    823  056d							;
    824  056d				   iCMPRnoteq
    825  056d		       a5 52		      lda	R0
    826  056f		       c5 54		      cmp	R1	; Sets the carry flag
    827  0571		       a5 53		      lda	R0+1
    828  0573		       e5 55		      sbc	R1+1
    829  0575
    830  0575		       50 02		      bvc	iCMPR_2	; branch if N eor V
    831  0577		       49 80		      eor	#$80
    832  0579
    833  0579		       30 04	   iCMPR_2    bmi	iCMPlt
    834  057b		       a9 04		      lda	#REL_GT
    835  057d		       d0 02		      bne	iCMPcom
    836  057f
    837  057f		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    838  0581
    839  0581				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    840  0581							;
    841  0581							; Now compare the end result with what the caller
    842  0581							; was looking for.
    843  0581							;
    844  0581		       25 56		      and	MQ
    845  0583		       f0 0c		      beq	iCMPno	; no match
    846  0585		       a9 ff		      lda	#$FF	; true is $ffff
    847  0587		       85 52		      sta	R0
    848  0589		       85 53		      sta	R0+1
    849  058b		       d0 0a		      bne	iCMPDone
    850  058d							;
    851  058d							; R0 > R1
    852  058d							;
    853  058d		       a9 04	   iCMPgt     lda	#REL_GT
    854  058f		       d0 f0		      bne	iCMPcom
    855  0591				   iCMPno
    856  0591		       a9 00		      lda	#0
    857  0593		       85 52		      sta	R0
    858  0595		       85 53		      sta	R0+1
    859  0597
    860  0597				   iCMPDone
    861  0597		       60		      rts
    862  0598
    863  0598							;
    864  0598							; if Not a match, so jump to the next line of code.
    865  0598							; Branches based upon value on top of the stack
    866  0598				   iBranch
    867  0598		       20 b6 2c 	      jsr	popR0
    868  059b		       a5 52		      lda	R0
    869  059d		       05 53		      ora	R0+1
    870  059f		       f0 03		      beq	iBranchFalse	; not true
    871  05a1		       4c b1 02 	      jmp	NextIL	; It is true if any value not zero
    872  05a4							;
    873  05a4				   iBranchFalse
    874  05a4		       20 b5 2a 	      jsr	FindNextLine
    875  05a7		       4c ed 04 	      jmp	iXFER2
    876  05aa							;
    877  05aa							;=====================================================
    878  05aa							; Start a read of data in background
    879  05aa				   iReadStart
    880  05aa		       a9 3f		      lda	#'?	; Prompt with question mark
    881  05ac		       a6 01		      ldx	1	; Indicate to start read in background
    882  05ae		       20 41 2b 	      jsr	GetLine	; Call the getline to start read
    883  05b1		       4c b1 02 	      jmp	NextIL	; next instruction
    884  05b4							;
    885  05b4							;=====================================================
    886  05b4							; Complete the read and return the curptr, curoff pointing to data
    887  05b4				   iReadComplete
    888  05b4		       a9 01		      lda	#GOSUB_RTN
    889  05b6		       20 3e 2c 	      jsr	pushLN
    890  05b9		       90 03		      bcc	iReadOk
    891  05bb		       4c 3a 0c    iReadErr   jmp	ErrStkOver	; Check if there was an error
    892  05be				   iReadOk
    893  05be		       20 61 2b 	      jsr	ReadComplete
    894  05c1		       4c b1 02 	      jmp	NextIL
    895  05c4		       20 67 2c 	      jsr	popLN
    896  05c7		       4c b1 02 	      jmp	NextIL
    897  05ca							;=====================================================
    898  05ca							; Get a line of text from the user, convert to a
    899  05ca							; number, leave on top of stack.
    900  05ca							;
    901  05ca				   iINNUM
    902  05ca		       a9 01		      lda	#GOSUB_RTN
    903  05cc		       20 3e 2c 	      jsr	pushLN
    904  05cf		       b0 ea		      bcs	iReadErr	; Stack over flow error
    905  05d1							;
    906  05d1		       a9 3f		      lda	#'?
    907  05d3		       a2 00		      ldx	#0	;Wait for complete
    908  05d5		       20 41 2b 	      jsr	GetLine
    909  05d8		       20 d6 2a 	      jsr	getDecimal
    910  05db		       20 24 2c 	      jsr	pushR0	;put onto stack
    911  05de		       b0 db		      bcs	iReadErr	;StackOverflow error
    912  05e0							;
    913  05e0		       4c fc 05 	      jmp	ExitIn
    914  05e3							;
    915  05e3							;=====================================================
    916  05e3							; Get a line of text from the user, convert to a
    917  05e3							; character value , leave on top of stack. up to 2 characters
    918  05e3							;
    919  05e3				   iINSTR
    920  05e3		       a9 01		      lda	#GOSUB_RTN
    921  05e5		       20 3e 2c 	      jsr	pushLN
    922  05e8		       b0 d1		      bcs	iReadErr	; Stack overflow error
    923  05ea		       a9 3f		      lda	#'?
    924  05ec		       a2 00		      ldx	#0	;wait for read complete
    925  05ee		       20 41 2b 	      jsr	GetLine
    926  05f1		       b1 4f		      lda	(CURPTR),y
    927  05f3		       85 52		      sta	R0
    928  05f5		       a9 00		      lda	#0
    929  05f7		       85 53		      sta	R0+1
    930  05f9		       20 24 2c 	      jsr	pushR0	;put onto stack
    931  05fc				   ExitIn
    932  05fc		       20 67 2c 	      jsr	popLN
    933  05ff		       4c b1 02 	      jmp	NextIL
    934  0602							;
    935  0602							;
    936  0602							;=====================================================
    937  0602							; Stop the currently running program.	Actually very
    938  0602							; simple to do... clear the RunMode flag, then set the
    939  0602							; ILPC to the standard handler and continue running.
    940  0602							;
    941  0602		       a9 00	   iFIN       lda	#0
    942  0604		       85 5b		      sta	RunMode
    943  0606		       20 6a 26 	      jsr	taskReset
    944  0609							;
    945  0609		       ad 1a 43 	      lda	errGoto
    946  060c		       85 43		      sta	ILPC
    947  060e		       ad 1b 43 	      lda	errGoto+1
    948  0611		       85 44		      sta	ILPC+1
    949  0613		       4c b1 02 	      jmp	NextIL
    950  0616							;
    951  0616							;=====================================================
    952  0616							; Handle the ERR opcode.  Following the instruction is
    953  0616							; a 16 bit error number.  Print an error message, and
    954  0616							; if we're in run mode, print the line number.  Stop
    955  0616							; program execution and return to the initial state.
    956  0616							;
    957  0616		       ad 27 43    iERR       lda	taskIOPending
    958  0619		       f0 03		      beq	iErrNext
    959  061b		       ce 27 43 	      dec	taskIOPending
    960  061e
    961  061e		       20 27 2a    iErrNext   jsr	getILWord	;get err code
    962  0621		       20 27 06 	      jsr	DisplayError
    963  0624		       4c 80 06 	      jmp	iErrComplete
    964  0627							;
    965  0627							; Enter here with the error code in X (LSB) and A (MSB).
    966  0627							;
    967  0627				   DisplayError
    968  0627		       86 52		      stx	R0
    969  0629		       85 53		      sta	R0+1
    970  062b							;
    971  062b		       20 ad 21 	      jsr	puts
      0  062e					      db	CR,LF,"Error ",0
      1  062e		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    973  0637		       20 dc 20 	      jsr	PrintDecimal
    974  063a							;
    975  063a		       a5 5b		      lda	RunMode	;running?
    976  063c		       f0 3b		      beq	iERR3	;nope
    977  063e		       20 ad 21 	      jsr	puts
      0  0641					      db	" at line ",0
      1  0641		       20 61 74 20*	      .byte.b	" at line ",0
    979  064b		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    980  064d				   iErr2a
    981  064d		       b1 4f		      lda	(CURPTR),y
    982  064f		       85 52		      sta	R0
    983  0651		       c8		      iny
    984  0652		       b1 4f		      lda	(CURPTR),y
    985  0654		       85 53		      sta	R0+1
    986  0656		       20 dc 20 	      jsr	PrintDecimal
    987  0659		       20 ad 21 	      jsr	puts
      0  065c					      db	":",0
      1  065c		       3a 00		      .byte.b	":",0
    989  065e		       a9 00		      lda	#0
    990  0660		       85 53		      sta	R0+1
    991  0662		       a5 51		      lda	CUROFF
    992  0664		       18		      clc
    993  0665		       e9 03		      sbc	#3
    994  0667		       85 52		      sta	R0
    995  0669		       20 dc 20 	      jsr	PrintDecimal
    996  066c		       20 ad 21 	      jsr	puts
      0  066f					      db	":",0
      1  066f		       3a 00		      .byte.b	":",0
    998  0671		       ad b4 36 	      lda	taskPtr
    999  0674		       85 52		      sta	R0
   1000  0676		       20 90 21 	      jsr	HexToOut
   1001  0679							;
   1002  0679				   iERR3
   1003  0679		       20 6f 2d 	      jsr	CRLF
   1004  067c		       60		      rts
   1005  067d
   1006  067d				   iErr2
   1007  067d		       20 27 06 	      jsr	DisplayError
   1008  0680
   1009  0680				   iErrComplete
   1010  0680		       20 62 26 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1011  0683		       a9 00		      lda	#0
   1012  0685		       85 5b		      sta	RunMode	; fall through...
   1013  0687							;
   1014  0687							;=====================================================
   1015  0687							; Reset the IL to be back at the idle loop.  Does not
   1016  0687							; clear variables so the user can see what state
   1017  0687							; the program is in.
   1018  0687							;
   1019  0687		       a9 00	   ResetIL    lda	#0
   1020  0689		       85 4f		      sta	CURPTR
   1021  068b		       85 51		      sta	CUROFF
   1022  068d		       85 47		      sta	ILSTACKPTR
   1023  068f		       ad 1a 43 	      lda	errGoto
   1024  0692		       85 43		      sta	ILPC
   1025  0694		       ad 1b 43 	      lda	errGoto+1
   1026  0697		       85 44		      sta	ILPC+1
   1027  0699		       a2 ff		      ldx	#$FF	; make sure the stack pointer is reset
   1028  069b		       9a		      txs
   1029  069c		       4c b1 02 	      jmp	NextIL
   1030  069f
   1031  069f							;
   1032  069f							;=====================================================
   1033  069f							; Pop two items off stack, add them, then place the
   1034  069f							; result back onto the stack.
   1035  069f							;
   1036  069f		       20 b6 2c    iADD       jsr	popR0
   1037  06a2		       20 ce 2c 	      jsr	popR1
   1038  06a5				   iADDfast
   1039  06a5		       18		      clc
   1040  06a6		       a5 52		      lda	R0
   1041  06a8		       65 54		      adc	R1
   1042  06aa		       85 52		      sta	R0
   1043  06ac		       a5 53		      lda	R0+1
   1044  06ae		       65 55		      adc	R1+1
   1045  06b0		       85 53		      sta	R0+1
   1046  06b2		       4c 1d 07 	      jmp	pushR0nextIl
   1047  06b5							;
   1048  06b5							;=====================================================
   1049  06b5							; Pop two items off the stack.  Subtract the top of
   1050  06b5							; stack from the lower entry.
   1051  06b5							;
   1052  06b5		       20 ce 2c    iSUB       jsr	popR1
   1053  06b8		       20 b6 2c 	      jsr	popR0
   1054  06bb		       38		      sec
   1055  06bc		       a5 52		      lda	R0
   1056  06be		       e5 54		      sbc	R1
   1057  06c0		       85 52		      sta	R0
   1058  06c2		       a5 53		      lda	R0+1
   1059  06c4		       e5 55		      sbc	R1+1
   1060  06c6		       85 53		      sta	R0+1
   1061  06c8		       4c 1d 07 	      jmp	pushR0nextIl
   1062  06cb							;
   1063  06cb							;=====================================================
   1064  06cb							; Negate the top of stack.
   1065  06cb							;
   1066  06cb		       20 b6 2c    iNEG       jsr	popR0
   1067  06ce		       a5 52		      lda	R0
   1068  06d0		       49 ff		      eor	#$ff
   1069  06d2		       85 52		      sta	R0
   1070  06d4		       a5 53		      lda	R0+1
   1071  06d6		       49 ff		      eor	#$ff
   1072  06d8		       85 53		      sta	R0+1
   1073  06da		       e6 52		      inc	R0
   1074  06dc		       d0 02		      bne	iNEG2
   1075  06de		       e6 53		      inc	R0+1
   1076  06e0		       4c 1d 07    iNEG2      jmp	pushR0nextIl
   1077  06e3							;
   1078  06e3							;=====================================================
   1079  06e3							; Multiply top two items on the stack, put the results
   1080  06e3							; on top.  This uses the algorithm documented on page
   1081  06e3							; 115 of "Microprocessor Programming for Computer
   1082  06e3							; Hobbyists" by Neill Graham.
   1083  06e3							;
   1084  06e3		       20 e9 06    iMUL       jsr	iMultiply
   1085  06e6		       4c b1 02 	      jmp	NextIL
   1086  06e9
   1087  06e9				   iMultiply
   1088  06e9		       20 b6 2c 	      jsr	popR0	;AC
   1089  06ec		       20 ce 2c 	      jsr	popR1	;OP
   1090  06ef							;
   1091  06ef		       a5 52		      lda	R0
   1092  06f1		       85 56		      sta	MQ
   1093  06f3		       a5 53		      lda	R0+1
   1094  06f5		       85 57		      sta	MQ+1
   1095  06f7		       a9 00		      lda	#0	;clear result
   1096  06f9		       85 52		      sta	R0
   1097  06fb		       85 53		      sta	R0+1
   1098  06fd							;
   1099  06fd		       a2 10		      ldx	#16	;number of bits in value
   1100  06ff		       06 52	   multloop   asl	R0
   1101  0701		       26 53		      rol	R0+1
   1102  0703		       06 56		      asl	MQ
   1103  0705		       26 57		      rol	MQ+1
   1104  0707		       90 0d		      bcc	multno	;skip add if no carry
   1105  0709							;
   1106  0709							; Add R1 back into R0
   1107  0709							;
   1108  0709		       18		      clc
   1109  070a		       a5 52		      lda	R0
   1110  070c		       65 54		      adc	R1
   1111  070e		       85 52		      sta	R0
   1112  0710		       a5 53		      lda	R0+1
   1113  0712		       65 55		      adc	R1+1
   1114  0714		       85 53		      sta	R0+1
   1115  0716							;
   1116  0716		       ca	   multno     dex		;did all bits yet?
   1117  0717		       d0 e6		      bne	multloop
   1118  0719		       20 24 2c 	      jsr	pushR0	;OP
   1119  071c		       60		      rts
   1120  071d							;
   1121  071d				   pushR0nextIl
   1122  071d		       20 24 2c 	      jsr	pushR0	;OP
   1123  0720		       4c b1 02 	      jmp	NextIL
   1124  0723							;
   1125  0723							;=====================================================
   1126  0723							; Divide the top of stack into the next to top item.
   1127  0723							; Leave results on stack.  Taken from:
   1128  0723							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1129  0723							;
   1130  0723							; R0 = R0 / R1
   1131  0723							; Remainder is in MQ
   1132  0723							;
   1133  0723		       20 3d 07    iDIV       jsr	iDoDiv
   1134  0726		       20 37 2d 	      jsr	RestoreSigns
   1135  0729		       4c 1d 07 	      jmp	pushR0nextIl
   1136  072c
   1137  072c		       20 3d 07    iMOD       jsr	iDoDiv
   1138  072f		       20 37 2d 	      jsr	RestoreSigns
   1139  0732		       a5 56		      lda	MQ
   1140  0734		       85 52		      sta	R0
   1141  0736		       a5 57		      lda	MQ+1
   1142  0738		       85 53		      sta	R0+1
   1143  073a		       4c 1d 07 	      jmp	pushR0nextIl
   1144  073d
   1145  073d				   iDoDiv
   1146  073d		       20 ce 2c 	      jsr	popR1
   1147  0740		       20 b6 2c 	      jsr	popR0
   1148  0743							;
   1149  0743							; Check for divide by zero
   1150  0743							;
   1151  0743
   1152  0743				   iDivNoPop
   1153  0743		       a5 54		      lda	R1
   1154  0745		       05 55		      ora	R1+1
   1155  0747		       f0 29		      beq	divby0
   1156  0749							;
   1157  0749		       20 fc 2c 	      jsr	SaveSigns
   1158  074c		       a9 00		      lda	#0	;preset remainder to 0
   1159  074e		       85 56		      sta	MQ
   1160  0750		       85 57		      sta	MQ+1
   1161  0752		       a2 10		      ldx	#16	;repeat for each bit: ...
   1162  0754				   divloop
   1163  0754		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1164  0756		       26 53		      rol	R0+1
   1165  0758		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1166  075a		       26 57		      rol	MQ+1
   1167  075c		       a5 56		      lda	MQ
   1168  075e		       38		      sec
   1169  075f		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1170  0761		       a8		      tay		;lb result -> Y, for we may need it later
   1171  0762		       a5 57		      lda	MQ+1
   1172  0764		       e5 55		      sbc	R1+1
   1173  0766		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1174  0768
   1175  0768		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1176  076a		       84 56		      sty	MQ
   1177  076c		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1178  076e
   1179  076e		       ca	   skip       dex
   1180  076f		       d0 e3		      bne	divloop
   1181  0771		       60		      rts
   1182  0772							;
   1183  0772							; Indicate divide-by-zero error
   1184  0772							;
   1185  0772		       68	   divby0     pla		; remove the reyurn from the stack
   1186  0773		       68		      pla
   1187  0774		       a2 06		      ldx	#ERR_DIVIDE_ZERO	; do the error
   1188  0776		       a9 00		      lda	#0
   1189  0778		       4c 7d 06 	      jmp	iErr2
   1190  077b							;
   1191  077b							;=====================================================
   1192  077b							; This pops the top two items off the stack.  The top
   1193  077b							; item is a data value and the other is an ABSOLUTE address.
   1194  077b							; Save the value into that address.
   1195  077b							;
   1196  077b		       98	   iSTORE     tya
   1197  077c		       48		      pha
   1198  077d		       20 b6 2c 	      jsr	popR0	;data
   1199  0780		       20 ce 2c 	      jsr	popR1	;Storage location
   1200  0783		       a0 01		      ldy	#1
   1201  0785		       a5 58		      lda	R2
   1202  0787		       c9 a2		      cmp	#tByte
   1203  0789		       f0 04		      beq	iStoreB
   1204  078b				   iStoreW
   1205  078b		       a5 53		      lda	R0+1
   1206  078d		       91 54		      sta	(R1),y
   1207  078f				   iStoreB
   1208  078f		       a5 52		      lda	R0
   1209  0791		       88		      dey
   1210  0792		       91 54		      sta	(R1),y
   1211  0794		       68		      pla
   1212  0795		       a8		      tay
   1213  0796		       4c b1 02 	      jmp	NextIL
   1214  0799							;
   1215  0799							;=====================================================
   1216  0799							; Replaces the top of stack with the Value
   1217  0799							; of the variable  whose absolute address it represents.
   1218  0799							;
   1219  0799
   1220  0799		       98	   iIND       tya
   1221  079a		       48		      pha
   1222  079b		       20 ce 2c 	      jsr	popR1
   1223  079e		       a0 01		      ldy	#1
   1224  07a0		       a5 58		      lda	R2
   1225  07a2		       c9 a4		      cmp	#tInteger
   1226  07a4		       f0 04		      beq	iINDW
   1227  07a6				   iINDB
   1228  07a6		       a9 00		      lda	#0
   1229  07a8		       f0 02		      BEQ	iINDC
   1230  07aa				   iINDW
   1231  07aa		       b1 54		      lda	(R1),y
   1232  07ac				   iINDC
   1233  07ac		       85 53		      sta	R0+1
   1234  07ae		       88		      dey
   1235  07af		       b1 54		      lda	(R1),y
   1236  07b1		       85 52		      sta	R0
   1237  07b3		       68		      pla
   1238  07b4		       a8		      tay
   1239  07b5		       4c 1d 07 	      jmp	pushR0nextIl
   1240  07b8
   1241  07b8							;
   1242  07b8							;=====================================================
   1243  07b8							; Check which type of index to use byte or word and jmp to correct
   1244  07b8							; function
   1245  07b8		       98	   iArray     tya
   1246  07b9		       48		      pha
   1247  07ba
   1248  07ba		       20 b6 2c 	      jsr	popR0	; Get the array index
   1249  07bd		       20 ce 2c 	      jsr	popR1	; Get the Variable address
   1250  07c0
   1251  07c0		       20 2b 2a 	      jsr	getILByte	; Get type of number to process
   1252  07c3		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Are we testing a valid parameter
   1253  07c5		       f0 52		      beq	iArrayFNparm	; process a fn pramater index
   1254  07c7
   1255  07c7		       29 fe		      and	#$FE	; Turn off the unsigned bit
   1256  07c9		       c9 a2		      cmp	#tByte	; Test for a byte index
   1257  07cb		       f0 10		      beq	iArrayB	; yes so branch to process a byte
   1258  07cd							;=====================================================
   1259  07cd							; Process 32 bit index into memory
   1260  07cd		       c9 a6	   iArrayL    cmp	#tLong	; Are we working with 32 bit integers
   1261  07cf		       d0 06		      bne	iArrayW	; Process with sigle shift
   1262  07d1		       06 52		      asl	R0	; Do the multiply by 2
   1263  07d3		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1264  07d5		       b0 39		      bcs	iArrayError	; if the carry is set we have an error
   1265  07d7							;=====================================================
   1266  07d7							; Get the array index from top of stack get Current variable
   1267  07d7							; address from next on stack, add the offset
   1268  07d7							; push the result back onto the stack
   1269  07d7				   iArrayW		; pointers, arrays etc all use 16 bit unsigned integers
   1270  07d7		       06 52		      asl	R0	; Do the multiply by 2
   1271  07d9		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1272  07db		       b0 33		      bcs	iArrayError	; if the carry is set we have an error
   1273  07dd
   1274  07dd							;=====================================================
   1275  07dd							; Get from Byte array not Integer array
   1276  07dd				   iArrayB
   1277  07dd		       18		      clc
   1278  07de		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1279  07e0		       65 52		      adc	R0
   1280  07e2		       85 52		      sta	R0
   1281  07e4		       a5 55		      lda	R1+1
   1282  07e6		       65 53		      adc	R0+1
   1283  07e8		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1284  07ea		       a5 55		      lda	R1+1
   1285  07ec		       cd 30 43 	      cmp	ProgramEnd+1	; lets check if we are processing an @ buffer pointer to free memory
   1286  07ef		       d0 08		      bne	iArrayCheckVar
   1287  07f1				   iArrayExit
   1288  07f1		       20 24 2c 	      jsr	pushR0	; Push R0 assume it is correct
   1289  07f4
   1290  07f4		       68		      pla
   1291  07f5		       a8		      tay
   1292  07f6		       4c b1 02 	      jmp	NextIL
   1293  07f9							; Check for valis variable and valid index to use
   1294  07f9		       a5 41	   iArrayCheckVar lda	VARIABLES
   1295  07fb		       18		      clc
   1296  07fc		       69 33		      adc	#[25*2]+1	; the number of actual variable valid bytes
   1297  07fe		       85 56		      sta	MQ	; mq contains the last valid byte we can use
   1298  0800		       a9 00		      lda	#0
   1299  0802		       65 42		      adc	VARIABLES+1	; Memory past last word R0+1 > A then invalid
   1300  0804		       c5 53		      cmp	R0+1
   1301  0806		       90 08		      bcc	iArrayError
   1302  0808		       a5 52		      lda	R0	; a > m invalid past last byte of variable area
   1303  080a		       c5 56		      cmp	MQ
   1304  080c		       f0 e3		      beq	iArrayExit	; If it is equal then it is valid
   1305  080e		       90 e1		      bcc	iArrayExit	; if it is less it is valid
   1306  0810
   1307  0810							; Get here if array index is out of range
   1308  0810		       68	   iArrayError pla
   1309  0811		       98		      tya
   1310  0812		       a9 00		      lda	#0
   1311  0814		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1312  0816		       4c 7d 06 	      jmp	iErr2
   1313  0819							;=====================================================
   1314  0819							; Verify function paramater index is valid
   1315  0819		       20 b8 25    iArrayFNparm jsr	GosubFindParms	; Get a pointer to the current functions parameter list info
   1316  081c		       90 f2		      bcc	iArrayError	; There are no paramters for this call, should never be true
   1317  081e		       88		      dey
   1318  081f		       88		      dey		; Points to parameter count
   1319  0820		       a5 52		      lda	R0	; get parm to be accessed
   1320  0822		       d1 4b		      cmp	(GOSUBSTACK),y	; compare to max number allowed
   1321  0824		       b0 ea		      bcs	iArrayError	; the parameter index should be less than the count
   1322  0826		       06 52		      asl	R0	; Do the multiply by 2
   1323  0828		       26 53		      rol	R0+1
   1324  082a
   1325  082a		       18		      clc
   1326  082b		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1327  082d		       65 52		      adc	R0
   1328  082f		       85 52		      sta	R0
   1329  0831		       a5 55		      lda	R1+1
   1330  0833		       65 53		      adc	R0+1
   1331  0835		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1332  0837		       4c f1 07 	      jmp	iArrayExit	; Get ot we are done
   1333  083a							;
   1334  083a							;=====================================================
   1335  083a							; List the current BASIC program in memory.  Uses R0,
   1336  083a							; tempIly, and dpl.
   1337  083a							;
   1338  083a		       20 b6 2e    iLST       jsr	SetOutConsole
   1339  083d		       ad 2d 43    iLST2      lda	ProgramStart
   1340  0840		       85 59		      sta	dpl
   1341  0842		       ad 2e 43 	      lda	ProgramStart+1
   1342  0845		       85 5a		      sta	dpl+1
   1343  0847							;
   1344  0847							; dpl/dph point to the current line.  See if we're at
   1345  0847							; the end of the program.
   1346  0847							;
   1347  0847		       a5 59	   iLSTloop   lda	dpl
   1348  0849		       cd 2f 43 	      cmp	ProgramEnd
   1349  084c		       d0 07		      bne	iLstNotEnd
   1350  084e		       a5 5a		      lda	dpl+1
   1351  0850		       cd 30 43 	      cmp	ProgramEnd+1
   1352  0853		       f0 15		      beq	iLstdone
   1353  0855							;
   1354  0855		       20 45 22    iLstNotEnd jsr	PrintProgramLine
   1355  0858							;		  ldy	  #1		  ;Change:  Skip first byte length
   1356  0858							;		  lda	  (dpl),y	  ;line number LSB
   1357  0858							;		  sta	  R0
   1358  0858							;		  iny
   1359  0858							;		  lda	  (dpl),y		 ;line number MSB
   1360  0858							;		  sta	  R0+1
   1361  0858							;		  iny
   1362  0858							;		  sty	  tempIlY
   1363  0858							;		  jsr	  PrintDecimal
   1364  0858							;		  lda	  #SPACE
   1365  0858							;		  jsr	  VOUTCH
   1366  0858							;		  ldy	  tempIlY
   1367  0858							;iLSTl2	  lda	  (dpl),y
   1368  0858							;		  beq	  iLST3 	  ;end of this line 0 value
   1369  0858							;		  sty	  tempIlY
   1370  0858							;		  jsr	  VOUTCH
   1371  0858							;		  ldy	  tempIlY
   1372  0858							;		  iny
   1373  0858							;		  bne	  iLSTl2	  ;do next char
   1374  0858							;
   1375  0858							; End of this line.  Print CR/LF, then move to the
   1376  0858							; next line.
   1377  0858							;
   1378  0858		       a0 00	   iLST3      ldy	#0	;Move to next line
   1379  085a		       b1 59		      lda	(dpl),y	;Current line length
   1380  085c		       18		      clc		;Clear the carry flag
   1381  085d							;		  tya
   1382  085d		       65 59		      adc	dpl	;Add the offset to the pointer
   1383  085f		       85 59		      sta	dpl	;Save the new value
   1384  0861		       a5 5a		      lda	dpl+1	;Next byte
   1385  0863		       69 00		      adc	#0	;ad in the carry if any
   1386  0865		       85 5a		      sta	dpl+1	;Save it
   1387  0867							;
   1388  0867							; Have to manually do CR/LF so it uses the vectored
   1389  0867							; output function.
   1390  0867							;
   1391  0867							;		  lda	  #CR
   1392  0867							;		  jsr	  VOUTCH
   1393  0867							;		  lda	  #LF
   1394  0867							;		  jsr	  VOUTCH
   1395  0867		       4c 47 08 	      jmp	iLSTloop	;do next line
   1396  086a							;
   1397  086a		       20 b6 2e    iLstdone   jsr	SetOutConsole
   1398  086d		       4c b1 02 	      jmp	NextIL
   1399  0870							;
   1400  0870							;=====================================================
   1401  0870							; Get a line of text into LINBUF.  Terminate with a
   1402  0870							; null byte.
   1403  0870							;
   1404  0870				   iGETLINE
   1405  0870		       a9 3e		      lda	#'>	;prompt character
   1406  0872		       a6 00		      ldx	0	;Wait for read to complete
   1407  0874		       20 41 2b 	      jsr	GetLine
   1408  0877							;
   1409  0877		       a9 00		      lda	#0
   1410  0879		       85 5b		      sta	RunMode
   1411  087b				   iGetParseLine
   1412  087b							; lda	   CUROFF
   1413  087b							; pha
   1414  087b		       20 50 1d 	      jsr	ParseInputLine
   1415  087e							; pla
   1416  087e							;  sta     CUROFF
   1417  087e		       a9 4d		      lda	#TOKENBUFFER&$FF
   1418  0880		       85 4f		      sta	CURPTR
   1419  0882		       a9 1c		      lda	#TOKENBUFFER>>8
   1420  0884		       85 50		      sta	CURPTR+1
   1421  0886		       a9 01		      lda	#1
   1422  0888		       85 51		      sta	CUROFF
   1423  088a		       4c b1 02 	      jmp	NextIL
   1424  088d							;
   1425  088d							;=====================================================
   1426  088d							; This is called when the input buffer contains a line
   1427  088d							; typed in by the user that starts with a line number.
   1428  088d							; Insert the line into the program or delete the line
   1429  088d							; if there is nothing after the line number,
   1430  088d							;
   1431  088d				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1432  088d		       ad 4e 1c 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1433  0890		       85 52		      sta	R0	; place the number into R0
   1434  0892		       ad 4f 1c 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1435  0895		       85 53		      STA	R0+1	; Place it into
   1436  0897							;
   1437  0897							; Now find the line OR the next higher line OR the
   1438  0897							; end of the program.
   1439  0897							;
   1440  0897		       20 70 2a 	      jsr	findLine	; Look for the line number in the current program
   1441  089a							; Returns Z and curptr point to the line if found
   1442  089a							; Returns C and curptr at next higher line if not found and there is a higher line
   1443  089a							; Returns ZC clear and curptr to end of program if higher than all other lines
   1444  089a							;
   1445  089a							; If the line exists, it needs to be removed.
   1446  089a							;
   1447  089a		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1448  089c							;
   1449  089c							; Get length of line to be removed, we fall thru to here if we find a matching line
   1450  089c							;
   1451  089c							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1452  089c		       a0 00		      ldy	#0
   1453  089e		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1454  08a0		       a8		      tay
   1455  08a1							;If it is equal we delete the line and replace it, get length
   1456  08a1							;then adjust all program line after up or down depending on len of line
   1457  08a1							;If next higher then just move everythimg down by length bytes
   1458  08a1							;This call will return how many bytes in the line we found
   1459  08a1		       8c 26 43 	      sty	lineLength	;Save the length of the line we found
   1460  08a4							;
   1461  08a4							; Compute the new end of the program first.
   1462  08a4							;
   1463  08a4		       38		      sec		;Set the carry bit
   1464  08a5		       ad 2f 43 	      lda	ProgramEnd	;Get low byte of program end
   1465  08a8		       ed 26 43 	      sbc	lineLength	;Subtract the length of the current line
   1466  08ab		       8d 2f 43 	      sta	ProgramEnd	;save it
   1467  08ae		       ad 30 43 	      lda	ProgramEnd+1
   1468  08b1		       e9 00		      sbc	#0	;Process the carry
   1469  08b3		       8d 30 43 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1470  08b6							;
   1471  08b6							; Copy CURPTR into R1 for working
   1472  08b6							;
   1473  08b6		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1474  08b8		       85 54		      sta	R1
   1475  08ba		       a5 50		      lda	CURPTR+1
   1476  08bc		       85 55		      sta	R1+1
   1477  08be							;
   1478  08be							; See if we're at the end.
   1479  08be							;
   1480  08be		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1481  08c0		       cd 2f 43 	      cmp	ProgramEnd
   1482  08c3		       d0 07		      bne	InsDelLoop
   1483  08c5		       a5 55		      lda	R1+1
   1484  08c7		       cd 30 43 	      cmp	ProgramEnd+1
   1485  08ca		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1486  08cc							;
   1487  08cc							; Move one byte, move to next location.
   1488  08cc							;
   1489  08cc		       ac 26 43    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1490  08cf		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1491  08d1		       b1 54		      lda	(R1),y
   1492  08d3		       a0 00		      ldy	#0
   1493  08d5		       91 54		      sta	(R1),y
   1494  08d7		       e6 54		      inc	R1
   1495  08d9		       d0 e3		      bne	InsDelChk
   1496  08db		       e6 55		      inc	R1+1
   1497  08dd		       4c be 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1498  08e0							;
   1499  08e0							; Deletion is done.
   1500  08e0							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1501  08e0							;
   1502  08e0				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1503  08e0		       ad 4d 1c 	      lda	TOKENBUFFER	; Get the length
   1504  08e3		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1505  08e5							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1506  08e5		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1507  08e7							;
   1508  08e7							; CURPTR points to where the line will be inserted.
   1509  08e7							;
   1510  08e7							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1511  08e7		       ae 4d 1c 	      ldx	TOKENBUFFER
   1512  08ea		       8e 26 43 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1513  08ed							;
   1514  08ed		       ad 2f 43 	      lda	ProgramEnd	;Load the start address for the copy
   1515  08f0							;At this point curptr still contains the location we will insert data
   1516  08f0		       85 5c		      sta	FROM
   1517  08f2		       ad 30 43 	      lda	ProgramEnd+1
   1518  08f5		       85 5d		      sta	FROM+1
   1519  08f7							;
   1520  08f7		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1521  08f9		       b1 5c		      lda	(FROM),y
   1522  08fb		       ac 26 43 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1523  08fe		       91 5c		      sta	(FROM),y	;Save the new byte
   1524  0900							;
   1525  0900		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1526  0902		       c5 4f		      cmp	CURPTR
   1527  0904		       d0 06		      bne	mvUpMore
   1528  0906		       a5 5d		      lda	FROM+1
   1529  0908		       c5 50		      cmp	CURPTR+1
   1530  090a		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1531  090c							;
   1532  090c							; Not done yet
   1533  090c							;
   1534  090c		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1535  090e		       d0 02		      bne	mvUpMore2
   1536  0910		       c6 5d		      dec	FROM+1
   1537  0912		       c6 5c	   mvUpMore2  dec	FROM
   1538  0914		       4c f7 08 	      jmp	mvup1	;Loop until everything is moved
   1539  0917							;
   1540  0917							; All done with copy.
   1541  0917							;
   1542  0917				   mvUpDone
   1543  0917		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1544  0918		       ad 26 43 	      lda	lineLength	;Number of bytes to copy from line buff
   1545  091b		       6d 2f 43 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1546  091e		       8d 2f 43 	      sta	ProgramEnd
   1547  0921		       ad 30 43 	      lda	ProgramEnd+1
   1548  0924		       69 00		      adc	#0
   1549  0926		       8d 30 43 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1550  0929							;
   1551  0929							;===================jlit use length before line newline
   1552  0929
   1553  0929		       a0 00		      ldy	#0	;Set offset of copy
   1554  092b							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1555  092b							;		  sta	  (CURPTR),y	  ;Store the length
   1556  092b							;		  iny
   1557  092b							;		  lda	  R0		  ;Store the line number next
   1558  092b							;		  sta	  (CURPTR),y
   1559  092b							;		  iny
   1560  092b							;		  lda	  R0+1
   1561  092b							;		  sta	  (CURPTR),y
   1562  092b							;		  iny
   1563  092b							;
   1564  092b							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1565  092b		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1566  092d				   mvUpLoop2
   1567  092d							;		  lda	  LINBUF,x	 ;get a byte
   1568  092d		       bd 4d 1c 	      lda	TOKENBUFFER,x	;get a byte
   1569  0930		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1570  0932
   1571  0932		       e8		      inx
   1572  0933		       ec 4d 1c 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1573  0936		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1574  0938		       c8		      iny
   1575  0939		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1576  093b							;
   1577  093b		       4c b1 02    mvUpFini   jmp	NextIL
   1578  093e							;
   1579  093e							;=====================================================
   1580  093e							; Pops the top value of the ILPC stack and stores it
   1581  093e							; in ILPC.  Ie, return from an IL subroutine.
   1582  093e							;
   1583  093e		       20 5e 2a    iRTN       jsr	popILPC
   1584  0941		       4c b1 02 	      jmp	NextIL
   1585  0944							;
   1586  0944							;=====================================================
   1587  0944							; NLINE print a newline
   1588  0944							;
   1589  0944		       20 6f 2d    iNLINE     jsr	CRLF	;user supplied sub
   1590  0947		       4c b1 02 	      jmp	NextIL
   1591  094a							;
   1592  094a							;=====================================================
   1593  094a							; This saves the current ILPC value on the stack, then
   1594  094a							; jumps to the address specified by the next two bytes.
   1595  094a							;
   1596  094a		       20 41 2a    iCALL      jsr	pushILPC	;save ILPC
   1597  094d		       90 07		      bcc	iJMP
   1598  094f
   1599  094f							;If the push failed not enough stack space
   1600  094f		       a2 15	   ErrILStkOver ldx	#ERR_IL_STACK_OVER_FLOW	; Flag any error in line number
   1601  0951		       a9 00		      lda	#0	; stop the execution
   1602  0953		       4c 7d 06 	      jmp	iErr2
   1603  0956							;
   1604  0956							; Jmp to a specific location in the IL code.  The new
   1605  0956							; address immediately follows the opcode.
   1606  0956							;
   1607  0956		       20 27 2a    iJMP       jsr	getILWord
   1608  0959		       86 43		      stx	ILPC
   1609  095b		       85 44		      sta	ILPC+1
   1610  095d		       4c b1 02 	      jmp	NextIL
   1611  0960
   1612  0960
   1613  0960							;
   1614  0960							;=====================================================
   1615  0960							; Push the next two bytes onto the arithmetic stack.
   1616  0960							;
   1617  0960		       20 2b 2a    iSetR2     jsr	getILByte
   1618  0963		       85 58		      sta	R2
   1619  0965		       4c b1 02 	      jmp	NextIL
   1620  0968							;
   1621  0968							;=====================================================
   1622  0968							; Push the next two bytes onto the arithmetic stack.
   1623  0968							;
   1624  0968		       20 27 2a    iLIT       jsr	getILWord
   1625  096b		       86 52		      stx	R0
   1626  096d		       85 53		      sta	R0+1
   1627  096f		       20 24 2c 	      jsr	pushR0
   1628  0972		       4c b1 02 	      jmp	NextIL
   1629  0975							;
   1630  0975							;=====================================================
   1631  0975							; Initialize all variables for a single task.	Ie, set to zero.
   1632  0975							; And internal stack pointers
   1633  0975							;
   1634  0975		       98	   subVINIT   tya
   1635  0976		       48		      pha
   1636  0977
   1637  0977		       a9 00		      lda	#0
   1638  0979		       a0 00		      ldy	#0
   1639  097b		       91 41	   Vinit2     sta	(VARIABLES),y
   1640  097d		       c8		      iny
   1641  097e		       c0 48		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1642  0980		       90 f9		      bcc	Vinit2
   1643  0982		       85 4a		      sta	MATHSTACKPTR	; Clear the math stack
   1644  0984		       85 4d		      sta	GOSUBSTACKPTR	; Clear the gosub stack
   1645  0986		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reset the message queue
   1646  0988		       85 4e		      STA	MESSAGEPTR
   1647  098a
   1648  098a		       68		      pla
   1649  098b		       a8		      tay
   1650  098c		       60		      rts
   1651  098d
   1652  098d				   iVINIT
   1653  098d		       20 75 09 	      jsr	subVINIT
   1654  0990		       20 e7 1f 	      jsr	Compile	; compile line numbers to memory pointers
   1655  0993		       4c b1 02 	      jmp	NextIL
   1656  0996							;
   1657  0996							;=====================================================
   1658  0996							; Set the address of the error handler.  After any
   1659  0996							; error, set to the ILPC to the specified location.
   1660  0996							;
   1661  0996		       20 27 2a    iERRGOTO   jsr	getILWord
   1662  0999		       8e 1a 43 	      stx	errGoto
   1663  099c		       8d 1b 43 	      sta	errGoto+1
   1664  099f		       4c b1 02 	      jmp	NextIL
   1665  09a2							;
   1666  09a2							;=====================================================
   1667  09a2							; TST is followed by an 8 bit signed offset, then a
   1668  09a2							; null terminated string.  Compare the string against
   1669  09a2							; the string starting at (CURPTR),CUROFF.  If the
   1670  09a2							; strings match, continue executing the next IL
   1671  09a2							; opcode.  Else, add the offset to ILPC.
   1672  09a2							;
   1673  09a2		       20 2b 2a    iTST       jsr	getILByte	;Get the relative jump address
   1674  09a5		       8d 25 43 	      sta	offset	;save it to use if test faile
   1675  09a8		       20 0e 2c 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1676  09ab
   1677  09ab		       a4 51		      ldy	CUROFF
   1678  09ad		       84 59		      sty	dpl	;save for later
   1679  09af							;
   1680  09af		       20 2b 2a    iTSTloop   jsr	getILByte	;get next char
   1681  09b2		       f0 11		      beq	iTSTm	;match!
   1682  09b4		       a4 59		      ldy	dpl
   1683  09b6		       d1 4f		      cmp	(CURPTR),y
   1684  09b8		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1685  09ba		       09 20		      ora	#$20	; lets allow lowercase as well
   1686  09bc		       d1 4f		      cmp	(CURPTR),y
   1687  09be		       d0 23		      bne	iTSTfail	;mismatch
   1688  09c0		       c8	   iTSTUpper  iny
   1689  09c1		       84 59		      sty	dpl
   1690  09c3		       d0 ea		      bne	iTSTloop
   1691  09c5							;
   1692  09c5							; It's a match!  Clean up a bit.
   1693  09c5							;
   1694  09c5		       a4 59	   iTSTm      ldy	dpl
   1695  09c7		       84 51		      sty	CUROFF
   1696  09c9		       4c b1 02 	      jmp	NextIL
   1697  09cc
   1698  09cc							; Test for a single quote string
   1699  09cc		       20 2b 2a    iTSTStr    jsr	getILByte
   1700  09cf		       8d 25 43 	      sta	offset
   1701  09d2		       20 0e 2c 	      jsr	saveIL
   1702  09d5		       a4 51		      ldy	CUROFF
   1703  09d7		       a9 22		      lda	#'"
   1704  09d9		       d1 4f		      cmp	(CURPTR),y
   1705  09db		       d0 06		      bne	iTSTfail
   1706  09dd		       c8		      iny
   1707  09de		       84 51		      sty	CUROFF
   1708  09e0		       4c d4 02 	      jmp	NextILStr
   1709  09e3							;
   1710  09e3							; Not a match, reset ILPC and then move to the
   1711  09e3							; offset.
   1712  09e3							;
   1713  09e3		       20 19 2c    iTSTfail   jsr	restoreIL
   1714  09e6		       4c e0 0b 	      jmp	tstBranch
   1715  09e9							;
   1716  09e9							;=================================================JLIT=
   1717  09e9							; Test if we have a let statement without the let keyword
   1718  09e9		       20 2b 2a    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1719  09ec		       8d 25 43 	      sta	offset	; Save the jump offset for fails
   1720  09ef		       20 0e 2c 	      jsr	saveIL	; save to restore when done if fail
   1721  09f2
   1722  09f2		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1723  09f4		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1724  09f6		       c9 01		      cmp	#kLet	; Is it a let keyword
   1725  09f8		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1726  09fa		       c9 80		      cmp	#tVa	; lets check for a variable
   1727  09fc		       90 e5		      bcc	iTSTfail	; Less than variable range
   1728  09fe		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1729  0a00		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1730  0a02		       b0 df		      bcs	iTSTfail	; return it failed
   1731  0a04
   1732  0a04				   iTSTLETGOOD
   1733  0a04		       c8		      iny
   1734  0a05		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1735  0a07				   iTSTGOODVAR
   1736  0a07		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1737  0a0a
   1738  0a0a							;=================================================JLIT=
   1739  0a0a							; Test a byte at an indirect address
   1740  0a0a							; fails if byte is not equal to the value at the address
   1741  0a0a							; The tests an indirect byte and branches if true
   1742  0a0a		       20 2b 2a    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1743  0a0d		       8d 25 43 	      sta	offset	; Save the jump offset for fails
   1744  0a10		       20 0e 2c 	      jsr	saveIL	; save to restore when done if fail
   1745  0a13		       20 27 2a 	      jsr	getILWord	; Get a word into RO
   1746  0a16		       86 52		      stx	R0
   1747  0a18		       85 53		      sta	R0+1
   1748  0a1a		       20 2b 2a 	      jsr	getILByte	; Get byte into A
   1749  0a1d		       a0 00		      ldy	#0
   1750  0a1f		       d1 52		      cmp	(R0),y
   1751  0a21		       d0 03		      bne	iTSTByteNotEqual
   1752  0a23		       4c e3 09 	      jmp	iTSTfail
   1753  0a26
   1754  0a26				   iTSTByteNotEqual
   1755  0a26		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1756  0a29
   1757  0a29							;=================================================JLIT=
   1758  0a29							; Test a byte	branch if it fails
   1759  0a29		       20 2b 2a    iTSTB      jsr	getILByte	; Get the relative offset byte
   1760  0a2c		       8d 25 43 	      sta	offset	; Save the jump offset for fails
   1761  0a2f		       20 0e 2c 	      jsr	saveIL	; save to restore when done if fail
   1762  0a32		       20 2b 2a 	      jsr	getILByte	; Get a byte into Acc
   1763  0a35		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1764  0a37		       d1 4f		      cmp	(CURPTR),y
   1765  0a39		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1766  0a3b		       4c e3 09 	      jmp	iTSTfail	; REcover and move on to next test
   1767  0a3e
   1768  0a3e				   iTSTBMatch
   1769  0a3e		       c8		      iny
   1770  0a3f		       84 51		      sty	CUROFF	; Point to the next byte
   1771  0a41		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1772  0a44
   1773  0a44							;=================================================JLIT=
   1774  0a44							; Test a byte	branch if it fails
   1775  0a44		       20 2b 2a    iTSTW      jsr	getILByte	; Get the relative offset byte
   1776  0a47		       8d 25 43 	      sta	offset	; Save the jump offset for fails
   1777  0a4a		       20 0e 2c 	      jsr	saveIL	; save to restore when done if fail
   1778  0a4d		       20 27 2a 	      jsr	getILWord	; Get a word into RO
   1779  0a50		       86 52		      stx	R0
   1780  0a52		       85 53		      sta	R0+1
   1781  0a54		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1782  0a56		       8a		      txa
   1783  0a57		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1784  0a59		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1785  0a5b		       4c e3 09 	      jmp	iTSTfail	; REcover and move on to next test
   1786  0a5e		       c8	   iTSTWM1    iny
   1787  0a5f		       a5 53		      lda	R0+1
   1788  0a61		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1789  0a63		       f0 03		      beq	iTSTWMatch
   1790  0a65		       4c e3 09 	      jmp	iTSTfail
   1791  0a68
   1792  0a68				   iTSTWMatch
   1793  0a68		       c8		      iny
   1794  0a69		       84 51		      sty	CUROFF
   1795  0a6b		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1796  0a6e
   1797  0a6e							;================================================jLIT=
   1798  0a6e							;Test for end of line
   1799  0a6e							;
   1800  0a6e				   iTSTDONE
   1801  0a6e		       20 2b 2a 	      jsr	getILByte
   1802  0a71		       8d 25 43 	      sta	offset
   1803  0a74		       20 0e 2c 	      jsr	saveIL
   1804  0a77		       a4 51		      ldy	CUROFF
   1805  0a79		       84 59		      sty	dpl
   1806  0a7b		       b1 4f		      lda	(CURPTR),y
   1807  0a7d		       f0 0b		      beq	iTSTDONEtrue
   1808  0a7f		       c9 e6		      cmp	#oColon
   1809  0a81		       f0 07		      beq	iTSTDONEtrue
   1810  0a83		       a4 59		      ldy	dpl
   1811  0a85		       84 51		      sty	CUROFF
   1812  0a87		       4c e3 09 	      jmp	iTSTfail
   1813  0a8a							;
   1814  0a8a							; Advance to the next line
   1815  0a8a							;
   1816  0a8a				   iTSTDONEtrue
   1817  0a8a		       4c b1 02 	      jmp	NextIL
   1818  0a8d
   1819  0a8d		       4c e0 0b    tstBranchLink jmp	tstBranch
   1820  0a90							;
   1821  0a90							;=====================================================
   1822  0a90							; Inc and dec a variable , faster than a = a + 1
   1823  0a90				   iINCVAR
   1824  0a90		       20 b6 2c 	      jsr	popR0
   1825  0a93		       a0 00		      ldy	#0
   1826  0a95		       18		      clc
   1827  0a96		       a9 01		      lda	#1
   1828  0a98		       71 52		      adc	(R0),y
   1829  0a9a		       91 52		      sta	(R0),y
   1830  0a9c		       90 07		      bcc	iINCDONE
   1831  0a9e		       c8		      iny
   1832  0a9f		       a9 00		      lda	#0
   1833  0aa1		       71 52		      adc	(R0),y
   1834  0aa3		       91 52		      sta	(R0),y
   1835  0aa5				   iINCDONE
   1836  0aa5		       4c b1 02 	      jmp	NextIL
   1837  0aa8
   1838  0aa8				   iDECVAR
   1839  0aa8		       20 b6 2c 	      jsr	popR0
   1840  0aab		       a0 00		      ldy	#0
   1841  0aad		       38		      sec
   1842  0aae		       b1 52		      lda	(R0),y
   1843  0ab0		       e9 01		      sbc	#1
   1844  0ab2		       91 52		      sta	(R0),y
   1845  0ab4		       c8		      iny
   1846  0ab5		       b1 52		      lda	(R0),y
   1847  0ab7		       e9 00		      sbc	#0
   1848  0ab9		       91 52		      sta	(R0),y
   1849  0abb		       4c b1 02 	      jmp	NextIL
   1850  0abe
   1851  0abe
   1852  0abe							;
   1853  0abe							;=====================================================
   1854  0abe							; TSTV is followed by an 8 bit signed offset.	If the
   1855  0abe							; value at (CURPTR),CUROFF appears to be a variable
   1856  0abe							; name, move to the next IL statement.  Else, add the
   1857  0abe							; offset to ILPC. Converted to use actual absolute memory addresses
   1858  0abe							; TSTVT Looks for the task context
   1859  0abe							;
   1860  0abe		       20 ce 2c    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1861  0ac1		       a9 00		      lda	#0
   1862  0ac3		       85 58		      sta	R2
   1863  0ac5		       f0 04		      beq	iTSTVV
   1864  0ac7
   1865  0ac7							; Test for simple variable
   1866  0ac7		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1867  0ac9		       85 58		      sta	R2
   1868  0acb
   1869  0acb		       20 2b 2a    iTSTVV     jsr	getILByte	;offset
   1870  0ace		       8d 25 43 	      sta	offset
   1871  0ad1							;
   1872  0ad1		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1873  0ad3		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1874  0ad5		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1875  0ad7		       4c 8d 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1876  0ada							;
   1877  0ada				   iTSTVnext
   1878  0ada		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1879  0adc		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1880  0ade
   1881  0ade		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1882  0ae0		       f0 5b		      beq	iTSTVParm
   1883  0ae2
   1884  0ae2		       c9 9b		      cmp	#tVhat	; task exit code
   1885  0ae4		       d0 04		      bne	iTSTV_A2Z
   1886  0ae6		       a9 48		      lda	#TASKEXITCODE
   1887  0ae8		       d0 0b		      bne	iTSTVContinue
   1888  0aea
   1889  0aea				   iTSTV_A2Z
   1890  0aea
   1891  0aea		       c9 80		      cmp	#tVa
   1892  0aec		       90 9f		      bcc	tstBranchLink
   1893  0aee		       c9 9a		      cmp	#tVz+1
   1894  0af0		       b0 9b		      bcs	tstBranchLink
   1895  0af2
   1896  0af2
   1897  0af2							;
   1898  0af2							; The condition is true, so convert to an index, push
   1899  0af2							; it onto the stack and continue running.
   1900  0af2							;
   1901  0af2		       29 7f		      and	#%01111111	; Mask off the high bit
   1902  0af4		       0a		      asl		; multiply by two
   1903  0af5
   1904  0af5				   iTSTVContinue
   1905  0af5		       c8		      iny
   1906  0af6		       84 51		      sty	CUROFF	; it is a valid variable
   1907  0af8		       48		      pha		; save the last variable pointer value
   1908  0af9		       a5 58		      lda	R2
   1909  0afb		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1910  0afd
   1911  0afd		       20 00 2a 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1912  0b00		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1913  0b02
   1914  0b02		       68		      pla		; We have an invalid pid for getting variable value
   1915  0b03		       a2 10		      ldx	#ERR_INVALID_PID
   1916  0b05		       a9 00		      lda	#0
   1917  0b07		       4c 7d 06 	      jmp	iErr2
   1918  0b0a
   1919  0b0a				   iTSTVGOODPID
   1920  0b0a		       20 e8 29 	      jsr	ipc_getcontext	; Get the other tasks variables
   1921  0b0d		       a0 01		      ldy	#VARIABLEPOS
   1922  0b0f		       b1 56		      lda	(MQ),y
   1923  0b11		       85 52		      sta	R0
   1924  0b13		       c8		      iny
   1925  0b14		       b1 56		      lda	(MQ),y
   1926  0b16		       85 53		      sta	R0+1
   1927  0b18		       4c 23 0b 	      jmp	iTSTVAddOffset
   1928  0b1b
   1929  0b1b				   iTSTVLocalValue
   1930  0b1b		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1931  0b1d		       85 52		      sta	R0
   1932  0b1f		       a5 42		      lda	VARIABLES+1
   1933  0b21		       85 53		      sta	R0+1
   1934  0b23
   1935  0b23				   iTSTVAddOffset
   1936  0b23		       68		      pla
   1937  0b24		       85 54		      sta	R1
   1938  0b26		       a9 00		      lda	#0
   1939  0b28		       85 55		      sta	R1+1
   1940  0b2a
   1941  0b2a				   iTSTVcontinue
   1942  0b2a
   1943  0b2a		       4c a5 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1944  0b2d
   1945  0b2d							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1946  0b2d							; an array of integer values or byte.
   1947  0b2d				   iTSTVat
   1948  0b2d		       c8		      iny
   1949  0b2e		       84 51		      sty	CUROFF	;it is a valid variable
   1950  0b30		       ad 2f 43 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1951  0b33		       85 52		      sta	R0
   1952  0b35		       ad 30 43 	      lda	ProgramEnd+1
   1953  0b38		       85 53		      sta	R0+1
   1954  0b3a		       4c 1d 07 	      jmp	pushR0nextIl	;place this onto the stack
   1955  0b3d
   1956  0b3d							; When we get parameters passed we can access them using the # variable with[]
   1957  0b3d							; example #[0] #[1] etc, we dont check yet if there is too many
   1958  0b3d		       c8	   iTSTVParm  iny
   1959  0b3e		       84 51		      sty	CUROFF	;it is a valid variable
   1960  0b40
   1961  0b40							; upon return the y register  point to the gosub Parms entry value entry
   1962  0b40		       20 b8 25 	      jsr	GosubFindParms
   1963  0b43		       90 21		      bcc	iTSTMissingParms
   1964  0b45
   1965  0b45		       88		      dey
   1966  0b46		       88		      dey
   1967  0b47		       88		      dey		;Point to the actual index of first parameter in math stack
   1968  0b48
   1969  0b48		       a5 48		      lda	MATHSTACK
   1970  0b4a		       85 52		      sta	R0
   1971  0b4c		       a5 49		      lda	MATHSTACK+1
   1972  0b4e		       85 53		      sta	R0+1
   1973  0b50		       b1 4b		      lda	(GOSUBSTACK),y	; Get the correct Offset to start of parameters
   1974  0b52		       f0 0b		      beq	iTSTVindex0	; no math if no offset
   1975  0b54		       18		      clc
   1976  0b55		       65 52		      adc	R0	; Point to the actual address that the variables start, not just top of stack
   1977  0b57		       85 52		      sta	R0
   1978  0b59		       a9 00		      lda	#0
   1979  0b5b		       65 53		      adc	R0+1
   1980  0b5d		       85 53		      sta	R0+1
   1981  0b5f				   iTSTVindex0
   1982  0b5f		       a9 81		      lda	#GOSUB_RTN_VALUE
   1983  0b61		       85 58		      sta	R2	; Set the data type as a parameter to a function
   1984  0b63		       4c 1d 07 	      jmp	pushR0nextIl
   1985  0b66
   1986  0b66
   1987  0b66				   iTSTMissingParms
   1988  0b66		       a9 00		      lda	#0
   1989  0b68		       a2 19		      ldx	#ERR_FUNCTION_EXPECTED_PARAMETERS
   1990  0b6a		       4c 7d 06 	      jmp	iErr2
   1991  0b6d
   1992  0b6d							;
   1993  0b6d							;=====================================================
   1994  0b6d							; TSTL seems basically the same as TSTN, but leave the
   1995  0b6d							; value in R0 instead of pushing onto stack.
   1996  0b6d							; This tests for a valid line number
   1997  0b6d							;
   1998  0b6d		       20 2b 2a    iTSTL      jsr	getILByte
   1999  0b70		       8d 25 43 	      sta	offset
   2000  0b73							;
   2001  0b73		       a4 51		      ldy	CUROFF
   2002  0b75		       b1 4f		      lda	(CURPTR),y
   2003  0b77		       c8		      iny
   2004  0b78		       11 4f		      ora	(CURPTR),y
   2005  0b7a		       f0 06		      beq	iTSTLNotLineNo
   2006  0b7c
   2007  0b7c
   2008  0b7c							; In Both cases we need to point to the first usefull byte to process.
   2009  0b7c		       c8		      iny
   2010  0b7d		       84 51		      sty	CUROFF
   2011  0b7f		       4c b1 02 	      jmp	NextIL
   2012  0b82				   iTSTLNotLineNo
   2013  0b82		       c8		      iny
   2014  0b83		       84 51		      sty	CUROFF
   2015  0b85		       4c e0 0b 	      jmp	tstBranch
   2016  0b88
   2017  0b88							;
   2018  0b88							;=====================================================
   2019  0b88							; TSTN checks for a number.  This is very simplistic;
   2020  0b88							; if the character is a digit, assume it's a number.
   2021  0b88							; Convert to a number and push it onto the stack.
   2022  0b88							;
   2023  0b88		       20 2b 2a    iTSTN      jsr	getILByte
   2024  0b8b		       8d 25 43 	      sta	offset
   2025  0b8e							;
   2026  0b8e		       a9 00		      lda	#0
   2027  0b90		       85 59		      sta	dpl
   2028  0b92		       a4 51		      ldy	CUROFF
   2029  0b94				   chkType
   2030  0b94		       b1 4f		      lda	(CURPTR),y
   2031  0b96		       c9 a2		      cmp	#tByte
   2032  0b98		       f0 0e		      beq	chkByte
   2033  0b9a		       c9 a4		      cmp	#tInteger
   2034  0b9c		       f0 16		      beq	chkInteger
   2035  0b9e		       c9 eb		      cmp	#oMinus
   2036  0ba0		       d0 3e		      bne	tstBranch
   2037  0ba2		       e6 59		      inc	dpl
   2038  0ba4		       c8		      iny
   2039  0ba5		       4c 94 0b 	      jmp	chkType
   2040  0ba8
   2041  0ba8				   chkByte
   2042  0ba8		       a9 00		      lda	#0
   2043  0baa		       85 53		      sta	R0+1
   2044  0bac		       c8		      iny
   2045  0bad		       b1 4f		      lda	(CURPTR),y
   2046  0baf		       85 52		      sta	R0
   2047  0bb1		       c8		      iny
   2048  0bb2		       d0 0b		      bne	iTSTN_1
   2049  0bb4
   2050  0bb4				   chkInteger
   2051  0bb4		       c8		      iny
   2052  0bb5		       b1 4f		      lda	(CURPTR),y
   2053  0bb7		       85 52		      sta	R0
   2054  0bb9		       c8		      iny
   2055  0bba		       b1 4f		      lda	(CURPTR),y
   2056  0bbc		       85 53		      sta	R0+1
   2057  0bbe		       c8		      iny
   2058  0bbf							;
   2059  0bbf							; Check if it is negative and make it so
   2060  0bbf							;
   2061  0bbf				   iTSTN_1
   2062  0bbf		       84 51		      sty	CUROFF
   2063  0bc1
   2064  0bc1		       a5 59		      lda	dpl
   2065  0bc3		       f0 18		      beq	iTSTN_2	;positive
   2066  0bc5							;
   2067  0bc5		       a5 52		      lda	R0
   2068  0bc7		       05 53		      ora	R0+1
   2069  0bc9		       f0 12		      beq	iTSTN_2	;zero
   2070  0bcb
   2071  0bcb							; Invert all the bits, then add one.
   2072  0bcb							;
   2073  0bcb		       a5 52		      lda	R0
   2074  0bcd		       49 ff		      eor	#$ff
   2075  0bcf		       85 52		      sta	R0
   2076  0bd1		       a5 53		      lda	R0+1
   2077  0bd3		       49 ff		      eor	#$ff
   2078  0bd5		       85 53		      sta	R0+1
   2079  0bd7							;
   2080  0bd7		       e6 52		      inc	R0
   2081  0bd9		       d0 02		      bne	iTSTN_2
   2082  0bdb		       e6 53		      inc	R0+1
   2083  0bdd				   iTSTN_2
   2084  0bdd		       4c 1d 07 	      jmp	pushR0nextIl	;save onto stack
   2085  0be0
   2086  0be0							;
   2087  0be0							; Common jump point for all TSTx instructions that
   2088  0be0							; fail to meet the requirements.  This takes the
   2089  0be0							; offset and adds/subtracts to/from ILPC.
   2090  0be0							;
   2091  0be0		       ad 25 43    tstBranch  lda	offset	;get signed offset
   2092  0be3		       10 0e		      bpl	tstPositive
   2093  0be5							;
   2094  0be5							; Do negative branch.	Do sign extension.
   2095  0be5							;
   2096  0be5		       18	   tstNegative clc
   2097  0be6		       65 43		      adc	ILPC
   2098  0be8		       85 43		      sta	ILPC
   2099  0bea							;		  bcc	  tstBothDone
   2100  0bea							;		  dec	  ILPC+1
   2101  0bea							;		  jmp	  NextIL
   2102  0bea
   2103  0bea		       a5 44		      lda	ILPC+1
   2104  0bec		       69 ff		      adc	#$ff
   2105  0bee		       85 44		      sta	ILPC+1
   2106  0bf0		       4c b1 02 	      jmp	NextIL	;keep going
   2107  0bf3							;
   2108  0bf3		       18	   tstPositive clc
   2109  0bf4		       65 43		      adc	ILPC
   2110  0bf6		       85 43		      sta	ILPC
   2111  0bf8		       90 02		      bcc	tstBothDone
   2112  0bfa		       e6 44		      inc	ILPC+1
   2113  0bfc				   tstBothDone
   2114  0bfc		       4c b1 02 	      jmp	NextIL
   2115  0bff
   2116  0bff							;
   2117  0bff							;====================================================
   2118  0bff							; Test for IRQ pending, and test if a break key pressed
   2119  0bff							; Yes I know but this handles all sorts of irq/break issues
   2120  0bff							;
   2121  0bff		       20 2b 2a    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2122  0c02		       8d 25 43 	      sta	offset	; Store the not true jump address offset
   2123  0c05		       ad b8 19    irqNo      lda	IRQPending	; Check if the pending value is set
   2124  0c08		       f0 20		      beq	tstBreak	; if no irq then check for an escape key pressed
   2125  0c0a		       c9 01		      cmp	#1	; only do this if set to first time
   2126  0c0c		       d0 1c		      bne	tstBreak	; We are in a irq service already
   2127  0c0e				   iTSTProcessIRQ
   2128  0c0e		       78		      sei		; disable the interupt until ireturn resets it
   2129  0c0f		       ee b8 19 	      inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2130  0c12		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2131  0c14		       20 3e 2c 	      jsr	pushLN	; Push the next line to be executed
   2132  0c17		       b0 21		      bcs	ErrStkOver	; Check if there was an error
   2133  0c19		       ad b9 19 	      lda	IRQEntry	; Get the line number to branch to
   2134  0c1c		       85 4f		      sta	CURPTR	; put line number into r0
   2135  0c1e		       ad ba 19 	      lda	IRQEntry+1
   2136  0c21		       85 50		      sta	CURPTR+1
   2137  0c23		       a9 03		      lda	#3	; Point to first byte of program text
   2138  0c25		       85 51		      sta	CUROFF
   2139  0c27		       4c b1 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2140  0c2a
   2141  0c2a				   tstBreak
   2142  0c2a		       20 67 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2143  0c2d		       d0 b1		      bne	tstBranch	; z not set of no break found
   2144  0c2f		       ad 27 43 	      lda	taskIOPending
   2145  0c32		       f0 03		      beq	tstBrkComplete
   2146  0c34		       ce 27 43 	      dec	taskIOPending
   2147  0c37		       4c 02 06    tstBrkComplete jmp	iFIN	; Exit out of run mode
   2148  0c3a
   2149  0c3a		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2150  0c3c		       a9 00		      lda	#0	; stop the execution
   2151  0c3e		       4c 7d 06 	      jmp	iErr2
   2152  0c41							;
   2153  0c41
   2154  0c41							;=====================================================
   2155  0c41							; This places the number of free bytes on top of the
   2156  0c41							; stack.
   2157  0c41							;
   2158  0c41		       20 c6 23    iFREE      jsr	MemFree
   2159  0c44		       4c 1d 07 	      jmp	pushR0nextIl
   2160  0c47							;
   2161  0c47							;=====================================================
   2162  0c47							; Generate a random number from 0-FFFF and then MOD
   2163  0c47							; it with the value on top of stack.  Leaves number on
   2164  0c47							; stack
   2165  0c47							;
   2166  0c47		       20 ce 2c    iRANDOM    jsr	popR1	;mod value
   2167  0c4a							;
   2168  0c4a							; If the value is zero, just return a one.
   2169  0c4a							;
   2170  0c4a		       a5 54		      lda	R1
   2171  0c4c		       05 55		      ora	R1+1
   2172  0c4e		       f0 4a		      beq	irandom1
   2173  0c50							;
   2174  0c50		       ad 20 43 	      lda	random+1
   2175  0c53		       8d 1d 43 	      sta	rtemp1
   2176  0c56		       ad 1f 43 	      lda	random
   2177  0c59		       0a		      asl
   2178  0c5a		       2e 1d 43 	      rol	rtemp1
   2179  0c5d		       0a		      asl
   2180  0c5e		       2e 1d 43 	      rol	rtemp1
   2181  0c61		       18		      clc
   2182  0c62		       6d 1f 43 	      adc	random
   2183  0c65
   2184  0c65		       48		      pha
   2185  0c66
   2186  0c66		       ad 1d 43 	      lda	rtemp1
   2187  0c69		       6d 20 43 	      adc	random+1
   2188  0c6c		       8d 20 43 	      sta	random+1
   2189  0c6f
   2190  0c6f		       68		      pla
   2191  0c70
   2192  0c70		       69 11		      adc	#$11
   2193  0c72		       8d 1f 43 	      sta	random
   2194  0c75		       ad 20 43 	      lda	random+1
   2195  0c78		       69 36		      adc	#$36
   2196  0c7a		       8d 20 43 	      sta	random+1
   2197  0c7d
   2198  0c7d		       ad 1f 43 	      lda	random
   2199  0c80		       85 52		      sta	R0
   2200  0c82		       ad 20 43 	      lda	random+1
   2201  0c85		       29 7f		      and	#$7f	;make positive
   2202  0c87		       85 53		      sta	R0+1
   2203  0c89							;
   2204  0c89							; R0 contains the number and R1 contains the max value.
   2205  0c89							;
   2206  0c89		       20 43 07 	      jsr	iDivNoPop
   2207  0c8c		       20 37 2d 	      jsr	RestoreSigns
   2208  0c8f		       a5 56		      lda	MQ
   2209  0c91		       85 52		      sta	R0
   2210  0c93		       a5 57		      lda	MQ+1
   2211  0c95		       85 53		      sta	R0+1
   2212  0c97		       4c 1d 07 	      jmp	pushR0nextIl
   2213  0c9a				   irandom1
   2214  0c9a		       a9 00		      lda	#0
   2215  0c9c		       85 53		      sta	R0+1
   2216  0c9e		       a9 01		      lda	#1
   2217  0ca0		       85 52		      sta	R0
   2218  0ca2		       4c 1d 07 	      jmp	pushR0nextIl
   2219  0ca5
   2220  0ca5							; The following replaced by call to division/modulo
   2221  0ca5							;iRANDOM_2	lda	R0
   2222  0ca5							;		cmp	R1
   2223  0ca5							;		bne	iRANDOM_1
   2224  0ca5							;		lda	R0+1
   2225  0ca5							;		cmp	R1+1
   2226  0ca5							;		bne	iRANDOM_1	;need to subtract
   2227  0ca5							;
   2228  0ca5							; Subtract R1 from R0
   2229  0ca5							;
   2230  0ca5							;iRANDOM_sub	sec
   2231  0ca5							;		lda	R0
   2232  0ca5							;		sbc	R1
   2233  0ca5							;		sta	R0
   2234  0ca5							;		lda	R0+1
   2235  0ca5							;		sbc	R1+1
   2236  0ca5							;		sta	R0+1
   2237  0ca5							;		jmp	iRANDOM_2
   2238  0ca5							;
   2239  0ca5							; See if R1 > R0.  If so, branch to subtract.
   2240  0ca5							;
   2241  0ca5							;iRANDOM_1	lda	R0
   2242  0ca5							;		cmp	R1
   2243  0ca5							;		lda	R0+1
   2244  0ca5							;		sbc	R1+1
   2245  0ca5							;		bvc	iRANDOM_4
   2246  0ca5							;		eor	#$80
   2247  0ca5							;iRANDOM_4	bpl	iRANDOM_sub
   2248  0ca5							;
   2249  0ca5							; All done.  Almost.  Add one, then push the result.
   2250  0ca5							;
   2251  0ca5							;irandom1	inc	R0
   2252  0ca5							;		bne	iRANDOM_3
   2253  0ca5							;		inc	R0+1
   2254  0ca5							;iRANDOM_3
   2255  0ca5							;		  jsr	pushR0	;return value
   2256  0ca5							;		jmp	NextIL
   2257  0ca5							;
   2258  0ca5							; Poke a value into a memory location
   2259  0ca5		       8c 21 43    iPOKEMEMORY sty	tempy
   2260  0ca8		       20 b6 2c 	      jsr	popR0
   2261  0cab		       20 ce 2c 	      jsr	popR1
   2262  0cae		       a0 00		      ldy	#0
   2263  0cb0		       a5 52		      lda	R0
   2264  0cb2		       91 54		      sta	(R1),y
   2265  0cb4		       ac 21 43 	      ldy	tempy
   2266  0cb7		       4c b1 02 	      jmp	NextIL
   2267  0cba							;
   2268  0cba							; Get a value from a memory location
   2269  0cba							;
   2270  0cba		       8c 21 43    iPEEKMEMORY sty	tempy
   2271  0cbd		       20 b6 2c 	      jsr	popR0
   2272  0cc0		       a0 00		      ldy	#0
   2273  0cc2		       b1 52		      lda	(R0),y
   2274  0cc4		       ac 21 43 	      ldy	tempy
   2275  0cc7		       85 52		      sta	R0
   2276  0cc9		       a9 00		      lda	#0
   2277  0ccb		       85 53		      sta	R0+1
   2278  0ccd		       4c 1d 07 	      jmp	pushR0nextIl
   2279  0cd0							;
   2280  0cd0							; Call to address return what ever is in a to the stack
   2281  0cd0							; func2 will load a value into a before the call
   2282  0cd0		       20 ce 2c    iCallFunc  jsr	popR1
   2283  0cd3		       a5 54		      lda	R1
   2284  0cd5		       20 e1 0c 	      jsr	iCallRtn
   2285  0cd8		       85 52		      sta	R0
   2286  0cda		       a9 00		      lda	#0
   2287  0cdc		       85 53		      sta	R0+1
   2288  0cde		       20 1d 07 	      jsr	pushR0nextIl
   2289  0ce1				   iCallRtn
   2290  0ce1		       20 b6 2c 	      jsr	popR0
   2291  0ce4		       6c 52 00 	      jmp	(R0)
   2292  0ce7
   2293  0ce7
   2294  0ce7							;===========================================jlit======
   2295  0ce7							;Get a character from the terminal convert to value
   2296  0ce7							;leave the number on top of the stack
   2297  0ce7							;
   2298  0ce7				   iGETCHAR
   2299  0ce7		       20 58 1a 	      jsr	VGETCH
   2300  0cea					      if	CTMON65
   2301  0cea		       48		      pha
   2302  0ceb		       20 55 1a 	      jsr	VOUTCH	;echo echo echo
   2303  0cee		       68		      pla
   2304  0cef					      endif
   2305  0cef		       85 52		      sta	R0
   2306  0cf1		       a9 00		      lda	#0
   2307  0cf3		       85 53		      sta	R0+1
   2308  0cf5		       20 24 2c 	      jsr	pushR0
   2309  0cf8							;
   2310  0cf8		       4c b1 02 	      jmp	NextIL
   2311  0cfb							;===========================================jusilostintim======
   2312  0cfb							;Put a character to the terminal convert to
   2313  0cfb							;
   2314  0cfb		       20 b6 2c    iPUTCHAR   jsr	popR0
   2315  0cfe		       a5 52		      lda	R0
   2316  0d00		       20 55 1a 	      jsr	VOUTCH
   2317  0d03		       4c b1 02 	      jmp	NextIL
   2318  0d06							;=====================================================
   2319  0d06							; Put the number on the stack out as hex, suppress leading 0
   2320  0d06				   iHexOut
   2321  0d06		       20 b6 2c 	      jsr	popR0
   2322  0d09		       a5 53		      lda	R0+1
   2323  0d0b		       f0 03		      beq	iHexSecondByte
   2324  0d0d		       20 90 21 	      jsr	OUTHEX
   2325  0d10				   iHexSecondByte
   2326  0d10		       a5 52		      lda	R0
   2327  0d12		       20 90 21 	      jsr	OUTHEX
   2328  0d15		       4c b1 02 	      jmp	NextIL
   2329  0d18							;
   2330  0d18							;=====================================================
   2331  0d18							; Replace TOS with its absolute value.
   2332  0d18							;
   2333  0d18		       20 b6 2c    iABS       jsr	popR0
   2334  0d1b		       a5 53		      lda	R0+1
   2335  0d1d		       10 10		      bpl	iABS_1	;already positive
   2336  0d1f		       49 ff		      eor	#$ff
   2337  0d21		       85 53		      sta	R0+1
   2338  0d23		       a5 52		      lda	R0
   2339  0d25		       49 ff		      eor	#$ff
   2340  0d27		       85 52		      sta	R0
   2341  0d29		       e6 52		      inc	R0
   2342  0d2b		       d0 02		      bne	iABS_1
   2343  0d2d		       e6 53		      inc	R0+1
   2344  0d2f		       4c 1d 07    iABS_1     jmp	pushR0nextIl
   2345  0d32
   2346  0d32							;
   2347  0d32							;================================================================
   2348  0d32							; The set of logical operators
   2349  0d32				   iLogAnd
   2350  0d32		       20 b6 2c 	      jsr	popR0
   2351  0d35		       20 ce 2c 	      jsr	popR1
   2352  0d38		       a5 52		      lda	R0
   2353  0d3a		       25 54		      and	R1
   2354  0d3c		       85 52		      sta	R0
   2355  0d3e		       a5 53		      lda	R0+1
   2356  0d40		       25 55		      and	R1+1
   2357  0d42		       85 53		      sta	R0+1
   2358  0d44		       4c 1d 07 	      jmp	pushR0nextIl
   2359  0d47
   2360  0d47				   iLogOr
   2361  0d47		       20 b6 2c 	      jsr	popR0
   2362  0d4a		       20 ce 2c 	      jsr	popR1
   2363  0d4d		       a5 52		      lda	R0
   2364  0d4f		       05 54		      ora	R1
   2365  0d51		       85 52		      sta	R0
   2366  0d53		       a5 53		      lda	R0+1
   2367  0d55		       05 55		      ora	R1+1
   2368  0d57		       85 53		      sta	R0+1
   2369  0d59		       4c 1d 07 	      jmp	pushR0nextIl
   2370  0d5c				   iLogXor
   2371  0d5c		       20 b6 2c 	      jsr	popR0
   2372  0d5f		       20 ce 2c 	      jsr	popR1
   2373  0d62		       a5 52		      lda	R0
   2374  0d64		       45 54		      eor	R1
   2375  0d66		       85 52		      sta	R0
   2376  0d68		       a5 53		      lda	R0+1
   2377  0d6a		       45 55		      eor	R1+1
   2378  0d6c		       85 53		      sta	R0+1
   2379  0d6e		       4c 1d 07 	      jmp	pushR0nextIl
   2380  0d71				   iLogNot
   2381  0d71		       20 b6 2c 	      jsr	popR0
   2382  0d74		       a5 52		      lda	R0
   2383  0d76		       49 ff		      eor	#$FF
   2384  0d78		       85 52		      sta	R0
   2385  0d7a		       a5 53		      lda	R0+1
   2386  0d7c		       49 ff		      eor	#$FF
   2387  0d7e		       85 53		      sta	R0+1
   2388  0d80		       4c 1d 07 	      jmp	pushR0nextIl
   2389  0d83
   2390  0d83				   iTruth
   2391  0d83		       a9 ff		      lda	#$FF
   2392  0d85		       85 52		      sta	R0
   2393  0d87		       85 53		      sta	R0+1
   2394  0d89		       4c 1d 07 	      jmp	pushR0nextIl
   2395  0d8c				   iFalse
   2396  0d8c		       a9 00		      lda	#$00
   2397  0d8e		       85 52		      sta	R0
   2398  0d90		       85 53		      sta	R0+1
   2399  0d92		       4c 1d 07 	      jmp	pushR0nextIl
   2400  0d95							;===============================================================
   2401  0d95							;Shift instruction right 1, left 0
   2402  0d95							;
   2403  0d95		       8a	   iShift     txa
   2404  0d96		       48		      pha
   2405  0d97		       20 b6 2c 	      jsr	popR0	; number of places to shift 0 to 16 really
   2406  0d9a		       20 ce 2c 	      jsr	popR1	; value to shift
   2407  0d9d		       a6 52		      ldx	R0	; get number of times to shift
   2408  0d9f		       20 2b 2a 	      jsr	getILByte	; get direction to shift
   2409  0da2		       c9 01		      cmp	#1	; Should we be doing left
   2410  0da4		       f0 0a		      beq	iShiftRight
   2411  0da6							;
   2412  0da6							; Shift r1 left n bits
   2413  0da6				   iShiftLeft
   2414  0da6		       18	   iShiftLloop clc
   2415  0da7		       26 54		      rol	R1
   2416  0da9		       26 55		      rol	R1+1
   2417  0dab		       ca		      dex
   2418  0dac		       d0 f8		      bne	iShiftLloop
   2419  0dae		       f0 07		      beq	iShiftExit
   2420  0db0							;
   2421  0db0							; Shift R1 right n bits
   2422  0db0							;
   2423  0db0				   iShiftRight
   2424  0db0		       46 55	   iShiftRloop lsr	R1+1
   2425  0db2		       46 54		      lsr	R1
   2426  0db4		       ca		      dex
   2427  0db5		       d0 f9		      bne	iShiftRloop
   2428  0db7				   iShiftExit
   2429  0db7		       68		      pla
   2430  0db8		       aa		      tax
   2431  0db9		       20 9c 2c 	      jsr	pushR1
   2432  0dbc		       4c b1 02 	      jmp	NextIL
   2433  0dbf
   2434  0dbf							;================================================================
   2435  0dbf							;Set the IRQ service rtn line number
   2436  0dbf							;
   2437  0dbf		       78	   iSetIrq    sei		; disable the interupts
   2438  0dc0		       a9 00		      lda	#0	; Zero the Status flag
   2439  0dc2		       8d b7 19 	      sta	IRQStatus
   2440  0dc5		       20 b6 2c 	      jsr	popR0	; get the line number
   2441  0dc8		       a5 52		      lda	R0
   2442  0dca		       05 53		      ora	R0+1
   2443  0dcc		       f0 22		      beq	iSetExt	; if it is zero disable all
   2444  0dce		       a9 01		      lda	#GOSUB_RTN	; default push type
   2445  0dd0		       20 3e 2c 	      jsr	pushLN	; Save the current line pointer
   2446  0dd3		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2447  0dd5		       4c 3a 0c 	      jmp	ErrStkOver	; Check if there was an error
   2448  0dd8				   iSetIrqOk
   2449  0dd8		       20 70 2a 	      jsr	findLine	; Find the IRQ func Line Pointer
   2450  0ddb		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2451  0ddd		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2452  0ddf		       8d ba 19 	      sta	IRQEntry+1
   2453  0de2		       a5 4f		      lda	CURPTR
   2454  0de4		       8d b9 19 	      sta	IRQEntry
   2455  0de7		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2456  0de9		       8d b7 19 	      sta	IRQStatus
   2457  0dec		       20 67 2c 	      jsr	popLN	; Restore the old line number
   2458  0def		       58		      cli		; Enable the interupts
   2459  0df0		       4c b1 02    iSetExt    jmp	NextIL
   2460  0df3
   2461  0df3		       20 67 2c    iSetIrqErr jsr	popLN
   2462  0df6		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2463  0df8		       a9 00		      lda	#0
   2464  0dfa		       4c 7d 06 	      jmp	iErr2
   2465  0dfd							;
   2466  0dfd		       20 b6 2c    iTRACEPROG jsr	popR0
   2467  0e00		       a5 52		      lda	R0
   2468  0e02		       85 40		      sta	ILTrace
   2469  0e04		       4c b1 02 	      jmp	NextIL
   2470  0e07
   2471  0e07							;=====================================================
   2472  0e07							; Define start of non page zero data
   2473 U4337 ????				      seg.u	TBData
   2474 U3661					      org	PROGEND
   2475 U3661							;=================================================================
   2476 U3661							;
   2477 U3661					      if	IL_DEBUG_TEXT
------- FILE ILKeyText.inc LEVEL 2 PASS 6
      0 U3661					      include	"ILKeyText.inc"
      1  0e07					      seg	Code
      2  0e07					      if	IL_DEBUG_TEXT
      3  0e07				   ILTEXTTABLE
      0  0e07					      db	0,23,"iXINIT		   ",0
      1  0e07		       00 17 69 58*	      .byte.b	0,23,"iXINIT		   ",0
      0  0e1e					      db	1,23,"iDONE		   ",0
      1  0e1e		       01 17 69 44*	      .byte.b	1,23,"iDONE		   ",0
      0  0e35					      db	2,23,"iPRS		   ",0
      1  0e35		       02 17 69 50*	      .byte.b	2,23,"iPRS		   ",0
      0  0e4c					      db	3,23,"iPRN		   ",0
      1  0e4c		       03 17 69 50*	      .byte.b	3,23,"iPRN		   ",0
      0  0e63					      db	4,23,"iSPC		   ",0
      1  0e63		       04 17 69 53*	      .byte.b	4,23,"iSPC		   ",0
      0  0e7a					      db	5,23,"iNLINE		   ",0
      1  0e7a		       05 17 69 4e*	      .byte.b	5,23,"iNLINE		   ",0
      0  0e91					      db	6,23,"iNXT		   ",0
      1  0e91		       06 17 69 4e*	      .byte.b	6,23,"iNXT		   ",0
      0  0ea8					      db	7,23,"iXFER		   ",0
      1  0ea8		       07 17 69 58*	      .byte.b	7,23,"iXFER		   ",0
      0  0ebf					      db	8,23,"iSAV		   ",0
      1  0ebf		       08 17 69 53*	      .byte.b	8,23,"iSAV		   ",0
      0  0ed6					      db	9,23,"iRSTR		   ",0
      1  0ed6		       09 17 69 52*	      .byte.b	9,23,"iRSTR		   ",0
      0  0eed					      db	10,23,"iCMPR		    ",0
      1  0eed		       0a 17 69 43*	      .byte.b	10,23,"iCMPR		    ",0
      0  0f04					      db	11,23,"iINNUM		    ",0
      1  0f04		       0b 17 69 49*	      .byte.b	11,23,"iINNUM		    ",0
      0  0f1b					      db	12,23,"iFIN		    ",0
      1  0f1b		       0c 17 69 46*	      .byte.b	12,23,"iFIN		    ",0
      0  0f32					      db	13,23,"iERR		    ",0
      1  0f32		       0d 17 69 45*	      .byte.b	13,23,"iERR		    ",0
      0  0f49					      db	14,23,"iADD		    ",0
      1  0f49		       0e 17 69 41*	      .byte.b	14,23,"iADD		    ",0
      0  0f60					      db	15,23,"iSUB		    ",0
      1  0f60		       0f 17 69 53*	      .byte.b	15,23,"iSUB		    ",0
      0  0f77					      db	16,23,"iNEG		    ",0
      1  0f77		       10 17 69 4e*	      .byte.b	16,23,"iNEG		    ",0
      0  0f8e					      db	17,23,"iMUL		    ",0
      1  0f8e		       11 17 69 4d*	      .byte.b	17,23,"iMUL		    ",0
      0  0fa5					      db	18,23,"iDIV		    ",0
      1  0fa5		       12 17 69 44*	      .byte.b	18,23,"iDIV		    ",0
      0  0fbc					      db	19,23,"iSTORE		    ",0
      1  0fbc		       13 17 69 53*	      .byte.b	19,23,"iSTORE		    ",0
      0  0fd3					      db	20,23,"iIND		    ",0
      1  0fd3		       14 17 69 49*	      .byte.b	20,23,"iIND		    ",0
      0  0fea					      db	21,23,"iLST		    ",0
      1  0fea		       15 17 69 4c*	      .byte.b	21,23,"iLST		    ",0
      0  1001					      db	22,23,"iINIT		    ",0
      1  1001		       16 17 69 49*	      .byte.b	22,23,"iINIT		    ",0
      0  1018					      db	23,23,"iGETLINE	    ",0
      1  1018		       17 17 69 47*	      .byte.b	23,23,"iGETLINE	    ",0
      0  102f					      db	24,23,"iINSRT		    ",0
      1  102f		       18 17 69 49*	      .byte.b	24,23,"iINSRT		    ",0
      0  1046					      db	25,23,"iRTN		    ",0
      1  1046		       19 17 69 52*	      .byte.b	25,23,"iRTN		    ",0
      0  105d					      db	26,23,"MONITOR 	    ",0
      1  105d		       1a 17 4d 4f*	      .byte.b	26,23,"MONITOR 	    ",0
      0  1074					      db	27,23,"iLIT		    ",0
      1  1074		       1b 17 69 4c*	      .byte.b	27,23,"iLIT		    ",0
      0  108b					      db	28,23,"iCALL		    ",0
      1  108b		       1c 17 69 43*	      .byte.b	28,23,"iCALL		    ",0
      0  10a2					      db	29,23,"iJMP		    ",0
      1  10a2		       1d 17 69 4a*	      .byte.b	29,23,"iJMP		    ",0
      0  10b9					      db	30,23,"iVINIT		    ",0
      1  10b9		       1e 17 69 56*	      .byte.b	30,23,"iVINIT		    ",0
      0  10d0					      db	31,23,"iERRGOTO	    ",0
      1  10d0		       1f 17 69 45*	      .byte.b	31,23,"iERRGOTO	    ",0
      0  10e7					      db	32,23,"iTST		    ",0
      1  10e7		       20 17 69 54*	      .byte.b	32,23,"iTST		    ",0
      0  10fe					      db	33,23,"iTSTV		    ",0
      1  10fe		       21 17 69 54*	      .byte.b	33,23,"iTSTV		    ",0
      0  1115					      db	34,23,"iTSTL		    ",0
      1  1115		       22 17 69 54*	      .byte.b	34,23,"iTSTL		    ",0
      0  112c					      db	35,23,"iTSTN		    ",0
      1  112c		       23 17 69 54*	      .byte.b	35,23,"iTSTN		    ",0
      0  1143					      db	36,23,"iFREE		    ",0
      1  1143		       24 17 69 46*	      .byte.b	36,23,"iFREE		    ",0
      0  115a					      db	37,23,"iRANDOM 	    ",0
      1  115a		       25 17 69 52*	      .byte.b	37,23,"iRANDOM 	    ",0
      0  1171					      db	38,23,"iABS		    ",0
      1  1171		       26 17 69 41*	      .byte.b	38,23,"iABS		    ",0
      0  1188					      db	39,23,"iOPENREAD	    ",0
      1  1188		       27 17 69 4f*	      .byte.b	39,23,"iOPENREAD	    ",0
      0  119f					      db	40,23,"iOPENWRITE	    ",0
      1  119f		       28 17 69 4f*	      .byte.b	40,23,"iOPENWRITE	    ",0
      0  11b6					      db	41,23,"iDCLOSE 	    ",0
      1  11b6		       29 17 69 44*	      .byte.b	41,23,"iDCLOSE 	    ",0
      0  11cd					      db	42,23,"iDGETLINE	    ",0
      1  11cd		       2a 17 69 44*	      .byte.b	42,23,"iDGETLINE	    ",0
      0  11e4					      db	43,23,"iDLIST		    ",0
      1  11e4		       2b 17 69 44*	      .byte.b	43,23,"iDLIST		    ",0
      0  11fb					      db	44,23,"iDDIR		    ",0
      1  11fb		       2c 17 69 44*	      .byte.b	44,23,"iDDIR		    ",0
      0  1212					      db	45,23,"iRMFILE 	    ",0
      1  1212		       2d 17 69 52*	      .byte.b	45,23,"iRMFILE 	    ",0
      0  1229					      db	39,23,"NextIL		    ",0
      1  1229		       27 17 4e 65*	      .byte.b	39,23,"NextIL		    ",0
      0  1240					      db	40,23,"NextIL		    ",0
      1  1240		       28 17 4e 65*	      .byte.b	40,23,"NextIL		    ",0
      0  1257					      db	41,23,"NextIL		    ",0
      1  1257		       29 17 4e 65*	      .byte.b	41,23,"NextIL		    ",0
      0  126e					      db	42,23,"NextIL		    ",0
      1  126e		       2a 17 4e 65*	      .byte.b	42,23,"NextIL		    ",0
      0  1285					      db	43,23,"NextIL		    ",0
      1  1285		       2b 17 4e 65*	      .byte.b	43,23,"NextIL		    ",0
      0  129c					      db	44,23,"NextIL		    ",0
      1  129c		       2c 17 4e 65*	      .byte.b	44,23,"NextIL		    ",0
      0  12b3					      db	45,23,"NextIL		    ",0
      1  12b3		       2d 17 4e 65*	      .byte.b	45,23,"NextIL		    ",0
      0  12ca					      db	46,23,"iCLEARSCREEN	    ",0
      1  12ca		       2e 17 69 43*	      .byte.b	46,23,"iCLEARSCREEN	    ",0
      0  12e1					      db	47,23,"iPOKEMEMORY	    ",0
      1  12e1		       2f 17 69 50*	      .byte.b	47,23,"iPOKEMEMORY	    ",0
      0  12f8					      db	48,23,"iPEEKMEMORY	    ",0
      1  12f8		       30 17 69 50*	      .byte.b	48,23,"iPEEKMEMORY	    ",0
      0  130f					      db	49,23,"iTSTLET 	    ",0
      1  130f		       31 17 69 54*	      .byte.b	49,23,"iTSTLET 	    ",0
      0  1326					      db	50,23,"iTSTDONE	    ",0
      1  1326		       32 17 69 54*	      .byte.b	50,23,"iTSTDONE	    ",0
      0  133d					      db	51,23,"iGETCHAR	    ",0
      1  133d		       33 17 69 47*	      .byte.b	51,23,"iGETCHAR	    ",0
      0  1354					      db	52,23,"iPUTCHAR	    ",0
      1  1354		       34 17 69 50*	      .byte.b	52,23,"iPUTCHAR	    ",0
      0  136b					      db	53,23,"iCallFunc	    ",0
      1  136b		       35 17 69 43*	      .byte.b	53,23,"iCallFunc	    ",0
      0  1382					      db	54,23,"iBranch 	    ",0
      1  1382		       36 17 69 42*	      .byte.b	54,23,"iBranch 	    ",0
      0  1399					      db	55,23,"iTSTStr 	    ",0
      1  1399		       37 17 69 54*	      .byte.b	55,23,"iTSTStr 	    ",0
      0  13b0					      db	56,23,"iSetIrq 	    ",0
      1  13b0		       38 17 69 53*	      .byte.b	56,23,"iSetIrq 	    ",0
      0  13c7					      db	57,23,"iTstIrq 	    ",0
      1  13c7		       39 17 69 54*	      .byte.b	57,23,"iTstIrq 	    ",0
      0  13de					      db	58,23,"iRET		    ",0
      1  13de		       3a 17 69 52*	      .byte.b	58,23,"iRET		    ",0
      0  13f5					      db	59,23,"iINSTR		    ",0
      1  13f5		       3b 17 69 49*	      .byte.b	59,23,"iINSTR		    ",0
      0  140c					      db	60,23,"iMOD		    ",0
      1  140c		       3c 17 69 4d*	      .byte.b	60,23,"iMOD		    ",0
      0  1423					      db	61,23,"iTaskSet	    ",0
      1  1423		       3d 17 69 54*	      .byte.b	61,23,"iTaskSet	    ",0
      0  143a					      db	62,23,"iETask		    ",0
      1  143a		       3e 17 69 45*	      .byte.b	62,23,"iETask		    ",0
      0  1451					      db	63,23,"iNTask		    ",0
      1  1451		       3f 17 69 4e*	      .byte.b	63,23,"iNTask		    ",0
      0  1468					      db	64,23,"iArray		    ",0
      1  1468		       40 17 69 41*	      .byte.b	64,23,"iArray		    ",0
      0  147f					      db	65,23,"iTaskKill	    ",0
      1  147f		       41 17 69 54*	      .byte.b	65,23,"iTaskKill	    ",0
      0  1496					      db	66,23,"iTaskStat	    ",0
      1  1496		       42 17 69 54*	      .byte.b	66,23,"iTaskStat	    ",0
      0  14ad					      db	67,23,"iHexOut 	    ",0
      1  14ad		       43 17 69 48*	      .byte.b	67,23,"iHexOut 	    ",0
      0  14c4					      db	68,23,"iReadComplete	    ",0
      1  14c4		       44 17 69 52*	      .byte.b	68,23,"iReadComplete	    ",0
      0  14db					      db	69,23,"iReadStart	    ",0
      1  14db		       45 17 69 52*	      .byte.b	69,23,"iReadStart	    ",0
      0  14f2					      db	70,23,"iStartIO	    ",0
      1  14f2		       46 17 69 53*	      .byte.b	70,23,"iStartIO	    ",0
      0  1509					      db	71,23,"iEndIO		    ",0
      1  1509		       47 17 69 45*	      .byte.b	71,23,"iEndIO		    ",0
      0  1520					      db	72,23,"iLogNot 	    ",0
      1  1520		       48 17 69 4c*	      .byte.b	72,23,"iLogNot 	    ",0
      0  1537					      db	73,23,"iLogOr		    ",0
      1  1537		       49 17 69 4c*	      .byte.b	73,23,"iLogOr		    ",0
      0  154e					      db	74,23,"iLogAnd 	    ",0
      1  154e		       4a 17 69 4c*	      .byte.b	74,23,"iLogAnd 	    ",0
      0  1565					      db	75,23,"iLogXor 	    ",0
      1  1565		       4b 17 69 4c*	      .byte.b	75,23,"iLogXor 	    ",0
      0  157c					      db	76,23,"iWTASK		    ",0
      1  157c		       4c 17 69 57*	      .byte.b	76,23,"iWTASK		    ",0
      0  1593					      db	77,23,"iTASKPID	    ",0
      1  1593		       4d 17 69 54*	      .byte.b	77,23,"iTASKPID	    ",0
      0  15aa					      db	78,23,"iTRACEPROG	    ",0
      1  15aa		       4e 17 69 54*	      .byte.b	78,23,"iTRACEPROG	    ",0
      0  15c1					      db	79,23,"idbgBasic	    ",0
      1  15c1		       4f 17 69 64*	      .byte.b	79,23,"idbgBasic	    ",0
      0  15d8					      db	80,23,"iIPCS		    ",0
      1  15d8		       50 17 69 49*	      .byte.b	80,23,"iIPCS		    ",0
      0  15ef					      db	81,23,"iIPCR		    ",0
      1  15ef		       51 17 69 49*	      .byte.b	81,23,"iIPCR		    ",0
      0  1606					      db	82,23,"iIPCC		    ",0
      1  1606		       52 17 69 49*	      .byte.b	82,23,"iIPCC		    ",0
      0  161d					      db	83,23,"iIPCIO		    ",0
      1  161d		       53 17 69 49*	      .byte.b	83,23,"iIPCIO		    ",0
      0  1634					      db	84,23,"iPushMathStack	    ",0
      1  1634		       54 17 69 50*	      .byte.b	84,23,"iPushMathStack	    ",0
      0  164b					      db	85,23,"iPopMathStack	    ",0
      1  164b		       55 17 69 50*	      .byte.b	85,23,"iPopMathStack	    ",0
      0  1662					      db	86,23,"iSaveMathStack	    ",0
      1  1662		       56 17 69 53*	      .byte.b	86,23,"iSaveMathStack	    ",0
      0  1679					      db	87,23,"iRestoreMathStack   ",0
      1  1679		       57 17 69 52*	      .byte.b	87,23,"iRestoreMathStack   ",0
      0  1690					      db	88,23,"iIncParmCount	    ",0
      1  1690		       58 17 69 49*	      .byte.b	88,23,"iIncParmCount	    ",0
      0  16a7					      db	89,23,"iTaskGetMathStack   ",0
      1  16a7		       59 17 69 54*	      .byte.b	89,23,"iTaskGetMathStack   ",0
      0  16be					      db	90,23,"iTaskEnable	    ",0
      1  16be		       5a 17 69 54*	      .byte.b	90,23,"iTaskEnable	    ",0
      0  16d5					      db	91,23,"iTaskSuspend	    ",0
      1  16d5		       5b 17 69 54*	      .byte.b	91,23,"iTaskSuspend	    ",0
      0  16ec					      db	92,23,"iTaskPutMathPtr     ",0
      1  16ec		       5c 17 69 54*	      .byte.b	92,23,"iTaskPutMathPtr     ",0
      0  1703					      db	93,23,"iTSTVT		    ",0
      1  1703		       5d 17 69 54*	      .byte.b	93,23,"iTSTVT		    ",0
      0  171a					      db	94,23,"iSetR2		    ",0
      1  171a		       5e 17 69 53*	      .byte.b	94,23,"iSetR2		    ",0
      0  1731					      db	95,23,"iStk2Tmp	    ",0
      1  1731		       5f 17 69 53*	      .byte.b	95,23,"iStk2Tmp	    ",0
      0  1748					      db	96,23,"iTmp2Stk	    ",0
      1  1748		       60 17 69 54*	      .byte.b	96,23,"iTmp2Stk	    ",0
      0  175f					      db	97,23,"iTSTBYTE	    ",0
      1  175f		       61 17 69 54*	      .byte.b	97,23,"iTSTBYTE	    ",0
      0  1776					      db	98,23,"iINCVAR 	    ",0
      1  1776		       62 17 69 49*	      .byte.b	98,23,"iINCVAR 	    ",0
      0  178d					      db	99,23,"iDECVAR 	    ",0
      1  178d		       63 17 69 44*	      .byte.b	99,23,"iDECVAR 	    ",0
      0  17a4					      db	100,23,"iSLICE 	     ",0
      1  17a4		       64 17 69 53*	      .byte.b	100,23,"iSLICE 	     ",0
      0  17bb					      db	101,23,"iTSTB		     ",0
      1  17bb		       65 17 69 54*	      .byte.b	101,23,"iTSTB		     ",0
      0  17d2					      db	102,23,"iTSTW		     ",0
      1  17d2		       66 17 69 54*	      .byte.b	102,23,"iTSTW		     ",0
      0  17e9					      db	103,23,"iOnGoto	     ",0
      1  17e9		       67 17 69 4f*	      .byte.b	103,23,"iOnGoto	     ",0
      0  1800					      db	104,23,"iTSTRELOP	     ",0
      1  1800		       68 17 69 54*	      .byte.b	104,23,"iTSTRELOP	     ",0
      0  1817					      db	105,23,"iRepeatLine	     ",0
      1  1817		       69 17 69 52*	      .byte.b	105,23,"iRepeatLine	     ",0
      0  182e					      db	106,23,"iTSTBRANCH	     ",0
      1  182e		       6a 17 69 54*	      .byte.b	106,23,"iTSTBRANCH	     ",0
      0  1845					      db	107,23,"iFastXfer	     ",0
      1  1845		       6b 17 69 46*	      .byte.b	107,23,"iFastXfer	     ",0
      0  185c					      db	108,23,"iSetTerminal	     ",0
      1  185c		       6c 17 69 53*	      .byte.b	108,23,"iSetTerminal	     ",0
      0  1873					      db	109,23,"iINDB		     ",0
      1  1873		       6d 17 69 49*	      .byte.b	109,23,"iINDB		     ",0
      0  188a					      db	110,23,"iSetBlock	     ",0
      1  188a		       6e 17 69 53*	      .byte.b	110,23,"iSetBlock	     ",0
      0  18a1					      db	111,23,"iCopyBlock	     ",0
      1  18a1		       6f 17 69 43*	      .byte.b	111,23,"iCopyBlock	     ",0
      0  18b8					      db	112,23,"iCmpBlock	     ",0
      1  18b8		       70 17 69 43*	      .byte.b	112,23,"iCmpBlock	     ",0
      0  18cf					      db	113,23,"iShift 	     ",0
      1  18cf		       71 17 69 53*	      .byte.b	113,23,"iShift 	     ",0
      0  18e6					      db	114,23,"iTimer 	     ",0
      1  18e6		       72 17 69 54*	      .byte.b	114,23,"iTimer 	     ",0
      0  18fd					      db	$FF,23,"0		     ",0
      1  18fd		       ff 17 30 20*	      .byte.b	$FF,23,"0		     ",0
    127  1914
    128  1914							; Search for the il instruction and print the correct text for it
    129  1914							; on entry a contains the ip instruction to print
    130  1914
    131 U3661					      seg.u	TBData
    132 U3661		       00 00	   R0TempIL   ds	2
    133 U3663		       00	   ILSTA      ds	1
    134 U3664
    135  1914					      Seg	Code
    136  1914
    137  1914		       8d 63 36    PrintILText sta	ILSTA
    138  1917		       98		      tya
    139  1918		       48		      pha
    140  1919		       8a		      txa
    141  191a		       48		      pha
    142  191b		       a5 52		      lda	R0
    143  191d		       8d 61 36 	      sta	R0TempIL
    144  1920		       a5 53		      lda	R0+1
    145  1922		       8d 61 36 	      sta	R0TempIL
    146  1925		       a9 07		      lda	#ILTEXTTABLE&$FF
    147  1927		       85 52		      sta	R0
    148  1929		       a9 0e		      LDA	#ILTEXTTABLE>>8
    149  192b		       85 53		      sta	R0+1
    150  192d							;Loop Here for each entry
    151  192d		       a0 00	   PrintILLoop ldy	#0
    152  192f		       b1 52		      lda	(R0),y
    153  1931		       c9 ff		      cmp	#$FF
    154  1933		       f0 2a		      beq	PrintILNotFound
    155  1935		       cd 63 36 	      cmp	ILSTA
    156  1938		       f0 11		      beq	PrintILFound
    157  193a		       c8		      iny
    158  193b		       b1 52		      lda	(R0),y
    159  193d		       18		      clc
    160  193e		       65 52		      adc	R0
    161  1940		       85 52		      sta	R0
    162  1942		       a9 00		      lda	#0
    163  1944		       65 53		      adc	R0+1
    164  1946		       85 53		      sta	R0+1
    165  1948		       4c 2d 19 	      jmp	PrintILLoop
    166  194b							; The text was discovered
    167  194b		       c8	   PrintILFound iny		; point to length of instruction
    168  194c		       c8		      iny		; Point to start of text
    169  194d		       98		      tya
    170  194e		       18		      clc
    171  194f		       65 52		      adc	R0
    172  1951		       a8		      tay		; Low order byte of address
    173  1952		       a9 00		      lda	#0
    174  1954		       65 53		      adc	R0+1
    175  1956		       aa		      tax		; High order byte of address
    176  1957		       a9 00		      lda	#0	; Termination byte of string
    177  1959		       20 eb 21 	      jsr	PrtStr	; print the string
    178  195c		       4c 65 19 	      jmp	PrintILDone
    179  195f
    180  195f		       ad 63 36    PrintILNotFound lda	ILSTA
    181  1962		       20 90 21 	      jsr	HexToOut
    182  1965
    183  1965		       ad 61 36    PrintILDone lda	R0TempIL
    184  1968		       85 52		      sta	R0
    185  196a		       ad 62 36 	      lda	R0TempIL+1
    186  196d		       85 52		      sta	R0
    187  196f		       68		      pla
    188  1970		       aa		      tax
    189  1971		       68		      pla
    190  1972		       a8		      tay
    191  1973		       60		      rts
    192  1974					      endif
------- FILE mytb.asm
   2479  1974					      endif
------- FILE time.asm LEVEL 2 PASS 6
      0  1974					      include	"time.asm"
      1  1974							;This is the timer management functions
      2  1974							; a = 0 turn off irq, stop timer
      3  1974							; a = 1 turn on irq, set parm contained in x
      4  1974							; a = 4 get low value
      5  1974							; a = 2 get high value
      6  1974
      7  1974		       e0 10	   timerinterface equ	$E010
      8  1974		       00 1e	   cTimerControl equ	$1E
      9  1974		       00 00	   cTimerStop equ	0
     10  1974		       00 01	   cTimerStart equ	1
     11  1974		       00 02	   cTimerLow  equ	2
     12  1974		       00 04	   cTimerHigh equ	4
     13  1974
     14  1974							; il interface to the timer
     15  1974
     16  1974				   iTimer
     17  1974		       20 b6 2c 	      jsr	popR0
     18  1977		       a6 52		      ldx	R0	; Set time parameter
     19  1979		       20 b6 2c 	      jsr	popR0
     20  197c		       a5 52		      lda	R0	; control parameter 0-4
     21  197e		       20 88 19 	      jsr	iTimerif
     22  1981		       85 52		      sta	R0
     23  1983		       86 53		      stx	R0+1
     24  1985		       4c 1d 07 	      jmp	pushR0nextIl
     25  1988
     26  1988							; Actual system interface to the timer
     27  1988							; x is value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
     28  1988							; a is 0,1,2,4
     29  1988				   iTimerif
     30  1988		       c9 02		      cmp	#cTimerLow	; Do they want the low byte
     31  198a		       b0 1c		      bcs	iTimerValue	; Just get the value we need
     32  198c		       48		      pha		; Save the command we will use
     33  198d		       a9 1e		      lda	#cTimerControl	; Load the timer control command
     34  198f		       8d 10 e0 	      sta	timerinterface	; Write it to the timer port
     35  1992		       68		      pla		; Get the actual command back
     36  1993		       8d 10 e0 	      sta	timerinterface	; write it to the port
     37  1996		       c9 01		      cmp	#cTimerStart	; if the command was start timer then write value
     38  1998		       f0 04		      beq	iTimerParm	; if not then get ack/nak and continue
     39  199a		       78		      sei		; Disable the interupts
     40  199b		       4c a2 19 	      jmp	iTimerAck	; get ack and exit
     41  199e
     42  199e				   iTimerParm
     43  199e		       8e 10 e0 	      stx	timerinterface	; Write the program value otherwise
     44  19a1		       58		      cli		; enable the interupts, this is start/restart timer
     45  19a2
     46  19a2				   iTimerAck
     47  19a2		       ad 10 e0 	      lda	timerinterface	; get the ack nak
     48  19a5		       a2 00		      ldx	#0	; the ack value is single byte so pad with x
     49  19a7		       60		      rts
     50  19a8
     51  19a8				   iTimerValue		; get the value from the offsets provided
     52  19a8		       08		      php
     53  19a9		       78		      sei
     54  19aa		       aa		      tax		; the control is also the value
     55  19ab		       bd 27 43 	      lda	[timercounter-2],x	; get the high byte of value
     56  19ae		       48		      pha
     57  19af		       bd 28 43 	      lda	[timercounter-1],x	; get the low part of value
     58  19b2		       aa		      tax
     59  19b3		       68		      pla
     60  19b4		       28		      plp		; restore the interupt flag if it was enabled
     61  19b5		       60		      rts
     62  19b6
     63  19b6
     64  19b6
------- FILE mytb.asm
------- FILE io.asm LEVEL 2 PASS 6
      0  19b6					      include	"io.asm"
      1  19b6							; This is the io blocks and function for reading and writing
      2  19b6							; to devices attached to this computer.
      3  19b6							; This supports devices mapped at e000 thru efff in slot sizes of 16 byte
      4  19b6							;
      5  19b6							;=====================================================================
      6  19b6							; Device configuration equates
      7  19b6		       00 00	   ConsoleID  equ	0
      8  19b6		       00 08	   SerialID   equ	[1<<3]
      9  19b6		       00 10	   ClockID    equ	[2<<3]
     10  19b6		       00 18	   TimerID    equ	[3<<3]
     11  19b6		       00 20	   DiskID     equ	[4<<3]
     12  19b6
     13  19b6		       00 0a	   IO_MAX_DEVICES equ	10
     14  19b6		       00 06	   IO_VECT_LEN equ	6
     15  19b6
     16  19b6		       00 01	   IO_DEVICE_CLOSED equ	1	; The device is not open
     17  19b6		       00 02	   IO_DEVICE_INVALID equ	2	; The Device number provided is invalid
     18  19b6
     19  19b6							;========================================================================================
     20  19b6							; Uninitialized data segment
     21 U3664					      seg.u	TBData
     22 U3664
     23 U3664		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
     24 U3666		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
     25 U3668		       00 00	   BStatVec   ds	2	; This is used by inteface to read write status/config information
      0 U366a				   BActiveDevice db	1	; the index of the current device block
      1 U366a		       01		      .byte.b	1
      0 U366b				   BActiveDriver db	1	; Index of the device driver block
      1 U366b		       01		      .byte.b	1
     28 U366c
     29 U366c							;============================================================================================
     30  19b6					      Seg	Code
     31  19b6							; IRQ BASIC Code Service RTN Support
      0  19b6				   SaveIrqReg db	0	; Store current setting
      1  19b6		       00		      .byte.b	0
      0  19b7				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1  19b7		       00		      .byte.b	0
      0  19b8				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1  19b8		       00		      .byte.b	0
      0  19b9				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1  19b9		       00 00		      .byte.b	0,0
     36  19bb
     37  19bb							;============================================================================================
     38  19bb							; Define the device interface blocks
     39  19bb				   DeviceDriverBlocks
     40  19bb				   ConsoleDevice		; Block 0
      0  19bb					      dw	ConsoleID	; device idenifier Console
      1  19bb		       00 00		      .word.w	ConsoleID
      0  19bd					      dw	cin	; read function vector
      1  19bd		       09 f0		      .word.w	cin
      0  19bf					      dw	cout	; write function vector
      1  19bf		       0c f0		      .word.w	cout
      0  19c1					      dw	cstatus	; Get current Status info/Write config
      1  19c1		       0f f0		      .word.w	cstatus
     45  19c3
     46  19c3				   SerialDevice 		; Block 1
      0  19c3					      dw	SerialID	; device idenifier Serial
      1  19c3		       08 00		      .word.w	SerialID
      0  19c5					      dw	SerialIn	; read function vector
      1  19c5		       b1 1a		      .word.w	SerialIn
      0  19c7					      dw	SerialOut	; write function vector
      1  19c7		       b1 1a		      .word.w	SerialOut
      0  19c9					      dw	SerialStatus	; Get current Status info/Write config
      1  19c9		       b1 1a		      .word.w	SerialStatus
     51  19cb
     52  19cb				   ClockDevice		; Block 2
      0  19cb					      dw	ClockID	; Day/date Clock
      1  19cb		       10 00		      .word.w	ClockID
      0  19cd					      dw	ClockRead	; Read the date from clock
      1  19cd		       b2 1a		      .word.w	ClockRead
      0  19cf					      dw	ClockWrite	; Set the date/time of clock
      1  19cf		       b2 1a		      .word.w	ClockWrite
      0  19d1					      dw	#0	; No Status/Config Function
      1  19d1		       00 00		      .word.w	#0
     57  19d3
     58  19d3				   TimerDevice		; Block 3
      0  19d3					      dw	TimerID	; Timer/interrupt interface
      1  19d3		       18 00		      .word.w	TimerID
      0  19d5					      dw	TimerStart	; Start the timer
      1  19d5		       b3 1a		      .word.w	TimerStart
      0  19d7					      dw	TimerStop	; Stop the timer
      1  19d7		       b3 1a		      .word.w	TimerStop
      0  19d9					      dw	TimerStatus	; Config/read status
      1  19d9		       b3 1a		      .word.w	TimerStatus
     63  19db
      0  19db				   DiskDevice dw	DiskID	; Block 4
      1  19db		       20 00		      .word.w	DiskID
      0  19dd					      dw	DIN	; Disk Input / read function
      1  19dd		       5d 31		      .word.w	DIN
      0  19df					      dw	DOUT	; Disk Output / write function
      1  19df		       44 31		      .word.w	DOUT
      0  19e1					      dw	DSTAT	; Disk Status/open/close etc information
      1  19e1		       76 31		      .word.w	DSTAT
     68  19e3							;
     69  19e3							;======================================================================
     70  19e3							; Define the Device/Slot,driver control blocks
     71  19e3							; entry format: ControlWord,DeviceDriver,PortAddress,StatusWord
     72  19e3							; Fixed at 10 devices memory usage is getting pretty big!!!!!!
     73  19e3							; Control word : bit 0 = active 1, Free 0
     74  19e3
     75  19e3				   DeviceIoBlocks
      0  19e3					      dw	1, ConsoleID, $E000, 0	; Console device is 0 file
      1  19e3		       01 00 00 00*	      .word.w	1, ConsoleID, $E000, 0
      0  19eb					      dw	1, ClockID, $E010, 0	; Port for the day/time clock
      1  19eb		       01 00 10 00*	      .word.w	1, ClockID, $E010, 0
      0  19f3					      dw	1, TimerID, $E010, 0	; Timer interface
      1  19f3		       01 00 18 00*	      .word.w	1, TimerID, $E010, 0
      0  19fb					      dw	1, DiskID, $E010, 0	; Disk Driver interface
      1  19fb		       01 00 20 00*	      .word.w	1, DiskID, $E010, 0
      0  1a03					      dw	1, SerialID, $E020, 0	; Second terminal(default Basic debug)
      1  1a03		       01 00 08 00*	      .word.w	1, SerialID, $E020, 0
      0  1a0b					      dw	0, SerialID, $E030, 0	; Unused slot
      1  1a0b		       00 00 08 00*	      .word.w	0, SerialID, $E030, 0
      0  1a13					      dw	0, SerialID, $E040, 0	; Unused slot
      1  1a13		       00 00 08 00*	      .word.w	0, SerialID, $E040, 0
      0  1a1b					      dw	0, SerialID, $E050, 0	; Unused slot
      1  1a1b		       00 00 08 00*	      .word.w	0, SerialID, $E050, 0
      0  1a23					      dw	0, SerialID, $E060, 0	; Unused slot
      1  1a23		       00 00 08 00*	      .word.w	0, SerialID, $E060, 0
      0  1a2b					      dw	0, SerialID, $E070, 0	; Unused slot
      1  1a2b		       00 00 08 00*	      .word.w	0, SerialID, $E070, 0
     86  1a33							;
     87  1a33							;======================================================================
     88  1a33							;
     89  1a33					      Seg	Code
     90  1a33							;======================================================================
     91  1a33							; This is the Basic IRQ handler, works with task manager, assumes timer interupt
     92  1a33							;
     93  1a33		       48	   ServiceIrq pha
     94  1a34		       8a		      txa
     95  1a35		       48		      pha
     96  1a36		       a2 00		      ldx	#0
     97  1a38				   ServiceLoop
     98  1a38		       fe 29 43 	      inc	timercounter,x
     99  1a3b		       d0 05		      bne	ServiceCont
    100  1a3d		       e8		      inx
    101  1a3e		       e0 04		      cpx	#4
    102  1a40		       d0 f6		      bne	ServiceLoop
    103  1a42				   ServiceCont
    104  1a42		       ad b7 19 	      lda	IRQStatus
    105  1a45		       f0 0a		      beq	RetIrq
    106  1a47		       ad b8 19 	      lda	IRQPending
    107  1a4a		       d0 05		      bne	RetIrq
    108  1a4c		       a9 01		      lda	#1
    109  1a4e		       8d b8 19 	      sta	IRQPending
    110  1a51				   RetIrq
    111  1a51		       68		      pla
    112  1a52		       aa		      tax
    113  1a53		       68		      pla
    114  1a54		       40		      rti
    115  1a55							;======================================================================
    116  1a55							; Jump to the output/input function in BOutVec/BInVec
    117  1a55							;
    118  1a55		       6c 66 36    VOUTCH     jmp	(BOutVec)	; Primary block io vectors
    119  1a58		       6c 64 36    VGETCH     jmp	(BInVec)
    120  1a5b		       6c 68 36    VSTAT      jmp	(BStatVec)
    121  1a5e							;
    122  1a5e							;======================================================================
    123  1a5e							; IO Service functions
    124  1a5e							; Validate the device index and set x to offest in table
    125  1a5e							; does not return to ioInterface if invalid, returns to original caller
    126  1a5e							; should be called immediatly after entering the ioInterface call
    127  1a5e				   ioValidateDevice
    128  1a5e		       e0 0a		      cpx	#IO_MAX_DEVICES
    129  1a60		       90 04		      bcc	ioValidIndex
    130  1a62		       a2 02		      ldx	#IO_DEVICE_INVALID
    131  1a64		       b0 13		      bcs	ioInvalidDevice
    132  1a66				   ioValidIndex
    133  1a66		       8a		      txa
    134  1a67		       0a		      asl		; Multiply by 8
    135  1a68		       0a		      asl
    136  1a69		       0a		      asl
    137  1a6a		       aa		      tax		; Point to actual offset in the table
    138  1a6b		       ec 6a 36 	      cpx	BActiveDevice	; is it already active ?
    139  1a6e		       f0 0d		      beq	ioValidDevice	; Shortcut if this is the active device already
    140  1a70		       a9 01		      lda	#1	; Active flag
    141  1a72		       3d e3 19 	      and	DeviceIoBlocks,x	; Check if the device is active
    142  1a75		       d0 06		      bne	ioValidDevice	; The device is active and valid index
    143  1a77		       a2 01		      ldx	#IO_DEVICE_CLOSED
    144  1a79
    145  1a79				   ioInvalidDevice
    146  1a79		       68		      pla		; Remove return address of IO interface
    147  1a7a		       68		      pla
    148  1a7b		       38		      sec		; ensure that carry is set
    149  1a7c		       60		      rts
    150  1a7d
    151  1a7d				   ioValidDevice
    152  1a7d		       18		      clc
    153  1a7e		       60		      rts
    154  1a7f							;
    155  1a7f							;===================================================================================
    156  1a7f							; Set the io device jmp vectors
    157  1a7f							; input x contains the vector to the active Device IO Block
    158  1a7f							; output a, x undefined y unchanged
    159  1a7f				   ioSetDeviceVectors
    160  1a7f		       ec 6a 36 	      cpx	BActiveDevice	; Check if already set
    161  1a82		       f0 1b		      beq	ioSetDevExit	; if already set then do nothing
    162  1a84
    163  1a84		       8e 6a 36 	      stx	BActiveDevice	; set the active device vector
    164  1a87		       98		      tya
    165  1a88		       48		      pha
    166  1a89
    167  1a89		       bc e5 19 	      ldy	DeviceIoBlocks+2,x	; Get the device driver index
    168  1a8c		       8c 6b 36 	      sty	BActiveDriver	; Pointer to active Device driver
    169  1a8f		       a2 00		      ldx	#0	; Transfer the 6 pointers to the Vectors
    170  1a91				   ioSetDevLoop
    171  1a91		       b9 bd 19 	      lda	DeviceDriverBlocks+2,y
    172  1a94		       9d 64 36 	      sta	BInVec,x
    173  1a97		       e8		      inx
    174  1a98		       c8		      iny
    175  1a99		       e0 06		      cpx	#IO_VECT_LEN	; Transfer the vector length to copy
    176  1a9b		       d0 f4		      bne	ioSetDevLoop
    177  1a9d
    178  1a9d		       68		      pla
    179  1a9e		       a8		      tay
    180  1a9f				   ioSetDevExit
    181  1a9f		       60		      rts
    182  1aa0							;
    183  1aa0							;======================================================================
    184  1aa0							; Generic call interface for devices
    185  1aa0							; input x = DeviceIoBlockIndex
    186  1aa0							; Carry set if error, x contains the error code
    187  1aa0							; all other parameters are dependant upon the actual device interface
    188  1aa0							;
    189  1aa0							; ioPutCH  a contains the character to send
    190  1aa0		       20 5e 1a    ioPutCH    jsr	ioValidateDevice
    191  1aa3		       48		      pha
    192  1aa4		       20 7f 1a 	      jsr	ioSetDeviceVectors
    193  1aa7		       68		      pla
    194  1aa8		       20 55 1a 	      jsr	VOUTCH
    195  1aab		       18		      clc
    196  1aac		       60		      rts
    197  1aad
    198  1aad							; io Getch returns the character read from device
    199  1aad		       20 5e 1a    ioGetCH    jsr	ioValidateDevice
    200  1ab0
    201  1ab0		       60		      rts
    202  1ab1							;
    203  1ab1							;======================================================================
    204  1ab1							;TTY interface functions,
    205  1ab1							;	a contains the character to send
    206  1ab1							;	x contains the Device ID (equals index into io blocks)	of the io block to used
    207  1ab1							;
    208  1ab1				   SerialIn
    209  1ab1
    210  1ab1				   SerialOut
    211  1ab1
    212  1ab1				   SerialStatus
    213  1ab1		       60		      rts
    214  1ab2							;
    215  1ab2							;======================================================================
    216  1ab2							; Date/Time clock interface
    217  1ab2				   ClockRead
    218  1ab2
    219  1ab2				   ClockWrite
    220  1ab2		       60		      rts
    221  1ab3							;
    222  1ab3							;======================================================================
    223  1ab3							;
    224  1ab3				   TimerStart
    225  1ab3
    226  1ab3				   TimerStop
    227  1ab3
    228  1ab3				   TimerStatus
    229  1ab3		       60		      rts
    230  1ab4
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  1ab4					      include	"tokenizer.asm"
      1  1ab4					      seg	Code
      2  1ab4		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  1ab4
      4  1ab4							; Define the types of tokens found, and identifiers
      5  1ab4		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  1ab4		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  1ab4		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  1ab4		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  1ab4
     10  1ab4		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  1ab4		       00 9c	   tVhash     equ	$9C	; Variable #
     12  1ab4		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  1ab4
     14  1ab4							; Base variable type supported by This basic
     15  1ab4							; Unsigned types always have the 0 bit set to 1
     16  1ab4		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     17  1ab4		       00 a2	   tByte      equ	$A2	; Signed Byte value
     18  1ab4		       00 a4	   tInteger   equ	$A4	; all tokenized integers start with 251 as first byte 16 bit signed number
     19  1ab4		       00 a6	   tLong      equ	$A6	; Signed 32 bit integer
     20  1ab4
     21  1ab4		       00 a1	   tArray     equ	$A1	; Identifies Array Type, the byte following defines the length of each element
     22  1ab4							; Arrays of string are arrays of pointers 2 bytes each
     23  1ab4		       00 a3	   tPointer   equ	$A3	; Pointer  unsigned 16 bit
     24  1ab4		       00 a5	   tIndirect  equ	$A5	; Points to an address that points to the data 16 bits
     25  1ab4		       00 a7	   tuByte     equ	$A7	; Unsigned byte value 8 bit unsigned value
     26  1ab4		       00 a9	   tUint      equ	$A9	; unsigned integer type 16 bit
     27  1ab4		       00 ab	   tUlong     equ	$AB	; Unsigned 32 bit integer
     28  1ab4
     29  1ab4		       3c 3e	   Operators  BYTE.b	"<>"
     30  1ab6		       3c 3d		      BYTE.b	"<="
     31  1ab8		       3e 3d		      BYTE.b	">="
     32  1aba		       3c 3c		      Byte.b	"<<"
     33  1abc		       3e 3e		      Byte.b	">>"
     34  1abe		       3c 00		      BYTE.b	"<",0
     35  1ac0		       3d 00		      BYTE.b	"=",0
     36  1ac2		       3e 00		      BYTE.b	">",0
     37  1ac4		       2b 2b		      Byte.b	"++"
     38  1ac6		       2b 00		      BYTE.b	"+",0
     39  1ac8		       2d 2d		      Byte.b	"--"
     40  1aca		       2d 00		      BYTE.b	"-",0
     41  1acc		       2f 00		      BYTE.b	"/",0
     42  1ace		       25 00		      BYTE.b	"%",0
     43  1ad0		       2a 00		      BYTE.b	"*",0
     44  1ad2		       28 00		      BYTE.b	"(",0
     45  1ad4		       29 00		      BYTE.b	")",0
     46  1ad6		       2c 00		      BYTE.b	",",0
     47  1ad8		       3b 00		      BYTE.b	";",0
     48  1ada		       5b 00		      BYTE.b	"[",0
     49  1adc		       5d 00		      BYTE.b	"]",0
     50  1ade		       3a 00		      BYTE.b	":",0
     51  1ae0		       24 00		      BYTE.b	"$",0
     52  1ae2		       21 00		      BYTE.b	"!",0
     53  1ae4		       3f 00		      BYTE.b	"?",0
     54  1ae6		       2e 00		      BYTE.b	".",0
     55  1ae8		       26 00		      BYTE.b	"&",0
     56  1aea		       27 00		      Byte.b	"'",0
     57  1aec		       7c 00		      Byte.b	"|",0
     58  1aee		       7e 00		      Byte.b	"~",0
     59  1af0		       00 00		      BYTE.b	0,0
     60  1af2
     61  1af2		       f5 f3 f6 29*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oSHL,oSHR,oLess,oEqual,oGreater
     62  1afa		       02 ea 03 eb*	      BYTE.b	oINC, oPlus, oDEC, oMinus, oDivide, oModulo, oMultiply
     63  1b01		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     64  1b07		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod, oAmphistan, oQuote, oBar,oTilde
     65  1b10
     66  1b10		       00 0b	   oQuestion  equ	kPrint
     67  1b10							;    2 is =
     68  1b10							;    1 is <
     69  1b10							;    3 is <=
     70  1b10							;    5 is <>
     71  1b10							;    4 is >
     72  1b10							;    6 is >=
     73  1b10		       00 f1	   oLess      equ	$F1
     74  1b10		       00 f2	   oEqual     equ	$F2
     75  1b10		       00 f3	   oLessEqual equ	$F3
     76  1b10		       00 f4	   oGreater   equ	$F4
     77  1b10		       00 f5	   oNotEqual  equ	$F5
     78  1b10		       00 f6	   oGreaterEqual equ	$F6
     79  1b10
     80  1b10		       00 e0	   oLeftBracket equ	$E0
     81  1b10		       00 e1	   oRightBracket equ	$E1
     82  1b10		       00 e2	   oComma     equ	$E2
     83  1b10		       00 e3	   oSemiColon equ	$E3
     84  1b10		       00 e4	   oLeftSQBracket equ	$E4
     85  1b10		       00 e5	   oRightSQBracket equ	$E5
     86  1b10		       00 e6	   oColon     equ	$E6
     87  1b10		       00 e7	   oDollar    equ	$E7
     88  1b10		       00 e8	   oBang      equ	$E8
     89  1b10		       00 e9	   oPeriod    equ	$E9
     90  1b10
     91  1b10
     92  1b10		       00 ea	   oPlus      equ	$EA
     93  1b10		       00 eb	   oMinus     equ	$EB
     94  1b10		       00 ec	   oDivide    equ	$EC
     95  1b10		       00 ed	   oModulo    equ	$ED
     96  1b10		       00 ee	   oMultiply  equ	$EE
     97  1b10
     98  1b10		       00 ed	   oPercent   equ	oModulo
     99  1b10		       00 27	   oAmphistan equ	kAnd
    100  1b10		       00 25	   oBar       equ	kOr
    101  1b10		       00 0a	   oQuote     equ	kRem
    102  1b10		       00 26	   oTilde     equ	kXor
    103  1b10		       00 28	   oSHR       equ	kShr
    104  1b10		       00 29	   oSHL       equ	kShl
    105  1b10		       00 02	   oINC       equ	kInc
    106  1b10		       00 03	   oDEC       equ	kDec
    107  1b10
    108  1b10		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
    109  1b10
    110  1b10		       00 ff	   tError     equ	$FF	; Error should never happen
    111  1b10							;============================================================================================
    112  1b10							; Keyword and seperator values
    113  1b10				   '
    114  1b10		       00 01	   kBeginKey  equ	kLet
    115  1b10							;
    116  1b10		       00 01	   kLet       equ	1
    117  1b10		       00 02	   kInc       equ	kLet+1
    118  1b10		       00 03	   kDec       equ	kInc+1
    119  1b10		       00 04	   kIreturn   equ	kDec+1
    120  1b10		       00 05	   kIf	      equ	kIreturn+1
    121  1b10		       00 06	   kThen      equ	kIf+1
    122  1b10		       00 07	   kGoto      equ	kThen+1
    123  1b10		       00 08	   kGosub     equ	kGoto+1
    124  1b10		       00 09	   kReturn    equ	kGosub+1
    125  1b10		       00 0a	   kRem       equ	kReturn+1
    126  1b10		       00 0b	   kPrint     equ	kRem+1
    127  1b10		       00 0c	   kTaske     equ	kPrint+1
    128  1b10		       00 0d	   kTaskn     equ	kTaske+1
    129  1b10		       00 0e	   kTaskw     equ	kTaskn+1
    130  1b10		       00 0f	   kPoke      equ	kTaskw+1
    131  1b10		       00 10	   kPutch     equ	kPoke+1
    132  1b10		       00 11	   kCls       equ	kPutch+1
    133  1b10		       00 12	   kInput     equ	kCls+1
    134  1b10		       00 13	   kEnd       equ	kInput+1
    135  1b10		       00 14	   kIrq       equ	kEnd+1
    136  1b10		       00 15	   kKill      equ	kIrq+1
    137  1b10		       00 16	   kList      equ	kKill+1
    138  1b10		       00 17	   kRun       equ	kList+1
    139  1b10		       00 18	   kNew       equ	kRun+1
    140  1b10		       00 19	   kSlice     equ	kNew+1
    141  1b10		       00 1a	   kTrace     equ	kSlice+1
    142  1b10		       00 1b	   kExit      equ	kTrace+1
    143  1b10		       00 1c	   kSave      equ	kExit+1
    144  1b10		       00 1d	   kLoad      equ	kSave+1
    145  1b10		       00 1e	   kErase     equ	kLoad+1
    146  1b10		       00 1f	   kDir       equ	kErase+1
    147  1b10		       00 20	   kSetTerm   equ	kDir+1
    148  1b10		       00 21	   kSetMemB   equ	kSetTerm+1
    149  1b10		       00 22	   kSetMemW   equ	kSetMemB+1
    150  1b10		       00 23	   kCopyMem   equ	kSetMemW+1
    151  1b10							;
    152  1b10							; End of actual key words
    153  1b10							;
    154  1b10		       00 22	   kKeyCount  equ	kCopyMem-kBeginKey
    155  1b10							;
    156  1b10							; Logical operators
    157  1b10							;
    158  1b10		       00 24	   kNot       equ	kCopyMem+1
    159  1b10		       00 25	   kOr	      equ	kNot+1
    160  1b10		       00 26	   kXor       equ	kOr+1
    161  1b10		       00 27	   kAnd       equ	kXor+1
    162  1b10							;
    163  1b10							; Shift operators
    164  1b10							;
    165  1b10		       00 28	   kShr       equ	kAnd+1
    166  1b10		       00 29	   kShl       equ	kShr+1
    167  1b10
    168  1b10							; numeric functions
    169  1b10							;
    170  1b10		       00 2a	   kBeginFunc equ	kTrue
    171  1b10							;
    172  1b10							; Truth operators
    173  1b10							;
    174  1b10		       00 2a	   kTrue      equ	kShl+1
    175  1b10		       00 2b	   kFalse     equ	kTrue+1
    176  1b10							; Functions
    177  1b10		       00 2c	   kFree      equ	kFalse+1
    178  1b10		       00 2d	   kGetch     equ	kFree+1
    179  1b10		       00 2e	   kPeek      equ	kGetch+1
    180  1b10		       00 2f	   kTask      equ	kPeek+1
    181  1b10		       00 30	   kIpcc      equ	kTask+1
    182  1b10		       00 31	   kIpcs      equ	kIpcc+1
    183  1b10		       00 32	   kIpcr      equ	kIpcs+1
    184  1b10		       00 33	   kRnd       equ	kIpcr+1
    185  1b10		       00 34	   kStat      equ	kRnd+1
    186  1b10		       00 35	   kAbs       equ	kStat+1
    187  1b10		       00 36	   kCall      equ	kAbs+1
    188  1b10		       00 37	   kGofn      equ	kCall+1
    189  1b10		       00 38	   kPid       equ	kGofn+1
    190  1b10		       00 39	   kAddr      equ	kPid+1
    191  1b10		       00 3a	   kCmpMem    equ	kAddr+1
    192  1b10		       00 3b	   kTimer     equ	kCmpMem+1
    193  1b10							;
    194  1b10		       00 12	   kFuncCount equ	((kTimer - kBeginFunc) + 1)
    195  1b10
    196  1b10							;
    197  1b10							; Keyword table contains 54 keywords
    198  1b10				   KeyWordTable
      0  1b10					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  1b10		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  1b14					      db	kInc,"inC"
      1  1b14		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  1b18					      db	kDec,"deC"
      1  1b18		       03 64 65 43	      .byte.b	kDec,"deC"
      0  1b1c					      db	kIreturn,"ireturN"
      1  1b1c		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  1b24					      db	kIf,"iF"
      1  1b24		       05 69 46 	      .byte.b	kIf,"iF"
      0  1b27					      db	kThen,"theN"
      1  1b27		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  1b2c					      db	kGoto,"gotO"
      1  1b2c		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  1b31					      db	kGosub,"gosuB"
      1  1b31		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  1b37					      db	kReturn,"returN"
      1  1b37		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  1b3e					      db	kRem,"reM"
      1  1b3e		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  1b42					      db	kPrint,"prinT"
      1  1b42		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  1b48					      db	kTaske,"taskE"
      1  1b48		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  1b4e					      db	kTaskn,"taskN"
      1  1b4e		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  1b54					      db	kTaskw,"taskW"
      1  1b54		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  1b5a					      db	kPoke,"pokE"
      1  1b5a		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  1b5f					      db	kPutch,"putcH"
      1  1b5f		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  1b65					      db	kCls,"clS"
      1  1b65		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  1b69					      db	kInput,"inpuT"
      1  1b69		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  1b6f					      db	kEnd,"enD"
      1  1b6f		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  1b73					      db	kIrq,"irQ"
      1  1b73		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  1b77					      db	kKill,"kilL"
      1  1b77		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  1b7c					      db	kList,"lisT"
      1  1b7c		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  1b81					      db	kRun,"ruN"
      1  1b81		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  1b85					      db	kNew,"neW"
      1  1b85		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  1b89					      db	kSlice,"slicE"
      1  1b89		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  1b8f					      db	kTrace,"tracE"
      1  1b8f		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  1b95					      db	kExit,"exiT"
      1  1b95		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  1b9a					      db	kSave,"savE"
      1  1b9a		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  1b9f					      db	kLoad,"loaD"
      1  1b9f		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  1ba4					      db	kErase,"erasE"
      1  1ba4		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  1baa					      db	kDir,"diR"
      1  1baa		       1f 64 69 52	      .byte.b	kDir,"diR"
    230  1bae							;Short form for statements:
      0  1bae					      db	kIreturn,"ireT"
      1  1bae		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  1bb3					      db	kReturn,"reT"
      1  1bb3		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  1bb7					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  1bb7		       0b 70 52 	      .byte.b	kPrint,"pR"
      0  1bba					      db	kSetTerm, "setterM"
      1  1bba		       20 73 65 74*	      .byte.b	kSetTerm, "setterM"
      0  1bc2					      db	kSetMemB, "setmemB"
      1  1bc2		       21 73 65 74*	      .byte.b	kSetMemB, "setmemB"
      0  1bca					      db	kSetMemW, "setmemW"
      1  1bca		       22 73 65 74*	      .byte.b	kSetMemW, "setmemW"
      0  1bd2					      db	kCopyMem, "copymeM"
      1  1bd2		       23 63 6f 70*	      .byte.b	kCopyMem, "copymeM"
    238  1bda
    239  1bda							; Shift operators
      0  1bda					      db	kShr,"shR"
      1  1bda		       28 73 68 52	      .byte.b	kShr,"shR"
      0  1bde					      db	kShl,"shL"
      1  1bde		       29 73 68 4c	      .byte.b	kShl,"shL"
    242  1be2
    243  1be2							;Logical and truth operators
      0  1be2					      db	kNot,"noT"
      1  1be2		       24 6e 6f 54	      .byte.b	kNot,"noT"
      0  1be6					      db	kOr,"oR"
      1  1be6		       25 6f 52 	      .byte.b	kOr,"oR"
      0  1be9					      db	kXor,"xoR"
      1  1be9		       26 78 6f 52	      .byte.b	kXor,"xoR"
      0  1bed					      db	kAnd,"anD"
      1  1bed		       27 61 6e 44	      .byte.b	kAnd,"anD"
    248  1bf1
    249  1bf1							; Truth values
      0  1bf1					      db	kTrue,"truE"
      1  1bf1		       2a 74 72 75*	      .byte.b	kTrue,"truE"
      0  1bf6					      db	kFalse,"falsE"
      1  1bf6		       2b 66 61 6c*	      .byte.b	kFalse,"falsE"
    252  1bfc
    253  1bfc
    254  1bfc
    255  1bfc							;functions returning values
    256  1bfc
      0  1bfc					      db	kFree,"freE"
      1  1bfc		       2c 66 72 65*	      .byte.b	kFree,"freE"
      0  1c01					      db	kGetch,"getcH"
      1  1c01		       2d 67 65 74*	      .byte.b	kGetch,"getcH"
      0  1c07					      db	kPeek,"peeK"
      1  1c07		       2e 70 65 65*	      .byte.b	kPeek,"peeK"
      0  1c0c					      db	kTask,"tasK"
      1  1c0c		       2f 74 61 73*	      .byte.b	kTask,"tasK"
      0  1c11					      db	kIpcc,"ipcC"
      1  1c11		       30 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  1c16					      db	kIpcs,"ipcS"
      1  1c16		       31 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  1c1b					      db	kIpcr,"ipcR"
      1  1c1b		       32 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  1c20					      db	kRnd,"rnD"
      1  1c20		       33 72 6e 44	      .byte.b	kRnd,"rnD"
      0  1c24					      db	kStat,"staT"
      1  1c24		       34 73 74 61*	      .byte.b	kStat,"staT"
      0  1c29					      db	kAbs,"abS"
      1  1c29		       35 61 62 53	      .byte.b	kAbs,"abS"
      0  1c2d					      db	kCall,"calL"
      1  1c2d		       36 63 61 6c*	      .byte.b	kCall,"calL"
      0  1c32					      db	kGofn,"fN"
      1  1c32		       37 66 4e 	      .byte.b	kGofn,"fN"
      0  1c35					      db	kPid,"piD"
      1  1c35		       38 70 69 44	      .byte.b	kPid,"piD"
      0  1c39					      db	kAddr,"addR"
      1  1c39		       39 61 64 64*	      .byte.b	kAddr,"addR"
      0  1c3e					      db	kCmpMem, "cmpmeM"
      1  1c3e		       3a 63 6d 70*	      .byte.b	kCmpMem, "cmpmeM"
      0  1c45					      db	kTimer,"timeR"
      1  1c45		       3b 74 69 6d*	      .byte.b	kTimer,"timeR"
      0  1c4b					      db	0,0
      1  1c4b		       00 00		      .byte.b	0,0
    274  1c4d
    275  1c4d		       1c 4d	   KeyWordTableEnd equ	*
    276  1c4d		       01 3d	   KeyWordTableLength equ	* - KeyWordTable
    277  1c4d		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    278  1d4d		       00 00 00    printStorage ds	3
    279  1d50							;==================================================================================================================
    280  1d50							; Read accross the inputline and output to TOKENBUFFER
    281  1d50							; Format   byte      Description
    282  1d50							;	     0	      length of line 1-255
    283  1d50							;	    0-1       Line Number
    284  1d50							;	    Tokens and litteral values encoded into the line
    285  1d50							;
    286  1d50							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    287  1d50							;  if fails then test for keywords
    288  1d50							;  if fails then test for variables and arrays
    289  1d50							;  if fails check for operators/seperators  + - < > = % / * () [] , ; : >> <<
    290  1d50
    291  1d50				   ParseInputLine
    292  1d50				  -	      if	DEBUGPARSER
    293  1d50				  -	      jsr	SetOutDebug
    294  1d50				  -	      jsr	DebugClearBuffer
    295  1d50					      endif
    296  1d50		       a5 51		      lda	CUROFF
    297  1d52		       48		      pha
    298  1d53		       8a		      txa
    299  1d54		       48		      pha
    300  1d55		       98		      tya
    301  1d56		       48		      pha
    302  1d57		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    303  1d59		       20 d6 2a 	      jsr	getDecimal	; Check for a line number, none is ok too
    304  1d5c		       84 51		      sty	CUROFF
    305  1d5e		       20 1c 1f 	      jsr	R02TOKEN	; Move R0 to token buffer
    306  1d61
    307  1d61				   ParseInputLoop
    308  1d61		       a4 51		      ldy	CUROFF
    309  1d63		       20 66 2d 	      jsr	SkipSpaces	; Skip any spaces
    310  1d66		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    311  1d68		       b9 90 42 	      lda	LINBUF,y	; Check for end of line
    312  1d6b		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    313  1d6d
    314  1d6d				   ParseForNumber
    315  1d6d		       20 70 1e 	      jsr	ParseNumeric	; Check for a numeric value
    316  1d70		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    317  1d72
    318  1d72				   ParseForString
    319  1d72		       20 46 1e 	      jsr	ParseString	; Check for a string
    320  1d75		       90 ea		      bcc	ParseInputLoop	; It was a string
    321  1d77
    322  1d77				   ParseForOp
    323  1d77		       20 ae 1e 	      jsr	ParseForOperator	; Check for operator or punctuation
    324  1d7a		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    325  1d7c
    326  1d7c				   ParseForKey
    327  1d7c		       20 a3 1d 	      jsr	ParseLookupKey	; Check for a keyword value
    328  1d7f		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    329  1d81
    330  1d81				   ParseForVar
    331  1d81		       20 e5 1e 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    332  1d84		       90 db		      bcc	ParseInputLoop
    333  1d86
    334  1d86				   ParseKeepChar		; if it does not parse just keep it safe
    335  1d86		       b9 90 42 	      lda	LINBUF,y
    336  1d89		       9d 4d 1c 	      sta	TOKENBUFFER,x
    337  1d8c		       e8		      inx
    338  1d8d		       c8		      iny
    339  1d8e		       84 51		      sty	CUROFF
    340  1d90		       d0 cf		      bne	ParseInputLoop
    341  1d92
    342  1d92				   ParseComplete
    343  1d92		       a9 00		      lda	#0
    344  1d94		       9d 4d 1c 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    345  1d97		       e8		      inx
    346  1d98		       8e 4d 1c 	      stx	TOKENBUFFER	; Place size including null into buffer start
    347  1d9b
    348  1d9b		       68		      pla
    349  1d9c		       a8		      tay
    350  1d9d		       68		      pla
    351  1d9e		       aa		      tax
    352  1d9f		       68		      pla
    353  1da0		       85 51		      sta	CUROFF
    354  1da2
    355  1da2				  -	      if	DEBUGPARSER
    356  1da2				  -
    357  1da2				  -	      jsr	printTokenBuffer
    358  1da2				  -			;jsr	  DebugPrintProgramLine
    359  1da2				  -	      jsr	SetOutDebugEnd
    360  1da2				  -
    361  1da2					      endif
    362  1da2		       60		      rts
    363  1da3
    364  1da3							;==================================================================================================================
    365  1da3							; Look at curptr, curpos and check for a valid KeyWord
    366  1da3							; A contains the index value. c is clear
    367  1da3							;		     not found c set  A undefined
    368  1da3							; X is prerserved
    369  1da3							;
    370  1da3				   ParseLookupKey
    371  1da3		       86 58		      stx	R2
    372  1da5		       a0 00		      ldy	#0
    373  1da7		       a9 10		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    374  1da9		       85 54		      sta	R1
    375  1dab		       a9 1b		      lda	#KeyWordTable>>8
    376  1dad		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    377  1daf		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    378  1db1		       85 52		      sta	R0	; Save until next keyword
    379  1db3		       c8		      iny		; Point to first character of keyword
    380  1db4		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    381  1db6
    382  1db6				  -	      if	DEBUGPARSER
    383  1db6				  -			;    jsr DebugKeyword
    384  1db6					      endif
    385  1db6
    386  1db6				   ParseLookupLoop
    387  1db6		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    388  1db8		       29 df		      and	#%11011111	; Force Keyword to upper case
    389  1dba		       dd 90 42 	      cmp	LINBUF,x	; Check the input buffer
    390  1dbd		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    391  1dbf		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    392  1dc1		       dd 90 42 	      cmp	LINBUF,x	; Compare value to upercase
    393  1dc4		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    394  1dc6
    395  1dc6				   ParseNextLetter
    396  1dc6		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    397  1dc8		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    398  1dca		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    399  1dcc		       e8		      inx		; Point to next char in the input buffer
    400  1dcd		       c8		      iny		; Point to the next character in the Keyword table
    401  1dce		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    402  1dd0		       dd 90 42 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    403  1dd3		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    404  1dd5		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    405  1dd7
    406  1dd7				   ParseKeyFound
    407  1dd7		       a5 52		      lda	R0	; get the keyword index
    408  1dd9
    409  1dd9				   ParseKeyDone
    410  1dd9		       e8		      inx		; point past the last character
    411  1dda		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    412  1ddc		       a6 58		      ldx	R2	; Restore the original x pointer
    413  1dde		       9d 4d 1c 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    414  1de1		       e8		      inx		; Point to next position in the output buffer
    415  1de2		       86 58		      stx	R2	; Save next position in buffer
    416  1de4		       c9 0a		      cmp	#kRem	; remark statement
    417  1de6		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    418  1de8		       c9 07		      cmp	#kGoto
    419  1dea		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    420  1dec		       c9 08		      cmp	#kGosub
    421  1dee		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    422  1df0		       c9 37		      cmp	#kGofn
    423  1df2		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    424  1df4		       c9 2f		      cmp	#kTask
    425  1df6		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    426  1df8
    427  1df8		       18		      clc		; C flag clear, we found it
    428  1df9		       60		      rts
    429  1dfa
    430  1dfa							; Move forward to the next entry in table
    431  1dfa				   ParseNextEntry
    432  1dfa		       b1 54		      lda	(R1),y	; Get the next character in the token
    433  1dfc		       29 20		      and	#%00100000	; Is it the last character
    434  1dfe		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    435  1e00		       c8		      iny		; Point to next char in the entry
    436  1e01		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    437  1e03
    438  1e03				   ParseEndOfEntry
    439  1e03		       c8		      iny		; Point to the byte after the last character
    440  1e04		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    441  1e05		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    442  1e06		       65 54		      adc	R1
    443  1e08		       85 54		      sta	R1
    444  1e0a		       a5 55		      lda	R1+1
    445  1e0c		       69 00		      adc	#0
    446  1e0e		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    447  1e10		       a0 00		      ldy	#0	; Reset the index back to zero
    448  1e12		       b1 54		      lda	(R1),y	; get keyword value
    449  1e14		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    450  1e16		       85 52		      sta	R0	; save the next token value
    451  1e18		       c8		      iny		; Inc past token value
    452  1e19
    453  1e19				  -	      if	DEBUGPARSER
    454  1e19				  -			;    jsr DebugKeyword
    455  1e19					      endif
    456  1e19		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    457  1e1b		       4c b6 1d 	      jmp	ParseLookupLoop	; branch back for next key word
    458  1e1e
    459  1e1e				   ParseNoneFound
    460  1e1e		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    461  1e20		       38		      sec		; c clear, not found
    462  1e21		       60		      rts
    463  1e22
    464  1e22							;===============================================================================
    465  1e22							; Move everything from current position until the end of line into the token buffer
    466  1e22							;
    467  1e22		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    468  1e24		       a6 58		      ldx	R2	; where to place in the buffer
    469  1e26				   ParseMoveLoop
    470  1e26		       b9 90 42 	      lda	LINBUF,y	; get the next byte
    471  1e29		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    472  1e2b		       9d 4d 1c 	      sta	TOKENBUFFER,x	; save the byte
    473  1e2e		       c8		      iny
    474  1e2f		       e8		      inx
    475  1e30		       d0 f4		      bne	ParseMoveLoop
    476  1e32				   ParseMoveDone
    477  1e32		       84 51		      sty	CUROFF
    478  1e34		       18		      clc
    479  1e35		       60		      rts
    480  1e36							;================================================================================================
    481  1e36							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    482  1e36							; transfer to a memory address
    483  1e36				   ParseHandleBranches
    484  1e36		       a6 58		      ldx	R2
    485  1e38		       a9 00		      lda	#0
    486  1e3a		       9d 4d 1c 	      sta	TOKENBUFFER,x
    487  1e3d		       e8		      inx
    488  1e3e		       9d 4d 1c 	      sta	TOKENBUFFER,x
    489  1e41		       e8		      inx
    490  1e42		       86 58		      stx	R2
    491  1e44		       18		      clc
    492  1e45		       60		      rts
    493  1e46
    494  1e46							;=========================================================================================================
    495  1e46							;ParseString Parse a quotes string
    496  1e46							; on input X = outbuf position
    497  1e46							; y = inbuf position
    498  1e46							; Copies string to output buffer, updates x and y
    499  1e46				   ParseString
    500  1e46		       a4 51		      ldy	CUROFF
    501  1e48		       a9 a0		      lda	#tString
    502  1e4a		       9d 4d 1c 	      sta	TOKENBUFFER,X
    503  1e4d		       b9 90 42 	      lda	LINBUF,y
    504  1e50		       c9 22		      cmp	#'"
    505  1e52		       d0 1a		      bne	ParseStringInvalid
    506  1e54		       e8		      inx
    507  1e55		       9d 4d 1c 	      sta	TOKENBUFFER,x
    508  1e58		       e8		      inx
    509  1e59		       c8		      iny
    510  1e5a
    511  1e5a				   ParseStringLoop
    512  1e5a		       b9 90 42 	      lda	LINBUF,y
    513  1e5d		       9d 4d 1c 	      sta	TOKENBUFFER,x
    514  1e60		       c9 22		      cmp	#'"
    515  1e62		       f0 04		      beq	ParseStringDone
    516  1e64		       c8		      iny
    517  1e65		       e8		      inx
    518  1e66		       d0 f2		      bne	ParseStringLoop
    519  1e68
    520  1e68				   ParseStringDone
    521  1e68		       e8		      inx
    522  1e69		       c8		      iny
    523  1e6a		       84 51		      sty	CUROFF
    524  1e6c		       18		      clc
    525  1e6d		       60		      rts
    526  1e6e
    527  1e6e				   ParseStringInvalid
    528  1e6e		       38		      sec
    529  1e6f		       60		      rts
    530  1e70
    531  1e70							;=========================================================================================================
    532  1e70							; Get numeric values and return value in RO and type in a
    533  1e70							;
    534  1e70				   ParseNumeric
    535  1e70		       a4 51		      ldy	CUROFF
    536  1e72		       b9 90 42 	      lda	LINBUF,y
    537  1e75		       c9 30		      cmp	#'0
    538  1e77		       90 33		      bcc	ParseNumInvalid
    539  1e79		       c9 3a		      cmp	#'9+1
    540  1e7b		       b0 2f		      bcs	ParseNumInvalid
    541  1e7d		       86 58		      stx	R2
    542  1e7f		       20 d6 2a 	      jsr	getDecimal
    543  1e82		       a6 58		      ldx	R2
    544  1e84		       84 51		      sty	CUROFF
    545  1e86		       a5 53		      lda	R0+1
    546  1e88		       f0 14		      beq	ParseByteValue
    547  1e8a
    548  1e8a				   ParseIntegerValue
    549  1e8a		       a9 a4		      lda	#tInteger
    550  1e8c		       9d 4d 1c 	      sta	TOKENBUFFER,x
    551  1e8f		       e8		      inx
    552  1e90		       a5 52		      lda	R0
    553  1e92		       9d 4d 1c 	      sta	TOKENBUFFER,x
    554  1e95		       e8		      inx
    555  1e96		       a5 53		      lda	R0+1
    556  1e98		       9d 4d 1c 	      sta	TOKENBUFFER,X
    557  1e9b		       e8		      inx
    558  1e9c		       18		      clc
    559  1e9d		       60		      rts
    560  1e9e
    561  1e9e				   ParseByteValue
    562  1e9e		       a9 a2		      lda	#tByte
    563  1ea0		       9d 4d 1c 	      sta	TOKENBUFFER,x
    564  1ea3		       e8		      inx
    565  1ea4		       a5 52		      lda	R0
    566  1ea6		       9d 4d 1c 	      sta	TOKENBUFFER,x
    567  1ea9		       e8		      inx
    568  1eaa		       18		      clc
    569  1eab		       60		      rts
    570  1eac
    571  1eac				   ParseNumInvalid		;Not a valid Numeric
    572  1eac		       38		      sec
    573  1ead		       60		      rts
    574  1eae
    575  1eae							;=========================================================================================================
    576  1eae							;Parse for operators and seperators
    577  1eae							; on exit the A has the oper code, c is clear
    578  1eae							;		 not found then c is set
    579  1eae							;	x is preserved
    580  1eae							;
    581  1eae				   ParseForOperator
    582  1eae		       86 58		      stx	R2
    583  1eb0		       a4 51		      ldy	CUROFF
    584  1eb2		       a2 00		      ldx	#0
    585  1eb4				  -	      if	DEBUGPARSER
    586  1eb4				  -			;	jsr    DebugPrintOP
    587  1eb4					      endif
    588  1eb4
    589  1eb4				   ParseOpLoop
    590  1eb4		       bd b4 1a 	      lda	Operators,x	; First byte of operator
    591  1eb7		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    592  1eb9
    593  1eb9		       d9 90 42 	      cmp	LINBUF,y	; Check the first byte
    594  1ebc		       d0 1c		      bne	ParseOpNext
    595  1ebe
    596  1ebe		       c8		      iny
    597  1ebf
    598  1ebf		       bd b5 1a 	      lda	Operators+1,x
    599  1ec2		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    600  1ec4
    601  1ec4		       d9 90 42 	      cmp	LINBUF,y
    602  1ec7		       d0 11		      bne	ParseOpNext
    603  1ec9
    604  1ec9				   ParseOpFound
    605  1ec9		       c8		      iny
    606  1eca
    607  1eca				   ParseOpFoundSingle
    608  1eca		       84 51		      sty	CUROFF
    609  1ecc
    610  1ecc		       8a		      txa
    611  1ecd		       4a		      lsr
    612  1ece		       aa		      tax
    613  1ecf		       bd f2 1a 	      lda	OperValues,x
    614  1ed2		       a6 58		      ldx	R2
    615  1ed4		       9d 4d 1c 	      sta	TOKENBUFFER,x
    616  1ed7		       e8		      inx
    617  1ed8		       18		      clc
    618  1ed9		       60		      rts
    619  1eda
    620  1eda				   ParseOpNext
    621  1eda		       e8		      inx
    622  1edb		       e8		      inx
    623  1edc
    624  1edc				  -	      if	DEBUGPARSER
    625  1edc				  -			;	 jsr	DebugPrintOP
    626  1edc					      endif
    627  1edc		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    628  1ede		       4c b4 1e 	      jmp	ParseOpLoop
    629  1ee1
    630  1ee1				   ParseOpNotFound
    631  1ee1		       a6 58		      ldx	R2
    632  1ee3		       38		      sec
    633  1ee4		       60		      rts
    634  1ee5							;=========================================================================================================
    635  1ee5				  -	      if	DEBUGPARSER
    636  1ee5				  -			;Print the text of a keyword
    637  1ee5				  -			;Input R1    = offset into table
    638  1ee5				  -DebugKeyword
    639  1ee5				  -	      tya
    640  1ee5				  -	      pha
    641  1ee5				  -	      ldy	#1
    642  1ee5				  -DebugKeyLoop
    643  1ee5				  -	      lda	(R1),y
    644  1ee5				  -	      jsr	VOUTCH
    645  1ee5				  -	      and	#%00100000
    646  1ee5				  -	      beq	DebugKeyDone
    647  1ee5				  -	      iny
    648  1ee5				  -	      bne	DebugKeyLoop
    649  1ee5				  -
    650  1ee5				  -DebugKeyDone
    651  1ee5				  -	      jsr	CRLF
    652  1ee5				  -	      pla
    653  1ee5				  -	      tay
    654  1ee5				  -	      rts
    655  1ee5				  -			;========================================
    656  1ee5				  -DebugPrintOP
    657  1ee5				  -	      pha
    658  1ee5				  -	      lda	Operators,x
    659  1ee5				  -	      jsr	VOUTCH
    660  1ee5				  -	      lda	Operators+1,x
    661  1ee5				  -	      beq	DbgPrtOpDone
    662  1ee5				  -	      jsr	VOUTCH
    663  1ee5				  -
    664  1ee5				  -DbgPrtOpDone
    665  1ee5				  -	      jsr	CRLF
    666  1ee5				  -	      pla
    667  1ee5				  -	      rts
    668  1ee5				  -			;=======================================
    669  1ee5				  -DebugClearBuffer
    670  1ee5				  -	      txa
    671  1ee5				  -	      pha
    672  1ee5				  -	      ldx	#$FF
    673  1ee5				  -	      lda	#0
    674  1ee5				  -DebugClrLoop
    675  1ee5				  -	      sta	TOKENBUFFER,x
    676  1ee5				  -	      dex
    677  1ee5				  -	      bne	DebugClrLoop
    678  1ee5				  -	      sta	TOKENBUFFER,x
    679  1ee5				  -	      pla
    680  1ee5				  -	      tax
    681  1ee5				  -	      rts
    682  1ee5				  -
    683  1ee5				  -			;=====================================================
    684  1ee5				  -			; Print the parser buffer as hex values
    685  1ee5				  -printTokenBuffer
    686  1ee5				  -	      stx	printStorage
    687  1ee5				  -	      sty	printStorage+1
    688  1ee5				  -	      sta	printStorage+2
    689  1ee5				  -
    690  1ee5				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    691  1ee5				  -	      inx		; we want to show the last zero byte
    692  1ee5				  -	      ldy	#0
    693  1ee5				  -
    694  1ee5				  -printHexLoop
    695  1ee5				  -	      lda	TOKENBUFFER,y	; get the character
    696  1ee5				  -	      jsr	HexToOut	; print it
    697  1ee5				  -	      lda	#$20
    698  1ee5				  -	      jsr	VOUTCH
    699  1ee5				  -	      iny
    700  1ee5				  -	      dex
    701  1ee5				  -	      cpx	#0
    702  1ee5				  -	      bne	printHexLoop
    703  1ee5				  -	      jsr	CRLF
    704  1ee5				  -
    705  1ee5				  -	      ldy	printStorage+1
    706  1ee5				  -	      ldx	printStorage
    707  1ee5				  -	      lda	printStorage+2
    708  1ee5				  -printHexDone
    709  1ee5				  -	      clc
    710  1ee5				  -	      rts
    711  1ee5					      endif
    712  1ee5
    713  1ee5
    714  1ee5							;=========================================================================================================
    715  1ee5							; Parse for variables A-Z @, ^  x!x x[op]
    716  1ee5				   ParseForVariable
    717  1ee5		       a4 51		      ldy	CUROFF
    718  1ee7		       b9 90 42 	      lda	LINBUF,y
    719  1eea		       c9 5e		      cmp	#'^	; is it an exit code
    720  1eec		       d0 04		      bne	ParseVarMem
    721  1eee		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    722  1ef0		       d0 1f		      bne	ParseVarSpecial
    723  1ef2
    724  1ef2				   ParseVarMem
    725  1ef2		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    726  1ef4		       d0 04		      bne	ParseVarStack
    727  1ef6		       a9 9d		      lda	#tVat
    728  1ef8		       d0 17		      bne	ParseVarSpecial
    729  1efa
    730  1efa				   ParseVarStack
    731  1efa		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    732  1efc		       d0 04		      bne	ParseVarLetters
    733  1efe		       a9 9c		      lda	#tVhash
    734  1f00		       d0 0f		      bne	ParseVarSpecial
    735  1f02
    736  1f02				   ParseVarLetters
    737  1f02		       29 df		      and	#%11011111	; Force upper case
    738  1f04		       c9 41		      cmp	#'A
    739  1f06		       90 12		      bcc	ParseVarInvalid
    740  1f08		       c9 5b		      cmp	#'Z+1
    741  1f0a		       b0 0e		      bcs	ParseVarInvalid
    742  1f0c							;
    743  1f0c							; The condition is true, so convert to an index, push
    744  1f0c							; it onto the stack and continue running.
    745  1f0c							;
    746  1f0c		       38		      sec
    747  1f0d		       e9 41		      sbc	#'A	;index is zero based
    748  1f0f		       09 80		      ora	#$80
    749  1f11
    750  1f11				   ParseVarSpecial
    751  1f11		       9d 4d 1c 	      sta	TOKENBUFFER,x
    752  1f14		       e8		      inx
    753  1f15		       c8		      iny
    754  1f16		       84 51		      sty	CUROFF
    755  1f18		       18		      clc
    756  1f19		       60		      rts
    757  1f1a
    758  1f1a				   ParseVarInvalid
    759  1f1a		       38		      sec
    760  1f1b		       60		      rts
    761  1f1c
    762  1f1c
    763  1f1c							;=========================================================================================================
    764  1f1c							; Transfer R0 to the TOKENBUFFER
    765  1f1c							;
    766  1f1c				   R02TOKEN
    767  1f1c		       a5 52		      lda	R0
    768  1f1e		       9d 4d 1c 	      sta	TOKENBUFFER,x
    769  1f21		       e8		      inx
    770  1f22		       a5 53		      lda	R0+1
    771  1f24		       9d 4d 1c 	      sta	TOKENBUFFER,x
    772  1f27		       e8		      inx
    773  1f28		       18		      clc
    774  1f29		       60		      rts
    775  1f2a							;=========================================================================
    776  1f2a							; Transfer word in Token Buffer to R0
    777  1f2a				   TOKEN2R0
    778  1f2a		       b9 4d 1c 	      lda	TOKENBUFFER,y
    779  1f2d		       85 52		      sta	R0
    780  1f2f		       c8		      iny
    781  1f30		       ca		      dex
    782  1f31		       b9 4d 1c 	      lda	TOKENBUFFER,y
    783  1f34		       c8		      iny
    784  1f35		       ca		      dex
    785  1f36		       85 53		      sta	R0+1
    786  1f38		       60		      rts
    787  1f39							;==========================================================================
    788  1f39							; Transfer	Display Buffer position to R0
    789  1f39							;
    790  1f39				   DPL2R0
    791  1f39		       b1 59		      lda	(dpl),y
    792  1f3b		       85 52		      sta	R0
    793  1f3d		       c8		      iny
    794  1f3e		       ca		      dex
    795  1f3f		       b1 59		      lda	(dpl),y
    796  1f41		       c8		      iny
    797  1f42		       ca		      dex
    798  1f43		       85 53		      sta	R0+1
    799  1f45		       60		      rts
    800  1f46
    801  1f46
    802  1f46							;=========================================================================
    803  1f46							; Read an IL byte lookit up in the table, of words
    804  1f46							; set the next ilpc to point to that address
    805  1f46							; if not found then do ussual filter stuff
    806  1f46							; ongoto ilvectortable, not found address
    807  1f46		       20 27 2a    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    808  1f49		       86 52		      stx	R0
    809  1f4b		       85 53		      sta	R0+1
    810  1f4d
    811  1f4d		       a4 51		      ldy	CUROFF
    812  1f4f		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    813  1f51		       a0 00		      ldy	#0
    814  1f53		       38		      sec
    815  1f54		       f1 52		      sbc	(R0),y	; Subract the base value
    816  1f56		       c8		      iny
    817  1f57		       d1 52		      cmp	(R0),y	; Check if we are in range
    818  1f59		       b0 12		      bcs	iOnGotoInvalid
    819  1f5b		       e6 51		      inc	CUROFF	; Save the offset
    820  1f5d
    821  1f5d		       0a		      asl
    822  1f5e		       a8		      tay		; Turn into vector
    823  1f5f		       c8		      iny		; Inc must include the table base and entry count
    824  1f60		       c8		      iny
    825  1f61
    826  1f61		       b1 52		      lda	(R0),y
    827  1f63		       85 43		      sta	ILPC
    828  1f65		       c8		      iny
    829  1f66		       b1 52		      lda	(R0),y
    830  1f68		       85 44		      sta	ILPC+1
    831  1f6a		       4c b1 02 	      jmp	NextIL
    832  1f6d
    833  1f6d				   iOnGotoInvalid
    834  1f6d		       20 27 2a 	      jsr	getILWord
    835  1f70		       86 43		      stx	ILPC
    836  1f72		       85 44		      sta	ILPC+1
    837  1f74		       4c b1 02 	      jmp	NextIL
    838  1f77							;
    839  1f77							;==========================================================================================
    840  1f77							; Test the token for relop and push the value onto the stack if true
    841  1f77							;
    842  1f77				   iTSTRELOP
    843  1f77		       20 2b 2a 	      jsr	getILByte
    844  1f7a		       8d 25 43 	      sta	offset
    845  1f7d
    846  1f7d		       a4 51		      ldy	CUROFF
    847  1f7f		       b1 4f		      lda	(CURPTR),y
    848  1f81		       48		      pha
    849  1f82		       29 f0		      and	#$F0
    850  1f84		       c9 f0		      cmp	#$F0
    851  1f86		       d0 12		      bne	iTSTRELOPNOT
    852  1f88		       68		      pla
    853  1f89		       29 0f		      and	#$0F	; get the actual value
    854  1f8b		       85 52		      sta	R0	; save it for later
    855  1f8d		       a9 00		      lda	#0
    856  1f8f		       85 53		      sta	R0+1
    857  1f91		       20 24 2c 	      jsr	pushR0
    858  1f94		       c8		      iny
    859  1f95		       84 51		      sty	CUROFF	; save the y pointer
    860  1f97		       4c b1 02 	      jmp	NextIL
    861  1f9a
    862  1f9a				   iTSTRELOPNOT
    863  1f9a		       68		      pla
    864  1f9b		       4c e0 0b 	      jmp	tstBranch
    865  1f9e
    866  1f9e							;
    867  1f9e							;===================================================================================================
    868  1f9e							; Test the token and following info for precompiled address information
    869  1f9e							; skip it if zero, transfer and skip next integer value if not zero
    870  1f9e							; used by both gosub, goto and gofN
    871  1f9e							;
    872  1f9e				   iTSTBRANCH		; il format TSTBRANCH whereToGoIfFailed
    873  1f9e		       20 2b 2a 	      jsr	getILByte	; Get jump address if vector is valid
    874  1fa1		       8d 25 43 	      sta	offset	; Mark offset for later if vector found
    875  1fa4		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    876  1fa6		       88		      dey		; point back to the type of branch
    877  1fa7		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    878  1fa9		       48		      pha		; Save till needed
    879  1faa		       c8		      iny		; back to memory vectors
    880  1fab				   ITSTBRANCHCont
    881  1fab		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    882  1fad		       85 52		      sta	R0	; R0 will contain mem pointer of present
    883  1faf		       c8		      iny		; Point to next byte of mem vector
    884  1fb0		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    885  1fb2		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    886  1fb4		       c8		      iny		; Point to the byte past memory vector
    887  1fb5		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    888  1fb7
    889  1fb7		       05 52		      ora	R0	; Get the second byte of the mem
    890  1fb9		       f0 28		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    891  1fbb		       68		      pla
    892  1fbc		       c9 07		      cmp	#kGoto	; Short cut lots if a goto stuff
    893  1fbe		       d0 03		      bne	NotGoto
    894  1fc0		       4c dc 04 	      jmp	FastFastXfer
    895  1fc3				   NotGoto
    896  1fc3		       c9 2f		      cmp	#kTask	; Task defined with Task() so bypass the first bracket
    897  1fc5		       d0 07		      bne	iTSTBRANCHCont
    898  1fc7		       b1 4f		      lda	(CURPTR),y
    899  1fc9		       c9 e0		      cmp	#oLeftBracket
    900  1fcb		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    901  1fcd		       c8		      iny		; Increment past the bracket
    902  1fce				   iTSTBRANCHCont
    903  1fce		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    904  1fd0		       c9 a2		      cmp	#tByte	; A byte value is valid
    905  1fd2		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    906  1fd4		       c9 a4		      cmp	#tInteger	; An integer value is valid
    907  1fd6		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    908  1fd8		       c8		      iny		; skip type indicator for
    909  1fd9				   ITSTBRANCHBYTE
    910  1fd9		       c8		      iny		; skip first byte of value line number
    911  1fda		       c8		      iny		; Skip second byte of line number
    912  1fdb
    913  1fdb				   iTSTBRANCHVALID
    914  1fdb		       84 51		      sty	CUROFF
    915  1fdd		       20 24 2c 	      jsr	pushR0	; place transfer address on top of stack
    916  1fe0		       4c e0 0b 	      jmp	tstBranch
    917  1fe3
    918  1fe3				   iTSTBRANCHNoCompile
    919  1fe3		       68		      pla
    920  1fe4				   iTSTBRANCHErr
    921  1fe4		       4c b1 02 	      jmp	NextIL
    922  1fe7
    923  1fe7
    924  1fe7
    925  1fe7
    926  1fe7
    927  1fe7
    928  1fe7
    929  1fe7
    930  1fe7
    931  1fe7
------- FILE mytb.asm
------- FILE compile.asm LEVEL 2 PASS 6
      0  1fe7					      include	"compile.asm"
      1  1fe7					      Seg	Code
      2  1fe7							;
      3  1fe7							;=====================================================================
      4  1fe7							; Scan the loaded program just before running and insert memory locations of each
      5  1fe7							; line number branched to. goto gosub, gofn
      6  1fe7							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value}
      7  1fe7				   Compile
      8  1fe7		       a9 00		      lda	#0
      9  1fe9		       85 52		      sta	R0	; keep track of how many errors we find
     10  1feb		       a5 5b		      lda	RunMode
     11  1fed		       48		      pha
     12  1fee		       e6 5b		      inc	RunMode	; force run mode for error reporting
     13  1ff0		       a5 4f		      lda	CURPTR
     14  1ff2		       48		      pha
     15  1ff3		       a5 50		      lda	CURPTR+1
     16  1ff5		       48		      pha
     17  1ff6		       a5 51		      lda	CUROFF
     18  1ff8		       48		      pha
     19  1ff9		       ad 2d 43 	      lda	ProgramStart
     20  1ffc		       85 59		      sta	dpl
     21  1ffe		       ad 2e 43 	      lda	ProgramStart+1
     22  2001		       85 5a		      sta	dpl+1
     23  2003
     24  2003				   CompileLineStart
     25  2003		       a5 59		      lda	dpl
     26  2005		       cd 2f 43 	      cmp	ProgramEnd
     27  2008		       d0 07		      bne	CompileContinue
     28  200a		       a5 5a		      lda	dpl+1
     29  200c		       cd 30 43 	      cmp	ProgramEnd+1
     30  200f		       f0 3f		      beq	CompileComplete
     31  2011
     32  2011				   CompileContinue
     33  2011		       a0 03		      ldy	#3	; first real character in the line
     34  2013
     35  2013				   CompileLoop
     36  2013		       b1 59		      lda	(dpl),y	; get the byte
     37  2015		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     38  2017		       c8		      iny		; Pass this byte
     39  2018		       c9 07		      cmp	#kGoto
     40  201a		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     41  201c		       c9 08		      cmp	#kGosub
     42  201e		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     43  2020		       c9 37		      cmp	#kGofn
     44  2022		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  2024		       c9 2f		      cmp	#kTask
     46  2026		       f0 4c		      beq	CompileField
     47  2028		       c9 0a		      cmp	#kRem
     48  202a		       f0 12		      beq	CompileRem	; Skip until end of line
     49  202c		       c9 a0		      cmp	#tString
     50  202e		       f0 2f		      beq	CompileString
     51  2030		       c9 a4		      cmp	#tInteger
     52  2032		       f0 06		      beq	CompileInteger
     53  2034		       c9 a2		      cmp	#tByte
     54  2036		       f0 03		      beq	CompileByte
     55  2038		       d0 d9		      bne	CompileLoop	; Next character
     56  203a
     57  203a				   CompileInteger
     58  203a		       c8		      iny
     59  203b				   CompileByte
     60  203b		       c8		      iny
     61  203c		       d0 d5		      bne	CompileLoop
     62  203e				   CompileRem
     63  203e				   CompileEndOfLine
     64  203e		       a0 00		      ldy	#0
     65  2040		       b1 59		      lda	(dpl),y
     66  2042		       18		      clc
     67  2043		       65 59		      adc	dpl
     68  2045		       85 59		      sta	dpl
     69  2047		       a9 00		      lda	#0
     70  2049		       65 5a		      adc	dpl+1
     71  204b		       85 5a		      sta	dpl+1
     72  204d
     73  204d		       4c 03 20 	      jmp	CompileLineStart
     74  2050
     75  2050				   CompileComplete
     76  2050		       68		      pla
     77  2051		       85 51		      sta	CUROFF
     78  2053		       68		      pla
     79  2054		       85 50		      sta	CURPTR+1
     80  2056		       68		      pla
     81  2057		       85 4f		      sta	CURPTR
     82  2059		       68		      pla
     83  205a		       85 5b		      sta	RunMode
     84  205c		       a5 52		      lda	R0	; returning the number of errors
     85  205e		       60		      rts
     86  205f
     87  205f
     88  205f				   CompileString
     89  205f		       c8		      iny		; point past first "
     90  2060				   CompileStringLoop
     91  2060		       b1 59		      lda	(dpl),y
     92  2062		       f0 0d		      beq	CompileStrDone2	; end of line
     93  2064		       c9 22		      cmp	#'"	; end of string
     94  2066		       f0 08		      beq	CompileStrDone
     95  2068		       c9 5c		      cmp	#'\	; escape character
     96  206a		       d0 01		      bne	CompileStrNext
     97  206c		       c8		      iny		; skip the escape character
     98  206d				   CompileStrNext
     99  206d		       c8		      iny		; Next character
    100  206e		       d0 f0		      bne	CompileStringLoop	; test for end
    101  2070				   CompileStrDone
    102  2070		       c8		      iny
    103  2071				   CompileStrDone2
    104  2071		       4c 13 20 	      Jmp	CompileLoop
    105  2074							;
    106  2074							;===============================================================
    107  2074							; on entry y points to storage location y+2 points to line number
    108  2074							; on exit y points to line number type
    109  2074
    110  2074		       85 52	   CompileField sta	R0
    111  2076		       98		      tya		; save the y pointer to store the memory value
    112  2077		       48		      pha
    113  2078		       c8		      iny		; Skip over the memory vector
    114  2079		       c8		      iny
    115  207a		       a5 52		      lda	R0
    116  207c		       c9 2f		      cmp	#kTask	; for a task it is the next byte after a bracket
    117  207e		       d0 07		      bne	CompNoBracket
    118  2080
    119  2080		       b1 59		      lda	(dpl),y	; Lets make sure it is a )
    120  2082		       c9 e0		      cmp	#oLeftBracket
    121  2084		       d0 01		      bne	CompNoBracket	; in case of error
    122  2086		       c8		      iny		; skip the bracket
    123  2087
    124  2087				   CompNoBracket
    125  2087		       a9 00		      lda	#0	; In case the value is a byte
    126  2089		       85 53		      sta	R0+1
    127  208b
    128  208b		       b1 59		      lda	(dpl),Y	; get the type of the next byte t something or other
    129  208d		       c9 a2		      cmp	#tByte
    130  208f		       f0 15		      beq	CompByteLoad
    131  2091		       c9 a4		      cmp	#tInteger
    132  2093		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    133  2095		       68		      pla
    134  2096		       4c 13 20 	      jmp	CompileLoop	; Ignore the saved stack
    135  2099				   CompIntLoad
    136  2099		       c8		      iny
    137  209a		       b1 59		      lda	(dpl),y
    138  209c		       85 52		      sta	R0
    139  209e		       c8		      iny
    140  209f		       b1 59		      lda	(dpl),y
    141  20a1		       85 53		      sta	R0+1
    142  20a3		       4c ab 20 	      jmp	CompFindLine
    143  20a6				   CompByteLoad
    144  20a6		       c8		      iny
    145  20a7		       b1 59		      lda	(dpl),y
    146  20a9		       85 52		      sta	R0
    147  20ab				   CompFindLine
    148  20ab		       20 70 2a 	      jsr	findLine
    149  20ae		       f0 1d		      beq	CompFoundLine
    150  20b0		       e6 52		      inc	R0	; number of errors
    151  20b2
    152  20b2		       a5 59		      lda	dpl
    153  20b4		       85 4f		      sta	CURPTR
    154  20b6		       a5 5a		      lda	dpl+1
    155  20b8		       85 50		      sta	CURPTR+1
    156  20ba		       84 51		      sty	CUROFF
    157  20bc
    158  20bc		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    159  20be		       a9 00		      lda	#0
    160  20c0
    161  20c0		       20 27 06 	      jsr	DisplayError
    162  20c3		       20 45 22 	      jsr	PrintProgramLine
    163  20c6
    164  20c6		       68		      pla
    165  20c7		       a8		      tay
    166  20c8		       c8		      iny
    167  20c9		       c8		      iny
    168  20ca		       4c 13 20 	      jmp	CompileLoop
    169  20cd
    170  20cd				   CompFoundLine
    171  20cd		       68		      pla
    172  20ce		       a8		      tay
    173  20cf		       a5 4f		      lda	CURPTR
    174  20d1		       91 59		      sta	(dpl),y
    175  20d3		       c8		      iny
    176  20d4		       a5 50		      lda	CURPTR+1
    177  20d6		       91 59		      sta	(dpl),y
    178  20d8		       c8		      iny
    179  20d9		       4c 13 20 	      jmp	CompileLoop
    180  20dc
    181  20dc
    182  20dc
    183  20dc
    184  20dc
    185  20dc
    186  20dc
    187  20dc
    188  20dc
    189  20dc
    190  20dc
    191  20dc
    192  20dc
    193  20dc
    194  20dc
    195  20dc
    196  20dc
    197  20dc
    198  20dc
    199  20dc
    200  20dc
    201  20dc
    202  20dc
    203  20dc
    204  20dc
    205  20dc
    206  20dc
    207  20dc
    208  20dc
    209  20dc
    210  20dc
    211  20dc
    212  20dc
    213  20dc
    214  20dc
    215  20dc
    216  20dc
    217  20dc
    218  20dc
    219  20dc
    220  20dc
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  20dc					      include	"print.asm"
      1  20dc					      Seg	Code
      2  20dc							;---------------------------
      3  20dc							; Print 24-bit decimal number or  16bit unsigned
      4  20dc							; ---------------------------
      5  20dc							; On entry, R0=number to print
      6  20dc							;	     Defaults to pad=0 , y=21 default
      7  20dc							;	     R2 = 1 unsigned 16 bit
      8  20dc							;	     R2 = 0 Signed   16 bit
      9  20dc
     10  20dc							; On entry at PrintDecPadded:
     11  20dc							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  20dc
     13  20dc							; On exit,  A,X,Y,num,pad corrupted
     14  20dc							; Size      129 bytes, Table 24 bytes	--- total 153
     15  20dc							; -----------------------------------------------------------------
     16  20dc
     17  20dc				   PrintDecimal
     18  20dc		       8a		      TXA
     19  20dd		       48		      pha
     20  20de		       98		      tya
     21  20df		       48		      pha
     22  20e0		       a9 00		      lda	#0
     23  20e2		       8d 77 21 	      sta	pad
     24  20e5		       a0 15		      LDY	#21	; Offset to powers of ten
     25  20e7		       4c ed 20 	      JMP	PrintDo
     26  20ea
     27  20ea				   PrintDecPadded
     28  20ea		       8e 77 21 	      stx	pad
     29  20ed
     30  20ed				   PrintDo
     31  20ed		       a9 00		      lda	#0
     32  20ef		       85 54		      sta	R1
     33  20f1
     34  20f1		       a5 58		      lda	R2
     35  20f3		       c9 a9		      cmp	#tUint
     36  20f5		       f0 29		      beq	PrintPos
     37  20f7
     38  20f7		       a5 53		      lda	R0+1	;MSB has sign
     39  20f9		       10 25		      bpl	PrintPos	;it's a positive number;
     40  20fb
     41  20fb
     42  20fb							; Negative numbers need more work.  Invert all the bits,
     43  20fb							; then add one.
     44  20fb
     45  20fb		       a9 2d		      lda	#'-
     46  20fd		       20 55 1a 	      jsr	VOUTCH	;print the negative sign
     47  2100
     48  2100		       a9 ff		      lda	#$FF
     49  2102		       85 54		      sta	R1
     50  2104		       a5 52		      lda	R0	;invert bits
     51  2106		       49 ff		      eor	#$ff
     52  2108		       85 52		      sta	R0
     53  210a		       a5 53		      lda	R0+1
     54  210c		       49 ff		      eor	#$ff
     55  210e		       85 53		      sta	R0+1
     56  2110		       a5 54		      lda	R1
     57  2112		       49 ff		      eor	#$ff
     58  2114		       85 54		      sta	R1
     59  2116		       e6 52		      inc	R0	;add one
     60  2118		       d0 06		      bne	PrintPos
     61  211a		       e6 53		      inc	R0+1
     62  211c		       d0 02		      bne	PrintPos
     63  211e		       e6 54		      inc	R1
     64  2120				   PrintPos
     65  2120
     66  2120				   PrDec24Lp1
     67  2120		       a2 ff		      LDX	#$FF
     68  2122		       38		      SEC		; Start with digit=-1
     69  2123				   PrDec24Lp2
     70  2123		       a5 52		      LDA	R0+0
     71  2125		       f9 78 21 	      SBC	PrDec24Tens+0,Y
     72  2128		       85 52		      STA	R0+0	; Subtract current tens
     73  212a		       a5 53		      LDA	R0+1
     74  212c		       f9 79 21 	      SBC	PrDec24Tens+1,Y
     75  212f		       85 53		      STA	R0+1
     76  2131		       a5 54		      LDA	R0+2
     77  2133		       f9 7a 21 	      SBC	PrDec24Tens+2,Y
     78  2136		       85 54		      STA	R0+2
     79  2138		       e8		      INX
     80  2139		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     81  213b		       a5 52		      LDA	R0+0
     82  213d		       79 78 21 	      ADC	PrDec24Tens+0,Y
     83  2140		       85 52		      STA	R0+0	; Add current tens back in
     84  2142		       a5 53		      LDA	R0+1
     85  2144		       79 79 21 	      ADC	PrDec24Tens+1,Y
     86  2147		       85 53		      STA	R0+1
     87  2149		       a5 54		      LDA	R0+2
     88  214b		       79 7a 21 	      ADC	PrDec24Tens+2,Y
     89  214e		       85 54		      STA	R0+2
     90  2150		       8a		      TXA
     91  2151		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     92  2153		       ad 77 21 	      LDA	pad
     93  2156		       d0 09		      BNE	PrDec24Print
     94  2158		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     95  215a				   PrDec24Digit
     96  215a		       a2 30		      LDX	#'0
     97  215c		       8e 77 21 	      STX	pad	; No more zero padding
     98  215f		       09 30		      ORA	#'0	; Print this digit
     99  2161				   PrDec24Print
    100  2161		       20 55 1a 	      JSR	VOUTCH
    101  2164				   PrDec24Next
    102  2164		       88		      DEY
    103  2165		       88		      DEY
    104  2166		       88		      DEY
    105  2167		       f0 07		      beq	PrDec24LastDigit
    106  2169		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    107  216b		       68		      pla
    108  216c		       a8		      tay
    109  216d		       68		      pla
    110  216e		       aa		      tax
    111  216f		       60		      RTS
    112  2170				   PrDec24LastDigit
    113  2170		       a2 30		      LDX	#'0
    114  2172		       8e 77 21 	      STX	pad	; No more zero padding
    115  2175		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    116  2177
      0  2177				   pad	      db	0
      1  2177		       00		      .byte.b	0
    118  2178
    119  2178				   PrDec24Tens
      0  2178					      dw	1
      1  2178		       01 00		      .word.w	1
      0  217a					      db	(1 / 65536)
      1  217a		       00		      .byte.b	(1 / 65536)
      0  217b					      dw	10
      1  217b		       0a 00		      .word.w	10
      0  217d					      db	(10 / 65536)
      1  217d		       00		      .byte.b	(10 / 65536)
      0  217e					      dw	100
      1  217e		       64 00		      .word.w	100
      0  2180					      db	(100 / 65536)
      1  2180		       00		      .byte.b	(100 / 65536)
      0  2181					      dw	1000
      1  2181		       e8 03		      .word.w	1000
      0  2183					      db	(1000 / 65536)
      1  2183		       00		      .byte.b	(1000 / 65536)
      0  2184					      dw	10000
      1  2184		       10 27		      .word.w	10000
      0  2186					      db	(10000 / 65536)
      1  2186		       00		      .byte.b	(10000 / 65536)
      0  2187					      dw	100000
      1  2187		       a0 86		      .word.w	100000
      0  2189					      db	(100000 / 65536)
      1  2189		       01		      .byte.b	(100000 / 65536)
      0  218a					      dw	1000000
      1  218a		       40 42		      .word.w	1000000
      0  218c					      db	(1000000 / 65536)
      1  218c		       0f		      .byte.b	(1000000 / 65536)
      0  218d					      dw	10000000
      1  218d		       80 96		      .word.w	10000000
      0  218f					      db	(10000000 / 65536)
      1  218f		       98		      .byte.b	(10000000 / 65536)
    136  2190							;=====================================================
    137  2190							; Print character in A as two hex digits to the Console
    138  2190
    139  2190		       48	   HexToOut   pha		;save return value
    140  2191		       48		      pha
    141  2192		       4a		      lsr		;a  ;move top nibble to bottom
    142  2193		       4a		      lsr		;a
    143  2194		       4a		      lsr		;a
    144  2195		       4a		      lsr		;a
    145  2196		       20 9f 21 	      jsr	hexta	;output nibble
    146  2199		       68		      pla
    147  219a		       20 9f 21 	      jsr	hexta
    148  219d		       68		      pla		;restore
    149  219e		       60		      rts
    150  219f							;
    151  219f		       29 0f	   hexta      and	#%0001111
    152  21a1		       c9 0a		      cmp	#$0a
    153  21a3		       18		      clc
    154  21a4		       30 02		      bmi	hexta1
    155  21a6		       69 07		      adc	#7
    156  21a8		       69 30	   hexta1     adc	#'0	;then fall into...
    157  21aa		       4c 55 1a 	      jmp	VOUTCH
    158  21ad							;
    159  21ad							;=====================================================
    160  21ad							; Print the string that immediately follows the JSR to
    161  21ad							; this function.  Stops when a null byte is found,
    162  21ad							; then returns to the instruction immediately
    163  21ad							; following the null.
    164  21ad							;
    165  21ad							; Thanks to Ross Archer for this code.
    166  21ad							; http://www.6502.org/source/io/primm.htm
    167  21ad							;
    168  21ad
    169  21ad		       68	   tbputs     pla		;Get the low part of "return" address
    170  21ae							;(data start address)
    171  21ae		       85 5e		      sta	PrtFrom
    172  21b0		       68		      pla
    173  21b1		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    174  21b3							;(data start address)
    175  21b3							;Note: actually we're pointing one short
    176  21b3		       a0 01	   PSINB      ldy	#1
    177  21b5		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    178  21b7		       e6 5e		      inc	PrtFrom	;update the pointer
    179  21b9		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    180  21bb		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    181  21bd		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    182  21bf							;   Accumulator
    183  21bf		       f0 06		      beq	PSIX1	;don't print the final NULL
    184  21c1		       20 55 1a 	      jsr	VOUTCH	;write it out
    185  21c4		       4c b3 21 	      jmp	PSINB	;back around
    186  21c7		       e6 5e	   PSIX1      inc	PrtFrom
    187  21c9		       d0 02		      bne	PSIX2
    188  21cb		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    189  21cd		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    190  21d0
    191  21d0							;+
    192  21d0							;====================================================
    193  21d0		       43 21	   PrtTerm    equ	tempy
    194  21d0
    195  21d0							; on exit Print Y has the offset to use
    196  21d0							; input y =	 addr low
    197  21d0							;	 x =	 addr high
    198  21d0							;	 a =	 termination string
    199  21d0
    200  21d0
    201  21d0				   PrtQuoted		; Print a quoted string from the current program space
    202  21d0		       a9 22		      lda	#'"
    203  21d2		       a4 51		      ldy	CUROFF
    204  21d4		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    205  21d6		       d0 03		      bne	PrtNoInc
    206  21d8		       c8		      iny
    207  21d9		       84 51		      sty	CUROFF
    208  21db				   PrtNoInc
    209  21db		       8d 21 43 	      sta	PrtTerm
    210  21de
    211  21de				   PrtPrgString 		; Print a terminated string from the static program space
    212  21de		       a4 51		      ldy	CUROFF
    213  21e0		       a5 4f		      lda	CURPTR
    214  21e2		       85 5e		      sta	PrtFrom
    215  21e4		       a5 50		      lda	CURPTR+1
    216  21e6		       85 5f		      sta	PrtFrom+1
    217  21e8		       4c f4 21 	      jmp	PrtLoop
    218  21eb
    219  21eb							; Print a string pointed to by x= h, y=l terminated by value in  accumulator
    220  21eb							; Return y as the length
    221  21eb
    222  21eb		       86 5f	   PrtStr     stx	PrtFrom+1
    223  21ed		       84 5e		      sty	PrtFrom
    224  21ef		       8d 21 43 	      sta	PrtTerm
    225  21f2		       a0 00		      ldy	#0
    226  21f4							;
    227  21f4							; On entry here ptrfrom and prtterm point to area to print
    228  21f4							;
    229  21f4		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    230  21f6		       cd 21 43 	      cmp	PrtTerm
    231  21f9		       f0 0b		      beq	PrtEnd
    232  21fb		       c9 00		      cmp	#0	; always end if 0 is found
    233  21fd		       f0 07		      beq	PrtEnd
    234  21ff		       20 55 1a 	      jsr	VOUTCH
    235  2202		       c8		      iny
    236  2203		       4c f4 21 	      jmp	PrtLoop
    237  2206		       c8	   PrtEnd     iny		;return byte after the write
    238  2207		       60		      rts
    239  2208
    240  2208							;
    241  2208							;=======================================================
    242  2208							; Print all Variables
    243  2208				   PrintAllVars
    244  2208		       a0 00		      ldy	#0
    245  220a		       a9 41		      lda	#'A
    246  220c				   PrintAllVarsLoop
    247  220c		       48		      pha
    248  220d		       b1 41		      lda	(VARIABLES),y
    249  220f		       85 52		      sta	R0
    250  2211		       c8		      iny
    251  2212		       b1 41		      lda	(VARIABLES),y
    252  2214		       85 53		      sta	R0+1
    253  2216
    254  2216		       68		      pla		;get the current letter
    255  2217		       48		      pha
    256  2218		       20 55 1a 	      jsr	VOUTCH
    257  221b		       20 ad 21 	      jsr	puts
      0  221e					      db	"=",0
      1  221e		       3d 00		      .byte.b	"=",0
    259  2220		       68		      pla
    260  2221		       aa		      tax
    261  2222		       e8		      inx
    262  2223		       8a		      txa
    263  2224		       48		      pha		;
    264  2225
    265  2225		       98		      tya
    266  2226		       48		      pha
    267  2227		       20 dc 20 	      jsr	PrintDecimal
    268  222a		       20 ad 21 	      jsr	puts
      0  222d					      db	" ",0
      1  222d		       20 00		      .byte.b	" ",0
    270  222f		       68		      pla
    271  2230		       a8		      tay
    272  2231		       c8		      iny
    273  2232		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    274  2234		       90 d6		      bcc	PrintAllVarsLoop
    275  2236		       20 6f 2d 	      jsr	CRLF
    276  2239
    277  2239		       68		      pla
    278  223a		       60		      rts
    279  223b							;==========================================================================================================
    280  223b							;Debug   Print a Program Line from compile buffer
    281  223b							;
    282  223b				   DebugPrintProgramLine
    283  223b		       48		      pha
    284  223c		       a9 4d		      lda	#TOKENBUFFER&$FF
    285  223e		       85 59		      sta	dpl
    286  2240		       a9 1c		      lda	#TOKENBUFFER>>8
    287  2242		       85 5a		      sta	dpl+1
    288  2244		       68		      pla
    289  2245
    290  2245							; Decode and print a line of program text
    291  2245							; on entry	 dpl points to line of code to print
    292  2245							; on exit	 no change in reg or dpl
    293  2245							;
    294  2245				   PrintProgramLine
    295  2245
    296  2245		       8e 4d 1d 	      stx	printStorage
    297  2248		       8c 4e 1d 	      sty	printStorage+1
    298  224b		       48		      pha
    299  224c
    300  224c		       a0 01		      ldy	#1	; index into the token buffer
    301  224e		       84 58		      sty	R2	; print unsigned decimal
    302  2250		       a0 00		      ldy	#0
    303  2252		       b1 59		      lda	(dpl),y	; get number of bytes
    304  2254		       aa		      tax		; place pointer into x
    305  2255		       c8		      iny
    306  2256		       ca		      dex		; Deduct the length byte
    307  2257		       20 39 1f 	      jsr	DPL2R0	; Print the line number
    308  225a		       20 dc 20 	      jsr	PrintDecimal
    309  225d		       a9 20		      lda	#$20
    310  225f		       20 55 1a 	      jsr	VOUTCH
    311  2262
    312  2262				   PrintProgLoop
    313  2262		       b1 59		      lda	(dpl),y	; Get a character
    314  2264		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    315  2266		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    316  2268		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    317  226a
    318  226a				   PrintProgVars
    319  226a		       b1 59		      lda	(dpl),y
    320  226c		       29 e0		      and	#$E0	; Check for operators and punctuation
    321  226e		       c9 e0		      cmp	#$E0
    322  2270		       f0 6b		      beq	PrintProgOperatorVect
    323  2272
    324  2272		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    325  2274		       c9 9e		      cmp	#$9D+1
    326  2276		       90 62		      bcc	PrintProgVariableVec
    327  2278		       29 a0		      and	#$A0	; Check for a valid datatype
    328  227a		       c9 a0		      cmp	#$A0
    329  227c		       f0 06		      beq	PrintDataType	; if not just print the character
    330  227e		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    331  2280		       ca		      dex		; Ok we are processing it
    332  2281		       c8		      iny
    333  2282		       d0 25		      bne	PrintContinue	; Print and do the next character
    334  2284
    335  2284				   PrintDataType
    336  2284		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    337  2286		       c9 a0		      cmp	#tString
    338  2288		       f0 31		      beq	PrintStringVariable
    339  228a
    340  228a				   PrintProgNumber
    341  228a		       c8		      iny		; we have a numerical integer value
    342  228b		       ca		      dex
    343  228c		       48		      pha
    344  228d		       a9 00		      lda	#0
    345  228f		       85 53		      sta	R0+1
    346  2291		       85 58		      sta	R2	; Set to print signed number
    347  2293		       b1 59		      lda	(dpl),y
    348  2295		       85 52		      sta	R0
    349  2297		       68		      pla
    350  2298		       c9 a4		      cmp	#tInteger
    351  229a		       d0 06		      bne	PrintProgNumDone
    352  229c		       c8		      iny
    353  229d		       ca		      dex
    354  229e		       b1 59		      lda	(dpl),y
    355  22a0		       85 53		      sta	R0+1
    356  22a2
    357  22a2				   PrintProgNumDone
    358  22a2		       c8		      iny
    359  22a3		       ca		      dex
    360  22a4		       20 dc 20 	      jsr	PrintDecimal
    361  22a7
    362  22a7				   PrintProgNext
    363  22a7		       a9 20		      lda	#$20
    364  22a9				   PrintContinue
    365  22a9		       20 55 1a 	      jsr	VOUTCH
    366  22ac				   PrintProgSkipSpace
    367  22ac		       e0 00		      cpx	#0
    368  22ae		       d0 b2		      bne	PrintProgLoop
    369  22b0				   PrintProgramComplete
    370  22b0		       20 6f 2d 	      jsr	CRLF
    371  22b3
    372  22b3		       ae 4d 1d 	      ldx	printStorage
    373  22b6		       ac 4e 1d 	      ldy	printStorage+1
    374  22b9		       68		      pla
    375  22ba
    376  22ba		       60		      rts
    377  22bb							;=================================================================================================================
    378  22bb							; Print a string variable including the quotes
    379  22bb							; On Input	 y is offset into buffer
    380  22bb							; On Exit	 y is updated to new offset
    381  22bb
    382  22bb				   PrintStringVariable
    383  22bb		       c8		      iny
    384  22bc		       a9 22		      lda	#'"
    385  22be		       20 55 1a 	      jsr	VOUTCH
    386  22c1		       c8		      iny
    387  22c2		       a5 59		      lda	dpl
    388  22c4		       85 5e		      sta	PrtFrom
    389  22c6		       a5 5a		      lda	dpl+1
    390  22c8		       85 5f		      sta	PrtFrom+1
    391  22ca		       a9 22		      lda	#'"
    392  22cc		       8d 21 43 	      sta	PrtTerm
    393  22cf		       20 f4 21 	      jsr	PrtLoop
    394  22d2		       a9 22		      lda	#'"
    395  22d4		       20 55 1a 	      jsr	VOUTCH
    396  22d7		       4c a7 22 	      jmp	PrintProgNext
    397  22da
    398  22da				   PrintProgVariableVec
    399  22da		       4c 7a 23 	      jmp	PrintProgVariable
    400  22dd
    401  22dd				   PrintProgOperatorVect
    402  22dd		       4c 51 23 	      jmp	PrintProgOperator
    403  22e0							;===============================================================================================================
    404  22e0							; On entry dpl points to the buffer we are printing from
    405  22e0							;	    y	current offset into the dpl buffer
    406  22e0							; all registers preserved
    407  22e0							;
    408  22e0				   PrintKeyword
    409  22e0
    410  22e0		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    411  22e2		       85 52		      sta	R0	; The value we are looking for
    412  22e4		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    413  22e6		       f0 0c		      beq	PrintKeyBranch
    414  22e8		       c9 08		      cmp	#kGosub
    415  22ea		       f0 08		      beq	PrintKeyBranch
    416  22ec		       c9 2f		      cmp	#kTask
    417  22ee		       f0 04		      beq	PrintKeyBranch
    418  22f0		       c9 37		      cmp	#kGofn
    419  22f2		       d0 04		      bne	PrintKeySkipped
    420  22f4				   PrintKeyBranch
    421  22f4		       c8		      iny		; Skip the compiled memory address
    422  22f5		       c8		      iny
    423  22f6		       ca		      dex		; Change number of bytes to print
    424  22f7		       ca		      dex		; Remove the bytes to print
    425  22f8
    426  22f8				   PrintKeySkipped
    427  22f8		       c8		      iny		; Inc y to point to the next char to be printed
    428  22f9		       ca		      dex		; Reduce number of bytes to print
    429  22fa		       98		      tya		; Save y and x for the return
    430  22fb		       48		      pha
    431  22fc		       8a		      txa
    432  22fd		       48		      pha
    433  22fe
    434  22fe		       a9 10		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    435  2300		       85 54		      sta	R1
    436  2302		       a9 1b		      lda	#KeyWordTable>>8
    437  2304		       85 55		      sta	R1+1
    438  2306
    439  2306
    440  2306				   PrintKeyLoop
    441  2306		       a0 00		      ldy	#0	; Index into the keyword entry
    442  2308		       b1 54		      lda	(R1),y	; Get token value for this entry
    443  230a		       c8		      iny		; Point to first byte of key
    444  230b		       c5 52		      cmp	R0	; Compare to the token we are looking for
    445  230d		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    446  230f
    447  230f				   PrintKeyNext
    448  230f		       b1 54		      lda	(R1),y	; Get key letter
    449  2311		       c8		      iny		; Point to next byte always
    450  2312		       29 20		      and	#%00100000	; Check for last character in key work
    451  2314		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    452  2316
    453  2316		       98		      tya		; Trabsfer y to a for the addition
    454  2317		       18		      clc		; Table > 256 bytes
    455  2318		       65 54		      adc	R1
    456  231a		       85 54		      sta	R1
    457  231c		       a9 00		      lda	#0
    458  231e		       65 55		      adc	R1+1
    459  2320		       85 55		      sta	R1+1
    460  2322		       4c 06 23 	      jmp	PrintKeyLoop
    461  2325
    462  2325				   PrintKeyFound
    463  2325		       b1 54		      lda	(R1),y	; letter from key table
    464  2327		       48		      pha		; Save it for later check
    465  2328		       09 20		      ora	#%00100000	; Force it to lower case
    466  232a		       20 55 1a 	      jsr	VOUTCH	; Print it out
    467  232d		       c8		      iny		; Point to next character
    468  232e		       68		      pla		; Restore the value
    469  232f		       29 20		      and	#%00100000	; Check if it was last char in keyword
    470  2331		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    471  2333
    472  2333		       68		      pla		; Restore the x and y values
    473  2334		       aa		      tax
    474  2335		       68		      pla
    475  2336		       a8		      tay
    476  2337
    477  2337				   PrintChkRem
    478  2337		       a9 0a		      lda	#kRem
    479  2339		       c5 52		      cmp	R0
    480  233b		       d0 11		      bne	PrintKeyDone
    481  233d				   PrintKeyRem
    482  233d		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    483  233f		       85 5e		      sta	PrtFrom
    484  2341		       a5 5a		      lda	dpl+1
    485  2343		       85 5f		      sta	PrtFrom+1
    486  2345		       a9 00		      lda	#0
    487  2347		       8d 21 43 	      sta	PrtTerm
    488  234a		       20 f4 21 	      jsr	PrtLoop
    489  234d		       88		      dey		; point back to the terminating null value
    490  234e				   PrintKeyDone
    491  234e		       4c a7 22 	      jmp	PrintProgNext
    492  2351							;==================================================================================================================
    493  2351							;Print Variable, number or operator
    494  2351				   PrintProgOperator
    495  2351		       b1 59		      lda	(dpl),y
    496  2353		       c8		      iny
    497  2354		       ca		      dex
    498  2355		       8e 4f 1d 	      stx	printStorage+2
    499  2358		       a2 00		      ldx	#0
    500  235a				   PrintOprLoop
    501  235a		       dd f2 1a 	      cmp	OperValues,x
    502  235d		       f0 03		      beq	PrintOprFound
    503  235f		       e8		      inx
    504  2360		       d0 f8		      bne	PrintOprLoop
    505  2362				   PrintOprFound
    506  2362		       8a		      txa
    507  2363		       0a		      asl
    508  2364		       aa		      tax
    509  2365		       bd b4 1a 	      lda	Operators,x
    510  2368		       20 55 1a 	      jsr	VOUTCH
    511  236b		       e8		      inx
    512  236c		       bd b4 1a 	      lda	Operators,x
    513  236f		       f0 03		      beq	PrintOprDone
    514  2371		       20 55 1a 	      jsr	VOUTCH
    515  2374				   PrintOprDone
    516  2374		       ae 4f 1d 	      ldx	printStorage+2
    517  2377		       4c a7 22 	      jmp	PrintProgNext
    518  237a
    519  237a							;=================================================================================================================
    520  237a							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    521  237a							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    522  237a							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    523  237a							;tVhat 	    equ     155 		   ; Variable ^
    524  237a							;tVhash	    equ     156 		   ; Variable #
    525  237a							;tVat		    equ     157 		   ; Variable @ = 0
    526  237a				   PrintProgVariable
    527  237a		       b1 59		      lda	(dpl),y
    528  237c		       c8		      iny
    529  237d		       ca		      dex
    530  237e		       c9 9b		      cmp	#tVhat
    531  2380		       d0 04		      bne	PrintProgChkHash
    532  2382		       a9 5e		      lda	#'^
    533  2384		       d0 15		      bne	PrintTheVar
    534  2386				   PrintProgChkHash
    535  2386		       c9 9c		      cmp	#tVhash
    536  2388		       d0 04		      bne	PrintProgChkAt
    537  238a		       a9 23		      lda	#'#
    538  238c		       d0 0d		      bne	PrintTheVar
    539  238e				   PrintProgChkAt
    540  238e		       c9 9d		      cmp	#tVat
    541  2390		       d0 04		      bne	PrintProgVarLetter
    542  2392		       a9 40		      lda	#'@
    543  2394		       d0 05		      bne	PrintTheVar
    544  2396				   PrintProgVarLetter
    545  2396		       29 7f		      and	#%01111111
    546  2398		       18		      clc
    547  2399		       69 41		      adc	#'A
    548  239b				   PrintTheVar
    549  239b		       20 55 1a 	      jsr	VOUTCH
    550  239e		       4c a7 22 	      jmp	PrintProgNext
    551  23a1
    552  23a1
    553  23a1							;==================================================================================================
    554  23a1							; Size of print functions
    555  23a1		       02 c5	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  23a1					      include	"mem.asm"
      1  23a1							;===================================================================
      2  23a1							;This file contains the memory allocation and free functions
      3  23a1							; This is the management of free memory in the system
      4  23a1							; the interface to these functions
      5  23a1							; a,x returns or provides the low hi bytes of the managed addresses
      6  23a1							; This uses the programend, to memory end as the area to manage
      7  23a1							;===================================================================
      8 U366c					      Seg.u	TBData
      9 U366c							;
     10 U366c							;=====================================================
     11 U366c							;Pointers for memory Management
     12 U366c							;Allocated block are not chained but can be followed for all memory by the associated length
     13 U366c							; Mem block format is
     14 U366c							;	 0-1   pointer to next block for free blocks
     15 U366c							;	 0-1   for allocated blocks
     16 U366c							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     17 U366c							;	   1   refrence counter ... lol only up to 256 but it is something
     18 U366c							;	 2-3   length constant for exevy type of memory block
     19 U366c							; Memory is recombined as it is released
     20 U366c							; The memory manager is not interupted durring allocation
     21 U366c							; or freeing of memory
     22 U366c							;====================================================
     23 U366c		       00 00	   MemFreeList ds	2	; list of free blocks of memory
     24 U366e		       00 00	   MemR0      ds	2	; source for copy/move/Init
     25 U3670		       00 00	   MemR1      ds	2	; Destination for copy/move
     26 U3672							;=====================================================
     27  23a1					      Seg	Code
     28  23a1							;=====================================================
     29  23a1				   MemInit
     30  23a1		       a9 37		      lda	#FreeMemStart&$FF
     31  23a3		       8d 2d 43 	      sta	ProgramStart
     32  23a6		       8d 2f 43 	      sta	ProgramEnd
     33  23a9		       a9 43		      lda	#FreeMemStart>>8
     34  23ab		       8d 2e 43 	      sta	ProgramStart+1
     35  23ae		       8d 30 43 	      sta	ProgramEnd+1
     36  23b1
     37  23b1		       20 bb 23 	      jsr	GetSizes
     38  23b4		       20 c6 23 	      jsr	MemFree
     39  23b7		       20 de 23 	      jsr	MemUsed
     40  23ba				   MemInitEnd
     41  23ba		       60		      rts
     42  23bb
     43  23bb
     44  23bb							;
     45  23bb							;=====================================================
     46  23bb							; This function might go away eventually, but was
     47  23bb							; added to provide data for other pieces of code.
     48  23bb							; It has some ties to the operating environment that
     49  23bb							; will need to be customized for the target system.
     50  23bb							;
     51  23bb				   GetSizes
     52  23bb							;
     53  23bb							; Here is machine specific code to get the highest
     54  23bb							; memory location that can be used by BASIC.
     55  23bb							;
     56  23bb				  -	      if	ProgramStart < $2000
     57  23bb				  -	      lda	#$ff
     58  23bb				  -	      sta	HighMem	;$13ff for KIM-1
     59  23bb				  -	      sta	MemFreeList
     60  23bb				  -	      lda	#$DE	;#$13
     61  23bb				  -	      sta	HighMem+1
     62  23bb				  -	      sta	MemFreeList+1
     63  23bb					      else
     64  23bb		       a9 ff		      lda	#$ff
     65  23bd		       8d 31 43 	      sta	HighMem	;$CFFF otherwise
     66  23c0		       a9 cf		      lda	#$cf
     67  23c2		       8d 32 43 	      sta	HighMem+1
     68  23c5					      endif
     69  23c5		       60		      rts
     70  23c6							;
     71  23c6							; This computes the available memory remaining.
     72  23c6							;
     73  23c6				   MemFree
     74  23c6		       38		      sec
     75  23c7		       ad 31 43 	      lda	HighMem
     76  23ca		       ed 2f 43 	      sbc	ProgramEnd
     77  23cd		       8d 35 43 	      sta	FreeMem
     78  23d0		       85 52		      sta	R0
     79  23d2		       ad 32 43 	      lda	HighMem+1
     80  23d5		       ed 30 43 	      sbc	ProgramEnd+1
     81  23d8		       8d 36 43 	      sta	FreeMem+1
     82  23db		       85 53		      sta	R0+1
     83  23dd		       60		      rts
     84  23de							;
     85  23de							; This computes the size of the current user program.
     86  23de							;
     87  23de				   MemUsed
     88  23de		       38		      sec
     89  23df		       ad 2f 43 	      lda	ProgramEnd
     90  23e2		       ed 2d 43 	      sbc	ProgramStart
     91  23e5		       8d 33 43 	      sta	UsedMem
     92  23e8		       85 52		      sta	R0
     93  23ea		       ad 30 43 	      lda	ProgramEnd+1
     94  23ed		       ed 2e 43 	      sbc	ProgramStart+1
     95  23f0		       8d 34 43 	      sta	UsedMem+1
     96  23f3		       85 53		      sta	R0+1
     97  23f5							;
     98  23f5		       60		      rts
     99  23f6							;
    100  23f6							;=====================================================
    101  23f6							; Set a block of memory to a value
    102  23f6		       8a	   iSetBlock  txa
    103  23f7		       48		      pha
    104  23f8		       98		      tya
    105  23f9		       48		      pha
    106  23fa		       20 b6 2c 	      jsr	popR0	; the address to write to
    107  23fd		       a5 52		      lda	R0
    108  23ff		       85 59		      sta	dpl
    109  2401		       a5 53		      lda	R0+1
    110  2403		       85 5a		      sta	dpl+1
    111  2405		       20 ce 2c 	      jsr	popR1	; Number of bytes to write
    112  2408		       20 b6 2c 	      jsr	popR0	; Get the value to store into memory
    113  240b		       20 2b 2a 	      jsr	getILByte
    114  240e		       85 58		      sta	R2	; store the data type into R2
    115  2410		       c9 a4		      cmp	#tInteger
    116  2412		       f0 08		      beq	memset	; skip this if we have an integer
    117  2414		       a5 52		      lda	R0	; Revers the order so they can be copied in correct order
    118  2416		       a6 53		      ldx	R0+1
    119  2418		       86 52		      stx	R0
    120  241a		       85 53		      sta	R0+1
    121  241c
    122  241c				   memset
    123  241c		       a0 00		      ldy	#0	; Set for length of block to copy
    124  241e		       a2 00		      ldx	#0	; set for number of block of 256 to copy
    125  2420
    126  2420		       a5 58	   iSetBlockLoop lda	R2	; Get Datatype
    127  2422		       c9 a2		      cmp	#tByte
    128  2424		       f0 09		      beq	iSetBlockB
    129  2426
    130  2426		       a5 52	   iSetBlockW lda	R0
    131  2428		       91 59		      sta	(dpl),y
    132  242a		       20 3f 24 	      jsr	iSetBlockEnd
    133  242d		       f0 09		      beq	iSetBlockComplete
    134  242f
    135  242f		       a5 53	   iSetBlockB lda	R0+1
    136  2431		       91 59		      sta	(dpl),y
    137  2433		       20 3f 24 	      jsr	iSetBlockEnd
    138  2436		       d0 e8		      bne	iSetBlockLoop
    139  2438
    140  2438				   iSetBlockComplete
    141  2438		       68		      pla
    142  2439		       a8		      tay
    143  243a		       68		      pla
    144  243b		       aa		      tax
    145  243c		       4c b1 02 	      jmp	NextIL
    146  243f							;
    147  243f							; Check if we have reached the end of the initialization/Copy
    148  243f							;
    149  243f		       c8	   iSetBlockEnd iny
    150  2440		       d0 03		      bne	iSetBlockEndChk
    151  2442		       e8		      inx
    152  2443		       e6 5a		      inc	dpl+1
    153  2445				   iSetBlockEndChk
    154  2445		       c4 54		      cpy	R1
    155  2447		       d0 02		      bne	iSetBlockEndExit
    156  2449		       e4 55		      cpx	R1+1
    157  244b				   iSetBlockEndExit
    158  244b		       60		      rts
    159  244c							;
    160  244c							;================================================================
    161  244c							; Copy a block of memory from one location to another
    162  244c							;
    163  244c		       8a	   iCopyBlock txa
    164  244d		       48		      pha
    165  244e		       98		      tya
    166  244f		       48		      pha
    167  2450		       20 b6 2c 	      jsr	popR0	; get the source address
    168  2453		       20 ce 2c 	      jsr	popR1	; Destination address
    169  2456		       a5 54		      lda	R1
    170  2458		       85 59		      sta	dpl
    171  245a		       a5 55		      lda	R1+1
    172  245c		       85 5a		      sta	dpl+1
    173  245e		       20 ce 2c 	      jsr	popR1	; Number of bytes to copy
    174  2461				   memcpy
    175  2461		       a2 00		      ldx	#0
    176  2463		       a0 00		      ldy	#0
    177  2465				   iCopyBlockLoop
    178  2465		       b1 52		      lda	(R0),y	;  Get the byte to copy
    179  2467		       91 59		      sta	(dpl),y	;  Store the byte
    180  2469		       c8		      iny
    181  246a		       d0 05		      bne	iCopyChkEnd
    182  246c		       e8		      inx
    183  246d		       e6 53		      inc	R0+1
    184  246f		       e6 5a		      inc	dpl+1
    185  2471		       c4 54	   iCopyChkEnd cpy	R1
    186  2473		       d0 f0		      bne	iCopyBlockLoop
    187  2475		       e4 55		      cpx	R1+1
    188  2477		       d0 ec		      bne	iCopyBlockLoop
    189  2479				   iCopyBlockDone
    190  2479		       68		      pla
    191  247a		       a8		      tay
    192  247b		       68		      pla
    193  247c		       aa		      tax
    194  247d		       4c b1 02 	      jmp	NextIL
    195  2480							;
    196  2480							;=============================================================================
    197  2480							; Compare memory block location
    198  2480							; returns on the stack
    199  2480							; 0 - equals
    200  2480							; -1 - s1  <  s2
    201  2480							; 1   s1  >  s2
    202  2480		       8a	   iCmpBlock  txa
    203  2481		       48		      pha
    204  2482		       98		      tya
    205  2483		       48		      pha
    206  2484		       20 ce 2c 	      jsr	popR1	; Get the Source 2 pointer
    207  2487		       a5 54		      lda	R1
    208  2489		       85 59		      sta	dpl	; store the secon source in dpl
    209  248b		       a5 55		      lda	R1+1
    210  248d		       85 5a		      sta	dpl+1
    211  248f		       20 b6 2c 	      jsr	popR0	; Get the Source 1 pointer
    212  2492		       20 ce 2c 	      jsr	popR1	; Get the length of the compare to do
    213  2495		       a0 00		      ldy	#0
    214  2497		       a2 00		      ldx	#0
    215  2499		       4c a6 24 	      jmp	iCmpCheckEnd
    216  249c
    217  249c		       b1 59	   iCmpLoop   lda	(dpl),y
    218  249e		       d1 52		      cmp	(R0),y
    219  24a0		       d0 19		      bne	iCmpDone
    220  24a2		       c8		      iny
    221  24a3		       d0 01		      bne	iCmpCheckEnd
    222  24a5		       e8		      inx
    223  24a6				   iCmpCheckEnd
    224  24a6		       c4 54		      cpy	R1
    225  24a8		       d0 f2		      bne	iCmpLoop
    226  24aa		       e4 55		      cpx	R1+1
    227  24ac		       d0 ee		      bne	iCmpLoop
    228  24ae		       a5 00		      lda	0
    229  24b0		       85 53		      sta	R0+1
    230  24b2		       85 52		      sta	R0
    231  24b4				   iCmpReturn
    232  24b4		       68		      pla
    233  24b5		       a8		      tay
    234  24b6		       68		      pla
    235  24b7		       aa		      tax
    236  24b8		       4c 1d 07 	      jmp	pushR0nextIl
    237  24bb
    238  24bb				   iCmpDone
    239  24bb		       90 0a		      bcc	iCmpGreater
    240  24bd				   iCmpLess
    241  24bd		       a9 00		      lda	#0
    242  24bf		       85 53		      sta	R0+1
    243  24c1		       a9 01		      lda	#1
    244  24c3		       85 52		      sta	R0
    245  24c5		       d0 ed		      bne	iCmpReturn
    246  24c7				   iCmpGreater
    247  24c7		       a9 ff		      lda	#-1
    248  24c9		       85 52		      sta	R0
    249  24cb		       85 53		      sta	R0+1
    250  24cd		       d0 e5		      bne	iCmpReturn
    251  24cf
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  24cf					      include	"gosub.asm"
      1  24cf					      seg	Code
      2  24cf
      3  24cf							; Gosub and return related functions
      4  24cf							;==========================================================
      5  24cf							; Push the current math stack frame onto the gosub stack
      6  24cf				   iPushMathStack
      7  24cf		       98		      tya
      8  24d0		       48		      pha
      9  24d1		       a4 4d		      ldy	GOSUBSTACKPTR
     10  24d3		       a5 4a		      lda	MATHSTACKPTR
     11  24d5		       91 4b		      sta	(GOSUBSTACK),y
     12  24d7		       a9 00		      lda	#0
     13  24d9		       c8		      iny
     14  24da		       91 4b		      sta	(GOSUBSTACK),y
     15  24dc		       c8		      iny
     16  24dd		       91 4b		      sta	(GOSUBSTACK),y
     17  24df		       c8		      iny
     18  24e0		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  24e2		       91 4b		      sta	(GOSUBSTACK),y
     20  24e4		       c8		      iny
     21  24e5		       84 4d		      sty	GOSUBSTACKPTR
     22  24e7		       68		      pla
     23  24e8		       a8		      tay
     24  24e9		       4c b1 02 	      jmp	NextIL
     25  24ec							;
     26  24ec							;==========================================================
     27  24ec							; Increment parameter count. Assume Stack frame is top of stack
     28  24ec				   iIncParmCount
     29  24ec		       98		      tya
     30  24ed		       48		      pha
     31  24ee
     32  24ee		       a4 4d		      ldy	GOSUBSTACKPTR
     33  24f0		       88		      dey
     34  24f1		       88		      dey
     35  24f2		       88		      dey
     36  24f3		       b1 4b		      lda	(GOSUBSTACK),y
     37  24f5		       18		      clc
     38  24f6		       69 01		      adc	#1
     39  24f8		       91 4b		      sta	(GOSUBSTACK),y
     40  24fa
     41  24fa		       68		      pla
     42  24fb		       a8		      tay
     43  24fc		       4c b1 02 	      jmp	NextIL
     44  24ff							;
     45  24ff							;==========================================================
     46  24ff							;Restore the math stack frame
     47  24ff		       20 05 25    iPopMathStack jsr	PopMathStackNow
     48  2502		       4c b1 02 	      jmp	NextIL
     49  2505
     50  2505				   PopMathStackNow
     51  2505		       98		      tya
     52  2506		       48		      pha
     53  2507
     54  2507		       a4 4d		      ldy	GOSUBSTACKPTR
     55  2509		       88		      dey
     56  250a		       b1 4b		      lda	(GOSUBSTACK),y
     57  250c		       c9 05		      cmp	#GOSUB_STACK_FRAME
     58  250e		       d0 09		      bne	iPopMathStackNoFrame
     59  2510		       88		      dey
     60  2511		       88		      dey
     61  2512		       88		      dey
     62  2513		       b1 4b		      lda	(GOSUBSTACK),y
     63  2515		       85 4a		      sta	MATHSTACKPTR
     64  2517		       84 4d		      sty	GOSUBSTACKPTR
     65  2519
     66  2519				   iPopMathStackNoFrame
     67  2519
     68  2519		       68		      pla
     69  251a		       a8		      tay
     70  251b		       60		      rts
     71  251c
     72  251c
     73  251c							;==========================================================
     74  251c							; Push the current math stack information onto the gosub stack
     75  251c				   iSaveMathStack
     76  251c		       98		      tya
     77  251d		       48		      pha
     78  251e
     79  251e		       a4 4d		      ldy	GOSUBSTACKPTR
     80  2520		       a5 4a		      lda	MATHSTACKPTR
     81  2522		       91 4b		      sta	(GOSUBSTACK),y
     82  2524		       a5 48		      lda	MATHSTACK
     83  2526		       c8		      iny
     84  2527
     85  2527		       91 4b		      sta	(GOSUBSTACK),y
     86  2529		       c8		      iny
     87  252a
     88  252a		       a5 49		      lda	MATHSTACK+1
     89  252c		       91 4b		      sta	(GOSUBSTACK),y
     90  252e		       c8		      iny
     91  252f
     92  252f		       a9 06		      lda	#GOSUB_STACK_SAVE
     93  2531		       91 4b		      sta	(GOSUBSTACK),y
     94  2533		       c8		      iny
     95  2534
     96  2534		       84 4d		      sty	GOSUBSTACKPTR
     97  2536
     98  2536		       68		      pla
     99  2537		       a8		      tay
    100  2538		       4c b1 02 	      jmp	NextIL
    101  253b							;
    102  253b							;==========================================================
    103  253b							;Restore the math stack information from the gosub stack
    104  253b				   iRestoreMathStack
    105  253b		       98		      tya
    106  253c		       48		      pha
    107  253d
    108  253d		       a5 4a		      lda	MATHSTACKPTR
    109  253f		       85 58		      sta	R2	; save the current offset for whatever task to R2
    110  2541
    111  2541		       a4 4d		      ldy	GOSUBSTACKPTR
    112  2543		       88		      dey
    113  2544		       b1 4b		      lda	(GOSUBSTACK),y
    114  2546		       c9 06		      cmp	#GOSUB_STACK_SAVE
    115  2548		       d0 16		      bne	iPopMathStack_Err
    116  254a		       88		      dey
    117  254b		       b1 4b		      lda	(GOSUBSTACK),y
    118  254d		       85 49		      sta	MATHSTACK+1
    119  254f		       88		      dey
    120  2550		       b1 4b		      lda	(GOSUBSTACK),y
    121  2552		       85 48		      sta	MATHSTACK
    122  2554		       88		      dey
    123  2555		       b1 4b		      lda	(GOSUBSTACK),y
    124  2557		       85 4a		      sta	MATHSTACKPTR
    125  2559		       84 4d		      sty	GOSUBSTACKPTR
    126  255b
    127  255b		       68		      pla
    128  255c		       a8		      tay
    129  255d		       4c b1 02 	      jmp	NextIL
    130  2560
    131  2560				   iPopMathStack_Err
    132  2560		       68		      pla
    133  2561		       a8		      tay
    134  2562		       a9 00		      lda	#0
    135  2564		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    136  2566		       4c 7d 06 	      jmp	iErr2
    137  2569							;=========================================
    138  2569							; For functions and tasks the variable address of # means
    139  2569							; a passed parameter so #[0] is the first parameter etc
    140  2569							; will try for a better way later
    141  2569							;=====================================================
    142  2569							; On entry il, branch to if function
    143  2569							;	    il+1, value to be returned or not true or false
    144  2569							;
    145  2569							; Return from GOSUB  or function function
    146  2569							; format   RSTR 0   --- return form gosub
    147  2569							;	    RSTR 1   --- return from Function
    148  2569							;
    149  2569		       20 2b 2a    iRSTR      jsr	getILByte	; get where to go if 0 = gosub/1=function call
    150  256c		       8d 25 43 	      sta	offset
    151  256f		       20 0e 2c 	      jsr	saveIL	; for later jump if needed add extra entry to	the return stack
    152  2572
    153  2572		       20 67 2c 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    154  2575		       85 54		      sta	R1	; keep the type of call returning from
    155  2577		       b0 2b		      bcs	iRSTRErr	; stack underflow error possible
    156  2579
    157  2579		       20 2b 2a 	      jsr	getILByte	; get if a value is being returned
    158  257c
    159  257c		       48		      pha		; save if a value was passed to be returned
    160  257d
    161  257d		       c9 00		      cmp	#0	; yes attemping to return a value
    162  257f		       f0 03		      beq	iRSTRPOP	; no value to return
    163  2581		       20 b6 2c 	      jsr	popR0	; Get the value from the stack save if needed
    164  2584
    165  2584				   iRSTRPOP
    166  2584		       20 05 25 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    167  2587		       a5 54		      lda	R1	; called as a statement ?
    168  2589		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    169  258b		       f0 13		      beq	iRSTRExit
    170  258d
    171  258d		       68		      pla		; get back if value returned or not
    172  258e		       c9 01		      cmp	#1	; we have a value to return
    173  2590		       f0 05		      beq	iRSTRVALUE
    174  2592
    175  2592		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    176  2594		       4c 12 05 	      jmp	iSAVErr2	; jump to general error reporting function
    177  2597
    178  2597				   iRSTRVALUE
    179  2597		       20 24 2c 	      jsr	pushR0	; return value back to top of stack
    180  259a		       20 19 2c 	      jsr	restoreIL	; get the correct il
    181  259d		       4c e0 0b 	      jmp	tstBranch	; And called as a function
    182  25a0
    183  25a0				   iRSTRExit
    184  25a0		       68		      pla		; throw away gosub/func flag
    185  25a1		       4c b1 02 	      jmp	NextIL
    186  25a4
    187  25a4				   iRSTRNORETURNVALUE
    188  25a4
    189  25a4
    190  25a4		       ad b4 36    iRSTRErr   lda	taskPtr	; Check if this is task zero
    191  25a7		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    192  25a9		       a5 56		      lda	MQ
    193  25ab		       d0 03		      bne	taskRet
    194  25ad		       20 f1 2e 	      jsr	pushFalse	; the result code by default is 0
    195  25b0				   taskRet
    196  25b0		       4c 24 28 	      jmp	iETask	; not task zero then do a task end instead
    197  25b3				   taskZeroEnd
    198  25b3		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    199  25b5		       4c 12 05 	      jmp	iSAVErr2
    200  25b8							;
    201  25b8							;==========================================================================================
    202  25b8							; Find the next gosub function parameter info	position on the stack
    203  25b8							; Returns y = index and c set if found clear c otherwise
    204  25b8		       a4 4d	   GosubFindParms ldy	GOSUBSTACKPTR	;Get the Pointer to the top of stack
    205  25ba		       88		      dey		;Point to stack entry type
    206  25bb
    207  25bb							;Veryify the stack size and position for the call
    208  25bb							;Loops here until it finds a GOSUB with value entry or gosub-rtn entry
    209  25bb
    210  25bb		       c0 00	   GosubFindLoop cpy	#0	;If we reach the top of the stack then no parametrs
    211  25bd		       f0 2d		      beq	GosubNotFunc
    212  25bf		       c0 10		      cpy	#GOSUBSTACKSIZE	;Tst if we are outside the stack size
    213  25c1		       b0 29		      bcs	GosubNotFunc	;Not valid
    214  25c3
    215  25c3							;Look for the	 GOSUB_RTN_VALUE stack position
    216  25c3		       b1 4b		      lda	(GOSUBSTACK),y	;Get the type of call - if it is not a fn call error
    217  25c5		       c9 01		      cmp	#GOSUB_RTN	;if we find this then this function had no parameters
    218  25c7		       f0 0f		      beq	GosubParmFnd	;We can pass parameters to a function that returns nothing
    219  25c9
    220  25c9		       c9 81		      cmp	#GOSUB_RTN_VALUE	;Parameters with the gosub call
    221  25cb		       f0 0b		      beq	GosubParmFnd	;Skip any non Gosub related entries
    222  25cd
    223  25cd		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    224  25cf		       f0 13		      beq	GosubParmSkip	;We have a stackframe good
    225  25d1
    226  25d1		       88		      dey
    227  25d2		       88		      dey
    228  25d3		       88		      dey
    229  25d4		       88		      dey
    230  25d5		       4c bb 25 	      jmp	GosubFindLoop
    231  25d8
    232  25d8		       c0 03	   GosubParmFnd cpy	#3	; Check if we are outside the stack
    233  25da		       90 10		      bcc	GosubNotFunc	; if y < 3 then error not found
    234  25dc		       c0 10		      cpy	#GOSUBSTACKSIZE	; Largest value
    235  25de		       b0 0c		      bcs	GosubNotFunc	; no parameters passed
    236  25e0
    237  25e0		       88		      dey		; Point to hopefully Math Stack frame information
    238  25e1		       88		      dey
    239  25e2		       88		      dey
    240  25e3		       88		      dey
    241  25e4				   GosubParmSkip
    242  25e4		       b1 4b		      lda	(GOSUBSTACK),y	;This should be a stack frame pointer
    243  25e6		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    244  25e8		       d0 02		      bne	GosubNotFunc	;No parameters passed but expected
    245  25ea		       38		      sec
    246  25eb		       60		      rts
    247  25ec
    248  25ec		       18	   GosubNotFunc clc
    249  25ed		       60		      rts
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  25ee					      include	"tasks.asm"
      1  25ee							;=====================================================
      2  25ee							; Tiny Basic IL task management
      3  25ee							; Data required by task management
      4  25ee							; currently each context is about 30 bytes and is swapped
      5  25ee							; into and out of page zero on each task switch....
      6  25ee							; LOL yes it is slow, but works for this iteration.
      7  25ee							;
      8  25ee
      9  25ee					      Seg	Code
     10  25ee							;=====================================================
     11  25ee							; Sets the pointers to the math,IL and gosub stacks
     12  25ee							; Creates the initial Context for each task slot
     13  25ee				   taskSetStacks
     14  25ee		       a9 b4		      lda	#mathStack&$FF
     15  25f0		       85 48		      sta	MATHSTACK
     16  25f2		       a9 37		      lda	#mathStack>>8
     17  25f4		       85 49		      sta	MATHSTACK+1
     18  25f6
     19  25f6		       a9 44		      lda	#ilStack&$ff
     20  25f8		       85 45		      sta	ILSTACK
     21  25fa		       a9 39		      lda	#ilStack>>8
     22  25fc		       85 46		      sta	ILSTACK+1
     23  25fe
     24  25fe		       a9 2c		      lda	#gosubStack&$FF
     25  2600		       85 4b		      sta	GOSUBSTACK
     26  2602		       a9 3d		      lda	#gosubStack>>8
     27  2604		       85 4c		      sta	GOSUBSTACK+1
     28  2606
     29  2606		       a9 ac		      lda	#variableStack&$FF
     30  2608		       85 41		      sta	VARIABLES
     31  260a		       a9 3f		      lda	#variableStack>>8
     32  260c		       85 42		      sta	VARIABLES+1
     33  260e		       a2 0a		      ldx	#TASKCOUNT
     34  2610		       a0 00		      ldy	#0
     35  2612		       20 e2 28 	      jsr	ContextSave	; Save the Task 0 context
     36  2615
     37  2615		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  2617		       b0 3a		      bcs	taskSetDone
     39  2619
     40  2619		       a5 4b		      lda	GOSUBSTACK
     41  261b		       18		      clc
     42  261c		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  261e		       85 4b		      sta	GOSUBSTACK
     44  2620		       a5 4c		      lda	GOSUBSTACK+1
     45  2622		       69 00		      adc	#0
     46  2624		       85 4c		      sta	GOSUBSTACK+1
     47  2626
     48  2626		       a5 45		      lda	ILSTACK	; must be less than 256
     49  2628		       18		      clc
     50  2629		       69 64		      adc	#ILSTACKSIZE*2
     51  262b		       85 45		      sta	ILSTACK
     52  262d		       a5 46		      lda	ILSTACK+1
     53  262f		       69 00		      adc	#0
     54  2631		       85 46		      sta	ILSTACK+1
     55  2633
     56  2633		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  2635		       18		      clc
     58  2636		       69 28		      adc	#MATHSTACKSIZE*2
     59  2638		       85 48		      sta	MATHSTACK
     60  263a		       a5 49		      lda	MATHSTACK+1
     61  263c		       69 00		      adc	#0
     62  263e		       85 49		      sta	MATHSTACK+1
     63  2640
     64  2640		       a5 41		      lda	VARIABLES	; must be less than 256
     65  2642		       18		      clc
     66  2643		       69 4a		      adc	#VARIABLESSIZE*2
     67  2645		       85 41		      sta	VARIABLES
     68  2647		       a5 42		      lda	VARIABLES+1
     69  2649		       69 00		      adc	#0
     70  264b		       85 42		      sta	VARIABLES+1
     71  264d		       20 e2 28 	      jsr	ContextSave
     72  2650		       4c 15 26 	      jmp	taskSetLoop
     73  2653
     74  2653				   taskSetDone
     75  2653		       a0 00		      ldy	#0	; reload the main loop context
     76  2655		       20 f1 28 	      jsr	ContextLoad
     77  2658		       60		      rts
     78  2659							;
     79  2659							;============================================================
     80  2659							; Saves the io block to the context
     81  2659
     82  2659
     83  2659		       98	   SaveIOblock tya
     84  265a		       48		      pha
     85  265b		       8a		      txa
     86  265c		       48		      pha
     87  265d
     88  265d
     89  265d
     90  265d		       68		      pla
     91  265e		       aa		      tax
     92  265f		       68		      pla
     93  2660		       a8		      tay
     94  2661		       60		      rts
     95  2662
     96  2662							;
     97  2662							;=====================================================
     98  2662							; In some error cases the math stacks may be left pointing to the wrong stack
     99  2662							; This function will reset those stack addresses but not the actual pointer
    100  2662				   taskResetStacks
    101  2662		       a0 00		      ldy	#0
    102  2664		       20 f1 28 	      jsr	ContextLoad
    103  2667		       4c ee 25 	      jmp	taskSetStacks
    104  266a							;
    105  266a							;=====================================================
    106  266a							; Clear all task entries and task stacks
    107  266a		       98	   taskReset  tya		; Save Y
    108  266b		       48		      pha
    109  266c		       a9 01		      lda	#1
    110  266e		       8d b3 37 	      sta	taskCounter	; Set number of active tasks to 1
    111  2671		       ac b4 36 	      ldy	taskPtr	; Set the active task to 0 MAIN
    112  2674		       c0 00		      cpy	#0	; check if we are the main context
    113  2676		       f0 08		      beq	taskResetCont	; if we are just continue
    114  2678
    115  2678		       a0 00		      ldy	#0	; else we need to switch to the main context
    116  267a		       8c b4 36 	      sty	taskPtr
    117  267d		       20 f1 28 	      jsr	ContextLoad	; load the System Task context
    118  2680				   taskResetCont
    119  2680		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    120  2682
    121  2682				   taskResetLoop
    122  2682		       a9 00		      lda	#TASKINACTIVE
    123  2684		       99 b5 36 	      sta	taskTable,y	; Ensure that the task is made inactive
    124  2687		       18		      clc
    125  2688		       98		      tya
    126  2689		       69 19		      adc	#CONTEXTLEN
    127  268b		       a8		      tay
    128  268c		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    129  268e		       90 f2		      bcc	taskResetLoop	; Go for more
    130  2690
    131  2690				   taskResetComplete
    132  2690
    133  2690		       68		      pla		; Restore y
    134  2691		       a8		      tay
    135  2692		       60		      rts
    136  2693
    137  2693							;
    138  2693							;======================================================
    139  2693							; iTaskSwitch	 switch to new task if not interrupt and
    140  2693							;		 count is exceded for task time slice gets here
    141  2693							;		 when time slice has reached zero
    142  2693							;
    143  2693		       98	   iTaskSwitch tya
    144  2694		       48		      pha
    145  2695
    146  2695		       ad b1 37 	      lda	taskResetValue	; Always reset the counter value
    147  2698		       8d af 37 	      sta	taskCurrentCycles	; Update the counter with the new value
    148  269b		       ce b0 37 	      dec	taskCurrentCycles+1	; dec high order byte
    149  269e		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    150  26a0
    151  26a0		       ad b2 37 	      lda	taskResetValue+1
    152  26a3		       8d b0 37 	      sta	taskCurrentCycles+1
    153  26a6
    154  26a6		       ad b8 19 	      lda	IRQPending	; Skip this if we are processing an irq
    155  26a9		       0d 27 43 	      ora	taskIOPending	; If set then don't switch
    156  26ac		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    157  26ae
    158  26ae		       ad b3 37    iTaskMain  lda	taskCounter	; Number of tasks
    159  26b1		       c9 01		      cmp	#1	; if there is only one task must be main
    160  26b3		       d0 07		      bne	itasknext	; if it some other number continue to next
    161  26b5
    162  26b5		       ac b4 36 	      ldy	taskPtr	; check if we have not just ended some other task
    163  26b8		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    164  26ba		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    165  26bc							;
    166  26bc							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    167  26bc							;
    168  26bc				   itasknext
    169  26bc		       ac b4 36 	      ldy	taskPtr
    170  26bf		       20 e2 28 	      jsr	ContextSave	; Save the current context, y points to next context
    171  26c2				   itaskLoop
    172  26c2		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    173  26c4		       90 04		      bcc	iTaskNextChk
    174  26c6
    175  26c6		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    176  26c8		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    177  26ca
    178  26ca				   iTaskNextChk
    179  26ca		       b9 b5 36 	      lda	taskTable,y	; there is always at least one entry in table
    180  26cd		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    181  26cf		       18	   iTaskNext  clc
    182  26d0		       98		      tya
    183  26d1		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    184  26d3		       a8		      tay
    185  26d4		       4c c2 26 	      jmp	itaskLoop	; Check for busy entry
    186  26d7
    187  26d7		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    188  26d9		       59 b5 36 	      eor	taskTable,y	; Check for anything waiting io
    189  26dc		       d0 f1		      bne	iTaskNext
    190  26de		       20 f1 28 	      jsr	ContextLoad	; load the next context
    191  26e1		       8c b4 36 	      sty	taskPtr	; update the task pointer
    192  26e4
    193  26e4				   iTaskSwitchDone
    194  26e4		       68		      pla
    195  26e5		       a8		      tay
    196  26e6		       60		      rts
    197  26e7							;
    198  26e7							;================================================================
    199  26e7							; Task Set task number to line number to start
    200  26e7							; on entry stack contains, type of line description and  memvector or linenumber
    201  26e7							; Task Table structure:
    202  26e7							;    byte 0	-   Active inactive
    203  26e7							;    byte 1-2	-   Basic code line pointer
    204  26e7							;    byte 3	-   Offset on current line
    205  26e7		       98	   iTaskSet   tya		;preserve Y
    206  26e8		       48		      pha		; push a
    207  26e9		       20 ce 2c 	      jsr	popR1	; Get if compiled or line number expression
    208  26ec		       20 b6 2c 	      jsr	popR0	; Get the line number to be saved
    209  26ef
    210  26ef
    211  26ef
    212  26ef		       ac b4 36 	      ldy	taskPtr	; find out where we are
    213  26f2		       20 e2 28 	      jsr	ContextSave	; Save the current context
    214  26f5
    215  26f5							;Find the pointer to the line we need to start at
    216  26f5		       a5 54		      lda	R1
    217  26f7		       f0 0b		      beq	iTaskLineNum
    218  26f9		       a5 52		      lda	R0
    219  26fb		       85 4f		      sta	CURPTR
    220  26fd		       a5 53		      lda	R0+1
    221  26ff		       85 50		      sta	CURPTR+1
    222  2701		       4c 14 27 	      jmp	iTaskCont
    223  2704
    224  2704				   iTaskLineNum
    225  2704		       20 70 2a 	      jsr	findLine	; Get the offset of the line to start task at
    226  2707		       f0 0b		      beq	iTaskCont
    227  2709
    228  2709		       ac b4 36 	      ldy	taskPtr	; Restore the original Context Error Exit
    229  270c		       20 f1 28 	      jsr	ContextLoad
    230  270f
    231  270f		       68		      pla		; pop a - exit
    232  2710		       a8		      tay
    233  2711		       4c f3 0d 	      jmp	iSetIrqErr	; Bad line number provided
    234  2714
    235  2714				   iTaskCont
    236  2714		       20 b4 28 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    237  2717		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    238  2719
    239  2719		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    240  271b		       99 b5 36 	      sta	taskTable,y	; new task as active
    241  271e
    242  271e		       a5 4f		      lda	CURPTR
    243  2720		       48		      pha		; push a
    244  2721		       a5 50		      lda	CURPTR+1
    245  2723		       48		      pha		; push a
    246  2724
    247  2724		       20 f1 28 	      jsr	ContextLoad	; load the context of the new task
    248  2727
    249  2727		       68		      pla		; pop a
    250  2728		       85 50		      sta	CURPTR+1
    251  272a		       68		      pla		; pop a
    252  272b		       85 4f		      sta	CURPTR
    253  272d		       a9 03		      lda	#3	; Offset to first instruction
    254  272f		       85 51		      sta	CUROFF
    255  2731
    256  2731		       a9 00		      lda	#0
    257  2733		       85 47		      sta	ILSTACKPTR
    258  2735		       85 4a		      sta	MATHSTACKPTR
    259  2737		       85 4d		      sta	GOSUBSTACKPTR
    260  2739		       a9 40		      lda	#GOSUBSTACKSIZE*4
    261  273b		       85 4e		      sta	MESSAGEPTR
    262  273d
    263  273d		       20 75 09 	      jsr	subVINIT	; Clear the variables
    264  2740
    265  2740		       a9 01		      lda	#STMT&$FF
    266  2742		       85 43		      sta	ILPC
    267  2744		       a9 32		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    268  2746		       85 44		      sta	ILPC+1
    269  2748
    270  2748		       98		      tya		; Save the new context offset to return to user
    271  2749		       48		      pha		; push a
    272  274a
    273  274a		       20 e2 28    itaskSetSave jsr	ContextSave	; save the updated context
    274  274d		       ee b3 37 	      inc	taskCounter	; Update the number of Tasks running
    275  2750
    276  2750		       ac b4 36 	      ldy	taskPtr
    277  2753		       20 f1 28 	      jsr	ContextLoad	; restore the original context
    278  2756
    279  2756		       a9 00		      lda	#0	; Set the R0 upper to zero
    280  2758		       85 53		      sta	R0+1
    281  275a		       68		      pla		; Get the task pid we stored				 ; pop a
    282  275b		       85 52		      sta	R0	; Get the table entry value
    283  275d
    284  275d		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    285  275e		       a8		      tay
    286  275f
    287  275f		       4c 1d 07 	      jmp	pushR0nextIl	; Push R0 and continue
    288  2762				   iTaskNoEmpty
    289  2762		       ac b4 36 	      ldy	taskPtr
    290  2765		       20 f1 28 	      jsr	ContextLoad
    291  2768
    292  2768		       68		      pla		; pop a    -- exit
    293  2769		       a8		      tay
    294  276a
    295  276a		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    296  276c		       a9 00		      lda	#0
    297  276e		       4c 7d 06 	      jmp	iErr2
    298  2771							;
    299  2771							;===============================================================
    300  2771							; Run the task whos PID is on the stack, preserve the stack
    301  2771							;
    302  2771				   iTaskEnable
    303  2771		       98		      tya
    304  2772		       48		      pha
    305  2773		       20 ce 2c 	      jsr	popR1
    306  2776		       20 9c 2c 	      jsr	pushR1
    307  2779		       20 e8 29 	      jsr	ipc_getcontext	; get context pointer into mq
    308  277c		       a0 00		      ldy	#0
    309  277e		       b1 56		      lda	(MQ),y
    310  2780		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    311  2782		       09 80		      ora	#TASKACTIVE
    312  2784		       91 56		      sta	(MQ),y
    313  2786		       68		      pla
    314  2787		       a8		      tay
    315  2788		       4c b1 02 	      jmp	NextIL
    316  278b
    317  278b							;
    318  278b							;===============================================================
    319  278b							; Suspend the task whos PID  is on the stack, preserve the stack
    320  278b							;
    321  278b				   iTaskSuspend
    322  278b		       98		      tya
    323  278c		       48		      pha
    324  278d		       20 ce 2c 	      jsr	popR1
    325  2790		       20 9c 2c 	      jsr	pushR1
    326  2793		       20 e8 29 	      jsr	ipc_getcontext	; get context pointer into mq
    327  2796		       a0 00		      ldy	#0
    328  2798		       b1 56		      lda	(MQ),y
    329  279a		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    330  279c		       09 80		      ora	#TASKACTIVE
    331  279e		       68		      pla
    332  279f		       a8		      tay
    333  27a0		       4c b1 02 	      jmp	NextIL
    334  27a3
    335  27a3							;================================================================
    336  27a3							; Returns task Status
    337  27a3				   iTaskStat
    338  27a3		       98		      tya
    339  27a4		       48		      pha
    340  27a5		       20 b7 27 	      jsr	iTaskValid	; returns pointer to task entry
    341  27a8		       b9 b5 36 	      lda	taskTable,y
    342  27ab		       f0 05		      beq	iTaskStatExit
    343  27ad		       68		      pla
    344  27ae		       a8		      tay
    345  27af		       4c 83 0d 	      jmp	iTruth
    346  27b2				   iTaskStatExit
    347  27b2		       68		      pla
    348  27b3		       a8		      tay
    349  27b4		       4c 8c 0d 	      jmp	iFalse
    350  27b7
    351  27b7							;
    352  27b7							;================================================================
    353  27b7							; Validate the task number on top of the stack
    354  27b7							; on exit y points to the requested task entry
    355  27b7							;
    356  27b7		       20 b6 2c    iTaskValid jsr	popR0	; get result of the multiply
    357  27ba		       a5 53		      lda	R0+1
    358  27bc		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    359  27be		       a5 52		      lda	R0
    360  27c0		       c9 fa		      cmp	#TASKTABLELEN
    361  27c2		       90 09		      bcc	iTaskIsValid
    362  27c4
    363  27c4		       68	   iTaskValidErr pla		;remove return address
    364  27c5		       68		      pla
    365  27c6		       a2 10		      ldx	#ERR_INVALID_PID
    366  27c8		       a9 00		      lda	#0
    367  27ca		       4c 7d 06 	      jmp	iErr2
    368  27cd
    369  27cd		       a8	   iTaskIsValid tay
    370  27ce		       60		      rts
    371  27cf							;
    372  27cf							;================================================================
    373  27cf							; Kill a running task, do nothing if already stopped
    374  27cf		       20 b7 27    iTaskKill  jsr	iTaskValid
    375  27d2		       a9 00		      lda	#0
    376  27d4		       99 b5 36 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    377  27d7							;
    378  27d7							;================================================================
    379  27d7							;Skip to next task
    380  27d7				   iNTask
    381  27d7		       a9 01		      lda	#1
    382  27d9		       8d af 37 	      sta	taskCurrentCycles
    383  27dc		       8d b0 37 	      sta	taskCurrentCycles+1
    384  27df		       4c b1 02 	      jmp	NextIL
    385  27e2							;
    386  27e2							;=======================================================
    387  27e2							; Wait for a task to complete
    388  27e2				   iWTASK
    389  27e2		       20 2b 2a 	      jsr	getILByte
    390  27e5		       8d 25 43 	      sta	offset
    391  27e8							;
    392  27e8		       20 0e 2c 	      jsr	saveIL	;in case of failure
    393  27eb
    394  27eb		       20 b7 27 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    395  27ee		       b9 b5 36 	      lda	taskTable,y
    396  27f1		       d0 03		      bne	iWTASKWAIT
    397  27f3				   iWTASKEXITED
    398  27f3		       4c b1 02 	      jmp	NextIL
    399  27f6				   iWTASKWAIT
    400  27f6		       20 24 2c 	      jsr	pushR0	; Push R0 back onto the stack
    401  27f9		       a9 01		      lda	#1
    402  27fb		       8d af 37 	      sta	taskCurrentCycles	; Give up the cycles
    403  27fe		       8d b0 37 	      sta	taskCurrentCycles+1
    404  2801		       20 19 2c 	      jsr	restoreIL
    405  2804		       4c e0 0b 	      jmp	tstBranch
    406  2807							;
    407  2807							;=======================================================
    408  2807							; Set task io lock
    409  2807		       ee 27 43    iStartIO   inc	taskIOPending
    410  280a		       4c b1 02 	      jmp	NextIL
    411  280d							;
    412  280d							;=======================================================
    413  280d							; Release the io lock
    414  280d		       ad 27 43    iEndIO     lda	taskIOPending
    415  2810		       f0 03		      beq	iEndIOExit
    416  2812		       ce 27 43 	      dec	taskIOPending
    417  2815		       4c b1 02    iEndIOExit jmp	NextIL
    418  2818							;
    419  2818							;===============================================================
    420  2818							; Return the task PID
    421  2818				   iTASKPID
    422  2818		       a9 00		      lda	#0
    423  281a		       85 53		      sta	R0+1
    424  281c		       ad b4 36 	      lda	taskPtr
    425  281f		       85 52		      sta	R0
    426  2821		       4c 1d 07 	      jmp	pushR0nextIl
    427  2824							;
    428  2824							;================================================================
    429  2824							; Terminate a task
    430  2824		       ac b4 36    iETask     ldy	taskPtr
    431  2827		       c0 00		      cpy	#0
    432  2829		       d0 03		      bne	iETaskCont
    433  282b		       4c 02 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    434  282e				   iETaskCont
    435  282e		       a9 00		      lda	#TASKINACTIVE
    436  2830		       99 b5 36 	      sta	taskTable,y	; mark entry as free
    437  2833		       ce b3 37 	      dec	taskCounter	; reduce the number of active tasks
    438  2836		       a9 01		      lda	#1
    439  2838		       8d af 37 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    440  283b		       8d b0 37 	      sta	taskCurrentCycles+1
    441  283e		       20 cf 28 	      jsr	TaskSetExitCode
    442  2841				   iETaskExit
    443  2841		       4c b1 02 	      jmp	NextIL
    444  2844							;================================================================
    445  2844							; make the current tasks math stack equal another tasks stack
    446  2844							; The task to get is stored on the math stack
    447  2844
    448  2844				   iTaskGetMathStack
    449  2844		       20 f5 2e 	      jsr	CopyStackR1	; Get the top of stack to R1
    450  2847		       20 e8 29 	      jsr	ipc_getcontext	; MQ now has the context address
    451  284a		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  284c		       b1 56		      lda	(MQ),y
    453  284e		       85 4a		      sta	MATHSTACKPTR
    454  2850		       a0 08		      ldy	#MATHSTACKPOS
    455  2852		       b1 56		      lda	(MQ),y
    456  2854		       85 48		      sta	MATHSTACK
    457  2856		       c8		      iny
    458  2857		       b1 56		      lda	(MQ),y
    459  2859		       85 49		      sta	MATHSTACK+1
    460  285b		       4c b1 02 	      jmp	NextIL
    461  285e							;==================================================================
    462  285e							; Updates the tasks math stack pointer with contents of R2
    463  285e							; PID is on top of the stack
    464  285e				   iTaskPutMathPtr
    465  285e		       20 f5 2e 	      jsr	CopyStackR1	; Get the top of stack to R1
    466  2861		       20 e8 29 	      jsr	ipc_getcontext	; MQ now has the context address
    467  2864		       a5 58		      lda	R2	; R2 contains the number of parameters/offset
    468  2866		       a0 0a		      ldy	#MATHSTACKPTRPOS	; Pointer to new tasks stack pointer
    469  2868		       91 56		      sta	(MQ),y	; update it to point to the free space on stack
    470  286a							;if parm count > 0 then we need to create a parameter block on the tasks gosubStack
    471  286a		       c9 00		      cmp	#0	; if no parameters then
    472  286c		       f0 26		      beq	iTaskPutMathPtrExit	; just get out of here
    473  286e
    474  286e		       a0 0b		      ldy	#GOSUBSTKPOS
    475  2870		       b1 56		      lda	(MQ),y	; get the address of the new tasks gosub stack into R1
    476  2872		       85 54		      sta	R1
    477  2874		       c8		      iny
    478  2875		       b1 56		      lda	(MQ),y
    479  2877		       85 55		      sta	R1+1
    480  2879
    481  2879		       a9 00		      lda	#0	; Store the math stack offset into new gosub stack, always 0
    482  287b		       91 54		      sta	(R1),y
    483  287d
    484  287d		       c8		      iny
    485  287e		       18		      clc		; We need to turn stack ptr to actual parm count
    486  287f		       e9 01		      sbc	#1	; Stack pointer always point to next free byte
    487  2881		       0a		      asl
    488  2882		       91 54		      sta	(R1),y
    489  2884
    490  2884		       c8		      iny
    491  2885		       a9 ff		      lda	#$FF	; Dummy field, not used
    492  2887		       91 54		      sta	(R1),y
    493  2889		       c8		      iny
    494  288a		       a9 05		      lda	#GOSUB_STACK_FRAME	; Tell its a stck frame, ie identify param cnt etc
    495  288c		       91 54		      sta	(R1),y
    496  288e		       c8		      iny
    497  288f		       98		      tya
    498  2890		       a0 0d		      ldy	#GOSUBPTRPOS
    499  2892		       91 56		      sta	(MQ),y	; update the new tasks gosub stk pointer
    500  2894
    501  2894				   iTaskPutMathPtrExit
    502  2894		       4c b1 02 	      jmp	NextIL
    503  2897							;
    504  2897							;================================================================
    505  2897							; Set the time slice for each task
    506  2897				   iSLICE
    507  2897		       20 b6 2c 	      jsr	popR0
    508  289a		       a5 52		      lda	R0
    509  289c		       8d b1 37 	      sta	taskResetValue
    510  289f		       a5 53		      lda	R0+1
    511  28a1		       8d b2 37 	      sta	taskResetValue+1
    512  28a4		       d0 0b		      bne	iSliceSet
    513  28a6		       ee b2 37 	      inc	taskResetValue+1	; must be at least 1 high counter
    514  28a9		       a9 01		      lda	#1
    515  28ab		       8d af 37 	      sta	taskCurrentCycles
    516  28ae		       8d b0 37 	      sta	taskCurrentCycles+1
    517  28b1				   iSliceSet
    518  28b1		       4c b1 02 	      jmp	NextIL
    519  28b4							;================================================================
    520  28b4							; Find an empty slot in the taskTable
    521  28b4							; Return the index in y
    522  28b4							; on exit   c set if an empty slot is found
    523  28b4							;	     c clear if not found
    524  28b4							;================================================================
    525  28b4							;
    526  28b4		       ad b3 37    TaskEmpty  lda	taskCounter
    527  28b7		       c9 0a		      cmp	#TASKCOUNT
    528  28b9		       b0 10		      bcs	TaskNoSlot
    529  28bb		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    530  28bd				   TaskLoop
    531  28bd		       b9 b5 36 	      lda	taskTable,y
    532  28c0		       f0 0b		      beq	TaskEmptyFnd
    533  28c2		       98		      tya
    534  28c3		       18		      clc
    535  28c4		       69 19		      adc	#CONTEXTLEN
    536  28c6		       a8		      tay
    537  28c7		       c0 fa		      cpy	#TASKTABLELEN
    538  28c9		       90 f2		      bcc	TaskLoop	; Y is never zero
    539  28cb				   TaskNoSlot
    540  28cb		       18		      clc
    541  28cc		       60		      rts
    542  28cd				   TaskEmptyFnd
    543  28cd		       38		      sec
    544  28ce		       60		      rts
    545  28cf							;====================================================
    546  28cf							; Set the task exit code called from the return command
    547  28cf							; on entry stack top hold exit value
    548  28cf				   TaskSetExitCode
    549  28cf		       98		      tya
    550  28d0		       48		      pha
    551  28d1		       20 b6 2c 	      jsr	popR0
    552  28d4		       a0 48		      ldy	#TASKEXITCODE
    553  28d6		       a5 52		      lda	R0
    554  28d8		       91 41		      sta	(VARIABLES),y
    555  28da		       c8		      iny
    556  28db		       a5 53		      lda	R0+1
    557  28dd		       91 41		      sta	(VARIABLES),y
    558  28df		       68		      pla
    559  28e0		       98		      tya
    560  28e1		       60		      rts
    561  28e2
    562  28e2							;
    563  28e2							;=====================================================
    564  28e2							; Save Context Store the context to the TASK Table
    565  28e2							; on entry y contains the task table entry to save to
    566  28e2							; on exit y points to next task table entry
    567  28e2							;	   x contains the number of bytes copied
    568  28e2		       a2 00	   ContextSave ldx	#0
    569  28e4		       c8		      iny		;inc past the task flags
    570  28e5		       b5 41	   ContextSvLoop lda	CONTEXT,x
    571  28e7		       99 b5 36 	      sta	taskTable,y
    572  28ea		       c8		      iny
    573  28eb		       e8		      inx
    574  28ec		       e0 18		      cpx	#[CONTEXTLEN-1]
    575  28ee		       90 f5		      bcc	ContextSvLoop
    576  28f0		       60		      rts
    577  28f1							;
    578  28f1							; Load Context transfer context from task table to the Current Context
    579  28f1							; on entry y contains the task table entry to transfer
    580  28f1							; on exit y points to the original task table entry
    581  28f1							;	   x contains the number of bytes copied
    582  28f1		       98	   ContextLoad tya
    583  28f2		       48		      pha
    584  28f3		       a2 00		      ldx	#0
    585  28f5		       c8		      iny		;inc past the task flags
    586  28f6		       b9 b5 36    ContextLDLoop lda	taskTable,y
    587  28f9		       95 41		      sta	CONTEXT,x
    588  28fb		       c8		      iny
    589  28fc		       e8		      inx
    590  28fd		       e0 18		      cpx	#[CONTEXTLEN-1]
    591  28ff		       90 f5		      bcc	ContextLDLoop
    592  2901		       68		      pla
    593  2902		       a8		      tay
    594  2903		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  2904					      include	"ipc.asm"
      1  2904							;======================================================
      2  2904							; Inter process communications.
      3  2904							; Tasks may write/read integer messages among
      4  2904							; them selves.
      5  2904							; This uses each tasks gosub stack as a message queue
      6  2904							; Gosub calls start at the highest address and the
      7  2904							; msg queue starts at the highest address.
      8  2904							;
      9  2904							;======================================================
     10  2904							; ipcs   - Send msg to another task or many tasks
     11  2904							; on entry  math stack contains the  top PID
     12  2904							;				      2ND Message value
     13  2904							; on exit   math stack contain top True-good or False-failed
     14  2904							;
     15  2904							; it may not be sent if queue is full
     16  2904							;
     17  2904							; a = ipcs(<message-expression>,<task PID-expression>)
     18  2904							;
     19  2904				   iIPCS
     20  2904		       98		      tya
     21  2905		       48		      pha
     22  2906		       20 6d 29 	      jsr	ipc_enqueue
     23  2909		       b0 08		      bcs	iIPC_BAD
     24  290b		       20 e7 2e 	      jsr	pushTrue
     25  290e		       68		      pla
     26  290f		       a8		      tay
     27  2910		       4c b1 02 	      jmp	NextIL
     28  2913				   iIPC_BAD
     29  2913		       68		      pla
     30  2914		       a8		      tay
     31  2915		       20 f1 2e 	      jsr	pushFalse
     32  2918		       4c b1 02 	      jmp	NextIL
     33  291b
     34  291b							;======================================================
     35  291b							; ipcr   - Recieve msg from task
     36  291b							; on exit  the message value is returned from message queue
     37  291b							;	    message -1	is reserved meaning no entry found
     38  291b							; The provided variable contains the pid of the sending
     39  291b							; task. This is optional. This always waits for a message
     40  291b							; before returning.
     41  291b							;
     42  291b							; a = ipcr(<variable name>)
     43  291b							;
     44  291b				   iIPCR
     45  291b		       98		      tya
     46  291c		       48		      pha
     47  291d		       20 af 29 	      jsr	ipc_dequeue
     48  2920		       b0 05		      bcs	iIPCR_Q_Empty
     49  2922		       68		      pla
     50  2923		       a8		      tay
     51  2924		       4c b1 02 	      jmp	NextIL
     52  2927				   iIPCR_Q_Empty
     53  2927		       68		      pla
     54  2928		       a8		      tay
     55  2929		       20 e7 2e 	      jsr	pushTrue	; puts -1 on the stack
     56  292c		       4c b1 02 	      jmp	NextIL
     57  292f
     58  292f							;=======================================================
     59  292f							; ipcc   - Check if message available
     60  292f							; on exit  Stack contains number of messages
     61  292f							;
     62  292f							; a = ipcc()
     63  292f							;
     64  292f				   iIPCC
     65  292f		       98		      tya
     66  2930		       48		      pha
     67  2931		       20 5a 29 	      jsr	ipc_queue_count
     68  2934		       20 24 2c 	      jsr	pushR0	; return the count
     69  2937		       68		      pla
     70  2938		       a8		      tay
     71  2939		       4c b1 02 	      jmp	NextIL
     72  293c
     73  293c							;=======================================================
     74  293c							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  293c				   iIPCIO
     76  293c		       98		      tya
     77  293d		       48		      pha
     78  293e		       20 5a 29 	      jsr	ipc_queue_count
     79  2941		       a5 52		      lda	R0
     80  2943		       d0 10		      bne	iIPCIO_No_Halt
     81  2945		       a9 01		      lda	#1
     82  2947		       8d af 37 	      sta	taskCurrentCycles	; force a task switch
     83  294a		       a9 01		      lda	#TASKWAITIPC
     84  294c		       ac b4 36 	      ldy	taskPtr
     85  294f		       19 b5 36 	      ora	taskTable,y
     86  2952		       99 b5 36 	      sta	taskTable,y
     87  2955
     88  2955				   iIPCIO_No_Halt
     89  2955		       68		      pla
     90  2956		       a8		      tay
     91  2957		       4c b1 02 	      jmp	NextIL
     92  295a							;======================================================
     93  295a							;ipc_queue_count
     94  295a				   ipc_queue_count
     95  295a		       a5 4e		      lda	MESSAGEPTR
     96  295c		       18		      clc
     97  295d		       4a		      lsr		; divide by 4
     98  295e		       4a		      lsr
     99  295f		       85 52		      sta	R0	; store into R0
    100  2961		       a9 10		      lda	#GOSUBSTACKSIZE
    101  2963		       38		      sec
    102  2964		       e5 52		      sbc	R0	; Get how many entries on queue
    103  2966		       85 52		      sta	R0
    104  2968		       a9 00		      lda	#0
    105  296a		       85 53		      sta	R0+1
    106  296c		       60		      rts
    107  296d							;=======================================================
    108  296d							; Support functions for messaging
    109  296d							;
    110  296d							; Enqueue message -> onto PID's MSG Q
    111  296d							; on entry top of stack contains the PID
    112  296d							;	    second contains the Message of the task
    113  296d							; on exit contains c set if failed
    114  296d							;		    c cleared if success
    115  296d							;		    PID's MSG Q PTR points to the message
    116  296d							;
    117  296d				   ipc_enqueue
    118  296d		       20 ce 2c 	      jsr	popR1	; Get the pid
    119  2970		       20 e8 29 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  2973
    121  2973		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  2975		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  2977		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  2979		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  297b		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  297d
    127  297d
    128  297d							; Get the PID'S stack address into R0
    129  297d		       a0 0b		      ldy	#GOSUBSTKPOS
    130  297f		       b1 56		      lda	(MQ),y
    131  2981		       85 52		      sta	R0
    132  2983		       c8		      iny
    133  2984		       b1 56		      lda	(MQ),y
    134  2986		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  2988
    136  2988							; Set y to point to the msg q entry
    137  2988		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  298a		       b1 56		      lda	(MQ),y	; Get the index
    139  298c		       a8		      tay		; Set y to queue offset
    140  298d
    141  298d							; enqueue the message
    142  298d		       88		      dey		; First byte to save to
    143  298e		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  2990		       91 52		      sta	(R0),y	; Set the entry type
    145  2992
    146  2992		       88		      dey
    147  2993		       ad b4 36 	      lda	taskPtr	; Store the PID into queue
    148  2996		       91 52		      sta	(R0),y
    149  2998		       20 ce 2c 	      jsr	popR1	; Get the actual message value
    150  299b		       20 1c 2a 	      jsr	ipc_pushR1	; Store Message value into queue
    151  299e
    152  299e		       98		      tya		; Save the new q ptr
    153  299f		       a0 0e		      ldy	#MSGPTRPOS
    154  29a1		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  29a3		       a0 00		      ldy	#0	; points to context root
    156  29a5		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  29a7		       51 56		      eor	(MQ),y	; Turn off the bit
    158  29a9		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  29ab		       18		      clc
    160  29ac		       60		      rts
    161  29ad				   ipc_enq_full
    162  29ad		       38		      sec
    163  29ae		       60		      rts
    164  29af							;=============================================================
    165  29af							; De-queue for message stack -> local tasks msg q
    166  29af							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  29af							;  message into
    168  29af							;  on exit   math stack contains value of message
    169  29af							;				  Variable if provided is pid
    170  29af				   ipc_dequeue
    171  29af		       20 e5 2c 	      jsr	popMQ	; Variable address to put PID into
    172  29b2
    173  29b2		       a4 4e		      ldy	MESSAGEPTR
    174  29b4		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    175  29b6		       b0 2e		      bcs	ipc_deq_empty
    176  29b8		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  29ba		       85 52		      sta	R0
    178  29bc		       c8		      iny
    179  29bd		       b1 4b		      lda	(GOSUBSTACK),y
    180  29bf		       85 53		      sta	R0+1
    181  29c1		       c8		      iny
    182  29c2		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  29c4		       85 54		      sta	R1
    184  29c6		       c8		      iny
    185  29c7		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  29c9		       c8		      iny
    187  29ca		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  29cc
    189  29cc		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  29ce		       d0 16		      bne	ipc_deq_empty
    191  29d0
    192  29d0		       20 24 2c 	      jsr	pushR0	; place value on stack
    193  29d3
    194  29d3		       a5 56		      lda	MQ
    195  29d5		       05 57		      ora	MQ+1
    196  29d7		       f0 0b		      beq	ipc_deq_done
    197  29d9		       a5 54		      lda	R1
    198  29db		       a0 00		      ldy	#0
    199  29dd		       91 56		      sta	(MQ),y
    200  29df		       c8		      iny
    201  29e0		       a9 00		      lda	#0
    202  29e2		       91 56		      sta	(MQ),y
    203  29e4				   ipc_deq_done
    204  29e4		       18		      clc
    205  29e5		       60		      rts
    206  29e6
    207  29e6				   ipc_deq_empty
    208  29e6		       38		      sec
    209  29e7		       60		      rts
    210  29e8
    211  29e8							;=============================================
    212  29e8							;  Get the context address into MQ from R1 with
    213  29e8							;  context/index/pid
    214  29e8				   ipc_getcontext
    215  29e8		       18		      clc		; Get pointer to Task context
    216  29e9		       a9 b5		      lda	#taskTable&$FF	; change ptr to address
    217  29eb		       65 54		      adc	R1
    218  29ed		       85 56		      sta	MQ
    219  29ef		       a9 36		      lda	#taskTable>>8
    220  29f1		       65 55		      adc	R1+1
    221  29f3		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  29f5		       60		      rts
    223  29f6							;
    224  29f6							;==============================================
    225  29f6							; on entry R1 has a context value,
    226  29f6							; on exit c is set if fails
    227  29f6							;
    228  29f6				   ipc_CONTEXTVALUES
      0  29f6					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  29f6		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  29fa					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  29fa		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  29fe					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  29fe		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    232  2a00
    233  2a00				   ipc_ValidateContext
    234  2a00		       48		      pha
    235  2a01		       8a		      txa
    236  2a02		       48		      pha
    237  2a03		       a5 55		      lda	R1+1
    238  2a05		       d0 0e		      bne	ipc_Validate_Fail
    239  2a07		       a2 00		      ldx	#0
    240  2a09		       a5 54		      lda	R1
    241  2a0b				   ipc_ValidateLoop
    242  2a0b		       dd f6 29 	      cmp	ipc_CONTEXTVALUES,x
    243  2a0e		       f0 09		      beq	ipc_Valid_Context
    244  2a10		       e8		      inx
    245  2a11		       e0 0a		      cpx	#TASKCOUNT
    246  2a13		       90 f6		      bcc	ipc_ValidateLoop
    247  2a15
    248  2a15				   ipc_Validate_Fail
    249  2a15		       68		      pla
    250  2a16		       aa		      tax
    251  2a17		       68		      pla
    252  2a18		       60		      rts
    253  2a19
    254  2a19				   ipc_Valid_Context
    255  2a19		       18		      clc
    256  2a1a		       90 f9		      bcc	ipc_Validate_Fail
    257  2a1c							;
    258  2a1c							;==============================================
    259  2a1c							;Push R1 onto the stack
    260  2a1c							;on entry y = next entry
    261  2a1c							;R0 points to the stack space
    262  2a1c							;on exit y points to next free byte
    263  2a1c				   ipc_pushR1
    264  2a1c		       88		      dey
    265  2a1d		       a5 55		      lda	R1+1	; PID first
    266  2a1f		       91 52		      sta	(R0),y
    267  2a21		       88		      dey
    268  2a22		       a5 54		      lda	R1
    269  2a24		       91 52		      sta	(R0),y
    270  2a26		       60		      rts
    271  2a27
    272  2a27
    273  2a27
    274  2a27
    275  2a27
    276  2a27
    277  2a27
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  2a27					      include	"support.asm"
      1  2a27							;
      2  2a27							;=====================================================
      3  2a27							;=====================================================
      4  2a27							;=====================================================
      5  2a27							; This marks the start of support functions used by
      6  2a27							; the IL opcodes.  These are support functions, NOT
      7  2a27							; the IL code.
      8  2a27							;=====================================================
      9  2a27							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  2a27							;=====================================================
     11  2a27					      Seg	Code
     12  2a27							;=====================================================
     13  2a27							; This gets the next two bytes pointed to by ILPC and
     14  2a27							; returns them; X contains LSB, A contains MSB.  ILPC
     15  2a27							; is advanced by two, and Y contains 0 on return.
     16  2a27
     17  2a27							;
     18  2a27		       20 2b 2a    getILWord  jsr	getILByte	;LSB
     19  2a2a		       aa		      tax
     20  2a2b							;
     21  2a2b							;=====================================================
     22  2a2b							; This gets the next byte pointed to by ILPC and
     23  2a2b							; returns it in A.  On return, X is unchanged but Y
     24  2a2b							; contains 0.
     25  2a2b							;
     26  2a2b		       a0 00	   getILByte  ldy	#0
     27  2a2d		       b1 43		      lda	(ILPC),y	;get byte
     28  2a2f		       08		      php		;save status
     29  2a30		       e6 43		      inc	ILPC	;inc LSB
     30  2a32		       d0 02		      bne	getILb2	;branch if no overflow
     31  2a34		       e6 44		      inc	ILPC+1	;inc MSB
     32  2a36		       28	   getILb2    plp		;restore status
     33  2a37		       60		      rts
     34  2a38							;
     35  2a38							;=====================================================
     36  2a38							; Decrement ILPC by one.
     37  2a38							;
     38  2a38		       a5 43	   decIL      lda	ILPC
     39  2a3a		       d0 02		      bne	decIL2
     40  2a3c		       c6 44		      dec	ILPC+1
     41  2a3e		       c6 43	   decIL2     dec	ILPC
     42  2a40		       60		      rts
     43  2a41							;
     44  2a41							;=====================================================
     45  2a41							; Push the ILPC onto the return stack.  Actually, this
     46  2a41							; pushes the address of ILPC+2 since that's the next
     47  2a41							; address to execute.
     48  2a41							;
     49  2a41		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  2a43		       c0 64		      cpy	#ILSTACKSIZE<<1
     51  2a45		       b0 15		      bcs	pushErr
     52  2a47		       a5 43		      lda	ILPC
     53  2a49		       18		      clc
     54  2a4a		       69 02		      adc	#2
     55  2a4c		       91 45		      sta	(ILSTACK),y
     56  2a4e		       08		      php		;save C bit
     57  2a4f		       c8		      iny
     58  2a50		       a5 44		      lda	ILPC+1
     59  2a52		       28		      plp		;restore C
     60  2a53		       69 00		      adc	#0
     61  2a55		       91 45		      sta	(ILSTACK),y
     62  2a57		       c8		      iny
     63  2a58		       84 47		      sty	ILSTACKPTR
     64  2a5a		       18		      clc
     65  2a5b		       60		      rts
     66  2a5c				   pushErr
     67  2a5c		       38		      sec
     68  2a5d		       60		      rts
     69  2a5e							;
     70  2a5e							;=====================================================
     71  2a5e							; Pull the top entry from return stack and put into
     72  2a5e							; ILPC.
     73  2a5e							;
     74  2a5e		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  2a60		       f0 fa		      beq	pushErr
     76  2a62		       88		      dey
     77  2a63		       b1 45		      lda	(ILSTACK),y
     78  2a65		       85 44		      sta	ILPC+1
     79  2a67		       88		      dey
     80  2a68		       b1 45		      lda	(ILSTACK),y
     81  2a6a		       85 43		      sta	ILPC
     82  2a6c		       84 47		      sty	ILSTACKPTR
     83  2a6e		       18		      clc
     84  2a6f		       60		      rts
     85  2a70							;
     86  2a70							;=====================================================
     87  2a70							; This searches for a specific line number that is in
     88  2a70							; R0.	There are three possible return conditions:
     89  2a70							; Line numbers are now the third byte, the first byte is now
     90  2a70							; a pointer to the next line, of course no longer than 255 byte
     91  2a70							; per line.
     92  2a70							;
     93  2a70							; Exact match was found:
     94  2a70							;    * Z set
     95  2a70							;    * CURPTR points to two-byte line number for that
     96  2a70							;	line.
     97  2a70							;
     98  2a70							; Next highest line found:
     99  2a70							;    * Z cleared
    100  2a70							;    * C set
    101  2a70							;    * CURPTR points to two-byte line number for that
    102  2a70							;	line.
    103  2a70							;
    104  2a70							; End of program reached:
    105  2a70							;    * Z cleared
    106  2a70							;    * C cleared
    107  2a70							;    * CURPTR points to first free byte at end of
    108  2a70							;	program.  Ie, it has save value as PROGRAMEND.
    109  2a70							;
    110  2a70							; A, X, and Y are all undefined on return.
    111  2a70							;
    112  2a70
    113  2a70				   findLine
    114  2a70		       ad 2d 43 	      lda	ProgramStart	;Start of program -> CURPTR
    115  2a73		       85 4f		      sta	CURPTR
    116  2a75		       ad 2e 43 	      lda	ProgramStart+1
    117  2a78		       85 50		      sta	CURPTR+1
    118  2a7a							;
    119  2a7a							; At end of code?
    120  2a7a							;
    121  2a7a				   iXFER1
    122  2a7a		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  2a7c		       cd 2f 43 	      cmp	ProgramEnd	; at end of program then stop run
    124  2a7f		       d0 0b		      bne	xfer2	; not end
    125  2a81		       a5 50		      lda	CURPTR+1
    126  2a83		       cd 30 43 	      cmp	ProgramEnd+1
    127  2a86		       d0 04		      bne	xfer2	;Not at end
    128  2a88							;
    129  2a88							; Line not found and the end of the program was
    130  2a88							; reached.  Return Z and C both clear.
    131  2a88							;
    132  2a88		       a9 01		      lda	#1	;clear Z
    133  2a8a		       18		      clc		;clear C
    134  2a8b		       60		      rts
    135  2a8c							;
    136  2a8c							; Check for an exact line number match
    137  2a8c							;
    138  2a8c		       a5 52	   xfer2      lda	R0
    139  2a8e		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  2a90		       d1 4f		      cmp	(CURPTR),y
    141  2a92		       d0 08		      bne	xfernotit
    142  2a94		       c8		      iny
    143  2a95		       a5 53		      lda	R0+1
    144  2a97		       d1 4f		      cmp	(CURPTR),y
    145  2a99		       d0 01		      bne	xfernotit	; not a matching line number
    146  2a9b							;
    147  2a9b							; This is exactly the line we want.
    148  2a9b							;
    149  2a9b		       60		      rts		;it matches exactly
    150  2a9c							;
    151  2a9c							; See if this line is greater than the one we're
    152  2a9c							; searching for.
    153  2a9c							;
    154  2a9c		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  2a9e		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  2aa0		       c5 53		      cmp	R0+1
    157  2aa2		       90 0b		      bcc	xfer3
    158  2aa4		       d0 07		      bne	xfer4
    159  2aa6		       88		      dey
    160  2aa7		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  2aa9		       c5 52		      cmp	R0
    162  2aab		       90 02		      bcc	xfer3
    163  2aad							;
    164  2aad							; This line is greater than the one we want, so
    165  2aad							; return Z clear and C set.
    166  2aad							;
    167  2aad		       38	   xfer4      sec		;We found a line number greater
    168  2aae		       60		      rts		;both conditions set
    169  2aaf							;
    170  2aaf							; Not the line (or droid) we're looking for.  Move to
    171  2aaf							; the next line.
    172  2aaf							;
    173  2aaf		       20 b5 2a    xfer3      jsr	FindNextLine
    174  2ab2		       4c 7a 2a 	      jmp	iXFER1
    175  2ab5							;
    176  2ab5							;=====================================================
    177  2ab5							; This advances CURPTR to the next line.  If there
    178  2ab5							; are no more lines, this leaves CURPTR equal to
    179  2ab5							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  2ab5							; CURPTR is pointing to a valid line on entry.  This
    181  2ab5							; pointer points to the two-byte line number.
    182  2ab5							; Update this points to the 1 byte line length  ****************
    183  2ab5							;
    184  2ab5				   FindNextLine
    185  2ab5		       a0 03		      ldy	#3	;skip line number and length byte
    186  2ab7		       84 51		      sty	CUROFF	;this is the new offset
    187  2ab9		       a0 00		      ldy	#0
    188  2abb		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  2abd		       18		      clc
    190  2abe		       65 4f		      adc	CURPTR
    191  2ac0		       85 4f		      sta	CURPTR
    192  2ac2		       a5 50		      lda	CURPTR+1
    193  2ac4		       69 00		      adc	#0
    194  2ac6		       85 50		      sta	CURPTR+1
    195  2ac8		       60	   FindNext4  rts
    196  2ac9							;
    197  2ac9							;=====================================================
    198  2ac9							; This compares CURPTR to PROGRAMEND and returns Z set
    199  2ac9							; if they are equal, Z clear if not.
    200  2ac9							;
    201  2ac9		       a5 4f	   AtEnd      lda	CURPTR
    202  2acb		       cd 2f 43 	      cmp	ProgramEnd
    203  2ace		       d0 05		      bne	atendexit
    204  2ad0		       a5 50		      lda	CURPTR+1
    205  2ad2		       cd 30 43 	      cmp	ProgramEnd+1
    206  2ad5		       60	   atendexit  rts
    207  2ad6							;
    208  2ad6
    209  2ad6							;
    210  2ad6							;=====================================================
    211  2ad6							; Convert an ASCII string to a number.  On input,
    212  2ad6							; (CURPTR),Y points to the first digit.  This gets
    213  2ad6							; digit-by-digit until finding a non-number.  Returns
    214  2ad6							; Y pointing to the non-digit, and R0 contains the
    215  2ad6							; number.  This does NOT check for valid ranges, so
    216  2ad6							; a value like "123456789" will produce something,
    217  2ad6							; but not what you had expected.
    218  2ad6							;
    219  2ad6		       a9 00	   getDecimal lda	#0
    220  2ad8		       85 52		      sta	R0
    221  2ada		       85 53		      sta	R0+1
    222  2adc		       85 59		      sta	dpl	;temporary negative flag
    223  2ade							;
    224  2ade							; See if it's negative...
    225  2ade							;
    226  2ade							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  2ade		       b1 4f		      lda	(CURPTR),y
    228  2ae0		       c9 2d		      cmp	#'-
    229  2ae2		       d0 02		      bne	getDecLoop
    230  2ae4		       e6 59		      inc	dpl	;it's negative
    231  2ae6							;
    232  2ae6		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  2ae8		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  2aea		       c9 30		      cmp	#'0
    235  2aec		       90 36		      bcc	getDdone
    236  2aee		       c9 3a		      cmp	#'9+1
    237  2af0		       b0 32		      bcs	getDdone
    238  2af2		       38		      sec
    239  2af3		       e9 30		      sbc	#'0	;convert to binary
    240  2af5		       48		      pha
    241  2af6							;
    242  2af6							; Now multiply R0 by 10.  Remember that
    243  2af6							; 2*N + 8*N = 10*N.
    244  2af6							;
    245  2af6		       06 52		      asl	R0
    246  2af8		       26 53		      rol	R0+1	;*2
    247  2afa		       a5 52		      lda	R0
    248  2afc		       85 54		      sta	R1
    249  2afe		       a5 53		      lda	R0+1
    250  2b00		       85 55		      sta	R1+1
    251  2b02		       06 52		      asl	R0
    252  2b04		       26 53		      rol	R0+1	;*4
    253  2b06		       06 52		      asl	R0
    254  2b08		       26 53		      rol	R0+1	;*8
    255  2b0a		       18		      clc		;now add the partial sums...
    256  2b0b		       a5 52		      lda	R0	;...to get *10
    257  2b0d		       65 54		      adc	R1
    258  2b0f		       85 52		      sta	R0
    259  2b11		       a5 53		      lda	R0+1
    260  2b13		       65 55		      adc	R1+1
    261  2b15		       85 53		      sta	R0+1
    262  2b17							;
    263  2b17							; Add in the new digit
    264  2b17							;
    265  2b17		       68		      pla
    266  2b18		       18		      clc
    267  2b19		       65 52		      adc	R0
    268  2b1b		       85 52		      sta	R0
    269  2b1d		       90 02		      bcc	getD2
    270  2b1f		       e6 53		      inc	R0+1
    271  2b21							;
    272  2b21							; Move to next character
    273  2b21							;
    274  2b21		       c8	   getD2      iny
    275  2b22		       d0 c2		      bne	getDecLoop
    276  2b24							;
    277  2b24							; All done with digits, so now deal with it being
    278  2b24							; negative.  If zero, then don't check for negative
    279  2b24							; flag.  Ie, -0 is stored as 0.
    280  2b24							;
    281  2b24		       a5 52	   getDdone   lda	R0
    282  2b26		       05 53		      ora	R0+1
    283  2b28		       f0 16		      beq	getDone2	;zero
    284  2b2a		       a5 59		      lda	dpl
    285  2b2c		       f0 12		      beq	getDone2	;positive
    286  2b2e							;
    287  2b2e							; Invert all the bits, then add one.
    288  2b2e							;
    289  2b2e		       a5 52		      lda	R0
    290  2b30		       49 ff		      eor	#$ff
    291  2b32		       85 52		      sta	R0
    292  2b34		       a5 53		      lda	R0+1
    293  2b36		       49 ff		      eor	#$ff
    294  2b38		       85 53		      sta	R0+1
    295  2b3a							;
    296  2b3a		       e6 52		      inc	R0
    297  2b3c		       d0 02		      bne	getDone2
    298  2b3e		       e6 53		      inc	R0+1
    299  2b40				   getDone2
    300  2b40							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  2b40							;lda	  R0
    302  2b40							;sta	  $0010
    303  2b40							;lda	  R0+1
    304  2b40							;sta	  $0011
    305  2b40							;lda	  dpl
    306  2b40							;sta	  $012
    307  2b40
    308  2b40		       60		      rts
    309  2b41
    310  2b41							;=====================================================
    311  2b41							; Gets a line of input into LINBUF.
    312  2b41							;
    313  2b41							; On entry:
    314  2b41							;    A contains the prompt character, or 0 if none.
    315  2b41							;    X = 1 Background read
    316  2b41							;    x = 0 Forground read with wait
    317  2b41							;
    318  2b41							; On exit:
    319  2b41							;    CURPTR points to LINBUF
    320  2b41							;    LINBUF contains the line with 0 at the end.
    321  2b41							;    Y has offset to first non-space character
    322  2b41							;    CURROFF has the same as Y.
    323  2b41							;
    324  2b41		       20 90 2b    GetLine    jsr	ReadPrompt
    325  2b44		       e0 00		      cpx	#0
    326  2b46		       f0 14		      beq	GetLineRetry
    327  2b48		       ae b4 36 	      ldx	taskPtr
    328  2b4b		       bd b5 36 	      lda	taskTable,x
    329  2b4e		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  2b50		       d0 3d		      bne	taskWaitingIO
    331  2b52		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  2b54		       9d b5 36 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  2b57		       ce 8f 2b 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  2b5a		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  2b5c
    336  2b5c							;
    337  2b5c							; Now read a line and wait for the CR
    338  2b5c							;
    339  2b5c				   GetLineRetry
    340  2b5c		       a9 00		      lda	#0	;Wait for input to complete
    341  2b5e		       20 a8 2b 	      jsr	ReadLine
    342  2b61
    343  2b61							;
    344  2b61							; Point to the line we just read
    345  2b61							; Set the current pointer to point to the input line
    346  2b61							;
    347  2b61		       a0 00	   ReadComplete ldy	#0
    348  2b63		       84 51		      sty	CUROFF
    349  2b65		       a2 90		      ldx	#LINBUF&$ff
    350  2b67		       86 4f		      stx	CURPTR
    351  2b69		       a2 42		      ldx	#LINBUF>>8
    352  2b6b		       86 50		      stx	CURPTR+1
    353  2b6d							;
    354  2b6d							; Output a CR/LF
    355  2b6d							;
    356  2b6d		       20 6f 2d 	      jsr	CRLF
    357  2b70							;
    358  2b70							; If a blank line, prompt again.
    359  2b70							;
    360  2b70		       20 66 2d 	      jsr	SkipSpaces
    361  2b73		       b1 4f		      lda	(CURPTR),y
    362  2b75		       d0 10		      bne	GetLineDone	;We have data then exit
    363  2b77		       20 93 2b 	      jsr	ReadPromptRetry
    364  2b7a		       ae b4 36 	      ldx	taskPtr	;if this task is waiting for IO
    365  2b7d		       bd b5 36 	      lda	taskTable,x	;then get out, wait for line to
    366  2b80		       29 40		      and	#TASKWAITIO	;Complete again
    367  2b82		       d0 0b		      bne	taskWaitingIO
    368  2b84		       4c 5c 2b 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  2b87
    370  2b87				   GetLineDone
    371  2b87		       ae b4 36 	      ldx	taskPtr
    372  2b8a		       a9 80		      lda	#TASKACTIVE
    373  2b8c		       9d b5 36 	      sta	taskTable,x	;IO is complete
    374  2b8f
    375  2b8f				   taskWaitingIO
    376  2b8f		       60		      rts
    377  2b90
    378  2b90							;
    379  2b90							;=======================================================================
    380  2b90							; Display the prompt character
    381  2b90							; On entry
    382  2b90							;	    A contains the prompt character
    383  2b90							; On exit
    384  2b90							;	    The readbuffer index is reset to 0
    385  2b90							;
    386  2b90		       8d 17 43    ReadPrompt sta	promptChar
    387  2b93
    388  2b93							;
    389  2b93							; Prompt
    390  2b93							;
    391  2b93
    392  2b93		       ad 17 43    ReadPromptRetry lda	promptChar
    393  2b96		       09 00		      ora	#0	;any prompt?
    394  2b98		       f0 08		      beq	getlinenp
    395  2b9a		       20 55 1a 	      jsr	VOUTCH
    396  2b9d		       a9 20		      lda	#$20
    397  2b9f		       20 55 1a 	      jsr	VOUTCH	;Space after prompt
    398  2ba2							;
    399  2ba2		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  2ba4		       8e 14 43 	      stx	getlinx
    401  2ba7		       60		      rts
    402  2ba8							;
    403  2ba8							;===============================================================
    404  2ba8							; This fuction is the driver for the line input
    405  2ba8							; on call if a = 0 then it waits for all input
    406  2ba8							;	      a = 1 then nowait for input
    407  2ba8							; On exit
    408  2ba8							;		       c clear if not complete line
    409  2ba8							;		       c set if it was a complete line
    410  2ba8
    411  2ba8				   ReadLine
    412  2ba8		       8d 16 43 	      sta	inputNoWait
    413  2bab		       c9 00		      cmp	#0
    414  2bad		       f0 05		      beq	getline1
    415  2baf		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  2bb2		       f0 2b		      beq	GetLineNoWait
    417  2bb4		       20 58 1a    getline1   jsr	VGETCH
    418  2bb7					      if	CTMON65
    419  2bb7		       48		      pha
    420  2bb8		       20 55 1a 	      jsr	VOUTCH	;echo echo echo
    421  2bbb		       68		      pla
    422  2bbc					      endif
    423  2bbc		       c9 0d		      cmp	#CR
    424  2bbe		       f0 15		      beq	getlind	;end of line
    425  2bc0		       c9 08		      cmp	#BS	;backspace?
    426  2bc2		       f0 1d		      beq	getlinebs
    427  2bc4		       ae 14 43 	      ldx	getlinx
    428  2bc7		       9d 90 42 	      sta	LINBUF,x
    429  2bca		       e8		      inx
    430  2bcb		       8e 14 43 	      stx	getlinx
    431  2bce		       ad 16 43 	      lda	inputNoWait
    432  2bd1		       f0 e1		      beq	getline1
    433  2bd3		       d0 0a		      bne	GetLineNoWait
    434  2bd5							;
    435  2bd5							; CR was hit
    436  2bd5							;
    437  2bd5		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  2bd7		       ae 14 43 	      ldx	getlinx
    439  2bda		       9d 90 42 	      sta	LINBUF,x
    440  2bdd
    441  2bdd		       38		      sec		; Carry set then cr received
    442  2bde		       60		      rts
    443  2bdf
    444  2bdf				   GetLineNoWait
    445  2bdf		       18		      clc		; Carry clear no end of line
    446  2be0		       60		      rts
    447  2be1							;
    448  2be1							; Backspace was hit
    449  2be1							;
    450  2be1		       ae 14 43    getlinebs  ldx	getlinx
    451  2be4		       f0 0e		      beq	getlineEOL	;at start of line
    452  2be6		       ca		      dex
    453  2be7		       8e 14 43 	      stx	getlinx
    454  2bea		       20 ad 21    getlinepbs jsr	puts
      0  2bed					      db	27,"[K",0
      1  2bed		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  2bf1		       4c b4 2b 	      jmp	getline1
    457  2bf4		       a9 20	   getlineEOL lda	#SPACE
    458  2bf6		       20 55 1a 	      jsr	VOUTCH
    459  2bf9		       d0 ef		      bne	getlinepbs
    460  2bfb							;
    461  2bfb							;=====================================================
    462  2bfb							; Count the length of the line currently in LINBUF
    463  2bfb							; starting at offset Y.  Returns the length in X.  The
    464  2bfb							; starting offset in Y should point past the ASCII
    465  2bfb							; line number.  Also counts the trailing NULL and two
    466  2bfb							; extra bytes for where the line number will be.
    467  2bfb							; Update must now include leading length byte not the null at end ****************
    468  2bfb							;
    469  2bfb				   getLineLength
    470  2bfb		       a2 00		      ldx	#0	;size
    471  2bfd		       b9 90 42    getLineL2  lda	LINBUF,y
    472  2c00		       f0 04		      beq	getLineL3
    473  2c02		       c8		      iny
    474  2c03		       e8		      inx
    475  2c04		       d0 f7		      bne	getLineL2
    476  2c06		       e8	   getLineL3  inx		;count null at end
    477  2c07		       e8		      inx		;line number LSB
    478  2c08		       e8		      inx		;MSB
    479  2c09		       e8		      inx		;change: count new leading line length
    480  2c0a		       8e 26 43 	      stx	lineLength
    481  2c0d		       60		      rts
    482  2c0e							;
    483  2c0e							;=====================================================
    484  2c0e							; Count the length of the line pointed to by CURPTR.
    485  2c0e							; This also counts the line number and the terminating
    486  2c0e							; null.  Ie, this string returns 8:
    487  2c0e							;
    488  2c0e							; <lineLow><lineHi>Hello<null>
    489  2c0e							;
    490  2c0e							; Another way of looking at it: add the return value
    491  2c0e							; to the CURPTR and it'll point to the next line's
    492  2c0e							; line number.  Returns the value in Y.
    493  2c0e							; Update to ject get the leading byte length ********************
    494  2c0e							;
    495  2c0e							;getCURPTRLength
    496  2c0e							;		ldy	CURPTR
    497  2c0e							;		ldy	#3	;change: skip line number and leading length byte
    498  2c0e							;getCLineL2	lda	(CURPTR),y
    499  2c0e							;		beq	getCLineL3
    500  2c0e							;		iny
    501  2c0e							;		bne	getCLineL2
    502  2c0e							;getCLineL3	iny		;count null at end
    503  2c0e							;		rts
    504  2c0e
    505  2c0e							;
    506  2c0e							;=====================================================
    507  2c0e							; This saves ILPC.  This saves to a single save area,
    508  2c0e							; so it can't be called more than once.
    509  2c0e							;
    510  2c0e		       a5 43	   saveIL     lda	ILPC
    511  2c10		       8d 22 43 	      sta	tempIL
    512  2c13		       a5 44		      lda	ILPC+1
    513  2c15		       8d 23 43 	      sta	tempIL+1
    514  2c18		       60		      rts
    515  2c19							;
    516  2c19							;=====================================================
    517  2c19							; This restores ILPC.
    518  2c19							;
    519  2c19		       ad 22 43    restoreIL  lda	tempIL
    520  2c1c		       85 43		      sta	ILPC
    521  2c1e		       ad 23 43 	      lda	tempIL+1
    522  2c21		       85 44		      sta	ILPC+1
    523  2c23		       60		      rts
    524  2c24							;
    525  2c24							;=====================================================
    526  2c24							; This pushes R0 onto the stack.
    527  2c24							;
    528  2c24		       8c 1d 43    pushR0     sty	rtemp1
    529  2c27		       a4 4a		      ldy	MATHSTACKPTR
    530  2c29		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  2c2b		       b0 38		      bcs	pusherr
    532  2c2d		       a5 52		      lda	R0
    533  2c2f		       91 48		      sta	(MATHSTACK),y
    534  2c31		       c8		      iny
    535  2c32		       a5 53		      lda	R0+1
    536  2c34		       91 48		      sta	(MATHSTACK),y
    537  2c36		       c8		      iny
    538  2c37		       84 4a		      sty	MATHSTACKPTR
    539  2c39		       ac 1d 43 	      ldy	rtemp1
    540  2c3c		       18		      clc
    541  2c3d		       60		      rts
    542  2c3e
    543  2c3e							;=====================================================
    544  2c3e							; This pushes curptr basic current line onto the call stack.
    545  2c3e							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  2c3e
    547  2c3e				   pushLN
    548  2c3e		       8d 1e 43 	      STA	rtemp1+1	; Store type of push being done
    549  2c41		       8c 1d 43 	      sty	rtemp1
    550  2c44		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  2c46		       c5 4d		      cmp	GOSUBSTACKPTR
    552  2c48		       90 1b		      bcc	pusherr	; No error
    553  2c4a		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  2c4c		       a2 00		      ldx	#0	; Start of bytes to copy
    555  2c4e				   pushLoop
    556  2c4e		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  2c50		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  2c52		       c8		      iny		; Next destination
    559  2c53		       e8		      inx		; Next Source byte
    560  2c54		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  2c56		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  2c58
    563  2c58		       ad 1e 43    pushDone   lda	rtemp1+1	; Type of stack entry
    564  2c5b		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  2c5d		       c8		      iny		; Next entry
    566  2c5e
    567  2c5e		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  2c60		       ac 1d 43 	      ldy	rtemp1
    569  2c63		       18		      clc
    570  2c64		       60		      rts
    571  2c65				   pusherr
    572  2c65		       38		      sec
    573  2c66		       60		      rts
    574  2c67							;=====================================================
    575  2c67							; This pops Top Off gosub call Stack and
    576  2c67							; places it in CURPTR/CUROFF.
    577  2c67							; This checks if the type = 1 GOSUB
    578  2c67							; if not it removes what ever is on the stack
    579  2c67							; until it finds the next return. Allowing
    580  2c67							; a return from within a for/next
    581  2c67							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  2c67		       8c 1d 43    popLN      sty	rtemp1
    583  2c6a		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  2c6c		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  2c6e
    586  2c6e				   popContinue
    587  2c6e		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  2c70		       90 22		      bcc	poperr	; Process an error
    589  2c72
    590  2c72		       88		      dey		; Position to read entry type
    591  2c73		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  2c75		       8d 1e 43 	      sta	rtemp1+1	; Save to be returned
    593  2c78		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  2c7a		       f0 04		      beq	popLoop	; Restore the line
    595  2c7c		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  2c7e		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  2c80
    598  2c80				   popLoop
    599  2c80		       88		      dey
    600  2c81		       ca		      dex
    601  2c82		       b1 4b		      lda	(GOSUBSTACK),y
    602  2c84		       95 4f		      sta	CURPTR,x
    603  2c86		       e0 00		      cpx	#0
    604  2c88		       d0 f6		      bne	popLoop	; Loop until all moved
    605  2c8a
    606  2c8a
    607  2c8a		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  2c8c		       ac 1d 43 	      ldy	rtemp1
    609  2c8f		       ad 1e 43 	      lda	rtemp1+1	; get the type of return
    610  2c92		       18		      clc
    611  2c93		       60		      rts
    612  2c94
    613  2c94		       38	   poperr     sec
    614  2c95		       60		      rts
    615  2c96
    616  2c96		       88	   popSkipEntry dey
    617  2c97		       88		      dey
    618  2c98		       88		      dey
    619  2c99		       4c 6e 2c 	      jmp	popContinue
    620  2c9c
    621  2c9c							;
    622  2c9c							;=====================================================
    623  2c9c							; This pushes R1 onto the stack
    624  2c9c							;
    625  2c9c		       8c 1d 43    pushR1     sty	rtemp1
    626  2c9f		       a4 4a		      ldy	MATHSTACKPTR
    627  2ca1		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  2ca3		       b0 ef		      bcs	poperr
    629  2ca5		       a5 54		      lda	R1
    630  2ca7		       91 48		      sta	(MATHSTACK),y
    631  2ca9		       c8		      iny
    632  2caa		       a5 55		      lda	R1+1
    633  2cac		       91 48		      sta	(MATHSTACK),y
    634  2cae		       c8		      iny
    635  2caf		       84 4a		      sty	MATHSTACKPTR
    636  2cb1		       ac 1d 43 	      ldy	rtemp1
    637  2cb4		       18		      clc
    638  2cb5		       60		      rts
    639  2cb6							;
    640  2cb6							;=====================================================
    641  2cb6							; This pops Top Of Stack and places it in R0.
    642  2cb6							;
    643  2cb6		       8c 1d 43    popR0      sty	rtemp1
    644  2cb9		       a4 4a		      ldy	MATHSTACKPTR
    645  2cbb		       f0 d7		      beq	poperr
    646  2cbd		       88		      dey
    647  2cbe		       b1 48		      lda	(MATHSTACK),y
    648  2cc0		       85 53		      sta	R0+1
    649  2cc2		       88		      dey
    650  2cc3		       b1 48		      lda	(MATHSTACK),y
    651  2cc5		       85 52		      sta	R0
    652  2cc7		       84 4a		      sty	MATHSTACKPTR
    653  2cc9		       ac 1d 43 	      ldy	rtemp1
    654  2ccc		       18		      clc
    655  2ccd		       60		      rts
    656  2cce
    657  2cce							;
    658  2cce							;=====================================================
    659  2cce							; This pops TOS and places it in R1.
    660  2cce							;
    661  2cce		       8c 1d 43    popR1      sty	rtemp1
    662  2cd1		       a4 4a		      ldy	MATHSTACKPTR
    663  2cd3		       f0 bf		      beq	poperr
    664  2cd5		       88		      dey
    665  2cd6		       b1 48		      lda	(MATHSTACK),y
    666  2cd8		       85 55		      sta	R1+1
    667  2cda		       88		      dey
    668  2cdb		       b1 48		      lda	(MATHSTACK),y
    669  2cdd		       85 54		      sta	R1
    670  2cdf		       84 4a		      sty	MATHSTACKPTR
    671  2ce1		       ac 1d 43 	      ldy	rtemp1
    672  2ce4		       60		      rts
    673  2ce5							;
    674  2ce5							;=====================================================
    675  2ce5							; This pops TOS and places it in MQ.
    676  2ce5							;
    677  2ce5		       8c 1d 43    popMQ      sty	rtemp1
    678  2ce8		       a4 4a		      ldy	MATHSTACKPTR
    679  2cea		       f0 a8		      beq	poperr
    680  2cec		       88		      dey
    681  2ced		       b1 48		      lda	(MATHSTACK),y
    682  2cef		       85 57		      sta	MQ+1
    683  2cf1		       88		      dey
    684  2cf2		       b1 48		      lda	(MATHSTACK),y
    685  2cf4		       85 56		      sta	MQ
    686  2cf6		       84 4a		      sty	MATHSTACKPTR
    687  2cf8		       ac 1d 43 	      ldy	rtemp1
    688  2cfb		       60		      rts
    689  2cfc							;
    690  2cfc							;=====================================================
    691  2cfc							; This assists with multiplication and division by
    692  2cfc							; looking at R0 and R1 and saving a flag as to what
    693  2cfc							; sign the result will be.  Math is always done on
    694  2cfc							; positive numbers, so this converts negative numbers
    695  2cfc							; into positives.  On exit, R0 and R1 are both
    696  2cfc							; positive.  If the signs were different then 'signs'
    697  2cfc							; will be non-zero.
    698  2cfc							;
    699  2cfc		       a9 00	   SaveSigns  lda	#0
    700  2cfe		       8d 1c 43 	      sta	sign	;assume positive
    701  2d01		       a5 53		      lda	R0+1	;MSB
    702  2d03		       10 13		      bpl	SaveSigns1
    703  2d05		       ee 1c 43 	      inc	sign	;it's negative
    704  2d08		       49 ff		      eor	#$ff	;flip bits
    705  2d0a		       85 53		      sta	R0+1
    706  2d0c		       a5 52		      lda	R0
    707  2d0e		       49 ff		      eor	#$ff
    708  2d10		       85 52		      sta	R0
    709  2d12		       e6 52		      inc	R0
    710  2d14		       d0 02		      bne	SaveSigns1
    711  2d16		       e6 53		      inc	R0+1
    712  2d18		       a5 55	   SaveSigns1 lda	R1+1
    713  2d1a		       10 1a		      bpl	SaveSigns2
    714  2d1c		       48		      pha
    715  2d1d		       ad 1c 43 	      lda	sign
    716  2d20		       49 01		      eor	#1
    717  2d22		       8d 1c 43 	      sta	sign
    718  2d25		       68		      pla
    719  2d26		       49 ff		      eor	#$ff	;flip bits
    720  2d28		       85 55		      sta	R1+1
    721  2d2a		       a5 54		      lda	R1
    722  2d2c		       49 ff		      eor	#$ff
    723  2d2e		       85 54		      sta	R1
    724  2d30		       e6 54		      inc	R1
    725  2d32		       d0 02		      bne	SaveSigns2
    726  2d34		       e6 55		      inc	R1+1
    727  2d36		       60	   SaveSigns2 rts
    728  2d37							;
    729  2d37							;=====================================================
    730  2d37							; This looks at the value of 'signs' and will convert
    731  2d37							; both R0 and R1 to negative if set.
    732  2d37							;
    733  2d37				   RestoreSigns
    734  2d37		       ad 1c 43 	      lda	sign
    735  2d3a		       f0 28		      beq	restoresigns2
    736  2d3c							;
    737  2d3c		       a5 52		      lda	R0
    738  2d3e		       d0 02		      bne	restoresigns3
    739  2d40		       c6 53		      dec	R0+1
    740  2d42				   restoresigns3
    741  2d42		       c6 52		      dec	R0
    742  2d44		       a5 52		      lda	R0
    743  2d46		       49 ff		      eor	#$ff
    744  2d48		       85 52		      sta	R0
    745  2d4a		       a5 53		      lda	R0+1
    746  2d4c		       49 ff		      eor	#$ff
    747  2d4e		       85 53		      sta	R0+1
    748  2d50							;
    749  2d50		       a5 54		      lda	R1
    750  2d52		       d0 02		      bne	restoresigns4
    751  2d54		       c6 55		      dec	R1+1
    752  2d56				   restoresigns4
    753  2d56		       c6 54		      dec	R1
    754  2d58		       a5 54		      lda	R1
    755  2d5a		       49 ff		      eor	#$ff
    756  2d5c		       85 54		      sta	R1
    757  2d5e		       a5 55		      lda	R1+1
    758  2d60		       49 ff		      eor	#$ff
    759  2d62		       85 55		      sta	R1+1
    760  2d64							;
    761  2d64				   restoresigns2
    762  2d64		       60		      rts
    763  2d65							;
    764  2d65							;=====================================================
    765  2d65							; Skip over spaces.  Returns Y with the offset to
    766  2d65							; either the last character in the line, or the first
    767  2d65							; non-space character.
    768  2d65							;
    769  2d65
    770  2d65		       c8	   skipsp2    iny
    771  2d66		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  2d68		       f0 04		      beq	Skip3	;end of line
    773  2d6a		       c9 20		      cmp	#SPACE
    774  2d6c		       f0 f7		      beq	skipsp2
    775  2d6e		       60	   Skip3      rts
    776  2d6f							;*********************************************************
    777  2d6f							; Output a CR/LF combination to the console.  Preserves
    778  2d6f							; all registers.
    779  2d6f							;
    780  2d6f		       48	   tbcrlf     pha
    781  2d70		       a9 0d		      lda	#CR
    782  2d72		       20 55 1a 	      jsr	VOUTCH
    783  2d75		       a9 0a		      lda	#LF
    784  2d77		       20 55 1a 	      jsr	VOUTCH
    785  2d7a		       68		      pla
    786  2d7b		       60		      rts
    787  2d7c							;
    788  2d7c							;=====================================================
    789  2d7c							; Some logic to print the Line of basic code being executed
    790  2d7c		       24 40	   idbgBasic  bit	ILTrace
    791  2d7e		       50 75		      bvc	dbgBasicNone
    792  2d80		       98		      tya
    793  2d81		       48		      pha
    794  2d82		       20 0a 2f 	      jsr	SetOutDebug
    795  2d85
    796  2d85		       a5 4f		      lda	CURPTR
    797  2d87		       85 59		      sta	dpl
    798  2d89		       a5 50		      lda	CURPTR+1
    799  2d8b		       85 5a		      sta	dpl+1
    800  2d8d
    801  2d8d		       20 45 22 	      jsr	PrintProgramLine
    802  2d90
    803  2d90		       a5 40		      lda	ILTrace
    804  2d92		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  2d94		       f0 5a		      beq	dbgBasicDone
    806  2d96		       20 21 2f 	      jsr	SetInDebug
    807  2d99		       20 ad 21 	      jsr	puts
      0  2d9c					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  2d9c		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  2dd9				   dbgBasicLoop
    810  2dd9		       20 58 1a 	      jsr	VGETCH
    811  2ddc		       20 6f 2d 	      jsr	CRLF
    812  2ddf		       20 45 2f 	      jsr	SetInDebugEnd
    813  2de2
    814  2de2		       c9 73		      cmp	#'s	; Quit program
    815  2de4		       f0 12		      beq	dbgBasicStop
    816  2de6
    817  2de6		       c9 64		      cmp	#'d	; Display Variables
    818  2de8		       d0 06		      bne	dbgBasicDone
    819  2dea
    820  2dea		       20 08 22 	      jsr	PrintAllVars
    821  2ded		       18		      clc
    822  2dee		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  2df0
    824  2df0		       20 38 2f    dbgBasicDone jsr	SetOutDebugEnd
    825  2df3		       68		      pla
    826  2df4		       a8		      tay
    827  2df5		       4c b1 02    dbgBasicNone jmp	NextIL
    828  2df8
    829  2df8				   dbgBasicStop
    830  2df8		       20 38 2f 	      jsr	SetOutDebugEnd
    831  2dfb		       68		      pla
    832  2dfc		       a8		      tay
    833  2dfd		       4c 02 06 	      jmp	iFIN
    834  2e00							;
    835  2e00							;=====================================================
    836  2e00							; This is some debug logic which displays the current
    837  2e00							; value of the ILPC and the line buffer.
    838  2e00							;
    839  2e00		       24 40	   dbgLine    bit	ILTrace
    840  2e02		       30 01		      bmi	dbgPrt
    841  2e04		       60		      rts
    842  2e05				   dbgPrt
    843  2e05		       20 0a 2f 	      jsr	SetOutDebug
    844  2e08		       20 ad 21 	      jsr	puts
      0  2e0b					      db	"ILPC:",0
      1  2e0b		       49 4c 50 43*	      .byte.b	"ILPC:",0
    846  2e11		       a5 44		      lda	ILPC+1
    847  2e13		       20 90 21 	      jsr	OUTHEX
    848  2e16		       a5 43		      lda	ILPC
    849  2e18		       20 90 21 	      jsr	OUTHEX
    850  2e1b		       a9 20		      lda	#SPACE
    851  2e1d		       20 55 1a 	      jsr	VOUTCH
    852  2e20
    853  2e20		       a0 00		      ldy	#0
    854  2e22		       b1 43		      lda	(ILPC),y	;Get the il pcode value
    855  2e24					      if	IL_DEBUG_TEXT
    856  2e24		       20 14 19 	      jsr	PrintILText
    857  2e27				  -	      else
    858  2e27				  -	      jsr	OUTHEX
    859  2e27					      endif
    860  2e27		       20 ad 21 	      jsr	puts
      0  2e2a					      db	" ILSP:",0
      1  2e2a		       20 49 4c 53*	      .byte.b	" ILSP:",0
    862  2e31		       a5 47		      lda	ILSTACKPTR
    863  2e33		       20 90 21 	      jsr	OUTHEX
    864  2e36		       a9 20		      lda	#SPACE
    865  2e38		       20 55 1a 	      jsr	VOUTCH
    866  2e3b
    867  2e3b							; Display the CURPTR value and offset
    868  2e3b							;
    869  2e3b		       20 ad 21 	      jsr	puts
      0  2e3e					      db	", CURPTR: ",0
      1  2e3e		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    871  2e49		       a5 50		      lda	CURPTR+1
    872  2e4b		       20 90 21 	      jsr	OUTHEX
    873  2e4e		       a5 4f		      lda	CURPTR
    874  2e50		       20 90 21 	      jsr	OUTHEX
    875  2e53		       a9 2b		      lda	#'+
    876  2e55		       20 55 1a 	      jsr	VOUTCH
    877  2e58		       a5 51		      lda	CUROFF
    878  2e5a		       20 90 21 	      jsr	OUTHEX
    879  2e5d							;
    880  2e5d		       20 6f 2d 	      jsr	CRLF
    881  2e60		       20 38 2f 	      jsr	SetOutDebugEnd
    882  2e63		       20 96 2e 	      jsr	ILChkRange
    883  2e66		       b0 02		      bcs	dbgLineErr
    884  2e68		       18		      clc
    885  2e69		       60		      rts
    886  2e6a
    887  2e6a				   dbgLineErr
    888  2e6a		       20 0a 2f 	      jsr	SetOutDebug
    889  2e6d		       20 ad 21 	      jsr	puts
      0  2e70					      db	"Outside Valid IL Address Range",CR,LF,0
      1  2e70		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    891  2e91		       20 38 2f 	      jsr	SetOutDebugEnd
    892  2e94		       38		      sec
    893  2e95		       60		      rts
    894  2e96
    895  2e96		       a5 44	   ILChkRange lda	ILPC+1
    896  2e98		       c9 31		      cmp	#IL>>8
    897  2e9a		       90 18		      bcc	ILBadRange
    898  2e9c		       d0 06		      bne	ILChkHigh
    899  2e9e
    900  2e9e		       a5 43		      lda	ILPC
    901  2ea0		       c9 f3		      cmp	#IL&$ff
    902  2ea2		       90 10		      bcc	ILBadRange
    903  2ea4
    904  2ea4		       a5 44	   ILChkHigh  lda	ILPC+1
    905  2ea6		       c9 36		      cmp	#ILEND>>8
    906  2ea8		       90 08		      bcc	ILGoodRange
    907  2eaa		       d0 08		      bne	ILBadRange
    908  2eac
    909  2eac		       a5 43		      lda	ILPC
    910  2eae		       c9 61		      cmp	#ILEND&$ff
    911  2eb0		       b0 02		      bcs	ILBadRange
    912  2eb2
    913  2eb2		       18	   ILGoodRange clc
    914  2eb3		       60		      rts
    915  2eb4				   ILBadRange
    916  2eb4		       38		      sec
    917  2eb5		       60		      rts
    918  2eb6
    919  2eb6
    920  2eb6							;=====================================================
    921  2eb6							; Set output vector to the console output function
    922  2eb6							;
    923  2eb6				   SetOutConsole
    924  2eb6		       48		      pha
    925  2eb7		       a9 0c		      lda	#OUTCH&$ff
    926  2eb9		       8d 66 36 	      sta	BOutVec
    927  2ebc		       a9 f0		      lda	#OUTCH>>8
    928  2ebe		       8d 67 36 	      sta	BOutVec+1
    929  2ec1		       68		      pla
    930  2ec2		       60		      rts
    931  2ec3
    932  2ec3				   SetInConsole
    933  2ec3		       48		      pha
    934  2ec4		       a9 09		      lda	#GETCH&$ff
    935  2ec6		       8d 64 36 	      sta	BInVec
    936  2ec9		       a9 f0		      lda	#GETCH>>8
    937  2ecb		       8d 65 36 	      sta	BInVec+1
    938  2ece		       68		      pla
    939  2ecf		       60		      rts
    940  2ed0
    941  2ed0
    942  2ed0
    943  2ed0							;====================================================
    944  2ed0							;Clear the terminal assume it is ansii or vt100
    945  2ed0							;
    946  2ed0				   iCLEARSCREEN
    947  2ed0		       20 ad 21 	      jsr	puts
      0  2ed3					      db	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
      1  2ed3		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
    949  2ee4		       4c b1 02 	      jmp	NextIL
    950  2ee7
    951  2ee7							;====================================================
    952  2ee7							; Push true and false onto math stack
    953  2ee7				   pushTrue
    954  2ee7		       a9 ff		      lda	#$ff
    955  2ee9		       85 52	   pushTF     sta	R0
    956  2eeb		       85 53		      sta	R0+1
    957  2eed		       20 24 2c 	      jsr	pushR0
    958  2ef0		       60		      rts
    959  2ef1		       a9 00	   pushFalse  lda	#0
    960  2ef3		       f0 f4		      beq	pushTF
    961  2ef5
    962  2ef5							;======================================================
    963  2ef5							; Copy stack top to R1
    964  2ef5				   CopyStackR1
    965  2ef5		       98		      tya
    966  2ef6		       48		      pha
    967  2ef7		       a4 4a		      ldy	MATHSTACKPTR
    968  2ef9		       88		      dey
    969  2efa		       b1 48		      lda	(MATHSTACK),y
    970  2efc		       85 55		      sta	R1+1
    971  2efe		       88		      dey
    972  2eff		       b1 48		      lda	(MATHSTACK),y
    973  2f01		       85 54		      sta	R1
    974  2f03		       68		      pla
    975  2f04		       a8		      tay
    976  2f05		       60		      rts
    977  2f06
    978  2f06
    979  2f06							;====================================================
    980  2f06							;Swap the out debug call for standard calls
    981  2f06		       00 00	   DebugIOSave ds	2
    982  2f08		       00 00	   DebugInSave ds	2
    983  2f0a				   SetOutDebug
    984  2f0a		       ad 66 36 	      lda	BOutVec
    985  2f0d		       8d 06 2f 	      sta	DebugIOSave
    986  2f10		       ad 67 36 	      lda	BOutVec+1
    987  2f13		       8d 07 2f 	      sta	DebugIOSave+1
    988  2f16		       a9 9e		      lda	#OUTDEBUG&$ff	; Put the Debug output
    989  2f18		       8d 66 36 	      sta	BOutVec
    990  2f1b		       a9 2f		      lda	#OUTDEBUG>>8
    991  2f1d		       8d 67 36 	      sta	BOutVec+1
    992  2f20		       60		      rts
    993  2f21				   SetInDebug
    994  2f21		       ad 64 36 	      lda	BInVec
    995  2f24		       8d 08 2f 	      sta	DebugInSave
    996  2f27		       ad 65 36 	      lda	BInVec+1
    997  2f2a		       8d 09 2f 	      sta	DebugInSave+1
    998  2f2d		       a9 a2		      lda	#INDEBUG&$ff
    999  2f2f		       8d 64 36 	      sta	BInVec
   1000  2f32		       a9 2f		      lda	#INDEBUG>>8
   1001  2f34		       8d 65 36 	      sta	BInVec+1
   1002  2f37		       60		      rts
   1003  2f38				   SetOutDebugEnd
   1004  2f38		       ad 06 2f 	      lda	DebugIOSave
   1005  2f3b		       8d 66 36 	      sta	BOutVec
   1006  2f3e		       ad 07 2f 	      lda	DebugIOSave+1
   1007  2f41		       8d 67 36 	      sta	BOutVec+1
   1008  2f44		       60		      rts
   1009  2f45				   SetInDebugEnd
   1010  2f45		       ad 08 2f 	      lda	DebugInSave
   1011  2f48		       8d 64 36 	      sta	BInVec
   1012  2f4b		       ad 09 2f 	      lda	DebugInSave+1
   1013  2f4e		       8d 65 36 	      sta	BInVec+1
   1014  2f51		       60		      rts
   1015  2f52							;
   1016  2f52							;====================================================
   1017  2f52							; Set the input and output terminal address
   1018  2f52							; The math stack stack byte is the output io slot
   1019  2f52							; The math stack  is the input io slot
   1020  2f52
   1021  2f52				   iSetTerminal
   1022  2f52		       20 b6 2c 	      jsr	popR0	; Process the output io addresses
   1023  2f55		       20 7f 2f 	      jsr	CalcSlot
   1024  2f58		       a5 52		      lda	R0
   1025  2f5a		       09 01		      ora	#1
   1026  2f5c		       8d 9f 2f 	      sta	TerminalOutputPort
   1027  2f5f		       a5 53		      lda	R0+1
   1028  2f61		       8d a0 2f 	      sta	TerminalOutputPort+1
   1029  2f64
   1030  2f64		       20 b6 2c 	      jsr	popR0	; Process the input io address
   1031  2f67		       20 7f 2f 	      jsr	CalcSlot
   1032  2f6a		       a5 52		      lda	R0
   1033  2f6c		       8d a3 2f 	      sta	TerminalStatusPort
   1034  2f6f		       09 01		      ora	#1
   1035  2f71		       8d aa 2f 	      sta	TerminalInputPort
   1036  2f74		       a5 53		      lda	R0+1
   1037  2f76		       8d ab 2f 	      sta	TerminalInputPort+1
   1038  2f79		       8d a4 2f 	      sta	TerminalStatusPort+1
   1039  2f7c		       4c b1 02 	      jmp	NextIL
   1040  2f7f
   1041  2f7f							;===================================================
   1042  2f7f							; Calculate the slot address the the slot number
   1043  2f7f							; R0 contains the slot number 0-255
   1044  2f7f
   1045  2f7f				   CalcSlot
   1046  2f7f		       8a		      txa
   1047  2f80		       48		      pha
   1048  2f81
   1049  2f81		       a2 04		      ldx	#4
   1050  2f83				   CalcSlotLoop
   1051  2f83		       18		      clc
   1052  2f84		       26 52		      rol	R0
   1053  2f86		       26 53		      rol	R0+1
   1054  2f88		       ca		      dex
   1055  2f89		       d0 f8		      bne	CalcSlotLoop
   1056  2f8b
   1057  2f8b		       a9 e0		      lda	#$E0
   1058  2f8d		       05 53		      ora	R0+1
   1059  2f8f		       85 53		      sta	R0+1
   1060  2f91		       68		      pla
   1061  2f92
   1062  2f92		       aa		      tax
   1063  2f93		       60		      rts
   1064  2f94							;
   1065  2f94							;====================================================
   1066  2f94							; Output to the Terminal/Debug console
   1067  2f94							;     x = high address byte
   1068  2f94							;     y = low address byte
   1069  2f94							;     a = Terminator for string
   1070  2f94				   TerminalWrite
   1071  2f94				   DebugWrite
   1072  2f94		       20 0a 2f 	      jsr	SetOutDebug
   1073  2f97		       20 eb 21 	      jsr	PrtStr
   1074  2f9a		       20 38 2f 	      jsr	SetOutDebugEnd
   1075  2f9d		       60		      rts
   1076  2f9e
   1077  2f9e				   TerminalIOblock
   1078  2f9e				   OUTDEBUG
   1079  2f9e		       8d		      .byte.b	$8D	; STA
   1080  2f9f				   TerminalOutputPort
   1081  2f9f		       21 e0	   DEBUGPORT  .word.w	$E021	; Dont check anything just output the byte
   1082  2fa1		       60		      RTS
   1083  2fa2
   1084  2fa2				   TerminalRead
   1085  2fa2				   INDEBUG
   1086  2fa2		       ad		      .byte.b	$AD	; LDA
   1087  2fa3				   TerminalStatusPort
   1088  2fa3		       20 e0	   DEBUGPORTSTATUS .word.w	$E020
   1089  2fa5
   1090  2fa5		       29 01		      and	#$01
   1091  2fa7		       f0 f9		      beq	INDEBUG
   1092  2fa9
   1093  2fa9		       ad		      .byte.b	$AD	; LDA
   1094  2faa				   TerminalInputPort
   1095  2faa		       21 e0	   DEBUGPORTIN .word.w	$E021
   1096  2fac		       60		      rts
   1097  2fad				   TerminalIOblockEnd
   1098  2fad							;======================================================================
   1099  2fad							;Copy Quoted string to buffer, terminate with 0 byte
   1100  2fad							; R0  Source tring points to tString type
   1101  2fad							; x is terminator
   1102  2fad							; R1 points to destinition location
   1103  2fad							; On exit R0 contains length of copy Plus Term and leading bytes
   1104  2fad
   1105  2fad				   qstrcpy
   1106  2fad		       20 24 2c 	      jsr	pushR0
   1107  2fb0		       20 fd 2f 	      jsr	IncR0	; point past the tString
   1108  2fb3		       20 fd 2f 	      jsr	IncR0	; Point Past the opening "
   1109  2fb6		       a2 22		      ldx	#'"	; copy Termination
   1110  2fb8		       20 d2 2f 	      jsr	pstrcpy
   1111  2fbb		       20 fd 2f 	      jsr	IncR0	; point to "
   1112  2fbe		       20 fd 2f 	      jsr	IncR0	; Point to next free byte
   1113  2fc1		       20 ce 2c 	      jsr	popR1
   1114  2fc4		       38		      sec
   1115  2fc5		       a5 52		      lda	R0
   1116  2fc7		       e5 54		      sbc	R1
   1117  2fc9		       85 52		      sta	R0
   1118  2fcb		       a5 53		      lda	R0+1
   1119  2fcd		       e5 55		      sbc	R1+1
   1120  2fcf		       85 53		      sta	R0+1
   1121  2fd1		       60		      rts
   1122  2fd2
   1123  2fd2							;=========================================================================
   1124  2fd2							;Copy string from R0 to R1, terminator in x
   1125  2fd2							; On exit    R0 contains the length of the copy
   1126  2fd2				   pstrcpy
   1127  2fd2		       a0 00		      ldy	#0
   1128  2fd4		       86 58		      stx	R2
   1129  2fd6
   1130  2fd6				   strcpyLoop
   1131  2fd6		       b1 52		      lda	(R0),y
   1132  2fd8		       c5 58		      cmp	R2
   1133  2fda		       f0 0a		      beq	strcpyDone
   1134  2fdc		       91 54		      sta	(R1),y
   1135  2fde		       20 fd 2f 	      jsr	IncR0
   1136  2fe1		       20 eb 2f 	      jsr	IncR1
   1137  2fe4		       90 f0		      bcc	strcpyLoop
   1138  2fe6				   strcpyDone
   1139  2fe6		       a9 00		      lda	#0
   1140  2fe8		       91 54		      sta	(R1),y
   1141  2fea
   1142  2fea		       60		      rts
   1143  2feb
   1144  2feb							;=========================================================================
   1145  2feb							; on exit c is set on overflow
   1146  2feb				   IncR1
   1147  2feb		       48		      pha
   1148  2fec		       18		      clc
   1149  2fed		       a9 01		      lda	#1
   1150  2fef		       65 54		      adc	R1
   1151  2ff1		       85 54		      sta	R1
   1152  2ff3		       90 06		      bcc	IncR1Done
   1153  2ff5		       a9 00		      lda	#0
   1154  2ff7		       65 55		      adc	R1+1
   1155  2ff9		       85 55		      sta	R1+1
   1156  2ffb				   IncR1Done
   1157  2ffb		       68		      pla
   1158  2ffc		       60		      rts
   1159  2ffd							;=========================================================================
   1160  2ffd							; on exit c is set on overflow
   1161  2ffd				   IncR0
   1162  2ffd		       48		      pha
   1163  2ffe		       18		      clc
   1164  2fff		       a9 01		      lda	#1
   1165  3001		       65 52		      adc	R0
   1166  3003		       85 52		      sta	R0
   1167  3005		       90 06		      bcc	IncR0Done
   1168  3007		       a9 00		      lda	#0
   1169  3009		       65 53		      adc	R0+1
   1170  300b		       85 53		      sta	R0+1
   1171  300d				   IncR0Done
   1172  300d		       68		      pla
   1173  300e		       60		      rts
   1174  300f
   1175  300f
   1176  300f
   1177  300f
   1178  300f
   1179  300f
   1180  300f
   1181  300f
   1182  300f
   1183  300f
   1184  300f
   1185  300f
   1186  300f
   1187  300f
   1188  300f
   1189  300f
------- FILE mytb.asm
   2490  300f
   2491  300f					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  300f					      include	"storage.asm"
      1  300f							;
      2  300f							;=====================================================
      3  300f							;=====================================================
      4  300f							;=====================================================
      5  300f							; This file contains the functions for saving and
      6  300f							; restoring programs from some sort of mass storage
      7  300f							; device.  This particular version is for using the
      8  300f							; Corsham Tech SD Card System.
      9  300f							;=====================================================
     10  300f							;=====================================================
     11  300f							;=====================================================
     12  300f
     13 U3672					      seg.u	TBData
     14 U3672		       00	   diskBufLength ds	1
     15 U3673		       00	   diskBufOffset ds	1
     16 U3674		       00 00 00 00*DiskFileName ds	64
     17 U36b4
     18  300f					      SEG	Code
     19  300f
     20  300f							;
     21  300f							;=====================================================
     22  300f							; Open a file for reading as a program.  The next
     23  300f							; thing on the line should be the filename.
     24  300f							;
     25  300f				   iOPENREAD
     26  300f					      if	XKIM || CTMON65
     27  300f		       20 29 30 	      jsr	setFileName	;Set the file name to open
     28  3012		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  3015		       90 07		      bcc	Ropenok	;branch if opened ok
     30  3017							;
     31  3017							; Open failed
     32  3017							;
     33  3017		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  3019		       a9 00	   Rdfail2    lda	#0
     35  301b		       4c 7d 06 	      jmp	iErr2
     36  301e							;
     37  301e							; Clear counts and offsets so the next read will
     38  301e							; cause the file to be read.
     39  301e							;
     40  301e		       a9 00	   Ropenok    lda	#0
     41  3020		       8d 73 36 	      sta	diskBufOffset
     42  3023		       8d 72 36 	      sta	diskBufLength
     43  3026		       4c b1 02 	      jmp	NextIL
     44  3029					      endif
     45  3029
     46  3029							;===============================================================
     47  3029							; Set file name
     48  3029				   setFileName
     49  3029		       a4 51		      ldy	CUROFF
     50  302b		       b1 4f		      lda	(CURPTR),y
     51  302d		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  302f		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  3031
     54  3031		       18		      clc
     55  3032		       98		      tya
     56  3033		       65 4f		      adc	CURPTR
     57  3035		       85 52		      sta	R0	;LSB
     58  3037		       a5 50		      lda	CURPTR+1
     59  3039		       69 00		      adc	#0
     60  303b		       85 53		      sta	R0+1
     61  303d		       a9 74		      lda	#DiskFileName&$ff
     62  303f		       85 54		      sta	R1
     63  3041		       a9 36		      lda	#DiskFileName>>8
     64  3043		       85 55		      sta	R1+1
     65  3045		       20 ad 2f 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  3048		       a5 52		      lda	R0
     67  304a		       18		      clc
     68  304b		       65 51		      adc	CUROFF	; add the current offset
     69  304d		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  304f				   ResetFileName
     71  304f		       a0 74		      ldy	#DiskFileName&$ff
     72  3051		       a2 36		      ldx	#DiskFileName>>8
     73  3053		       18		      clc
     74  3054		       60		      rts
     75  3055
     76  3055				   setFileNameNotFound
     77  3055		       68		      pla
     78  3056		       68		      pla		; remove the return address from the stack
     79  3057		       a9 00		      lda	#0
     80  3059		       a2 09		      ldx	#ERR_NO_FILENAME
     81  305b		       4c 7d 06 	      jmp	iErr2
     82  305e
     83  305e							;
     84  305e							;==============================JUSTLOSTINTIME 08/02/2022========
     85  305e							;Remove a file from the disk
     86  305e				   iRMFILE
     87  305e					      if	XKIM || CTMON65
     88  305e		       20 29 30 	      jsr	setFileName
     89  3061		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  3064		       90 07		      bcc	wrmOk	;branch if removed ok
     91  3066		       a9 00		      lda	#0
     92  3068		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  306a		       4c 7d 06 	      jmp	iErr2
     94  306d				   wrmOk
     95  306d		       4c b1 02 	      jmp	NextIL
     96  3070
     97  3070					      endif
     98  3070							;
     99  3070							;=====================================================
    100  3070				   iOPENWRITE
    101  3070					      if	XKIM || CTMON65
    102  3070		       20 29 30 	      jsr	setFileName
    103  3073		       20 2b 2a 	      jsr	getILByte	;get the append or create byte
    104  3076		       c9 01		      cmp	#1	;create/truncate
    105  3078		       d0 06		      bne	iopencont
    106  307a		       20 4f 30 	      jsr	ResetFileName	;point back to the file name
    107  307d		       20 45 f0 	      jsr	DiskRmFile	;by default files opened for write are append
    108  3080
    109  3080				   iopencont
    110  3080		       20 4f 30 	      jsr	ResetFileName	;point back to the file name
    111  3083		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    112  3086		       90 07		      bcc	Wopenok	;branch if opened ok
    113  3088							;
    114  3088							; Open failed
    115  3088							;
    116  3088		       a9 00	   Wdfail     lda	#0
    117  308a		       a2 08		      ldx	#ERR_WRITE_FAIL
    118  308c		       4c 7d 06 	      jmp	iErr2
    119  308f							;
    120  308f		       4c b1 02    Wopenok    jmp	NextIL
    121  3092					      endif
    122  3092							;
    123  3092							;=====================================================
    124  3092							; Gets a line of input from the disk file and puts it
    125  3092							; into LINBUF.
    126  3092							;
    127  3092							; On exit:
    128  3092							;    CURPTR points to LINBUF
    129  3092							;    LINBUF contains the line with 0 at the end.
    130  3092							;    Y has offset to first non-space character
    131  3092							;    CURROFF has the same as Y.
    132  3092							;
    133  3092				   iDGETLINE
    134  3092					      if	XKIM || CTMON65
    135  3092		       a2 90		      ldx	#LINBUF&$ff
    136  3094		       86 4f		      stx	CURPTR
    137  3096		       a2 42		      ldx	#LINBUF>>8
    138  3098		       86 50		      stx	CURPTR+1
    139  309a							;
    140  309a		       a2 00		      ldx	#0	;offset
    141  309c		       8e 14 43    iDgetLoop  stx	getlinx
    142  309f		       20 0a 31 	      jsr	getNextFileByte
    143  30a2		       b0 16		      bcs	iGetEOF
    144  30a4		       c9 0d		      cmp	#CR
    145  30a6		       f0 0d		      beq	iGetEOL
    146  30a8		       c9 0a		      cmp	#LF
    147  30aa		       f0 09		      beq	iGetEOL
    148  30ac		       ae 14 43 	      ldx	getlinx
    149  30af		       9d 90 42 	      sta	LINBUF,x
    150  30b2		       e8		      inx
    151  30b3		       d0 e7		      bne	iDgetLoop
    152  30b5							;
    153  30b5							; Handle end of line.	If the line has nothing, loop
    154  30b5							; back and get another line.
    155  30b5							;
    156  30b5		       ae 14 43    iGetEOL    ldx	getlinx	;blank line?
    157  30b8		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    158  30ba							;
    159  30ba							; This can fall through when there is a line, or
    160  30ba							; called directly when EOF is encountered.
    161  30ba							;
    162  30ba		       ae 14 43    iGetEOF    ldx	getlinx
    163  30bd		       a9 00		      lda	#0
    164  30bf		       9d 90 42 	      sta	LINBUF,x
    165  30c2		       a0 00		      ldy	#0
    166  30c4		       20 66 2d 	      jsr	SkipSpaces
    167  30c7		       20 50 1d 	      jsr	ParseInputLine
    168  30ca		       a9 4d		      lda	#TOKENBUFFER&$ff
    169  30cc		       85 4f		      sta	CURPTR
    170  30ce		       a9 1c		      lda	#TOKENBUFFER>>8
    171  30d0		       85 50		      sta	CURPTR+1
    172  30d2		       a9 01		      lda	#1
    173  30d4		       85 51		      sta	CUROFF
    174  30d6		       4c b1 02 	      jmp	NextIL
    175  30d9					      endif
    176  30d9
    177  30d9							;
    178  30d9							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    179  30d9							; DISK
    180  30d9							;
    181  30d9				   iDDIR
    182  30d9					      if	XKIM || CTMON65
    183  30d9		       20 30 f0 	      jsr	DiskDir
    184  30dc							;
    185  30dc							; Get/Display each entry
    186  30dc							;
    187  30dc		       a2 36	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    188  30de		       a0 74		      ldy	#DiskFileName&$ff
    189  30e0		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    190  30e3		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    191  30e5		       20 ad 21 	      jsr	puts
      0  30e8					      db	"   ",0
      1  30e8		       20 20 20 00	      .byte.b	"   ",0
    193  30ec							; Print the line to the console
    194  30ec		       a2 36		      ldx	#DiskFileName>>8	;pointer to buffer
    195  30ee		       a0 74		      ldy	#DiskFileName&$ff
    196  30f0		       a5 00		      lda	0
    197  30f2		       20 eb 21 	      jsr	PrtStr	;else print name
    198  30f5		       20 18 f0 	      jsr	crlf
    199  30f8
    200  30f8		       4c dc 30 	      jmp	DiskDirLoop	;do next entry
    201  30fb
    202  30fb		       4c b1 02    DiskDirEnd jmp	NextIL
    203  30fe					      endif
    204  30fe							;
    205  30fe							;=====================================================
    206  30fe							; Does a LIST to a Disk file.
    207  30fe							;
    208  30fe				   iDLIST
    209  30fe					      if	XKIM || CTMON65
    210  30fe		       20 39 31 	      jsr	SetOutDisk
    211  3101		       4c 3d 08 	      jmp	iLST2
    212  3104					      endif
    213  3104							;
    214  3104							;=====================================================
    215  3104							; Closes any pending disk file.  Okay to call if there
    216  3104							; is no open file.
    217  3104							;
    218  3104				   iDCLOSE
    219  3104					      if	XKIM || CTMON65
    220  3104		       20 42 f0 	      jsr	DiskClose
    221  3107		       4c b1 02 	      jmp	NextIL
    222  310a					      endif
    223  310a							;
    224  310a							;=====================================================
    225  310a							; This gets the next byte from an open disk file.  If
    226  310a							; there are no more bytes left, this returns C set.
    227  310a							; Else, C is clear and A contains the character.
    228  310a							;
    229  310a				   getNextFileByte
    230  310a					      if	XKIM || CTMON65
    231  310a		       ae 73 36 	      ldx	diskBufOffset
    232  310d		       ec 72 36 	      cpx	diskBufLength
    233  3110		       d0 14		      bne	hasdata	;branch if still data
    234  3112							;
    235  3112							; There is no data left in the buffer, so read a
    236  3112							; block from the SD system.
    237  3112							;
    238  3112		       a9 84		      lda	#BUFFER_SIZE
    239  3114		       a2 df		      ldx	#buffer>>8
    240  3116		       a0 0a		      ldy	#buffer&$ff
    241  3118		       20 3c f0 	      jsr	DiskRead
    242  311b		       b0 12		      bcs	getNextEof
    243  311d							;
    244  311d							; A contains the number of bytes actually read.
    245  311d							;
    246  311d		       8d 72 36 	      sta	diskBufLength	;save length
    247  3120		       c9 00		      cmp	#0	;shouldn't happen
    248  3122		       f0 0b		      beq	getNextEof
    249  3124							;
    250  3124		       a2 00		      ldx	#0
    251  3126		       bd 0a df    hasdata    lda	buffer,x
    252  3129		       e8		      inx
    253  312a		       8e 73 36 	      stx	diskBufOffset
    254  312d		       18		      clc
    255  312e		       60		      rts
    256  312f							;
    257  312f		       a9 00	   getNextEof lda	#0
    258  3131		       8d 73 36 	      sta	diskBufOffset
    259  3134		       8d 72 36 	      sta	diskBufLength
    260  3137		       38		      sec
    261  3138		       60		      rts
    262  3139							;
    263  3139							;=====================================================
    264  3139							; Set output vector to the disk output function
    265  3139							;
    266  3139		       a9 44	   SetOutDisk lda	#DOUT&$ff
    267  313b		       8d 66 36 	      sta	BOutVec
    268  313e		       a9 31		      lda	#DOUT/256
    269  3140		       8d 67 36 	      sta	BOutVec+1
    270  3143		       60		      rts
    271  3144							;
    272  3144							;=====================================================
    273  3144							; input a contains charater to write to open file
    274  3144							; output:
    275  3144							;	    C flag clear if no error
    276  3144							;
    277  3144		       8e 74 36    DOUT       stx	DiskFileName	; Save the x value, fulename not used
    278  3147		       8c 75 36 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    279  314a		       8d 0a df 	      sta	buffer	; Store the byte to send into the buffer
    280  314d		       a9 01		      lda	#1	; set number of bytes to send to 1
    281  314f		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    282  3151		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    283  3153		       20 3f f0 	      jsr	DiskWrite	; Place the character to disk if a file is open
    284  3156		       ae 74 36 	      ldx	DiskFileName	; Restore the x value that was saved
    285  3159		       ac 75 36 	      ldy	DiskFileName+1	; Restore the y value saved
    286  315c		       60		      rts
    287  315d							;=======================================================
    288  315d							; output:
    289  315d							;	  c flag is clear if no error, a contains bytes read
    290  315d							;	  c flag set Reached eof, a undefined
    291  315d							;
    292  315d		       8e 74 36    DIN	      stx	DiskFileName	; Save the x value, filename not used just storage
    293  3160		       8c 75 36 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    294  3163		       a9 01		      lda	#1	; set number of bytes to read to 1
    295  3165		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    296  3167		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    297  3169		       20 3c f0 	      jsr	DiskRead
    298  316c		       ad 0a df 	      lda	buffer	; Get the byte just read
    299  316f		       ae 74 36 	      ldx	DiskFileName
    300  3172		       ac 75 36 	      ldy	DiskFileName+1
    301  3175		       60		      rts
    302  3176
    303  3176							;========================================================
    304  3176							; Dstat / open/close/stat files
    305  3176				   DSTAT
    306  3176		       60		      rts
    307  3177							;========================================================
    308  3177					      endif
------- FILE mytb.asm
   2493  3177					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  3177					      include	"IL.inc"
      1  3177
      2  3177							;=====================================================
      3  3177							; IL.inc
      4  3177							; These are macros for IL instructions
      5  3177							;
      6  3177					      mac	dw
      7  3177					      .word	{0}
      8  3177					      endm
      9  3177					      mac	db
     10  3177					      .byte	{0}
     11  3177					      endm
     12  3177					      macro	xinit
     13  3177					      db	0
     14  3177					      endm		;reset the il to start clear all
     15  3177							;
     16  3177					      macro	done
     17  3177					      db	1
     18  3177					      endm		;print an error if not end of line
     19  3177							;
     20  3177					      macro	prs
     21  3177					      db	2
     22  3177					      endm		;print a quoted string
     23  3177							;
     24  3177					      macro	prn
     25  3177					      db	3
     26  3177					      endm		;print a number
     27  3177							;
     28  3177					      macro	spc
     29  3177					      db	4
     30  3177					      endm		;print space til new tabstop
     31  3177							;
     32  3177					      macro	nline
     33  3177					      db	5
     34  3177					      endm		;print a new line crlf
     35  3177							;
     36  3177							; My NXT is a bit different in that it takes one
     37  3177							; parameter, which is an address.  If the BASIC
     38  3177							; program is currently running then move to the
     39  3177							; next line and continue execution.  However, if
     40  3177							; in direct mode, jump to the specified IL label.
     41  3177							;
     42  3177					      macro	nxt
     43  3177					      db	6
     44  3177					      dw	{1}	; addr
     45  3177					      endm		; addr
     46  3177							;
     47  3177					      macro	xfer
     48  3177					      db	7
     49  3177					      endm
     50  3177							;
     51  3177					      macro	sav
     52  3177					      db	8
     53  3177					      db	{1}
     54  3177					      endm
     55  3177							;
     56  3177							;  Passed jump if function called, and true false value returned
     57  3177					      macro	rstr
     58  3177					      db	9
     59  3177					      db	({1}-*)-1	;(addr-*)-1
     60  3177					      db	{2}
     61  3177					      endm
     62  3177							;
     63  3177					      macro	cmpr
     64  3177					      db	10
     65  3177					      endm
     66  3177							;
     67  3177					      macro	innum
     68  3177					      db	11
     69  3177					      endm
     70  3177							;
     71  3177					      macro	fin
     72  3177					      db	12
     73  3177					      endm
     74  3177							;
     75  3177							; ERR is followed by an error number.	The error
     76  3177							; code is printed along with the line number.
     77  3177							; Control is passed to the statement set with
     78  3177							; the ERRGOTO statement.
     79  3177							;
     80  3177					      macro	errmsg
     81  3177					      db	13
     82  3177					      dw	{1}	;ecode
     83  3177					      endm		;ecode
     84  3177							;
     85  3177					      macro	add
     86  3177					      db	14
     87  3177					      endm
     88  3177							;
     89  3177					      macro	sub
     90  3177					      db	15
     91  3177					      endm
     92  3177							;
     93  3177					      macro	neg
     94  3177					      db	16
     95  3177					      endm
     96  3177							;
     97  3177					      macro	mul
     98  3177					      db	17
     99  3177					      endm
    100  3177							;
    101  3177					      macro	div
    102  3177					      db	18
    103  3177					      endm
    104  3177							;
    105  3177					      macro	store
    106  3177					      db	19
    107  3177					      endm
    108  3177							;
    109  3177					      macro	ind
    110  3177					      db	20
    111  3177					      endm
    112  3177							;
    113  3177					      macro	lst
    114  3177					      db	21
    115  3177					      endm
    116  3177							;
    117  3177					      macro	init
    118  3177					      db	22
    119  3177					      endm
    120  3177							;
    121  3177					      macro	getline
    122  3177					      db	23
    123  3177					      endm
    124  3177							;
    125  3177					      macro	insert
    126  3177					      db	24
    127  3177					      endm
    128  3177							;
    129  3177					      macro	rtn
    130  3177					      db	25
    131  3177					      endm
    132  3177							;
    133  3177					      macro	exit
    134  3177					      db	26
    135  3177					      endm
    136  3177							;
    137  3177					      macro	lit
    138  3177					      db	27
    139  3177					      dw	{1}	;value
    140  3177					      endm		; value LIT
    141  3177							;
    142  3177					      macro	call
    143  3177					      db	28
    144  3177					      dw	{1}	;addr
    145  3177					      endm		;addr
    146  3177							;
    147  3177							; IJMP will set the IL PC to the specified value.
    148  3177							;
    149  3177					      macro	ijmp
    150  3177					      db	29
    151  3177					      dw	{1}	;addr
    152  3177					      endm		;addr
    153  3177							;
    154  3177					      macro	vinit
    155  3177					      db	30
    156  3177					      endm
    157  3177							;
    158  3177							; ERRGOTO sets the point in the code where the IL
    159  3177							; interpreter will go after any error.
    160  3177							;
    161  3177					      macro	errgoto
    162  3177					      db	31
    163  3177					      dw	{1}	;addr
    164  3177					      endm		;addr
    165  3177							;
    166  3177					      macro	tst
    167  3177					      db	32
    168  3177					      db	({1}-*)-1	;(addr-*)-1
    169  3177					      db	{2},0	;string,0
    170  3177					      endm		;addr,string
    171  3177							;
    172  3177					      macro	tstv
    173  3177					      db	33
    174  3177					      db	({1}-*)-1	;(addr-*)-1
    175  3177					      endm		;addr
    176  3177							;
    177  3177					      macro	tstl
    178  3177					      db	34
    179  3177					      db	({1}-*)-1	;(addr-*)-1
    180  3177					      endm		;addr
    181  3177							;
    182  3177					      macro	tstn
    183  3177					      db	35
    184  3177					      db	({1}-*)-1	;(addr-*)-1
    185  3177					      endm		;addr
    186  3177							;
    187  3177							; FREE returns the amount of free RAM on top of
    188  3177							; the stack.  This is the amount of room the user
    189  3177							; program has available.
    190  3177							;
    191  3177					      macro	free
    192  3177					      db	36
    193  3177					      endm
    194  3177							;
    195  3177							; RANDOM takes the top item off the stack and
    196  3177							; replaces it with a random number that is
    197  3177							; MOD the initial value.  Ie, if the TOS is
    198  3177							; 42 then RANDOM returns a value from 0 to 41.
    199  3177							;
    200  3177					      macro	random
    201  3177					      db	37
    202  3177					      endm
    203  3177							;
    204  3177							; ABS will replace the top of stack with the
    205  3177							; absolute value.
    206  3177							;
    207  3177					      macro	abs
    208  3177					      db	38
    209  3177					      endm
    210  3177							;
    211  3177							; OPENREAD opens a file for reading, as in getting
    212  3177							; statements from it.
    213  3177							;
    214  3177					      macro	openread
    215  3177					      db	39
    216  3177					      endm
    217  3177							;
    218  3177							; OPENWRITE opens a file for writing, as in saving
    219  3177							; the current program to it.
    220  3177							;
    221  3177					      macro	openwrite
    222  3177					      db	40
    223  3177					      db	{1}	; 0= append 1 = create/truncate
    224  3177					      endm
    225  3177							;
    226  3177							; DCLOSE closes any open disk file.
    227  3177							;
    228  3177					      macro	dclose
    229  3177					      db	41
    230  3177					      endm
    231  3177							;
    232  3177							; DGETLINE gets one line from the disk file and puts it
    233  3177							; into LINBUFF.
    234  3177							;
    235  3177					      macro	dgetline
    236  3177					      db	42
    237  3177					      endm
    238  3177							;
    239  3177							; DLIST saves the program to an open disk file.
    240  3177							;
    241  3177					      macro	dlist
    242  3177					      db	43
    243  3177					      endm
    244  3177							; DDIR list the current directory
    245  3177							;
    246  3177					      macro	ddir
    247  3177					      db	44
    248  3177					      endm
    249  3177
    250  3177							; RMFILE remove a fle from disk
    251  3177					      macro	rmfile
    252  3177					      db	45
    253  3177					      endm
    254  3177
    255  3177							; CLEARSCREEN clear the screen
    256  3177					      macro	clearscreen
    257  3177					      db	46
    258  3177					      endm
    259  3177							; POKEMEM Poke value into memory
    260  3177					      macro	pokemem
    261  3177					      db	47
    262  3177					      endm
    263  3177							; PEEKMEM peek at value in memory
    264  3177					      macro	peekmem
    265  3177					      db	48
    266  3177					      endm
    267  3177							; TSTLET Test if the statement is a let without the keyword let
    268  3177					      macro	tstlet
    269  3177					      db	49
    270  3177					      db	({1}-*)-1	;(addr-*)-1
    271  3177					      endm		;addr
    272  3177							; TSTDONE if we reach the end of a statement
    273  3177					      macro	tstdone
    274  3177					      db	50
    275  3177					      db	({1}-*)-1	;(addr-*)-1
    276  3177					      endm		;addr
    277  3177							; GETCHAR	get a character from the input line leave it in RO
    278  3177					      macro	getchar
    279  3177					      db	51
    280  3177					      endm
    281  3177							; PUTCHAR	Put a character to the terminal
    282  3177					      macro	putchar
    283  3177					      db	52
    284  3177					      endm
    285  3177							; Call		Call a machine function return a to stack
    286  3177					      macro	callfunc
    287  3177					      db	53
    288  3177					      endm
    289  3177
    290  3177							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    291  3177					      macro	ibranch
    292  3177					      db	54
    293  3177					      endm
    294  3177
    295  3177							; TSTSTR	 Tests for the open quote in a string
    296  3177					      macro	tststr
    297  3177					      db	55
    298  3177					      db	({1}-*)-1	;(addr-*)-1
    299  3177					      endm
    300  3177							; SETIRQ	Sets the line number to run when an irq happens irq 550
    301  3177					      macro	setirq
    302  3177					      db	56
    303  3177					      endm
    304  3177
    305  3177							; TSTIRQ	Test for irq pending,
    306  3177							;		if so push the IRQ LINE NUMBER into RO, onto stack
    307  3177					      macro	tstirq
    308  3177					      db	57
    309  3177					      db	({1}-*)-1	;(addr-*)-1
    310  3177					      endm
    311  3177
    312  3177							; IRET    return from interupt service
    313  3177					      macro	iret
    314  3177					      db	58
    315  3177					      endm
    316  3177
    317  3177							; INSTR   read a string from the input
    318  3177					      macro	instr
    319  3177					      db	59
    320  3177					      endm
    321  3177
    322  3177							; MODULO Returns the remainder of the division
    323  3177					      macro	modulo
    324  3177					      db	60
    325  3177					      endm
    326  3177							; Set a task line
    327  3177					      macro	taskcreate
    328  3177					      db	61
    329  3177					      endm
    330  3177							; End a task
    331  3177					      macro	etask
    332  3177					      db	62
    333  3177					      endm
    334  3177							; Skip to next task
    335  3177					      macro	ntask
    336  3177					      db	63
    337  3177					      endm
    338  3177							; Subscript
    339  3177					      macro	subscript
    340  3177					      db	64
    341  3177					      db	{1}
    342  3177					      endm
    343  3177							; KILL Task
    344  3177					      macro	taskkill
    345  3177					      db	65
    346  3177					      endm
    347  3177							; STAT Task
    348  3177					      macro	taskstat
    349  3177					      db	66
    350  3177					      endm
    351  3177							;  output value as hex
    352  3177					      macro	hexprt
    353  3177					      db	67
    354  3177					      endm
    355  3177							;  Read in background has completed
    356  3177					      macro	readcomplete
    357  3177					      db	68
    358  3177					      endm
    359  3177							;  ReadInput line
    360  3177					      macro	readstart
    361  3177					      db	69
    362  3177					      endm
    363  3177							; Startio request
    364  3177					      macro	startio
    365  3177					      db	70
    366  3177					      endm
    367  3177							; Endio
    368  3177					      macro	endio
    369  3177					      db	71
    370  3177					      endm
    371  3177							; Logical not
    372  3177					      macro	lognot
    373  3177					      db	72
    374  3177					      endm
    375  3177							; Logical OR
    376  3177					      macro	logor
    377  3177					      db	73
    378  3177					      endm
    379  3177							;Logical and
    380  3177					      macro	logand
    381  3177					      db	74
    382  3177					      endm
    383  3177							;Logical XOR
    384  3177					      macro	logxor
    385  3177					      db	75
    386  3177					      endm
    387  3177							;Wait for task to complete, or list of tasks
    388  3177					      macro	wtask
    389  3177					      db	76
    390  3177					      db	({1}-*)-1	;(addr-*)-1
    391  3177					      endm
    392  3177							;Get the current task id
    393  3177					      MACRO	taskpid
    394  3177					      db	77
    395  3177					      endm
    396  3177							;Trace the basic execution
    397  3177					      Macro	traceprogram
    398  3177					      db	78
    399  3177					      endm
    400  3177							;Do a basic program Trace
    401  3177					      Macro	debugbasic
    402  3177					      db	79
    403  3177					      endm
    404  3177
    405  3177							; Inter Process communications instructions
    406  3177					      Macro	ipcsend
    407  3177					      db	80
    408  3177					      endm
    409  3177					      Macro	ipcreceive
    410  3177					      db	81
    411  3177					      endm
    412  3177					      Macro	ipccheck
    413  3177					      db	82
    414  3177					      endm
    415  3177					      Macro	ipcio
    416  3177					      db	83
    417  3177					      endm
    418  3177					      Macro	pushmathstack
    419  3177					      db	84
    420  3177					      endm
    421  3177					      Macro	popmathstack
    422  3177					      db	85
    423  3177					      endm
    424  3177					      Macro	savemathstack
    425  3177					      db	86
    426  3177					      endm
    427  3177					      Macro	restoremathstack
    428  3177					      db	87
    429  3177					      endm
    430  3177					      Macro	incparmcount
    431  3177					      db	88
    432  3177					      endm
    433  3177					      Macro	taskgetmathstack
    434  3177					      db	89
    435  3177					      endm
    436  3177					      Macro	taskenable
    437  3177					      db	90
    438  3177					      endm
    439  3177					      Macro	tasksuspend
    440  3177					      db	91
    441  3177					      endm
    442  3177					      Macro	taskputmathptr
    443  3177					      db	92
    444  3177					      endm
    445  3177							; Test for an extension type of variable that allows access to a tasks variables
    446  3177							; Using  PID!<Var name>
    447  3177					      Macro	tstvt
    448  3177					      db	93
    449  3177					      db	({1}-*)-1	;(addr-*)-1
    450  3177					      endm
    451  3177
    452  3177							; Provide access to R2 for the IL program
    453  3177					      Macro	setr2
    454  3177					      db	94
    455  3177					      db	{1}	; R2 is only one byte
    456  3177					      endm
    457  3177
    458  3177							;Move stack top to temp
    459  3177					      Macro	stk2tmp
    460  3177					      db	95
    461  3177					      endm
    462  3177
    463  3177					      Macro	tmp2stk
    464  3177					      db	96
    465  3177					      endm
    466  3177
    467  3177					      Macro	tstbyte
    468  3177					      db	97
    469  3177					      db	({1}-*)-1	; (addr-*)-1 goto if match
    470  3177					      dw	{2}	; address to check
    471  3177					      db	{3}	; Value to compare
    472  3177					      endm
    473  3177
    474  3177					      Macro	incvar
    475  3177					      db	98
    476  3177					      endm
    477  3177					      Macro	decvar
    478  3177					      db	99
    479  3177					      endm
    480  3177
    481  3177					      Macro	slice
    482  3177					      db	100
    483  3177					      endm
    484  3177
    485  3177					      Macro	tstb
    486  3177					      db	101
    487  3177					      db	({1}-*)-1
    488  3177					      db	{2}
    489  3177					      endm
    490  3177
    491  3177					      Macro	tstw
    492  3177					      db	102
    493  3177					      db	({1}-*)-1
    494  3177					      dw	{2}
    495  3177					      endm
    496  3177
    497  3177					      Macro	ongoto
    498  3177					      db	103
    499  3177					      dw	{1}
    500  3177					      dw	{2}
    501  3177					      endm
    502  3177
    503  3177					      Macro	tstrelop
    504  3177					      db	104
    505  3177					      db	({1}-*)-1
    506  3177					      endm
    507  3177
    508  3177					      Macro	repeatline
    509  3177					      db	105
    510  3177					      endm
    511  3177
    512  3177							; Check for a precompiled branch, will take branch if precompiled value present
    513  3177					      Macro	tstbranch
    514  3177					      db	106
    515  3177					      db	({1}-*)-1
    516  3177					      endm
    517  3177
    518  3177					      Macro	fastxfer
    519  3177					      db	107
    520  3177					      endm
    521  3177
    522  3177							; Set all io to to a terminal for input output
    523  3177							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    524  3177							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    525  3177					      Macro	setterminal
    526  3177					      db	108
    527  3177					      endm
    528  3177
    529  3177							;Fetch a single byte from memory
    530  3177					      Macro	indb
    531  3177					      db	109
    532  3177					      endm
    533  3177
    534  3177							; Set a block of memory to a fixed value, byte or word
    535  3177							; Stack must contain destiniation address, length to set in bytes, value {byte of word} to initialize to
    536  3177					      Macro	setblock
    537  3177					      db	110
    538  3177					      db	{1}	; the data type to initialize	tByte or tInteger
    539  3177					      endm
    540  3177
    541  3177							; Copy a block of memory
    542  3177							; Stack must contain source address, destination address, length in bytes
    543  3177					      Macro	copyblock
    544  3177					      db	111
    545  3177					      endm
    546  3177
    547  3177							; Compare one block of memory to another
    548  3177							; Stack contains Length, Source1 Source 2
    549  3177							; Place on stack 0 equal, 1 s1>s2, -1 s1 < s2
    550  3177					      Macro	cmpmem
    551  3177					      db	112
    552  3177					      endm
    553  3177
    554  3177							; Shift Left and Right
    555  3177					      Macro	shift
    556  3177					      db	113
    557  3177					      db	{1}	; direction  0 = left 1 = right
    558  3177					      endm
    559  3177
    560  3177							; set of timer macros
    561  3177					      Macro	timerset
    562  3177					      db	114,1
    563  3177					      db	{1}	; value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    564  3177					      endm
    565  3177
    566  3177					      Macro	timerstop
    567  3177					      db	114,0,0
    568  3177					      endm
    569  3177
    570  3177					      Macro	timervaluelow
    571  3177					      db	114,2,0
    572  3177					      endm
    573  3177
    574  3177					      Macro	timervaluehigh
    575  3177					      db	114,3,0
    576  3177					      endm
    577  3177
    578  3177					      Macro	timer
    579  3177					      db	114
    580  3177					      endm
------- FILE mytb.asm
   2495  3177							;
   2496  3177				  -	      if	FIXED
   2497  3177				  -	      org	$1000
   2498  3177					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  3177					      include	"basic.il"
      1  3177					      seg	Code
      2  3177							; on goto table
      3  3177							; format :   first byte is value Base, subtracted from value found
      4  3177							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  3177				   BasicStmts
      0  3177					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  3177		       01 23		      .byte.b	kBeginKey,(kKeyCount+1)
      0  3179					      dw	ekLet
      1  3179		       06 32		      .word.w	ekLet
      0  317b					      dw	ekInc
      1  317b		       38 32		      .word.w	ekInc
      0  317d					      dw	ekDec
      1  317d		       45 32		      .word.w	ekDec
      0  317f					      dw	ekIreturn
      1  317f		       52 32		      .word.w	ekIreturn
      0  3181					      dw	ekIf
      1  3181		       57 32		      .word.w	ekIf
      0  3183					      dw	ekThen
      1  3183		       5d 32		      .word.w	ekThen
      0  3185					      dw	ekGoto
      1  3185		       61 32		      .word.w	ekGoto
      0  3187					      dw	ekGosub
      1  3187		       08 36		      .word.w	ekGosub
      0  3189					      dw	ekReturn
      1  3189		       16 36		      .word.w	ekReturn
      0  318b					      dw	ekRem
      1  318b		       75 32		      .word.w	ekRem
      0  318d					      dw	ekPrint	; should be entry for print
      1  318d		       8b 32		      .word.w	ekPrint
      0  318f					      dw	ekTaske
      1  318f		       d8 32		      .word.w	ekTaske
      0  3191					      dw	ekTaskn
      1  3191		       ee 32		      .word.w	ekTaskn
      0  3193					      dw	ekTaskw
      1  3193		       f5 32		      .word.w	ekTaskw
      0  3195					      dw	ekPoke
      1  3195		       10 33		      .word.w	ekPoke
      0  3197					      dw	ekPutch
      1  3197		       72 33		      .word.w	ekPutch
      0  3199					      dw	ekCls
      1  3199		       7d 33		      .word.w	ekCls
      0  319b					      dw	ekInput
      1  319b		       84 33		      .word.w	ekInput
      0  319d					      dw	ekEnd
      1  319d		       b2 33		      .word.w	ekEnd
      0  319f					      dw	ekIrq
      1  319f		       b6 33		      .word.w	ekIrq
      0  31a1					      dw	ekKill
      1  31a1		       c1 33		      .word.w	ekKill
      0  31a3					      dw	ekList
      1  31a3		       cc 33		      .word.w	ekList
      0  31a5					      dw	ekRun
      1  31a5		       d1 33		      .word.w	ekRun
      0  31a7					      dw	ekNew
      1  31a7		       da 33		      .word.w	ekNew
      0  31a9					      dw	ekSlice
      1  31a9		       de 33		      .word.w	ekSlice
      0  31ab					      dw	ekTrace
      1  31ab		       e9 33		      .word.w	ekTrace
      0  31ad					      dw	ekExit
      1  31ad		       fa 33		      .word.w	ekExit
      0  31af					      dw	ekSave
      1  31af		       fb 33		      .word.w	ekSave
      0  31b1					      dw	ekLoad
      1  31b1		       02 34		      .word.w	ekLoad
      0  31b3					      dw	ekErase
      1  31b3		       12 34		      .word.w	ekErase
      0  31b5					      dw	ekDir
      1  31b5		       0e 34		      .word.w	ekDir
      0  31b7					      dw	ekSetTerm
      1  31b7		       7b 32		      .word.w	ekSetTerm
      0  31b9					      dw	ekSetMemB
      1  31b9		       27 33		      .word.w	ekSetMemB
      0  31bb					      dw	ekSetMemW
      1  31bb		       33 33		      .word.w	ekSetMemW
      0  31bd					      dw	ekCopyMem
      1  31bd		       55 33		      .word.w	ekCopyMem
     42  31bf							;
     43  31bf							; Logical operators
      0  31bf				   BasicLogical db	kOr,3
      1  31bf		       25 03		      .byte.b	kOr,3
      0  31c1					      dw	ekOr
      1  31c1		       40 34		      .word.w	ekOr
      0  31c3					      dw	ekXor
      1  31c3		       45 34		      .word.w	ekXor
      0  31c5					      dw	ekAnd
      1  31c5		       3b 34		      .word.w	ekAnd
     48  31c7
      0  31c7				   BasicShift db	kShr,2
      1  31c7		       28 02		      .byte.b	kShr,2
      0  31c9					      dw	ekShiftRight
      1  31c9		       30 34		      .word.w	ekShiftRight
      0  31cb					      dw	ekShiftLeft
      1  31cb		       2a 34		      .word.w	ekShiftLeft
     52  31cd
     53  31cd							;functions returning values
     54  31cd
      0  31cd				   BasicFuncs db	kBeginFunc,kFuncCount
      1  31cd		       2a 12		      .byte.b	kBeginFunc,kFuncCount
      0  31cf					      dw	ekTrue
      1  31cf		       a5 34		      .word.w	ekTrue
      0  31d1					      dw	ekFalse
      1  31d1		       a9 34		      .word.w	ekFalse
      0  31d3					      dw	ekFree
      1  31d3		       ad 34		      .word.w	ekFree
      0  31d5					      dw	ekGetch
      1  31d5		       b5 34		      .word.w	ekGetch
      0  31d7					      dw	ekPeek
      1  31d7		       fa 34		      .word.w	ekPeek
      0  31d9					      dw	ekTask
      1  31d9		       05 35		      .word.w	ekTask
      0  31db					      dw	ekIpcc
      1  31db		       51 35		      .word.w	ekIpcc
      0  31dd					      dw	ekIpcs
      1  31dd		       2c 35		      .word.w	ekIpcs
      0  31df					      dw	ekIpcr
      1  31df		       3d 35		      .word.w	ekIpcr
      0  31e1					      dw	ekRnd
      1  31e1		       5c 35		      .word.w	ekRnd
      0  31e3					      dw	ekStat
      1  31e3		       7a 35		      .word.w	ekStat
      0  31e5					      dw	ekAbs
      1  31e5		       6f 35		      .word.w	ekAbs
      0  31e7					      dw	ekCall
      1  31e7		       87 35		      .word.w	ekCall
      0  31e9					      dw	ekGofn
      1  31e9		       0f 36		      .word.w	ekGofn
      0  31eb					      dw	ekPid
      1  31eb		       85 35		      .word.w	ekPid
      0  31ed					      dw	ekAddr
      1  31ed		       bd 34		      .word.w	ekAddr
      0  31ef					      dw	ekCmpMem
      1  31ef		       cc 34		      .word.w	ekCmpMem
      0  31f1					      dw	eKTimer
      1  31f1		       e3 34		      .word.w	eKTimer
     74  31f3							;====================================================
     75  31f3							; file constants
     76  31f3		       00 00	   OPEN_APPEND equ	0	; append to file
     77  31f3		       00 01	   OPEN_CREATE equ	1	; truncate/create file
     78  31f3
     79  31f3							;=====================================================
     80  31f3							; This is the IL of the BASIC (or whatever) language.
     81  31f3							; Because of the way macros are implemented by as65,
     82  31f3							; labels can't be on the same line as a macro
     83  31f3							; invocation, so that's why labels are on separate
     84  31f3							; lines.
     85  31f3							;
     86  31f3		       31 f3	   IL	      equ	*
     87  31f3
     88  31f3							;THE IL CONTROL SECTION
     89  31f3
     90  31f3				   START
      0  31f3					      INIT		;INITIALIZE
      0  31f3					      db	22
      1  31f3		       16		      .byte.b	22
      0  31f4					      NLINE		;WRITE CRLF
      0  31f4					      db	5
      1  31f4		       05		      .byte.b	5
      0  31f5					      ERRGOTO	CO	;where to go after an error
      0  31f5					      db	31
      1  31f5		       1f		      .byte.b	31
      0  31f6					      dw	CO
      1  31f6		       f9 31		      .word.w	CO
      0  31f8					      VINIT		;clear all variables
      0  31f8					      db	30
      1  31f8		       1e		      .byte.b	30
     95  31f9							;
     96  31f9							; This is where we jump to get a line of commands or
     97  31f9							; a program from the user.
     98  31f9							;
     99  31f9				   CO
      0  31f9					      GETLINE		;WRITE PROMPT AND GET LINE
      0  31f9					      db	23
      1  31f9		       17		      .byte.b	23
      0  31fa					      TSTL	XEC	;TEST FOR LINE NUMBER, if none then execute the line
      0  31fa					      db	34
      1  31fa		       22		      .byte.b	34
      0  31fb					      db	(XEC-*)-1
      1  31fb		       04		      .byte.b	(XEC-*)-1
      0  31fc					      INSERT		;INSERT IT (MAY BE DELETE)
      0  31fc					      db	24
      1  31fc		       18		      .byte.b	24
      0  31fd					      IJMP	CO
      0  31fd					      db	29
      1  31fd		       1d		      .byte.b	29
      0  31fe					      dw	CO
      1  31fe		       f9 31		      .word.w	CO
    104  3200				   XEC
      0  3200					      XINIT		;INITIALIZE
      0  3200					      db	0
      1  3200		       00		      .byte.b	0
    106  3201							;============================================================================
    107  3201							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
    108  3201							;
    109  3201				   STMT
      0  3201					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  3201					      db	57
      1  3201		       39		      .byte.b	57
      0  3202					      db	(notirq-*)-1
      1  3202		       00		      .byte.b	(notirq-*)-1
    111  3203							;==========================================================================================
    112  3203							; Process a let statement implied or explicit.
    113  3203							;
    114  3203				   notirq
      0  3203					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  3203					      db	79
      1  3203		       4f		      .byte.b	79
      0  3204					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  3204					      db	49
      1  3204		       31		      .byte.b	49
      0  3205					      db	(DoVector-*)-1
      1  3205		       2d		      .byte.b	(DoVector-*)-1
    117  3206				   ekLet
      0  3206					      TSTV	DoVector	; Test for variable
      0  3206					      db	33
      1  3206		       21		      .byte.b	33
      0  3207					      db	(DoVector-*)-1
      1  3207		       2b		      .byte.b	(DoVector-*)-1
      0  3208					      CALL	FactVarPtrNoTst	; get a pointer to the variable
      0  3208					      db	28
      1  3208		       1c		      .byte.b	28
      0  3209					      dw	FactVarPtrNoTst
      1  3209		       ce 35		      .word.w	FactVarPtrNoTst
    120  320b
    121  320b				   LETINDEX_ALL
      0  320b					      TSTB	ERRMissingEquals,oEqual	; (This line originally omitted)
      0  320b					      db	101
      1  320b		       65		      .byte.b	101
      0  320c					      db	(ERRMissingEquals-*)-1
      1  320c		       20		      .byte.b	(ERRMissingEquals-*)-1
      0  320d					      db	oEqual
      1  320d		       f2		      .byte.b	oEqual
    123  320e				   LETBE
      0  320e					      TSTBYTE	LETAssignByte,R2,tByte	; Check for a byte conversion
      0  320e					      db	97
      1  320e		       61		      .byte.b	97
      0  320f					      db	(LETAssignByte-*)-1
      1  320f		       10		      .byte.b	(LETAssignByte-*)-1
      0  3210					      dw	R2
      1  3210		       58 00		      .word.w	R2
      0  3212					      db	tByte
      1  3212		       a2		      .byte.b	tByte
      0  3213					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  3213					      db	28
      1  3213		       1c		      .byte.b	28
      0  3214					      dw	EXPR
      1  3214		       1a 34		      .word.w	EXPR
      0  3216					      DONE		; REPORT ERROR IF NOT NEXT
      0  3216					      db	1
      1  3216		       01		      .byte.b	1
      0  3217					      SETR2	tInteger	; Store an integer type
      0  3217					      db	94
      1  3217		       5e		      .byte.b	94
      0  3218					      db	tInteger
      1  3218		       a4		      .byte.b	tInteger
      0  3219					      STORE		; STORE RESULT at variable address
      0  3219					      db	19
      1  3219		       13		      .byte.b	19
      0  321a					      NXT	CO	; AND SEQUENCE TO NEXT
      0  321a					      db	6
      1  321a		       06		      .byte.b	6
      0  321b					      dw	CO
      1  321b		       f9 31		      .word.w	CO
      0  321d					      IJMP	STMT	; Next statement
      0  321d					      db	29
      1  321d		       1d		      .byte.b	29
      0  321e					      dw	STMT
      1  321e		       01 32		      .word.w	STMT
    131  3220
    132  3220				   LETAssignByte
      0  3220					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  3220					      db	28
      1  3220		       1c		      .byte.b	28
      0  3221					      dw	EXPR
      1  3221		       1a 34		      .word.w	EXPR
      0  3223					      DONE		; REPORT ERROR IF NOT NEXT
      0  3223					      db	1
      1  3223		       01		      .byte.b	1
      0  3224					      SETR2	tByte	; Set to store a byte value
      0  3224					      db	94
      1  3224		       5e		      .byte.b	94
      0  3225					      db	tByte
      1  3225		       a2		      .byte.b	tByte
      0  3226					      STORE		; STORE RESULT at variable address
      0  3226					      db	19
      1  3226		       13		      .byte.b	19
      0  3227					      NXT	CO	; AND SEQUENCE TO NEXT
      0  3227					      db	6
      1  3227		       06		      .byte.b	6
      0  3228					      dw	CO
      1  3228		       f9 31		      .word.w	CO
      0  322a					      IJMP	STMT	; Next statement
      0  322a					      db	29
      1  322a		       1d		      .byte.b	29
      0  322b					      dw	STMT
      1  322b		       01 32		      .word.w	STMT
    139  322d
    140  322d				   ERRMissingEquals
      0  322d					      ERRMSG	ERR_MISSINGEQUALSIGN	; Missing asignment
      0  322d					      db	13
      1  322d		       0d		      .byte.b	13
      0  322e					      dw	ERR_MISSINGEQUALSIGN
      1  322e		       18 00		      .word.w	ERR_MISSINGEQUALSIGN
    142  3230
    143  3230				   ERRVEC2
      0  3230					      IJMP	UNKNOWN
      0  3230					      db	29
      1  3230		       1d		      .byte.b	29
      0  3231					      dw	UNKNOWN
      1  3231		       16 34		      .word.w	UNKNOWN
    145  3233							;=============================================================
    146  3233							;Branch on a valid statement start
    147  3233				   DoVector
      0  3233					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  3233					      db	103
      1  3233		       67		      .byte.b	103
      0  3234					      dw	BasicStmts
      1  3234		       77 31		      .word.w	BasicStmts
      0  3236					      dw	UNKNOWN
      1  3236		       16 34		      .word.w	UNKNOWN
    149  3238							;This will never return here!
    150  3238							;=============================================================
    151  3238							; Inc or dec a variable
    152  3238				   ekInc
      0  3238					      TSTV	ERRVEC2	; Verify we have a variable
      0  3238					      db	33
      1  3238		       21		      .byte.b	33
      0  3239					      db	(ERRVEC2-*)-1
      1  3239		       f6		      .byte.b	(ERRVEC2-*)-1
      0  323a					      CALL	FactVarPtrNoTst	; Get a pointer to the memory location to increment
      0  323a					      db	28
      1  323a		       1c		      .byte.b	28
      0  323b					      dw	FactVarPtrNoTst
      1  323b		       ce 35		      .word.w	FactVarPtrNoTst
    155  323d							;	  TSTB	     eDoInc,oBang		    ; Allow to inc or dec other tasks variables
    156  323d							;	  IND					    ; we just got a pid
    157  323d							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    158  323d				   eDoInc
      0  323d					      INCVAR		; Do the increment of the variable
      0  323d					      db	98
      1  323d		       62		      .byte.b	98
      0  323e					      DONE		; Test for end of line or end of statement ":"
      0  323e					      db	1
      1  323e		       01		      .byte.b	1
      0  323f					      NXT	CO	; Get the next statement, branch CO if end of program
      0  323f					      db	6
      1  323f		       06		      .byte.b	6
      0  3240					      dw	CO
      1  3240		       f9 31		      .word.w	CO
      0  3242					      IJMP	STMT	; Process the next statement
      0  3242					      db	29
      1  3242		       1d		      .byte.b	29
      0  3243					      dw	STMT
      1  3243		       01 32		      .word.w	STMT
    163  3245							;S1Dec:
    164  3245							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    165  3245				   ekDec
      0  3245					      TSTV	ERRVEC2	; Must be followed by a variable
      0  3245					      db	33
      1  3245		       21		      .byte.b	33
      0  3246					      db	(ERRVEC2-*)-1
      1  3246		       e9		      .byte.b	(ERRVEC2-*)-1
      0  3247					      CALL	FactVarPtrNoTst	; Get a pointer to the variable to update
      0  3247					      db	28
      1  3247		       1c		      .byte.b	28
      0  3248					      dw	FactVarPtrNoTst
      1  3248		       ce 35		      .word.w	FactVarPtrNoTst
    168  324a							;	  TSTB	     eDoDec,oBang		    ; Allow to inc or dec other tasks variables
    169  324a							;	  IND					    ; we just got a pid
    170  324a							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    171  324a				   eDoDec
      0  324a					      DECVAR		; Decrement the actual variable
      0  324a					      db	99
      1  324a		       63		      .byte.b	99
      0  324b					      DONE		; Test if end of line or : statement
      0  324b					      db	1
      1  324b		       01		      .byte.b	1
      0  324c					      NXT	CO	; If at end of program then got the console
      0  324c					      db	6
      1  324c		       06		      .byte.b	6
      0  324d					      dw	CO
      1  324d		       f9 31		      .word.w	CO
      0  324f					      IJMP	STMT	; Process the next statement of command line
      0  324f					      db	29
      1  324f		       1d		      .byte.b	29
      0  3250					      dw	STMT
      1  3250		       01 32		      .word.w	STMT
    176  3252							;=============================================================================================================================
    177  3252							; iret or ireturn, Return from interupt process
    178  3252							;
    179  3252							;S1Iret:
    180  3252							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    181  3252							;S1Sa:
    182  3252				   ekIreturn
      0  3252					      DONE		; Must be only thing on the line
      0  3252					      db	1
      1  3252		       01		      .byte.b	1
      0  3253					      IRET		; RESTORE LINE NUMBER OF CALL
      0  3253					      db	58
      1  3253		       3a		      .byte.b	58
      0  3254					      IJMP	STMT
      0  3254					      db	29
      1  3254		       1d		      .byte.b	29
      0  3255					      dw	STMT
      1  3255		       01 32		      .word.w	STMT
    186  3257							;==============================================================================================================================
    187  3257							;Process if statement, if true then process all statements until end of line reached
    188  3257							;S1S1:
    189  3257							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    190  3257				   ekIf
      0  3257					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  3257					      db	28
      1  3257		       1c		      .byte.b	28
      0  3258					      dw	EXPR
      1  3258		       1a 34		      .word.w	EXPR
      0  325a					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  325a					      db	101
      1  325a		       65		      .byte.b	101
      0  325b					      db	(S1W-*)-1
      1  325b		       01		      .byte.b	(S1W-*)-1
      0  325c					      db	kThen
      1  325c		       06		      .byte.b	kThen
    193  325d				   ekThen
    194  325d				   S1W
      0  325d					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  325d					      db	54
      1  325d		       36		      .byte.b	54
      0  325e					      IJMP	STMT
      0  325e					      db	29
      1  325e		       1d		      .byte.b	29
      0  325f					      dw	STMT
      1  325f		       01 32		      .word.w	STMT
    197  3261							;===============================================================================================================================
    198  3261							; Test for GOTO
    199  3261							;S1Z:
    200  3261							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    201  3261							;
    202  3261				   ekGoto
      0  3261					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  3261					      db	106
      1  3261		       6a		      .byte.b	106
      0  3262					      db	(ekGotoCompiled-*)-1
      1  3262		       0e		      .byte.b	(ekGotoCompiled-*)-1
    204  3263							; Else we have the address and just goto that address
      0  3263					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  3263					      db	101
      1  3263		       65		      .byte.b	101
      0  3264					      db	(ekGotoLine-*)-1
      1  3264		       05		      .byte.b	(ekGotoLine-*)-1
      0  3265					      db	oPeriod
      1  3265		       e9		      .byte.b	oPeriod
      0  3266					      REPEATLINE		; Repeat the same line again
      0  3266					      db	105
      1  3266		       69		      .byte.b	105
      0  3267					      IJMP	STMT	; Go do the statement
      0  3267					      db	29
      1  3267		       1d		      .byte.b	29
      0  3268					      dw	STMT
      1  3268		       01 32		      .word.w	STMT
    208  326a
    209  326a				   ekGotoLine
      0  326a					      CALL	EXPR	; GET LABEL
      0  326a					      db	28
      1  326a		       1c		      .byte.b	28
      0  326b					      dw	EXPR
      1  326b		       1a 34		      .word.w	EXPR
      0  326d					      lit	0	; Place indicator for line num on stack
      0  326d					      db	27
      1  326d		       1b		      .byte.b	27
      0  326e					      dw	0
      1  326e		       00 00		      .word.w	0
      0  3270					      FASTXFER
      0  3270					      db	107
      1  3270		       6b		      .byte.b	107
    213  3271				   ekGotoCompiled
      0  3271					      lit	1	; tell it that mempointer on the stack
      0  3271					      db	27
      1  3271		       1b		      .byte.b	27
      0  3272					      dw	1
      1  3272		       01 00		      .word.w	1
      0  3274					      FASTXFER		; put top of stack into curptr
      0  3274					      db	107
      1  3274		       6b		      .byte.b	107
    216  3275
    217  3275
    218  3275							;==================================================================================================================================
    219  3275							; Process REM statement
    220  3275							;
    221  3275							;S2a:
    222  3275							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    223  3275				   ekRem
      0  3275					      NXT	CO	; The rest of the line is ignored
      0  3275					      db	6
      1  3275		       06		      .byte.b	6
      0  3276					      dw	CO
      1  3276		       f9 31		      .word.w	CO
      0  3278					      IJMP	STMT	; Process the next statement
      0  3278					      db	29
      1  3278		       1d		      .byte.b	29
      0  3279					      dw	STMT
      1  3279		       01 32		      .word.w	STMT
    226  327b							;====================================================================================================================================
    227  327b							; Set the Task input output slot each slot is 16 byte starting at e000
    228  327b							; so 0,1,...
    229  327b				   ekSetTerm
      0  327b					      CALL	EXPR
      0  327b					      db	28
      1  327b		       1c		      .byte.b	28
      0  327c					      dw	EXPR
      1  327c		       1a 34		      .word.w	EXPR
      0  327e					      TSTB	ERRVEC,oComma
      0  327e					      db	101
      1  327e		       65		      .byte.b	101
      0  327f					      db	(ERRVEC-*)-1
      1  327f		       2f		      .byte.b	(ERRVEC-*)-1
      0  3280					      db	oComma
      1  3280		       e2		      .byte.b	oComma
      0  3281					      CALL	EXPR
      0  3281					      db	28
      1  3281		       1c		      .byte.b	28
      0  3282					      dw	EXPR
      1  3282		       1a 34		      .word.w	EXPR
      0  3284					      SETTERMINAL
      0  3284					      db	108
      1  3284		       6c		      .byte.b	108
      0  3285					      NXT	CO	;Next statement to execute
      0  3285					      db	6
      1  3285		       06		      .byte.b	6
      0  3286					      dw	CO
      1  3286		       f9 31		      .word.w	CO
      0  3288					      IJMP	STMT
      0  3288					      db	29
      1  3288		       1d		      .byte.b	29
      0  3289					      dw	STMT
      1  3289		       01 32		      .word.w	STMT
    236  328b							;==================================================================================================================================
    237  328b							; Print statement
    238  328b							;
    239  328b							;S3:
    240  328b							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    241  328b				   ekPrint
      0  328b					      STARTIO		; Lock task until io completes
      0  328b					      db	70
      1  328b		       46		      .byte.b	70
    243  328c				   S4
      0  328c					      TSTDONE	S4a	; Test if we just want crlf printed
      0  328c					      db	50
      1  328c		       32		      .byte.b	50
      0  328d					      db	(S4a-*)-1
      1  328d		       03		      .byte.b	(S4a-*)-1
      0  328e					      IJMP	S6
      0  328e					      db	29
      1  328e		       1d		      .byte.b	29
      0  328f					      dw	S6
      1  328f		       a6 32		      .word.w	S6
    246  3291
    247  3291				   S4a
      0  3291					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  3291					      db	101
      1  3291		       65		      .byte.b	101
      0  3292					      db	(S7-*)-1
      1  3292		       1f		      .byte.b	(S7-*)-1
      0  3293					      db	tString
      1  3293		       a0		      .byte.b	tString
      0  3294					      PRS		; PRINT STRING
      0  3294					      db	2
      1  3294		       02		      .byte.b	2
    250  3295				   S5
      0  3295					      TSTB	S6A,oComma	; IS THERE MORE?
      0  3295					      db	101
      1  3295		       65		      .byte.b	101
      0  3296					      db	(S6A-*)-1
      1  3296		       07		      .byte.b	(S6A-*)-1
      0  3297					      db	oComma
      1  3297		       e2		      .byte.b	oComma
      0  3298					      SPC		; SPACE TO NEXT ZONE
      0  3298					      db	4
      1  3298		       04		      .byte.b	4
      0  3299					      TSTDONE	S4	; Not end of line jump back
      0  3299					      db	50
      1  3299		       32		      .byte.b	50
      0  329a					      db	(S4-*)-1
      1  329a		       f1		      .byte.b	(S4-*)-1
      0  329b					      IJMP	S6Z	; YES JUMP BACK
      0  329b					      db	29
      1  329b		       1d		      .byte.b	29
      0  329c					      dw	S6Z
      1  329c		       a8 32		      .word.w	S6Z
    255  329e
    256  329e							;
    257  329e							; If a semicolon, don't do anything.
    258  329e							;
    259  329e				   S6A
      0  329e					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  329e					      db	101
      1  329e		       65		      .byte.b	101
      0  329f					      db	(S6-*)-1
      1  329f		       06		      .byte.b	(S6-*)-1
      0  32a0					      db	oSemiColon
      1  32a0		       e3		      .byte.b	oSemiColon
      0  32a1					      TSTDONE	S4	; Jump Back if not end of line
      0  32a1					      db	50
      1  32a1		       32		      .byte.b	50
      0  32a2					      db	(S4-*)-1
      1  32a2		       e9		      .byte.b	(S4-*)-1
      0  32a3					      IJMP	S6Z
      0  32a3					      db	29
      1  32a3		       1d		      .byte.b	29
      0  32a4					      dw	S6Z
      1  32a4		       a8 32		      .word.w	S6Z
    263  32a6
    264  32a6				   S6
    265  32a6
      0  32a6					      DONE		; ERROR IF CR NOT NEXT
      0  32a6					      db	1
      1  32a6		       01		      .byte.b	1
      0  32a7					      NLINE
      0  32a7					      db	5
      1  32a7		       05		      .byte.b	5
    268  32a8				   S6Z
      0  32a8					      ENDIO		; release task io completed
      0  32a8					      db	71
      1  32a8		       47		      .byte.b	71
      0  32a9					      NXT	CO	; exit here if , or ; at end of print
      0  32a9					      db	6
      1  32a9		       06		      .byte.b	6
      0  32aa					      dw	CO
      1  32aa		       f9 31		      .word.w	CO
      0  32ac					      IJMP	STMT
      0  32ac					      db	29
      1  32ac		       1d		      .byte.b	29
      0  32ad					      dw	STMT
      1  32ad		       01 32		      .word.w	STMT
    272  32af							;
    273  32af							; A jump for code too far away for relative branch
    274  32af							;
    275  32af				   ERRVEC
      0  32af					      IJMP	UNKNOWN
      0  32af					      db	29
      1  32af		       1d		      .byte.b	29
      0  32b0					      dw	UNKNOWN
      1  32b0		       16 34		      .word.w	UNKNOWN
    277  32b2							;
    278  32b2							; Get here if there is an expression to print
    279  32b2				   S7
      0  32b2					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  32b2					      db	101
      1  32b2		       65		      .byte.b	101
      0  32b3					      db	(S7AUnsigned-*)-1
      1  32b3		       08		      .byte.b	(S7AUnsigned-*)-1
      0  32b4					      db	oDollar
      1  32b4		       e7		      .byte.b	oDollar
      0  32b5					      CALL	EXPR
      0  32b5					      db	28
      1  32b5		       1c		      .byte.b	28
      0  32b6					      dw	EXPR
      1  32b6		       1a 34		      .word.w	EXPR
      0  32b8					      HEXPRT
      0  32b8					      db	67
      1  32b8		       43		      .byte.b	67
      0  32b9					      IJMP	S5
      0  32b9					      db	29
      1  32b9		       1d		      .byte.b	29
      0  32ba					      dw	S5
      1  32ba		       95 32		      .word.w	S5
    284  32bc
    285  32bc				   S7AUnsigned
    286  32bc
      0  32bc					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  32bc					      db	101
      1  32bc		       65		      .byte.b	101
      0  32bd					      db	(S7A-*)-1
      1  32bd		       0a		      .byte.b	(S7A-*)-1
      0  32be					      db	oPercent
      1  32be		       ed		      .byte.b	oPercent
      0  32bf					      CALL	EXPR
      0  32bf					      db	28
      1  32bf		       1c		      .byte.b	28
      0  32c0					      dw	EXPR
      1  32c0		       1a 34		      .word.w	EXPR
      0  32c2					      SETR2	tUint
      0  32c2					      db	94
      1  32c2		       5e		      .byte.b	94
      0  32c3					      db	tUint
      1  32c3		       a9		      .byte.b	tUint
      0  32c4					      PRN
      0  32c4					      db	3
      1  32c4		       03		      .byte.b	3
      0  32c5					      IJMP	S5
      0  32c5					      db	29
      1  32c5		       1d		      .byte.b	29
      0  32c6					      dw	S5
      1  32c6		       95 32		      .word.w	S5
    292  32c8
    293  32c8				   S7A
    294  32c8
      0  32c8					      CALL	EXPR
      0  32c8					      db	28
      1  32c8		       1c		      .byte.b	28
      0  32c9					      dw	EXPR
      1  32c9		       1a 34		      .word.w	EXPR
      0  32cb					      TSTB	S7B,oDollar	; Print the value as a single character
      0  32cb					      db	101
      1  32cb		       65		      .byte.b	101
      0  32cc					      db	(S7B-*)-1
      1  32cc		       05		      .byte.b	(S7B-*)-1
      0  32cd					      db	oDollar
      1  32cd		       e7		      .byte.b	oDollar
      0  32ce					      PUTCHAR
      0  32ce					      db	52
      1  32ce		       34		      .byte.b	52
      0  32cf					      IJMP	S5
      0  32cf					      db	29
      1  32cf		       1d		      .byte.b	29
      0  32d0					      dw	S5
      1  32d0		       95 32		      .word.w	S5
    299  32d2
    300  32d2				   S7B
      0  32d2					      SETR2	tInteger	; Print the value as a signed number
      0  32d2					      db	94
      1  32d2		       5e		      .byte.b	94
      0  32d3					      db	tInteger
      1  32d3		       a4		      .byte.b	tInteger
      0  32d4					      PRN		; PRINT IT
      0  32d4					      db	3
      1  32d4		       03		      .byte.b	3
      0  32d5					      IJMP	S5	; IS THERE MORE?
      0  32d5					      db	29
      1  32d5		       1d		      .byte.b	29
      0  32d6					      dw	S5
      1  32d6		       95 32		      .word.w	S5
    304  32d8							;
    305  32d8							;===========================================================
    306  32d8							; PROCESS ALL THE TASK STATEMENTS
    307  32d8							;
    308  32d8							;S8:
    309  32d8							;	  TSTB	      S8G,kTaske		 ; End Task
    310  32d8				   ekTaske
      0  32d8					      TSTB	S8NoParm,oLeftBracket
      0  32d8					      db	101
      1  32d8		       65		      .byte.b	101
      0  32d9					      db	(S8NoParm-*)-1
      1  32d9		       0c		      .byte.b	(S8NoParm-*)-1
      0  32da					      db	oLeftBracket
      1  32da		       e0		      .byte.b	oLeftBracket
      0  32db					      CALL	EXPR
      0  32db					      db	28
      1  32db		       1c		      .byte.b	28
      0  32dc					      dw	EXPR
      1  32dc		       1a 34		      .word.w	EXPR
      0  32de					      TSTB	UNKNOWNLnk,oRightBracket
      0  32de					      db	101
      1  32de		       65		      .byte.b	101
      0  32df					      db	(UNKNOWNLnk-*)-1
      1  32df		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  32e0					      db	oRightBracket
      1  32e0		       e1		      .byte.b	oRightBracket
      0  32e1					      ETASK
      0  32e1					      db	62
      1  32e1		       3e		      .byte.b	62
      0  32e2					      DONE
      0  32e2					      db	1
      1  32e2		       01		      .byte.b	1
      0  32e3					      IJMP	STMT
      0  32e3					      db	29
      1  32e3		       1d		      .byte.b	29
      0  32e4					      dw	STMT
      1  32e4		       01 32		      .word.w	STMT
    317  32e6				   S8NoParm
      0  32e6					      LIT	0
      0  32e6					      db	27
      1  32e6		       1b		      .byte.b	27
      0  32e7					      dw	0
      1  32e7		       00 00		      .word.w	0
      0  32e9					      ETASK
      0  32e9					      db	62
      1  32e9		       3e		      .byte.b	62
      0  32ea					      DONE		; Must be last thing on a line
      0  32ea					      db	1
      1  32ea		       01		      .byte.b	1
      0  32eb					      IJMP	STMT
      0  32eb					      db	29
      1  32eb		       1d		      .byte.b	29
      0  32ec					      dw	STMT
      1  32ec		       01 32		      .word.w	STMT
    322  32ee							;
    323  32ee							;===========================================================
    324  32ee							; The task gives up the rest of the cycles
    325  32ee							;S8G:
    326  32ee							;	  TSTB	      S8a,kTaskn	 ;Next task
    327  32ee				   ekTaskn
      0  32ee					      NTASK
      0  32ee					      db	63
      1  32ee		       3f		      .byte.b	63
      0  32ef					      NXT	CO	;Next statement to execute
      0  32ef					      db	6
      1  32ef		       06		      .byte.b	6
      0  32f0					      dw	CO
      1  32f0		       f9 31		      .word.w	CO
      0  32f2					      IJMP	STMT
      0  32f2					      db	29
      1  32f2		       1d		      .byte.b	29
      0  32f3					      dw	STMT
      1  32f3		       01 32		      .word.w	STMT
    331  32f5							;
    332  32f5							;===========================================================
    333  32f5							; Waits for a task or list of tasks to complete
    334  32f5
    335  32f5				   ekTaskw
      0  32f5					      TSTB	UNKNOWNLnk,oLeftBracket
      0  32f5					      db	101
      1  32f5		       65		      .byte.b	101
      0  32f6					      db	(UNKNOWNLnk-*)-1
      1  32f6		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  32f7					      db	oLeftBracket
      1  32f7		       e0		      .byte.b	oLeftBracket
    337  32f8				   S8TSK
      0  32f8					      Call	EXPR	;Gets the PID of task to wait for
      0  32f8					      db	28
      1  32f8		       1c		      .byte.b	28
      0  32f9					      dw	EXPR
      1  32f9		       1a 34		      .word.w	EXPR
    339  32fb				   S8LOOP
      0  32fb					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  32fb					      db	76
      1  32fb		       4c		      .byte.b	76
      0  32fc					      db	(S8LOOP-*)-1
      1  32fc		       fe		      .byte.b	(S8LOOP-*)-1
      0  32fd					      TSTB	S8aa,oComma	;Checks for more tasks
      0  32fd					      db	101
      1  32fd		       65		      .byte.b	101
      0  32fe					      db	(S8aa-*)-1
      1  32fe		       04		      .byte.b	(S8aa-*)-1
      0  32ff					      db	oComma
      1  32ff		       e2		      .byte.b	oComma
      0  3300					      IJMP	S8TSK	;Go for the next task number
      0  3300					      db	29
      1  3300		       1d		      .byte.b	29
      0  3301					      dw	S8TSK
      1  3301		       f8 32		      .word.w	S8TSK
    343  3303				   S8aa
      0  3303					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  3303					      db	101
      1  3303		       65		      .byte.b	101
      0  3304					      db	(UNKNOWNLnk-*)-1
      1  3304		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  3305					      db	oRightBracket
      1  3305		       e1		      .byte.b	oRightBracket
      0  3306					      DONE
      0  3306					      db	1
      1  3306		       01		      .byte.b	1
      0  3307					      NXT	CO
      0  3307					      db	6
      1  3307		       06		      .byte.b	6
      0  3308					      dw	CO
      1  3308		       f9 31		      .word.w	CO
      0  330a					      IJMP	STMT	;Next Statement
      0  330a					      db	29
      1  330a		       1d		      .byte.b	29
      0  330b					      dw	STMT
      1  330b		       01 32		      .word.w	STMT
    348  330d
    349  330d
    350  330d
    351  330d				   UNKNOWNLnk
      0  330d					      iJMP	UNKNOWN
      0  330d					      db	29
      1  330d		       1d		      .byte.b	29
      0  330e					      dw	UNKNOWN
      1  330e		       16 34		      .word.w	UNKNOWN
    353  3310
    354  3310							;
    355  3310							;===========================================================
    356  3310							; Update a memory location with a value
    357  3310							;  Use @[offset] to write a word value to memory
    358  3310							;
    359  3310							;S8a1:
    360  3310							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    361  3310				   ekPoke
      0  3310					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3310					      db	101
      1  3310		       65		      .byte.b	101
      0  3311					      db	(UNKNOWNV-*)-1
      1  3311		       a1		      .byte.b	(UNKNOWNV-*)-1
      0  3312					      db	oLeftBracket
      1  3312		       e0		      .byte.b	oLeftBracket
      0  3313					      CALL	EXPR	; Get address to write to
      0  3313					      db	28
      1  3313		       1c		      .byte.b	28
      0  3314					      dw	EXPR
      1  3314		       1a 34		      .word.w	EXPR
      0  3316					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  3316					      db	101
      1  3316		       65		      .byte.b	101
      0  3317					      db	(UNKNOWNV-*)-1
      1  3317		       9b		      .byte.b	(UNKNOWNV-*)-1
      0  3318					      db	oComma
      1  3318		       e2		      .byte.b	oComma
      0  3319					      CALL	EXPR	; Get the value to poke
      0  3319					      db	28
      1  3319		       1c		      .byte.b	28
      0  331a					      dw	EXPR
      1  331a		       1a 34		      .word.w	EXPR
      0  331c					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  331c					      db	101
      1  331c		       65		      .byte.b	101
      0  331d					      db	(UNKNOWNV-*)-1
      1  331d		       95		      .byte.b	(UNKNOWNV-*)-1
      0  331e					      db	oRightBracket
      1  331e		       e1		      .byte.b	oRightBracket
      0  331f					      POKEMEM
      0  331f					      db	47
      1  331f		       2f		      .byte.b	47
      0  3320					      DONE
      0  3320					      db	1
      1  3320		       01		      .byte.b	1
      0  3321					      NXT	CO	;AND SEQUENCE TO NEXT
      0  3321					      db	6
      1  3321		       06		      .byte.b	6
      0  3322					      dw	CO
      1  3322		       f9 31		      .word.w	CO
      0  3324					      IJMP	STMT
      0  3324					      db	29
      1  3324		       1d		      .byte.b	29
      0  3325					      dw	STMT
      1  3325		       01 32		      .word.w	STMT
    371  3327							;
    372  3327							;================================================================
    373  3327							; Set a block of memory to a value word or byte
    374  3327							; SetMem(Value, Length, Destination)
    375  3327				   ekSetMemB
      0  3327					      CALL	ekSetMem
      0  3327					      db	28
      1  3327		       1c		      .byte.b	28
      0  3328					      dw	ekSetMem
      1  3328		       3f 33		      .word.w	ekSetMem
      0  332a					      SETBLOCK	tByte	; set value as byte
      0  332a					      db	110
      1  332a		       6e		      .byte.b	110
      0  332b					      db	tByte
      1  332b		       a2		      .byte.b	tByte
      0  332c					      DONE
      0  332c					      db	1
      1  332c		       01		      .byte.b	1
      0  332d					      NXT	CO
      0  332d					      db	6
      1  332d		       06		      .byte.b	6
      0  332e					      dw	CO
      1  332e		       f9 31		      .word.w	CO
      0  3330					      IJMP	STMT
      0  3330					      db	29
      1  3330		       1d		      .byte.b	29
      0  3331					      dw	STMT
      1  3331		       01 32		      .word.w	STMT
    381  3333
    382  3333				   ekSetMemW
      0  3333					      CALL	ekSetMem
      0  3333					      db	28
      1  3333		       1c		      .byte.b	28
      0  3334					      dw	ekSetMem
      1  3334		       3f 33		      .word.w	ekSetMem
      0  3336					      SETBLOCK	tInteger	; set value as byte
      0  3336					      db	110
      1  3336		       6e		      .byte.b	110
      0  3337					      db	tInteger
      1  3337		       a4		      .byte.b	tInteger
      0  3338					      DONE
      0  3338					      db	1
      1  3338		       01		      .byte.b	1
      0  3339					      NXT	CO
      0  3339					      db	6
      1  3339		       06		      .byte.b	6
      0  333a					      dw	CO
      1  333a		       f9 31		      .word.w	CO
      0  333c					      IJMP	STMT
      0  333c					      db	29
      1  333c		       1d		      .byte.b	29
      0  333d					      dw	STMT
      1  333d		       01 32		      .word.w	STMT
    388  333f
    389  333f				   ekSetMem
      0  333f					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  333f					      db	101
      1  333f		       65		      .byte.b	101
      0  3340					      db	(UNKNOWNV-*)-1
      1  3340		       72		      .byte.b	(UNKNOWNV-*)-1
      0  3341					      db	oLeftBracket
      1  3341		       e0		      .byte.b	oLeftBracket
      0  3342					      CALL	EXPR	; Value to set
      0  3342					      db	28
      1  3342		       1c		      .byte.b	28
      0  3343					      dw	EXPR
      1  3343		       1a 34		      .word.w	EXPR
      0  3345					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3345					      db	101
      1  3345		       65		      .byte.b	101
      0  3346					      db	(UNKNOWNV-*)-1
      1  3346		       6c		      .byte.b	(UNKNOWNV-*)-1
      0  3347					      db	oComma
      1  3347		       e2		      .byte.b	oComma
      0  3348					      CALL	EXPR	; Get The Length
      0  3348					      db	28
      1  3348		       1c		      .byte.b	28
      0  3349					      dw	EXPR
      1  3349		       1a 34		      .word.w	EXPR
      0  334b					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  334b					      db	101
      1  334b		       65		      .byte.b	101
      0  334c					      db	(UNKNOWNV-*)-1
      1  334c		       66		      .byte.b	(UNKNOWNV-*)-1
      0  334d					      db	oComma
      1  334d		       e2		      .byte.b	oComma
      0  334e					      CALL	EXPR	; GET the address to start at
      0  334e					      db	28
      1  334e		       1c		      .byte.b	28
      0  334f					      dw	EXPR
      1  334f		       1a 34		      .word.w	EXPR
      0  3351					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3351					      db	101
      1  3351		       65		      .byte.b	101
      0  3352					      db	(UNKNOWNV-*)-1
      1  3352		       60		      .byte.b	(UNKNOWNV-*)-1
      0  3353					      db	oRightBracket
      1  3353		       e1		      .byte.b	oRightBracket
      0  3354					      RTN
      0  3354					      db	25
      1  3354		       19		      .byte.b	25
    398  3355							;
    399  3355							;================================================================
    400  3355							; Copy a block of memory
    401  3355							; CopyMem(Length, Destination, Source)
    402  3355				   ekCopyMem
      0  3355					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3355					      db	101
      1  3355		       65		      .byte.b	101
      0  3356					      db	(UNKNOWNV-*)-1
      1  3356		       5c		      .byte.b	(UNKNOWNV-*)-1
      0  3357					      db	oLeftBracket
      1  3357		       e0		      .byte.b	oLeftBracket
      0  3358					      CALL	EXPR	; Length
      0  3358					      db	28
      1  3358		       1c		      .byte.b	28
      0  3359					      dw	EXPR
      1  3359		       1a 34		      .word.w	EXPR
      0  335b					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  335b					      db	101
      1  335b		       65		      .byte.b	101
      0  335c					      db	(UNKNOWNV-*)-1
      1  335c		       56		      .byte.b	(UNKNOWNV-*)-1
      0  335d					      db	oComma
      1  335d		       e2		      .byte.b	oComma
      0  335e					      CALL	EXPR	; Destination
      0  335e					      db	28
      1  335e		       1c		      .byte.b	28
      0  335f					      dw	EXPR
      1  335f		       1a 34		      .word.w	EXPR
      0  3361					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3361					      db	101
      1  3361		       65		      .byte.b	101
      0  3362					      db	(UNKNOWNV-*)-1
      1  3362		       50		      .byte.b	(UNKNOWNV-*)-1
      0  3363					      db	oComma
      1  3363		       e2		      .byte.b	oComma
      0  3364					      CALL	EXPR	; Source
      0  3364					      db	28
      1  3364		       1c		      .byte.b	28
      0  3365					      dw	EXPR
      1  3365		       1a 34		      .word.w	EXPR
      0  3367					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3367					      db	101
      1  3367		       65		      .byte.b	101
      0  3368					      db	(UNKNOWNV-*)-1
      1  3368		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  3369					      db	oRightBracket
      1  3369		       e1		      .byte.b	oRightBracket
      0  336a					      COPYBLOCK		; Copy the memory
      0  336a					      db	111
      1  336a		       6f		      .byte.b	111
      0  336b					      DONE
      0  336b					      db	1
      1  336b		       01		      .byte.b	1
      0  336c					      NXT	CO
      0  336c					      db	6
      1  336c		       06		      .byte.b	6
      0  336d					      dw	CO
      1  336d		       f9 31		      .word.w	CO
      0  336f					      IJMP	STMT
      0  336f					      db	29
      1  336f		       1d		      .byte.b	29
      0  3370					      dw	STMT
      1  3370		       01 32		      .word.w	STMT
    414  3372
    415  3372							;================================================================
    416  3372							; Write a single byte to the output device
    417  3372							;
    418  3372				   ekPutch
      0  3372					      CALL	EXPR
      0  3372					      db	28
      1  3372		       1c		      .byte.b	28
      0  3373					      dw	EXPR
      1  3373		       1a 34		      .word.w	EXPR
      0  3375					      PUTCHAR
      0  3375					      db	52
      1  3375		       34		      .byte.b	52
      0  3376					      DONE
      0  3376					      db	1
      1  3376		       01		      .byte.b	1
      0  3377					      NXT	CO	;AND SEQUENCE TO NEXT
      0  3377					      db	6
      1  3377		       06		      .byte.b	6
      0  3378					      dw	CO
      1  3378		       f9 31		      .word.w	CO
      0  337a					      IJMP	STMT
      0  337a					      db	29
      1  337a		       1d		      .byte.b	29
      0  337b					      dw	STMT
      1  337b		       01 32		      .word.w	STMT
    424  337d							;================================================================
    425  337d							; Clear the screen lines
    426  337d							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    427  337d							;
    428  337d				   ekCls
      0  337d					      CLEARSCREEN
      0  337d					      db	46
      1  337d		       2e		      .byte.b	46
      0  337e					      NXT	CO	;AND SEQUENCE TO NEXT
      0  337e					      db	6
      1  337e		       06		      .byte.b	6
      0  337f					      dw	CO
      1  337f		       f9 31		      .word.w	CO
      0  3381					      IJMP	STMT
      0  3381					      db	29
      1  3381		       1d		      .byte.b	29
      0  3382					      dw	STMT
      1  3382		       01 32		      .word.w	STMT
    432  3384							;==================================================================
    433  3384							; Get input from the terminal
    434  3384							;   Reads from the currently active input device
    435  3384							;
    436  3384				   ekInput
    437  3384				   S10
      0  3384					      TSTB	S10A,tString	;If there is a string print the prompt
      0  3384					      db	101
      1  3384		       65		      .byte.b	101
      0  3385					      db	(S10A-*)-1
      1  3385		       05		      .byte.b	(S10A-*)-1
      0  3386					      db	tString
      1  3386		       a0		      .byte.b	tString
      0  3387					      PRS
      0  3387					      db	2
      1  3387		       02		      .byte.b	2
      0  3388					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  3388					      db	101
      1  3388		       65		      .byte.b	101
      0  3389					      db	(S10Z-*)-1
      1  3389		       1e		      .byte.b	(S10Z-*)-1
      0  338a					      db	oSemiColon
      1  338a		       e3		      .byte.b	oSemiColon
    441  338b				   S10A
      0  338b					      TSTB	InNoString,oDollar	; Check if we are reading characters
      0  338b					      db	101
      1  338b		       65		      .byte.b	101
      0  338c					      db	(InNoString-*)-1
      1  338c		       0c		      .byte.b	(InNoString-*)-1
      0  338d					      db	oDollar
      1  338d		       e7		      .byte.b	oDollar
      0  338e					      TSTV	UNKNOWN
      0  338e					      db	33
      1  338e		       21		      .byte.b	33
      0  338f					      db	(UNKNOWN-*)-1
      1  338f		       86		      .byte.b	(UNKNOWN-*)-1
      0  3390					      CALL	FactVarPtrNoTst
      0  3390					      db	28
      1  3390		       1c		      .byte.b	28
      0  3391					      dw	FactVarPtrNoTst
      1  3391		       ce 35		      .word.w	FactVarPtrNoTst
      0  3393					      INSTR		;Move character From tty to AESTK
      0  3393					      db	59
      1  3393		       3b		      .byte.b	59
      0  3394					      SETR2	tByte
      0  3394					      db	94
      1  3394		       5e		      .byte.b	94
      0  3395					      db	tByte
      1  3395		       a2		      .byte.b	tByte
      0  3396					      IJMP	S10A2
      0  3396					      db	29
      1  3396		       1d		      .byte.b	29
      0  3397					      dw	S10A2
      1  3397		       a1 33		      .word.w	S10A2
    448  3399
    449  3399				   InNoString
      0  3399					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  3399					      db	33
      1  3399		       21		      .byte.b	33
      0  339a					      db	(UNKNOWN-*)-1
      1  339a		       7b		      .byte.b	(UNKNOWN-*)-1
      0  339b					      CALL	FactVarPtrNoTst
      0  339b					      db	28
      1  339b		       1c		      .byte.b	28
      0  339c					      dw	FactVarPtrNoTst
      1  339c		       ce 35		      .word.w	FactVarPtrNoTst
      0  339e					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  339e					      db	11
      1  339e		       0b		      .byte.b	11
      0  339f					      SETR2	tInteger
      0  339f					      db	94
      1  339f		       5e		      .byte.b	94
      0  33a0					      db	tInteger
      1  33a0		       a4		      .byte.b	tInteger
    454  33a1
    455  33a1				   S10A2
      0  33a1					      STORE		;STORE IT
      0  33a1					      db	19
      1  33a1		       13		      .byte.b	19
      0  33a2					      TSTB	S11,oComma	;IS THERE MORE?
      0  33a2					      db	101
      1  33a2		       65		      .byte.b	101
      0  33a3					      db	(S11-*)-1
      1  33a3		       07		      .byte.b	(S11-*)-1
      0  33a4					      db	oComma
      1  33a4		       e2		      .byte.b	oComma
      0  33a5					      IJMP	S10	;YES
      0  33a5					      db	29
      1  33a5		       1d		      .byte.b	29
      0  33a6					      dw	S10
      1  33a6		       84 33		      .word.w	S10
    459  33a8				   S10Z
      0  33a8					      iJMP	UNKNOWN
      0  33a8					      db	29
      1  33a8		       1d		      .byte.b	29
      0  33a9					      dw	UNKNOWN
      1  33a9		       16 34		      .word.w	UNKNOWN
    461  33ab				   S11
      0  33ab					      DONE		;MUST BE CR
      0  33ab					      db	1
      1  33ab		       01		      .byte.b	1
      0  33ac					      NXT	CO	;SEQUENCE TO NEXT
      0  33ac					      db	6
      1  33ac		       06		      .byte.b	6
      0  33ad					      dw	CO
      1  33ad		       f9 31		      .word.w	CO
      0  33af					      IJMP	STMT
      0  33af					      db	29
      1  33af		       1d		      .byte.b	29
      0  33b0					      dw	STMT
      1  33b0		       01 32		      .word.w	STMT
    465  33b2							;=====================================================================
    466  33b2							; End of program, return to command line process
    467  33b2							; Main Task may also use taske or return to stopped
    468  33b2							;
    469  33b2				   ekEnd
      0  33b2					      FIN
      0  33b2					      db	12
      1  33b2		       0c		      .byte.b	12
    471  33b3				   UNKNOWNV
      0  33b3					      IJMP	UNKNOWN
      0  33b3					      db	29
      1  33b3		       1d		      .byte.b	29
      0  33b4					      dw	UNKNOWN
      1  33b4		       16 34		      .word.w	UNKNOWN
    473  33b6							;====================================================================
    474  33b6							; IRQ <IRQ-HANDLER-Line expression>
    475  33b6							;   Specify a line number subroutine to call when an interupt is processed
    476  33b6							;   These subroutines must use iret to return.
    477  33b6							;
    478  33b6				   ekIrq
      0  33b6					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  33b6					      db	28
      1  33b6		       1c		      .byte.b	28
      0  33b7					      dw	EXPR
      1  33b7		       1a 34		      .word.w	EXPR
      0  33b9					      DONE		;must be CR
      0  33b9					      db	1
      1  33b9		       01		      .byte.b	1
      0  33ba					      SETIRQ		;Set the line number now
      0  33ba					      db	56
      1  33ba		       38		      .byte.b	56
      0  33bb					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  33bb					      db	6
      1  33bb		       06		      .byte.b	6
      0  33bc					      dw	CO
      1  33bc		       f9 31		      .word.w	CO
      0  33be					      IJMP	STMT
      0  33be					      db	29
      1  33be		       1d		      .byte.b	29
      0  33bf					      dw	STMT
      1  33bf		       01 32		      .word.w	STMT
    484  33c1
    485  33c1							;=========================================================================
    486  33c1							; KILL PID-expression	 kill a running task
    487  33c1							;  ignored of task has already stopped
    488  33c1							;
    489  33c1				   ekKill
      0  33c1					      CALL	EXPR
      0  33c1					      db	28
      1  33c1		       1c		      .byte.b	28
      0  33c2					      dw	EXPR
      1  33c2		       1a 34		      .word.w	EXPR
      0  33c4					      DONE
      0  33c4					      db	1
      1  33c4		       01		      .byte.b	1
      0  33c5					      TASKKILL
      0  33c5					      db	65
      1  33c5		       41		      .byte.b	65
      0  33c6					      NXT	CO
      0  33c6					      db	6
      1  33c6		       06		      .byte.b	6
      0  33c7					      dw	CO
      1  33c7		       f9 31		      .word.w	CO
      0  33c9					      IJMP	STMT
      0  33c9					      db	29
      1  33c9		       1d		      .byte.b	29
      0  33ca					      dw	STMT
      1  33ca		       01 32		      .word.w	STMT
    495  33cc
    496  33cc							;============================================================================
    497  33cc							; List all program lines
    498  33cc							;
    499  33cc				   ekList
      0  33cc					      DONE
      0  33cc					      db	1
      1  33cc		       01		      .byte.b	1
      0  33cd					      LST
      0  33cd					      db	21
      1  33cd		       15		      .byte.b	21
      0  33ce					      IJMP	CO
      0  33ce					      db	29
      1  33ce		       1d		      .byte.b	29
      0  33cf					      dw	CO
      1  33cf		       f9 31		      .word.w	CO
    503  33d1							;=======================================================================
    504  33d1							;RUN begin to executed the program in memory
    505  33d1							;
    506  33d1				   ekRun
      0  33d1					      DONE
      0  33d1					      db	1
      1  33d1		       01		      .byte.b	1
      0  33d2					      VINIT		;clear variables compile the line numbers
      0  33d2					      db	30
      1  33d2		       1e		      .byte.b	30
      0  33d3					      LIT	1	;GOTO line 1
      0  33d3					      db	27
      1  33d3		       1b		      .byte.b	27
      0  33d4					      dw	1
      1  33d4		       01 00		      .word.w	1
      0  33d6					      XFER		;Bob's addition
      0  33d6					      db	7
      1  33d6		       07		      .byte.b	7
    511  33d7							; EXIT
      0  33d7					      IJMP	STMT	;and run!
      0  33d7					      db	29
      1  33d7		       1d		      .byte.b	29
      0  33d8					      dw	STMT
      1  33d8		       01 32		      .word.w	STMT
    513  33da							;=========================================================================
    514  33da							;Clear the program memory, delete all proram lines
    515  33da							;
    516  33da				   ekNew
      0  33da					      DONE
      0  33da					      db	1
      1  33da		       01		      .byte.b	1
      0  33db					      IJMP	START
      0  33db					      db	29
      1  33db		       1d		      .byte.b	29
      0  33dc					      dw	START
      1  33dc		       f3 31		      .word.w	START
    519  33de
    520  33de							;========================================================================
    521  33de							; Slice(slice legth expression)
    522  33de							;   set the length of time between task switches
    523  33de							;
    524  33de				   ekSlice
      0  33de					      CALL	EXPR
      0  33de					      db	28
      1  33de		       1c		      .byte.b	28
      0  33df					      dw	EXPR
      1  33df		       1a 34		      .word.w	EXPR
      0  33e1					      SLICE
      0  33e1					      db	100
      1  33e1		       64		      .byte.b	100
      0  33e2					      DONE
      0  33e2					      db	1
      1  33e2		       01		      .byte.b	1
      0  33e3					      NXT	CO
      0  33e3					      db	6
      1  33e3		       06		      .byte.b	6
      0  33e4					      dw	CO
      1  33e4		       f9 31		      .word.w	CO
      0  33e6					      IJMP	STMT
      0  33e6					      db	29
      1  33e6		       1d		      .byte.b	29
      0  33e7					      dw	STMT
      1  33e7		       01 32		      .word.w	STMT
    530  33e9							;==========================================================================
    531  33e9							; Turn off and on the thrace functions
    532  33e9							; a debug terminal needs to be available
    533  33e9							; Trace( Trace flag expression)
    534  33e9							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    535  33e9							;	for individual lines of basic code. These can be combined
    536  33e9				   ekTrace
      0  33e9					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  33e9					      db	101
      1  33e9		       65		      .byte.b	101
      0  33ea					      db	(UNKNOWN-*)-1
      1  33ea		       2b		      .byte.b	(UNKNOWN-*)-1
      0  33eb					      db	oLeftBracket
      1  33eb		       e0		      .byte.b	oLeftBracket
      0  33ec					      CALL	EXPR
      0  33ec					      db	28
      1  33ec		       1c		      .byte.b	28
      0  33ed					      dw	EXPR
      1  33ed		       1a 34		      .word.w	EXPR
      0  33ef					      TSTB	UNKNOWN,oRightBracket
      0  33ef					      db	101
      1  33ef		       65		      .byte.b	101
      0  33f0					      db	(UNKNOWN-*)-1
      1  33f0		       25		      .byte.b	(UNKNOWN-*)-1
      0  33f1					      db	oRightBracket
      1  33f1		       e1		      .byte.b	oRightBracket
      0  33f2					      TRACEPROGRAM
      0  33f2					      db	78
      1  33f2		       4e		      .byte.b	78
      0  33f3					      DONE
      0  33f3					      db	1
      1  33f3		       01		      .byte.b	1
      0  33f4					      NXT	CO
      0  33f4					      db	6
      1  33f4		       06		      .byte.b	6
      0  33f5					      dw	CO
      1  33f5		       f9 31		      .word.w	CO
      0  33f7					      IJMP	STMT
      0  33f7					      db	29
      1  33f7		       1d		      .byte.b	29
      0  33f8					      dw	STMT
      1  33f8		       01 32		      .word.w	STMT
    544  33fa							;=====================================================================
    545  33fa							; Exit basic to machine monitor
    546  33fa							;
    547  33fa				   ekExit
      0  33fa					      EXIT
      0  33fa					      db	26
      1  33fa		       1a		      .byte.b	26
    549  33fb
    550  33fb							;=======================================================================
    551  33fb							; Commands related to saving/restoring programs
    552  33fb							; to/from mass storage.
    553  33fb							;=======================================================================
    554  33fb							; Save a program file
    555  33fb							;
    556  33fb					      if	(XKIM || CTMON65) && DISK_ACCESS
    557  33fb
    558  33fb				   ekSave
      0  33fb					      OPENWRITE	OPEN_CREATE
      0  33fb					      db	40
      1  33fb		       28		      .byte.b	40
      0  33fc					      db	OPEN_CREATE
      1  33fc		       01		      .byte.b	OPEN_CREATE
      0  33fd					      DLIST
      0  33fd					      db	43
      1  33fd		       2b		      .byte.b	43
      0  33fe					      DCLOSE
      0  33fe					      db	41
      1  33fe		       29		      .byte.b	41
      0  33ff					      IJMP	CO
      0  33ff					      db	29
      1  33ff		       1d		      .byte.b	29
      0  3400					      dw	CO
      1  3400		       f9 31		      .word.w	CO
    563  3402							;=========================================================================
    564  3402							; Load a program file
    565  3402							;
    566  3402				   ekLoad
      0  3402					      OPENREAD
      0  3402					      db	39
      1  3402		       27		      .byte.b	39
    568  3403				   S17CLP
      0  3403					      DGETLINE		;get line from file
      0  3403					      db	42
      1  3403		       2a		      .byte.b	42
      0  3404					      TSTL	S17EOL	;no line num means EOL
      0  3404					      db	34
      1  3404		       22		      .byte.b	34
      0  3405					      db	(S17EOL-*)-1
      1  3405		       04		      .byte.b	(S17EOL-*)-1
      0  3406					      INSERT		;put it into the program
      0  3406					      db	24
      1  3406		       18		      .byte.b	24
      0  3407					      IJMP	S17CLP	;keep going
      0  3407					      db	29
      1  3407		       1d		      .byte.b	29
      0  3408					      dw	S17CLP
      1  3408		       03 34		      .word.w	S17CLP
    573  340a				   S17EOL
      0  340a					      DCLOSE		;close disk file
      0  340a					      db	41
      1  340a		       29		      .byte.b	41
      0  340b					      IJMP	CO	;back to start
      0  340b					      db	29
      1  340b		       1d		      .byte.b	29
      0  340c					      dw	CO
      1  340c		       f9 31		      .word.w	CO
    576  340e							;=========================================================================
    577  340e							; Display the directory content
    578  340e							;
    579  340e				   ekDir
      0  340e					      DDIR		;Display the directory content
      0  340e					      db	44
      1  340e		       2c		      .byte.b	44
      0  340f					      IJMP	CO
      0  340f					      db	29
      1  340f		       1d		      .byte.b	29
      0  3410					      dw	CO
      1  3410		       f9 31		      .word.w	CO
    582  3412							;=========================================================================
    583  3412							; Erase a file from disk
    584  3412							;
    585  3412				   ekErase
      0  3412					      RMFILE		;Erase the file from the disk
      0  3412					      db	45
      1  3412		       2d		      .byte.b	45
      0  3413					      IJMP	CO
      0  3413					      db	29
      1  3413		       1d		      .byte.b	29
      0  3414					      dw	CO
      1  3414		       f9 31		      .word.w	CO
    588  3416
    589  3416					      endif
    590  3416
    591  3416							;===========================================================================
    592  3416							; Else, unknown command.
    593  3416							;
    594  3416				   UNKNOWN
      0  3416					      ENDIO
      0  3416					      db	71
      1  3416		       47		      .byte.b	71
    596  3417
    597  3417				   NotKnownStatement
    598  3417
      0  3417					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  3417					      db	13
      1  3417		       0d		      .byte.b	13
      0  3418					      dw	ERR_SYNTAX
      1  3418		       05 00		      .word.w	ERR_SYNTAX
    600  341a
    601  341a							;=======================================================
    602  341a							; Process Expresions, precidence is represented by the
    603  341a							; various call levels
    604  341a							;
    605  341a				   EXPR
      0  341a					      TSTB	EXPRLOGS,kNot
      0  341a					      db	101
      1  341a		       65		      .byte.b	101
      0  341b					      db	(EXPRLOGS-*)-1
      1  341b		       06		      .byte.b	(EXPRLOGS-*)-1
      0  341c					      db	kNot
      1  341c		       24		      .byte.b	kNot
    607  341d				   ekNot
      0  341d					      Call	EXPR
      0  341d					      db	28
      1  341d		       1c		      .byte.b	28
      0  341e					      dw	EXPR
      1  341e		       1a 34		      .word.w	EXPR
      0  3420					      LOGNOT
      0  3420					      db	72
      1  3420		       48		      .byte.b	72
      0  3421					      RTN
      0  3421					      db	25
      1  3421		       19		      .byte.b	25
    611  3422
    612  3422							;=========================================================
    613  3422							;Look for logical operators, but does get first part of expression
    614  3422				   EXPRLOGS
      0  3422					      Call	EXPRCMP
      0  3422					      db	28
      1  3422		       1c		      .byte.b	28
      0  3423					      dw	EXPRCMP
      1  3423		       4a 34		      .word.w	EXPRCMP
    616  3425							;=========================================================
    617  3425							;Look for shift left and shift right level
    618  3425				   EXPSHIFT
      0  3425					      OnGoto	BasicShift,EXPRLOGICAL
      0  3425					      db	103
      1  3425		       67		      .byte.b	103
      0  3426					      dw	BasicShift
      1  3426		       c7 31		      .word.w	BasicShift
      0  3428					      dw	EXPRLOGICAL
      1  3428		       36 34		      .word.w	EXPRLOGICAL
    620  342a
    621  342a				   ekShiftLeft
      0  342a					      Call	EXPR
      0  342a					      db	28
      1  342a		       1c		      .byte.b	28
      0  342b					      dw	EXPR
      1  342b		       1a 34		      .word.w	EXPR
      0  342d					      SHIFT	0
      0  342d					      db	113
      1  342d		       71		      .byte.b	113
      0  342e					      db	0
      1  342e		       00		      .byte.b	0
      0  342f					      RTN
      0  342f					      db	25
      1  342f		       19		      .byte.b	25
    625  3430
    626  3430				   ekShiftRight
      0  3430					      Call	EXPR
      0  3430					      db	28
      1  3430		       1c		      .byte.b	28
      0  3431					      dw	EXPR
      1  3431		       1a 34		      .word.w	EXPR
      0  3433					      SHIFT	1
      0  3433					      db	113
      1  3433		       71		      .byte.b	113
      0  3434					      db	1
      1  3434		       01		      .byte.b	1
      0  3435					      RTN
      0  3435					      db	25
      1  3435		       19		      .byte.b	25
    630  3436
    631  3436							;======================================================================
    632  3436				   EXPRLOGICAL
      0  3436					      OnGoto	BasicLogical,iLOGExit
      0  3436					      db	103
      1  3436		       67		      .byte.b	103
      0  3437					      dw	BasicLogical
      1  3437		       bf 31		      .word.w	BasicLogical
      0  3439					      dw	iLOGExit
      1  3439		       49 34		      .word.w	iLOGExit
    634  343b				   ekAnd
      0  343b					      Call	EXPR
      0  343b					      db	28
      1  343b		       1c		      .byte.b	28
      0  343c					      dw	EXPR
      1  343c		       1a 34		      .word.w	EXPR
      0  343e					      LOGAND
      0  343e					      db	74
      1  343e		       4a		      .byte.b	74
      0  343f					      RTN
      0  343f					      db	25
      1  343f		       19		      .byte.b	25
    638  3440				   ekOr
      0  3440					      Call	EXPR
      0  3440					      db	28
      1  3440		       1c		      .byte.b	28
      0  3441					      dw	EXPR
      1  3441		       1a 34		      .word.w	EXPR
      0  3443					      LOGOR
      0  3443					      db	73
      1  3443		       49		      .byte.b	73
      0  3444					      RTN
      0  3444					      db	25
      1  3444		       19		      .byte.b	25
    642  3445				   ekXor
      0  3445					      Call	EXPR
      0  3445					      db	28
      1  3445		       1c		      .byte.b	28
      0  3446					      dw	EXPR
      1  3446		       1a 34		      .word.w	EXPR
      0  3448					      LOGXOR
      0  3448					      db	75
      1  3448		       4b		      .byte.b	75
    645  3449				   iLOGExit
      0  3449					      RTN
      0  3449					      db	25
      1  3449		       19		      .byte.b	25
    647  344a							;========================================================================
    648  344a							; Process relational operators
    649  344a							;
    650  344a				   EXPRCMP
      0  344a					      Call	EXPR2	; get the left first expression
      0  344a					      db	28
      1  344a		       1c		      .byte.b	28
      0  344b					      dw	EXPR2
      1  344b		       55 34		      .word.w	EXPR2
      0  344d					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  344d					      db	104
      1  344d		       68		      .byte.b	104
      0  344e					      db	(iRDone-*)-1
      1  344e		       05		      .byte.b	(iRDone-*)-1
    653  344f							;	  TSTB	     iR0,oEqual
    654  344f							;	  LIT	     2		     ;=
    655  344f							;	  IJMP	     iRFound
    656  344f							;iR0:
    657  344f							;	  TSTB	      iR1,oLessEqual
    658  344f							;	  LIT	      3 	      ;<=
    659  344f							;	  IJMP	     iRFound
    660  344f							;iR1:
    661  344f							;	  TSTB	     iR3,oNotEqual
    662  344f							;	  LIT	     5		      ;<>
    663  344f							;	      IJMP	  iRFound
    664  344f							;iR3:
    665  344f							;	  TSTB	     iR4,oLess
    666  344f							;	  LIT	     1		     ;<
    667  344f							;	      IJMP	  iRFound
    668  344f							;iR4:
    669  344f							;	  TST	     iR5,oGreaterEqual
    670  344f							;	  LIT	     6		     ;>=
    671  344f							;	      IJMP	  iRFound
    672  344f							;iR5:
    673  344f							;	  TSTB	     iRDone,oGreater
    674  344f							;	  LIT	     4		     ;>
    675  344f				   iRFound
      0  344f					      Call	EXPR	; get the right side of the expression
      0  344f					      db	28
      1  344f		       1c		      .byte.b	28
      0  3450					      dw	EXPR
      1  3450		       1a 34		      .word.w	EXPR
      0  3452					      CMPR		; Push the value of the true false onto the stack
      0  3452					      db	10
      1  3452		       0a		      .byte.b	10
      0  3453					      RTN
      0  3453					      db	25
      1  3453		       19		      .byte.b	25
    679  3454
    680  3454				   iRDone
      0  3454					      RTN
      0  3454					      db	25
      1  3454		       19		      .byte.b	25
    682  3455
    683  3455				   EXPR2
      0  3455					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  3455					      db	101
      1  3455		       65		      .byte.b	101
      0  3456					      db	(E0-*)-1
      1  3456		       08		      .byte.b	(E0-*)-1
      0  3457					      db	oMinus
      1  3457		       eb		      .byte.b	oMinus
      0  3458					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  3458					      db	28
      1  3458		       1c		      .byte.b	28
      0  3459					      dw	TERM
      1  3459		       7b 34		      .word.w	TERM
      0  345b					      NEG		; Make value negated
      0  345b					      db	16
      1  345b		       10		      .byte.b	16
      0  345c					      IJMP	E1	; We have Left term process operators next
      0  345c					      db	29
      1  345c		       1d		      .byte.b	29
      0  345d					      dw	E1
      1  345d		       65 34		      .word.w	E1
    688  345f				   E0
      0  345f					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  345f					      db	101
      1  345f		       65		      .byte.b	101
      0  3460					      db	(E1A-*)-1
      1  3460		       01		      .byte.b	(E1A-*)-1
      0  3461					      db	oPlus
      1  3461		       ea		      .byte.b	oPlus
    690  3462				   E1A
      0  3462					      CALL	TERM	; Get the left term if it was not negated
      0  3462					      db	28
      1  3462		       1c		      .byte.b	28
      0  3463					      dw	TERM
      1  3463		       7b 34		      .word.w	TERM
    692  3465				   E1
      0  3465					      TST	E2,oPlus	; Check if we are adding left term to something
      0  3465					      db	32
      1  3465		       20		      .byte.b	32
      0  3466					      db	(E2-*)-1
      1  3466		       09		      .byte.b	(E2-*)-1
      0  3467					      db	oPlus,0
      1  3467		       ea 00		      .byte.b	oPlus,0
      0  3469					      CALL	TERM	; if adding then get the right side term
      0  3469					      db	28
      1  3469		       1c		      .byte.b	28
      0  346a					      dw	TERM
      1  346a		       7b 34		      .word.w	TERM
      0  346c					      ADD		; Add it to left term
      0  346c					      db	14
      1  346c		       0e		      .byte.b	14
      0  346d					      IJMP	E1	; look for next + or -
      0  346d					      db	29
      1  346d		       1d		      .byte.b	29
      0  346e					      dw	E1
      1  346e		       65 34		      .word.w	E1
    697  3470				   E2
      0  3470					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  3470					      db	101
      1  3470		       65		      .byte.b	101
      0  3471					      db	(E3-*)-1
      1  3471		       08		      .byte.b	(E3-*)-1
      0  3472					      db	oMinus
      1  3472		       eb		      .byte.b	oMinus
      0  3473					      CALL	TERM	; get right side to subtract Diffrence
      0  3473					      db	28
      1  3473		       1c		      .byte.b	28
      0  3474					      dw	TERM
      1  3474		       7b 34		      .word.w	TERM
      0  3476					      SUB		; Subtract the value
      0  3476					      db	15
      1  3476		       0f		      .byte.b	15
      0  3477					      IJMP	E1	; Look for next + or -
      0  3477					      db	29
      1  3477		       1d		      .byte.b	29
      0  3478					      dw	E1
      1  3478		       65 34		      .word.w	E1
    702  347a				   E3			; Finish processing the expression
      0  347a					      RTN		; We are finished processing the Expression
      0  347a					      db	25
      1  347a		       19		      .byte.b	25
    704  347b							;
    705  347b							; Get one of the terms of an expression
    706  347b							;
    707  347b				   TERM
      0  347b					      CALL	FACT	; Get a value
      0  347b					      db	28
      1  347b		       1c		      .byte.b	28
      0  347c					      dw	FACT
      1  347c		       a0 34		      .word.w	FACT
    709  347e				   T0			; Check for higher precidence operators
      0  347e					      TSTB	T1,oMultiply	; Check for *
      0  347e					      db	101
      1  347e		       65		      .byte.b	101
      0  347f					      db	(T1-*)-1
      1  347f		       08		      .byte.b	(T1-*)-1
      0  3480					      db	oMultiply
      1  3480		       ee		      .byte.b	oMultiply
      0  3481					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  3481					      db	28
      1  3481		       1c		      .byte.b	28
      0  3482					      dw	FACT
      1  3482		       a0 34		      .word.w	FACT
      0  3484					      MUL		; Multiply factors
      0  3484					      db	17
      1  3484		       11		      .byte.b	17
      0  3485					      IJMP	T0	; Check for * or /
      0  3485					      db	29
      1  3485		       1d		      .byte.b	29
      0  3486					      dw	T0
      1  3486		       7e 34		      .word.w	T0
    714  3488				   T1
      0  3488					      TSTB	T2,oDivide	; Check for a division
      0  3488					      db	101
      1  3488		       65		      .byte.b	101
      0  3489					      db	(T2-*)-1
      1  3489		       08		      .byte.b	(T2-*)-1
      0  348a					      db	oDivide
      1  348a		       ec		      .byte.b	oDivide
      0  348b					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  348b					      db	28
      1  348b		       1c		      .byte.b	28
      0  348c					      dw	FACT
      1  348c		       a0 34		      .word.w	FACT
      0  348e					      DIV		; do division
      0  348e					      db	18
      1  348e		       12		      .byte.b	18
      0  348f					      IJMP	T0	; check for more * or /
      0  348f					      db	29
      1  348f		       1d		      .byte.b	29
      0  3490					      dw	T0
      1  3490		       7e 34		      .word.w	T0
    719  3492				   T2
      0  3492					      TSTB	T3,oModulo	; Check for a division
      0  3492					      db	101
      1  3492		       65		      .byte.b	101
      0  3493					      db	(T3-*)-1
      1  3493		       08		      .byte.b	(T3-*)-1
      0  3494					      db	oModulo
      1  3494		       ed		      .byte.b	oModulo
      0  3495					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  3495					      db	28
      1  3495		       1c		      .byte.b	28
      0  3496					      dw	FACT
      1  3496		       a0 34		      .word.w	FACT
      0  3498					      MODULO		; do division for remainder
      0  3498					      db	60
      1  3498		       3c		      .byte.b	60
      0  3499					      IJMP	T0	; check for more * or / or %
      0  3499					      db	29
      1  3499		       1d		      .byte.b	29
      0  349a					      dw	T0
      1  349a		       7e 34		      .word.w	T0
    724  349c				   T3			; Finish processing the Term
      0  349c					      RTN
      0  349c					      db	25
      1  349c		       19		      .byte.b	25
    726  349d
    727  349d				   UNKNOWNVEC
      0  349d					      IJMP	UNKNOWN
      0  349d					      db	29
      1  349d		       1d		      .byte.b	29
      0  349e					      dw	UNKNOWN
      1  349e		       16 34		      .word.w	UNKNOWN
    729  34a0
    730  34a0							;=============================================================================================
    731  34a0							; Factor an expression.  Always test for functions
    732  34a0							; first or else they'll be confused for variables.
    733  34a0							;
    734  34a0				   FACT
      0  34a0					      OnGoto	BasicFuncs,FactNumber
      0  34a0					      db	103
      1  34a0		       67		      .byte.b	103
      0  34a1					      dw	BasicFuncs
      1  34a1		       cd 31		      .word.w	BasicFuncs
      0  34a3					      dw	FactNumber
      1  34a3		       a0 35		      .word.w	FactNumber
    736  34a5
    737  34a5							;FACTCONTINUE:
    738  34a5							;	  TSTB	     F1AA,kTrue
    739  34a5				   ekTrue
      0  34a5					      LIT	-1
      0  34a5					      db	27
      1  34a5		       1b		      .byte.b	27
      0  34a6					      dw	-1
      1  34a6		       ff ff		      .word.w	-1
      0  34a8					      RTN
      0  34a8					      db	25
      1  34a8		       19		      .byte.b	25
    742  34a9							;F1AA:
    743  34a9							;	  TSTB	     F1AB,kFalse
    744  34a9				   ekFalse
      0  34a9					      LIT	0
      0  34a9					      db	27
      1  34a9		       1b		      .byte.b	27
      0  34aa					      dw	0
      1  34aa		       00 00		      .word.w	0
      0  34ac					      RTN
      0  34ac					      db	25
      1  34ac		       19		      .byte.b	25
    747  34ad							;==================================================================================
    748  34ad							; Returns the amount of free SPACE
    749  34ad				   ekFree
      0  34ad					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34ad					      db	101
      1  34ad		       65		      .byte.b	101
      0  34ae					      db	(UNKNOWNVEC-*)-1
      1  34ae		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  34af					      db	oLeftBracket
      1  34af		       e0		      .byte.b	oLeftBracket
      0  34b0					      TSTB	UNKNOWNVEC,oRightBracket
      0  34b0					      db	101
      1  34b0		       65		      .byte.b	101
      0  34b1					      db	(UNKNOWNVEC-*)-1
      1  34b1		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  34b2					      db	oRightBracket
      1  34b2		       e1		      .byte.b	oRightBracket
      0  34b3					      FREE
      0  34b3					      db	36
      1  34b3		       24		      .byte.b	36
      0  34b4					      RTN
      0  34b4					      db	25
      1  34b4		       19		      .byte.b	25
    754  34b5							;===================================================================================
    755  34b5							; getch() read a character from the input device
    756  34b5							;
    757  34b5				   ekGetch
      0  34b5					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34b5					      db	101
      1  34b5		       65		      .byte.b	101
      0  34b6					      db	(UNKNOWNVEC-*)-1
      1  34b6		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  34b7					      db	oLeftBracket
      1  34b7		       e0		      .byte.b	oLeftBracket
      0  34b8					      TSTB	UNKNOWNVEC,oRightBracket
      0  34b8					      db	101
      1  34b8		       65		      .byte.b	101
      0  34b9					      db	(UNKNOWNVEC-*)-1
      1  34b9		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  34ba					      db	oRightBracket
      1  34ba		       e1		      .byte.b	oRightBracket
      0  34bb					      GETCHAR
      0  34bb					      db	51
      1  34bb		       33		      .byte.b	51
      0  34bc					      RTN
      0  34bc					      db	25
      1  34bc		       19		      .byte.b	25
    762  34bd							;
    763  34bd							;====================================================================================
    764  34bd							; addr(variable definition)
    765  34bd							; Returns the address of a variable on top of the stack
    766  34bd				   ekAddr
      0  34bd					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34bd					      db	101
      1  34bd		       65		      .byte.b	101
      0  34be					      db	(UNKNOWNVEC-*)-1
      1  34be		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  34bf					      db	oLeftBracket
      1  34bf		       e0		      .byte.b	oLeftBracket
      0  34c0					      TSTV	ExpectedVariable
      0  34c0					      db	33
      1  34c0		       21		      .byte.b	33
      0  34c1					      db	(ExpectedVariable-*)-1
      1  34c1		       07		      .byte.b	(ExpectedVariable-*)-1
      0  34c2					      CALL	FactVarPtrNoTst
      0  34c2					      db	28
      1  34c2		       1c		      .byte.b	28
      0  34c3					      dw	FactVarPtrNoTst
      1  34c3		       ce 35		      .word.w	FactVarPtrNoTst
      0  34c5					      TSTB	UNKNOWNVEC,oRightBracket
      0  34c5					      db	101
      1  34c5		       65		      .byte.b	101
      0  34c6					      db	(UNKNOWNVEC-*)-1
      1  34c6		       d6		      .byte.b	(UNKNOWNVEC-*)-1
      0  34c7					      db	oRightBracket
      1  34c7		       e1		      .byte.b	oRightBracket
      0  34c8					      RTN
      0  34c8					      db	25
      1  34c8		       19		      .byte.b	25
    772  34c9
    773  34c9				   ExpectedVariable
      0  34c9					      ERRMSG	ERR_SYNTAX	;Expected Variable
      0  34c9					      db	13
      1  34c9		       0d		      .byte.b	13
      0  34ca					      dw	ERR_SYNTAX
      1  34ca		       05 00		      .word.w	ERR_SYNTAX
    775  34cc							;
    776  34cc							;================================================================
    777  34cc							; Compare a block of memory
    778  34cc							; CmpMem(Length, Source 1, Source 2)
    779  34cc							; returns on the stack 0 equal, 1 s1>s2, -1 s1<s2
    780  34cc				   ekCmpMem
      0  34cc					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  34cc					      db	101
      1  34cc		       65		      .byte.b	101
      0  34cd					      db	(UNKNOWNVEC-*)-1
      1  34cd		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  34ce					      db	oLeftBracket
      1  34ce		       e0		      .byte.b	oLeftBracket
      0  34cf					      CALL	EXPR	; Length
      0  34cf					      db	28
      1  34cf		       1c		      .byte.b	28
      0  34d0					      dw	EXPR
      1  34d0		       1a 34		      .word.w	EXPR
      0  34d2					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  34d2					      db	101
      1  34d2		       65		      .byte.b	101
      0  34d3					      db	(UNKNOWNVEC-*)-1
      1  34d3		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  34d4					      db	oComma
      1  34d4		       e2		      .byte.b	oComma
      0  34d5					      CALL	EXPR	; Source 1
      0  34d5					      db	28
      1  34d5		       1c		      .byte.b	28
      0  34d6					      dw	EXPR
      1  34d6		       1a 34		      .word.w	EXPR
      0  34d8					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  34d8					      db	101
      1  34d8		       65		      .byte.b	101
      0  34d9					      db	(UNKNOWNVEC-*)-1
      1  34d9		       c3		      .byte.b	(UNKNOWNVEC-*)-1
      0  34da					      db	oComma
      1  34da		       e2		      .byte.b	oComma
      0  34db					      CALL	EXPR	; Source 2
      0  34db					      db	28
      1  34db		       1c		      .byte.b	28
      0  34dc					      dw	EXPR
      1  34dc		       1a 34		      .word.w	EXPR
      0  34de					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  34de					      db	101
      1  34de		       65		      .byte.b	101
      0  34df					      db	(UNKNOWNVEC-*)-1
      1  34df		       bd		      .byte.b	(UNKNOWNVEC-*)-1
      0  34e0					      db	oRightBracket
      1  34e0		       e1		      .byte.b	oRightBracket
      0  34e1					      CMPMEM		; Compare the memory
      0  34e1					      db	112
      1  34e1		       70		      .byte.b	112
      0  34e2					      RTN
      0  34e2					      db	25
      1  34e2		       19		      .byte.b	25
    790  34e3							;
    791  34e3							;===============================================================================
    792  34e3							; Set/stop/return timer values
    793  34e3							;value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    794  34e3							;cmd	0 =
    795  34e3				   eKTimer
      0  34e3					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  34e3					      db	101
      1  34e3		       65		      .byte.b	101
      0  34e4					      db	(UNKNOWNVEC-*)-1
      1  34e4		       b8		      .byte.b	(UNKNOWNVEC-*)-1
      0  34e5					      db	oLeftBracket
      1  34e5		       e0		      .byte.b	oLeftBracket
      0  34e6					      CALL	EXPR	; purpose 0-4
      0  34e6					      db	28
      1  34e6		       1c		      .byte.b	28
      0  34e7					      dw	EXPR
      1  34e7		       1a 34		      .word.w	EXPR
      0  34e9					      TSTB	eKTimerZero,oComma	; Must have a comma if more than one value
      0  34e9					      db	101
      1  34e9		       65		      .byte.b	101
      0  34ea					      db	(eKTimerZero-*)-1
      1  34ea		       07		      .byte.b	(eKTimerZero-*)-1
      0  34eb					      db	oComma
      1  34eb		       e2		      .byte.b	oComma
      0  34ec					      CALL	EXPR	; only used by set parameters
      0  34ec					      db	28
      1  34ec		       1c		      .byte.b	28
      0  34ed					      dw	EXPR
      1  34ed		       1a 34		      .word.w	EXPR
      0  34ef					      iJMP	eKTimerOut	; get out
      0  34ef					      db	29
      1  34ef		       1d		      .byte.b	29
      0  34f0					      dw	eKTimerOut
      1  34f0		       f5 34		      .word.w	eKTimerOut
    801  34f2				   eKTimerZero
      0  34f2					      lit	0	; no second parameter
      0  34f2					      db	27
      1  34f2		       1b		      .byte.b	27
      0  34f3					      dw	0
      1  34f3		       00 00		      .word.w	0
    803  34f5				   eKTimerOut
      0  34f5					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  34f5					      db	101
      1  34f5		       65		      .byte.b	101
      0  34f6					      db	(UNKNOWNVEC-*)-1
      1  34f6		       a6		      .byte.b	(UNKNOWNVEC-*)-1
      0  34f7					      db	oRightBracket
      1  34f7		       e1		      .byte.b	oRightBracket
      0  34f8					      Timer
      0  34f8					      db	114
      1  34f8		       72		      .byte.b	114
      0  34f9					      RTN
      0  34f9					      db	25
      1  34f9		       19		      .byte.b	25
    807  34fa
    808  34fa							;====================================================================================
    809  34fa							; peek(mem address) return the value of a byte in memory
    810  34fa							; @[offset] return a word value from offset -- see tstv
    811  34fa							;
    812  34fa							;F1A2:
    813  34fa							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    814  34fa				   ekPeek
      0  34fa					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34fa					      db	101
      1  34fa		       65		      .byte.b	101
      0  34fb					      db	(UNKNOWNVEC-*)-1
      1  34fb		       a1		      .byte.b	(UNKNOWNVEC-*)-1
      0  34fc					      db	oLeftBracket
      1  34fc		       e0		      .byte.b	oLeftBracket
      0  34fd					      CALL	EXPR	;Get the address to write to
      0  34fd					      db	28
      1  34fd		       1c		      .byte.b	28
      0  34fe					      dw	EXPR
      1  34fe		       1a 34		      .word.w	EXPR
      0  3500					      TSTB	UNKNOWNVEC,oRightBracket
      0  3500					      db	101
      1  3500		       65		      .byte.b	101
      0  3501					      db	(UNKNOWNVEC-*)-1
      1  3501		       9b		      .byte.b	(UNKNOWNVEC-*)-1
      0  3502					      db	oRightBracket
      1  3502		       e1		      .byte.b	oRightBracket
      0  3503					      PEEKMEM
      0  3503					      db	48
      1  3503		       30		      .byte.b	48
      0  3504					      RTN
      0  3504					      db	25
      1  3504		       19		      .byte.b	25
    820  3505							;=======================================================================================
    821  3505							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    822  3505							;
    823  3505							;F2AZ:
    824  3505							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    825  3505				   ekTask
      0  3505					      TSTBRANCH	ekTaskCompiled
      0  3505					      db	106
      1  3505		       6a		      .byte.b	106
      0  3506					      db	(ekTaskCompiled-*)-1
      1  3506		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  3507					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3507					      db	101
      1  3507		       65		      .byte.b	101
      0  3508					      db	(UNKNOWNVEC-*)-1
      1  3508		       94		      .byte.b	(UNKNOWNVEC-*)-1
      0  3509					      db	oLeftBracket
      1  3509		       e0		      .byte.b	oLeftBracket
      0  350a					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  350a					      db	28
      1  350a		       1c		      .byte.b	28
      0  350b					      dw	EXPR
      1  350b		       1a 34		      .word.w	EXPR
      0  350d					      lit	0
      0  350d					      db	27
      1  350d		       1b		      .byte.b	27
      0  350e					      dw	0
      1  350e		       00 00		      .word.w	0
      0  3510					      iJMP	ekTaskLinenum
      0  3510					      db	29
      1  3510		       1d		      .byte.b	29
      0  3511					      dw	ekTaskLinenum
      1  3511		       16 35		      .word.w	ekTaskLinenum
    831  3513
    832  3513				   ekTaskCompiled
      0  3513					      lit	1
      0  3513					      db	27
      1  3513		       1b		      .byte.b	27
      0  3514					      dw	1
      1  3514		       01 00		      .word.w	1
    834  3516
    835  3516				   ekTaskLinenum
      0  3516					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  3516					      db	61
      1  3516		       3d		      .byte.b	61
      0  3517					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  3517					      db	101
      1  3517		       65		      .byte.b	101
      0  3518					      db	(F2AZNoParms-*)-1
      1  3518		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  3519					      db	oComma
      1  3519		       e2		      .byte.b	oComma
      0  351a					      SAVEMATHSTACK		;Push The mathstack
      0  351a					      db	86
      1  351a		       56		      .byte.b	86
      0  351b					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  351b					      db	89
      1  351b		       59		      .byte.b	89
    840  351c
    841  351c				   F2AZLOOP
      0  351c					      CALL	EXPR
      0  351c					      db	28
      1  351c		       1c		      .byte.b	28
      0  351d					      dw	EXPR
      1  351d		       1a 34		      .word.w	EXPR
      0  351f					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  351f					      db	101
      1  351f		       65		      .byte.b	101
      0  3520					      db	(F2AZEndParm-*)-1
      1  3520		       04		      .byte.b	(F2AZEndParm-*)-1
      0  3521					      db	oComma
      1  3521		       e2		      .byte.b	oComma
      0  3522					      IJMP	F2AZLOOP	;check for more
      0  3522					      db	29
      1  3522		       1d		      .byte.b	29
      0  3523					      dw	F2AZLOOP
      1  3523		       1c 35		      .word.w	F2AZLOOP
    845  3525
    846  3525				   F2AZEndParm
      0  3525					      RESTOREMATHSTACK		;Back to normal stack
      0  3525					      db	87
      1  3525		       57		      .byte.b	87
      0  3526					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  3526					      db	92
      1  3526		       5c		      .byte.b	92
    849  3527
    850  3527				   F2AZNoParms
      0  3527					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  3527					      db	101
      1  3527		       65		      .byte.b	101
      0  3528					      db	(UNKNOWNVEC-*)-1
      1  3528		       74		      .byte.b	(UNKNOWNVEC-*)-1
      0  3529					      db	oRightBracket
      1  3529		       e1		      .byte.b	oRightBracket
    852  352a
      0  352a					      TASKENABLE		;Enable the task to execute
      0  352a					      db	90
      1  352a		       5a		      .byte.b	90
    854  352b
      0  352b					      RTN		;Returns the Task number
      0  352b					      db	25
      1  352b		       19		      .byte.b	25
    856  352c							;=========================================================================================
    857  352c							; Check for IPC interproccess instructions
    858  352c							;   IPCS  - Send a message
    859  352c							;
    860  352c							;F2AZ1:
    861  352c							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    862  352c				   ekIpcs
      0  352c					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  352c					      db	101
      1  352c		       65		      .byte.b	101
      0  352d					      db	(UNKNOWNVEC-*)-1
      1  352d		       6f		      .byte.b	(UNKNOWNVEC-*)-1
      0  352e					      db	oLeftBracket
      1  352e		       e0		      .byte.b	oLeftBracket
      0  352f					      CALL	EXPR	;Get the message value
      0  352f					      db	28
      1  352f		       1c		      .byte.b	28
      0  3530					      dw	EXPR
      1  3530		       1a 34		      .word.w	EXPR
      0  3532					      TSTB	UNKNOWNVEC,oComma
      0  3532					      db	101
      1  3532		       65		      .byte.b	101
      0  3533					      db	(UNKNOWNVEC-*)-1
      1  3533		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  3534					      db	oComma
      1  3534		       e2		      .byte.b	oComma
      0  3535					      CALL	EXPR	;Get pid of task to send to
      0  3535					      db	28
      1  3535		       1c		      .byte.b	28
      0  3536					      dw	EXPR
      1  3536		       1a 34		      .word.w	EXPR
      0  3538					      TSTB	UNKNOWNVEC,oRightBracket
      0  3538					      db	101
      1  3538		       65		      .byte.b	101
      0  3539					      db	(UNKNOWNVEC-*)-1
      1  3539		       63		      .byte.b	(UNKNOWNVEC-*)-1
      0  353a					      db	oRightBracket
      1  353a		       e1		      .byte.b	oRightBracket
      0  353b					      IPCSEND		;Send msg and clear pid msg pending
      0  353b					      db	80
      1  353b		       50		      .byte.b	80
      0  353c					      RTN
      0  353c					      db	25
      1  353c		       19		      .byte.b	25
    870  353d							;================================================================================
    871  353d							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    872  353d							;
    873  353d				   ekIpcr
      0  353d					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  353d					      db	101
      1  353d		       65		      .byte.b	101
      0  353e					      db	(UNKNOWNVEC-*)-1
      1  353e		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  353f					      db	oLeftBracket
      1  353f		       e0		      .byte.b	oLeftBracket
      0  3540					      TSTB	F2AZa1,oRightBracket
      0  3540					      db	101
      1  3540		       65		      .byte.b	101
      0  3541					      db	(F2AZa1-*)-1
      1  3541		       07		      .byte.b	(F2AZa1-*)-1
      0  3542					      db	oRightBracket
      1  3542		       e1		      .byte.b	oRightBracket
      0  3543					      LIT	0	;We dont want the pid returned to us
      0  3543					      db	27
      1  3543		       1b		      .byte.b	27
      0  3544					      dw	0
      1  3544		       00 00		      .word.w	0
      0  3546					      IJMP	ekIpcrComplete
      0  3546					      db	29
      1  3546		       1d		      .byte.b	29
      0  3547					      dw	ekIpcrComplete
      1  3547		       4e 35		      .word.w	ekIpcrComplete
    878  3549				   F2AZa1
      0  3549					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  3549					      db	33
      1  3549		       21		      .byte.b	33
      0  354a					      db	(UNKNOWNVEC-*)-1
      1  354a		       52		      .byte.b	(UNKNOWNVEC-*)-1
      0  354b					      TSTB	UNKNOWNVEC,oRightBracket
      0  354b					      db	101
      1  354b		       65		      .byte.b	101
      0  354c					      db	(UNKNOWNVEC-*)-1
      1  354c		       50		      .byte.b	(UNKNOWNVEC-*)-1
      0  354d					      db	oRightBracket
      1  354d		       e1		      .byte.b	oRightBracket
    881  354e
    882  354e				   ekIpcrComplete
      0  354e					      IPCIO		;Set the io bit and exit task till message
      0  354e					      db	83
      1  354e		       53		      .byte.b	83
      0  354f					      IPCRECEIVE		;Get the message
      0  354f					      db	81
      1  354f		       51		      .byte.b	81
      0  3550					      RTN
      0  3550					      db	25
      1  3550		       19		      .byte.b	25
    886  3551							;===============================================================================
    887  3551							; IPCC ---- check if a message is available
    888  3551				   ekIpcc
      0  3551					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3551					      db	101
      1  3551		       65		      .byte.b	101
      0  3552					      db	(UNKNOWNVEC-*)-1
      1  3552		       4a		      .byte.b	(UNKNOWNVEC-*)-1
      0  3553					      db	oLeftBracket
      1  3553		       e0		      .byte.b	oLeftBracket
      0  3554					      TSTB	UNKNOWNVEC,oRightBracket
      0  3554					      db	101
      1  3554		       65		      .byte.b	101
      0  3555					      db	(UNKNOWNVEC-*)-1
      1  3555		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  3556					      db	oRightBracket
      1  3556		       e1		      .byte.b	oRightBracket
      0  3557					      IPCCHECK
      0  3557					      db	82
      1  3557		       52		      .byte.b	82
      0  3558					      RTN
      0  3558					      db	25
      1  3558		       19		      .byte.b	25
    893  3559
    894  3559				   UNKNOWNID
      0  3559					      IJMP	UNKNOWN
      0  3559					      db	29
      1  3559		       1d		      .byte.b	29
      0  355a					      dw	UNKNOWN
      1  355a		       16 34		      .word.w	UNKNOWN
    896  355c							;============================================================
    897  355c							; RND() is supposed to have an argument but if none
    898  355c							; was provided, just assume a large value.
    899  355c							;
    900  355c				   ekRnd
      0  355c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  355c					      db	101
      1  355c		       65		      .byte.b	101
      0  355d					      db	(UNKNOWNVEC-*)-1
      1  355d		       3f		      .byte.b	(UNKNOWNVEC-*)-1
      0  355e					      db	oLeftBracket
      1  355e		       e0		      .byte.b	oLeftBracket
      0  355f					      TSTB	F2A1,oRightBracket
      0  355f					      db	101
      1  355f		       65		      .byte.b	101
      0  3560					      db	(F2A1-*)-1
      1  3560		       06		      .byte.b	(F2A1-*)-1
      0  3561					      db	oRightBracket
      1  3561		       e1		      .byte.b	oRightBracket
      0  3562					      LIT	32766
      0  3562					      db	27
      1  3562		       1b		      .byte.b	27
      0  3563					      dw	32766
      1  3563		       fe 7f		      .word.w	32766
      0  3565					      RANDOM
      0  3565					      db	37
      1  3565		       25		      .byte.b	37
      0  3566					      RTN
      0  3566					      db	25
      1  3566		       19		      .byte.b	25
    906  3567
    907  3567				   F2A1
      0  3567					      CALL	EXPR	;GET RANGE
      0  3567					      db	28
      1  3567		       1c		      .byte.b	28
      0  3568					      dw	EXPR
      1  3568		       1a 34		      .word.w	EXPR
      0  356a					      TSTB	UNKNOWNVEC,oRightBracket
      0  356a					      db	101
      1  356a		       65		      .byte.b	101
      0  356b					      db	(UNKNOWNVEC-*)-1
      1  356b		       31		      .byte.b	(UNKNOWNVEC-*)-1
      0  356c					      db	oRightBracket
      1  356c		       e1		      .byte.b	oRightBracket
      0  356d					      RANDOM
      0  356d					      db	37
      1  356d		       25		      .byte.b	37
      0  356e					      RTN
      0  356e					      db	25
      1  356e		       19		      .byte.b	25
    912  356f							;==========================================================
    913  356f							;	Return absolute value of expresion
    914  356f							;
    915  356f				   ekAbs
      0  356f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  356f					      db	101
      1  356f		       65		      .byte.b	101
      0  3570					      db	(UNKNOWNVEC-*)-1
      1  3570		       2c		      .byte.b	(UNKNOWNVEC-*)-1
      0  3571					      db	oLeftBracket
      1  3571		       e0		      .byte.b	oLeftBracket
      0  3572					      CALL	EXPR	;get value
      0  3572					      db	28
      1  3572		       1c		      .byte.b	28
      0  3573					      dw	EXPR
      1  3573		       1a 34		      .word.w	EXPR
      0  3575					      TSTB	UNKNOWNVEC,oRightBracket
      0  3575					      db	101
      1  3575		       65		      .byte.b	101
      0  3576					      db	(UNKNOWNVEC-*)-1
      1  3576		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  3577					      db	oRightBracket
      1  3577		       e1		      .byte.b	oRightBracket
      0  3578					      ABS
      0  3578					      db	38
      1  3578		       26		      .byte.b	38
      0  3579					      RTN
      0  3579					      db	25
      1  3579		       19		      .byte.b	25
    921  357a							;============================================================
    922  357a							;     Return the the status of a task, provide the PID
    923  357a							;
    924  357a				   ekStat
      0  357a					      TSTB	UNKNOWNVEC,oLeftBracket
      0  357a					      db	101
      1  357a		       65		      .byte.b	101
      0  357b					      db	(UNKNOWNVEC-*)-1
      1  357b		       21		      .byte.b	(UNKNOWNVEC-*)-1
      0  357c					      db	oLeftBracket
      1  357c		       e0		      .byte.b	oLeftBracket
      0  357d					      Call	EXPR
      0  357d					      db	28
      1  357d		       1c		      .byte.b	28
      0  357e					      dw	EXPR
      1  357e		       1a 34		      .word.w	EXPR
      0  3580					      TSTB	UNKNOWNVEC,oRightBracket
      0  3580					      db	101
      1  3580		       65		      .byte.b	101
      0  3581					      db	(UNKNOWNVEC-*)-1
      1  3581		       1b		      .byte.b	(UNKNOWNVEC-*)-1
      0  3582					      db	oRightBracket
      1  3582		       e1		      .byte.b	oRightBracket
      0  3583					      TASKSTAT
      0  3583					      db	66
      1  3583		       42		      .byte.b	66
      0  3584					      RTN
      0  3584					      db	25
      1  3584		       19		      .byte.b	25
    930  3585							;==============================================================
    931  3585							; Return the current tasks pid
    932  3585							;
    933  3585				   ekPid
      0  3585					      TASKPID
      0  3585					      db	77
      1  3585		       4d		      .byte.b	77
      0  3586					      RTN
      0  3586					      db	25
      1  3586		       19		      .byte.b	25
    936  3587							;===========================================================================
    937  3587							; Call a machine function, provide the address to call and optionally
    938  3587							; the value to be passed in reg A
    939  3587				   ekCall
      0  3587					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3587					      db	101
      1  3587		       65		      .byte.b	101
      0  3588					      db	(UNKNOWNVEC-*)-1
      1  3588		       14		      .byte.b	(UNKNOWNVEC-*)-1
      0  3589					      db	oLeftBracket
      1  3589		       e0		      .byte.b	oLeftBracket
      0  358a					      CALL	EXPR
      0  358a					      db	28
      1  358a		       1c		      .byte.b	28
      0  358b					      dw	EXPR
      1  358b		       1a 34		      .word.w	EXPR
      0  358d					      TSTB	F2B2A,oComma
      0  358d					      db	101
      1  358d		       65		      .byte.b	101
      0  358e					      db	(F2B2A-*)-1
      1  358e		       09		      .byte.b	(F2B2A-*)-1
      0  358f					      db	oComma
      1  358f		       e2		      .byte.b	oComma
      0  3590					      CALL	EXPR
      0  3590					      db	28
      1  3590		       1c		      .byte.b	28
      0  3591					      dw	EXPR
      1  3591		       1a 34		      .word.w	EXPR
      0  3593					      TSTB	UNKNOWNVEC,oRightBracket
      0  3593					      db	101
      1  3593		       65		      .byte.b	101
      0  3594					      db	(UNKNOWNVEC-*)-1
      1  3594		       08		      .byte.b	(UNKNOWNVEC-*)-1
      0  3595					      db	oRightBracket
      1  3595		       e1		      .byte.b	oRightBracket
      0  3596					      CALLFUNC
      0  3596					      db	53
      1  3596		       35		      .byte.b	53
      0  3597					      RTN
      0  3597					      db	25
      1  3597		       19		      .byte.b	25
    947  3598							; Run the gosub within this function
    948  3598				   F2B2A
      0  3598					      TSTB	UNKNOWNID,oRightBracket
      0  3598					      db	101
      1  3598		       65		      .byte.b	101
      0  3599					      db	(UNKNOWNID-*)-1
      1  3599		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  359a					      db	oRightBracket
      1  359a		       e1		      .byte.b	oRightBracket
      0  359b					      LIT	0	; No parameter passed so just load zero to A
      0  359b					      db	27
      1  359b		       1b		      .byte.b	27
      0  359c					      dw	0
      1  359c		       00 00		      .word.w	0
      0  359e					      CALLFUNC
      0  359e					      db	53
      1  359e		       35		      .byte.b	53
      0  359f					      RTN
      0  359f					      db	25
      1  359f		       19		      .byte.b	25
    953  35a0
    954  35a0
    955  35a0							;=================================================================================
    956  35a0							;Check for a number !
    957  35a0							;
    958  35a0				   FactNumber
      0  35a0					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  35a0					      db	35
      1  35a0		       23		      .byte.b	35
      0  35a1					      db	(FactVariable-*)-1
      1  35a1		       0f		      .byte.b	(FactVariable-*)-1
      0  35a2					      RTN
      0  35a2					      db	25
      1  35a2		       19		      .byte.b	25
    961  35a3
    962  35a3				   FactWithBracket
      0  35a3					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  35a3					      db	101
      1  35a3		       65		      .byte.b	101
      0  35a4					      db	(F2RTN-*)-1
      1  35a4		       08		      .byte.b	(F2RTN-*)-1
      0  35a5					      db	oLeftBracket
      1  35a5		       e0		      .byte.b	oLeftBracket
      0  35a6					      CALL	EXPR
      0  35a6					      db	28
      1  35a6		       1c		      .byte.b	28
      0  35a7					      dw	EXPR
      1  35a7		       1a 34		      .word.w	EXPR
      0  35a9					      TST	F2,oRightBracket
      0  35a9					      db	32
      1  35a9		       20		      .byte.b	32
      0  35aa					      db	(F2-*)-1
      1  35aa		       03		      .byte.b	(F2-*)-1
      0  35ab					      db	oRightBracket,0
      1  35ab		       e1 00		      .byte.b	oRightBracket,0
    966  35ad				   F2RTN
      0  35ad					      RTN
      0  35ad					      db	25
      1  35ad		       19		      .byte.b	25
    968  35ae
    969  35ae				   F2
      0  35ae					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  35ae					      db	13
      1  35ae		       0d		      .byte.b	13
      0  35af					      dw	ERR_SYNTAX
      1  35af		       05 00		      .word.w	ERR_SYNTAX
    971  35b1							;
    972  35b1							;=============================================================================
    973  35b1							; See if this is just a simple variable
    974  35b1							;  Allow a subscript for any variable
    975  35b1							;
    976  35b1				   FactVariable
    977  35b1
      0  35b1					      SETR2	tInteger
      0  35b1					      db	94
      1  35b1		       5e		      .byte.b	94
      0  35b2					      db	tInteger
      1  35b2		       a4		      .byte.b	tInteger
      0  35b3					      TSTV	FactWithBracket
      0  35b3					      db	33
      1  35b3		       21		      .byte.b	33
      0  35b4					      db	(FactWithBracket-*)-1
      1  35b4		       ee		      .byte.b	(FactWithBracket-*)-1
      0  35b5					      TSTBYTE	FactFNParm,R2,GOSUB_RTN_VALUE
      0  35b5					      db	97
      1  35b5		       61		      .byte.b	97
      0  35b6					      db	(FactFNParm-*)-1
      1  35b6		       08		      .byte.b	(FactFNParm-*)-1
      0  35b7					      dw	R2
      1  35b7		       58 00		      .word.w	R2
      0  35b9					      db	GOSUB_RTN_VALUE
      1  35b9		       81		      .byte.b	GOSUB_RTN_VALUE
      0  35ba					      CALL	FactVarPTR
      0  35ba					      db	28
      1  35ba		       1c		      .byte.b	28
      0  35bb					      dw	FactVarPTR
      1  35bb		       ce 35		      .word.w	FactVarPTR
    982  35bd							;	  CALL	      FactVariableValue
      0  35bd					      IND		; get the variable value
      0  35bd					      db	20
      1  35bd		       14		      .byte.b	20
      0  35be					      RTN
      0  35be					      db	25
      1  35be		       19		      .byte.b	25
    985  35bf
    986  35bf				   FactFNParm
      0  35bf					      TSTB	FactExpectedOpeningBracket,oLeftSQBracket
      0  35bf					      db	101
      1  35bf		       65		      .byte.b	101
      0  35c0					      db	(FactExpectedOpeningBracket-*)-1
      1  35c0		       44		      .byte.b	(FactExpectedOpeningBracket-*)-1
      0  35c1					      db	oLeftSQBracket
      1  35c1		       e4		      .byte.b	oLeftSQBracket
      0  35c2					      CALL	EXPR
      0  35c2					      db	28
      1  35c2		       1c		      .byte.b	28
      0  35c3					      dw	EXPR
      1  35c3		       1a 34		      .word.w	EXPR
      0  35c5					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  35c5					      db	101
      1  35c5		       65		      .byte.b	101
      0  35c6					      db	(FactMissingRightBracket-*)-1
      1  35c6		       3b		      .byte.b	(FactMissingRightBracket-*)-1
      0  35c7					      db	oRightSQBracket
      1  35c7		       e5		      .byte.b	oRightSQBracket
      0  35c8					      SUBSCRIPT	GOSUB_RTN_VALUE
      0  35c8					      db	64
      1  35c8		       40		      .byte.b	64
      0  35c9					      db	GOSUB_RTN_VALUE
      1  35c9		       81		      .byte.b	GOSUB_RTN_VALUE
      0  35ca					      SETR2	tInteger
      0  35ca					      db	94
      1  35ca		       5e		      .byte.b	94
      0  35cb					      db	tInteger
      1  35cb		       a4		      .byte.b	tInteger
      0  35cc					      IND
      0  35cc					      db	20
      1  35cc		       14		      .byte.b	20
      0  35cd					      RTN
      0  35cd					      db	25
      1  35cd		       19		      .byte.b	25
    994  35ce
    995  35ce				   FactVarPTR
    996  35ce				   FactVarPtrNoTst
      0  35ce					      TSTB	F2CLocalTask,oBang
      0  35ce					      db	101
      1  35ce		       65		      .byte.b	101
      0  35cf					      db	(F2CLocalTask-*)-1
      1  35cf		       04		      .byte.b	(F2CLocalTask-*)-1
      0  35d0					      db	oBang
      1  35d0		       e8		      .byte.b	oBang
      0  35d1					      IND		; we just got a pid
      0  35d1					      db	20
      1  35d1		       14		      .byte.b	20
      0  35d2					      TSTVT	UNKNOWNID	; if it is not another variable then error, Call test var. task
      0  35d2					      db	93
      1  35d2		       5d		      .byte.b	93
      0  35d3					      db	(UNKNOWNID-*)-1
      1  35d3		       85		      .byte.b	(UNKNOWNID-*)-1
   1000  35d4
   1001  35d4				   F2CLocalTask
      0  35d4					      SETR2	tInteger	; Sets the default type to integer
      0  35d4					      db	94
      1  35d4		       5e		      .byte.b	94
      0  35d5					      db	tInteger
      1  35d5		       a4		      .byte.b	tInteger
      0  35d6					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  35d6					      db	101
      1  35d6		       65		      .byte.b	101
      0  35d7					      db	(F2INTEGER-*)-1
      1  35d7		       11		      .byte.b	(F2INTEGER-*)-1
      0  35d8					      db	oDollar
      1  35d8		       e7		      .byte.b	oDollar
      0  35d9					      SETR2	tByte
      0  35d9					      db	94
      1  35d9		       5e		      .byte.b	94
      0  35da					      db	tByte
      1  35da		       a2		      .byte.b	tByte
      0  35db					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  35db					      db	101
      1  35db		       65		      .byte.b	101
      0  35dc					      db	(F2PTRLOADED-*)-1
      1  35dc		       22		      .byte.b	(F2PTRLOADED-*)-1
      0  35dd					      db	oLeftSQBracket
      1  35dd		       e4		      .byte.b	oLeftSQBracket
      0  35de					      CALL	EXPR
      0  35de					      db	28
      1  35de		       1c		      .byte.b	28
      0  35df					      dw	EXPR
      1  35df		       1a 34		      .word.w	EXPR
      0  35e1					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  35e1					      db	101
      1  35e1		       65		      .byte.b	101
      0  35e2					      db	(FactMissingRightBracket-*)-1
      1  35e2		       1f		      .byte.b	(FactMissingRightBracket-*)-1
      0  35e3					      db	oRightSQBracket
      1  35e3		       e5		      .byte.b	oRightSQBracket
      0  35e4					      SUBSCRIPT	tByte	; Byte type array
      0  35e4					      db	64
      1  35e4		       40		      .byte.b	64
      0  35e5					      db	tByte
      1  35e5		       a2		      .byte.b	tByte
      0  35e6					      SETR2	tByte	; Set byte data type
      0  35e6					      db	94
      1  35e6		       5e		      .byte.b	94
      0  35e7					      db	tByte
      1  35e7		       a2		      .byte.b	tByte
      0  35e8					      RTN
      0  35e8					      db	25
      1  35e8		       19		      .byte.b	25
   1011  35e9
   1012  35e9				   F2INTEGER
      0  35e9					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  35e9					      db	101
      1  35e9		       65		      .byte.b	101
      0  35ea					      db	(F2PTRLOADED-*)-1
      1  35ea		       14		      .byte.b	(F2PTRLOADED-*)-1
      0  35eb					      db	oLeftSQBracket
      1  35eb		       e4		      .byte.b	oLeftSQBracket
      0  35ec					      CALL	EXPR
      0  35ec					      db	28
      1  35ec		       1c		      .byte.b	28
      0  35ed					      dw	EXPR
      1  35ed		       1a 34		      .word.w	EXPR
      0  35ef					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  35ef					      db	101
      1  35ef		       65		      .byte.b	101
      0  35f0					      db	(FactMissingRightBracket-*)-1
      1  35f0		       11		      .byte.b	(FactMissingRightBracket-*)-1
      0  35f1					      db	oRightSQBracket
      1  35f1		       e5		      .byte.b	oRightSQBracket
      0  35f2					      SUBSCRIPT	tInteger	; Integer type array
      0  35f2					      db	64
      1  35f2		       40		      .byte.b	64
      0  35f3					      db	tInteger
      1  35f3		       a4		      .byte.b	tInteger
      0  35f4					      SETR2	tInteger	; Set word datatype
      0  35f4					      db	94
      1  35f4		       5e		      .byte.b	94
      0  35f5					      db	tInteger
      1  35f5		       a4		      .byte.b	tInteger
      0  35f6					      TSTB	F2PTRLOADED,oBang	; for a word it can be fillowed by a! as ref to other task variables
      0  35f6					      db	101
      1  35f6		       65		      .byte.b	101
      0  35f7					      db	(F2PTRLOADED-*)-1
      1  35f7		       07		      .byte.b	(F2PTRLOADED-*)-1
      0  35f8					      db	oBang
      1  35f8		       e8		      .byte.b	oBang
      0  35f9					      IND		; Get the value of the task context to access
      0  35f9					      db	20
      1  35f9		       14		      .byte.b	20
      0  35fa					      TSTVT	UNKNOWNID	; if it is not another variable name then it is a halt error
      0  35fa					      db	93
      1  35fa		       5d		      .byte.b	93
      0  35fb					      db	(UNKNOWNID-*)-1
      1  35fb		       5d		      .byte.b	(UNKNOWNID-*)-1
      0  35fc					      IJMP	FactVarPTR	; Process the value on the other side
      0  35fc					      db	29
      1  35fc		       1d		      .byte.b	29
      0  35fd					      dw	FactVarPTR
      1  35fd		       ce 35		      .word.w	FactVarPTR
   1022  35ff				   F2PTRLOADED
      0  35ff					      RTN
      0  35ff					      db	25
      1  35ff		       19		      .byte.b	25
   1024  3600
   1025  3600				   FactVariableValue
      0  3600					      IND		; YES, GET THE VALUE as word
      0  3600					      db	20
      1  3600		       14		      .byte.b	20
      0  3601					      RTN
      0  3601					      db	25
      1  3601		       19		      .byte.b	25
   1028  3602
   1029  3602				   FactMissingRightBracket
      0  3602					      IJMP	ReturnExpectBracket
      0  3602					      db	29
      1  3602		       1d		      .byte.b	29
      0  3603					      dw	ReturnExpectBracket
      1  3603		       36 36		      .word.w	ReturnExpectBracket
   1031  3605				   FactExpectedOpeningBracket
      0  3605					      ERRMSG	ERR_EXPECTED_OPENING_BRACKET
      0  3605					      db	13
      1  3605		       0d		      .byte.b	13
      0  3606					      dw	ERR_EXPECTED_OPENING_BRACKET
      1  3606		       1a 00		      .word.w	ERR_EXPECTED_OPENING_BRACKET
   1033  3608							;===============================================================================================================================
   1034  3608							;========================= Gosub and function interface ========================================================================
   1035  3608							; Process gosub 1000(Parm1, ...) no return value
   1036  3608							;
   1037  3608				   ekGosub
      0  3608					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  3608					      db	28
      1  3608		       1c		      .byte.b	28
      0  3609					      dw	GOSUBSTATEMENT
      1  3609		       3a 36		      .word.w	GOSUBSTATEMENT
      0  360b					      DONE		; ERROR IF CR NOT NEXT
      0  360b					      db	1
      1  360b		       01		      .byte.b	1
      0  360c					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  360c					      db	8
      1  360c		       08		      .byte.b	8
      0  360d					      db	GOSUB_RTN
      1  360d		       01		      .byte.b	GOSUB_RTN
      0  360e					      FASTXFER		; AND JUMP to sub rtn
      0  360e					      db	107
      1  360e		       6b		      .byte.b	107
   1042  360f							;
   1043  360f							; End of gosub processing
   1044  360f							;===========================================================================
   1045  360f							; Same as gosub but expects a return value
   1046  360f							;   FN 1000(parm1, ....)  Expects an integer to be returned
   1047  360f							;
   1048  360f				   ekGofn
      0  360f					      Call	GOSUBSTATEMENT
      0  360f					      db	28
      1  360f		       1c		      .byte.b	28
      0  3610					      dw	GOSUBSTATEMENT
      1  3610		       3a 36		      .word.w	GOSUBSTATEMENT
      0  3612					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  3612					      db	8
      1  3612		       08		      .byte.b	8
      0  3613					      db	GOSUB_RTN_VALUE
      1  3613		       81		      .byte.b	GOSUB_RTN_VALUE
      0  3614					      FASTXFER
      0  3614					      db	107
      1  3614		       6b		      .byte.b	107
   1052  3615
   1053  3615				   GOFNRet
      0  3615					      RTN
      0  3615					      db	25
      1  3615		       19		      .byte.b	25
   1055  3616							;===============================================================================================================================
   1056  3616							; Return from a gosub
   1057  3616							;
   1058  3616				   ekReturn
      0  3616					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  3616					      db	101
      1  3616		       65		      .byte.b	101
      0  3617					      db	(S2NoReturnValue-*)-1
      1  3617		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  3618					      db	oLeftBracket
      1  3618		       e0		      .byte.b	oLeftBracket
      0  3619					      CALL	EXPR
      0  3619					      db	28
      1  3619		       1c		      .byte.b	28
      0  361a					      dw	EXPR
      1  361a		       1a 34		      .word.w	EXPR
      0  361c					      TSTB	ReturnExpectBracket,oRightBracket	; Now a value is on the stack
      0  361c					      db	101
      1  361c		       65		      .byte.b	101
      0  361d					      db	(ReturnExpectBracket-*)-1
      1  361d		       18		      .byte.b	(ReturnExpectBracket-*)-1
      0  361e					      db	oRightBracket
      1  361e		       e1		      .byte.b	oRightBracket
      0  361f					      DONE
      0  361f					      db	1
      1  361f		       01		      .byte.b	1
      0  3620					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  3620					      db	9
      1  3620		       09		      .byte.b	9
      0  3621					      db	(S2RetFunc-*)-1
      1  3621		       11		      .byte.b	(S2RetFunc-*)-1
      0  3622					      db	1
      1  3622		       01		      .byte.b	1
      0  3623					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3623					      db	6
      1  3623		       06		      .byte.b	6
      0  3624					      dw	CO
      1  3624		       f9 31		      .word.w	CO
      0  3626					      IJMP	STMT	; Process the new statement
      0  3626					      db	29
      1  3626		       1d		      .byte.b	29
      0  3627					      dw	STMT
      1  3627		       01 32		      .word.w	STMT
   1066  3629
   1067  3629				   S2NoReturnValue
      0  3629					      DONE
      0  3629					      db	1
      1  3629		       01		      .byte.b	1
      0  362a					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  362a					      db	9
      1  362a		       09		      .byte.b	9
      0  362b					      db	(S2RetFunc-*)-1
      1  362b		       07		      .byte.b	(S2RetFunc-*)-1
      0  362c					      db	0
      1  362c		       00		      .byte.b	0
      0  362d					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  362d					      db	6
      1  362d		       06		      .byte.b	6
      0  362e					      dw	CO
      1  362e		       f9 31		      .word.w	CO
      0  3630					      IJMP	STMT	; Process the new statement
      0  3630					      db	29
      1  3630		       1d		      .byte.b	29
      0  3631					      dw	STMT
      1  3631		       01 32		      .word.w	STMT
   1072  3633
   1073  3633				   S2RetFunc
      0  3633					      IJMP	GOFNRet	; Back into the Function
      0  3633					      db	29
      1  3633		       1d		      .byte.b	29
      0  3634					      dw	GOFNRet
      1  3634		       15 36		      .word.w	GOFNRet
   1075  3636
   1076  3636				   ReturnExpectBracket
      0  3636					      ENDIO
      0  3636					      db	71
      1  3636		       47		      .byte.b	71
      0  3637					      ERRMSG	ERR_CLOSINGBRACKET
      0  3637					      db	13
      1  3637		       0d		      .byte.b	13
      0  3638					      dw	ERR_CLOSINGBRACKET
      1  3638		       17 00		      .word.w	ERR_CLOSINGBRACKET
   1079  363a							;
   1080  363a							; End of return from gosub
   1081  363a							;=============================================================
   1082  363a							; Gosub can be both a Function and a Subroutine
   1083  363a				   GOSUBSTATEMENT
      0  363a					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  363a					      db	106
      1  363a		       6a		      .byte.b	106
      0  363b					      db	(GOSUBCOMPILED-*)-1
      1  363b		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  363c					      CALL	EXPR	; GET DESTINATION
      0  363c					      db	28
      1  363c		       1c		      .byte.b	28
      0  363d					      dw	EXPR
      1  363d		       1a 34		      .word.w	EXPR
      0  363f					      CALL	GOSUBCONT
      0  363f					      db	28
      1  363f		       1c		      .byte.b	28
      0  3640					      dw	GOSUBCONT
      1  3640		       4d 36		      .word.w	GOSUBCONT
      0  3642					      lit	0	; mark as lookup on stack
      0  3642					      db	27
      1  3642		       1b		      .byte.b	27
      0  3643					      dw	0
      1  3643		       00 00		      .word.w	0
      0  3645					      RTN
      0  3645					      db	25
      1  3645		       19		      .byte.b	25
   1089  3646
   1090  3646				   GOSUBCOMPILED
      0  3646					      CALL	GOSUBCONT
      0  3646					      db	28
      1  3646		       1c		      .byte.b	28
      0  3647					      dw	GOSUBCONT
      1  3647		       4d 36		      .word.w	GOSUBCONT
      0  3649					      lit	1	;mark as compiled on stack
      0  3649					      db	27
      1  3649		       1b		      .byte.b	27
      0  364a					      dw	1
      1  364a		       01 00		      .word.w	1
      0  364c					      RTN
      0  364c					      db	25
      1  364c		       19		      .byte.b	25
   1094  364d
   1095  364d				   GOSUBCONT
      0  364d					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters If not bracket get out
      0  364d					      db	101
      1  364d		       65		      .byte.b	101
      0  364e					      db	(GOSUBDONE-*)-1
      1  364e		       11		      .byte.b	(GOSUBDONE-*)-1
      0  364f					      db	oLeftBracket
      1  364f		       e0		      .byte.b	oLeftBracket
      0  3650					      STK2TMP		;Transfer stack top to temp, temp gets line to goto
      0  3650					      db	95
      1  3650		       5f		      .byte.b	95
      0  3651					      PUSHMATHSTACK		;Record stack frame for return
      0  3651					      db	84
      1  3651		       54		      .byte.b	84
   1099  3652				   GOSUBLOOP
      0  3652					      CALL	EXPR	; Allows what ever fits onto stack
      0  3652					      db	28
      1  3652		       1c		      .byte.b	28
      0  3653					      dw	EXPR
      1  3653		       1a 34		      .word.w	EXPR
      0  3655					      INCPARMCOUNT
      0  3655					      db	88
      1  3655		       58		      .byte.b	88
      0  3656					      TSTB	GOSUBParmDONE,oComma
      0  3656					      db	101
      1  3656		       65		      .byte.b	101
      0  3657					      db	(GOSUBParmDONE-*)-1
      1  3657		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  3658					      db	oComma
      1  3658		       e2		      .byte.b	oComma
      0  3659					      IJMP	GOSUBLOOP
      0  3659					      db	29
      1  3659		       1d		      .byte.b	29
      0  365a					      dw	GOSUBLOOP
      1  365a		       52 36		      .word.w	GOSUBLOOP
   1104  365c				   GOSUBParmDONE
      0  365c					      TSTB	ReturnExpectBracket,oRightBracket
      0  365c					      db	101
      1  365c		       65		      .byte.b	101
      0  365d					      db	(ReturnExpectBracket-*)-1
      1  365d		       d8		      .byte.b	(ReturnExpectBracket-*)-1
      0  365e					      db	oRightBracket
      1  365e		       e1		      .byte.b	oRightBracket
      0  365f					      TMP2STK		; Restore line to goto
      0  365f					      db	96
      1  365f		       60		      .byte.b	96
   1107  3660				   GOSUBDONE
      0  3660					      RTN
      0  3660					      db	25
      1  3660		       19		      .byte.b	25
   1109  3661
   1110  3661		       36 61	   ILEND      equ	*
------- FILE mytb.asm
   2500  3661		       36 61	   PROGEND    equ	*
   2501  3661
   2502  3661
   2503  3661							;=====================================================
   2504  3661							; Define start of non page zero data
   2505 U36b4					      seg.u	TBData
   2506 U36b4
   2507 U36b4							;=====================================================
   2508 U36b4							; These are storage items not in page zero.
   2509 U36b4							;==================================================================================================
   2510 U36b4							; Task Management information
   2511 U36b4							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2512 U36b4							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2513 U36b4							; Task switchs happen at the beginning of the next Basic command line
   2514 U36b4							; It will not happen during an input or output operations
   2515 U36b4							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2516 U36b4							; Task Zero is always the root task, main line program
   2517 U36b4							;
   2518 U36b4							; Layout is repeated for each configured task
   2519 U36b4							; Task Table Byte   use masks follow
   2520 U36b4		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2521 U36b4		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2522 U36b4		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2523 U36b4		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2524 U36b4		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2525 U36b4
   2526 U36b4		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2527 U36b5		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2528 U36b5		       37 af	   TASKTABLEEND equ	*	; End of task table
   2529 U36b5		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2530 U37af
   2531 U37af							;Task Cycle Counter and reset count
   2532 U37af		       00 00	   taskCurrentCycles ds	2
   2533 U37b1		       00 00	   taskResetValue ds	2
   2534 U37b3		       00	   taskCounter ds	1	; Count of active tasks
   2535 U37b4
   2536 U37b4							;
   2537 U37b4							; Math stack and IL call and Gosub/For-next return stack definitions
   2538 U37b4							;
   2539 U37b4		       37 b4	   STACKSTART equ	*
   2540 U37b4		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2541 U3944		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2542 U3d2c		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2543 U3fac		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code,taskio block stdin,stdout,stdstat,iostatus
   2544 U3fac		       00 48	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2545 U3fac		       42 90	   STACKEND   equ	*
   2546 U3fac		       0a dc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2547 U4290							;
   2548 U4290							;
   2549 U4290		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2550 U4314		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2551 U4315		       00	   printtx    ds	1	;temp X for print funcs
   2552 U4316		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2553 U4317		       00	   promptChar ds	1	;the character to use for a prompt
   2554 U4318		       00	   diddigit   ds	1	;for leading zero suppression
   2555 U4319		       00	   putsy      ds	1
   2556 U431a		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2557 U431c		       00	   sign       ds	1	;0 = positive, else negative
   2558 U431d		       00 00	   rtemp1     ds	2	;Temp for x and y
   2559 U431f		       00 00	   random     ds	2
   2560 U4321		       00	   tempy      ds	1	;temp y storage
   2561 U4322
   2562 U4322
   2563 U4322							; Moved from page zero as one clock cycle diff gives more space on page zero
   2564 U4322		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2565 U4324		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2566 U4325		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2567 U4326		       00	   lineLength ds	1	;Length of current line
   2568 U4327
   2569 U4327		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2570 U4328		       00	   taskRDPending ds	1	; 1 = background read is pending
   2571 U4329		       00 00 00 00 timercounter ds	4	; if timer is running then this is continuously incremented
   2572 U432d
   2573 U432d				  -	      if	XKIM
   2574 U432d				  -buffer     ds	BUFFER_SIZE
   2575 U432d					      endif
   2576 U432d							;
   2577 U432d							; PROGRAMEND is the end of the user's BASIC program.
   2578 U432d							; More precisely, it is one byte past the end.  Or,
   2579 U432d							; it's where the next line added to the end will be
   2580 U432d							; placed.
   2581 U432d							;
   2582 U432d		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2583 U432f		       00 00	   ProgramEnd ds	2	; End of users basic program, Next free byte after end
   2584 U4331		       00 00	   HighMem    ds	2	; highest location
   2585 U4333		       00 00	   UsedMem    ds	2	; size of user program
   2586 U4335		       00 00	   FreeMem    ds	2	; amount of free memory
   2587 U4337							;
   2588 U4337							;=====================================================
   2589 U4337							; This is the start of the user's BASIC program space.
   2590 U4337							;
   2591 U4337							; PERSONAL GOAL: This should be no larger than $0DFF.
   2592 U4337							;		  0200-05FF = 1K
   2593 U4337							;		  0200-09FF = 2K
   2594 U4337							;		  0200-0DFF = 3K
   2595 U4337							;		  0200-11FF = 4K
   2596 U4337							;		  0200-13FF = 4.5K
   2597 U4337							;
   2598 U4337				  -	      if	FIXED
   2599 U4337				  -	      org	$2000
   2600 U4337					      endif
   2601 U4337
   2602 U4337		       43 37	   FreeMemStart equ	*
   2603 U4337							;/*
   2604 U4337							;  if	  CTMON65 || XKIM
   2605 U4337							;	  SEG Code
   2606 U4337							;	  org	  AutoRun
   2607 U4337							;	  dw	  TBasicCold
   2608 U4337							;  endif
   2609 U4337							;*/
   2610 U4337					      end
