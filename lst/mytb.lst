------- FILE mytb.asm LEVEL 1 PASS 6
      1 U4222				   input      processor	6502
      2 U4222 ????						;=====================================================
      3 U4222 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U4222 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U4222 ????						; Free Time. Now abiut 6K Full OS features.
      6 U4222 ????						;
      7 U4222 ????						; While working on the Corsham Technologies KIM Clone
      8 U4222 ????						; project, I wanted to include a TINY BASIC since that
      9 U4222 ????						; was a highly desirable feature of early computers.
     10 U4222 ????						;
     11 U4222 ????						; Rather than negotiating copyright issues for
     12 U4222 ????						; existing BASICs, I decided to just write one from
     13 U4222 ????						; scratch.
     14 U4222 ????						;
     15 U4222 ????						; 10/07/2017
     16 U4222 ????						;
     17 U4222 ????						; This implements a stripped down Tiny BASIC
     18 U4222 ????						; interpreter using the Interpretive Language (IL)
     19 U4222 ????						; method as described in the first few issues of
     20 U4222 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U4222 ????						; to write various languages simply by changing the
     22 U4222 ????						; IL code rather than the interpreter itself.
     23 U4222 ????						;
     24 U4222 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U4222 ????						;		* Fixed major bug in findLine that
     26 U4222 ????						;		  caused corrupted lines, crashes, etc.
     27 U4222 ????						;		* If no parameter given to RND, assume
     28 U4222 ????						;		  32766.
     29 U4222 ????						;		* No more error 5 when a program
     30 U4222 ????						;		  reaches the end without an END.
     31 U4222 ????						;
     32 U4222 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U4222 ????						;		 * Unexpanded version to play with everything
     34 U4222 ????						;		 * Add some usefull system level functions
     35 U4222 ????						;		 * allow a larger number of tiny basic formats
     36 U4222 ????						;		 * Add byte at start of line holding length
     37 U4222 ????						;		   for faster execution of goto and gosub
     38 U4222 ????						;		 * Re-added gosub
     39 U4222 ????						;		 * allow ; or , at end if print stmt
     40 U4222 ????						;		   without CRLF being added.
     41 U4222 ????						;		 * Added extended function erase to
     42 U4222 ????						;		   use the extended ctmon65 rm file
     43 U4222 ????						;		 * Fix quoted text to not have to backtrack
     44 U4222 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U4222 ????						;		 * Add concurrency features
     46 U4222 ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U4222 ????						;
     48 U4222 ????						; www.corshamtech.com
     49 U4222 ????						; bob@corshamtech.com
     50 U4222 ????						; JustLostInTime@gmail.com
     51 U4222 ????						;
     52 U4222 ????						;=====================================================
     53 U4222 ????						;
     54 U4222 ????						; Create TRUE and FALSE values for conditionals.
     55 U4222 ????						;
     56 U4222 ????
     57 U4222 ????	       00 00	   FALSE      equ	0
     58 U4222 ????	       ff ff ff ff TRUE       equ	~FALSE
     59 U4222 ????						;
     60 U4222 ????						;---------------------------------------------------------
     61 U4222 ????						; One of these must be set to indicate which environment
     62 U4222 ????						; Tiny BASIC will be running in.  Here are the current
     63 U4222 ????						; environments:
     64 U4222 ????						;
     65 U4222 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     66 U4222 ????						; more K of RAM.
     67 U4222 ????						;
     68 U4222 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     69 U4222 ????						; which enhances, without replacing, the standard KIM
     70 U4222 ????						; monitor.  It gives access to routines to save/load files
     71 U4222 ????						; to a micro SD card.
     72 U4222 ????						;
     73 U4222 ????						; CTMON65 is a from-scratch monitor written for the
     74 U4222 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     75 U4222 ????						; easily be ported to other systems.  It has support for
     76 U4222 ????						; using a micro SD card for file storage/retrieval.
     77 U4222 ????						;
     78 U4222 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     79 U4222 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     80 U4222 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     81 U4222 ????	       ff ff ff ff IL_DEBUG_TEXT equ	TRUE	;Print out as text IL instructions
     82 U4222 ????						;
     83 U4222 ????						;   Need to define some macros for the dasm assembler
     84 U4222 ????						;
     85 U4222 ????				      MACRO	dw
     86 U4222 ????				      .word	{0}
     87 U4222 ????				      ENDM
     88 U4222 ????
     89 U4222 ????				      MACRO	db
     90 U4222 ????				      .byte	{0}
     91 U4222 ????				      ENDM
     92 U4222 ????
     93 U4222 ????						;
     94 U4222 ????						; If set, include disk functions.
     95 U4222 ????						;
     96 U4222 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U4222 ????						;
     98 U4222 ????						; If ILTRACE is set then dump out the address of every
     99 U4222 ????						; IL opcode before executing it.
    100 U4222 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U4222 ????						;
    102 U4222 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U4222 ????						;
    104 U4222 ????						; If FIXED is set, put the IL code and the user
    105 U4222 ????						; program space at fixed locations in memory.	This is
    106 U4222 ????						; meant only for debugging.
    107 U4222 ????						;
    108 U4222 ????	       00 00	   FIXED      equ	FALSE
    109 U4222 ????
    110 U4222 ????	       00 0f	   terminalIOblockLen equ	[TerminalIOblockEnd - TerminalIOblock]
    111 U4222 ????
    112 U4222 ????						;
    113 U4222 ????						; Sets the arithmetic stack depth.  This is *TINY*
    114 U4222 ????						; BASIC, so keep this small!
    115 U4222 ????						;
    116 U4222 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    117 U4222 ????	       00 32	   ILSTACKSIZE equ	50	;number of entries in ilstack
    118 U4222 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    119 U4222 ????	       00 25	   VARIABLESSIZE equ	37	;26 variables + 1 for exit code + 10 entries (20bytes) for ioblock
    120 U4222 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    121 U4222 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    122 U4222 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    123 U4222 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    124 U4222 ????
    125 U4222 ????	       00 36	   taskSTDIN  equ	[[VARIABLESSIZE - 10]*2]	;io vector
    126 U4222 ????	       00 38	   taskSTDOUT equ	[[[VARIABLESSIZE - 10]*2]+2]	;io vector
    127 U4222 ????
    128 U4222 ????	       00 3f	   taskIOinPort equ	[[[VARIABLESSIZE - 10]*2]+4+5]	;Offset into the ioblock
    129 U4222 ????	       00 3b	   taskIOoutPort equ	[[[VARIABLESSIZE - 10]*2]+4+1]	;Offset into the ioblock
    130 U4222 ????	       00 46	   taskIOstatusPort equ	[[[VARIABLESSIZE - 10]*2]+4+12]	;Offset into the ioblock
    131 U4222 ????						;
    132 U4222 ????						; Gosub entry types
    133 U4222 ????
    134 U4222 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    135 U4222 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    136 U4222 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    137 U4222 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    138 U4222 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    139 U4222 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    140 U4222 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    141 U4222 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    142 U4222 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    143 U4222 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    144 U4222 ????						;
    145 U4222 ????						; Common ASCII constants
    146 U4222 ????						;
    147 U4222 ????	       00 07	   BEL	      equ	$07
    148 U4222 ????	       00 08	   BS	      equ	$08
    149 U4222 ????	       00 09	   TAB	      equ	$09
    150 U4222 ????	       00 0a	   LF	      equ	$0A
    151 U4222 ????	       00 0d	   CR	      equ	$0D
    152 U4222 ????	       00 22	   quote      equ	$22
    153 U4222 ????	       00 20	   SPACE      equ	$20
    154 U4222 ????	       00 2c	   COMMA      equ	',
    155 U4222 ????	       00 3b	   SEMICOLON  equ	';
    156 U4222 ????	       00 3a	   COLON      equ	':
    157 U4222 ????	       00 24	   DOLLAR     equ	'$
    158 U4222 ????						;
    159 U4222 ????						; These are error codes
    160 U4222 ????						;
    161 U4222 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    162 U4222 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    163 U4222 ????	       00 02	   ERR_UNDER  equ	2	;The Math stack underflow
    164 U4222 ????	       00 03	   ERR_OVER   equ	3	;The Math stack overflow
    165 U4222 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    166 U4222 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    167 U4222 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    168 U4222 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    169 U4222 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    170 U4222 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    171 U4222 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    172 U4222 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    173 U4222 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;the gosub Stack overflow
    174 U4222 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    175 U4222 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    176 U4222 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    177 U4222 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    178 U4222 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    179 U4222 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    180 U4222 ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    181 U4222 ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    182 U4222 ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    183 U4222 ????	       00 16	   ERR_EXPECTVAR equ	22	;Expected a variable name or definition
    184 U4222 ????	       00 17	   ERR_CLOSINGBRACKET equ	23	;Expected a closing bracket
    185 U4222 ????	       00 18	   ERR_MISSINGEQUALSIGN equ	24	;Expected an equal sign for assignment
    186 U4222 ????	       00 19	   ERR_FUNCTION_EXPECTED_PARAMETERS equ	25	;Function expected parameters
    187 U4222 ????	       00 1a	   ERR_EXPECTED_OPENING_BRACKET equ	26	;Expected opening bracket [ or (
    188 U4222 ????						;
    189 U4222 ????						;=====================================================
    190 U4222 ????						; Zero page storage.
    191 U4222 ????						;
    192 U00f6 ????				      SEG.U	ZEROPAGE
    193 U0040					      org	$0040
    194 U0040
    195 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    196 U0041
    197 U0041							; The context is used to locate a task switch
    198 U0041							; it copies from here till all task fields are saved/swapped
    199 U0041							; The max number of tasks is 256 / context length
    200 U0041							; All positions POS values are plus one task table incldues
    201 U0041							; a leading status byte .
    202 U0041							;
    203 U0041		       00 41	   CONTEXT    equ	*
    204 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    205 U0041
    206 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    207 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    208 U0043
    209 U0043		       00 00	   ILPC       ds	2	; IL program counter
    210 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    211 U0047		       00	   ILSTACKPTR ds	1
    212 U0048
    213 U0048
    214 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    215 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    216 U004a
    217 U004a
    218 U004a		       00	   MATHSTACKPTR ds	1
    219 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    220 U004b
    221 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    222 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT + 1	; Get the offset to the gosub/msg stack
    223 U004d
    224 U004d
    225 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    226 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    227 U004e
    228 U004e
    229 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    230 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    231 U004f							;
    232 U004f							; CURPTR is a pointer to curent BASIC line being
    233 U004f							; executed.  Always points to start of line, CUROFF
    234 U004f							; is the offset to the current character.
    235 U004f							; The order of these fields is important
    236 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    237 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    238 U0052							;
    239 U0052							;The order of these fields in important
    240 U0052
    241 U0052							;
    242 U0052							; R0, R1 and MQ are used for arithmetic operations and
    243 U0052							; general use.
    244 U0052							;
    245 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    246 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    247 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    248 U0056		       00 00	   MQ	      ds	2	;used for some math
    249 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    250 U0058		       00 59	   REGISTERSEND equ	*
    251 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    252 U0059
    253 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    254 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    255 U0059
    256 U0059		       00 00	   dpl	      ds	2	; Used as a pointer to call il instructions
    257 U005b							;
    258 U005b							; This is zero if in immediate mode, or non-zero
    259 U005b							; if currently running a program.  Any input from
    260 U005b							; the main loop clears this, and the XFER IL
    261 U005b							; statement will set it.
    262 U005b							;
    263 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    264 U005c							;
    265 U005c							; Used for line insertion/removal.
    266 U005c							;
    267 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    268 U005e
    269 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    270 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    271 U005e							;
    272 U005e		       00 00	   PrtFrom    ds	2	; FROM
    273 U0060
    274 U0060							;
    275 U0060							;=====================================================
    276 U0060							;
    277  3550 ????				      SEG	Code
    278  0200					      org	$0200
    279  0200							;
    280  0200							; Cold start is at $0200.  Warm start is at $0203.
    281  0200							;
    282  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    283  0203		       4c 82 02    warm       jmp	warm2	;Entry point for worm restart
    284  0206							;
    285  0206							; These are the user-supplied vectors to I/O routines.
    286  0206							; If you want, you can just patch these in the binary
    287  0206							; file, but it would be better to change the source
    288  0206							; code.
    289  0206							;
    290  0206				  -	      if	KIM
    291  0206				  -OUTCH      jmp	$1ea0	;output char in A
    292  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    293  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    294  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    295  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    296  0206					      endif
    297  0206				  -	      if	XKIM
    298  0206				  -	      include	"xkim.inc"
    299  0206				  -	      SEG	Code
    300  0206				  -OUTCH      jmp	$1ea0
    301  0206				  -GETCH      jmp	xkGETCH
    302  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    303  0206				  -OUTHEX     jmp	xkPRTBYT
    304  0206				  -MONITOR    jmp	extKIM
    305  0206				  -puts       equ	putsil
    306  0206				  -BUFFER_SIZE equ	132
    307  0206					      endif
    308  0206
    309  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0060					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    311 Udf8e
    312  0206					      SEG	Code
    313  0206							;
    314  0206		       f0 0c	   OUTCH      equ	cout
    315  0206		       f0 09	   GETCH      equ	cin
    316  0206		       2c 84	   CRLF       equ	tbcrlf
    317  0206		       20 db	   OUTHEX     equ	HexToOut
    318  0206		       f0 03	   MONITOR    equ	WARM
    319  0206		       f0 0f	   ISCHAR     equ	cstatus
    320  0206		       20 f8	   puts       equ	tbputs
    321  0206					      endif
    322  0206							;
    323  0206		       20 cb 2d    cold2      jsr	SetOutConsole
    324  0209		       20 d8 2d 	      jsr	SetInConsole
    325  020c		       20 f8 20 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      0  0241					      db	CR,LF,0
      1  0241		       0d 0a 00 	      .byte.b	CR,LF,0
    329  0244							;
    330  0244		       20 ec 22 	      jsr	MemInit	;setup the free space available
    331  0247
    332  0247		       a9 01	   calcstack  lda	#1
    333  0249		       8d a2 36 	      sta	taskCounter	; Initialize number of tasks to 1
    334  024c		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    335  024e		       8d a4 35 	      sta	taskTable	; mark the main task as active
    336  0251		       20 2d 25 	      jsr	taskSetStacks	; setup all the task stacks/Variables, Init task io block
    337  0254		       a9 f7		      lda	#IL&$ff
    338  0256		       85 43		      sta	ILPC
    339  0258		       a9 30		      lda	#IL>>8
    340  025a		       85 44		      sta	ILPC+1
    341  025c							;
    342  025c							;		  lda	  ProgramStart		     ; user prog
    343  025c							;		  sta	  ProgramEnd
    344  025c							;		  lda	  ProgramStart+1
    345  025c							;		  sta	  ProgramEnd+1
    346  025c							;
    347  025c
    348  025c							;  Init time slices defaults
    349  025c		       a9 02		      lda	#TASKCYCLESHIGH
    350  025e		       8d a1 36 	      sta	taskResetValue+1
    351  0261		       a9 ff		      lda	#TASKCYCLESDEFAULT
    352  0263		       8d a0 36 	      sta	taskResetValue
    353  0266							;
    354  0266							; Initialize the pseudo-random number sequence...
    355  0266							;
    356  0266		       a9 5a		      lda	#$5a
    357  0268		       8d 0c 42 	      sta	rtemp1
    358  026b		       a9 9d		      lda	#%10011101
    359  026d		       8d 0e 42 	      sta	random
    360  0270		       a9 5b		      lda	#%01011011
    361  0272		       8d 0f 42 	      sta	random+1
    362  0275							;
    363  0275							;   Insert a Basic irq handler for the basic Language
    364  0275		       a9 b6		      lda	#ServiceIrq&$ff
    365  0277		       8d 00 df 	      sta	IRQvec
    366  027a		       a9 19		      lda	#ServiceIrq>>8
    367  027c		       8d 01 df 	      sta	IRQvec+1
    368  027f		       4c 95 02 	      jmp	coldtwo
    369  0282
    370  0282							;
    371  0282							;
    372  0282							; This is the warm start entry point
    373  0282							;
    374  0282		       20 cb 2d    warm2      jsr	SetOutConsole
    375  0285		       20 d8 2d 	      jsr	SetInConsole
    376  0288		       20 84 2c 	      jsr	CRLF
    377  028b		       ad 09 42 	      lda	errGoto
    378  028e		       85 43		      sta	ILPC
    379  0290		       ad 0a 42 	      lda	errGoto+1
    380  0293		       85 44		      sta	ILPC+1
    381  0295							;
    382  0295							; And continue with both starts here
    383  0295							;
    384  0295				   coldtwo
    385  0295							;
    386  0295							; The ILTrace flag is now run-time settable.
    387  0295							;
    388  0295		       a9 00		      lda	#ILTRACE&$ff
    389  0297		       85 40		      sta	ILTrace
    390  0299							;
    391  0299
    392  0299		       a9 00		      lda	#0
    393  029b		       85 5b		      sta	RunMode
    394  029d		       8d 7f 41 	      sta	LINBUF
    395  02a0
    396  02a0							; Clear everything from the stacks
    397  02a0
    398  02a0		       8d 16 42 	      sta	taskIOPending	; No one waiting for io
    399  02a3		       8d 17 42 	      sta	taskRDPending	; No one waiting for bg io
    400  02a6
    401  02a6		       20 a9 25 	      jsr	taskReset
    402  02a9							;
    403  02a9		       a9 7f		      lda	#LINBUF&$ff
    404  02ab		       85 4f		      sta	CURPTR
    405  02ad		       a9 41		      lda	#LINBUF>>8
    406  02af		       85 50		      sta	CURPTR+1	;fall through...
    407  02b1
    408  02b1							;=====================================================
    409  02b1							; This is the top of the IL interpreter.  This fetches
    410  02b1							; and executes the instruction currently pointed to
    411  02b1							; by ILPC and adjusts ILPC to point to the next
    412  02b1							; instruction to execute.
    413  02b1							;
    414  02b1				   NextIL
    415  02b1		       ba		      tsx		; Get the stack pointer value
    416  02b2		       e0 ff		      cpx	#$FF	; Should be empty
    417  02b4		       d0 26		      bne	ILbad	; Halt and catch fire now!
    418  02b6
    419  02b6		       ce 9e 36 	      dec	taskCurrentCycles
    420  02b9		       d0 03		      bne	NextIlNow
    421  02bb		       20 d2 25 	      jsr	iTaskSwitch	;check for a task switch
    422  02be		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    423  02c0		       f0 03		      beq	NextIL2	;Skip if no bits set
    424  02c2
    425  02c2		       20 15 2d 	      jsr	dbgLine	;Print the IL trace information
    426  02c5
    427  02c5		       a4 51	   NextIL2    ldy	CUROFF
    428  02c7							;		  jsr	  SkipSpaces
    429  02c7							;		  sty	  CUROFF
    430  02c7							;Task IO Management
    431  02c7		       ad 17 42 	      lda	taskRDPending	; if it is zero then Nothing pending
    432  02ca		       f0 08		      beq	NextILStr
    433  02cc		       20 bd 2a 	      jsr	ReadLine	; else Pending and poll keyboard
    434  02cf		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    435  02d1		       ce 17 42 	      dec	taskRDPending	; Carry is set if CR has been recieved
    436  02d4							;
    437  02d4		       20 40 29    NextILStr  jsr	getILByte
    438  02d7							;
    439  02d7							; When the handler is called, these are the conditions
    440  02d7							; of several important items:
    441  02d7							;
    442  02d7							;    (ILPC) will point to the byte AFTER the IL
    443  02d7							;    opcode being executed.
    444  02d7							;
    445  02d7							;    (CURPTR),CUROFF will point to the start of the
    446  02d7							;    next word in the input buffer.  Ie, the next word
    447  02d7							;    in the user program.
    448  02d7							;
    449  02d7		       0a		      asl
    450  02d8		       c9 e6		      cmp	#ILTBLend-ILTBL+2
    451  02da		       90 33		      bcc	ILgood
    452  02dc							;
    453  02dc							; This handles an illegal IL opcode.  This is serious
    454  02dc							; and there's no way to recover.
    455  02dc							;
    456  02dc		       20 f8 20    ILbad      jsr	puts
      0  02df					      db	CR,LF
      1  02df		       0d 0a		      .byte.b	CR,LF
      0  02e1					      db	"Illegal IL "
      1  02e1		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02ec					      db	0
      1  02ec		       00		      .byte.b	0
    460  02ed							;
    461  02ed							; Well this is awkward, we need to back up the IL
    462  02ed							; by one since it no longer points to the current
    463  02ed							; opcode.
    464  02ed							;
    465  02ed		       20 4d 29 	      jsr	decIL
    466  02f0							;
    467  02f0		       a0 00		      ldy	#0
    468  02f2		       b1 43		      lda	(ILPC),y
    469  02f4		       20 db 20 	      jsr	OUTHEX
    470  02f7		       20 f8 20 	      jsr	puts
      0  02fa					      db	" at ",0
      1  02fa		       20 61 74 20*	      .byte.b	" at ",0
    472  02ff		       a5 44		      lda	ILPC+1
    473  0301		       20 db 20 	      jsr	OUTHEX
    474  0304		       a5 43		      lda	ILPC
    475  0306		       20 db 20 	      jsr	OUTHEX
    476  0309		       20 84 2c 	      jsr	CRLF
    477  030c		       4c 03 f0 	      jmp	MONITOR
    478  030f							;
    479  030f							; Just jump to the address (ILPC),y.  Have to do
    480  030f							; some goofy stuff.
    481  030f							;
    482  030f		       a8	   ILgood     tay		;move index into Y
    483  0310		       b9 1d 03 	      lda	ILTBL,y
    484  0313		       85 59		      sta	dpl
    485  0315		       b9 1e 03 	      lda	ILTBL+1,y
    486  0318		       85 5a		      sta	dpl+1
    487  031a		       6c 59 00 	      jmp	(dpl)	;go to handler
    488  031d							;
    489  031d							;=====================================================
    490  031d							; This is the IL jump table.  The IL opcode is
    491  031d							; mulitplied by two, then looked-up in this table.
    492  031d							; There is absolutely nothing special about the order
    493  031d							; of entries here... they all decode at exactly the
    494  031d							; same speed.	However the entry number must match the
    495  031d							; values in IL.inc.
    496  031d							;
    497  031d				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  031d					      include	"ilvectortable.asm"
      1  031d					      seg	Code
      2  031d
      0  031d					      dw	iXINIT	;0
      1  031d		       39 04		      .word.w	iXINIT
      0  031f					      dw	iDONE	;1
      1  031f		       56 04		      .word.w	iDONE
      0  0321					      dw	iPRS	;2
      1  0321		       6d 04		      .word.w	iPRS
      0  0323					      dw	iPRN	;3
      1  0323		       75 04		      .word.w	iPRN
      0  0325					      dw	iSPC	;4
      1  0325		       7e 04		      .word.w	iSPC
      0  0327					      dw	iNLINE	;5
      1  0327		       20 09		      .word.w	iNLINE
      0  0329					      dw	iNXT	;6
      1  0329		       86 04		      .word.w	iNXT
      0  032b					      dw	iXFER	;7
      1  032b		       c8 04		      .word.w	iXFER
      0  032d					      dw	iSAV	;8
      1  032d		       e6 04		      .word.w	iSAV
      0  032f					      dw	iRSTR	;9
      1  032f		       b4 24		      .word.w	iRSTR
      0  0331					      dw	iCMPR	;10
      1  0331		       2c 05		      .word.w	iCMPR
      0  0333					      dw	iINNUM	;11
      1  0333		       ab 05		      .word.w	iINNUM
      0  0335					      dw	iFIN	;12
      1  0335		       e3 05		      .word.w	iFIN
      0  0337					      dw	iERR	;13
      1  0337		       f7 05		      .word.w	iERR
      0  0339					      dw	iADD	;14
      1  0339		       79 06		      .word.w	iADD
      0  033b					      dw	iSUB	;15
      1  033b		       8f 06		      .word.w	iSUB
      0  033d					      dw	iNEG	;16
      1  033d		       a5 06		      .word.w	iNEG
      0  033f					      dw	iMUL	;17
      1  033f		       bd 06		      .word.w	iMUL
      0  0341					      dw	iDIV	;18
      1  0341		       fd 06		      .word.w	iDIV
      0  0343					      dw	iSTORE	;19
      1  0343		       53 07		      .word.w	iSTORE
      0  0345					      dw	iIND	;20
      1  0345		       71 07		      .word.w	iIND
      0  0347					      dw	iLST	;21
      1  0347		       16 08		      .word.w	iLST
      0  0349					      dw	iINIT	;22
      1  0349		       01 04		      .word.w	iINIT
      0  034b					      dw	iGETLINE	;23
      1  034b		       4c 08		      .word.w	iGETLINE
      0  034d					      dw	iINSRT	;24
      1  034d		       69 08		      .word.w	iINSRT
      0  034f					      dw	iRTN	;25
      1  034f		       1a 09		      .word.w	iRTN
      0  0351					      dw	MONITOR	;26
      1  0351		       03 f0		      .word.w	MONITOR
      0  0353					      dw	iLIT	;27
      1  0353		       44 09		      .word.w	iLIT
      0  0355					      dw	iCALL	;28
      1  0355		       26 09		      .word.w	iCALL
      0  0357					      dw	iJMP	;29
      1  0357		       32 09		      .word.w	iJMP
      0  0359					      dw	iVINIT	;30
      1  0359		       69 09		      .word.w	iVINIT
      0  035b					      dw	iERRGOTO	;31
      1  035b		       72 09		      .word.w	iERRGOTO
      0  035d					      dw	iTST	;32
      1  035d		       7e 09		      .word.w	iTST
      0  035f					      dw	iTSTV	;33
      1  035f		       a3 0a		      .word.w	iTSTV
      0  0361					      dw	iTSTL	;34
      1  0361		       49 0b		      .word.w	iTSTL
      0  0363					      dw	iTSTN	;35
      1  0363		       64 0b		      .word.w	iTSTN
      0  0365					      dw	iFREE	;36
      1  0365		       1d 0c		      .word.w	iFREE
      0  0367					      dw	iRANDOM	;37
      1  0367		       23 0c		      .word.w	iRANDOM
      0  0369					      dw	iABS	;38
      1  0369		       f4 0c		      .word.w	iABS
     42  036b							;
     43  036b							; Disk functions.  There must be pointers
     44  036b							; to functions even if no disk is supported.
     45  036b							; Makes things easier in IL.inc.
     46  036b							;
     47  036b					      if	DISK_ACCESS
      0  036b					      dw	iOPENREAD	;39
      1  036b		       18 2f		      .word.w	iOPENREAD
      0  036d					      dw	iOPENWRITE	;40
      1  036d		       79 2f		      .word.w	iOPENWRITE
      0  036f					      dw	iDCLOSE	;41
      1  036f		       0a 30		      .word.w	iDCLOSE
      0  0371					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0371		       98 2f		      .word.w	iDGETLINE
      0  0373					      dw	iDLIST	;43 Did you remember your towel?
      1  0373		       04 30		      .word.w	iDLIST
      0  0375					      dw	iDDIR	;44
      1  0375		       df 2f		      .word.w	iDDIR
      0  0377					      dw	iRMFILE	;45
      1  0377		       67 2f		      .word.w	iRMFILE
     55  0379				  -	      else
     56  0379				  -	      dw	NextIL	;39
     57  0379				  -	      dw	NextIL	;40
     58  0379				  -	      dw	NextIL	;41
     59  0379				  -	      dw	NextIL	;42
     60  0379				  -	      dw	NextIL	;43
     61  0379				  -	      dw	NextIL	;44
     62  0379				  -	      dw	NextIL	;45
     63  0379					      endif
     64  0379							;
      0  0379					      dw	iCLEARSCREEN	;46
      1  0379		       e5 2d		      .word.w	iCLEARSCREEN
      0  037b					      dw	iPOKEMEMORY	;47
      1  037b		       81 0c		      .word.w	iPOKEMEMORY
      0  037d					      dw	iPEEKMEMORY	;48
      1  037d		       96 0c		      .word.w	iPEEKMEMORY
      0  037f					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  037f		       c5 09		      .word.w	iTSTLET
      0  0381					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0381		       4a 0a		      .word.w	iTSTDONE
      0  0383					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0383		       c3 0c		      .word.w	iGETCHAR
      0  0385					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0385		       d7 0c		      .word.w	iPUTCHAR
      0  0387					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0387		       ac 0c		      .word.w	iCallFunc
      0  0389					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0389		       79 05		      .word.w	iBranch
      0  038b					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  038b		       a8 09		      .word.w	iTSTStr
      0  038d					      dw	iSetIrq	;56	   sets the irq handler
      1  038d		       9b 0d		      .word.w	iSetIrq
      0  038f					      dw	iTstIrq	;57	   test if irq is pending
      1  038f		       db 0b		      .word.w	iTstIrq
      0  0391					      dw	iRET	;58	   return from interupt
      1  0391		       1a 05		      .word.w	iRET
      0  0393					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0393		       c4 05		      .word.w	iINSTR
      0  0395					      dw	iMOD	;60	   returns remainder of division
      1  0395		       06 07		      .word.w	iMOD
      0  0397					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  0397		       26 26		      .word.w	iTaskSet
      0  0399					      dw	iETask	;62	   Terminates a task
      1  0399		       63 27		      .word.w	iETask
      0  039b					      dw	iNTask	;63	   goto next task
      1  039b		       16 27		      .word.w	iNTask
      0  039d					      dw	iArray	;64	   Allow Variable to have a subscript
      1  039d		       90 07		      .word.w	iArray
      0  039f					      dw	iTaskKill	;65	   kill a running task
      1  039f		       0e 27		      .word.w	iTaskKill
      0  03a1					      dw	iTaskStat	;66	   return the state of a task PID
      1  03a1		       e2 26		      .word.w	iTaskStat
      0  03a3					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03a3		       e2 0c		      .word.w	iHexOut
      0  03a5					      dw	iReadComplete	;68	   Called after a background read completes
      1  03a5		       95 05		      .word.w	iReadComplete
      0  03a7					      dw	iReadStart	;69	   Called to start a background read request
      1  03a7		       8b 05		      .word.w	iReadStart
      0  03a9					      dw	iStartIO	;70	   Lock task until io complete
      1  03a9		       46 27		      .word.w	iStartIO
      0  03ab					      dw	iEndIO	;71	   release task lock for io
      1  03ab		       4c 27		      .word.w	iEndIO
      0  03ad					      dw	iLogNot	;72	   Logical not
      1  03ad		       4d 0d		      .word.w	iLogNot
      0  03af					      dw	iLogOr	;73	   Logical Or
      1  03af		       23 0d		      .word.w	iLogOr
      0  03b1					      dw	iLogAnd	;74	   Logical And
      1  03b1		       0e 0d		      .word.w	iLogAnd
      0  03b3					      dw	iLogXor	;75	   Logical Xor
      1  03b3		       38 0d		      .word.w	iLogXor
      0  03b5					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03b5		       21 27		      .word.w	iWTASK
      0  03b7					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03b7		       57 27		      .word.w	iTASKPID
      0  03b9					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03b9		       d9 0d		      .word.w	iTRACEPROG
      0  03bb					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03bb		       91 2c		      .word.w	idbgBasic
      0  03bd					      dw	iIPCS	;80	   Sending a msg to a task
      1  03bd		       19 28		      .word.w	iIPCS
      0  03bf					      dw	iIPCR	;81	   Recieve a message from a task
      1  03bf		       30 28		      .word.w	iIPCR
      0  03c1					      dw	iIPCC	;82	   Check if any message available for task
      1  03c1		       44 28		      .word.w	iIPCC
      0  03c3					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03c3		       51 28		      .word.w	iIPCIO
      0  03c5					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03c5		       1a 24		      .word.w	iPushMathStack
      0  03c7					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03c7		       4a 24		      .word.w	iPopMathStack
      0  03c9					      dw	iSaveMathStack	;86	   Save all math info
      1  03c9		       67 24		      .word.w	iSaveMathStack
      0  03cb					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03cb		       86 24		      .word.w	iRestoreMathStack
      0  03cd					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03cd		       37 24		      .word.w	iIncParmCount
      0  03cf					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03cf		       83 27		      .word.w	iTaskGetMathStack
      0  03d1					      dw	iTaskEnable	;90	   enable a suspended task
      1  03d1		       b0 26		      .word.w	iTaskEnable
      0  03d3					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03d3		       ca 26		      .word.w	iTaskSuspend
      0  03d5					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03d5		       9d 27		      .word.w	iTaskPutMathPtr
      0  03d7					      dw	iTSTVT	;93	   test for another tasks variable
      1  03d7		       9a 0a		      .word.w	iTSTVT
      0  03d9					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03d9		       3c 09		      .word.w	iSetR2
      0  03db					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03db		       f8 04		      .word.w	iStk2Tmp
      0  03dd					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03dd		       09 05		      .word.w	iTmp2Stk
      0  03df					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03df		       e6 09		      .word.w	iTSTBYTE
      0  03e1					      dw	iINCVAR	;98	   Increment variable
      1  03e1		       6c 0a		      .word.w	iINCVAR
      0  03e3					      dw	iDECVAR	;99	   Decrement variable
      1  03e3		       84 0a		      .word.w	iDECVAR
      0  03e5					      dw	iSLICE	;100	   set the time slice for tasks
      1  03e5		       ac 27		      .word.w	iSLICE
      0  03e7					      dw	iTSTB	;101	   Test if byte equals
      1  03e7		       05 0a		      .word.w	iTSTB
      0  03e9					      dw	iTSTW	;102	   Test If word equals
      1  03e9		       20 0a		      .word.w	iTSTW
      0  03eb					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03eb		       98 1e		      .word.w	iOnGoto
      0  03ed					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03ed		       c9 1e		      .word.w	iTSTRELOP
      0  03ef					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03ef		       ac 04		      .word.w	iRepeatLine
      0  03f1					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch if is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03f1		       f0 1e		      .word.w	iTSTBRANCH
      0  03f3					      dw	iFastXfer	;107	   move top of stack to curptr
      1  03f3		       b3 04		      .word.w	iFastXfer
      0  03f5					      dw	iSetTerminal	;108	   Set the Io Terminal to be used by print and input statements
      1  03f5		       5b 2e		      .word.w	iSetTerminal
      0  03f7					      dw	iINDB	;109	   fetch a single byte from memory indirect
      1  03f7		       7e 07		      .word.w	iINDB
      0  03f9					      dw	iSetBlock	;110	   Set a block or words or byte to a value 16 bit length
      1  03f9		       41 23		      .word.w	iSetBlock
      0  03fb					      dw	iCopyBlock	;111	   Copy a block or memory from one location to another 16 bit length
      1  03fb		       97 23		      .word.w	iCopyBlock
      0  03fd					      dw	iCmpBlock	;112	   Compare to parts of memory
      1  03fd		       cb 23		      .word.w	iCmpBlock
      0  03ff					      dw	iShift	;113	   Shift left 0 or right 1
      1  03ff		       71 0d		      .word.w	iShift
    133  0401
------- FILE mytb.asm
    499  0401		       04 01	   ILTBLend   equ	*
    500  0401
    501  0401							;
    502  0401							;=====================================================
    503  0401							;=====================================================
    504  0401							;=====================================================
    505  0401							; This marks the start of the handlers for IL opcodes.
    506  0401							;=====================================================
    507  0401							;=====================================================
    508  0401							;=====================================================
    509  0401							;
    510  0401							;
    511  0401		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    512  0403		       85 47		      sta	ILSTACKPTR
    513  0405		       85 4a		      sta	MATHSTACKPTR
    514  0407		       85 4d		      sta	GOSUBSTACKPTR
    515  0409		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    516  040b		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    517  040d							;
    518  040d		       ad 18 42 	      lda	ProgramStart	; user prog
    519  0410		       85 4f		      sta	CURPTR
    520  0412		       8d a5 35 	      sta	taskTable+1
    521  0415		       8d 1a 42 	      sta	ProgramEnd
    522  0418		       ad 19 42 	      lda	ProgramStart+1
    523  041b		       85 50		      sta	CURPTR+1
    524  041d		       8d a6 35 	      sta	taskTable+2
    525  0420		       8d 1b 42 	      sta	ProgramEnd+1
    526  0423		       a9 80		      lda	#TASKACTIVE
    527  0425		       8d a4 35 	      sta	taskTable	;Mark the first slot as active
    528  0428		       a9 01		      lda	#1
    529  042a		       8d a2 36 	      sta	taskCounter	;there is always one task / Main task
    530  042d		       ad a0 36 	      lda	taskResetValue
    531  0430		       8d 9e 36 	      sta	taskCurrentCycles	; set up the task switch counts
    532  0433		       ad a1 36 	      lda	taskResetValue+1
    533  0436		       8d 9f 36 	      sta	taskCurrentCycles+1
    534  0439							;
    535  0439							; fall into XINIT...
    536  0439							;
    537  0439							;=====================================================
    538  0439							; This initializes for the start of the next line of
    539  0439							; BASIC text.
    540  0439							;
    541  0439		       78	   iXINIT     sei		; ensure interupts are off
    542  043a		       20 a9 25 	      jsr	taskReset	; Clear the task table
    543  043d		       a9 00		      lda	#0	; Clear the irq flags
    544  043f		       8d 3b 19 	      sta	IRQPending	; reset the irq pending
    545  0442		       8d 3a 19 	      sta	IRQStatus	; Make sure irqs are off
    546  0445
    547  0445		       4c b1 02    goodExit   jmp	NextIL
    548  0448							;
    549  0448							;=====================================================
    550  0448							; This check if the escape key has been entered
    551  0448							; then changes out of run mode. z Set if esc found
    552  0448				   BreakSet
    553  0448		       20 0f f0 	      jsr	ISCHAR
    554  044b		       f0 06		      beq	BreakNo
    555  044d		       20 cb 19 	      jsr	VGETCH
    556  0450		       c9 1b		      cmp	#$1B
    557  0452		       60		      rts
    558  0453				   BreakNo
    559  0453		       a9 01		      lda	#1
    560  0455		       60		      rts
    561  0456
    562  0456							;
    563  0456
    564  0456							;=====================================================
    565  0456							; Verify there is nothing else on this input line.
    566  0456							; If there is, generate an error.
    567  0456							;
    568  0456		       a4 51	   iDONE      ldy	CUROFF
    569  0458		       b1 4f		      lda	(CURPTR),y
    570  045a		       f0 0e		      beq	doneadv
    571  045c		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    572  045e		       d0 03		      bne	idoneErr
    573  0460							;		  sty	  CUROFF
    574  0460		       4c b1 02 	      jmp	NextIL	; continue on this line
    575  0463
    576  0463				   idoneErr
    577  0463		       a2 04		      ldx	#ERR_EXTRA_STUFF
    578  0465		       a9 00		      lda	#0
    579  0467		       4c 5e 06 	      jmp	iErr2
    580  046a							;
    581  046a							; Advance to the next line
    582  046a							;
    583  046a				   doneadv
    584  046a		       4c b1 02 	      jmp	NextIL
    585  046d							;
    586  046d							;=====================================================
    587  046d							; Print the string until a closing quote
    588  046d							;
    589  046d				   iPRS
    590  046d		       20 1b 21 	      jsr	PrtQuoted
    591  0470		       84 51		      sty	CUROFF
    592  0472		       4c b1 02 	      jmp	NextIL
    593  0475							;
    594  0475							;=====================================================
    595  0475							; Pop the top off the stack and print it as a signed
    596  0475							; decimal number.
    597  0475							;
    598  0475				   iPRN
    599  0475		       20 cb 2b 	      jsr	popR0
    600  0478		       20 27 20 	      jsr	PrintDecimal
    601  047b		       4c b1 02 	      jmp	NextIL
    602  047e							;
    603  047e							;=====================================================
    604  047e							; Space to next zone.	Currently the code does not
    605  047e							; keep track of which column the output is on, so
    606  047e							; just print a tab.
    607  047e							;
    608  047e				   iSPC
    609  047e		       a9 09		      lda	#TAB
    610  0480		       20 c8 19 	      jsr	VOUTCH
    611  0483		       4c b1 02 	      jmp	NextIL
    612  0486							;
    613  0486							;=====================================================
    614  0486							; If in immediate mode, jump to the address following
    615  0486							; the NXT instruction.  Else move to the next line of
    616  0486							; user code and continue.
    617  0486							;
    618  0486		       a5 5b	   iNXT       lda	RunMode
    619  0488		       d0 03		      bne	iNxtRun	;in run mode
    620  048a							;
    621  048a							; Get address and jump to it.
    622  048a							;
    623  048a		       4c 32 09 	      jmp	iJMP
    624  048d							;
    625  048d				   iNxtRun
    626  048d		       a4 51		      ldy	CUROFF
    627  048f		       b1 4f		      lda	(CURPTR),y
    628  0491		       c9 e6		      cmp	#oColon
    629  0493		       d0 06		      bne	iNxtRunGo
    630  0495		       c8		      iny
    631  0496		       84 51		      sty	CUROFF
    632  0498		       4c a6 04 	      jmp	iNxtRun2
    633  049b
    634  049b				   iNxtRunGo
    635  049b		       20 ca 29 	      jsr	FindNextLine
    636  049e		       20 de 29 	      jsr	AtEnd
    637  04a1		       d0 03		      bne	iNxtRun2	;not at end
    638  04a3							;
    639  04a3							; At the end of the program.  Pretend an END statement
    640  04a3							; was found.
    641  04a3							;
    642  04a3		       4c e3 05    iFINv      jmp	iFIN
    643  04a6							;
    644  04a6		       20 3c 29    iNxtRun2   jsr	getILWord	;ignore next word
    645  04a9		       4c b1 02 	      jmp	NextIL
    646  04ac							;=====================================================
    647  04ac							;Repeat the same line against
    648  04ac		       a0 03	   iRepeatLine ldy	#3
    649  04ae		       84 51		      sty	CUROFF
    650  04b0		       4c b1 02 	      jmp	NextIL
    651  04b3							;
    652  04b3							;=====================================================
    653  04b3							; XFER takes the number on top of the stack and looks
    654  04b3							; for that line in the program, or the next line
    655  04b3							; higher.  Ie, if it's 1 but there is no line 1, then
    656  04b3							; find the next one after that.
    657  04b3							;
    658  04b3				   iFastXfer
    659  04b3		       20 e3 2b 	      jsr	popR1	; get type of transfer
    660  04b6		       a5 54		      lda	R1
    661  04b8		       f0 0e		      beq	iXFER
    662  04ba
    663  04ba		       20 cb 2b 	      jsr	popR0	; get where to transfer
    664  04bd		       a5 52		      lda	R0
    665  04bf		       85 4f		      sta	CURPTR
    666  04c1		       a5 53		      lda	R0+1
    667  04c3		       85 50		      sta	CURPTR+1
    668  04c5		       4c ce 04 	      jmp	iXFER2
    669  04c8
    670  04c8				   iXFER
    671  04c8		       20 cb 2b 	      jsr	popR0
    672  04cb		       20 85 29 	      jsr	findLine
    673  04ce
    674  04ce				   iXFER2
    675  04ce		       20 de 29 	      jsr	AtEnd	;at end of user program?
    676  04d1		       f0 d0		      beq	iFINv
    677  04d3
    678  04d3		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    679  04d5		       84 51		      sty	CUROFF
    680  04d7
    681  04d7							;		  lda	  #$ff
    682  04d7							;		  sta	  RunMode
    683  04d7							;
    684  04d7							; Transfer IL to STMT.  I don't like having this
    685  04d7							; hard-coded; fix it.
    686  04d7							;
    687  04d7							;		  lda	  #STMT&$ff
    688  04d7							;		  sta	  ILPC
    689  04d7							;		  lda	  #STMT>>8
    690  04d7							;		  sta	  ILPC+1
    691  04d7							;		  jmp	  NextIL
    692  04d7							;
    693  04d7							; Run
    694  04d7							;
    695  04d7				   iXferok
    696  04d7		       a9 ff		      lda	#$ff
    697  04d9		       85 5b		      sta	RunMode	;we're running
    698  04db							;
    699  04db							; Need a more elegant way to do this
    700  04db							;
    701  04db		       a9 05		      lda	#STMT&$ff
    702  04dd		       85 43		      sta	ILPC
    703  04df		       a9 31		      lda	#STMT>>8
    704  04e1		       85 44		      sta	ILPC+1
    705  04e3		       4c b1 02 	      jmp	NextIL
    706  04e6							;
    707  04e6							;=====================================================
    708  04e6							; Save the pointer to the next line to the call stack.
    709  04e6							;
    710  04e6		       20 40 29    iSAV       jsr	getILByte	; load type of gosub
    711  04e9		       20 53 2b 	      jsr	pushLN	; Type passed in A
    712  04ec		       b0 03		      bcs	iSAVErr
    713  04ee		       4c b1 02 	      jmp	NextIL
    714  04f1
    715  04f1		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    716  04f3		       a9 00	   iSAVErr2   lda	#0
    717  04f5		       4c 5e 06 	      jmp	iErr2
    718  04f8							;====================================================
    719  04f8							; Move stack top to and from temp area
    720  04f8				   iStk2Tmp
    721  04f8		       20 cb 2b 	      jsr	popR0
    722  04fb		       a5 52		      lda	R0
    723  04fd		       a0 48		      ldy	#TASKEXITCODE	; can also be used as temp
    724  04ff		       91 41		      sta	(VARIABLES),y
    725  0501		       c8		      iny
    726  0502		       a5 53		      lda	R0+1
    727  0504		       91 41		      sta	(VARIABLES),y
    728  0506		       4c b1 02 	      jmp	NextIL
    729  0509
    730  0509		       a0 48	   iTmp2Stk   ldy	#TASKEXITCODE
    731  050b		       b1 41		      lda	(VARIABLES),y
    732  050d		       85 52		      sta	R0
    733  050f		       c8		      iny
    734  0510		       b1 41		      lda	(VARIABLES),y
    735  0512		       85 53		      sta	R0+1
    736  0514		       20 39 2b 	      jsr	pushR0
    737  0517		       4c b1 02 	      jmp	NextIL
    738  051a							;
    739  051a							;=====================================================
    740  051a							; Pop the next line from the call stack. IRQ return
    741  051a							;
    742  051a		       20 7c 2b    iRET       jsr	popLN
    743  051d		       b0 d2		      bcs	iSAVErr
    744  051f		       a0 03		      ldy	#3
    745  0521		       84 51		      sty	CUROFF
    746  0523		       a9 00		      lda	#0
    747  0525		       8d 3b 19 	      sta	IRQPending
    748  0528		       58		      cli
    749  0529		       4c b1 02 	      jmp	NextIL
    750  052c							;
    751  052c							;=====================================================
    752  052c							; Compare items on stack.  Okay, so on input there are
    753  052c							; three things on the stack
    754  052c							;
    755  052c							;    EXPR2 <- Top of stack
    756  052c							;    OP    <- relational operator, next on stack
    757  052c							;    EXPR1 <- last item on stack
    758  052c							;
    759  052c							; Comparison is: EXPR1 <operator> EXPR2
    760  052c							;
    761  052c							; Operator is one of...
    762  052c							;
    763  052c							;    2 is =
    764  052c							;    1 is <
    765  052c							;    3 is <=
    766  052c							;    5 is <>
    767  052c							;    4 is >
    768  052c							;    6 is >=
    769  052c							;
    770  052c							; Those are bit-mapped:
    771  052c							;
    772  052c							;    xxxxxGEL
    773  052c							;
    774  052c							;    G = Greater than
    775  052c							;    E = Equal
    776  052c							;    L = Less than
    777  052c							;
    778  052c							; If the comparison is false, do a NXT, ie, move to the
    779  052c							; next line and continue.  If true, continue executing
    780  052c							; on this line.
    781  052c							;
    782  052c		       00 01	   REL_LT     equ	%001
    783  052c		       00 02	   REL_EQUAL  equ	%010
    784  052c		       00 04	   REL_GT     equ	%100
    785  052c							;
    786  052c		       20 e3 2b    iCMPR      jsr	popR1
    787  052f		       20 fa 2b 	      jsr	popMQ	;operator in MQ
    788  0532		       20 cb 2b 	      jsr	popR0
    789  0535		       20 3e 05 	      jsr	iCMPRsub
    790  0538		       20 39 2b 	      jsr	pushR0
    791  053b		       4c b1 02 	      jmp	NextIL
    792  053e							;
    793  053e							; See if they are equal or not
    794  053e							;
    795  053e				   iCMPRsub		; Called by internal functions
    796  053e
    797  053e		       a5 52		      lda	R0
    798  0540		       c5 54		      cmp	R1
    799  0542		       d0 0a		      bne	iCMPRnoteq	;try not equal
    800  0544		       a5 53		      lda	R0+1
    801  0546		       c5 55		      cmp	R1+1
    802  0548		       d0 04		      bne	iCMPRnoteq
    803  054a							;
    804  054a							; Equal, set the flag in MQ+1
    805  054a							;
    806  054a		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    807  054c		       d0 14		      bne	iCMPcom	;Exit it is equal
    808  054e							;
    809  054e							; See if EXPR1 (R0) < EXPR2 (R1)
    810  054e							; See www.6502.org/tutorials/compare_beyond.html
    811  054e							;
    812  054e				   iCMPRnoteq
    813  054e		       a5 52		      lda	R0
    814  0550		       c5 54		      cmp	R1	; Sets the carry flag
    815  0552		       a5 53		      lda	R0+1
    816  0554		       e5 55		      sbc	R1+1
    817  0556
    818  0556		       50 02		      bvc	iCMPR_2	; branch if N eor V
    819  0558		       49 80		      eor	#$80
    820  055a
    821  055a		       30 04	   iCMPR_2    bmi	iCMPlt
    822  055c		       a9 04		      lda	#REL_GT
    823  055e		       d0 02		      bne	iCMPcom
    824  0560
    825  0560		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    826  0562
    827  0562				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    828  0562							;
    829  0562							; Now compare the end result with what the caller
    830  0562							; was looking for.
    831  0562							;
    832  0562		       25 56		      and	MQ
    833  0564		       f0 0c		      beq	iCMPno	; no match
    834  0566		       a9 ff		      lda	#$FF	; true is $ffff
    835  0568		       85 52		      sta	R0
    836  056a		       85 53		      sta	R0+1
    837  056c		       d0 0a		      bne	iCMPDone
    838  056e							;
    839  056e							; R0 > R1
    840  056e							;
    841  056e		       a9 04	   iCMPgt     lda	#REL_GT
    842  0570		       d0 f0		      bne	iCMPcom
    843  0572				   iCMPno
    844  0572		       a9 00		      lda	#0
    845  0574		       85 52		      sta	R0
    846  0576		       85 53		      sta	R0+1
    847  0578
    848  0578				   iCMPDone
    849  0578		       60		      rts
    850  0579
    851  0579							;
    852  0579							; if Not a match, so jump to the next line of code.
    853  0579							; Branches based upon value on top of the stack
    854  0579				   iBranch
    855  0579		       20 cb 2b 	      jsr	popR0
    856  057c		       a5 52		      lda	R0
    857  057e		       05 53		      ora	R0+1
    858  0580		       f0 03		      beq	iBranchFalse	; not true
    859  0582		       4c b1 02 	      jmp	NextIL	; It is true if any value not zero
    860  0585							;
    861  0585				   iBranchFalse
    862  0585		       20 ca 29 	      jsr	FindNextLine
    863  0588		       4c ce 04 	      jmp	iXFER2
    864  058b							;
    865  058b							;=====================================================
    866  058b							; Start a read of data in background
    867  058b				   iReadStart
    868  058b		       a9 3f		      lda	#'?	; Prompt with question mark
    869  058d		       a6 01		      ldx	1	; Indicate to start read in background
    870  058f		       20 56 2a 	      jsr	GetLine	; Call the getline to start read
    871  0592		       4c b1 02 	      jmp	NextIL	; next instruction
    872  0595							;
    873  0595							;=====================================================
    874  0595							; Complete the read and return the curptr, curoff pointing to data
    875  0595				   iReadComplete
    876  0595		       a9 01		      lda	#GOSUB_RTN
    877  0597		       20 53 2b 	      jsr	pushLN
    878  059a		       90 03		      bcc	iReadOk
    879  059c		       4c 16 0c    iReadErr   jmp	ErrStkOver	; Check if there was an error
    880  059f				   iReadOk
    881  059f		       20 76 2a 	      jsr	ReadComplete
    882  05a2		       4c b1 02 	      jmp	NextIL
    883  05a5		       20 7c 2b 	      jsr	popLN
    884  05a8		       4c b1 02 	      jmp	NextIL
    885  05ab							;=====================================================
    886  05ab							; Get a line of text from the user, convert to a
    887  05ab							; number, leave on top of stack.
    888  05ab							;
    889  05ab				   iINNUM
    890  05ab		       a9 01		      lda	#GOSUB_RTN
    891  05ad		       20 53 2b 	      jsr	pushLN
    892  05b0		       b0 ea		      bcs	iReadErr	; Stack over flow error
    893  05b2							;
    894  05b2		       a9 3f		      lda	#'?
    895  05b4		       a2 00		      ldx	#0	;Wait for complete
    896  05b6		       20 56 2a 	      jsr	GetLine
    897  05b9		       20 eb 29 	      jsr	getDecimal
    898  05bc		       20 39 2b 	      jsr	pushR0	;put onto stack
    899  05bf		       b0 db		      bcs	iReadErr	;StackOverflow error
    900  05c1							;
    901  05c1		       4c dd 05 	      jmp	ExitIn
    902  05c4							;
    903  05c4							;=====================================================
    904  05c4							; Get a line of text from the user, convert to a
    905  05c4							; character value , leave on top of stack. up to 2 characters
    906  05c4							;
    907  05c4				   iINSTR
    908  05c4		       a9 01		      lda	#GOSUB_RTN
    909  05c6		       20 53 2b 	      jsr	pushLN
    910  05c9		       b0 d1		      bcs	iReadErr	; Stack overflow error
    911  05cb		       a9 3f		      lda	#'?
    912  05cd		       a2 00		      ldx	#0	;wait for read complete
    913  05cf		       20 56 2a 	      jsr	GetLine
    914  05d2		       b1 4f		      lda	(CURPTR),y
    915  05d4		       85 52		      sta	R0
    916  05d6		       a9 00		      lda	#0
    917  05d8		       85 53		      sta	R0+1
    918  05da		       20 39 2b 	      jsr	pushR0	;put onto stack
    919  05dd				   ExitIn
    920  05dd		       20 7c 2b 	      jsr	popLN
    921  05e0		       4c b1 02 	      jmp	NextIL
    922  05e3							;
    923  05e3							;
    924  05e3							;=====================================================
    925  05e3							; Stop the currently running program.	Actually very
    926  05e3							; simple to do... clear the RunMode flag, then set the
    927  05e3							; ILPC to the standard handler and continue running.
    928  05e3							;
    929  05e3		       a9 00	   iFIN       lda	#0
    930  05e5		       85 5b		      sta	RunMode
    931  05e7		       20 a9 25 	      jsr	taskReset
    932  05ea							;
    933  05ea		       ad 09 42 	      lda	errGoto
    934  05ed		       85 43		      sta	ILPC
    935  05ef		       ad 0a 42 	      lda	errGoto+1
    936  05f2		       85 44		      sta	ILPC+1
    937  05f4		       4c b1 02 	      jmp	NextIL
    938  05f7							;
    939  05f7							;=====================================================
    940  05f7							; Handle the ERR opcode.  Following the instruction is
    941  05f7							; a 16 bit error number.  Print an error message, and
    942  05f7							; if we're in run mode, print the line number.  Stop
    943  05f7							; program execution and return to the initial state.
    944  05f7							;
    945  05f7		       ad 16 42    iERR       lda	taskIOPending
    946  05fa		       f0 03		      beq	iErrNext
    947  05fc		       ce 16 42 	      dec	taskIOPending
    948  05ff
    949  05ff		       20 3c 29    iErrNext   jsr	getILWord	;get err code
    950  0602		       20 08 06 	      jsr	DisplayError
    951  0605		       4c 61 06 	      jmp	iErrComplete
    952  0608							;
    953  0608							; Enter here with the error code in X (LSB) and A (MSB).
    954  0608							;
    955  0608				   DisplayError
    956  0608		       86 52		      stx	R0
    957  060a		       85 53		      sta	R0+1
    958  060c							;
    959  060c		       20 f8 20 	      jsr	puts
      0  060f					      db	CR,LF,"Error ",0
      1  060f		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    961  0618		       20 27 20 	      jsr	PrintDecimal
    962  061b							;
    963  061b		       a5 5b		      lda	RunMode	;running?
    964  061d		       f0 3b		      beq	iERR3	;nope
    965  061f		       20 f8 20 	      jsr	puts
      0  0622					      db	" at line ",0
      1  0622		       20 61 74 20*	      .byte.b	" at line ",0
    967  062c		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    968  062e				   iErr2a
    969  062e		       b1 4f		      lda	(CURPTR),y
    970  0630		       85 52		      sta	R0
    971  0632		       c8		      iny
    972  0633		       b1 4f		      lda	(CURPTR),y
    973  0635		       85 53		      sta	R0+1
    974  0637		       20 27 20 	      jsr	PrintDecimal
    975  063a		       20 f8 20 	      jsr	puts
      0  063d					      db	":",0
      1  063d		       3a 00		      .byte.b	":",0
    977  063f		       a9 00		      lda	#0
    978  0641		       85 53		      sta	R0+1
    979  0643		       a5 51		      lda	CUROFF
    980  0645		       18		      clc
    981  0646		       e9 03		      sbc	#3
    982  0648		       85 52		      sta	R0
    983  064a		       20 27 20 	      jsr	PrintDecimal
    984  064d		       20 f8 20 	      jsr	puts
      0  0650					      db	":",0
      1  0650		       3a 00		      .byte.b	":",0
    986  0652		       ad a3 35 	      lda	taskPtr
    987  0655		       85 52		      sta	R0
    988  0657		       20 db 20 	      jsr	HexToOut
    989  065a							;
    990  065a				   iERR3
    991  065a		       20 84 2c 	      jsr	CRLF
    992  065d		       60		      rts
    993  065e
    994  065e				   iErr2
    995  065e		       20 08 06 	      jsr	DisplayError
    996  0661
    997  0661				   iErrComplete
    998  0661		       20 a1 25 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
    999  0664		       a9 00		      lda	#0
   1000  0666		       85 5b		      sta	RunMode	; fall through...
   1001  0668							;
   1002  0668							;=====================================================
   1003  0668							; Reset the IL to be back at the idle loop.  Does not
   1004  0668							; clear variables so the user can see what state
   1005  0668							; the program is in.
   1006  0668							;
   1007  0668		       a9 00	   ResetIL    lda	#0
   1008  066a		       85 47		      sta	ILSTACKPTR
   1009  066c		       ad 09 42 	      lda	errGoto
   1010  066f		       85 43		      sta	ILPC
   1011  0671		       ad 0a 42 	      lda	errGoto+1
   1012  0674		       85 44		      sta	ILPC+1
   1013  0676		       4c b1 02 	      jmp	NextIL
   1014  0679
   1015  0679							;
   1016  0679							;=====================================================
   1017  0679							; Pop two items off stack, add them, then place the
   1018  0679							; result back onto the stack.
   1019  0679							;
   1020  0679		       20 cb 2b    iADD       jsr	popR0
   1021  067c		       20 e3 2b 	      jsr	popR1
   1022  067f				   iADDfast
   1023  067f		       18		      clc
   1024  0680		       a5 52		      lda	R0
   1025  0682		       65 54		      adc	R1
   1026  0684		       85 52		      sta	R0
   1027  0686		       a5 53		      lda	R0+1
   1028  0688		       65 55		      adc	R1+1
   1029  068a		       85 53		      sta	R0+1
   1030  068c		       4c f7 06 	      jmp	pushR0nextIl
   1031  068f							;
   1032  068f							;=====================================================
   1033  068f							; Pop two items off the stack.  Subtract the top of
   1034  068f							; stack from the lower entry.
   1035  068f							;
   1036  068f		       20 e3 2b    iSUB       jsr	popR1
   1037  0692		       20 cb 2b 	      jsr	popR0
   1038  0695		       38		      sec
   1039  0696		       a5 52		      lda	R0
   1040  0698		       e5 54		      sbc	R1
   1041  069a		       85 52		      sta	R0
   1042  069c		       a5 53		      lda	R0+1
   1043  069e		       e5 55		      sbc	R1+1
   1044  06a0		       85 53		      sta	R0+1
   1045  06a2		       4c f7 06 	      jmp	pushR0nextIl
   1046  06a5							;
   1047  06a5							;=====================================================
   1048  06a5							; Negate the top of stack.
   1049  06a5							;
   1050  06a5		       20 cb 2b    iNEG       jsr	popR0
   1051  06a8		       a5 52		      lda	R0
   1052  06aa		       49 ff		      eor	#$ff
   1053  06ac		       85 52		      sta	R0
   1054  06ae		       a5 53		      lda	R0+1
   1055  06b0		       49 ff		      eor	#$ff
   1056  06b2		       85 53		      sta	R0+1
   1057  06b4		       e6 52		      inc	R0
   1058  06b6		       d0 02		      bne	iNEG2
   1059  06b8		       e6 53		      inc	R0+1
   1060  06ba		       4c f7 06    iNEG2      jmp	pushR0nextIl
   1061  06bd							;
   1062  06bd							;=====================================================
   1063  06bd							; Multiply top two items on the stack, put the results
   1064  06bd							; on top.  This uses the algorithm documented on page
   1065  06bd							; 115 of "Microprocessor Programming for Computer
   1066  06bd							; Hobbyists" by Neill Graham.
   1067  06bd							;
   1068  06bd		       20 c3 06    iMUL       jsr	iMultiply
   1069  06c0		       4c b1 02 	      jmp	NextIL
   1070  06c3
   1071  06c3				   iMultiply
   1072  06c3		       20 cb 2b 	      jsr	popR0	;AC
   1073  06c6		       20 e3 2b 	      jsr	popR1	;OP
   1074  06c9							;
   1075  06c9		       a5 52		      lda	R0
   1076  06cb		       85 56		      sta	MQ
   1077  06cd		       a5 53		      lda	R0+1
   1078  06cf		       85 57		      sta	MQ+1
   1079  06d1		       a9 00		      lda	#0	;clear result
   1080  06d3		       85 52		      sta	R0
   1081  06d5		       85 53		      sta	R0+1
   1082  06d7							;
   1083  06d7		       a2 10		      ldx	#16	;number of bits in value
   1084  06d9		       06 52	   multloop   asl	R0
   1085  06db		       26 53		      rol	R0+1
   1086  06dd		       06 56		      asl	MQ
   1087  06df		       26 57		      rol	MQ+1
   1088  06e1		       90 0d		      bcc	multno	;skip add if no carry
   1089  06e3							;
   1090  06e3							; Add R1 back into R0
   1091  06e3							;
   1092  06e3		       18		      clc
   1093  06e4		       a5 52		      lda	R0
   1094  06e6		       65 54		      adc	R1
   1095  06e8		       85 52		      sta	R0
   1096  06ea		       a5 53		      lda	R0+1
   1097  06ec		       65 55		      adc	R1+1
   1098  06ee		       85 53		      sta	R0+1
   1099  06f0							;
   1100  06f0		       ca	   multno     dex		;did all bits yet?
   1101  06f1		       d0 e6		      bne	multloop
   1102  06f3		       20 39 2b 	      jsr	pushR0	;OP
   1103  06f6		       60		      rts
   1104  06f7							;
   1105  06f7				   pushR0nextIl
   1106  06f7		       20 39 2b 	      jsr	pushR0	;OP
   1107  06fa		       4c b1 02 	      jmp	NextIL
   1108  06fd							;
   1109  06fd							;=====================================================
   1110  06fd							; Divide the top of stack into the next to top item.
   1111  06fd							; Leave results on stack.  Taken from:
   1112  06fd							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1113  06fd							;
   1114  06fd							; R0 = R0 / R1
   1115  06fd							; Remainder is in MQ
   1116  06fd							;
   1117  06fd		       20 17 07    iDIV       jsr	iDoDiv
   1118  0700		       20 4c 2c 	      jsr	RestoreSigns
   1119  0703		       4c f7 06 	      jmp	pushR0nextIl
   1120  0706
   1121  0706		       20 17 07    iMOD       jsr	iDoDiv
   1122  0709		       20 4c 2c 	      jsr	RestoreSigns
   1123  070c		       a5 56		      lda	MQ
   1124  070e		       85 52		      sta	R0
   1125  0710		       a5 57		      lda	MQ+1
   1126  0712		       85 53		      sta	R0+1
   1127  0714		       4c f7 06 	      jmp	pushR0nextIl
   1128  0717
   1129  0717				   iDoDiv
   1130  0717		       20 e3 2b 	      jsr	popR1
   1131  071a		       20 cb 2b 	      jsr	popR0
   1132  071d							;
   1133  071d							; Check for divide by zero
   1134  071d							;
   1135  071d
   1136  071d				   iDivNoPop
   1137  071d		       a5 54		      lda	R1
   1138  071f		       05 55		      ora	R1+1
   1139  0721		       f0 29		      beq	divby0
   1140  0723							;
   1141  0723		       20 11 2c 	      jsr	SaveSigns
   1142  0726		       a9 00		      lda	#0	;preset remainder to 0
   1143  0728		       85 56		      sta	MQ
   1144  072a		       85 57		      sta	MQ+1
   1145  072c		       a2 10		      ldx	#16	;repeat for each bit: ...
   1146  072e				   divloop
   1147  072e		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1148  0730		       26 53		      rol	R0+1
   1149  0732		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1150  0734		       26 57		      rol	MQ+1
   1151  0736		       a5 56		      lda	MQ
   1152  0738		       38		      sec
   1153  0739		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1154  073b		       a8		      tay		;lb result -> Y, for we may need it later
   1155  073c		       a5 57		      lda	MQ+1
   1156  073e		       e5 55		      sbc	R1+1
   1157  0740		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1158  0742
   1159  0742		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1160  0744		       84 56		      sty	MQ
   1161  0746		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1162  0748
   1163  0748		       ca	   skip       dex
   1164  0749		       d0 e3		      bne	divloop
   1165  074b		       60		      rts
   1166  074c							;
   1167  074c							; Indicate divide-by-zero error
   1168  074c							;
   1169  074c		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1170  074e		       a9 00		      lda	#0
   1171  0750		       4c 5e 06 	      jmp	iErr2
   1172  0753							;
   1173  0753							;=====================================================
   1174  0753							; This pops the top two items off the stack.  The top
   1175  0753							; item is a data value and the other is an ABSOLUTE address.
   1176  0753							; Save the value into that address.
   1177  0753							;
   1178  0753		       98	   iSTORE     tya
   1179  0754		       48		      pha
   1180  0755		       20 cb 2b 	      jsr	popR0	;data
   1181  0758		       20 e3 2b 	      jsr	popR1	;Storage location
   1182  075b		       a0 01		      ldy	#1
   1183  075d		       a5 58		      lda	R2
   1184  075f		       c9 a2		      cmp	#tByte
   1185  0761		       f0 04		      beq	iStoreB
   1186  0763				   iStoreW
   1187  0763		       a5 53		      lda	R0+1
   1188  0765		       91 54		      sta	(R1),y
   1189  0767				   iStoreB
   1190  0767		       a5 52		      lda	R0
   1191  0769		       88		      dey
   1192  076a		       91 54		      sta	(R1),y
   1193  076c		       68		      pla
   1194  076d		       a8		      tay
   1195  076e		       4c b1 02 	      jmp	NextIL
   1196  0771							;
   1197  0771							;=====================================================
   1198  0771							; Replaces the top of stack with the Value
   1199  0771							; of the variable  whose absolute address it represents.
   1200  0771							;
   1201  0771
   1202  0771		       98	   iIND       tya
   1203  0772		       48		      pha
   1204  0773		       20 e3 2b 	      jsr	popR1
   1205  0776		       a0 01		      ldy	#1
   1206  0778		       a5 58		      lda	R2
   1207  077a		       c9 a4		      cmp	#tInteger
   1208  077c		       f0 04		      beq	iINDW
   1209  077e				   iINDB
   1210  077e		       a9 00		      lda	#0
   1211  0780		       f0 02		      BEQ	iINDC
   1212  0782				   iINDW
   1213  0782		       b1 54		      lda	(R1),y
   1214  0784				   iINDC
   1215  0784		       85 53		      sta	R0+1
   1216  0786		       88		      dey
   1217  0787		       b1 54		      lda	(R1),y
   1218  0789		       85 52		      sta	R0
   1219  078b		       68		      pla
   1220  078c		       a8		      tay
   1221  078d		       4c f7 06 	      jmp	pushR0nextIl
   1222  0790
   1223  0790							;
   1224  0790							;=====================================================
   1225  0790							; Check which type of index to use byte or word and jmp to correct
   1226  0790							; function
   1227  0790		       98	   iArray     tya
   1228  0791		       48		      pha
   1229  0792
   1230  0792		       20 cb 2b 	      jsr	popR0	; Get the array index
   1231  0795		       20 e3 2b 	      jsr	popR1	; Get the Variable address
   1232  0798
   1233  0798		       20 40 29 	      jsr	getILByte	; Get type of number to process
   1234  079b		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Are we testing a valid parameter
   1235  079d		       f0 52		      beq	iArrayFNparm	; process a fn pramater index
   1236  079f
   1237  079f		       29 fe		      and	#$FE	; Turn off the unsigned bit
   1238  07a1		       c9 a2		      cmp	#tByte	; Test for a byte index
   1239  07a3		       f0 10		      beq	iArrayB	; yes so branch to process a byte
   1240  07a5							;=====================================================
   1241  07a5							; Process 32 bit index into memory
   1242  07a5		       c9 a6	   iArrayL    cmp	#tLong	; Are we working with 32 bit integers
   1243  07a7		       d0 06		      bne	iArrayW	; Process with sigle shift
   1244  07a9		       06 52		      asl	R0	; Do the multiply by 2
   1245  07ab		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1246  07ad		       b0 39		      bcs	iArrayError	; if the carry is set we have an error
   1247  07af							;=====================================================
   1248  07af							; Get the array index from top of stack get Current variable
   1249  07af							; address from next on stack, add the offset
   1250  07af							; push the result back onto the stack
   1251  07af				   iArrayW		; pointers, arrays etc all use 16 bit unsigned integers
   1252  07af		       06 52		      asl	R0	; Do the multiply by 2
   1253  07b1		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1254  07b3		       b0 33		      bcs	iArrayError	; if the carry is set we have an error
   1255  07b5
   1256  07b5							;=====================================================
   1257  07b5							; Get from Byte array not Integer array
   1258  07b5				   iArrayB
   1259  07b5		       18		      clc
   1260  07b6		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1261  07b8		       65 52		      adc	R0
   1262  07ba		       85 52		      sta	R0
   1263  07bc		       a5 55		      lda	R1+1
   1264  07be		       65 53		      adc	R0+1
   1265  07c0		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1266  07c2		       a5 55		      lda	R1+1
   1267  07c4		       cd 1b 42 	      cmp	ProgramEnd+1	; lets check if we are processing an @ buffer pointer to free memory
   1268  07c7		       d0 08		      bne	iArrayCheckVar
   1269  07c9				   iArrayExit
   1270  07c9		       20 39 2b 	      jsr	pushR0	; Push R0 assume it is correct
   1271  07cc
   1272  07cc		       68		      pla
   1273  07cd		       a8		      tay
   1274  07ce		       4c b1 02 	      jmp	NextIL
   1275  07d1							; Check for valis variable and valid index to use
   1276  07d1		       a5 41	   iArrayCheckVar lda	VARIABLES
   1277  07d3		       18		      clc
   1278  07d4		       69 33		      adc	#[25*2]+1	; the number of actual variable valid bytes
   1279  07d6		       85 56		      sta	MQ	; mq contains the last valid byte we can use
   1280  07d8		       a9 00		      lda	#0
   1281  07da		       65 42		      adc	VARIABLES+1	; Memory past last word R0+1 > A then invalid
   1282  07dc		       c5 53		      cmp	R0+1
   1283  07de		       90 08		      bcc	iArrayError
   1284  07e0		       a5 52		      lda	R0	; a > m invalid past last byte of variable area
   1285  07e2		       c5 56		      cmp	MQ
   1286  07e4		       f0 e3		      beq	iArrayExit	; If it is equal then it is valid
   1287  07e6		       90 e1		      bcc	iArrayExit	; if it is less it is valid
   1288  07e8
   1289  07e8							; Get here if array index is out of range
   1290  07e8		       68	   iArrayError pla
   1291  07e9		       98		      tya
   1292  07ea		       a9 00		      lda	#0
   1293  07ec		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1294  07ee		       4c 5e 06 	      jmp	iErr2
   1295  07f1							;=====================================================
   1296  07f1							; Verify function paramater index is valid
   1297  07f1		       20 03 25    iArrayFNparm jsr	GosubFindParms	; Get a pointer to the current functions parameter list info
   1298  07f4		       90 f2		      bcc	iArrayError	; There are no paramters for this call, should never be true
   1299  07f6		       88		      dey
   1300  07f7		       88		      dey		; Points to parameter count
   1301  07f8		       a5 52		      lda	R0	; get parm to be accessed
   1302  07fa		       d1 4b		      cmp	(GOSUBSTACK),y	; compare to max number allowed
   1303  07fc		       b0 ea		      bcs	iArrayError	; the parameter index should be less than the count
   1304  07fe		       c9 00		      cmp	#0
   1305  0800		       f0 c7		      beq	iArrayExit	; Skip the rest if index is zero
   1306  0802		       06 52		      asl	R0	; Do the multiply by 2
   1307  0804		       26 53		      rol	R0+1
   1308  0806
   1309  0806		       18		      clc
   1310  0807		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1311  0809		       65 52		      adc	R0
   1312  080b		       85 52		      sta	R0
   1313  080d		       a5 55		      lda	R1+1
   1314  080f		       65 53		      adc	R0+1
   1315  0811		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1316  0813		       4c c9 07 	      jmp	iArrayExit	; Get ot we are done
   1317  0816							;
   1318  0816							;=====================================================
   1319  0816							; List the current BASIC program in memory.  Uses R0,
   1320  0816							; tempIly, and dpl.
   1321  0816							;
   1322  0816		       20 cb 2d    iLST       jsr	SetOutConsole
   1323  0819		       ad 18 42    iLST2      lda	ProgramStart
   1324  081c		       85 59		      sta	dpl
   1325  081e		       ad 19 42 	      lda	ProgramStart+1
   1326  0821		       85 5a		      sta	dpl+1
   1327  0823							;
   1328  0823							; dpl/dph point to the current line.  See if we're at
   1329  0823							; the end of the program.
   1330  0823							;
   1331  0823		       a5 59	   iLSTloop   lda	dpl
   1332  0825		       cd 1a 42 	      cmp	ProgramEnd
   1333  0828		       d0 07		      bne	iLstNotEnd
   1334  082a		       a5 5a		      lda	dpl+1
   1335  082c		       cd 1b 42 	      cmp	ProgramEnd+1
   1336  082f		       f0 15		      beq	iLstdone
   1337  0831							;
   1338  0831		       20 90 21    iLstNotEnd jsr	PrintProgramLine
   1339  0834							;		  ldy	  #1		  ;Change:  Skip first byte length
   1340  0834							;		  lda	  (dpl),y	  ;line number LSB
   1341  0834							;		  sta	  R0
   1342  0834							;		  iny
   1343  0834							;		  lda	  (dpl),y		 ;line number MSB
   1344  0834							;		  sta	  R0+1
   1345  0834							;		  iny
   1346  0834							;		  sty	  tempIlY
   1347  0834							;		  jsr	  PrintDecimal
   1348  0834							;		  lda	  #SPACE
   1349  0834							;		  jsr	  VOUTCH
   1350  0834							;		  ldy	  tempIlY
   1351  0834							;iLSTl2	  lda	  (dpl),y
   1352  0834							;		  beq	  iLST3 	  ;end of this line 0 value
   1353  0834							;		  sty	  tempIlY
   1354  0834							;		  jsr	  VOUTCH
   1355  0834							;		  ldy	  tempIlY
   1356  0834							;		  iny
   1357  0834							;		  bne	  iLSTl2	  ;do next char
   1358  0834							;
   1359  0834							; End of this line.  Print CR/LF, then move to the
   1360  0834							; next line.
   1361  0834							;
   1362  0834		       a0 00	   iLST3      ldy	#0	;Move to next line
   1363  0836		       b1 59		      lda	(dpl),y	;Current line length
   1364  0838		       18		      clc		;Clear the carry flag
   1365  0839							;		  tya
   1366  0839		       65 59		      adc	dpl	;Add the offset to the pointer
   1367  083b		       85 59		      sta	dpl	;Save the new value
   1368  083d		       a5 5a		      lda	dpl+1	;Next byte
   1369  083f		       69 00		      adc	#0	;ad in the carry if any
   1370  0841		       85 5a		      sta	dpl+1	;Save it
   1371  0843							;
   1372  0843							; Have to manually do CR/LF so it uses the vectored
   1373  0843							; output function.
   1374  0843							;
   1375  0843							;		  lda	  #CR
   1376  0843							;		  jsr	  VOUTCH
   1377  0843							;		  lda	  #LF
   1378  0843							;		  jsr	  VOUTCH
   1379  0843		       4c 23 08 	      jmp	iLSTloop	;do next line
   1380  0846							;
   1381  0846		       20 cb 2d    iLstdone   jsr	SetOutConsole
   1382  0849		       4c b1 02 	      jmp	NextIL
   1383  084c							;
   1384  084c							;=====================================================
   1385  084c							; Get a line of text into LINBUF.  Terminate with a
   1386  084c							; null byte.
   1387  084c							;
   1388  084c				   iGETLINE
   1389  084c		       a9 3e		      lda	#'>	;prompt character
   1390  084e		       a6 00		      ldx	0	;Wait for read to complete
   1391  0850		       20 56 2a 	      jsr	GetLine
   1392  0853							;
   1393  0853		       a9 00		      lda	#0
   1394  0855		       85 5b		      sta	RunMode
   1395  0857				   iGetParseLine
   1396  0857							; lda	   CUROFF
   1397  0857							; pha
   1398  0857		       20 a2 1c 	      jsr	ParseInputLine
   1399  085a							; pla
   1400  085a							;  sta     CUROFF
   1401  085a		       a9 9f		      lda	#TOKENBUFFER&$FF
   1402  085c		       85 4f		      sta	CURPTR
   1403  085e		       a9 1b		      lda	#TOKENBUFFER>>8
   1404  0860		       85 50		      sta	CURPTR+1
   1405  0862		       a9 01		      lda	#1
   1406  0864		       85 51		      sta	CUROFF
   1407  0866		       4c b1 02 	      jmp	NextIL
   1408  0869							;
   1409  0869							;=====================================================
   1410  0869							; This is called when the input buffer contains a line
   1411  0869							; typed in by the user that starts with a line number.
   1412  0869							; Insert the line into the program or delete the line
   1413  0869							; if there is nothing after the line number,
   1414  0869							;
   1415  0869				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1416  0869		       ad a0 1b 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1417  086c		       85 52		      sta	R0	; place the number into R0
   1418  086e		       ad a1 1b 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1419  0871		       85 53		      STA	R0+1	; Place it into
   1420  0873							;
   1421  0873							; Now find the line OR the next higher line OR the
   1422  0873							; end of the program.
   1423  0873							;
   1424  0873		       20 85 29 	      jsr	findLine	; Look for the line number in the current program
   1425  0876							; Returns Z and curptr point to the line if found
   1426  0876							; Returns C and curptr at next higher line if not found and there is a higher line
   1427  0876							; Returns ZC clear and curptr to end of program if higher than all other lines
   1428  0876							;
   1429  0876							; If the line exists, it needs to be removed.
   1430  0876							;
   1431  0876		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1432  0878							;
   1433  0878							; Get length of line to be removed, we fall thru to here if we find a matching line
   1434  0878							;
   1435  0878							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1436  0878		       a0 00		      ldy	#0
   1437  087a		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1438  087c		       a8		      tay
   1439  087d							;If it is equal we delete the line and replace it, get length
   1440  087d							;then adjust all program line after up or down depending on len of line
   1441  087d							;If next higher then just move everythimg down by length bytes
   1442  087d							;This call will return how many bytes in the line we found
   1443  087d		       8c 15 42 	      sty	lineLength	;Save the length of the line we found
   1444  0880							;
   1445  0880							; Compute the new end of the program first.
   1446  0880							;
   1447  0880		       38		      sec		;Set the carry bit
   1448  0881		       ad 1a 42 	      lda	ProgramEnd	;Get low byte of program end
   1449  0884		       ed 15 42 	      sbc	lineLength	;Subtract the length of the current line
   1450  0887		       8d 1a 42 	      sta	ProgramEnd	;save it
   1451  088a		       ad 1b 42 	      lda	ProgramEnd+1
   1452  088d		       e9 00		      sbc	#0	;Process the carry
   1453  088f		       8d 1b 42 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1454  0892							;
   1455  0892							; Copy CURPTR into R1 for working
   1456  0892							;
   1457  0892		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1458  0894		       85 54		      sta	R1
   1459  0896		       a5 50		      lda	CURPTR+1
   1460  0898		       85 55		      sta	R1+1
   1461  089a							;
   1462  089a							; See if we're at the end.
   1463  089a							;
   1464  089a		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1465  089c		       cd 1a 42 	      cmp	ProgramEnd
   1466  089f		       d0 07		      bne	InsDelLoop
   1467  08a1		       a5 55		      lda	R1+1
   1468  08a3		       cd 1b 42 	      cmp	ProgramEnd+1
   1469  08a6		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1470  08a8							;
   1471  08a8							; Move one byte, move to next location.
   1472  08a8							;
   1473  08a8		       ac 15 42    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1474  08ab		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1475  08ad		       b1 54		      lda	(R1),y
   1476  08af		       a0 00		      ldy	#0
   1477  08b1		       91 54		      sta	(R1),y
   1478  08b3		       e6 54		      inc	R1
   1479  08b5		       d0 e3		      bne	InsDelChk
   1480  08b7		       e6 55		      inc	R1+1
   1481  08b9		       4c 9a 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1482  08bc							;
   1483  08bc							; Deletion is done.
   1484  08bc							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1485  08bc							;
   1486  08bc				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1487  08bc		       ad 9f 1b 	      lda	TOKENBUFFER	; Get the length
   1488  08bf		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1489  08c1							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1490  08c1		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1491  08c3							;
   1492  08c3							; CURPTR points to where the line will be inserted.
   1493  08c3							;
   1494  08c3							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1495  08c3		       ae 9f 1b 	      ldx	TOKENBUFFER
   1496  08c6		       8e 15 42 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1497  08c9							;
   1498  08c9		       ad 1a 42 	      lda	ProgramEnd	;Load the start address for the copy
   1499  08cc							;At this point curptr still contains the location we will insert data
   1500  08cc		       85 5c		      sta	FROM
   1501  08ce		       ad 1b 42 	      lda	ProgramEnd+1
   1502  08d1		       85 5d		      sta	FROM+1
   1503  08d3							;
   1504  08d3		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1505  08d5		       b1 5c		      lda	(FROM),y
   1506  08d7		       ac 15 42 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1507  08da		       91 5c		      sta	(FROM),y	;Save the new byte
   1508  08dc							;
   1509  08dc		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1510  08de		       c5 4f		      cmp	CURPTR
   1511  08e0		       d0 06		      bne	mvUpMore
   1512  08e2		       a5 5d		      lda	FROM+1
   1513  08e4		       c5 50		      cmp	CURPTR+1
   1514  08e6		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1515  08e8							;
   1516  08e8							; Not done yet
   1517  08e8							;
   1518  08e8		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1519  08ea		       d0 02		      bne	mvUpMore2
   1520  08ec		       c6 5d		      dec	FROM+1
   1521  08ee		       c6 5c	   mvUpMore2  dec	FROM
   1522  08f0		       4c d3 08 	      jmp	mvup1	;Loop until everything is moved
   1523  08f3							;
   1524  08f3							; All done with copy.
   1525  08f3							;
   1526  08f3				   mvUpDone
   1527  08f3		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1528  08f4		       ad 15 42 	      lda	lineLength	;Number of bytes to copy from line buff
   1529  08f7		       6d 1a 42 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1530  08fa		       8d 1a 42 	      sta	ProgramEnd
   1531  08fd		       ad 1b 42 	      lda	ProgramEnd+1
   1532  0900		       69 00		      adc	#0
   1533  0902		       8d 1b 42 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1534  0905							;
   1535  0905							;===================jlit use length before line newline
   1536  0905
   1537  0905		       a0 00		      ldy	#0	;Set offset of copy
   1538  0907							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1539  0907							;		  sta	  (CURPTR),y	  ;Store the length
   1540  0907							;		  iny
   1541  0907							;		  lda	  R0		  ;Store the line number next
   1542  0907							;		  sta	  (CURPTR),y
   1543  0907							;		  iny
   1544  0907							;		  lda	  R0+1
   1545  0907							;		  sta	  (CURPTR),y
   1546  0907							;		  iny
   1547  0907							;
   1548  0907							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1549  0907		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1550  0909				   mvUpLoop2
   1551  0909							;		  lda	  LINBUF,x	 ;get a byte
   1552  0909		       bd 9f 1b 	      lda	TOKENBUFFER,x	;get a byte
   1553  090c		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1554  090e
   1555  090e		       e8		      inx
   1556  090f		       ec 9f 1b 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1557  0912		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1558  0914		       c8		      iny
   1559  0915		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1560  0917							;
   1561  0917		       4c b1 02    mvUpFini   jmp	NextIL
   1562  091a							;
   1563  091a							;=====================================================
   1564  091a							; Pops the top value of the ILPC stack and stores it
   1565  091a							; in ILPC.  Ie, return from an IL subroutine.
   1566  091a							;
   1567  091a		       20 73 29    iRTN       jsr	popILPC
   1568  091d		       4c b1 02 	      jmp	NextIL
   1569  0920							;
   1570  0920							;=====================================================
   1571  0920							; NLINE print a newline
   1572  0920							;
   1573  0920		       20 84 2c    iNLINE     jsr	CRLF	;user supplied sub
   1574  0923		       4c b1 02 	      jmp	NextIL
   1575  0926							;
   1576  0926							;=====================================================
   1577  0926							; This saves the current ILPC value on the stack, then
   1578  0926							; jumps to the address specified by the next two bytes.
   1579  0926							;
   1580  0926		       20 56 29    iCALL      jsr	pushILPC	;save ILPC
   1581  0929		       90 07		      bcc	iJMP
   1582  092b
   1583  092b							;If the push failed not enough stack space
   1584  092b		       a2 15	   ErrILStkOver ldx	#ERR_IL_STACK_OVER_FLOW	; Flag any error in line number
   1585  092d		       a9 00		      lda	#0	; stop the execution
   1586  092f		       4c 5e 06 	      jmp	iErr2
   1587  0932							;
   1588  0932							; Jmp to a specific location in the IL code.  The new
   1589  0932							; address immediately follows the opcode.
   1590  0932							;
   1591  0932		       20 3c 29    iJMP       jsr	getILWord
   1592  0935		       86 43		      stx	ILPC
   1593  0937		       85 44		      sta	ILPC+1
   1594  0939		       4c b1 02 	      jmp	NextIL
   1595  093c
   1596  093c
   1597  093c							;
   1598  093c							;=====================================================
   1599  093c							; Push the next two bytes onto the arithmetic stack.
   1600  093c							;
   1601  093c		       20 40 29    iSetR2     jsr	getILByte
   1602  093f		       85 58		      sta	R2
   1603  0941		       4c b1 02 	      jmp	NextIL
   1604  0944							;
   1605  0944							;=====================================================
   1606  0944							; Push the next two bytes onto the arithmetic stack.
   1607  0944							;
   1608  0944		       20 3c 29    iLIT       jsr	getILWord
   1609  0947		       86 52		      stx	R0
   1610  0949		       85 53		      sta	R0+1
   1611  094b		       20 39 2b 	      jsr	pushR0
   1612  094e		       4c b1 02 	      jmp	NextIL
   1613  0951							;
   1614  0951							;=====================================================
   1615  0951							; Initialize all variables for a single task.	Ie, set to zero.
   1616  0951							; And internal stack pointers
   1617  0951							;
   1618  0951		       98	   subVINIT   tya
   1619  0952		       48		      pha
   1620  0953
   1621  0953		       a9 00		      lda	#0
   1622  0955		       a0 00		      ldy	#0
   1623  0957		       91 41	   Vinit2     sta	(VARIABLES),y
   1624  0959		       c8		      iny
   1625  095a		       c0 48		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1626  095c		       90 f9		      bcc	Vinit2
   1627  095e		       85 4a		      sta	MATHSTACKPTR	; Clear the math stack
   1628  0960		       85 4d		      sta	GOSUBSTACKPTR	; Clear the gosub stack
   1629  0962		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reset the message queue
   1630  0964		       85 4e		      STA	MESSAGEPTR
   1631  0966
   1632  0966		       68		      pla
   1633  0967		       a8		      tay
   1634  0968		       60		      rts
   1635  0969
   1636  0969				   iVINIT
   1637  0969		       20 51 09 	      jsr	subVINIT
   1638  096c		       20 32 1f 	      jsr	Compile	; compile line numbers to memory pointers
   1639  096f		       4c b1 02 	      jmp	NextIL
   1640  0972							;
   1641  0972							;=====================================================
   1642  0972							; Set the address of the error handler.  After any
   1643  0972							; error, set to the ILPC to the specified location.
   1644  0972							;
   1645  0972		       20 3c 29    iERRGOTO   jsr	getILWord
   1646  0975		       8e 09 42 	      stx	errGoto
   1647  0978		       8d 0a 42 	      sta	errGoto+1
   1648  097b		       4c b1 02 	      jmp	NextIL
   1649  097e							;
   1650  097e							;=====================================================
   1651  097e							; TST is followed by an 8 bit signed offset, then a
   1652  097e							; null terminated string.  Compare the string against
   1653  097e							; the string starting at (CURPTR),CUROFF.  If the
   1654  097e							; strings match, continue executing the next IL
   1655  097e							; opcode.  Else, add the offset to ILPC.
   1656  097e							;
   1657  097e		       20 40 29    iTST       jsr	getILByte	;Get the relative jump address
   1658  0981		       8d 14 42 	      sta	offset	;save it to use if test faile
   1659  0984		       20 23 2b 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1660  0987
   1661  0987		       a4 51		      ldy	CUROFF
   1662  0989		       84 59		      sty	dpl	;save for later
   1663  098b							;
   1664  098b		       20 40 29    iTSTloop   jsr	getILByte	;get next char
   1665  098e		       f0 11		      beq	iTSTm	;match!
   1666  0990		       a4 59		      ldy	dpl
   1667  0992		       d1 4f		      cmp	(CURPTR),y
   1668  0994		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1669  0996		       09 20		      ora	#$20	; lets allow lowercase as well
   1670  0998		       d1 4f		      cmp	(CURPTR),y
   1671  099a		       d0 23		      bne	iTSTfail	;mismatch
   1672  099c		       c8	   iTSTUpper  iny
   1673  099d		       84 59		      sty	dpl
   1674  099f		       d0 ea		      bne	iTSTloop
   1675  09a1							;
   1676  09a1							; It's a match!  Clean up a bit.
   1677  09a1							;
   1678  09a1		       a4 59	   iTSTm      ldy	dpl
   1679  09a3		       84 51		      sty	CUROFF
   1680  09a5		       4c b1 02 	      jmp	NextIL
   1681  09a8
   1682  09a8							; Test for a single quote string
   1683  09a8		       20 40 29    iTSTStr    jsr	getILByte
   1684  09ab		       8d 14 42 	      sta	offset
   1685  09ae		       20 23 2b 	      jsr	saveIL
   1686  09b1		       a4 51		      ldy	CUROFF
   1687  09b3		       a9 22		      lda	#'"
   1688  09b5		       d1 4f		      cmp	(CURPTR),y
   1689  09b7		       d0 06		      bne	iTSTfail
   1690  09b9		       c8		      iny
   1691  09ba		       84 51		      sty	CUROFF
   1692  09bc		       4c d4 02 	      jmp	NextILStr
   1693  09bf							;
   1694  09bf							; Not a match, reset ILPC and then move to the
   1695  09bf							; offset.
   1696  09bf							;
   1697  09bf		       20 2e 2b    iTSTfail   jsr	restoreIL
   1698  09c2		       4c bc 0b 	      jmp	tstBranch
   1699  09c5							;
   1700  09c5							;=================================================JLIT=
   1701  09c5							; Test if we have a let statement without the let keyword
   1702  09c5		       20 40 29    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1703  09c8		       8d 14 42 	      sta	offset	; Save the jump offset for fails
   1704  09cb		       20 23 2b 	      jsr	saveIL	; save to restore when done if fail
   1705  09ce
   1706  09ce		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1707  09d0		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1708  09d2		       c9 01		      cmp	#kLet	; Is it a let keyword
   1709  09d4		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1710  09d6		       c9 80		      cmp	#tVa	; lets check for a variable
   1711  09d8		       90 e5		      bcc	iTSTfail	; Less than variable range
   1712  09da		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1713  09dc		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1714  09de		       b0 df		      bcs	iTSTfail	; return it failed
   1715  09e0
   1716  09e0				   iTSTLETGOOD
   1717  09e0		       c8		      iny
   1718  09e1		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1719  09e3				   iTSTGOODVAR
   1720  09e3		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1721  09e6
   1722  09e6							;=================================================JLIT=
   1723  09e6							; Test a byte at an indirect address
   1724  09e6							; fails if byte is not equal to the value at the address
   1725  09e6							; The tests an indirect byte and branches if true
   1726  09e6		       20 40 29    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1727  09e9		       8d 14 42 	      sta	offset	; Save the jump offset for fails
   1728  09ec		       20 23 2b 	      jsr	saveIL	; save to restore when done if fail
   1729  09ef		       20 3c 29 	      jsr	getILWord	; Get a word into RO
   1730  09f2		       86 52		      stx	R0
   1731  09f4		       85 53		      sta	R0+1
   1732  09f6		       20 40 29 	      jsr	getILByte	; Get byte into A
   1733  09f9		       a0 00		      ldy	#0
   1734  09fb		       d1 52		      cmp	(R0),y
   1735  09fd		       d0 03		      bne	iTSTByteNotEqual
   1736  09ff		       4c bf 09 	      jmp	iTSTfail
   1737  0a02
   1738  0a02				   iTSTByteNotEqual
   1739  0a02		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1740  0a05
   1741  0a05							;=================================================JLIT=
   1742  0a05							; Test a byte	branch if it fails
   1743  0a05		       20 40 29    iTSTB      jsr	getILByte	; Get the relative offset byte
   1744  0a08		       8d 14 42 	      sta	offset	; Save the jump offset for fails
   1745  0a0b		       20 23 2b 	      jsr	saveIL	; save to restore when done if fail
   1746  0a0e		       20 40 29 	      jsr	getILByte	; Get a byte into Acc
   1747  0a11		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1748  0a13		       d1 4f		      cmp	(CURPTR),y
   1749  0a15		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1750  0a17		       4c bf 09 	      jmp	iTSTfail	; REcover and move on to next test
   1751  0a1a
   1752  0a1a				   iTSTBMatch
   1753  0a1a		       c8		      iny
   1754  0a1b		       84 51		      sty	CUROFF	; Point to the next byte
   1755  0a1d		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1756  0a20
   1757  0a20							;=================================================JLIT=
   1758  0a20							; Test a byte	branch if it fails
   1759  0a20		       20 40 29    iTSTW      jsr	getILByte	; Get the relative offset byte
   1760  0a23		       8d 14 42 	      sta	offset	; Save the jump offset for fails
   1761  0a26		       20 23 2b 	      jsr	saveIL	; save to restore when done if fail
   1762  0a29		       20 3c 29 	      jsr	getILWord	; Get a word into RO
   1763  0a2c		       86 52		      stx	R0
   1764  0a2e		       85 53		      sta	R0+1
   1765  0a30		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1766  0a32		       8a		      txa
   1767  0a33		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1768  0a35		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1769  0a37		       4c bf 09 	      jmp	iTSTfail	; REcover and move on to next test
   1770  0a3a		       c8	   iTSTWM1    iny
   1771  0a3b		       a5 53		      lda	R0+1
   1772  0a3d		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1773  0a3f		       f0 03		      beq	iTSTWMatch
   1774  0a41		       4c bf 09 	      jmp	iTSTfail
   1775  0a44
   1776  0a44				   iTSTWMatch
   1777  0a44		       c8		      iny
   1778  0a45		       84 51		      sty	CUROFF
   1779  0a47		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1780  0a4a
   1781  0a4a							;================================================jLIT=
   1782  0a4a							;Test for end of line
   1783  0a4a							;
   1784  0a4a				   iTSTDONE
   1785  0a4a		       20 40 29 	      jsr	getILByte
   1786  0a4d		       8d 14 42 	      sta	offset
   1787  0a50		       20 23 2b 	      jsr	saveIL
   1788  0a53		       a4 51		      ldy	CUROFF
   1789  0a55		       84 59		      sty	dpl
   1790  0a57		       b1 4f		      lda	(CURPTR),y
   1791  0a59		       f0 0b		      beq	iTSTDONEtrue
   1792  0a5b		       c9 e6		      cmp	#oColon
   1793  0a5d		       f0 07		      beq	iTSTDONEtrue
   1794  0a5f		       a4 59		      ldy	dpl
   1795  0a61		       84 51		      sty	CUROFF
   1796  0a63		       4c bf 09 	      jmp	iTSTfail
   1797  0a66							;
   1798  0a66							; Advance to the next line
   1799  0a66							;
   1800  0a66				   iTSTDONEtrue
   1801  0a66		       4c b1 02 	      jmp	NextIL
   1802  0a69
   1803  0a69		       4c bc 0b    tstBranchLink jmp	tstBranch
   1804  0a6c							;
   1805  0a6c							;=====================================================
   1806  0a6c							; Inc and dec a variable , faster than a = a + 1
   1807  0a6c				   iINCVAR
   1808  0a6c		       20 cb 2b 	      jsr	popR0
   1809  0a6f		       a0 00		      ldy	#0
   1810  0a71		       18		      clc
   1811  0a72		       a9 01		      lda	#1
   1812  0a74		       71 52		      adc	(R0),y
   1813  0a76		       91 52		      sta	(R0),y
   1814  0a78		       90 07		      bcc	iINCDONE
   1815  0a7a		       c8		      iny
   1816  0a7b		       a9 00		      lda	#0
   1817  0a7d		       71 52		      adc	(R0),y
   1818  0a7f		       91 52		      sta	(R0),y
   1819  0a81				   iINCDONE
   1820  0a81		       4c b1 02 	      jmp	NextIL
   1821  0a84
   1822  0a84				   iDECVAR
   1823  0a84		       20 cb 2b 	      jsr	popR0
   1824  0a87		       a0 00		      ldy	#0
   1825  0a89		       38		      sec
   1826  0a8a		       b1 52		      lda	(R0),y
   1827  0a8c		       e9 01		      sbc	#1
   1828  0a8e		       91 52		      sta	(R0),y
   1829  0a90		       c8		      iny
   1830  0a91		       b1 52		      lda	(R0),y
   1831  0a93		       e9 00		      sbc	#0
   1832  0a95		       91 52		      sta	(R0),y
   1833  0a97		       4c b1 02 	      jmp	NextIL
   1834  0a9a
   1835  0a9a
   1836  0a9a							;
   1837  0a9a							;=====================================================
   1838  0a9a							; TSTV is followed by an 8 bit signed offset.	If the
   1839  0a9a							; value at (CURPTR),CUROFF appears to be a variable
   1840  0a9a							; name, move to the next IL statement.  Else, add the
   1841  0a9a							; offset to ILPC. Converted to use actual absolute memory addresses
   1842  0a9a							; TSTVT Looks for the task context
   1843  0a9a							;
   1844  0a9a		       20 e3 2b    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1845  0a9d		       a9 00		      lda	#0
   1846  0a9f		       85 58		      sta	R2
   1847  0aa1		       f0 04		      beq	iTSTVV
   1848  0aa3
   1849  0aa3							; Test for simple variable
   1850  0aa3		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1851  0aa5		       85 58		      sta	R2
   1852  0aa7
   1853  0aa7		       20 40 29    iTSTVV     jsr	getILByte	;offset
   1854  0aaa		       8d 14 42 	      sta	offset
   1855  0aad							;
   1856  0aad		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1857  0aaf		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1858  0ab1		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1859  0ab3		       4c 69 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1860  0ab6							;
   1861  0ab6				   iTSTVnext
   1862  0ab6		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1863  0ab8		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1864  0aba
   1865  0aba		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1866  0abc		       f0 5b		      beq	iTSTVParm
   1867  0abe
   1868  0abe		       c9 9b		      cmp	#tVhat	; task exit code
   1869  0ac0		       d0 04		      bne	iTSTV_A2Z
   1870  0ac2		       a9 48		      lda	#TASKEXITCODE
   1871  0ac4		       d0 0b		      bne	iTSTVContinue
   1872  0ac6
   1873  0ac6				   iTSTV_A2Z
   1874  0ac6
   1875  0ac6		       c9 80		      cmp	#tVa
   1876  0ac8		       90 9f		      bcc	tstBranchLink
   1877  0aca		       c9 9a		      cmp	#tVz+1
   1878  0acc		       b0 9b		      bcs	tstBranchLink
   1879  0ace
   1880  0ace
   1881  0ace							;
   1882  0ace							; The condition is true, so convert to an index, push
   1883  0ace							; it onto the stack and continue running.
   1884  0ace							;
   1885  0ace		       29 7f		      and	#%01111111	; Mask off the high bit
   1886  0ad0		       0a		      asl		; multiply by two
   1887  0ad1
   1888  0ad1				   iTSTVContinue
   1889  0ad1		       c8		      iny
   1890  0ad2		       84 51		      sty	CUROFF	; it is a valid variable
   1891  0ad4		       48		      pha		; save the last variable pointer value
   1892  0ad5		       a5 58		      lda	R2
   1893  0ad7		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1894  0ad9
   1895  0ad9		       20 15 29 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1896  0adc		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1897  0ade
   1898  0ade		       68		      pla		; We have an invalid pid for getting variable value
   1899  0adf		       a2 10		      ldx	#ERR_INVALID_PID
   1900  0ae1		       a9 00		      lda	#0
   1901  0ae3		       4c 5e 06 	      jmp	iErr2
   1902  0ae6
   1903  0ae6				   iTSTVGOODPID
   1904  0ae6		       20 fd 28 	      jsr	ipc_getcontext	; Get the other tasks variables
   1905  0ae9		       a0 01		      ldy	#VARIABLEPOS
   1906  0aeb		       b1 56		      lda	(MQ),y
   1907  0aed		       85 52		      sta	R0
   1908  0aef		       c8		      iny
   1909  0af0		       b1 56		      lda	(MQ),y
   1910  0af2		       85 53		      sta	R0+1
   1911  0af4		       4c ff 0a 	      jmp	iTSTVAddOffset
   1912  0af7
   1913  0af7				   iTSTVLocalValue
   1914  0af7		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1915  0af9		       85 52		      sta	R0
   1916  0afb		       a5 42		      lda	VARIABLES+1
   1917  0afd		       85 53		      sta	R0+1
   1918  0aff
   1919  0aff				   iTSTVAddOffset
   1920  0aff		       68		      pla
   1921  0b00		       85 54		      sta	R1
   1922  0b02		       a9 00		      lda	#0
   1923  0b04		       85 55		      sta	R1+1
   1924  0b06
   1925  0b06				   iTSTVcontinue
   1926  0b06
   1927  0b06		       4c 7f 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1928  0b09
   1929  0b09							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1930  0b09							; an array of integer values or byte.
   1931  0b09				   iTSTVat
   1932  0b09		       c8		      iny
   1933  0b0a		       84 51		      sty	CUROFF	;it is a valid variable
   1934  0b0c		       ad 1a 42 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1935  0b0f		       85 52		      sta	R0
   1936  0b11		       ad 1b 42 	      lda	ProgramEnd+1
   1937  0b14		       85 53		      sta	R0+1
   1938  0b16		       4c f7 06 	      jmp	pushR0nextIl	;place this onto the stack
   1939  0b19
   1940  0b19							; When we get parameters passed we can access them using the # variable with[]
   1941  0b19							; example #[0] #[1] etc, we dont check yet if there is too many
   1942  0b19		       c8	   iTSTVParm  iny
   1943  0b1a		       84 51		      sty	CUROFF	;it is a valid variable
   1944  0b1c
   1945  0b1c							; upon return the y register  point to the gosub Parms entry value entry
   1946  0b1c		       20 03 25 	      jsr	GosubFindParms
   1947  0b1f		       90 21		      bcc	iTSTMissingParms
   1948  0b21
   1949  0b21		       88		      dey
   1950  0b22		       88		      dey
   1951  0b23		       88		      dey		;Point to the actual index of first parameter in math stack
   1952  0b24
   1953  0b24		       a5 48		      lda	MATHSTACK
   1954  0b26		       85 52		      sta	R0
   1955  0b28		       a5 49		      lda	MATHSTACK+1
   1956  0b2a		       85 53		      sta	R0+1
   1957  0b2c		       b1 4b		      lda	(GOSUBSTACK),y	; Get the correct Offset to start of parameters
   1958  0b2e		       f0 0b		      beq	iTSTVindex0	; no math if no offset
   1959  0b30		       18		      clc
   1960  0b31		       65 52		      adc	R0	; Point to the actual address that the variables start, not just top of stack
   1961  0b33		       85 52		      sta	R0
   1962  0b35		       a9 00		      lda	#0
   1963  0b37		       65 53		      adc	R0+1
   1964  0b39		       85 53		      sta	R0+1
   1965  0b3b				   iTSTVindex0
   1966  0b3b		       a9 81		      lda	#GOSUB_RTN_VALUE
   1967  0b3d		       85 58		      sta	R2	; Set the data type as a parameter to a function
   1968  0b3f		       4c f7 06 	      jmp	pushR0nextIl
   1969  0b42
   1970  0b42
   1971  0b42				   iTSTMissingParms
   1972  0b42		       a9 00		      lda	#0
   1973  0b44		       a2 19		      ldx	#ERR_FUNCTION_EXPECTED_PARAMETERS
   1974  0b46		       4c 5e 06 	      jmp	iErr2
   1975  0b49
   1976  0b49							;
   1977  0b49							;=====================================================
   1978  0b49							; TSTL seems basically the same as TSTN, but leave the
   1979  0b49							; value in R0 instead of pushing onto stack.
   1980  0b49							; This tests for a valid line number
   1981  0b49							;
   1982  0b49		       20 40 29    iTSTL      jsr	getILByte
   1983  0b4c		       8d 14 42 	      sta	offset
   1984  0b4f							;
   1985  0b4f		       a4 51		      ldy	CUROFF
   1986  0b51		       b1 4f		      lda	(CURPTR),y
   1987  0b53		       c8		      iny
   1988  0b54		       11 4f		      ora	(CURPTR),y
   1989  0b56		       f0 06		      beq	iTSTLNotLineNo
   1990  0b58
   1991  0b58
   1992  0b58							; In Both cases we need to point to the first usefull byte to process.
   1993  0b58		       c8		      iny
   1994  0b59		       84 51		      sty	CUROFF
   1995  0b5b		       4c b1 02 	      jmp	NextIL
   1996  0b5e				   iTSTLNotLineNo
   1997  0b5e		       c8		      iny
   1998  0b5f		       84 51		      sty	CUROFF
   1999  0b61		       4c bc 0b 	      jmp	tstBranch
   2000  0b64
   2001  0b64							;
   2002  0b64							;=====================================================
   2003  0b64							; TSTN checks for a number.  This is very simplistic;
   2004  0b64							; if the character is a digit, assume it's a number.
   2005  0b64							; Convert to a number and push it onto the stack.
   2006  0b64							;
   2007  0b64		       20 40 29    iTSTN      jsr	getILByte
   2008  0b67		       8d 14 42 	      sta	offset
   2009  0b6a							;
   2010  0b6a		       a9 00		      lda	#0
   2011  0b6c		       85 59		      sta	dpl
   2012  0b6e		       a4 51		      ldy	CUROFF
   2013  0b70				   chkType
   2014  0b70		       b1 4f		      lda	(CURPTR),y
   2015  0b72		       c9 a2		      cmp	#tByte
   2016  0b74		       f0 0e		      beq	chkByte
   2017  0b76		       c9 a4		      cmp	#tInteger
   2018  0b78		       f0 16		      beq	chkInteger
   2019  0b7a		       c9 eb		      cmp	#oMinus
   2020  0b7c		       d0 3e		      bne	tstBranch
   2021  0b7e		       e6 59		      inc	dpl
   2022  0b80		       c8		      iny
   2023  0b81		       4c 70 0b 	      jmp	chkType
   2024  0b84
   2025  0b84				   chkByte
   2026  0b84		       a9 00		      lda	#0
   2027  0b86		       85 53		      sta	R0+1
   2028  0b88		       c8		      iny
   2029  0b89		       b1 4f		      lda	(CURPTR),y
   2030  0b8b		       85 52		      sta	R0
   2031  0b8d		       c8		      iny
   2032  0b8e		       d0 0b		      bne	iTSTN_1
   2033  0b90
   2034  0b90				   chkInteger
   2035  0b90		       c8		      iny
   2036  0b91		       b1 4f		      lda	(CURPTR),y
   2037  0b93		       85 52		      sta	R0
   2038  0b95		       c8		      iny
   2039  0b96		       b1 4f		      lda	(CURPTR),y
   2040  0b98		       85 53		      sta	R0+1
   2041  0b9a		       c8		      iny
   2042  0b9b							;
   2043  0b9b							; Check if it is negative and make it so
   2044  0b9b							;
   2045  0b9b				   iTSTN_1
   2046  0b9b		       84 51		      sty	CUROFF
   2047  0b9d
   2048  0b9d		       a5 59		      lda	dpl
   2049  0b9f		       f0 18		      beq	iTSTN_2	;positive
   2050  0ba1							;
   2051  0ba1		       a5 52		      lda	R0
   2052  0ba3		       05 53		      ora	R0+1
   2053  0ba5		       f0 12		      beq	iTSTN_2	;zero
   2054  0ba7
   2055  0ba7							; Invert all the bits, then add one.
   2056  0ba7							;
   2057  0ba7		       a5 52		      lda	R0
   2058  0ba9		       49 ff		      eor	#$ff
   2059  0bab		       85 52		      sta	R0
   2060  0bad		       a5 53		      lda	R0+1
   2061  0baf		       49 ff		      eor	#$ff
   2062  0bb1		       85 53		      sta	R0+1
   2063  0bb3							;
   2064  0bb3		       e6 52		      inc	R0
   2065  0bb5		       d0 02		      bne	iTSTN_2
   2066  0bb7		       e6 53		      inc	R0+1
   2067  0bb9				   iTSTN_2
   2068  0bb9		       4c f7 06 	      jmp	pushR0nextIl	;save onto stack
   2069  0bbc
   2070  0bbc							;
   2071  0bbc							; Common jump point for all TSTx instructions that
   2072  0bbc							; fail to meet the requirements.  This takes the
   2073  0bbc							; offset and adds/subtracts to/from ILPC.
   2074  0bbc							;
   2075  0bbc		       ad 14 42    tstBranch  lda	offset	;get signed offset
   2076  0bbf		       10 0e		      bpl	tstPositive
   2077  0bc1							;
   2078  0bc1							; Do negative branch.	Do sign extension.
   2079  0bc1							;
   2080  0bc1		       18	   tstNegative clc
   2081  0bc2		       65 43		      adc	ILPC
   2082  0bc4		       85 43		      sta	ILPC
   2083  0bc6							;		  bcc	  tstBothDone
   2084  0bc6							;		  dec	  ILPC+1
   2085  0bc6							;		  jmp	  NextIL
   2086  0bc6
   2087  0bc6		       a5 44		      lda	ILPC+1
   2088  0bc8		       69 ff		      adc	#$ff
   2089  0bca		       85 44		      sta	ILPC+1
   2090  0bcc		       4c b1 02 	      jmp	NextIL	;keep going
   2091  0bcf							;
   2092  0bcf		       18	   tstPositive clc
   2093  0bd0		       65 43		      adc	ILPC
   2094  0bd2		       85 43		      sta	ILPC
   2095  0bd4		       90 02		      bcc	tstBothDone
   2096  0bd6		       e6 44		      inc	ILPC+1
   2097  0bd8				   tstBothDone
   2098  0bd8		       4c b1 02 	      jmp	NextIL
   2099  0bdb
   2100  0bdb							;
   2101  0bdb							;====================================================
   2102  0bdb							; Test for IRQ pending, and test if a break key pressed
   2103  0bdb							; Yes I know but this handles all sorts of irq/break issues
   2104  0bdb							;
   2105  0bdb		       20 40 29    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2106  0bde		       8d 14 42 	      sta	offset	; Store the not true jump address offset
   2107  0be1		       ad 3b 19    irqNo      lda	IRQPending	; Check if the pending value is set
   2108  0be4		       f0 20		      beq	tstBreak	; if no irq then check for an escape key pressed
   2109  0be6		       c9 01		      cmp	#1	; only do this if set to first time
   2110  0be8		       d0 1c		      bne	tstBreak	; We are in a irq service already
   2111  0bea				   iTSTProcessIRQ
   2112  0bea		       78		      sei		; disable the interupt until ireturn resets it
   2113  0beb		       ee 3b 19 	      inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2114  0bee		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2115  0bf0		       20 53 2b 	      jsr	pushLN	; Push the next line to be executed
   2116  0bf3		       b0 21		      bcs	ErrStkOver	; Check if there was an error
   2117  0bf5		       ad 3c 19 	      lda	IRQEntry	; Get the line number to branch to
   2118  0bf8		       85 4f		      sta	CURPTR	; put line number into r0
   2119  0bfa		       ad 3d 19 	      lda	IRQEntry+1
   2120  0bfd		       85 50		      sta	CURPTR+1
   2121  0bff		       a9 03		      lda	#3	; Point to first byte of program text
   2122  0c01		       85 51		      sta	CUROFF
   2123  0c03		       4c b1 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2124  0c06
   2125  0c06				   tstBreak
   2126  0c06		       20 48 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2127  0c09		       d0 b1		      bne	tstBranch	; z not set of no break found
   2128  0c0b		       ad 16 42 	      lda	taskIOPending
   2129  0c0e		       f0 03		      beq	tstBrkComplete
   2130  0c10		       ce 16 42 	      dec	taskIOPending
   2131  0c13		       4c e3 05    tstBrkComplete jmp	iFIN	; Exit out of run mode
   2132  0c16
   2133  0c16		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2134  0c18		       a9 00		      lda	#0	; stop the execution
   2135  0c1a		       4c 5e 06 	      jmp	iErr2
   2136  0c1d							;
   2137  0c1d
   2138  0c1d							;=====================================================
   2139  0c1d							; This places the number of free bytes on top of the
   2140  0c1d							; stack.
   2141  0c1d							;
   2142  0c1d		       20 11 23    iFREE      jsr	MemFree
   2143  0c20		       4c f7 06 	      jmp	pushR0nextIl
   2144  0c23							;
   2145  0c23							;=====================================================
   2146  0c23							; Generate a random number from 0-FFFF and then MOD
   2147  0c23							; it with the value on top of stack.  Leaves number on
   2148  0c23							; stack
   2149  0c23							;
   2150  0c23		       20 e3 2b    iRANDOM    jsr	popR1	;mod value
   2151  0c26							;
   2152  0c26							; If the value is zero, just return a one.
   2153  0c26							;
   2154  0c26		       a5 54		      lda	R1
   2155  0c28		       05 55		      ora	R1+1
   2156  0c2a		       f0 4a		      beq	irandom1
   2157  0c2c							;
   2158  0c2c		       ad 0f 42 	      lda	random+1
   2159  0c2f		       8d 0c 42 	      sta	rtemp1
   2160  0c32		       ad 0e 42 	      lda	random
   2161  0c35		       0a		      asl
   2162  0c36		       2e 0c 42 	      rol	rtemp1
   2163  0c39		       0a		      asl
   2164  0c3a		       2e 0c 42 	      rol	rtemp1
   2165  0c3d		       18		      clc
   2166  0c3e		       6d 0e 42 	      adc	random
   2167  0c41
   2168  0c41		       48		      pha
   2169  0c42
   2170  0c42		       ad 0c 42 	      lda	rtemp1
   2171  0c45		       6d 0f 42 	      adc	random+1
   2172  0c48		       8d 0f 42 	      sta	random+1
   2173  0c4b
   2174  0c4b		       68		      pla
   2175  0c4c
   2176  0c4c		       69 11		      adc	#$11
   2177  0c4e		       8d 0e 42 	      sta	random
   2178  0c51		       ad 0f 42 	      lda	random+1
   2179  0c54		       69 36		      adc	#$36
   2180  0c56		       8d 0f 42 	      sta	random+1
   2181  0c59
   2182  0c59		       ad 0e 42 	      lda	random
   2183  0c5c		       85 52		      sta	R0
   2184  0c5e		       ad 0f 42 	      lda	random+1
   2185  0c61		       29 7f		      and	#$7f	;make positive
   2186  0c63		       85 53		      sta	R0+1
   2187  0c65							;
   2188  0c65							; R0 contains the number and R1 contains the max value.
   2189  0c65							;
   2190  0c65		       20 1d 07 	      jsr	iDivNoPop
   2191  0c68		       20 4c 2c 	      jsr	RestoreSigns
   2192  0c6b		       a5 56		      lda	MQ
   2193  0c6d		       85 52		      sta	R0
   2194  0c6f		       a5 57		      lda	MQ+1
   2195  0c71		       85 53		      sta	R0+1
   2196  0c73		       4c f7 06 	      jmp	pushR0nextIl
   2197  0c76				   irandom1
   2198  0c76		       a9 00		      lda	#0
   2199  0c78		       85 53		      sta	R0+1
   2200  0c7a		       a9 01		      lda	#1
   2201  0c7c		       85 52		      sta	R0
   2202  0c7e		       4c f7 06 	      jmp	pushR0nextIl
   2203  0c81
   2204  0c81							; The following replaced by call to division/modulo
   2205  0c81							;iRANDOM_2	lda	R0
   2206  0c81							;		cmp	R1
   2207  0c81							;		bne	iRANDOM_1
   2208  0c81							;		lda	R0+1
   2209  0c81							;		cmp	R1+1
   2210  0c81							;		bne	iRANDOM_1	;need to subtract
   2211  0c81							;
   2212  0c81							; Subtract R1 from R0
   2213  0c81							;
   2214  0c81							;iRANDOM_sub	sec
   2215  0c81							;		lda	R0
   2216  0c81							;		sbc	R1
   2217  0c81							;		sta	R0
   2218  0c81							;		lda	R0+1
   2219  0c81							;		sbc	R1+1
   2220  0c81							;		sta	R0+1
   2221  0c81							;		jmp	iRANDOM_2
   2222  0c81							;
   2223  0c81							; See if R1 > R0.  If so, branch to subtract.
   2224  0c81							;
   2225  0c81							;iRANDOM_1	lda	R0
   2226  0c81							;		cmp	R1
   2227  0c81							;		lda	R0+1
   2228  0c81							;		sbc	R1+1
   2229  0c81							;		bvc	iRANDOM_4
   2230  0c81							;		eor	#$80
   2231  0c81							;iRANDOM_4	bpl	iRANDOM_sub
   2232  0c81							;
   2233  0c81							; All done.  Almost.  Add one, then push the result.
   2234  0c81							;
   2235  0c81							;irandom1	inc	R0
   2236  0c81							;		bne	iRANDOM_3
   2237  0c81							;		inc	R0+1
   2238  0c81							;iRANDOM_3
   2239  0c81							;		  jsr	pushR0	;return value
   2240  0c81							;		jmp	NextIL
   2241  0c81							;
   2242  0c81							; Poke a value into a memory location
   2243  0c81		       8c 10 42    iPOKEMEMORY sty	tempy
   2244  0c84		       20 cb 2b 	      jsr	popR0
   2245  0c87		       20 e3 2b 	      jsr	popR1
   2246  0c8a		       a0 00		      ldy	#0
   2247  0c8c		       a5 52		      lda	R0
   2248  0c8e		       91 54		      sta	(R1),y
   2249  0c90		       ac 10 42 	      ldy	tempy
   2250  0c93		       4c b1 02 	      jmp	NextIL
   2251  0c96							;
   2252  0c96							; Get a value from a memory location
   2253  0c96							;
   2254  0c96		       8c 10 42    iPEEKMEMORY sty	tempy
   2255  0c99		       20 cb 2b 	      jsr	popR0
   2256  0c9c		       a0 00		      ldy	#0
   2257  0c9e		       b1 52		      lda	(R0),y
   2258  0ca0		       ac 10 42 	      ldy	tempy
   2259  0ca3		       85 52		      sta	R0
   2260  0ca5		       a9 00		      lda	#0
   2261  0ca7		       85 53		      sta	R0+1
   2262  0ca9		       4c f7 06 	      jmp	pushR0nextIl
   2263  0cac							;
   2264  0cac							; Call to address return what ever is in a to the stack
   2265  0cac							; func2 will load a value into a before the call
   2266  0cac		       20 e3 2b    iCallFunc  jsr	popR1
   2267  0caf		       a5 54		      lda	R1
   2268  0cb1		       20 bd 0c 	      jsr	iCallRtn
   2269  0cb4		       85 52		      sta	R0
   2270  0cb6		       a9 00		      lda	#0
   2271  0cb8		       85 53		      sta	R0+1
   2272  0cba		       20 f7 06 	      jsr	pushR0nextIl
   2273  0cbd				   iCallRtn
   2274  0cbd		       20 cb 2b 	      jsr	popR0
   2275  0cc0		       6c 52 00 	      jmp	(R0)
   2276  0cc3
   2277  0cc3
   2278  0cc3							;===========================================jlit======
   2279  0cc3							;Get a character from the terminal convert to value
   2280  0cc3							;leave the number on top of the stack
   2281  0cc3							;
   2282  0cc3				   iGETCHAR
   2283  0cc3		       20 cb 19 	      jsr	VGETCH
   2284  0cc6					      if	CTMON65
   2285  0cc6		       48		      pha
   2286  0cc7		       20 c8 19 	      jsr	VOUTCH	;echo echo echo
   2287  0cca		       68		      pla
   2288  0ccb					      endif
   2289  0ccb		       85 52		      sta	R0
   2290  0ccd		       a9 00		      lda	#0
   2291  0ccf		       85 53		      sta	R0+1
   2292  0cd1		       20 39 2b 	      jsr	pushR0
   2293  0cd4							;
   2294  0cd4		       4c b1 02 	      jmp	NextIL
   2295  0cd7							;===========================================jusilostintim======
   2296  0cd7							;Put a character to the terminal convert to
   2297  0cd7							;
   2298  0cd7		       20 cb 2b    iPUTCHAR   jsr	popR0
   2299  0cda		       a5 52		      lda	R0
   2300  0cdc		       20 c8 19 	      jsr	VOUTCH
   2301  0cdf		       4c b1 02 	      jmp	NextIL
   2302  0ce2							;=====================================================
   2303  0ce2							; Put the number on the stack out as hex, suppress leading 0
   2304  0ce2				   iHexOut
   2305  0ce2		       20 cb 2b 	      jsr	popR0
   2306  0ce5		       a5 53		      lda	R0+1
   2307  0ce7		       f0 03		      beq	iHexSecondByte
   2308  0ce9		       20 db 20 	      jsr	OUTHEX
   2309  0cec				   iHexSecondByte
   2310  0cec		       a5 52		      lda	R0
   2311  0cee		       20 db 20 	      jsr	OUTHEX
   2312  0cf1		       4c b1 02 	      jmp	NextIL
   2313  0cf4							;
   2314  0cf4							;=====================================================
   2315  0cf4							; Replace TOS with its absolute value.
   2316  0cf4							;
   2317  0cf4		       20 cb 2b    iABS       jsr	popR0
   2318  0cf7		       a5 53		      lda	R0+1
   2319  0cf9		       10 10		      bpl	iABS_1	;already positive
   2320  0cfb		       49 ff		      eor	#$ff
   2321  0cfd		       85 53		      sta	R0+1
   2322  0cff		       a5 52		      lda	R0
   2323  0d01		       49 ff		      eor	#$ff
   2324  0d03		       85 52		      sta	R0
   2325  0d05		       e6 52		      inc	R0
   2326  0d07		       d0 02		      bne	iABS_1
   2327  0d09		       e6 53		      inc	R0+1
   2328  0d0b		       4c f7 06    iABS_1     jmp	pushR0nextIl
   2329  0d0e
   2330  0d0e							;
   2331  0d0e							;================================================================
   2332  0d0e							; The set of logical operators
   2333  0d0e				   iLogAnd
   2334  0d0e		       20 cb 2b 	      jsr	popR0
   2335  0d11		       20 e3 2b 	      jsr	popR1
   2336  0d14		       a5 52		      lda	R0
   2337  0d16		       25 54		      and	R1
   2338  0d18		       85 52		      sta	R0
   2339  0d1a		       a5 53		      lda	R0+1
   2340  0d1c		       25 55		      and	R1+1
   2341  0d1e		       85 53		      sta	R0+1
   2342  0d20		       4c f7 06 	      jmp	pushR0nextIl
   2343  0d23				   iLogOr
   2344  0d23		       20 cb 2b 	      jsr	popR0
   2345  0d26		       20 e3 2b 	      jsr	popR1
   2346  0d29		       a5 52		      lda	R0
   2347  0d2b		       05 54		      ora	R1
   2348  0d2d		       85 52		      sta	R0
   2349  0d2f		       a5 53		      lda	R0+1
   2350  0d31		       05 55		      ora	R1+1
   2351  0d33		       85 53		      sta	R0+1
   2352  0d35		       4c f7 06 	      jmp	pushR0nextIl
   2353  0d38				   iLogXor
   2354  0d38		       20 cb 2b 	      jsr	popR0
   2355  0d3b		       20 e3 2b 	      jsr	popR1
   2356  0d3e		       a5 52		      lda	R0
   2357  0d40		       45 54		      eor	R1
   2358  0d42		       85 52		      sta	R0
   2359  0d44		       a5 53		      lda	R0+1
   2360  0d46		       45 55		      eor	R1+1
   2361  0d48		       85 53		      sta	R0+1
   2362  0d4a		       4c f7 06 	      jmp	pushR0nextIl
   2363  0d4d				   iLogNot
   2364  0d4d		       20 cb 2b 	      jsr	popR0
   2365  0d50		       a5 52		      lda	R0
   2366  0d52		       49 ff		      eor	#$FF
   2367  0d54		       85 52		      sta	R0
   2368  0d56		       a5 53		      lda	R0+1
   2369  0d58		       49 ff		      eor	#$FF
   2370  0d5a		       85 53		      sta	R0+1
   2371  0d5c		       4c f7 06 	      jmp	pushR0nextIl
   2372  0d5f
   2373  0d5f				   iTruth
   2374  0d5f		       a9 ff		      lda	#$FF
   2375  0d61		       85 52		      sta	R0
   2376  0d63		       85 53		      sta	R0+1
   2377  0d65		       4c f7 06 	      jmp	pushR0nextIl
   2378  0d68				   iFalse
   2379  0d68		       a9 00		      lda	#$00
   2380  0d6a		       85 52		      sta	R0
   2381  0d6c		       85 53		      sta	R0+1
   2382  0d6e		       4c f7 06 	      jmp	pushR0nextIl
   2383  0d71							;===============================================================
   2384  0d71							;Shift instruction right 1, left 0
   2385  0d71							;
   2386  0d71		       8a	   iShift     txa
   2387  0d72		       48		      pha
   2388  0d73		       20 cb 2b 	      jsr	popR0	; number of places to shift 0 to 16 really
   2389  0d76		       20 e3 2b 	      jsr	popR1	; value to shift
   2390  0d79		       a6 52		      ldx	R0	; get number of times to shift
   2391  0d7b		       20 40 29 	      jsr	getILByte	; get direction to shift
   2392  0d7e		       c9 01		      cmp	#1	; Should we be doing left
   2393  0d80		       f0 0a		      beq	iShiftRight
   2394  0d82							;
   2395  0d82							; Shift r1 left n bits
   2396  0d82				   iShiftLeft
   2397  0d82		       18	   iShiftLloop clc
   2398  0d83		       26 54		      rol	R1
   2399  0d85		       26 55		      rol	R1+1
   2400  0d87		       ca		      dex
   2401  0d88		       d0 f8		      bne	iShiftLloop
   2402  0d8a		       f0 07		      beq	iShiftExit
   2403  0d8c							;
   2404  0d8c							; Shift R1 right n bits
   2405  0d8c							;
   2406  0d8c				   iShiftRight
   2407  0d8c		       46 55	   iShiftRloop lsr	R1+1
   2408  0d8e		       46 54		      lsr	R1
   2409  0d90		       ca		      dex
   2410  0d91		       d0 f9		      bne	iShiftRloop
   2411  0d93				   iShiftExit
   2412  0d93		       68		      pla
   2413  0d94		       aa		      tax
   2414  0d95		       20 b1 2b 	      jsr	pushR1
   2415  0d98		       4c b1 02 	      jmp	NextIL
   2416  0d9b
   2417  0d9b							;================================================================
   2418  0d9b							;Set the IRQ service rtn line number
   2419  0d9b							;
   2420  0d9b		       78	   iSetIrq    sei		; disable the interupts
   2421  0d9c		       a9 00		      lda	#0	; Zero the Status flag
   2422  0d9e		       8d 3a 19 	      sta	IRQStatus
   2423  0da1		       20 cb 2b 	      jsr	popR0	; get the line number
   2424  0da4		       a5 52		      lda	R0
   2425  0da6		       05 53		      ora	R0+1
   2426  0da8		       f0 22		      beq	iSetExt	; if it is zero disable all
   2427  0daa		       a9 01		      lda	#GOSUB_RTN	; default push type
   2428  0dac		       20 53 2b 	      jsr	pushLN	; Save the current line pointer
   2429  0daf		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2430  0db1		       4c 16 0c 	      jmp	ErrStkOver	; Check if there was an error
   2431  0db4				   iSetIrqOk
   2432  0db4		       20 85 29 	      jsr	findLine	; Find the IRQ func Line Pointer
   2433  0db7		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2434  0db9		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2435  0dbb		       8d 3d 19 	      sta	IRQEntry+1
   2436  0dbe		       a5 4f		      lda	CURPTR
   2437  0dc0		       8d 3c 19 	      sta	IRQEntry
   2438  0dc3		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2439  0dc5		       8d 3a 19 	      sta	IRQStatus
   2440  0dc8		       20 7c 2b 	      jsr	popLN	; Restore the old line number
   2441  0dcb		       58		      cli		; Enable the interupts
   2442  0dcc		       4c b1 02    iSetExt    jmp	NextIL
   2443  0dcf
   2444  0dcf		       20 7c 2b    iSetIrqErr jsr	popLN
   2445  0dd2		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2446  0dd4		       a9 00		      lda	#0
   2447  0dd6		       4c 5e 06 	      jmp	iErr2
   2448  0dd9							;
   2449  0dd9		       20 cb 2b    iTRACEPROG jsr	popR0
   2450  0ddc		       a5 52		      lda	R0
   2451  0dde		       85 40		      sta	ILTrace
   2452  0de0		       4c b1 02 	      jmp	NextIL
   2453  0de3
   2454  0de3							;=====================================================
   2455  0de3							; Define start of non page zero data
   2456 U4222 ????				      seg.u	TBData
   2457 U3550					      org	PROGEND
   2458 U3550							;=================================================================
   2459 U3550							;
   2460 U3550					      if	IL_DEBUG_TEXT
------- FILE ILKeyText.inc LEVEL 2 PASS 6
      0 U3550					      include	"ILKeyText.inc"
      1  0de3					      seg	Code
      2  0de3					      if	IL_DEBUG_TEXT
      3  0de3				   ILTEXTTABLE
      0  0de3					      db	0,23,"iXINIT		   ",0
      1  0de3		       00 17 69 58*	      .byte.b	0,23,"iXINIT		   ",0
      0  0dfa					      db	1,23,"iDONE		   ",0
      1  0dfa		       01 17 69 44*	      .byte.b	1,23,"iDONE		   ",0
      0  0e11					      db	2,23,"iPRS		   ",0
      1  0e11		       02 17 69 50*	      .byte.b	2,23,"iPRS		   ",0
      0  0e28					      db	3,23,"iPRN		   ",0
      1  0e28		       03 17 69 50*	      .byte.b	3,23,"iPRN		   ",0
      0  0e3f					      db	4,23,"iSPC		   ",0
      1  0e3f		       04 17 69 53*	      .byte.b	4,23,"iSPC		   ",0
      0  0e56					      db	5,23,"iNLINE		   ",0
      1  0e56		       05 17 69 4e*	      .byte.b	5,23,"iNLINE		   ",0
      0  0e6d					      db	6,23,"iNXT		   ",0
      1  0e6d		       06 17 69 4e*	      .byte.b	6,23,"iNXT		   ",0
      0  0e84					      db	7,23,"iXFER		   ",0
      1  0e84		       07 17 69 58*	      .byte.b	7,23,"iXFER		   ",0
      0  0e9b					      db	8,23,"iSAV		   ",0
      1  0e9b		       08 17 69 53*	      .byte.b	8,23,"iSAV		   ",0
      0  0eb2					      db	9,23,"iRSTR		   ",0
      1  0eb2		       09 17 69 52*	      .byte.b	9,23,"iRSTR		   ",0
      0  0ec9					      db	10,23,"iCMPR		    ",0
      1  0ec9		       0a 17 69 43*	      .byte.b	10,23,"iCMPR		    ",0
      0  0ee0					      db	11,23,"iINNUM		    ",0
      1  0ee0		       0b 17 69 49*	      .byte.b	11,23,"iINNUM		    ",0
      0  0ef7					      db	12,23,"iFIN		    ",0
      1  0ef7		       0c 17 69 46*	      .byte.b	12,23,"iFIN		    ",0
      0  0f0e					      db	13,23,"iERR		    ",0
      1  0f0e		       0d 17 69 45*	      .byte.b	13,23,"iERR		    ",0
      0  0f25					      db	14,23,"iADD		    ",0
      1  0f25		       0e 17 69 41*	      .byte.b	14,23,"iADD		    ",0
      0  0f3c					      db	15,23,"iSUB		    ",0
      1  0f3c		       0f 17 69 53*	      .byte.b	15,23,"iSUB		    ",0
      0  0f53					      db	16,23,"iNEG		    ",0
      1  0f53		       10 17 69 4e*	      .byte.b	16,23,"iNEG		    ",0
      0  0f6a					      db	17,23,"iMUL		    ",0
      1  0f6a		       11 17 69 4d*	      .byte.b	17,23,"iMUL		    ",0
      0  0f81					      db	18,23,"iDIV		    ",0
      1  0f81		       12 17 69 44*	      .byte.b	18,23,"iDIV		    ",0
      0  0f98					      db	19,23,"iSTORE		    ",0
      1  0f98		       13 17 69 53*	      .byte.b	19,23,"iSTORE		    ",0
      0  0faf					      db	20,23,"iIND		    ",0
      1  0faf		       14 17 69 49*	      .byte.b	20,23,"iIND		    ",0
      0  0fc6					      db	21,23,"iLST		    ",0
      1  0fc6		       15 17 69 4c*	      .byte.b	21,23,"iLST		    ",0
      0  0fdd					      db	22,23,"iINIT		    ",0
      1  0fdd		       16 17 69 49*	      .byte.b	22,23,"iINIT		    ",0
      0  0ff4					      db	23,23,"iGETLINE	    ",0
      1  0ff4		       17 17 69 47*	      .byte.b	23,23,"iGETLINE	    ",0
      0  100b					      db	24,23,"iINSRT		    ",0
      1  100b		       18 17 69 49*	      .byte.b	24,23,"iINSRT		    ",0
      0  1022					      db	25,23,"iRTN		    ",0
      1  1022		       19 17 69 52*	      .byte.b	25,23,"iRTN		    ",0
      0  1039					      db	26,23,"MONITOR 	    ",0
      1  1039		       1a 17 4d 4f*	      .byte.b	26,23,"MONITOR 	    ",0
      0  1050					      db	27,23,"iLIT		    ",0
      1  1050		       1b 17 69 4c*	      .byte.b	27,23,"iLIT		    ",0
      0  1067					      db	28,23,"iCALL		    ",0
      1  1067		       1c 17 69 43*	      .byte.b	28,23,"iCALL		    ",0
      0  107e					      db	29,23,"iJMP		    ",0
      1  107e		       1d 17 69 4a*	      .byte.b	29,23,"iJMP		    ",0
      0  1095					      db	30,23,"iVINIT		    ",0
      1  1095		       1e 17 69 56*	      .byte.b	30,23,"iVINIT		    ",0
      0  10ac					      db	31,23,"iERRGOTO	    ",0
      1  10ac		       1f 17 69 45*	      .byte.b	31,23,"iERRGOTO	    ",0
      0  10c3					      db	32,23,"iTST		    ",0
      1  10c3		       20 17 69 54*	      .byte.b	32,23,"iTST		    ",0
      0  10da					      db	33,23,"iTSTV		    ",0
      1  10da		       21 17 69 54*	      .byte.b	33,23,"iTSTV		    ",0
      0  10f1					      db	34,23,"iTSTL		    ",0
      1  10f1		       22 17 69 54*	      .byte.b	34,23,"iTSTL		    ",0
      0  1108					      db	35,23,"iTSTN		    ",0
      1  1108		       23 17 69 54*	      .byte.b	35,23,"iTSTN		    ",0
      0  111f					      db	36,23,"iFREE		    ",0
      1  111f		       24 17 69 46*	      .byte.b	36,23,"iFREE		    ",0
      0  1136					      db	37,23,"iRANDOM 	    ",0
      1  1136		       25 17 69 52*	      .byte.b	37,23,"iRANDOM 	    ",0
      0  114d					      db	38,23,"iABS		    ",0
      1  114d		       26 17 69 41*	      .byte.b	38,23,"iABS		    ",0
      0  1164					      db	39,23,"iOPENREAD	    ",0
      1  1164		       27 17 69 4f*	      .byte.b	39,23,"iOPENREAD	    ",0
      0  117b					      db	40,23,"iOPENWRITE	    ",0
      1  117b		       28 17 69 4f*	      .byte.b	40,23,"iOPENWRITE	    ",0
      0  1192					      db	41,23,"iDCLOSE 	    ",0
      1  1192		       29 17 69 44*	      .byte.b	41,23,"iDCLOSE 	    ",0
      0  11a9					      db	42,23,"iDGETLINE	    ",0
      1  11a9		       2a 17 69 44*	      .byte.b	42,23,"iDGETLINE	    ",0
      0  11c0					      db	43,23,"iDLIST		    ",0
      1  11c0		       2b 17 69 44*	      .byte.b	43,23,"iDLIST		    ",0
      0  11d7					      db	44,23,"iDDIR		    ",0
      1  11d7		       2c 17 69 44*	      .byte.b	44,23,"iDDIR		    ",0
      0  11ee					      db	45,23,"iRMFILE 	    ",0
      1  11ee		       2d 17 69 52*	      .byte.b	45,23,"iRMFILE 	    ",0
      0  1205					      db	39,23,"NextIL		    ",0
      1  1205		       27 17 4e 65*	      .byte.b	39,23,"NextIL		    ",0
      0  121c					      db	40,23,"NextIL		    ",0
      1  121c		       28 17 4e 65*	      .byte.b	40,23,"NextIL		    ",0
      0  1233					      db	41,23,"NextIL		    ",0
      1  1233		       29 17 4e 65*	      .byte.b	41,23,"NextIL		    ",0
      0  124a					      db	42,23,"NextIL		    ",0
      1  124a		       2a 17 4e 65*	      .byte.b	42,23,"NextIL		    ",0
      0  1261					      db	43,23,"NextIL		    ",0
      1  1261		       2b 17 4e 65*	      .byte.b	43,23,"NextIL		    ",0
      0  1278					      db	44,23,"NextIL		    ",0
      1  1278		       2c 17 4e 65*	      .byte.b	44,23,"NextIL		    ",0
      0  128f					      db	45,23,"NextIL		    ",0
      1  128f		       2d 17 4e 65*	      .byte.b	45,23,"NextIL		    ",0
      0  12a6					      db	46,23,"iCLEARSCREEN	    ",0
      1  12a6		       2e 17 69 43*	      .byte.b	46,23,"iCLEARSCREEN	    ",0
      0  12bd					      db	47,23,"iPOKEMEMORY	    ",0
      1  12bd		       2f 17 69 50*	      .byte.b	47,23,"iPOKEMEMORY	    ",0
      0  12d4					      db	48,23,"iPEEKMEMORY	    ",0
      1  12d4		       30 17 69 50*	      .byte.b	48,23,"iPEEKMEMORY	    ",0
      0  12eb					      db	49,23,"iTSTLET 	    ",0
      1  12eb		       31 17 69 54*	      .byte.b	49,23,"iTSTLET 	    ",0
      0  1302					      db	50,23,"iTSTDONE	    ",0
      1  1302		       32 17 69 54*	      .byte.b	50,23,"iTSTDONE	    ",0
      0  1319					      db	51,23,"iGETCHAR	    ",0
      1  1319		       33 17 69 47*	      .byte.b	51,23,"iGETCHAR	    ",0
      0  1330					      db	52,23,"iPUTCHAR	    ",0
      1  1330		       34 17 69 50*	      .byte.b	52,23,"iPUTCHAR	    ",0
      0  1347					      db	53,23,"iCallFunc	    ",0
      1  1347		       35 17 69 43*	      .byte.b	53,23,"iCallFunc	    ",0
      0  135e					      db	54,23,"iBranch 	    ",0
      1  135e		       36 17 69 42*	      .byte.b	54,23,"iBranch 	    ",0
      0  1375					      db	55,23,"iTSTStr 	    ",0
      1  1375		       37 17 69 54*	      .byte.b	55,23,"iTSTStr 	    ",0
      0  138c					      db	56,23,"iSetIrq 	    ",0
      1  138c		       38 17 69 53*	      .byte.b	56,23,"iSetIrq 	    ",0
      0  13a3					      db	57,23,"iTstIrq 	    ",0
      1  13a3		       39 17 69 54*	      .byte.b	57,23,"iTstIrq 	    ",0
      0  13ba					      db	58,23,"iRET		    ",0
      1  13ba		       3a 17 69 52*	      .byte.b	58,23,"iRET		    ",0
      0  13d1					      db	59,23,"iINSTR		    ",0
      1  13d1		       3b 17 69 49*	      .byte.b	59,23,"iINSTR		    ",0
      0  13e8					      db	60,23,"iMOD		    ",0
      1  13e8		       3c 17 69 4d*	      .byte.b	60,23,"iMOD		    ",0
      0  13ff					      db	61,23,"iTaskSet	    ",0
      1  13ff		       3d 17 69 54*	      .byte.b	61,23,"iTaskSet	    ",0
      0  1416					      db	62,23,"iETask		    ",0
      1  1416		       3e 17 69 45*	      .byte.b	62,23,"iETask		    ",0
      0  142d					      db	63,23,"iNTask		    ",0
      1  142d		       3f 17 69 4e*	      .byte.b	63,23,"iNTask		    ",0
      0  1444					      db	64,23,"iArray		    ",0
      1  1444		       40 17 69 41*	      .byte.b	64,23,"iArray		    ",0
      0  145b					      db	65,23,"iTaskKill	    ",0
      1  145b		       41 17 69 54*	      .byte.b	65,23,"iTaskKill	    ",0
      0  1472					      db	66,23,"iTaskStat	    ",0
      1  1472		       42 17 69 54*	      .byte.b	66,23,"iTaskStat	    ",0
      0  1489					      db	67,23,"iHexOut 	    ",0
      1  1489		       43 17 69 48*	      .byte.b	67,23,"iHexOut 	    ",0
      0  14a0					      db	68,23,"iReadComplete	    ",0
      1  14a0		       44 17 69 52*	      .byte.b	68,23,"iReadComplete	    ",0
      0  14b7					      db	69,23,"iReadStart	    ",0
      1  14b7		       45 17 69 52*	      .byte.b	69,23,"iReadStart	    ",0
      0  14ce					      db	70,23,"iStartIO	    ",0
      1  14ce		       46 17 69 53*	      .byte.b	70,23,"iStartIO	    ",0
      0  14e5					      db	71,23,"iEndIO		    ",0
      1  14e5		       47 17 69 45*	      .byte.b	71,23,"iEndIO		    ",0
      0  14fc					      db	72,23,"iLogNot 	    ",0
      1  14fc		       48 17 69 4c*	      .byte.b	72,23,"iLogNot 	    ",0
      0  1513					      db	73,23,"iLogOr		    ",0
      1  1513		       49 17 69 4c*	      .byte.b	73,23,"iLogOr		    ",0
      0  152a					      db	74,23,"iLogAnd 	    ",0
      1  152a		       4a 17 69 4c*	      .byte.b	74,23,"iLogAnd 	    ",0
      0  1541					      db	75,23,"iLogXor 	    ",0
      1  1541		       4b 17 69 4c*	      .byte.b	75,23,"iLogXor 	    ",0
      0  1558					      db	76,23,"iWTASK		    ",0
      1  1558		       4c 17 69 57*	      .byte.b	76,23,"iWTASK		    ",0
      0  156f					      db	77,23,"iTASKPID	    ",0
      1  156f		       4d 17 69 54*	      .byte.b	77,23,"iTASKPID	    ",0
      0  1586					      db	78,23,"iTRACEPROG	    ",0
      1  1586		       4e 17 69 54*	      .byte.b	78,23,"iTRACEPROG	    ",0
      0  159d					      db	79,23,"idbgBasic	    ",0
      1  159d		       4f 17 69 64*	      .byte.b	79,23,"idbgBasic	    ",0
      0  15b4					      db	80,23,"iIPCS		    ",0
      1  15b4		       50 17 69 49*	      .byte.b	80,23,"iIPCS		    ",0
      0  15cb					      db	81,23,"iIPCR		    ",0
      1  15cb		       51 17 69 49*	      .byte.b	81,23,"iIPCR		    ",0
      0  15e2					      db	82,23,"iIPCC		    ",0
      1  15e2		       52 17 69 49*	      .byte.b	82,23,"iIPCC		    ",0
      0  15f9					      db	83,23,"iIPCIO		    ",0
      1  15f9		       53 17 69 49*	      .byte.b	83,23,"iIPCIO		    ",0
      0  1610					      db	84,23,"iPushMathStack	    ",0
      1  1610		       54 17 69 50*	      .byte.b	84,23,"iPushMathStack	    ",0
      0  1627					      db	85,23,"iPopMathStack	    ",0
      1  1627		       55 17 69 50*	      .byte.b	85,23,"iPopMathStack	    ",0
      0  163e					      db	86,23,"iSaveMathStack	    ",0
      1  163e		       56 17 69 53*	      .byte.b	86,23,"iSaveMathStack	    ",0
      0  1655					      db	87,23,"iRestoreMathStack   ",0
      1  1655		       57 17 69 52*	      .byte.b	87,23,"iRestoreMathStack   ",0
      0  166c					      db	88,23,"iIncParmCount	    ",0
      1  166c		       58 17 69 49*	      .byte.b	88,23,"iIncParmCount	    ",0
      0  1683					      db	89,23,"iTaskGetMathStack   ",0
      1  1683		       59 17 69 54*	      .byte.b	89,23,"iTaskGetMathStack   ",0
      0  169a					      db	90,23,"iTaskEnable	    ",0
      1  169a		       5a 17 69 54*	      .byte.b	90,23,"iTaskEnable	    ",0
      0  16b1					      db	91,23,"iTaskSuspend	    ",0
      1  16b1		       5b 17 69 54*	      .byte.b	91,23,"iTaskSuspend	    ",0
      0  16c8					      db	92,23,"iTaskPutMathPtr     ",0
      1  16c8		       5c 17 69 54*	      .byte.b	92,23,"iTaskPutMathPtr     ",0
      0  16df					      db	93,23,"iTSTVT		    ",0
      1  16df		       5d 17 69 54*	      .byte.b	93,23,"iTSTVT		    ",0
      0  16f6					      db	94,23,"iSetR2		    ",0
      1  16f6		       5e 17 69 53*	      .byte.b	94,23,"iSetR2		    ",0
      0  170d					      db	95,23,"iStk2Tmp	    ",0
      1  170d		       5f 17 69 53*	      .byte.b	95,23,"iStk2Tmp	    ",0
      0  1724					      db	96,23,"iTmp2Stk	    ",0
      1  1724		       60 17 69 54*	      .byte.b	96,23,"iTmp2Stk	    ",0
      0  173b					      db	97,23,"iTSTBYTE	    ",0
      1  173b		       61 17 69 54*	      .byte.b	97,23,"iTSTBYTE	    ",0
      0  1752					      db	98,23,"iINCVAR 	    ",0
      1  1752		       62 17 69 49*	      .byte.b	98,23,"iINCVAR 	    ",0
      0  1769					      db	99,23,"iDECVAR 	    ",0
      1  1769		       63 17 69 44*	      .byte.b	99,23,"iDECVAR 	    ",0
      0  1780					      db	100,23,"iSLICE 	     ",0
      1  1780		       64 17 69 53*	      .byte.b	100,23,"iSLICE 	     ",0
      0  1797					      db	101,23,"iTSTB		     ",0
      1  1797		       65 17 69 54*	      .byte.b	101,23,"iTSTB		     ",0
      0  17ae					      db	102,23,"iTSTW		     ",0
      1  17ae		       66 17 69 54*	      .byte.b	102,23,"iTSTW		     ",0
      0  17c5					      db	103,23,"iOnGoto	     ",0
      1  17c5		       67 17 69 4f*	      .byte.b	103,23,"iOnGoto	     ",0
      0  17dc					      db	104,23,"iTSTRELOP	     ",0
      1  17dc		       68 17 69 54*	      .byte.b	104,23,"iTSTRELOP	     ",0
      0  17f3					      db	105,23,"iRepeatLine	     ",0
      1  17f3		       69 17 69 52*	      .byte.b	105,23,"iRepeatLine	     ",0
      0  180a					      db	106,23,"iTSTBRANCH	     ",0
      1  180a		       6a 17 69 54*	      .byte.b	106,23,"iTSTBRANCH	     ",0
      0  1821					      db	107,23,"iFastXfer	     ",0
      1  1821		       6b 17 69 46*	      .byte.b	107,23,"iFastXfer	     ",0
      0  1838					      db	108,23,"iSetTerminal	     ",0
      1  1838		       6c 17 69 53*	      .byte.b	108,23,"iSetTerminal	     ",0
      0  184f					      db	109,23,"iINDB		     ",0
      1  184f		       6d 17 69 49*	      .byte.b	109,23,"iINDB		     ",0
      0  1866					      db	110,23,"iSetBlock	     ",0
      1  1866		       6e 17 69 53*	      .byte.b	110,23,"iSetBlock	     ",0
      0  187d					      db	111,23,"iCopyBlock	     ",0
      1  187d		       6f 17 69 43*	      .byte.b	111,23,"iCopyBlock	     ",0
      0  1894					      db	112,23,"iCmpBlock	     ",0
      1  1894		       70 17 69 43*	      .byte.b	112,23,"iCmpBlock	     ",0
      0  18ab					      db	113,23,"iShift 	     ",0
      1  18ab		       71 17 69 53*	      .byte.b	113,23,"iShift 	     ",0
      0  18c2					      db	$FF,23,"0		     ",0
      1  18c2		       ff 17 30 20*	      .byte.b	$FF,23,"0		     ",0
    126  18d9
    127  18d9							; Search for the il instruction and print the correct text for it
    128  18d9							; on entry a contains the ip instruction to print
    129  18d9
    130 U3550					      seg.u	TBData
    131 U3550		       00 00	   R0TempIL   ds	2
    132 U3552		       00	   ILSTA      ds	1
    133 U3553
    134  18d9					      Seg	Code
    135  18d9
    136  18d9		       8d 52 35    PrintILText sta	ILSTA
    137  18dc		       98		      tya
    138  18dd		       48		      pha
    139  18de		       8a		      txa
    140  18df		       48		      pha
    141  18e0		       a5 52		      lda	R0
    142  18e2		       8d 50 35 	      sta	R0TempIL
    143  18e5		       a5 53		      lda	R0+1
    144  18e7		       8d 50 35 	      sta	R0TempIL
    145  18ea		       a9 e3		      lda	#ILTEXTTABLE&$FF
    146  18ec		       85 52		      sta	R0
    147  18ee		       a9 0d		      LDA	#ILTEXTTABLE>>8
    148  18f0		       85 53		      sta	R0+1
    149  18f2							;Loop Here for each entry
    150  18f2		       a0 00	   PrintILLoop ldy	#0
    151  18f4		       b1 52		      lda	(R0),y
    152  18f6		       c9 ff		      cmp	#$FF
    153  18f8		       f0 2a		      beq	PrintILNotFound
    154  18fa		       cd 52 35 	      cmp	ILSTA
    155  18fd		       f0 11		      beq	PrintILFound
    156  18ff		       c8		      iny
    157  1900		       b1 52		      lda	(R0),y
    158  1902		       18		      clc
    159  1903		       65 52		      adc	R0
    160  1905		       85 52		      sta	R0
    161  1907		       a9 00		      lda	#0
    162  1909		       65 53		      adc	R0+1
    163  190b		       85 53		      sta	R0+1
    164  190d		       4c f2 18 	      jmp	PrintILLoop
    165  1910							; The text was discovered
    166  1910		       c8	   PrintILFound iny		; point to length of instruction
    167  1911		       c8		      iny		; Point to start of text
    168  1912		       98		      tya
    169  1913		       18		      clc
    170  1914		       65 52		      adc	R0
    171  1916		       a8		      tay		; Low order byte of address
    172  1917		       a9 00		      lda	#0
    173  1919		       65 53		      adc	R0+1
    174  191b		       aa		      tax		; High order byte of address
    175  191c		       a9 00		      lda	#0	; Termination byte of string
    176  191e		       20 36 21 	      jsr	PrtStr	; print the string
    177  1921		       4c 2a 19 	      jmp	PrintILDone
    178  1924
    179  1924		       ad 52 35    PrintILNotFound lda	ILSTA
    180  1927		       20 db 20 	      jsr	HexToOut
    181  192a
    182  192a		       ad 50 35    PrintILDone lda	R0TempIL
    183  192d		       85 52		      sta	R0
    184  192f		       ad 51 35 	      lda	R0TempIL+1
    185  1932		       85 52		      sta	R0
    186  1934		       68		      pla
    187  1935		       aa		      tax
    188  1936		       68		      pla
    189  1937		       a8		      tay
    190  1938		       60		      rts
    191  1939					      endif
------- FILE mytb.asm
   2462  1939					      endif
------- FILE io.asm LEVEL 2 PASS 6
      0  1939					      include	"io.asm"
      1  1939							; This is the io blocks and function for reading and writing
      2  1939							; to devices attached to this computer.
      3  1939							; This supports devices mapped at e000 thru efff in slot sizes of 16 byte
      4  1939							;
      5  1939							;=====================================================================
      6  1939							; Device configuration equates
      7  1939		       00 00	   ConsoleID  equ	0
      8  1939		       00 08	   SerialID   equ	[1<<3]
      9  1939		       00 10	   ClockID    equ	[2<<3]
     10  1939		       00 18	   TimerID    equ	[3<<3]
     11  1939		       00 20	   DiskID     equ	[4<<3]
     12  1939
     13  1939		       00 0a	   IO_MAX_DEVICES equ	10
     14  1939		       00 06	   IO_VECT_LEN equ	6
     15  1939
     16  1939		       00 01	   IO_DEVICE_CLOSED equ	1	; The device is not open
     17  1939		       00 02	   IO_DEVICE_INVALID equ	2	; The Device number provided is invalid
     18  1939
     19  1939							;========================================================================================
     20  1939							; Uninitialized data segment
     21 U3553					      seg.u	TBData
     22 U3553
     23 U3553		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
     24 U3555		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
     25 U3557		       00 00	   BStatVec   ds	2	; This is used by inteface to read write status/config information
      0 U3559				   BActiveDevice db	1	; the index of the current device block
      1 U3559		       01		      .byte.b	1
      0 U355a				   BActiveDriver db	1	; Index of the device drive block
      1 U355a		       01		      .byte.b	1
     28 U355b
     29 U355b							;============================================================================================
     30  1939					      Seg	Code
     31  1939							; IRQ BASIC Code Service RTN Support
      0  1939				   SaveIrqReg db	0	; Store current setting
      1  1939		       00		      .byte.b	0
      0  193a				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1  193a		       00		      .byte.b	0
      0  193b				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1  193b		       00		      .byte.b	0
      0  193c				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1  193c		       00 00		      .byte.b	0,0
     36  193e
     37  193e							;============================================================================================
     38  193e							; Define the device interface blocks
     39  193e				   DeviceDriverBlocks
     40  193e				   ConsoleDevice		; Block 0
      0  193e					      dw	ConsoleID	; device idenifier Console
      1  193e		       00 00		      .word.w	ConsoleID
      0  1940					      dw	cin	; read function vector
      1  1940		       09 f0		      .word.w	cin
      0  1942					      dw	cout	; write function vector
      1  1942		       0c f0		      .word.w	cout
      0  1944					      dw	cstatus	; Get current Status info/Write config
      1  1944		       0f f0		      .word.w	cstatus
     45  1946
     46  1946				   SerialDevice 		; Block 1
      0  1946					      dw	SerialID	; device idenifier Serial
      1  1946		       08 00		      .word.w	SerialID
      0  1948					      dw	SerialIn	; read function vector
      1  1948		       24 1a		      .word.w	SerialIn
      0  194a					      dw	SerialOut	; write function vector
      1  194a		       24 1a		      .word.w	SerialOut
      0  194c					      dw	SerialStatus	; Get current Status info/Write config
      1  194c		       24 1a		      .word.w	SerialStatus
     51  194e
     52  194e				   ClockDevice		; Block 2
      0  194e					      dw	ClockID	; Day/date Clock
      1  194e		       10 00		      .word.w	ClockID
      0  1950					      dw	ClockRead	; Read the date from clock
      1  1950		       24 1a		      .word.w	ClockRead
      0  1952					      dw	ClockWrite	; Set the date/time of clock
      1  1952		       24 1a		      .word.w	ClockWrite
      0  1954					      dw	#0	; No Status/Config Function
      1  1954		       00 00		      .word.w	#0
     57  1956
     58  1956				   TimerDevice		; Block 3
      0  1956					      dw	TimerID	; Timer/interrupt interface
      1  1956		       18 00		      .word.w	TimerID
      0  1958					      dw	TimerStart	; Start the timer
      1  1958		       24 1a		      .word.w	TimerStart
      0  195a					      dw	TimerStop	; Stop the timer
      1  195a		       24 1a		      .word.w	TimerStop
      0  195c					      dw	TimerStatus	; Config/read status
      1  195c		       24 1a		      .word.w	TimerStatus
     63  195e
      0  195e				   DiskDevice dw	DiskID	; Block 4
      1  195e		       20 00		      .word.w	DiskID
      0  1960					      dw	DIN	; Disk Input / read function
      1  1960		       63 30		      .word.w	DIN
      0  1962					      dw	DOUT	; Disk Output / write function
      1  1962		       4a 30		      .word.w	DOUT
      0  1964					      dw	DSTAT	; Disk Status/open/close etc information
      1  1964		       7c 30		      .word.w	DSTAT
     68  1966							;
     69  1966							;======================================================================
     70  1966							; Define the Device/Slot,driver control blocks
     71  1966							; entry format: ControlWord,DeviceDriver,PortAddress,StatusWord
     72  1966							; Fixed at 10 devices memory usage is getting pretty big!!!!!!
     73  1966							; Control word : bit 0 = active 1, Free 0
     74  1966
     75  1966				   DeviceIoBlocks
      0  1966					      dw	1, ConsoleID, $E000, 0	; Console device is 0 file
      1  1966		       01 00 00 00*	      .word.w	1, ConsoleID, $E000, 0
      0  196e					      dw	1, ClockID, $E010, 0	; Port for the day/time clock
      1  196e		       01 00 10 00*	      .word.w	1, ClockID, $E010, 0
      0  1976					      dw	1, TimerID, $E010, 0	; Timer interface
      1  1976		       01 00 18 00*	      .word.w	1, TimerID, $E010, 0
      0  197e					      dw	1, DiskID, $E010, 0	; Disk Driver interface
      1  197e		       01 00 20 00*	      .word.w	1, DiskID, $E010, 0
      0  1986					      dw	1, SerialID, $E020, 0	; Second terminal(default Basic debug)
      1  1986		       01 00 08 00*	      .word.w	1, SerialID, $E020, 0
      0  198e					      dw	0, SerialID, $E030, 0	; Unused slot
      1  198e		       00 00 08 00*	      .word.w	0, SerialID, $E030, 0
      0  1996					      dw	0, SerialID, $E040, 0	; Unused slot
      1  1996		       00 00 08 00*	      .word.w	0, SerialID, $E040, 0
      0  199e					      dw	0, SerialID, $E050, 0	; Unused slot
      1  199e		       00 00 08 00*	      .word.w	0, SerialID, $E050, 0
      0  19a6					      dw	0, SerialID, $E060, 0	; Unused slot
      1  19a6		       00 00 08 00*	      .word.w	0, SerialID, $E060, 0
      0  19ae					      dw	0, SerialID, $E070, 0	; Unused slot
      1  19ae		       00 00 08 00*	      .word.w	0, SerialID, $E070, 0
     86  19b6							;
     87  19b6							;======================================================================
     88  19b6							;
     89  19b6					      Seg	Code
     90  19b6							;======================================================================
     91  19b6							; This is the Basic IRQ handler, works with task manager
     92  19b6							;
     93  19b6		       48	   ServiceIrq pha
     94  19b7		       ad 3a 19 	      lda	IRQStatus
     95  19ba		       f0 0a		      BEQ	RetIrq
     96  19bc		       ad 3b 19 	      lda	IRQPending
     97  19bf		       d0 05		      bne	RetIrq
     98  19c1		       a9 01		      lda	#1
     99  19c3		       8d 3b 19 	      sta	IRQPending
    100  19c6		       68	   RetIrq     pla
    101  19c7		       40		      rti
    102  19c8							;======================================================================
    103  19c8							; Jump to the output/input function in BOutVec/BInVec
    104  19c8							;
    105  19c8		       6c 55 35    VOUTCH     jmp	(BOutVec)	; Primary block io vectors
    106  19cb		       6c 53 35    VGETCH     jmp	(BInVec)
    107  19ce		       6c 57 35    VSTAT      jmp	(BStatVec)
    108  19d1							;
    109  19d1							;======================================================================
    110  19d1							; IO Service functions
    111  19d1							; Validate the device index and set x to offest in table
    112  19d1							; does not return to ioInterface if invalid, returns to original caller
    113  19d1							; should be called immediatly after entering the ioInterface call
    114  19d1				   ioValidateDevice
    115  19d1		       e0 0a		      cpx	#IO_MAX_DEVICES
    116  19d3		       90 04		      bcc	ioValidIndex
    117  19d5		       a2 02		      ldx	#IO_DEVICE_INVALID
    118  19d7		       b0 13		      bcs	ioInvalidDevice
    119  19d9				   ioValidIndex
    120  19d9		       8a		      txa
    121  19da		       0a		      asl		; Multiply by 8
    122  19db		       0a		      asl
    123  19dc		       0a		      asl
    124  19dd		       aa		      tax		; Point to actual offset in the table
    125  19de		       ec 59 35 	      cpx	BActiveDevice	; is it already active ?
    126  19e1		       f0 0d		      beq	ioValidDevice	; Shortcut if this is the active device already
    127  19e3		       a9 01		      lda	#1	; Active flag
    128  19e5		       3d 66 19 	      and	DeviceIoBlocks,x	; Check if the device is active
    129  19e8		       d0 06		      bne	ioValidDevice	; The device is active and valid index
    130  19ea		       a2 01		      ldx	#IO_DEVICE_CLOSED
    131  19ec
    132  19ec				   ioInvalidDevice
    133  19ec		       68		      pla		; Remove return address of IO interface
    134  19ed		       68		      pla
    135  19ee		       38		      sec		; ensure that carry is set
    136  19ef		       60		      rts
    137  19f0
    138  19f0				   ioValidDevice
    139  19f0		       18		      clc
    140  19f1		       60		      rts
    141  19f2							;
    142  19f2							;===================================================================================
    143  19f2							; Set the io device jmp vectors
    144  19f2							; input x contains the vector to the active Device IO Block
    145  19f2							; output a, x undefined y unchanged
    146  19f2				   ioSetDeviceVectors
    147  19f2		       ec 59 35 	      cpx	BActiveDevice	; Check if already set
    148  19f5		       f0 1b		      beq	ioSetDevExit	; if already set then do nothing
    149  19f7
    150  19f7		       8e 59 35 	      stx	BActiveDevice	; set the active device vector
    151  19fa		       98		      tya
    152  19fb		       48		      pha
    153  19fc
    154  19fc		       bc 68 19 	      ldy	DeviceIoBlocks+2,x	; Get the device driver index
    155  19ff		       8c 5a 35 	      sty	BActiveDriver	; Pointer to active Device driver
    156  1a02		       a2 00		      ldx	#0	; Transfer the 6 pointers to the Vectors
    157  1a04				   ioSetDevLoop
    158  1a04		       b9 40 19 	      lda	DeviceDriverBlocks+2,y
    159  1a07		       9d 53 35 	      sta	BInVec,x
    160  1a0a		       e8		      inx
    161  1a0b		       c8		      iny
    162  1a0c		       e0 06		      cpx	#IO_VECT_LEN	; Transfer the vector length to copy
    163  1a0e		       d0 f4		      bne	ioSetDevLoop
    164  1a10
    165  1a10		       68		      pla
    166  1a11		       a8		      tay
    167  1a12				   ioSetDevExit
    168  1a12		       60		      rts
    169  1a13							;
    170  1a13							;======================================================================
    171  1a13							; Generic call interface for devices
    172  1a13							; input x = DeviceIoBlockIndex
    173  1a13							; Carry set if error, x contains the error code
    174  1a13							; all other parameters are dependant upon the actual device interface
    175  1a13							;
    176  1a13							; ioPutCH  a contains the character to send
    177  1a13		       20 d1 19    ioPutCH    jsr	ioValidateDevice
    178  1a16		       48		      pha
    179  1a17		       20 f2 19 	      jsr	ioSetDeviceVectors
    180  1a1a		       68		      pla
    181  1a1b		       20 c8 19 	      jsr	VOUTCH
    182  1a1e		       18		      clc
    183  1a1f		       60		      rts
    184  1a20
    185  1a20							; io Getch returns the character read from device
    186  1a20		       20 d1 19    ioGetCH    jsr	ioValidateDevice
    187  1a23
    188  1a23		       60		      rts
    189  1a24							;
    190  1a24							;======================================================================
    191  1a24							;TTY interface functions,
    192  1a24							;	a contains the character to send
    193  1a24							;	x contains the Device ID (equals index into io blocks)	of the io block to used
    194  1a24							;
    195  1a24				   SerialIn
    196  1a24
    197  1a24				   SerialOut
    198  1a24
    199  1a24				   SerialStatus
    200  1a24
    201  1a24							;
    202  1a24							;======================================================================
    203  1a24							; Date/Time clock interface
    204  1a24				   ClockRead
    205  1a24
    206  1a24				   ClockWrite
    207  1a24
    208  1a24							;
    209  1a24							;======================================================================
    210  1a24							;
    211  1a24				   TimerStart
    212  1a24
    213  1a24				   TimerStop
    214  1a24
    215  1a24				   TimerStatus
    216  1a24
    217  1a24
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  1a24					      include	"tokenizer.asm"
      1  1a24					      seg	Code
      2  1a24		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  1a24
      4  1a24							; Define the types of tokens found, and identifiers
      5  1a24		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  1a24		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  1a24		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  1a24		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  1a24
     10  1a24		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  1a24		       00 9c	   tVhash     equ	$9C	; Variable #
     12  1a24		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  1a24
     14  1a24							; Base variable type supported by This basic
     15  1a24							; Unsigned types always have the 0 bit set to 1
     16  1a24		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     17  1a24		       00 a2	   tByte      equ	$A2	; Signed Byte value
     18  1a24		       00 a4	   tInteger   equ	$A4	; all tokenized integers start with 251 as first byte 16 bit signed number
     19  1a24		       00 a6	   tLong      equ	$A6	; Signed 32 bit integer
     20  1a24
     21  1a24		       00 a1	   tArray     equ	$A1	; Identifies Array Type, the byte following defines the length of each element
     22  1a24							; Arrays of string are arrays of pointers 2 bytes each
     23  1a24		       00 a3	   tPointer   equ	$A3	; Pointer  unsigned 16 bit
     24  1a24		       00 a5	   tIndirect  equ	$A5	; Points to an address that points to the data 16 bits
     25  1a24		       00 a7	   tuByte     equ	$A7	; Unsigned byte value 8 bit unsigned value
     26  1a24		       00 a9	   tUint      equ	$A9	; unsigned integer type 16 bit
     27  1a24		       00 ab	   tUlong     equ	$AB	; Unsigned 32 bit integer
     28  1a24
     29  1a24		       3c 3e	   Operators  BYTE.b	"<>"
     30  1a26		       3c 3d		      BYTE.b	"<="
     31  1a28		       3e 3d		      BYTE.b	">="
     32  1a2a		       3c 00		      BYTE.b	"<",0
     33  1a2c		       3d 00		      BYTE.b	"=",0
     34  1a2e		       3e 00		      BYTE.b	">",0
     35  1a30		       2b 00		      BYTE.b	"+",0
     36  1a32		       2d 00		      BYTE.b	"-",0
     37  1a34		       2f 00		      BYTE.b	"/",0
     38  1a36		       25 00		      BYTE.b	"%",0
     39  1a38		       2a 00		      BYTE.b	"*",0
     40  1a3a		       28 00		      BYTE.b	"(",0
     41  1a3c		       29 00		      BYTE.b	")",0
     42  1a3e		       2c 00		      BYTE.b	",",0
     43  1a40		       3b 00		      BYTE.b	";",0
     44  1a42		       5b 00		      BYTE.b	"[",0
     45  1a44		       5d 00		      BYTE.b	"]",0
     46  1a46		       3a 00		      BYTE.b	":",0
     47  1a48		       24 00		      BYTE.b	"$",0
     48  1a4a		       21 00		      BYTE.b	"!",0
     49  1a4c		       3f 00		      BYTE.b	"?",0
     50  1a4e		       2e 00		      BYTE.b	".",0
     51  1a50		       00 00		      BYTE.b	0,0
     52  1a52
     53  1a52		       f5 f3 f6 f1*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oLess,oEqual,oGreater
     54  1a58		       ea eb ec ed*	      BYTE.b	oPlus, oMinus, oDivide, oModulo, oMultiply
     55  1a5d		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     56  1a63		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod
     57  1a68
     58  1a68		       00 0b	   oQuestion  equ	kPrint
     59  1a68							;    2 is =
     60  1a68							;    1 is <
     61  1a68							;    3 is <=
     62  1a68							;    5 is <>
     63  1a68							;    4 is >
     64  1a68							;    6 is >=
     65  1a68		       00 f1	   oLess      equ	$F1
     66  1a68		       00 f2	   oEqual     equ	$F2
     67  1a68		       00 f3	   oLessEqual equ	$F3
     68  1a68		       00 f4	   oGreater   equ	$F4
     69  1a68		       00 f5	   oNotEqual  equ	$F5
     70  1a68		       00 f6	   oGreaterEqual equ	$F6
     71  1a68
     72  1a68		       00 e0	   oLeftBracket equ	$E0
     73  1a68		       00 e1	   oRightBracket equ	$E1
     74  1a68		       00 e2	   oComma     equ	$E2
     75  1a68		       00 e3	   oSemiColon equ	$E3
     76  1a68		       00 e4	   oLeftSQBracket equ	$E4
     77  1a68		       00 e5	   oRightSQBracket equ	$E5
     78  1a68		       00 e6	   oColon     equ	$E6
     79  1a68		       00 e7	   oDollar    equ	$E7
     80  1a68		       00 e8	   oBang      equ	$E8
     81  1a68		       00 e9	   oPeriod    equ	$E9
     82  1a68
     83  1a68
     84  1a68		       00 ea	   oPlus      equ	$EA
     85  1a68		       00 eb	   oMinus     equ	$EB
     86  1a68		       00 ec	   oDivide    equ	$EC
     87  1a68		       00 ed	   oModulo    equ	$ED
     88  1a68		       00 ee	   oMultiply  equ	$EE
     89  1a68
     90  1a68		       00 ed	   oPercent   equ	oModulo
     91  1a68
     92  1a68		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     93  1a68
     94  1a68		       00 ff	   tError     equ	$FF	; Error should never happen
     95  1a68							;============================================================================================
     96  1a68							; Keyword and seperator values
     97  1a68				   '
     98  1a68		       00 01	   kBeginKey  equ	kLet
     99  1a68							;
    100  1a68		       00 01	   kLet       equ	1
    101  1a68		       00 02	   kInc       equ	kLet+1
    102  1a68		       00 03	   kDec       equ	kInc+1
    103  1a68		       00 04	   kIreturn   equ	kDec+1
    104  1a68		       00 05	   kIf	      equ	kIreturn+1
    105  1a68		       00 06	   kThen      equ	kIf+1
    106  1a68		       00 07	   kGoto      equ	kThen+1
    107  1a68		       00 08	   kGosub     equ	kGoto+1
    108  1a68		       00 09	   kReturn    equ	kGosub+1
    109  1a68		       00 0a	   kRem       equ	kReturn+1
    110  1a68		       00 0b	   kPrint     equ	kRem+1
    111  1a68		       00 0c	   kTaske     equ	kPrint+1
    112  1a68		       00 0d	   kTaskn     equ	kTaske+1
    113  1a68		       00 0e	   kTaskw     equ	kTaskn+1
    114  1a68		       00 0f	   kPoke      equ	kTaskw+1
    115  1a68		       00 10	   kPutch     equ	kPoke+1
    116  1a68		       00 11	   kCls       equ	kPutch+1
    117  1a68		       00 12	   kInput     equ	kCls+1
    118  1a68		       00 13	   kEnd       equ	kInput+1
    119  1a68		       00 14	   kIrq       equ	kEnd+1
    120  1a68		       00 15	   kKill      equ	kIrq+1
    121  1a68		       00 16	   kList      equ	kKill+1
    122  1a68		       00 17	   kRun       equ	kList+1
    123  1a68		       00 18	   kNew       equ	kRun+1
    124  1a68		       00 19	   kSlice     equ	kNew+1
    125  1a68		       00 1a	   kTrace     equ	kSlice+1
    126  1a68		       00 1b	   kExit      equ	kTrace+1
    127  1a68		       00 1c	   kSave      equ	kExit+1
    128  1a68		       00 1d	   kLoad      equ	kSave+1
    129  1a68		       00 1e	   kErase     equ	kLoad+1
    130  1a68		       00 1f	   kDir       equ	kErase+1
    131  1a68		       00 20	   kSetTerm   equ	kDir+1
    132  1a68		       00 21	   kSetMemB   equ	kSetTerm+1
    133  1a68		       00 22	   kSetMemW   equ	kSetMemB+1
    134  1a68		       00 23	   kCopyMem   equ	kSetMemW+1
    135  1a68							;
    136  1a68							; End of actual key words
    137  1a68							;
    138  1a68		       00 22	   kKeyCount  equ	kCopyMem-kBeginKey
    139  1a68							;
    140  1a68							; Logical operators
    141  1a68							;
    142  1a68		       00 24	   kNot       equ	kCopyMem+1
    143  1a68		       00 25	   kOr	      equ	kNot+1
    144  1a68		       00 26	   kXor       equ	kOr+1
    145  1a68		       00 27	   kAnd       equ	kXor+1
    146  1a68							;
    147  1a68							; Shift operators
    148  1a68							;
    149  1a68		       00 28	   kShr       equ	kAnd+1
    150  1a68		       00 29	   kShl       equ	kShr+1
    151  1a68
    152  1a68							; numeric functions
    153  1a68							;
    154  1a68		       00 2a	   kBeginFunc equ	kTrue
    155  1a68							;
    156  1a68							; Truth operators
    157  1a68							;
    158  1a68		       00 2a	   kTrue      equ	kShl+1
    159  1a68		       00 2b	   kFalse     equ	kTrue+1
    160  1a68							; Functions
    161  1a68		       00 2c	   kFree      equ	kFalse+1
    162  1a68		       00 2d	   kGetch     equ	kFree+1
    163  1a68		       00 2e	   kPeek      equ	kGetch+1
    164  1a68		       00 2f	   kTask      equ	kPeek+1
    165  1a68		       00 30	   kIpcc      equ	kTask+1
    166  1a68		       00 31	   kIpcs      equ	kIpcc+1
    167  1a68		       00 32	   kIpcr      equ	kIpcs+1
    168  1a68		       00 33	   kRnd       equ	kIpcr+1
    169  1a68		       00 34	   kStat      equ	kRnd+1
    170  1a68		       00 35	   kAbs       equ	kStat+1
    171  1a68		       00 36	   kCall      equ	kAbs+1
    172  1a68		       00 37	   kGofn      equ	kCall+1
    173  1a68		       00 38	   kPid       equ	kGofn+1
    174  1a68		       00 39	   kAddr      equ	kPid+1
    175  1a68		       00 3a	   kCmpMem    equ	kAddr+1
    176  1a68							;
    177  1a68		       00 11	   kFuncCount equ	((kCmpMem - kBeginFunc) + 1)
    178  1a68
    179  1a68							;
    180  1a68							; Keyword table contains 54 keywords
    181  1a68				   KeyWordTable
      0  1a68					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  1a68		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  1a6c					      db	kInc,"inC"
      1  1a6c		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  1a70					      db	kDec,"deC"
      1  1a70		       03 64 65 43	      .byte.b	kDec,"deC"
      0  1a74					      db	kIreturn,"ireturN"
      1  1a74		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  1a7c					      db	kIf,"iF"
      1  1a7c		       05 69 46 	      .byte.b	kIf,"iF"
      0  1a7f					      db	kThen,"theN"
      1  1a7f		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  1a84					      db	kGoto,"gotO"
      1  1a84		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  1a89					      db	kGosub,"gosuB"
      1  1a89		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  1a8f					      db	kReturn,"returN"
      1  1a8f		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  1a96					      db	kRem,"reM"
      1  1a96		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  1a9a					      db	kPrint,"prinT"
      1  1a9a		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  1aa0					      db	kTaske,"taskE"
      1  1aa0		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  1aa6					      db	kTaskn,"taskN"
      1  1aa6		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  1aac					      db	kTaskw,"taskW"
      1  1aac		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  1ab2					      db	kPoke,"pokE"
      1  1ab2		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  1ab7					      db	kPutch,"putcH"
      1  1ab7		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  1abd					      db	kCls,"clS"
      1  1abd		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  1ac1					      db	kInput,"inpuT"
      1  1ac1		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  1ac7					      db	kEnd,"enD"
      1  1ac7		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  1acb					      db	kIrq,"irQ"
      1  1acb		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  1acf					      db	kKill,"kilL"
      1  1acf		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  1ad4					      db	kList,"lisT"
      1  1ad4		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  1ad9					      db	kRun,"ruN"
      1  1ad9		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  1add					      db	kNew,"neW"
      1  1add		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  1ae1					      db	kSlice,"slicE"
      1  1ae1		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  1ae7					      db	kTrace,"tracE"
      1  1ae7		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  1aed					      db	kExit,"exiT"
      1  1aed		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  1af2					      db	kSave,"savE"
      1  1af2		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  1af7					      db	kLoad,"loaD"
      1  1af7		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  1afc					      db	kErase,"erasE"
      1  1afc		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  1b02					      db	kDir,"diR"
      1  1b02		       1f 64 69 52	      .byte.b	kDir,"diR"
    213  1b06							;Short form for statements:
      0  1b06					      db	kIreturn,"ireT"
      1  1b06		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  1b0b					      db	kReturn,"reT"
      1  1b0b		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  1b0f					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  1b0f		       0b 70 52 	      .byte.b	kPrint,"pR"
      0  1b12					      db	kSetTerm, "setterM"
      1  1b12		       20 73 65 74*	      .byte.b	kSetTerm, "setterM"
      0  1b1a					      db	kSetMemB, "setmemB"
      1  1b1a		       21 73 65 74*	      .byte.b	kSetMemB, "setmemB"
      0  1b22					      db	kSetMemW, "setmemW"
      1  1b22		       22 73 65 74*	      .byte.b	kSetMemW, "setmemW"
      0  1b2a					      db	kCopyMem, "copymeM"
      1  1b2a		       23 63 6f 70*	      .byte.b	kCopyMem, "copymeM"
    221  1b32
    222  1b32							; Shift operators
      0  1b32					      db	kShr,"shR"
      1  1b32		       28 73 68 52	      .byte.b	kShr,"shR"
      0  1b36					      db	kShl,"shL"
      1  1b36		       29 73 68 4c	      .byte.b	kShl,"shL"
    225  1b3a
    226  1b3a							;Logical and truth operators
      0  1b3a					      db	kNot,"noT"
      1  1b3a		       24 6e 6f 54	      .byte.b	kNot,"noT"
      0  1b3e					      db	kOr,"oR"
      1  1b3e		       25 6f 52 	      .byte.b	kOr,"oR"
      0  1b41					      db	kXor,"xoR"
      1  1b41		       26 78 6f 52	      .byte.b	kXor,"xoR"
      0  1b45					      db	kAnd,"anD"
      1  1b45		       27 61 6e 44	      .byte.b	kAnd,"anD"
    231  1b49
    232  1b49							; Truth values
      0  1b49					      db	kTrue,"truE"
      1  1b49		       2a 74 72 75*	      .byte.b	kTrue,"truE"
      0  1b4e					      db	kFalse,"falsE"
      1  1b4e		       2b 66 61 6c*	      .byte.b	kFalse,"falsE"
    235  1b54
    236  1b54
    237  1b54
    238  1b54							;functions returning values
    239  1b54
      0  1b54					      db	kFree,"freE"
      1  1b54		       2c 66 72 65*	      .byte.b	kFree,"freE"
      0  1b59					      db	kGetch,"getcH"
      1  1b59		       2d 67 65 74*	      .byte.b	kGetch,"getcH"
      0  1b5f					      db	kPeek,"peeK"
      1  1b5f		       2e 70 65 65*	      .byte.b	kPeek,"peeK"
      0  1b64					      db	kTask,"tasK"
      1  1b64		       2f 74 61 73*	      .byte.b	kTask,"tasK"
      0  1b69					      db	kIpcc,"ipcC"
      1  1b69		       30 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  1b6e					      db	kIpcs,"ipcS"
      1  1b6e		       31 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  1b73					      db	kIpcr,"ipcR"
      1  1b73		       32 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  1b78					      db	kRnd,"rnD"
      1  1b78		       33 72 6e 44	      .byte.b	kRnd,"rnD"
      0  1b7c					      db	kStat,"staT"
      1  1b7c		       34 73 74 61*	      .byte.b	kStat,"staT"
      0  1b81					      db	kAbs,"abS"
      1  1b81		       35 61 62 53	      .byte.b	kAbs,"abS"
      0  1b85					      db	kCall,"calL"
      1  1b85		       36 63 61 6c*	      .byte.b	kCall,"calL"
      0  1b8a					      db	kGofn,"fN"
      1  1b8a		       37 66 4e 	      .byte.b	kGofn,"fN"
      0  1b8d					      db	kPid,"piD"
      1  1b8d		       38 70 69 44	      .byte.b	kPid,"piD"
      0  1b91					      db	kAddr,"addR"
      1  1b91		       39 61 64 64*	      .byte.b	kAddr,"addR"
      0  1b96					      db	kCmpMem, "cmpmeM"
      1  1b96		       3a 63 6d 70*	      .byte.b	kCmpMem, "cmpmeM"
      0  1b9d					      db	0,0
      1  1b9d		       00 00		      .byte.b	0,0
    256  1b9f
    257  1b9f		       1b 9f	   KeyWordTableEnd equ	*
    258  1b9f		       01 37	   KeyWordTableLength equ	* - KeyWordTable
    259  1b9f		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    260  1c9f		       00 00 00    printStorage ds	3
    261  1ca2							;==================================================================================================================
    262  1ca2							; Read accross the inputline and output to TOKENBUFFER
    263  1ca2							; Format   byte      Description
    264  1ca2							;	     0	      length of line 1-255
    265  1ca2							;	    0-1       Line Number
    266  1ca2							;	    Tokens and litteral values encoded into the line
    267  1ca2							;
    268  1ca2							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    269  1ca2							;  if fails then test for keywords
    270  1ca2							;  if fails then test for variables and arrays
    271  1ca2							;  if fails check for operators/seperators  + - < > = % / * () [] , ; : >> <<
    272  1ca2
    273  1ca2				   ParseInputLine
    274  1ca2				  -	      if	DEBUGPARSER
    275  1ca2				  -	      jsr	SetOutDebug
    276  1ca2				  -	      jsr	DebugClearBuffer
    277  1ca2					      endif
    278  1ca2		       a5 51		      lda	CUROFF
    279  1ca4		       48		      pha
    280  1ca5		       8a		      txa
    281  1ca6		       48		      pha
    282  1ca7		       98		      tya
    283  1ca8		       48		      pha
    284  1ca9		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    285  1cab		       20 eb 29 	      jsr	getDecimal	; Check for a line number, none is ok too
    286  1cae		       84 51		      sty	CUROFF
    287  1cb0		       20 6e 1e 	      jsr	R02TOKEN	; Move R0 to token buffer
    288  1cb3
    289  1cb3				   ParseInputLoop
    290  1cb3		       a4 51		      ldy	CUROFF
    291  1cb5		       20 7b 2c 	      jsr	SkipSpaces	; Skip any spaces
    292  1cb8		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    293  1cba		       b9 7f 41 	      lda	LINBUF,y	; Check for end of line
    294  1cbd		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    295  1cbf
    296  1cbf				   ParseForNumber
    297  1cbf		       20 c2 1d 	      jsr	ParseNumeric	; Check for a numeric value
    298  1cc2		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    299  1cc4
    300  1cc4				   ParseForString
    301  1cc4		       20 98 1d 	      jsr	ParseString	; Check for a string
    302  1cc7		       90 ea		      bcc	ParseInputLoop	; It was a string
    303  1cc9
    304  1cc9				   ParseForOp
    305  1cc9		       20 00 1e 	      jsr	ParseForOperator	; Check for operator or punctuation
    306  1ccc		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    307  1cce
    308  1cce				   ParseForKey
    309  1cce		       20 f5 1c 	      jsr	ParseLookupKey	; Check for a keyword value
    310  1cd1		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    311  1cd3
    312  1cd3				   ParseForVar
    313  1cd3		       20 37 1e 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    314  1cd6		       90 db		      bcc	ParseInputLoop
    315  1cd8
    316  1cd8				   ParseKeepChar		; if it does not parse just keep it safe
    317  1cd8		       b9 7f 41 	      lda	LINBUF,y
    318  1cdb		       9d 9f 1b 	      sta	TOKENBUFFER,x
    319  1cde		       e8		      inx
    320  1cdf		       c8		      iny
    321  1ce0		       84 51		      sty	CUROFF
    322  1ce2		       d0 cf		      bne	ParseInputLoop
    323  1ce4
    324  1ce4				   ParseComplete
    325  1ce4		       a9 00		      lda	#0
    326  1ce6		       9d 9f 1b 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    327  1ce9		       e8		      inx
    328  1cea		       8e 9f 1b 	      stx	TOKENBUFFER	; Place size including null into buffer start
    329  1ced
    330  1ced		       68		      pla
    331  1cee		       a8		      tay
    332  1cef		       68		      pla
    333  1cf0		       aa		      tax
    334  1cf1		       68		      pla
    335  1cf2		       85 51		      sta	CUROFF
    336  1cf4
    337  1cf4				  -	      if	DEBUGPARSER
    338  1cf4				  -
    339  1cf4				  -	      jsr	printTokenBuffer
    340  1cf4				  -			;jsr	  DebugPrintProgramLine
    341  1cf4				  -	      jsr	SetOutDebugEnd
    342  1cf4				  -
    343  1cf4					      endif
    344  1cf4		       60		      rts
    345  1cf5
    346  1cf5							;==================================================================================================================
    347  1cf5							; Look at curptr, curpos and check for a valid KeyWord
    348  1cf5							; A contains the index value. c is clear
    349  1cf5							;		     not found c set  A undefined
    350  1cf5							; X is prerserved
    351  1cf5							;
    352  1cf5				   ParseLookupKey
    353  1cf5		       86 58		      stx	R2
    354  1cf7		       a0 00		      ldy	#0
    355  1cf9		       a9 68		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    356  1cfb		       85 54		      sta	R1
    357  1cfd		       a9 1a		      lda	#KeyWordTable>>8
    358  1cff		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    359  1d01		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    360  1d03		       85 52		      sta	R0	; Save until next keyword
    361  1d05		       c8		      iny		; Point to first character of keyword
    362  1d06		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    363  1d08
    364  1d08				  -	      if	DEBUGPARSER
    365  1d08				  -			;    jsr DebugKeyword
    366  1d08					      endif
    367  1d08
    368  1d08				   ParseLookupLoop
    369  1d08		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    370  1d0a		       29 df		      and	#%11011111	; Force Keyword to upper case
    371  1d0c		       dd 7f 41 	      cmp	LINBUF,x	; Check the input buffer
    372  1d0f		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    373  1d11		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    374  1d13		       dd 7f 41 	      cmp	LINBUF,x	; Compare value to upercase
    375  1d16		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    376  1d18
    377  1d18				   ParseNextLetter
    378  1d18		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    379  1d1a		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    380  1d1c		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    381  1d1e		       e8		      inx		; Point to next char in the input buffer
    382  1d1f		       c8		      iny		; Point to the next character in the Keyword table
    383  1d20		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    384  1d22		       dd 7f 41 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    385  1d25		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    386  1d27		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    387  1d29
    388  1d29				   ParseKeyFound
    389  1d29		       a5 52		      lda	R0	; get the keyword index
    390  1d2b
    391  1d2b				   ParseKeyDone
    392  1d2b		       e8		      inx		; point past the last character
    393  1d2c		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    394  1d2e		       a6 58		      ldx	R2	; Restore the original x pointer
    395  1d30		       9d 9f 1b 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    396  1d33		       e8		      inx		; Point to next position in the output buffer
    397  1d34		       86 58		      stx	R2	; Save next position in buffer
    398  1d36		       c9 0a		      cmp	#kRem	; remark statement
    399  1d38		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    400  1d3a		       c9 07		      cmp	#kGoto
    401  1d3c		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    402  1d3e		       c9 08		      cmp	#kGosub
    403  1d40		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    404  1d42		       c9 37		      cmp	#kGofn
    405  1d44		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    406  1d46		       c9 2f		      cmp	#kTask
    407  1d48		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    408  1d4a
    409  1d4a		       18		      clc		; C flag clear, we found it
    410  1d4b		       60		      rts
    411  1d4c
    412  1d4c							; Move forward to the next entry in table
    413  1d4c				   ParseNextEntry
    414  1d4c		       b1 54		      lda	(R1),y	; Get the next character in the token
    415  1d4e		       29 20		      and	#%00100000	; Is it the last character
    416  1d50		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    417  1d52		       c8		      iny		; Point to next char in the entry
    418  1d53		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    419  1d55
    420  1d55				   ParseEndOfEntry
    421  1d55		       c8		      iny		; Point to the byte after the last character
    422  1d56		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    423  1d57		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    424  1d58		       65 54		      adc	R1
    425  1d5a		       85 54		      sta	R1
    426  1d5c		       a5 55		      lda	R1+1
    427  1d5e		       69 00		      adc	#0
    428  1d60		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    429  1d62		       a0 00		      ldy	#0	; Reset the index back to zero
    430  1d64		       b1 54		      lda	(R1),y	; get keyword value
    431  1d66		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    432  1d68		       85 52		      sta	R0	; save the next token value
    433  1d6a		       c8		      iny		; Inc past token value
    434  1d6b
    435  1d6b				  -	      if	DEBUGPARSER
    436  1d6b				  -			;    jsr DebugKeyword
    437  1d6b					      endif
    438  1d6b		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    439  1d6d		       4c 08 1d 	      jmp	ParseLookupLoop	; branch back for next key word
    440  1d70
    441  1d70				   ParseNoneFound
    442  1d70		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    443  1d72		       38		      sec		; c clear, not found
    444  1d73		       60		      rts
    445  1d74
    446  1d74							;===============================================================================
    447  1d74							; Move everything from current position until the end of line into the token buffer
    448  1d74							;
    449  1d74		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    450  1d76		       a6 58		      ldx	R2	; where to place in the buffer
    451  1d78				   ParseMoveLoop
    452  1d78		       b9 7f 41 	      lda	LINBUF,y	; get the next byte
    453  1d7b		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    454  1d7d		       9d 9f 1b 	      sta	TOKENBUFFER,x	; save the byte
    455  1d80		       c8		      iny
    456  1d81		       e8		      inx
    457  1d82		       d0 f4		      bne	ParseMoveLoop
    458  1d84				   ParseMoveDone
    459  1d84		       84 51		      sty	CUROFF
    460  1d86		       18		      clc
    461  1d87		       60		      rts
    462  1d88							;================================================================================================
    463  1d88							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    464  1d88							; transfer to a memory address
    465  1d88				   ParseHandleBranches
    466  1d88		       a6 58		      ldx	R2
    467  1d8a		       a9 00		      lda	#0
    468  1d8c		       9d 9f 1b 	      sta	TOKENBUFFER,x
    469  1d8f		       e8		      inx
    470  1d90		       9d 9f 1b 	      sta	TOKENBUFFER,x
    471  1d93		       e8		      inx
    472  1d94		       86 58		      stx	R2
    473  1d96		       18		      clc
    474  1d97		       60		      rts
    475  1d98
    476  1d98							;=========================================================================================================
    477  1d98							;ParseString Parse a quotes string
    478  1d98							; on input X = outbuf position
    479  1d98							; y = inbuf position
    480  1d98							; Copies string to output buffer, updates x and y
    481  1d98				   ParseString
    482  1d98		       a4 51		      ldy	CUROFF
    483  1d9a		       a9 a0		      lda	#tString
    484  1d9c		       9d 9f 1b 	      sta	TOKENBUFFER,X
    485  1d9f		       b9 7f 41 	      lda	LINBUF,y
    486  1da2		       c9 22		      cmp	#'"
    487  1da4		       d0 1a		      bne	ParseStringInvalid
    488  1da6		       e8		      inx
    489  1da7		       9d 9f 1b 	      sta	TOKENBUFFER,x
    490  1daa		       e8		      inx
    491  1dab		       c8		      iny
    492  1dac
    493  1dac				   ParseStringLoop
    494  1dac		       b9 7f 41 	      lda	LINBUF,y
    495  1daf		       9d 9f 1b 	      sta	TOKENBUFFER,x
    496  1db2		       c9 22		      cmp	#'"
    497  1db4		       f0 04		      beq	ParseStringDone
    498  1db6		       c8		      iny
    499  1db7		       e8		      inx
    500  1db8		       d0 f2		      bne	ParseStringLoop
    501  1dba
    502  1dba				   ParseStringDone
    503  1dba		       e8		      inx
    504  1dbb		       c8		      iny
    505  1dbc		       84 51		      sty	CUROFF
    506  1dbe		       18		      clc
    507  1dbf		       60		      rts
    508  1dc0
    509  1dc0				   ParseStringInvalid
    510  1dc0		       38		      sec
    511  1dc1		       60		      rts
    512  1dc2
    513  1dc2							;=========================================================================================================
    514  1dc2							; Get numeric values and return value in RO and type in a
    515  1dc2							;
    516  1dc2				   ParseNumeric
    517  1dc2		       a4 51		      ldy	CUROFF
    518  1dc4		       b9 7f 41 	      lda	LINBUF,y
    519  1dc7		       c9 30		      cmp	#'0
    520  1dc9		       90 33		      bcc	ParseNumInvalid
    521  1dcb		       c9 3a		      cmp	#'9+1
    522  1dcd		       b0 2f		      bcs	ParseNumInvalid
    523  1dcf		       86 58		      stx	R2
    524  1dd1		       20 eb 29 	      jsr	getDecimal
    525  1dd4		       a6 58		      ldx	R2
    526  1dd6		       84 51		      sty	CUROFF
    527  1dd8		       a5 53		      lda	R0+1
    528  1dda		       f0 14		      beq	ParseByteValue
    529  1ddc
    530  1ddc				   ParseIntegerValue
    531  1ddc		       a9 a4		      lda	#tInteger
    532  1dde		       9d 9f 1b 	      sta	TOKENBUFFER,x
    533  1de1		       e8		      inx
    534  1de2		       a5 52		      lda	R0
    535  1de4		       9d 9f 1b 	      sta	TOKENBUFFER,x
    536  1de7		       e8		      inx
    537  1de8		       a5 53		      lda	R0+1
    538  1dea		       9d 9f 1b 	      sta	TOKENBUFFER,X
    539  1ded		       e8		      inx
    540  1dee		       18		      clc
    541  1def		       60		      rts
    542  1df0
    543  1df0				   ParseByteValue
    544  1df0		       a9 a2		      lda	#tByte
    545  1df2		       9d 9f 1b 	      sta	TOKENBUFFER,x
    546  1df5		       e8		      inx
    547  1df6		       a5 52		      lda	R0
    548  1df8		       9d 9f 1b 	      sta	TOKENBUFFER,x
    549  1dfb		       e8		      inx
    550  1dfc		       18		      clc
    551  1dfd		       60		      rts
    552  1dfe
    553  1dfe				   ParseNumInvalid		;Not a valid Numeric
    554  1dfe		       38		      sec
    555  1dff		       60		      rts
    556  1e00
    557  1e00							;=========================================================================================================
    558  1e00							;Parse for operators and seperators
    559  1e00							; on exit the A has the oper code, c is clear
    560  1e00							;		 not found then c is set
    561  1e00							;	x is preserved
    562  1e00							;
    563  1e00				   ParseForOperator
    564  1e00		       86 58		      stx	R2
    565  1e02		       a4 51		      ldy	CUROFF
    566  1e04		       a2 00		      ldx	#0
    567  1e06				  -	      if	DEBUGPARSER
    568  1e06				  -			;	jsr    DebugPrintOP
    569  1e06					      endif
    570  1e06
    571  1e06				   ParseOpLoop
    572  1e06		       bd 24 1a 	      lda	Operators,x	; First byte of operator
    573  1e09		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    574  1e0b
    575  1e0b		       d9 7f 41 	      cmp	LINBUF,y	; Check the first byte
    576  1e0e		       d0 1c		      bne	ParseOpNext
    577  1e10
    578  1e10		       c8		      iny
    579  1e11
    580  1e11		       bd 25 1a 	      lda	Operators+1,x
    581  1e14		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    582  1e16
    583  1e16		       d9 7f 41 	      cmp	LINBUF,y
    584  1e19		       d0 11		      bne	ParseOpNext
    585  1e1b
    586  1e1b				   ParseOpFound
    587  1e1b		       c8		      iny
    588  1e1c
    589  1e1c				   ParseOpFoundSingle
    590  1e1c		       84 51		      sty	CUROFF
    591  1e1e
    592  1e1e		       8a		      txa
    593  1e1f		       4a		      lsr
    594  1e20		       aa		      tax
    595  1e21		       bd 52 1a 	      lda	OperValues,x
    596  1e24		       a6 58		      ldx	R2
    597  1e26		       9d 9f 1b 	      sta	TOKENBUFFER,x
    598  1e29		       e8		      inx
    599  1e2a		       18		      clc
    600  1e2b		       60		      rts
    601  1e2c
    602  1e2c				   ParseOpNext
    603  1e2c		       e8		      inx
    604  1e2d		       e8		      inx
    605  1e2e
    606  1e2e				  -	      if	DEBUGPARSER
    607  1e2e				  -			;	 jsr	DebugPrintOP
    608  1e2e					      endif
    609  1e2e		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    610  1e30		       4c 06 1e 	      jmp	ParseOpLoop
    611  1e33
    612  1e33				   ParseOpNotFound
    613  1e33		       a6 58		      ldx	R2
    614  1e35		       38		      sec
    615  1e36		       60		      rts
    616  1e37							;=========================================================================================================
    617  1e37				  -	      if	DEBUGPARSER
    618  1e37				  -			;Print the text of a keyword
    619  1e37				  -			;Input R1    = offset into table
    620  1e37				  -DebugKeyword
    621  1e37				  -	      tya
    622  1e37				  -	      pha
    623  1e37				  -	      ldy	#1
    624  1e37				  -DebugKeyLoop
    625  1e37				  -	      lda	(R1),y
    626  1e37				  -	      jsr	VOUTCH
    627  1e37				  -	      and	#%00100000
    628  1e37				  -	      beq	DebugKeyDone
    629  1e37				  -	      iny
    630  1e37				  -	      bne	DebugKeyLoop
    631  1e37				  -
    632  1e37				  -DebugKeyDone
    633  1e37				  -	      jsr	CRLF
    634  1e37				  -	      pla
    635  1e37				  -	      tay
    636  1e37				  -	      rts
    637  1e37				  -			;========================================
    638  1e37				  -DebugPrintOP
    639  1e37				  -	      pha
    640  1e37				  -	      lda	Operators,x
    641  1e37				  -	      jsr	VOUTCH
    642  1e37				  -	      lda	Operators+1,x
    643  1e37				  -	      beq	DbgPrtOpDone
    644  1e37				  -	      jsr	VOUTCH
    645  1e37				  -
    646  1e37				  -DbgPrtOpDone
    647  1e37				  -	      jsr	CRLF
    648  1e37				  -	      pla
    649  1e37				  -	      rts
    650  1e37				  -			;=======================================
    651  1e37				  -DebugClearBuffer
    652  1e37				  -	      txa
    653  1e37				  -	      pha
    654  1e37				  -	      ldx	#$FF
    655  1e37				  -	      lda	#0
    656  1e37				  -DebugClrLoop
    657  1e37				  -	      sta	TOKENBUFFER,x
    658  1e37				  -	      dex
    659  1e37				  -	      bne	DebugClrLoop
    660  1e37				  -	      sta	TOKENBUFFER,x
    661  1e37				  -	      pla
    662  1e37				  -	      tax
    663  1e37				  -	      rts
    664  1e37				  -
    665  1e37				  -			;=====================================================
    666  1e37				  -			; Print the parser buffer as hex values
    667  1e37				  -printTokenBuffer
    668  1e37				  -	      stx	printStorage
    669  1e37				  -	      sty	printStorage+1
    670  1e37				  -	      sta	printStorage+2
    671  1e37				  -
    672  1e37				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    673  1e37				  -	      inx		; we want to show the last zero byte
    674  1e37				  -	      ldy	#0
    675  1e37				  -
    676  1e37				  -printHexLoop
    677  1e37				  -	      lda	TOKENBUFFER,y	; get the character
    678  1e37				  -	      jsr	HexToOut	; print it
    679  1e37				  -	      lda	#$20
    680  1e37				  -	      jsr	VOUTCH
    681  1e37				  -	      iny
    682  1e37				  -	      dex
    683  1e37				  -	      cpx	#0
    684  1e37				  -	      bne	printHexLoop
    685  1e37				  -	      jsr	CRLF
    686  1e37				  -
    687  1e37				  -	      ldy	printStorage+1
    688  1e37				  -	      ldx	printStorage
    689  1e37				  -	      lda	printStorage+2
    690  1e37				  -printHexDone
    691  1e37				  -	      clc
    692  1e37				  -	      rts
    693  1e37					      endif
    694  1e37
    695  1e37
    696  1e37							;=========================================================================================================
    697  1e37							; Parse for variables A-Z @, ^  x!x x[op]
    698  1e37				   ParseForVariable
    699  1e37		       a4 51		      ldy	CUROFF
    700  1e39		       b9 7f 41 	      lda	LINBUF,y
    701  1e3c		       c9 5e		      cmp	#'^	; is it an exit code
    702  1e3e		       d0 04		      bne	ParseVarMem
    703  1e40		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    704  1e42		       d0 1f		      bne	ParseVarSpecial
    705  1e44
    706  1e44				   ParseVarMem
    707  1e44		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    708  1e46		       d0 04		      bne	ParseVarStack
    709  1e48		       a9 9d		      lda	#tVat
    710  1e4a		       d0 17		      bne	ParseVarSpecial
    711  1e4c
    712  1e4c				   ParseVarStack
    713  1e4c		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    714  1e4e		       d0 04		      bne	ParseVarLetters
    715  1e50		       a9 9c		      lda	#tVhash
    716  1e52		       d0 0f		      bne	ParseVarSpecial
    717  1e54
    718  1e54				   ParseVarLetters
    719  1e54		       29 df		      and	#%11011111	; Force upper case
    720  1e56		       c9 41		      cmp	#'A
    721  1e58		       90 12		      bcc	ParseVarInvalid
    722  1e5a		       c9 5b		      cmp	#'Z+1
    723  1e5c		       b0 0e		      bcs	ParseVarInvalid
    724  1e5e							;
    725  1e5e							; The condition is true, so convert to an index, push
    726  1e5e							; it onto the stack and continue running.
    727  1e5e							;
    728  1e5e		       38		      sec
    729  1e5f		       e9 41		      sbc	#'A	;index is zero based
    730  1e61		       09 80		      ora	#$80
    731  1e63
    732  1e63				   ParseVarSpecial
    733  1e63		       9d 9f 1b 	      sta	TOKENBUFFER,x
    734  1e66		       e8		      inx
    735  1e67		       c8		      iny
    736  1e68		       84 51		      sty	CUROFF
    737  1e6a		       18		      clc
    738  1e6b		       60		      rts
    739  1e6c
    740  1e6c				   ParseVarInvalid
    741  1e6c		       38		      sec
    742  1e6d		       60		      rts
    743  1e6e
    744  1e6e
    745  1e6e							;=========================================================================================================
    746  1e6e							; Transfer R0 to the TOKENBUFFER
    747  1e6e							;
    748  1e6e				   R02TOKEN
    749  1e6e		       a5 52		      lda	R0
    750  1e70		       9d 9f 1b 	      sta	TOKENBUFFER,x
    751  1e73		       e8		      inx
    752  1e74		       a5 53		      lda	R0+1
    753  1e76		       9d 9f 1b 	      sta	TOKENBUFFER,x
    754  1e79		       e8		      inx
    755  1e7a		       18		      clc
    756  1e7b		       60		      rts
    757  1e7c							;=========================================================================
    758  1e7c							; Transfer word in Token Buffer to R0
    759  1e7c				   TOKEN2R0
    760  1e7c		       b9 9f 1b 	      lda	TOKENBUFFER,y
    761  1e7f		       85 52		      sta	R0
    762  1e81		       c8		      iny
    763  1e82		       ca		      dex
    764  1e83		       b9 9f 1b 	      lda	TOKENBUFFER,y
    765  1e86		       c8		      iny
    766  1e87		       ca		      dex
    767  1e88		       85 53		      sta	R0+1
    768  1e8a		       60		      rts
    769  1e8b							;==========================================================================
    770  1e8b							; Transfer	Display Buffer position to R0
    771  1e8b							;
    772  1e8b				   DPL2R0
    773  1e8b		       b1 59		      lda	(dpl),y
    774  1e8d		       85 52		      sta	R0
    775  1e8f		       c8		      iny
    776  1e90		       ca		      dex
    777  1e91		       b1 59		      lda	(dpl),y
    778  1e93		       c8		      iny
    779  1e94		       ca		      dex
    780  1e95		       85 53		      sta	R0+1
    781  1e97		       60		      rts
    782  1e98
    783  1e98
    784  1e98							;=========================================================================
    785  1e98							; Read an IL byte lookit up in the table, of words
    786  1e98							; set the next ilpc to point to that address
    787  1e98							; if not found then do ussual filter stuff
    788  1e98							; ongoto ilvectortable, not found address
    789  1e98		       20 3c 29    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    790  1e9b		       86 52		      stx	R0
    791  1e9d		       85 53		      sta	R0+1
    792  1e9f
    793  1e9f		       a4 51		      ldy	CUROFF
    794  1ea1		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    795  1ea3		       a0 00		      ldy	#0
    796  1ea5		       38		      sec
    797  1ea6		       f1 52		      sbc	(R0),y	; Subract the base value
    798  1ea8		       c8		      iny
    799  1ea9		       d1 52		      cmp	(R0),y	; Check if we are in range
    800  1eab		       b0 12		      bcs	iOnGotoInvalid
    801  1ead		       e6 51		      inc	CUROFF	; Save the offset
    802  1eaf
    803  1eaf		       0a		      asl
    804  1eb0		       a8		      tay		; Turn into vector
    805  1eb1		       c8		      iny		; Inc must include the table base and entry count
    806  1eb2		       c8		      iny
    807  1eb3
    808  1eb3		       b1 52		      lda	(R0),y
    809  1eb5		       85 43		      sta	ILPC
    810  1eb7		       c8		      iny
    811  1eb8		       b1 52		      lda	(R0),y
    812  1eba		       85 44		      sta	ILPC+1
    813  1ebc		       4c b1 02 	      jmp	NextIL
    814  1ebf
    815  1ebf				   iOnGotoInvalid
    816  1ebf		       20 3c 29 	      jsr	getILWord
    817  1ec2		       86 43		      stx	ILPC
    818  1ec4		       85 44		      sta	ILPC+1
    819  1ec6		       4c b1 02 	      jmp	NextIL
    820  1ec9							;
    821  1ec9							;==========================================================================================
    822  1ec9							; Test the token for relop and push the value onto the stack if true
    823  1ec9							;
    824  1ec9				   iTSTRELOP
    825  1ec9		       20 40 29 	      jsr	getILByte
    826  1ecc		       8d 14 42 	      sta	offset
    827  1ecf
    828  1ecf		       a4 51		      ldy	CUROFF
    829  1ed1		       b1 4f		      lda	(CURPTR),y
    830  1ed3		       48		      pha
    831  1ed4		       29 f0		      and	#$F0
    832  1ed6		       c9 f0		      cmp	#$F0
    833  1ed8		       d0 12		      bne	iTSTRELOPNOT
    834  1eda		       68		      pla
    835  1edb		       29 0f		      and	#$0F	; get the actual value
    836  1edd		       85 52		      sta	R0	; save it for later
    837  1edf		       a9 00		      lda	#0
    838  1ee1		       85 53		      sta	R0+1
    839  1ee3		       20 39 2b 	      jsr	pushR0
    840  1ee6		       c8		      iny
    841  1ee7		       84 51		      sty	CUROFF	; save the y pointer
    842  1ee9		       4c b1 02 	      jmp	NextIL
    843  1eec
    844  1eec				   iTSTRELOPNOT
    845  1eec		       68		      pla
    846  1eed		       4c bc 0b 	      jmp	tstBranch
    847  1ef0
    848  1ef0							;
    849  1ef0							;===================================================================================================
    850  1ef0							; Test the token and following info for precompiled address information
    851  1ef0							; skip it if zero, transfer and skip next integer value if not zero
    852  1ef0							; used by both gosub, goto and gofN
    853  1ef0							;
    854  1ef0				   iTSTBRANCH
    855  1ef0		       20 40 29 	      jsr	getILByte	; Get jump address if vector is valid
    856  1ef3		       8d 14 42 	      sta	offset	; Mark offset for later if vector found
    857  1ef6		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    858  1ef8		       88		      dey		; point back to the type of branch
    859  1ef9		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    860  1efb		       48		      pha		; Save till needed
    861  1efc		       c8		      iny		; back to memory vectors
    862  1efd				   ITSTBRANCHCont
    863  1efd		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    864  1eff		       85 52		      sta	R0	; R0 will contain mem pointer of present
    865  1f01		       c8		      iny		; Point to next byte of mem vector
    866  1f02		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    867  1f04		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    868  1f06		       c8		      iny		; Point to the byte past memory vector
    869  1f07		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    870  1f09
    871  1f09		       05 52		      ora	R0	; Get the second byte of the mem
    872  1f0b		       f0 21		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    873  1f0d		       68		      pla
    874  1f0e		       c9 2f		      cmp	#kTask	; Task defied with Task() so bypass the first bracket
    875  1f10		       d0 07		      bne	iTSTBRANCHCont
    876  1f12		       b1 4f		      lda	(CURPTR),y
    877  1f14		       c9 e0		      cmp	#oLeftBracket
    878  1f16		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    879  1f18		       c8		      iny		; Increment past the bracket
    880  1f19				   iTSTBRANCHCont
    881  1f19		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    882  1f1b		       c9 a2		      cmp	#tByte	; A byte value is valid
    883  1f1d		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    884  1f1f		       c9 a4		      cmp	#tInteger	; An integer value is valid
    885  1f21		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    886  1f23		       c8		      iny		; skip type indicator for
    887  1f24				   ITSTBRANCHBYTE
    888  1f24		       c8		      iny		; skip first byte of value line number
    889  1f25		       c8		      iny		; Skip second byte of line number
    890  1f26
    891  1f26				   iTSTBRANCHVALID
    892  1f26		       84 51		      sty	CUROFF
    893  1f28		       20 39 2b 	      jsr	pushR0	; place transfer address on top of stack
    894  1f2b		       4c bc 0b 	      jmp	tstBranch
    895  1f2e
    896  1f2e				   iTSTBRANCHNoCompile
    897  1f2e		       68		      pla
    898  1f2f				   iTSTBRANCHErr
    899  1f2f		       4c b1 02 	      jmp	NextIL
    900  1f32
    901  1f32
    902  1f32
    903  1f32
    904  1f32
    905  1f32
    906  1f32
    907  1f32
    908  1f32
    909  1f32
------- FILE mytb.asm
------- FILE compile.asm LEVEL 2 PASS 6
      0  1f32					      include	"compile.asm"
      1  1f32					      Seg	Code
      2  1f32							;
      3  1f32							;=====================================================================
      4  1f32							; Scan the loaded program just before running and insert memory locations of each
      5  1f32							; line number branched to. goto gosub, gofn
      6  1f32							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value}
      7  1f32				   Compile
      8  1f32		       a9 00		      lda	#0
      9  1f34		       85 52		      sta	R0	; keep track of how many errors we find
     10  1f36		       a5 5b		      lda	RunMode
     11  1f38		       48		      pha
     12  1f39		       e6 5b		      inc	RunMode	; force run mode for error reporting
     13  1f3b		       a5 4f		      lda	CURPTR
     14  1f3d		       48		      pha
     15  1f3e		       a5 50		      lda	CURPTR+1
     16  1f40		       48		      pha
     17  1f41		       a5 51		      lda	CUROFF
     18  1f43		       48		      pha
     19  1f44		       ad 18 42 	      lda	ProgramStart
     20  1f47		       85 59		      sta	dpl
     21  1f49		       ad 19 42 	      lda	ProgramStart+1
     22  1f4c		       85 5a		      sta	dpl+1
     23  1f4e
     24  1f4e				   CompileLineStart
     25  1f4e		       a5 59		      lda	dpl
     26  1f50		       cd 1a 42 	      cmp	ProgramEnd
     27  1f53		       d0 07		      bne	CompileContinue
     28  1f55		       a5 5a		      lda	dpl+1
     29  1f57		       cd 1b 42 	      cmp	ProgramEnd+1
     30  1f5a		       f0 3f		      beq	CompileComplete
     31  1f5c
     32  1f5c				   CompileContinue
     33  1f5c		       a0 03		      ldy	#3	; first real character in the line
     34  1f5e
     35  1f5e				   CompileLoop
     36  1f5e		       b1 59		      lda	(dpl),y	; get the byte
     37  1f60		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     38  1f62		       c8		      iny		; Pass this byte
     39  1f63		       c9 07		      cmp	#kGoto
     40  1f65		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     41  1f67		       c9 08		      cmp	#kGosub
     42  1f69		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     43  1f6b		       c9 37		      cmp	#kGofn
     44  1f6d		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  1f6f		       c9 2f		      cmp	#kTask
     46  1f71		       f0 4c		      beq	CompileField
     47  1f73		       c9 0a		      cmp	#kRem
     48  1f75		       f0 12		      beq	CompileRem	; Skip until end of line
     49  1f77		       c9 a0		      cmp	#tString
     50  1f79		       f0 2f		      beq	CompileString
     51  1f7b		       c9 a4		      cmp	#tInteger
     52  1f7d		       f0 06		      beq	CompileInteger
     53  1f7f		       c9 a2		      cmp	#tByte
     54  1f81		       f0 03		      beq	CompileByte
     55  1f83		       d0 d9		      bne	CompileLoop	; Next character
     56  1f85
     57  1f85				   CompileInteger
     58  1f85		       c8		      iny
     59  1f86				   CompileByte
     60  1f86		       c8		      iny
     61  1f87		       d0 d5		      bne	CompileLoop
     62  1f89				   CompileRem
     63  1f89				   CompileEndOfLine
     64  1f89		       a0 00		      ldy	#0
     65  1f8b		       b1 59		      lda	(dpl),y
     66  1f8d		       18		      clc
     67  1f8e		       65 59		      adc	dpl
     68  1f90		       85 59		      sta	dpl
     69  1f92		       a9 00		      lda	#0
     70  1f94		       65 5a		      adc	dpl+1
     71  1f96		       85 5a		      sta	dpl+1
     72  1f98
     73  1f98		       4c 4e 1f 	      jmp	CompileLineStart
     74  1f9b
     75  1f9b				   CompileComplete
     76  1f9b		       68		      pla
     77  1f9c		       85 51		      sta	CUROFF
     78  1f9e		       68		      pla
     79  1f9f		       85 50		      sta	CURPTR+1
     80  1fa1		       68		      pla
     81  1fa2		       85 4f		      sta	CURPTR
     82  1fa4		       68		      pla
     83  1fa5		       85 5b		      sta	RunMode
     84  1fa7		       a5 52		      lda	R0	; returning the number of errors
     85  1fa9		       60		      rts
     86  1faa
     87  1faa
     88  1faa				   CompileString
     89  1faa		       c8		      iny		; point past first "
     90  1fab				   CompileStringLoop
     91  1fab		       b1 59		      lda	(dpl),y
     92  1fad		       f0 0d		      beq	CompileStrDone2	; end of line
     93  1faf		       c9 22		      cmp	#'"	; end of string
     94  1fb1		       f0 08		      beq	CompileStrDone
     95  1fb3		       c9 5c		      cmp	#'\	; escape character
     96  1fb5		       d0 01		      bne	CompileStrNext
     97  1fb7		       c8		      iny		; skip the escape character
     98  1fb8				   CompileStrNext
     99  1fb8		       c8		      iny		; Next character
    100  1fb9		       d0 f0		      bne	CompileStringLoop	; test for end
    101  1fbb				   CompileStrDone
    102  1fbb		       c8		      iny
    103  1fbc				   CompileStrDone2
    104  1fbc		       4c 5e 1f 	      Jmp	CompileLoop
    105  1fbf							;
    106  1fbf							;===============================================================
    107  1fbf							; on entry y points to storage location y+2 points to line number
    108  1fbf							; on exit y points to line number type
    109  1fbf
    110  1fbf		       85 52	   CompileField sta	R0
    111  1fc1		       98		      tya		; save the y pointer to store the memory value
    112  1fc2		       48		      pha
    113  1fc3		       c8		      iny		; Skip over the memory vector
    114  1fc4		       c8		      iny
    115  1fc5		       a5 52		      lda	R0
    116  1fc7		       c9 2f		      cmp	#kTask	; for a task it is the next byte after a bracket
    117  1fc9		       d0 07		      bne	CompNoBracket
    118  1fcb
    119  1fcb		       b1 59		      lda	(dpl),y	; Lets make sure it is a )
    120  1fcd		       c9 e0		      cmp	#oLeftBracket
    121  1fcf		       d0 01		      bne	CompNoBracket	; in case of error
    122  1fd1		       c8		      iny		; skip the bracket
    123  1fd2
    124  1fd2				   CompNoBracket
    125  1fd2		       a9 00		      lda	#0	; In case the value is a byte
    126  1fd4		       85 53		      sta	R0+1
    127  1fd6
    128  1fd6		       b1 59		      lda	(dpl),Y	; get the type of the next byte t something or other
    129  1fd8		       c9 a2		      cmp	#tByte
    130  1fda		       f0 15		      beq	CompByteLoad
    131  1fdc		       c9 a4		      cmp	#tInteger
    132  1fde		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    133  1fe0		       68		      pla
    134  1fe1		       4c 5e 1f 	      jmp	CompileLoop	; Ignore the saved stack
    135  1fe4				   CompIntLoad
    136  1fe4		       c8		      iny
    137  1fe5		       b1 59		      lda	(dpl),y
    138  1fe7		       85 52		      sta	R0
    139  1fe9		       c8		      iny
    140  1fea		       b1 59		      lda	(dpl),y
    141  1fec		       85 53		      sta	R0+1
    142  1fee		       4c f6 1f 	      jmp	CompFindLine
    143  1ff1				   CompByteLoad
    144  1ff1		       c8		      iny
    145  1ff2		       b1 59		      lda	(dpl),y
    146  1ff4		       85 52		      sta	R0
    147  1ff6				   CompFindLine
    148  1ff6		       20 85 29 	      jsr	findLine
    149  1ff9		       f0 1d		      beq	CompFoundLine
    150  1ffb		       e6 52		      inc	R0	; number of errors
    151  1ffd
    152  1ffd		       a5 59		      lda	dpl
    153  1fff		       85 4f		      sta	CURPTR
    154  2001		       a5 5a		      lda	dpl+1
    155  2003		       85 50		      sta	CURPTR+1
    156  2005		       84 51		      sty	CUROFF
    157  2007
    158  2007		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    159  2009		       a9 00		      lda	#0
    160  200b
    161  200b		       20 08 06 	      jsr	DisplayError
    162  200e		       20 90 21 	      jsr	PrintProgramLine
    163  2011
    164  2011		       68		      pla
    165  2012		       a8		      tay
    166  2013		       c8		      iny
    167  2014		       c8		      iny
    168  2015		       4c 5e 1f 	      jmp	CompileLoop
    169  2018
    170  2018				   CompFoundLine
    171  2018		       68		      pla
    172  2019		       a8		      tay
    173  201a		       a5 4f		      lda	CURPTR
    174  201c		       91 59		      sta	(dpl),y
    175  201e		       c8		      iny
    176  201f		       a5 50		      lda	CURPTR+1
    177  2021		       91 59		      sta	(dpl),y
    178  2023		       c8		      iny
    179  2024		       4c 5e 1f 	      jmp	CompileLoop
    180  2027
    181  2027
    182  2027
    183  2027
    184  2027
    185  2027
    186  2027
    187  2027
    188  2027
    189  2027
    190  2027
    191  2027
    192  2027
    193  2027
    194  2027
    195  2027
    196  2027
    197  2027
    198  2027
    199  2027
    200  2027
    201  2027
    202  2027
    203  2027
    204  2027
    205  2027
    206  2027
    207  2027
    208  2027
    209  2027
    210  2027
    211  2027
    212  2027
    213  2027
    214  2027
    215  2027
    216  2027
    217  2027
    218  2027
    219  2027
    220  2027
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  2027					      include	"print.asm"
      1  2027					      Seg	Code
      2  2027							;---------------------------
      3  2027							; Print 24-bit decimal number or  16bit unsigned
      4  2027							; ---------------------------
      5  2027							; On entry, R0=number to print
      6  2027							;	     Defaults to pad=0 , y=21 default
      7  2027							;	     R2 = 1 unsigned 16 bit
      8  2027							;	     R2 = 0 Signed   16 bit
      9  2027
     10  2027							; On entry at PrintDecPadded:
     11  2027							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  2027
     13  2027							; On exit,  A,X,Y,num,pad corrupted
     14  2027							; Size      129 bytes, Table 24 bytes	--- total 153
     15  2027							; -----------------------------------------------------------------
     16  2027
     17  2027				   PrintDecimal
     18  2027		       8a		      TXA
     19  2028		       48		      pha
     20  2029		       98		      tya
     21  202a		       48		      pha
     22  202b		       a9 00		      lda	#0
     23  202d		       8d c2 20 	      sta	pad
     24  2030		       a0 15		      LDY	#21	; Offset to powers of ten
     25  2032		       4c 38 20 	      JMP	PrintDo
     26  2035
     27  2035				   PrintDecPadded
     28  2035		       8e c2 20 	      stx	pad
     29  2038
     30  2038				   PrintDo
     31  2038		       a9 00		      lda	#0
     32  203a		       85 54		      sta	R1
     33  203c
     34  203c		       a5 58		      lda	R2
     35  203e		       c9 a9		      cmp	#tUint
     36  2040		       f0 29		      beq	PrintPos
     37  2042
     38  2042		       a5 53		      lda	R0+1	;MSB has sign
     39  2044		       10 25		      bpl	PrintPos	;it's a positive number;
     40  2046
     41  2046
     42  2046							; Negative numbers need more work.  Invert all the bits,
     43  2046							; then add one.
     44  2046
     45  2046		       a9 2d		      lda	#'-
     46  2048		       20 c8 19 	      jsr	VOUTCH	;print the negative sign
     47  204b
     48  204b		       a9 ff		      lda	#$FF
     49  204d		       85 54		      sta	R1
     50  204f		       a5 52		      lda	R0	;invert bits
     51  2051		       49 ff		      eor	#$ff
     52  2053		       85 52		      sta	R0
     53  2055		       a5 53		      lda	R0+1
     54  2057		       49 ff		      eor	#$ff
     55  2059		       85 53		      sta	R0+1
     56  205b		       a5 54		      lda	R1
     57  205d		       49 ff		      eor	#$ff
     58  205f		       85 54		      sta	R1
     59  2061		       e6 52		      inc	R0	;add one
     60  2063		       d0 06		      bne	PrintPos
     61  2065		       e6 53		      inc	R0+1
     62  2067		       d0 02		      bne	PrintPos
     63  2069		       e6 54		      inc	R1
     64  206b				   PrintPos
     65  206b
     66  206b				   PrDec24Lp1
     67  206b		       a2 ff		      LDX	#$FF
     68  206d		       38		      SEC		; Start with digit=-1
     69  206e				   PrDec24Lp2
     70  206e		       a5 52		      LDA	R0+0
     71  2070		       f9 c3 20 	      SBC	PrDec24Tens+0,Y
     72  2073		       85 52		      STA	R0+0	; Subtract current tens
     73  2075		       a5 53		      LDA	R0+1
     74  2077		       f9 c4 20 	      SBC	PrDec24Tens+1,Y
     75  207a		       85 53		      STA	R0+1
     76  207c		       a5 54		      LDA	R0+2
     77  207e		       f9 c5 20 	      SBC	PrDec24Tens+2,Y
     78  2081		       85 54		      STA	R0+2
     79  2083		       e8		      INX
     80  2084		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     81  2086		       a5 52		      LDA	R0+0
     82  2088		       79 c3 20 	      ADC	PrDec24Tens+0,Y
     83  208b		       85 52		      STA	R0+0	; Add current tens back in
     84  208d		       a5 53		      LDA	R0+1
     85  208f		       79 c4 20 	      ADC	PrDec24Tens+1,Y
     86  2092		       85 53		      STA	R0+1
     87  2094		       a5 54		      LDA	R0+2
     88  2096		       79 c5 20 	      ADC	PrDec24Tens+2,Y
     89  2099		       85 54		      STA	R0+2
     90  209b		       8a		      TXA
     91  209c		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     92  209e		       ad c2 20 	      LDA	pad
     93  20a1		       d0 09		      BNE	PrDec24Print
     94  20a3		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     95  20a5				   PrDec24Digit
     96  20a5		       a2 30		      LDX	#'0
     97  20a7		       8e c2 20 	      STX	pad	; No more zero padding
     98  20aa		       09 30		      ORA	#'0	; Print this digit
     99  20ac				   PrDec24Print
    100  20ac		       20 c8 19 	      JSR	VOUTCH
    101  20af				   PrDec24Next
    102  20af		       88		      DEY
    103  20b0		       88		      DEY
    104  20b1		       88		      DEY
    105  20b2		       f0 07		      beq	PrDec24LastDigit
    106  20b4		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    107  20b6		       68		      pla
    108  20b7		       a8		      tay
    109  20b8		       68		      pla
    110  20b9		       aa		      tax
    111  20ba		       60		      RTS
    112  20bb				   PrDec24LastDigit
    113  20bb		       a2 30		      LDX	#'0
    114  20bd		       8e c2 20 	      STX	pad	; No more zero padding
    115  20c0		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    116  20c2
      0  20c2				   pad	      db	0
      1  20c2		       00		      .byte.b	0
    118  20c3
    119  20c3				   PrDec24Tens
      0  20c3					      dw	1
      1  20c3		       01 00		      .word.w	1
      0  20c5					      db	(1 / 65536)
      1  20c5		       00		      .byte.b	(1 / 65536)
      0  20c6					      dw	10
      1  20c6		       0a 00		      .word.w	10
      0  20c8					      db	(10 / 65536)
      1  20c8		       00		      .byte.b	(10 / 65536)
      0  20c9					      dw	100
      1  20c9		       64 00		      .word.w	100
      0  20cb					      db	(100 / 65536)
      1  20cb		       00		      .byte.b	(100 / 65536)
      0  20cc					      dw	1000
      1  20cc		       e8 03		      .word.w	1000
      0  20ce					      db	(1000 / 65536)
      1  20ce		       00		      .byte.b	(1000 / 65536)
      0  20cf					      dw	10000
      1  20cf		       10 27		      .word.w	10000
      0  20d1					      db	(10000 / 65536)
      1  20d1		       00		      .byte.b	(10000 / 65536)
      0  20d2					      dw	100000
      1  20d2		       a0 86		      .word.w	100000
      0  20d4					      db	(100000 / 65536)
      1  20d4		       01		      .byte.b	(100000 / 65536)
      0  20d5					      dw	1000000
      1  20d5		       40 42		      .word.w	1000000
      0  20d7					      db	(1000000 / 65536)
      1  20d7		       0f		      .byte.b	(1000000 / 65536)
      0  20d8					      dw	10000000
      1  20d8		       80 96		      .word.w	10000000
      0  20da					      db	(10000000 / 65536)
      1  20da		       98		      .byte.b	(10000000 / 65536)
    136  20db							;=====================================================
    137  20db							; Print character in A as two hex digits to the Console
    138  20db
    139  20db		       48	   HexToOut   pha		;save return value
    140  20dc		       48		      pha
    141  20dd		       4a		      lsr		;a  ;move top nibble to bottom
    142  20de		       4a		      lsr		;a
    143  20df		       4a		      lsr		;a
    144  20e0		       4a		      lsr		;a
    145  20e1		       20 ea 20 	      jsr	hexta	;output nibble
    146  20e4		       68		      pla
    147  20e5		       20 ea 20 	      jsr	hexta
    148  20e8		       68		      pla		;restore
    149  20e9		       60		      rts
    150  20ea							;
    151  20ea		       29 0f	   hexta      and	#%0001111
    152  20ec		       c9 0a		      cmp	#$0a
    153  20ee		       18		      clc
    154  20ef		       30 02		      bmi	hexta1
    155  20f1		       69 07		      adc	#7
    156  20f3		       69 30	   hexta1     adc	#'0	;then fall into...
    157  20f5		       4c c8 19 	      jmp	VOUTCH
    158  20f8							;
    159  20f8							;=====================================================
    160  20f8							; Print the string that immediately follows the JSR to
    161  20f8							; this function.  Stops when a null byte is found,
    162  20f8							; then returns to the instruction immediately
    163  20f8							; following the null.
    164  20f8							;
    165  20f8							; Thanks to Ross Archer for this code.
    166  20f8							; http://www.6502.org/source/io/primm.htm
    167  20f8							;
    168  20f8
    169  20f8		       68	   tbputs     pla		;Get the low part of "return" address
    170  20f9							;(data start address)
    171  20f9		       85 5e		      sta	PrtFrom
    172  20fb		       68		      pla
    173  20fc		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    174  20fe							;(data start address)
    175  20fe							;Note: actually we're pointing one short
    176  20fe		       a0 01	   PSINB      ldy	#1
    177  2100		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    178  2102		       e6 5e		      inc	PrtFrom	;update the pointer
    179  2104		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    180  2106		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    181  2108		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    182  210a							;   Accumulator
    183  210a		       f0 06		      beq	PSIX1	;don't print the final NULL
    184  210c		       20 c8 19 	      jsr	VOUTCH	;write it out
    185  210f		       4c fe 20 	      jmp	PSINB	;back around
    186  2112		       e6 5e	   PSIX1      inc	PrtFrom
    187  2114		       d0 02		      bne	PSIX2
    188  2116		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    189  2118		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    190  211b
    191  211b							;+
    192  211b							;====================================================
    193  211b		       42 10	   PrtTerm    equ	tempy
    194  211b
    195  211b							; on exit Print Y has the offset to use
    196  211b							; input y =	 addr low
    197  211b							;	 x =	 addr high
    198  211b							;	 a =	 termination string
    199  211b
    200  211b
    201  211b				   PrtQuoted		; Print a quoted string from the current program space
    202  211b		       a9 22		      lda	#'"
    203  211d		       a4 51		      ldy	CUROFF
    204  211f		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    205  2121		       d0 03		      bne	PrtNoInc
    206  2123		       c8		      iny
    207  2124		       84 51		      sty	CUROFF
    208  2126				   PrtNoInc
    209  2126		       8d 10 42 	      sta	PrtTerm
    210  2129
    211  2129				   PrtPrgString 		; Print a terminated string from the static program space
    212  2129		       a4 51		      ldy	CUROFF
    213  212b		       a5 4f		      lda	CURPTR
    214  212d		       85 5e		      sta	PrtFrom
    215  212f		       a5 50		      lda	CURPTR+1
    216  2131		       85 5f		      sta	PrtFrom+1
    217  2133		       4c 3f 21 	      jmp	PrtLoop
    218  2136
    219  2136							; Print a string pointed to by x= h, y=l terminated by value in  accumulator
    220  2136							; Return y as the length
    221  2136
    222  2136		       86 5f	   PrtStr     stx	PrtFrom+1
    223  2138		       84 5e		      sty	PrtFrom
    224  213a		       8d 10 42 	      sta	PrtTerm
    225  213d		       a0 00		      ldy	#0
    226  213f							;
    227  213f							; On entry here ptrfrom and prtterm point to area to print
    228  213f							;
    229  213f		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    230  2141		       cd 10 42 	      cmp	PrtTerm
    231  2144		       f0 0b		      beq	PrtEnd
    232  2146		       c9 00		      cmp	#0	; always end if 0 is found
    233  2148		       f0 07		      beq	PrtEnd
    234  214a		       20 c8 19 	      jsr	VOUTCH
    235  214d		       c8		      iny
    236  214e		       4c 3f 21 	      jmp	PrtLoop
    237  2151		       c8	   PrtEnd     iny		;return byte after the write
    238  2152		       60		      rts
    239  2153
    240  2153							;
    241  2153							;=======================================================
    242  2153							; Print all Variables
    243  2153				   PrintAllVars
    244  2153		       a0 00		      ldy	#0
    245  2155		       a9 41		      lda	#'A
    246  2157				   PrintAllVarsLoop
    247  2157		       48		      pha
    248  2158		       b1 41		      lda	(VARIABLES),y
    249  215a		       85 52		      sta	R0
    250  215c		       c8		      iny
    251  215d		       b1 41		      lda	(VARIABLES),y
    252  215f		       85 53		      sta	R0+1
    253  2161
    254  2161		       68		      pla		;get the current letter
    255  2162		       48		      pha
    256  2163		       20 c8 19 	      jsr	VOUTCH
    257  2166		       20 f8 20 	      jsr	puts
      0  2169					      db	"=",0
      1  2169		       3d 00		      .byte.b	"=",0
    259  216b		       68		      pla
    260  216c		       aa		      tax
    261  216d		       e8		      inx
    262  216e		       8a		      txa
    263  216f		       48		      pha		;
    264  2170
    265  2170		       98		      tya
    266  2171		       48		      pha
    267  2172		       20 27 20 	      jsr	PrintDecimal
    268  2175		       20 f8 20 	      jsr	puts
      0  2178					      db	" ",0
      1  2178		       20 00		      .byte.b	" ",0
    270  217a		       68		      pla
    271  217b		       a8		      tay
    272  217c		       c8		      iny
    273  217d		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    274  217f		       90 d6		      bcc	PrintAllVarsLoop
    275  2181		       20 84 2c 	      jsr	CRLF
    276  2184
    277  2184		       68		      pla
    278  2185		       60		      rts
    279  2186							;==========================================================================================================
    280  2186							;Debug   Print a Program Line from compile buffer
    281  2186							;
    282  2186				   DebugPrintProgramLine
    283  2186		       48		      pha
    284  2187		       a9 9f		      lda	#TOKENBUFFER&$FF
    285  2189		       85 59		      sta	dpl
    286  218b		       a9 1b		      lda	#TOKENBUFFER>>8
    287  218d		       85 5a		      sta	dpl+1
    288  218f		       68		      pla
    289  2190
    290  2190							; Decode and print a line of program text
    291  2190							; on entry	 dpl points to line of code to print
    292  2190							; on exit	 no change in reg or dpl
    293  2190							;
    294  2190				   PrintProgramLine
    295  2190
    296  2190		       8e 9f 1c 	      stx	printStorage
    297  2193		       8c a0 1c 	      sty	printStorage+1
    298  2196		       48		      pha
    299  2197
    300  2197		       a0 01		      ldy	#1	; index into the token buffer
    301  2199		       84 58		      sty	R2	; print unsigned decimal
    302  219b		       a0 00		      ldy	#0
    303  219d		       b1 59		      lda	(dpl),y	; get number of bytes
    304  219f		       aa		      tax		; place pointer into x
    305  21a0		       c8		      iny
    306  21a1		       ca		      dex		; Deduct the length byte
    307  21a2		       20 8b 1e 	      jsr	DPL2R0	; Print the line number
    308  21a5		       20 27 20 	      jsr	PrintDecimal
    309  21a8		       a9 20		      lda	#$20
    310  21aa		       20 c8 19 	      jsr	VOUTCH
    311  21ad
    312  21ad				   PrintProgLoop
    313  21ad		       b1 59		      lda	(dpl),y	; Get a character
    314  21af		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    315  21b1		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    316  21b3		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    317  21b5
    318  21b5				   PrintProgVars
    319  21b5		       b1 59		      lda	(dpl),y
    320  21b7		       29 e0		      and	#$E0	; Check for operators and punctuation
    321  21b9		       c9 e0		      cmp	#$E0
    322  21bb		       f0 6b		      beq	PrintProgOperatorVect
    323  21bd
    324  21bd		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    325  21bf		       c9 9e		      cmp	#$9D+1
    326  21c1		       90 62		      bcc	PrintProgVariableVec
    327  21c3		       29 a0		      and	#$A0	; Check for a valid datatype
    328  21c5		       c9 a0		      cmp	#$A0
    329  21c7		       f0 06		      beq	PrintDataType	; if not just print the character
    330  21c9		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    331  21cb		       ca		      dex		; Ok we are processing it
    332  21cc		       c8		      iny
    333  21cd		       d0 25		      bne	PrintContinue	; Print and do the next character
    334  21cf
    335  21cf				   PrintDataType
    336  21cf		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    337  21d1		       c9 a0		      cmp	#tString
    338  21d3		       f0 31		      beq	PrintStringVariable
    339  21d5
    340  21d5				   PrintProgNumber
    341  21d5		       c8		      iny		; we have a numerical integer value
    342  21d6		       ca		      dex
    343  21d7		       48		      pha
    344  21d8		       a9 00		      lda	#0
    345  21da		       85 53		      sta	R0+1
    346  21dc		       85 58		      sta	R2	; Set to print signed number
    347  21de		       b1 59		      lda	(dpl),y
    348  21e0		       85 52		      sta	R0
    349  21e2		       68		      pla
    350  21e3		       c9 a4		      cmp	#tInteger
    351  21e5		       d0 06		      bne	PrintProgNumDone
    352  21e7		       c8		      iny
    353  21e8		       ca		      dex
    354  21e9		       b1 59		      lda	(dpl),y
    355  21eb		       85 53		      sta	R0+1
    356  21ed
    357  21ed				   PrintProgNumDone
    358  21ed		       c8		      iny
    359  21ee		       ca		      dex
    360  21ef		       20 27 20 	      jsr	PrintDecimal
    361  21f2
    362  21f2				   PrintProgNext
    363  21f2		       a9 20		      lda	#$20
    364  21f4				   PrintContinue
    365  21f4		       20 c8 19 	      jsr	VOUTCH
    366  21f7				   PrintProgSkipSpace
    367  21f7		       e0 00		      cpx	#0
    368  21f9		       d0 b2		      bne	PrintProgLoop
    369  21fb				   PrintProgramComplete
    370  21fb		       20 84 2c 	      jsr	CRLF
    371  21fe
    372  21fe		       ae 9f 1c 	      ldx	printStorage
    373  2201		       ac a0 1c 	      ldy	printStorage+1
    374  2204		       68		      pla
    375  2205
    376  2205		       60		      rts
    377  2206							;=================================================================================================================
    378  2206							; Print a string variable including the quotes
    379  2206							; On Input	 y is offset into buffer
    380  2206							; On Exit	 y is updated to new offset
    381  2206
    382  2206				   PrintStringVariable
    383  2206		       c8		      iny
    384  2207		       a9 22		      lda	#'"
    385  2209		       20 c8 19 	      jsr	VOUTCH
    386  220c		       c8		      iny
    387  220d		       a5 59		      lda	dpl
    388  220f		       85 5e		      sta	PrtFrom
    389  2211		       a5 5a		      lda	dpl+1
    390  2213		       85 5f		      sta	PrtFrom+1
    391  2215		       a9 22		      lda	#'"
    392  2217		       8d 10 42 	      sta	PrtTerm
    393  221a		       20 3f 21 	      jsr	PrtLoop
    394  221d		       a9 22		      lda	#'"
    395  221f		       20 c8 19 	      jsr	VOUTCH
    396  2222		       4c f2 21 	      jmp	PrintProgNext
    397  2225
    398  2225				   PrintProgVariableVec
    399  2225		       4c c5 22 	      jmp	PrintProgVariable
    400  2228
    401  2228				   PrintProgOperatorVect
    402  2228		       4c 9c 22 	      jmp	PrintProgOperator
    403  222b							;===============================================================================================================
    404  222b							; On entry dpl points to the buffer we are printing from
    405  222b							;	    y	current offset into the dpl buffer
    406  222b							; all registers preserved
    407  222b							;
    408  222b				   PrintKeyword
    409  222b
    410  222b		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    411  222d		       85 52		      sta	R0	; The value we are looking for
    412  222f		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    413  2231		       f0 0c		      beq	PrintKeyBranch
    414  2233		       c9 08		      cmp	#kGosub
    415  2235		       f0 08		      beq	PrintKeyBranch
    416  2237		       c9 2f		      cmp	#kTask
    417  2239		       f0 04		      beq	PrintKeyBranch
    418  223b		       c9 37		      cmp	#kGofn
    419  223d		       d0 04		      bne	PrintKeySkipped
    420  223f				   PrintKeyBranch
    421  223f		       c8		      iny		; Skip the compiled memory address
    422  2240		       c8		      iny
    423  2241		       ca		      dex		; Change number of bytes to print
    424  2242		       ca		      dex		; Remove the bytes to print
    425  2243
    426  2243				   PrintKeySkipped
    427  2243		       c8		      iny		; Inc y to point to the next char to be printed
    428  2244		       ca		      dex		; Reduce number of bytes to print
    429  2245		       98		      tya		; Save y and x for the return
    430  2246		       48		      pha
    431  2247		       8a		      txa
    432  2248		       48		      pha
    433  2249
    434  2249		       a9 68		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    435  224b		       85 54		      sta	R1
    436  224d		       a9 1a		      lda	#KeyWordTable>>8
    437  224f		       85 55		      sta	R1+1
    438  2251
    439  2251
    440  2251				   PrintKeyLoop
    441  2251		       a0 00		      ldy	#0	; Index into the keyword entry
    442  2253		       b1 54		      lda	(R1),y	; Get token value for this entry
    443  2255		       c8		      iny		; Point to first byte of key
    444  2256		       c5 52		      cmp	R0	; Compare to the token we are looking for
    445  2258		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    446  225a
    447  225a				   PrintKeyNext
    448  225a		       b1 54		      lda	(R1),y	; Get key letter
    449  225c		       c8		      iny		; Point to next byte always
    450  225d		       29 20		      and	#%00100000	; Check for last character in key work
    451  225f		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    452  2261
    453  2261		       98		      tya		; Trabsfer y to a for the addition
    454  2262		       18		      clc		; Table > 256 bytes
    455  2263		       65 54		      adc	R1
    456  2265		       85 54		      sta	R1
    457  2267		       a9 00		      lda	#0
    458  2269		       65 55		      adc	R1+1
    459  226b		       85 55		      sta	R1+1
    460  226d		       4c 51 22 	      jmp	PrintKeyLoop
    461  2270
    462  2270				   PrintKeyFound
    463  2270		       b1 54		      lda	(R1),y	; letter from key table
    464  2272		       48		      pha		; Save it for later check
    465  2273		       09 20		      ora	#%00100000	; Force it to lower case
    466  2275		       20 c8 19 	      jsr	VOUTCH	; Print it out
    467  2278		       c8		      iny		; Point to next character
    468  2279		       68		      pla		; Restore the value
    469  227a		       29 20		      and	#%00100000	; Check if it was last char in keyword
    470  227c		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    471  227e
    472  227e		       68		      pla		; Restore the x and y values
    473  227f		       aa		      tax
    474  2280		       68		      pla
    475  2281		       a8		      tay
    476  2282
    477  2282				   PrintChkRem
    478  2282		       a9 0a		      lda	#kRem
    479  2284		       c5 52		      cmp	R0
    480  2286		       d0 11		      bne	PrintKeyDone
    481  2288				   PrintKeyRem
    482  2288		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    483  228a		       85 5e		      sta	PrtFrom
    484  228c		       a5 5a		      lda	dpl+1
    485  228e		       85 5f		      sta	PrtFrom+1
    486  2290		       a9 00		      lda	#0
    487  2292		       8d 10 42 	      sta	PrtTerm
    488  2295		       20 3f 21 	      jsr	PrtLoop
    489  2298		       88		      dey		; point back to the terminating null value
    490  2299				   PrintKeyDone
    491  2299		       4c f2 21 	      jmp	PrintProgNext
    492  229c							;==================================================================================================================
    493  229c							;Print Variable, number or operator
    494  229c				   PrintProgOperator
    495  229c		       b1 59		      lda	(dpl),y
    496  229e		       c8		      iny
    497  229f		       ca		      dex
    498  22a0		       8e a1 1c 	      stx	printStorage+2
    499  22a3		       a2 00		      ldx	#0
    500  22a5				   PrintOprLoop
    501  22a5		       dd 52 1a 	      cmp	OperValues,x
    502  22a8		       f0 03		      beq	PrintOprFound
    503  22aa		       e8		      inx
    504  22ab		       d0 f8		      bne	PrintOprLoop
    505  22ad				   PrintOprFound
    506  22ad		       8a		      txa
    507  22ae		       0a		      asl
    508  22af		       aa		      tax
    509  22b0		       bd 24 1a 	      lda	Operators,x
    510  22b3		       20 c8 19 	      jsr	VOUTCH
    511  22b6		       e8		      inx
    512  22b7		       bd 24 1a 	      lda	Operators,x
    513  22ba		       f0 03		      beq	PrintOprDone
    514  22bc		       20 c8 19 	      jsr	VOUTCH
    515  22bf				   PrintOprDone
    516  22bf		       ae a1 1c 	      ldx	printStorage+2
    517  22c2		       4c f2 21 	      jmp	PrintProgNext
    518  22c5
    519  22c5							;=================================================================================================================
    520  22c5							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    521  22c5							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    522  22c5							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    523  22c5							;tVhat 	    equ     155 		   ; Variable ^
    524  22c5							;tVhash	    equ     156 		   ; Variable #
    525  22c5							;tVat		    equ     157 		   ; Variable @ = 0
    526  22c5				   PrintProgVariable
    527  22c5		       b1 59		      lda	(dpl),y
    528  22c7		       c8		      iny
    529  22c8		       ca		      dex
    530  22c9		       c9 9b		      cmp	#tVhat
    531  22cb		       d0 04		      bne	PrintProgChkHash
    532  22cd		       a9 5e		      lda	#'^
    533  22cf		       d0 15		      bne	PrintTheVar
    534  22d1				   PrintProgChkHash
    535  22d1		       c9 9c		      cmp	#tVhash
    536  22d3		       d0 04		      bne	PrintProgChkAt
    537  22d5		       a9 23		      lda	#'#
    538  22d7		       d0 0d		      bne	PrintTheVar
    539  22d9				   PrintProgChkAt
    540  22d9		       c9 9d		      cmp	#tVat
    541  22db		       d0 04		      bne	PrintProgVarLetter
    542  22dd		       a9 40		      lda	#'@
    543  22df		       d0 05		      bne	PrintTheVar
    544  22e1				   PrintProgVarLetter
    545  22e1		       29 7f		      and	#%01111111
    546  22e3		       18		      clc
    547  22e4		       69 41		      adc	#'A
    548  22e6				   PrintTheVar
    549  22e6		       20 c8 19 	      jsr	VOUTCH
    550  22e9		       4c f2 21 	      jmp	PrintProgNext
    551  22ec
    552  22ec
    553  22ec							;==================================================================================================
    554  22ec							; Size of print functions
    555  22ec		       02 c5	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  22ec					      include	"mem.asm"
      1  22ec							;===================================================================
      2  22ec							;This file contains the memory allocation and free functions
      3  22ec							;in herant in this is the management of free memory in the system
      4  22ec							; the interface to these functions
      5  22ec							; a,x returns or provides the low hi bytes of the managed addresses
      6  22ec							; This uses the programend, to memory end as the area to manage
      7  22ec							;===================================================================
      8 U355b					      Seg.u	TBData
      9 U355b							;
     10 U355b							;=====================================================
     11 U355b							;Pointers for memory Management
     12 U355b							;Allocated block are not chained but can be followed for all memory by the associated length
     13 U355b							; Mem block format is
     14 U355b							;	 0-1   pointer to next block for free blocks
     15 U355b							;	 0-1   for allocated blocks
     16 U355b							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     17 U355b							;	   1   refrence counter ... lol only up to 256 but it is something
     18 U355b							;	 2-3   length constant for exevy type of memory block
     19 U355b							; Memory is recombined as it is released
     20 U355b							; The memory manager is not interupted durring allocation
     21 U355b							; or freeing of memory
     22 U355b							;====================================================
     23 U355b		       00 00	   MemFreeList ds	2	; list of free blocks of memory
     24 U355d		       00 00	   MemR0      ds	2	; source for copy/move/Init
     25 U355f		       00 00	   MemR1      ds	2	; Destination for copy/move
     26 U3561							;=====================================================
     27  22ec					      Seg	Code
     28  22ec							;=====================================================
     29  22ec				   MemInit
     30  22ec		       a9 22		      lda	#FreeMemStart&$FF
     31  22ee		       8d 18 42 	      sta	ProgramStart
     32  22f1		       8d 1a 42 	      sta	ProgramEnd
     33  22f4		       a9 42		      lda	#FreeMemStart>>8
     34  22f6		       8d 19 42 	      sta	ProgramStart+1
     35  22f9		       8d 1b 42 	      sta	ProgramEnd+1
     36  22fc
     37  22fc		       20 06 23 	      jsr	GetSizes
     38  22ff		       20 11 23 	      jsr	MemFree
     39  2302		       20 29 23 	      jsr	MemUsed
     40  2305				   MemInitEnd
     41  2305		       60		      rts
     42  2306
     43  2306
     44  2306							;
     45  2306							;=====================================================
     46  2306							; This function might go away eventually, but was
     47  2306							; added to provide data for other pieces of code.
     48  2306							; It has some ties to the operating environment that
     49  2306							; will need to be customized for the target system.
     50  2306							;
     51  2306				   GetSizes
     52  2306							;
     53  2306							; Here is machine specific code to get the highest
     54  2306							; memory location that can be used by BASIC.
     55  2306							;
     56  2306				  -	      if	ProgramStart < $2000
     57  2306				  -	      lda	#$ff
     58  2306				  -	      sta	HighMem	;$13ff for KIM-1
     59  2306				  -	      sta	MemFreeList
     60  2306				  -	      lda	#$DE	;#$13
     61  2306				  -	      sta	HighMem+1
     62  2306				  -	      sta	MemFreeList+1
     63  2306					      else
     64  2306		       a9 ff		      lda	#$ff
     65  2308		       8d 1c 42 	      sta	HighMem	;$CFFF otherwise
     66  230b		       a9 cf		      lda	#$cf
     67  230d		       8d 1d 42 	      sta	HighMem+1
     68  2310					      endif
     69  2310		       60		      rts
     70  2311							;
     71  2311							; This computes the available memory remaining.
     72  2311							;
     73  2311				   MemFree
     74  2311		       38		      sec
     75  2312		       ad 1c 42 	      lda	HighMem
     76  2315		       ed 1a 42 	      sbc	ProgramEnd
     77  2318		       8d 20 42 	      sta	FreeMem
     78  231b		       85 52		      sta	R0
     79  231d		       ad 1d 42 	      lda	HighMem+1
     80  2320		       ed 1b 42 	      sbc	ProgramEnd+1
     81  2323		       8d 21 42 	      sta	FreeMem+1
     82  2326		       85 53		      sta	R0+1
     83  2328		       60		      rts
     84  2329							;
     85  2329							; This computes the size of the current user program.
     86  2329							;
     87  2329				   MemUsed
     88  2329		       38		      sec
     89  232a		       ad 1a 42 	      lda	ProgramEnd
     90  232d		       ed 18 42 	      sbc	ProgramStart
     91  2330		       8d 1e 42 	      sta	UsedMem
     92  2333		       85 52		      sta	R0
     93  2335		       ad 1b 42 	      lda	ProgramEnd+1
     94  2338		       ed 19 42 	      sbc	ProgramStart+1
     95  233b		       8d 1f 42 	      sta	UsedMem+1
     96  233e		       85 53		      sta	R0+1
     97  2340							;
     98  2340		       60		      rts
     99  2341							;
    100  2341							;=====================================================
    101  2341							; Set a block of memory to a value
    102  2341		       8a	   iSetBlock  txa
    103  2342		       48		      pha
    104  2343		       98		      tya
    105  2344		       48		      pha
    106  2345		       20 cb 2b 	      jsr	popR0	; the address to write to
    107  2348		       a5 52		      lda	R0
    108  234a		       85 59		      sta	dpl
    109  234c		       a5 53		      lda	R0+1
    110  234e		       85 5a		      sta	dpl+1
    111  2350		       20 e3 2b 	      jsr	popR1	; Number of bytes to write
    112  2353		       20 cb 2b 	      jsr	popR0	; Get the value to store into memory
    113  2356		       20 40 29 	      jsr	getILByte
    114  2359		       85 58		      sta	R2	; store the data type into R2
    115  235b		       c9 a4		      cmp	#tInteger
    116  235d		       f0 08		      beq	memset	; skip this if we have an integer
    117  235f		       a5 52		      lda	R0	; Revers the order so they can be copied in correct order
    118  2361		       a6 53		      ldx	R0+1
    119  2363		       86 52		      stx	R0
    120  2365		       85 53		      sta	R0+1
    121  2367
    122  2367				   memset
    123  2367		       a0 00		      ldy	#0	; Set for length of block to copy
    124  2369		       a2 00		      ldx	#0	; set for number of block of 256 to copy
    125  236b
    126  236b		       a5 58	   iSetBlockLoop lda	R2	; Get Datatype
    127  236d		       c9 a2		      cmp	#tByte
    128  236f		       f0 09		      beq	iSetBlockB
    129  2371
    130  2371		       a5 52	   iSetBlockW lda	R0
    131  2373		       91 59		      sta	(dpl),y
    132  2375		       20 8a 23 	      jsr	iSetBlockEnd
    133  2378		       f0 09		      beq	iSetBlockComplete
    134  237a
    135  237a		       a5 53	   iSetBlockB lda	R0+1
    136  237c		       91 59		      sta	(dpl),y
    137  237e		       20 8a 23 	      jsr	iSetBlockEnd
    138  2381		       d0 e8		      bne	iSetBlockLoop
    139  2383
    140  2383				   iSetBlockComplete
    141  2383		       68		      pla
    142  2384		       a8		      tay
    143  2385		       68		      pla
    144  2386		       aa		      tax
    145  2387		       4c b1 02 	      jmp	NextIL
    146  238a							;
    147  238a							; Check if we have reached the end of the initialization/Copy
    148  238a							;
    149  238a		       c8	   iSetBlockEnd iny
    150  238b		       d0 03		      bne	iSetBlockEndChk
    151  238d		       e8		      inx
    152  238e		       e6 5a		      inc	dpl+1
    153  2390				   iSetBlockEndChk
    154  2390		       c4 54		      cpy	R1
    155  2392		       d0 02		      bne	iSetBlockEndExit
    156  2394		       e4 55		      cpx	R1+1
    157  2396				   iSetBlockEndExit
    158  2396		       60		      rts
    159  2397							;
    160  2397							;================================================================
    161  2397							; Copy a block of memory from one location to another
    162  2397							;
    163  2397		       8a	   iCopyBlock txa
    164  2398		       48		      pha
    165  2399		       98		      tya
    166  239a		       48		      pha
    167  239b		       20 cb 2b 	      jsr	popR0	; get the source address
    168  239e		       20 e3 2b 	      jsr	popR1	; Destination address
    169  23a1		       a5 54		      lda	R1
    170  23a3		       85 59		      sta	dpl
    171  23a5		       a5 55		      lda	R1+1
    172  23a7		       85 5a		      sta	dpl+1
    173  23a9		       20 e3 2b 	      jsr	popR1	; Number of bytes to copy
    174  23ac				   memcpy
    175  23ac		       a2 00		      ldx	#0
    176  23ae		       a0 00		      ldy	#0
    177  23b0				   iCopyBlockLoop
    178  23b0		       b1 52		      lda	(R0),y	;  Get the byte to copy
    179  23b2		       91 59		      sta	(dpl),y	;  Store the byte
    180  23b4		       c8		      iny
    181  23b5		       d0 05		      bne	iCopyChkEnd
    182  23b7		       e8		      inx
    183  23b8		       e6 53		      inc	R0+1
    184  23ba		       e6 5a		      inc	dpl+1
    185  23bc		       c4 54	   iCopyChkEnd cpy	R1
    186  23be		       d0 f0		      bne	iCopyBlockLoop
    187  23c0		       e4 55		      cpx	R1+1
    188  23c2		       d0 ec		      bne	iCopyBlockLoop
    189  23c4				   iCopyBlockDone
    190  23c4		       68		      pla
    191  23c5		       a8		      tay
    192  23c6		       68		      pla
    193  23c7		       aa		      tax
    194  23c8		       4c b1 02 	      jmp	NextIL
    195  23cb							;
    196  23cb							;=============================================================================
    197  23cb							; Compare memory block location
    198  23cb							; returns on the stack
    199  23cb							; 0 - equals
    200  23cb							; -1 - s1  <  s2
    201  23cb							; 1   s1  >  s2
    202  23cb		       8a	   iCmpBlock  txa
    203  23cc		       48		      pha
    204  23cd		       98		      tya
    205  23ce		       48		      pha
    206  23cf		       20 e3 2b 	      jsr	popR1	; Get the Source 2 pointer
    207  23d2		       a5 54		      lda	R1
    208  23d4		       85 59		      sta	dpl	; store the secon source in dpl
    209  23d6		       a5 55		      lda	R1+1
    210  23d8		       85 5a		      sta	dpl+1
    211  23da		       20 cb 2b 	      jsr	popR0	; Get the Source 1 pointer
    212  23dd		       20 e3 2b 	      jsr	popR1	; Get the length of the compare to do
    213  23e0		       a0 00		      ldy	#0
    214  23e2		       a2 00		      ldx	#0
    215  23e4		       4c f1 23 	      jmp	iCmpCheckEnd
    216  23e7
    217  23e7		       b1 59	   iCmpLoop   lda	(dpl),y
    218  23e9		       d1 52		      cmp	(R0),y
    219  23eb		       d0 19		      bne	iCmpDone
    220  23ed		       c8		      iny
    221  23ee		       d0 01		      bne	iCmpCheckEnd
    222  23f0		       e8		      inx
    223  23f1				   iCmpCheckEnd
    224  23f1		       c4 54		      cpy	R1
    225  23f3		       d0 f2		      bne	iCmpLoop
    226  23f5		       e4 55		      cpx	R1+1
    227  23f7		       d0 ee		      bne	iCmpLoop
    228  23f9		       a5 00		      lda	0
    229  23fb		       85 53		      sta	R0+1
    230  23fd		       85 52		      sta	R0
    231  23ff				   iCmpReturn
    232  23ff		       68		      pla
    233  2400		       a8		      tay
    234  2401		       68		      pla
    235  2402		       aa		      tax
    236  2403		       4c f7 06 	      jmp	pushR0nextIl
    237  2406
    238  2406				   iCmpDone
    239  2406		       90 0a		      bcc	iCmpGreater
    240  2408				   iCmpLess
    241  2408		       a9 00		      lda	#0
    242  240a		       85 53		      sta	R0+1
    243  240c		       a9 01		      lda	#1
    244  240e		       85 52		      sta	R0
    245  2410		       d0 ed		      bne	iCmpReturn
    246  2412				   iCmpGreater
    247  2412		       a9 ff		      lda	#-1
    248  2414		       85 52		      sta	R0
    249  2416		       85 53		      sta	R0+1
    250  2418		       d0 e5		      bne	iCmpReturn
    251  241a
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  241a					      include	"gosub.asm"
      1  241a					      seg	Code
      2  241a
      3  241a							; Gosub and return related functions
      4  241a							;==========================================================
      5  241a							; Push the current math stack frame onto the gosub stack
      6  241a				   iPushMathStack
      7  241a		       98		      tya
      8  241b		       48		      pha
      9  241c		       a4 4d		      ldy	GOSUBSTACKPTR
     10  241e		       a5 4a		      lda	MATHSTACKPTR
     11  2420		       91 4b		      sta	(GOSUBSTACK),y
     12  2422		       a9 00		      lda	#0
     13  2424		       c8		      iny
     14  2425		       91 4b		      sta	(GOSUBSTACK),y
     15  2427		       c8		      iny
     16  2428		       91 4b		      sta	(GOSUBSTACK),y
     17  242a		       c8		      iny
     18  242b		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  242d		       91 4b		      sta	(GOSUBSTACK),y
     20  242f		       c8		      iny
     21  2430		       84 4d		      sty	GOSUBSTACKPTR
     22  2432		       68		      pla
     23  2433		       a8		      tay
     24  2434		       4c b1 02 	      jmp	NextIL
     25  2437							;
     26  2437							;==========================================================
     27  2437							; Increment parameter count. Assume Stack frame is top of stack
     28  2437				   iIncParmCount
     29  2437		       98		      tya
     30  2438		       48		      pha
     31  2439
     32  2439		       a4 4d		      ldy	GOSUBSTACKPTR
     33  243b		       88		      dey
     34  243c		       88		      dey
     35  243d		       88		      dey
     36  243e		       b1 4b		      lda	(GOSUBSTACK),y
     37  2440		       18		      clc
     38  2441		       69 01		      adc	#1
     39  2443		       91 4b		      sta	(GOSUBSTACK),y
     40  2445
     41  2445		       68		      pla
     42  2446		       a8		      tay
     43  2447		       4c b1 02 	      jmp	NextIL
     44  244a							;
     45  244a							;==========================================================
     46  244a							;Restore the math stack frame
     47  244a		       20 50 24    iPopMathStack jsr	PopMathStackNow
     48  244d		       4c b1 02 	      jmp	NextIL
     49  2450
     50  2450				   PopMathStackNow
     51  2450		       98		      tya
     52  2451		       48		      pha
     53  2452
     54  2452		       a4 4d		      ldy	GOSUBSTACKPTR
     55  2454		       88		      dey
     56  2455		       b1 4b		      lda	(GOSUBSTACK),y
     57  2457		       c9 05		      cmp	#GOSUB_STACK_FRAME
     58  2459		       d0 09		      bne	iPopMathStackNoFrame
     59  245b		       88		      dey
     60  245c		       88		      dey
     61  245d		       88		      dey
     62  245e		       b1 4b		      lda	(GOSUBSTACK),y
     63  2460		       85 4a		      sta	MATHSTACKPTR
     64  2462		       84 4d		      sty	GOSUBSTACKPTR
     65  2464
     66  2464				   iPopMathStackNoFrame
     67  2464
     68  2464		       68		      pla
     69  2465		       a8		      tay
     70  2466		       60		      rts
     71  2467
     72  2467
     73  2467							;==========================================================
     74  2467							; Push the current math stack information onto the gosub stack
     75  2467				   iSaveMathStack
     76  2467		       98		      tya
     77  2468		       48		      pha
     78  2469
     79  2469		       a4 4d		      ldy	GOSUBSTACKPTR
     80  246b		       a5 4a		      lda	MATHSTACKPTR
     81  246d		       91 4b		      sta	(GOSUBSTACK),y
     82  246f		       a5 48		      lda	MATHSTACK
     83  2471		       c8		      iny
     84  2472
     85  2472		       91 4b		      sta	(GOSUBSTACK),y
     86  2474		       c8		      iny
     87  2475
     88  2475		       a5 49		      lda	MATHSTACK+1
     89  2477		       91 4b		      sta	(GOSUBSTACK),y
     90  2479		       c8		      iny
     91  247a
     92  247a		       a9 06		      lda	#GOSUB_STACK_SAVE
     93  247c		       91 4b		      sta	(GOSUBSTACK),y
     94  247e		       c8		      iny
     95  247f
     96  247f		       84 4d		      sty	GOSUBSTACKPTR
     97  2481
     98  2481		       68		      pla
     99  2482		       a8		      tay
    100  2483		       4c b1 02 	      jmp	NextIL
    101  2486							;
    102  2486							;==========================================================
    103  2486							;Restore the math stack information from the gosub stack
    104  2486				   iRestoreMathStack
    105  2486		       98		      tya
    106  2487		       48		      pha
    107  2488
    108  2488		       a5 4a		      lda	MATHSTACKPTR
    109  248a		       85 58		      sta	R2	; save the current offset for whatever task to R2
    110  248c
    111  248c		       a4 4d		      ldy	GOSUBSTACKPTR
    112  248e		       88		      dey
    113  248f		       b1 4b		      lda	(GOSUBSTACK),y
    114  2491		       c9 06		      cmp	#GOSUB_STACK_SAVE
    115  2493		       d0 16		      bne	iPopMathStack_Err
    116  2495		       88		      dey
    117  2496		       b1 4b		      lda	(GOSUBSTACK),y
    118  2498		       85 49		      sta	MATHSTACK+1
    119  249a		       88		      dey
    120  249b		       b1 4b		      lda	(GOSUBSTACK),y
    121  249d		       85 48		      sta	MATHSTACK
    122  249f		       88		      dey
    123  24a0		       b1 4b		      lda	(GOSUBSTACK),y
    124  24a2		       85 4a		      sta	MATHSTACKPTR
    125  24a4		       84 4d		      sty	GOSUBSTACKPTR
    126  24a6
    127  24a6		       68		      pla
    128  24a7		       a8		      tay
    129  24a8		       4c b1 02 	      jmp	NextIL
    130  24ab
    131  24ab				   iPopMathStack_Err
    132  24ab		       68		      pla
    133  24ac		       a8		      tay
    134  24ad		       a9 00		      lda	#0
    135  24af		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    136  24b1		       4c 5e 06 	      jmp	iErr2
    137  24b4							;=========================================
    138  24b4							; For functions and tasks the variable address of # means
    139  24b4							; a passed parameter so #[0] is the first parameter etc
    140  24b4							; will try for a better way later
    141  24b4							;=====================================================
    142  24b4							; On entry il, branch to if function
    143  24b4							;	    il+1, value to be returned or not true or false
    144  24b4							;
    145  24b4							; Return from GOSUB  or function function
    146  24b4							; format   RSTR 0   --- return form gosub
    147  24b4							;	    RSTR 1   --- return from Function
    148  24b4							;
    149  24b4		       20 40 29    iRSTR      jsr	getILByte	; get where to go if 0 = gosub/1=function call
    150  24b7		       8d 14 42 	      sta	offset
    151  24ba		       20 23 2b 	      jsr	saveIL	; for later jump if needed add extra entry to	the return stack
    152  24bd
    153  24bd		       20 7c 2b 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    154  24c0		       85 54		      sta	R1	; keep the type of call returning from
    155  24c2		       b0 2b		      bcs	iRSTRErr	; stack underflow error possible
    156  24c4
    157  24c4		       20 40 29 	      jsr	getILByte	; get if a value is being returned
    158  24c7
    159  24c7		       48		      pha		; save if a value was passed to be returned
    160  24c8
    161  24c8		       c9 00		      cmp	#0	; yes attemping to return a value
    162  24ca		       f0 03		      beq	iRSTRPOP	; no value to return
    163  24cc		       20 cb 2b 	      jsr	popR0	; Get the value from the stack save if needed
    164  24cf
    165  24cf				   iRSTRPOP
    166  24cf		       20 50 24 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    167  24d2		       a5 54		      lda	R1	; called as a statement ?
    168  24d4		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    169  24d6		       f0 13		      beq	iRSTRExit
    170  24d8
    171  24d8		       68		      pla		; get back if value returned or not
    172  24d9		       c9 01		      cmp	#1	; we have a value to return
    173  24db		       f0 05		      beq	iRSTRVALUE
    174  24dd
    175  24dd		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    176  24df		       4c f3 04 	      jmp	iSAVErr2	; jump to general error reporting function
    177  24e2
    178  24e2				   iRSTRVALUE
    179  24e2		       20 39 2b 	      jsr	pushR0	; return value back to top of stack
    180  24e5		       20 2e 2b 	      jsr	restoreIL	; get the correct il
    181  24e8		       4c bc 0b 	      jmp	tstBranch	; And called as a function
    182  24eb
    183  24eb				   iRSTRExit
    184  24eb		       68		      pla		; throw away gosub/func flag
    185  24ec		       4c b1 02 	      jmp	NextIL
    186  24ef
    187  24ef				   iRSTRNORETURNVALUE
    188  24ef
    189  24ef
    190  24ef		       ad a3 35    iRSTRErr   lda	taskPtr	; Check if this is task zero
    191  24f2		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    192  24f4		       a5 56		      lda	MQ
    193  24f6		       d0 03		      bne	taskRet
    194  24f8		       20 fa 2d 	      jsr	pushFalse	; the result code by default is 0
    195  24fb				   taskRet
    196  24fb		       4c 63 27 	      jmp	iETask	; not task zero then do a task end instead
    197  24fe				   taskZeroEnd
    198  24fe		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    199  2500		       4c f3 04 	      jmp	iSAVErr2
    200  2503							;
    201  2503							;==========================================================================================
    202  2503							; Find the next gosub function parameter info	position on the stack
    203  2503							; Returns y = index and c set if found clera c otherwise
    204  2503		       a4 4d	   GosubFindParms ldy	GOSUBSTACKPTR	;Get the Pointer to the top of stack
    205  2505		       88		      dey		;Point to stack entry type
    206  2506
    207  2506							;Veryify the stack size and position for the call
    208  2506							;Loops here until it finds a GOSUB with value entry or gosub-rtn entry
    209  2506
    210  2506		       c0 00	   GosubFindLoop cpy	#0	;If we reach the top of the stack then no parametrs
    211  2508		       f0 21		      beq	GosubNotFunc
    212  250a		       c0 10		      cpy	#GOSUBSTACKSIZE	;Tst if we are outside the stack size
    213  250c		       b0 1d		      bcs	GosubNotFunc	;Not valid
    214  250e
    215  250e							;Look for the	 GOSUG_RTN_VALUE stack position
    216  250e		       b1 4b		      lda	(GOSUBSTACK),y	;Get the type of call - if it is not a fn call error
    217  2510		       c9 01		      cmp	#GOSUB_RTN	;if we find this then this function had no parameters
    218  2512		       f0 17		      beq	GosubNotFunc
    219  2514
    220  2514		       c9 81		      cmp	#GOSUB_RTN_VALUE
    221  2516		       f0 07		      beq	GosubParmFnd	;Skip any non Gosub related entries
    222  2518		       88		      dey
    223  2519		       88		      dey
    224  251a		       88		      dey
    225  251b		       88		      dey
    226  251c		       4c 06 25 	      jmp	GosubFindLoop
    227  251f
    228  251f		       88	   GosubParmFnd dey		;Point to hopefully Math Stack frame information
    229  2520		       88		      dey
    230  2521		       88		      dey
    231  2522		       88		      dey
    232  2523
    233  2523		       b1 4b		      lda	(GOSUBSTACK),y	;This should be a stack frame pointer
    234  2525		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    235  2527		       d0 02		      bne	GosubNotFunc	;No parameters passed but expected
    236  2529		       38		      sec
    237  252a		       60		      rts
    238  252b
    239  252b		       18	   GosubNotFunc clc
    240  252c		       60		      rts
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  252d					      include	"tasks.asm"
      1  252d							;=====================================================
      2  252d							; Tiny Basic IL task management
      3  252d							; Data required by task management
      4  252d							; currently each context is about 30 bytes and is swapped
      5  252d							; into and out of page zero on each task switch....
      6  252d							; LOL yes it is slow, but works for this iteration.
      7  252d							;
      8  252d
      9  252d					      Seg	Code
     10  252d							;=====================================================
     11  252d							; Sets the pointers to the math,IL and gosub stacks
     12  252d							; Creates the initial Context for each task slot
     13  252d				   taskSetStacks
     14  252d		       a9 a3		      lda	#mathStack&$FF
     15  252f		       85 48		      sta	MATHSTACK
     16  2531		       a9 36		      lda	#mathStack>>8
     17  2533		       85 49		      sta	MATHSTACK+1
     18  2535
     19  2535		       a9 33		      lda	#ilStack&$ff
     20  2537		       85 45		      sta	ILSTACK
     21  2539		       a9 38		      lda	#ilStack>>8
     22  253b		       85 46		      sta	ILSTACK+1
     23  253d
     24  253d		       a9 1b		      lda	#gosubStack&$FF
     25  253f		       85 4b		      sta	GOSUBSTACK
     26  2541		       a9 3c		      lda	#gosubStack>>8
     27  2543		       85 4c		      sta	GOSUBSTACK+1
     28  2545
     29  2545		       a9 9b		      lda	#variableStack&$FF
     30  2547		       85 41		      sta	VARIABLES
     31  2549		       a9 3e		      lda	#variableStack>>8
     32  254b		       85 42		      sta	VARIABLES+1
     33  254d		       a2 0a		      ldx	#TASKCOUNT
     34  254f		       a0 00		      ldy	#0
     35  2551		       20 f7 27 	      jsr	ContextSave	; Save the Task 0 context
     36  2554
     37  2554		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  2556		       b0 3a		      bcs	taskSetDone
     39  2558
     40  2558		       a5 4b		      lda	GOSUBSTACK
     41  255a		       18		      clc
     42  255b		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  255d		       85 4b		      sta	GOSUBSTACK
     44  255f		       a5 4c		      lda	GOSUBSTACK+1
     45  2561		       69 00		      adc	#0
     46  2563		       85 4c		      sta	GOSUBSTACK+1
     47  2565
     48  2565		       a5 45		      lda	ILSTACK	; must be less than 256
     49  2567		       18		      clc
     50  2568		       69 64		      adc	#ILSTACKSIZE*2
     51  256a		       85 45		      sta	ILSTACK
     52  256c		       a5 46		      lda	ILSTACK+1
     53  256e		       69 00		      adc	#0
     54  2570		       85 46		      sta	ILSTACK+1
     55  2572
     56  2572		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  2574		       18		      clc
     58  2575		       69 28		      adc	#MATHSTACKSIZE*2
     59  2577		       85 48		      sta	MATHSTACK
     60  2579		       a5 49		      lda	MATHSTACK+1
     61  257b		       69 00		      adc	#0
     62  257d		       85 49		      sta	MATHSTACK+1
     63  257f
     64  257f		       a5 41		      lda	VARIABLES	; must be less than 256
     65  2581		       18		      clc
     66  2582		       69 4a		      adc	#VARIABLESSIZE*2
     67  2584		       85 41		      sta	VARIABLES
     68  2586		       a5 42		      lda	VARIABLES+1
     69  2588		       69 00		      adc	#0
     70  258a		       85 42		      sta	VARIABLES+1
     71  258c		       20 f7 27 	      jsr	ContextSave
     72  258f		       4c 54 25 	      jmp	taskSetLoop
     73  2592
     74  2592				   taskSetDone
     75  2592		       a0 00		      ldy	#0	; reload the main loop context
     76  2594		       20 06 28 	      jsr	ContextLoad
     77  2597		       60		      rts
     78  2598							;
     79  2598							;============================================================
     80  2598							; Saves the io block to the context
     81  2598
     82  2598
     83  2598		       98	   SaveIOblock tya
     84  2599		       48		      pha
     85  259a		       8a		      txa
     86  259b		       48		      pha
     87  259c
     88  259c
     89  259c
     90  259c		       68		      pla
     91  259d		       aa		      tax
     92  259e		       68		      pla
     93  259f		       a8		      tay
     94  25a0		       60		      rts
     95  25a1
     96  25a1							;
     97  25a1							;=====================================================
     98  25a1							; In some error cases the math stacks may be left pointing to the wrong stack
     99  25a1							; This function will reset those stack addresses but not the actual pointer
    100  25a1				   taskResetStacks
    101  25a1		       a0 00		      ldy	#0
    102  25a3		       20 06 28 	      jsr	ContextLoad
    103  25a6		       4c 2d 25 	      jmp	taskSetStacks
    104  25a9							;
    105  25a9							;=====================================================
    106  25a9							; Clear all task entries and task stacks
    107  25a9		       98	   taskReset  tya		; Save Y
    108  25aa		       48		      pha
    109  25ab		       a9 01		      lda	#1
    110  25ad		       8d a2 36 	      sta	taskCounter	; Set number of active tasks to 1
    111  25b0		       ac a3 35 	      ldy	taskPtr	; Set the active task to 0 MAIN
    112  25b3		       c0 00		      cpy	#0	; check if we are the main context
    113  25b5		       f0 08		      beq	taskResetCont	; if we are just continue
    114  25b7
    115  25b7		       a0 00		      ldy	#0	; else we need to switch to the main context
    116  25b9		       8c a3 35 	      sty	taskPtr
    117  25bc		       20 06 28 	      jsr	ContextLoad	; load the System Task context
    118  25bf				   taskResetCont
    119  25bf		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    120  25c1
    121  25c1				   taskResetLoop
    122  25c1		       a9 00		      lda	#TASKINACTIVE
    123  25c3		       99 a4 35 	      sta	taskTable,y	; Ensure that the task is made inactive
    124  25c6		       18		      clc
    125  25c7		       98		      tya
    126  25c8		       69 19		      adc	#CONTEXTLEN
    127  25ca		       a8		      tay
    128  25cb		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    129  25cd		       90 f2		      bcc	taskResetLoop	; Go for more
    130  25cf
    131  25cf				   taskResetComplete
    132  25cf
    133  25cf		       68		      pla		; Restore y
    134  25d0		       a8		      tay
    135  25d1		       60		      rts
    136  25d2
    137  25d2							;
    138  25d2							;======================================================
    139  25d2							; iTaskSwitch	 switch to new task if not interrupt and
    140  25d2							;		 count is exceded for task time slice gets here
    141  25d2							;		 when time slice has reached zero
    142  25d2							;
    143  25d2		       98	   iTaskSwitch tya
    144  25d3		       48		      pha
    145  25d4
    146  25d4		       ad a0 36 	      lda	taskResetValue	; Always reset the counter value
    147  25d7		       8d 9e 36 	      sta	taskCurrentCycles	; Update the counter with the new value
    148  25da		       ce 9f 36 	      dec	taskCurrentCycles+1	; dec high order byte
    149  25dd		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    150  25df
    151  25df		       ad a1 36 	      lda	taskResetValue+1
    152  25e2		       8d 9f 36 	      sta	taskCurrentCycles+1
    153  25e5
    154  25e5		       ad 3b 19 	      lda	IRQPending	; Skip this if we are processing an irq
    155  25e8		       0d 16 42 	      ora	taskIOPending	; If set then don't switch
    156  25eb		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    157  25ed
    158  25ed		       ad a2 36    iTaskMain  lda	taskCounter	; Number of tasks
    159  25f0		       c9 01		      cmp	#1	; if there is only one task must be main
    160  25f2		       d0 07		      bne	itasknext	; if it some other number continue to next
    161  25f4
    162  25f4		       ac a3 35 	      ldy	taskPtr	; check if we have not just ended some other task
    163  25f7		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    164  25f9		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    165  25fb							;
    166  25fb							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    167  25fb							;
    168  25fb				   itasknext
    169  25fb		       ac a3 35 	      ldy	taskPtr
    170  25fe		       20 f7 27 	      jsr	ContextSave	; Save the current context, y points to next context
    171  2601				   itaskLoop
    172  2601		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    173  2603		       90 04		      bcc	iTaskNextChk
    174  2605
    175  2605		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    176  2607		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    177  2609
    178  2609				   iTaskNextChk
    179  2609		       b9 a4 35 	      lda	taskTable,y	; there is always at least one entry in table
    180  260c		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    181  260e		       18	   iTaskNext  clc
    182  260f		       98		      tya
    183  2610		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    184  2612		       a8		      tay
    185  2613		       4c 01 26 	      jmp	itaskLoop	; Check for busy entry
    186  2616
    187  2616		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    188  2618		       59 a4 35 	      eor	taskTable,y	; Check for anything waiting io
    189  261b		       d0 f1		      bne	iTaskNext
    190  261d		       20 06 28 	      jsr	ContextLoad	; load the next context
    191  2620		       8c a3 35 	      sty	taskPtr	; update the task pointer
    192  2623
    193  2623				   iTaskSwitchDone
    194  2623		       68		      pla
    195  2624		       a8		      tay
    196  2625		       60		      rts
    197  2626							;
    198  2626							;================================================================
    199  2626							; Task Set task number to line number to start
    200  2626							; on entry stack contains, type of line description and  memvector or linenumber
    201  2626							; Task Table structure:
    202  2626							;    byte 0	-   Active inactive
    203  2626							;    byte 1-2	-   Basic code line pointer
    204  2626							;    byte 3	-   Offset on current line
    205  2626		       98	   iTaskSet   tya		;preserve Y
    206  2627		       48		      pha		; push a
    207  2628		       20 e3 2b 	      jsr	popR1	; Get if compiled or line number expression
    208  262b		       20 cb 2b 	      jsr	popR0	; Get the line number to be saved
    209  262e
    210  262e
    211  262e
    212  262e		       ac a3 35 	      ldy	taskPtr	; find out where we are
    213  2631		       20 f7 27 	      jsr	ContextSave	; Save the current context
    214  2634
    215  2634							;Find the pointer to the line we need to start at
    216  2634		       a5 54		      lda	R1
    217  2636		       f0 0b		      beq	iTaskLineNum
    218  2638		       a5 52		      lda	R0
    219  263a		       85 4f		      sta	CURPTR
    220  263c		       a5 53		      lda	R0+1
    221  263e		       85 50		      sta	CURPTR+1
    222  2640		       4c 53 26 	      jmp	iTaskCont
    223  2643
    224  2643				   iTaskLineNum
    225  2643		       20 85 29 	      jsr	findLine	; Get the offset of the line to start task at
    226  2646		       f0 0b		      beq	iTaskCont
    227  2648
    228  2648		       ac a3 35 	      ldy	taskPtr	; Restore the original Context Error Exit
    229  264b		       20 06 28 	      jsr	ContextLoad
    230  264e
    231  264e		       68		      pla		; pop a - exit
    232  264f		       a8		      tay
    233  2650		       4c cf 0d 	      jmp	iSetIrqErr	; Bad line number provided
    234  2653
    235  2653				   iTaskCont
    236  2653		       20 c9 27 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    237  2656		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    238  2658
    239  2658		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    240  265a		       99 a4 35 	      sta	taskTable,y	; new task as active
    241  265d
    242  265d		       a5 4f		      lda	CURPTR
    243  265f		       48		      pha		; push a
    244  2660		       a5 50		      lda	CURPTR+1
    245  2662		       48		      pha		; push a
    246  2663
    247  2663		       20 06 28 	      jsr	ContextLoad	; load the context of the new task
    248  2666
    249  2666		       68		      pla		; pop a
    250  2667		       85 50		      sta	CURPTR+1
    251  2669		       68		      pla		; pop a
    252  266a		       85 4f		      sta	CURPTR
    253  266c		       a9 03		      lda	#3	; Offset to first instruction
    254  266e		       85 51		      sta	CUROFF
    255  2670
    256  2670		       a9 00		      lda	#0
    257  2672		       85 47		      sta	ILSTACKPTR
    258  2674		       85 4a		      sta	MATHSTACKPTR
    259  2676		       85 4d		      sta	GOSUBSTACKPTR
    260  2678		       a9 40		      lda	#GOSUBSTACKSIZE*4
    261  267a		       85 4e		      sta	MESSAGEPTR
    262  267c
    263  267c		       20 51 09 	      jsr	subVINIT	; Clear the variables
    264  267f
    265  267f		       a9 05		      lda	#STMT&$FF
    266  2681		       85 43		      sta	ILPC
    267  2683		       a9 31		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    268  2685		       85 44		      sta	ILPC+1
    269  2687
    270  2687		       98		      tya		; Save the new context offset to return to user
    271  2688		       48		      pha		; push a
    272  2689
    273  2689		       20 f7 27    itaskSetSave jsr	ContextSave	; save the updated context
    274  268c		       ee a2 36 	      inc	taskCounter	; Update the number of Tasks running
    275  268f
    276  268f		       ac a3 35 	      ldy	taskPtr
    277  2692		       20 06 28 	      jsr	ContextLoad	; restore the original context
    278  2695
    279  2695		       a9 00		      lda	#0	; Set the R0 upper to zero
    280  2697		       85 53		      sta	R0+1
    281  2699		       68		      pla		; Get the task pid we stored				 ; pop a
    282  269a		       85 52		      sta	R0	; Get the table entry value
    283  269c
    284  269c		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    285  269d		       a8		      tay
    286  269e
    287  269e		       4c f7 06 	      jmp	pushR0nextIl	; Push R0 and continue
    288  26a1				   iTaskNoEmpty
    289  26a1		       ac a3 35 	      ldy	taskPtr
    290  26a4		       20 06 28 	      jsr	ContextLoad
    291  26a7
    292  26a7		       68		      pla		; pop a    -- exit
    293  26a8		       a8		      tay
    294  26a9
    295  26a9		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    296  26ab		       a9 00		      lda	#0
    297  26ad		       4c 5e 06 	      jmp	iErr2
    298  26b0							;
    299  26b0							;===============================================================
    300  26b0							; Run the task whos PID is on the stack, preserve the stack
    301  26b0							;
    302  26b0				   iTaskEnable
    303  26b0		       98		      tya
    304  26b1		       48		      pha
    305  26b2		       20 e3 2b 	      jsr	popR1
    306  26b5		       20 b1 2b 	      jsr	pushR1
    307  26b8		       20 fd 28 	      jsr	ipc_getcontext	; get context pointer into mq
    308  26bb		       a0 00		      ldy	#0
    309  26bd		       b1 56		      lda	(MQ),y
    310  26bf		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    311  26c1		       09 80		      ora	#TASKACTIVE
    312  26c3		       91 56		      sta	(MQ),y
    313  26c5		       68		      pla
    314  26c6		       a8		      tay
    315  26c7		       4c b1 02 	      jmp	NextIL
    316  26ca
    317  26ca							;
    318  26ca							;===============================================================
    319  26ca							; Suspend the task whos PID  is on the stack, preserve the stack
    320  26ca							;
    321  26ca				   iTaskSuspend
    322  26ca		       98		      tya
    323  26cb		       48		      pha
    324  26cc		       20 e3 2b 	      jsr	popR1
    325  26cf		       20 b1 2b 	      jsr	pushR1
    326  26d2		       20 fd 28 	      jsr	ipc_getcontext	; get context pointer into mq
    327  26d5		       a0 00		      ldy	#0
    328  26d7		       b1 56		      lda	(MQ),y
    329  26d9		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    330  26db		       09 80		      ora	#TASKACTIVE
    331  26dd		       68		      pla
    332  26de		       a8		      tay
    333  26df		       4c b1 02 	      jmp	NextIL
    334  26e2
    335  26e2							;================================================================
    336  26e2							; Returns task Status
    337  26e2				   iTaskStat
    338  26e2		       98		      tya
    339  26e3		       48		      pha
    340  26e4		       20 f6 26 	      jsr	iTaskValid	; returns pointer to task entry
    341  26e7		       b9 a4 35 	      lda	taskTable,y
    342  26ea		       f0 05		      beq	iTaskStatExit
    343  26ec		       68		      pla
    344  26ed		       a8		      tay
    345  26ee		       4c 5f 0d 	      jmp	iTruth
    346  26f1				   iTaskStatExit
    347  26f1		       68		      pla
    348  26f2		       a8		      tay
    349  26f3		       4c 68 0d 	      jmp	iFalse
    350  26f6
    351  26f6							;
    352  26f6							;================================================================
    353  26f6							; Validate the task number on top of the stack
    354  26f6							; on exit y points to the requested task entry
    355  26f6							;
    356  26f6		       20 cb 2b    iTaskValid jsr	popR0	; get result of the multiply
    357  26f9		       a5 53		      lda	R0+1
    358  26fb		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    359  26fd		       a5 52		      lda	R0
    360  26ff		       c9 fa		      cmp	#TASKTABLELEN
    361  2701		       90 09		      bcc	iTaskIsValid
    362  2703
    363  2703		       68	   iTaskValidErr pla		;remove return address
    364  2704		       68		      pla
    365  2705		       a2 10		      ldx	#ERR_INVALID_PID
    366  2707		       a9 00		      lda	#0
    367  2709		       4c 5e 06 	      jmp	iErr2
    368  270c
    369  270c		       a8	   iTaskIsValid tay
    370  270d		       60		      rts
    371  270e							;
    372  270e							;================================================================
    373  270e							; Kill a running task, do nothing if already stopped
    374  270e		       20 f6 26    iTaskKill  jsr	iTaskValid
    375  2711		       a9 00		      lda	#0
    376  2713		       99 a4 35 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    377  2716							;
    378  2716							;================================================================
    379  2716							;Skip to next task
    380  2716				   iNTask
    381  2716		       a9 01		      lda	#1
    382  2718		       8d 9e 36 	      sta	taskCurrentCycles
    383  271b		       8d 9f 36 	      sta	taskCurrentCycles+1
    384  271e		       4c b1 02 	      jmp	NextIL
    385  2721							;
    386  2721							;=======================================================
    387  2721							; Wait for a task to complete
    388  2721				   iWTASK
    389  2721		       20 40 29 	      jsr	getILByte
    390  2724		       8d 14 42 	      sta	offset
    391  2727							;
    392  2727		       20 23 2b 	      jsr	saveIL	;in case of failure
    393  272a
    394  272a		       20 f6 26 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    395  272d		       b9 a4 35 	      lda	taskTable,y
    396  2730		       d0 03		      bne	iWTASKWAIT
    397  2732				   iWTASKEXITED
    398  2732		       4c b1 02 	      jmp	NextIL
    399  2735				   iWTASKWAIT
    400  2735		       20 39 2b 	      jsr	pushR0	; Push R0 back onto the stack
    401  2738		       a9 01		      lda	#1
    402  273a		       8d 9e 36 	      sta	taskCurrentCycles	; Give up the cycles
    403  273d		       8d 9f 36 	      sta	taskCurrentCycles+1
    404  2740		       20 2e 2b 	      jsr	restoreIL
    405  2743		       4c bc 0b 	      jmp	tstBranch
    406  2746							;
    407  2746							;=======================================================
    408  2746							; Set task io lock
    409  2746		       ee 16 42    iStartIO   inc	taskIOPending
    410  2749		       4c b1 02 	      jmp	NextIL
    411  274c							;
    412  274c							;=======================================================
    413  274c							; Release the io lock
    414  274c		       ad 16 42    iEndIO     lda	taskIOPending
    415  274f		       f0 03		      beq	iEndIOExit
    416  2751		       ce 16 42 	      dec	taskIOPending
    417  2754		       4c b1 02    iEndIOExit jmp	NextIL
    418  2757							;
    419  2757							;===============================================================
    420  2757							; Return the task PID
    421  2757				   iTASKPID
    422  2757		       a9 00		      lda	#0
    423  2759		       85 53		      sta	R0+1
    424  275b		       ad a3 35 	      lda	taskPtr
    425  275e		       85 52		      sta	R0
    426  2760		       4c f7 06 	      jmp	pushR0nextIl
    427  2763							;
    428  2763							;================================================================
    429  2763							; Terminate a task
    430  2763		       ac a3 35    iETask     ldy	taskPtr
    431  2766		       c0 00		      cpy	#0
    432  2768		       d0 03		      bne	iETaskCont
    433  276a		       4c e3 05 	      jmp	iFIN	; if the main task does a ETASK then stop
    434  276d				   iETaskCont
    435  276d		       a9 00		      lda	#TASKINACTIVE
    436  276f		       99 a4 35 	      sta	taskTable,y	; mark entry as free
    437  2772		       ce a2 36 	      dec	taskCounter	; reduce the number of active tasks
    438  2775		       a9 01		      lda	#1
    439  2777		       8d 9e 36 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    440  277a		       8d 9f 36 	      sta	taskCurrentCycles+1
    441  277d		       20 e4 27 	      jsr	TaskSetExitCode
    442  2780				   iETaskExit
    443  2780		       4c b1 02 	      jmp	NextIL
    444  2783							;================================================================
    445  2783							; make the current tasks math stack equal another tasks stack
    446  2783							; The task to get is stored on the math stack
    447  2783
    448  2783				   iTaskGetMathStack
    449  2783		       20 fe 2d 	      jsr	CopyStackR1	; Get the top of stack to R1
    450  2786		       20 fd 28 	      jsr	ipc_getcontext	; MQ now has the context address
    451  2789		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  278b		       b1 56		      lda	(MQ),y
    453  278d		       85 4a		      sta	MATHSTACKPTR
    454  278f		       a0 08		      ldy	#MATHSTACKPOS
    455  2791		       b1 56		      lda	(MQ),y
    456  2793		       85 48		      sta	MATHSTACK
    457  2795		       c8		      iny
    458  2796		       b1 56		      lda	(MQ),y
    459  2798		       85 49		      sta	MATHSTACK+1
    460  279a		       4c b1 02 	      jmp	NextIL
    461  279d							;==================================================================
    462  279d							; Updates the tasks math stack pointer with contents of R2
    463  279d							; PID is on top of the stack
    464  279d				   iTaskPutMathPtr
    465  279d		       20 fe 2d 	      jsr	CopyStackR1	; Get the top of stack to R1
    466  27a0		       20 fd 28 	      jsr	ipc_getcontext	; MQ now has the context address
    467  27a3		       a5 58		      lda	R2
    468  27a5		       a0 0a		      ldy	#MATHSTACKPTRPOS
    469  27a7		       91 56		      sta	(MQ),y
    470  27a9		       4c b1 02 	      jmp	NextIL
    471  27ac							;
    472  27ac							;================================================================
    473  27ac							; Set the time slice for each task
    474  27ac				   iSLICE
    475  27ac		       20 cb 2b 	      jsr	popR0
    476  27af		       a5 52		      lda	R0
    477  27b1		       8d a0 36 	      sta	taskResetValue
    478  27b4		       a5 53		      lda	R0+1
    479  27b6		       8d a1 36 	      sta	taskResetValue+1
    480  27b9		       d0 0b		      bne	iSliceSet
    481  27bb		       ee a1 36 	      inc	taskResetValue+1	; must be at least 1 high counter
    482  27be		       a9 01		      lda	#1
    483  27c0		       8d 9e 36 	      sta	taskCurrentCycles
    484  27c3		       8d 9f 36 	      sta	taskCurrentCycles+1
    485  27c6				   iSliceSet
    486  27c6		       4c b1 02 	      jmp	NextIL
    487  27c9							;================================================================
    488  27c9							; Find an empty slot in the taskTable
    489  27c9							; Return the index in y
    490  27c9							; on exit   c set if an empty slot is found
    491  27c9							;	     c clear if not found
    492  27c9							;================================================================
    493  27c9							;
    494  27c9		       ad a2 36    TaskEmpty  lda	taskCounter
    495  27cc		       c9 0a		      cmp	#TASKCOUNT
    496  27ce		       b0 10		      bcs	TaskNoSlot
    497  27d0		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    498  27d2				   TaskLoop
    499  27d2		       b9 a4 35 	      lda	taskTable,y
    500  27d5		       f0 0b		      beq	TaskEmptyFnd
    501  27d7		       98		      tya
    502  27d8		       18		      clc
    503  27d9		       69 19		      adc	#CONTEXTLEN
    504  27db		       a8		      tay
    505  27dc		       c0 fa		      cpy	#TASKTABLELEN
    506  27de		       90 f2		      bcc	TaskLoop	; Y is never zero
    507  27e0				   TaskNoSlot
    508  27e0		       18		      clc
    509  27e1		       60		      rts
    510  27e2				   TaskEmptyFnd
    511  27e2		       38		      sec
    512  27e3		       60		      rts
    513  27e4							;====================================================
    514  27e4							; Set the task exit code called from the return command
    515  27e4							; on entry stack top hold exit value
    516  27e4				   TaskSetExitCode
    517  27e4		       98		      tya
    518  27e5		       48		      pha
    519  27e6		       20 cb 2b 	      jsr	popR0
    520  27e9		       a0 48		      ldy	#TASKEXITCODE
    521  27eb		       a5 52		      lda	R0
    522  27ed		       91 41		      sta	(VARIABLES),y
    523  27ef		       c8		      iny
    524  27f0		       a5 53		      lda	R0+1
    525  27f2		       91 41		      sta	(VARIABLES),y
    526  27f4		       68		      pla
    527  27f5		       98		      tya
    528  27f6		       60		      rts
    529  27f7
    530  27f7							;
    531  27f7							;=====================================================
    532  27f7							; Save Context Store the context to the TASK Table
    533  27f7							; on entry y contains the task table entry to save to
    534  27f7							; on exit y points to next task table entry
    535  27f7							;	   x contains the number of bytes copied
    536  27f7		       a2 00	   ContextSave ldx	#0
    537  27f9		       c8		      iny		;inc past the task flags
    538  27fa		       b5 41	   ContextSvLoop lda	CONTEXT,x
    539  27fc		       99 a4 35 	      sta	taskTable,y
    540  27ff		       c8		      iny
    541  2800		       e8		      inx
    542  2801		       e0 18		      cpx	#[CONTEXTLEN-1]
    543  2803		       90 f5		      bcc	ContextSvLoop
    544  2805		       60		      rts
    545  2806							;
    546  2806							; Load Context transfer context from task table to the Current Context
    547  2806							; on entry y contains the task table entry to transfer
    548  2806							; on exit y points to the original task table entry
    549  2806							;	   x contains the number of bytes copied
    550  2806		       98	   ContextLoad tya
    551  2807		       48		      pha
    552  2808		       a2 00		      ldx	#0
    553  280a		       c8		      iny		;inc past the task flags
    554  280b		       b9 a4 35    ContextLDLoop lda	taskTable,y
    555  280e		       95 41		      sta	CONTEXT,x
    556  2810		       c8		      iny
    557  2811		       e8		      inx
    558  2812		       e0 18		      cpx	#[CONTEXTLEN-1]
    559  2814		       90 f5		      bcc	ContextLDLoop
    560  2816		       68		      pla
    561  2817		       a8		      tay
    562  2818		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  2819					      include	"ipc.asm"
      1  2819							;======================================================
      2  2819							; Inter process communications.
      3  2819							; Tasks may write/read integer messages among
      4  2819							; them selves.
      5  2819							; This uses each tasks gosub stack as a message queue
      6  2819							; Gosub calls start at the highest address and the
      7  2819							; msg queue starts at the highest address.
      8  2819							;
      9  2819							;======================================================
     10  2819							; ipcs   - Send msg to another task or many tasks
     11  2819							; on entry  math stack contains the  top PID
     12  2819							;				      2ND Message value
     13  2819							; on exit   math stack contain top True-good or False-failed
     14  2819							;
     15  2819							; it may not be sent if queue is full
     16  2819							;
     17  2819							; a = ipcs(<message-expression>,<task PID-expression>)
     18  2819							;
     19  2819				   iIPCS
     20  2819		       98		      tya
     21  281a		       48		      pha
     22  281b		       20 82 28 	      jsr	ipc_enqueue
     23  281e		       b0 08		      bcs	iIPC_BAD
     24  2820		       20 f0 2d 	      jsr	pushTrue
     25  2823		       68		      pla
     26  2824		       a8		      tay
     27  2825		       4c b1 02 	      jmp	NextIL
     28  2828				   iIPC_BAD
     29  2828		       68		      pla
     30  2829		       a8		      tay
     31  282a		       20 fa 2d 	      jsr	pushFalse
     32  282d		       4c b1 02 	      jmp	NextIL
     33  2830
     34  2830							;======================================================
     35  2830							; ipcr   - Recieve msg from task
     36  2830							; on exit  the message value is returned from message queue
     37  2830							;	    message -1	is reserved meaning no entry found
     38  2830							; The provided variable contains the pid of the sending
     39  2830							; task. This is optional. This always waits for a message
     40  2830							; before returning.
     41  2830							;
     42  2830							; a = ipcr(<variable name>)
     43  2830							;
     44  2830				   iIPCR
     45  2830		       98		      tya
     46  2831		       48		      pha
     47  2832		       20 c4 28 	      jsr	ipc_dequeue
     48  2835		       b0 05		      bcs	iIPCR_Q_Empty
     49  2837		       68		      pla
     50  2838		       a8		      tay
     51  2839		       4c b1 02 	      jmp	NextIL
     52  283c				   iIPCR_Q_Empty
     53  283c		       68		      pla
     54  283d		       a8		      tay
     55  283e		       20 f0 2d 	      jsr	pushTrue	; puts -1 on the stack
     56  2841		       4c b1 02 	      jmp	NextIL
     57  2844
     58  2844							;=======================================================
     59  2844							; ipcc   - Check if message available
     60  2844							; on exit  Stack contains number of messages
     61  2844							;
     62  2844							; a = ipcc()
     63  2844							;
     64  2844				   iIPCC
     65  2844		       98		      tya
     66  2845		       48		      pha
     67  2846		       20 6f 28 	      jsr	ipc_queue_count
     68  2849		       20 39 2b 	      jsr	pushR0	; return the count
     69  284c		       68		      pla
     70  284d		       a8		      tay
     71  284e		       4c b1 02 	      jmp	NextIL
     72  2851
     73  2851							;=======================================================
     74  2851							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  2851				   iIPCIO
     76  2851		       98		      tya
     77  2852		       48		      pha
     78  2853		       20 6f 28 	      jsr	ipc_queue_count
     79  2856		       a5 52		      lda	R0
     80  2858		       d0 10		      bne	iIPCIO_No_Halt
     81  285a		       a9 01		      lda	#1
     82  285c		       8d 9e 36 	      sta	taskCurrentCycles	; force a task switch
     83  285f		       a9 01		      lda	#TASKWAITIPC
     84  2861		       ac a3 35 	      ldy	taskPtr
     85  2864		       19 a4 35 	      ora	taskTable,y
     86  2867		       99 a4 35 	      sta	taskTable,y
     87  286a
     88  286a				   iIPCIO_No_Halt
     89  286a		       68		      pla
     90  286b		       a8		      tay
     91  286c		       4c b1 02 	      jmp	NextIL
     92  286f							;======================================================
     93  286f							;ipc_queue_count
     94  286f				   ipc_queue_count
     95  286f		       a5 4e		      lda	MESSAGEPTR
     96  2871		       18		      clc
     97  2872		       4a		      lsr		; divide by 4
     98  2873		       4a		      lsr
     99  2874		       85 52		      sta	R0	; store into R0
    100  2876		       a9 10		      lda	#GOSUBSTACKSIZE
    101  2878		       38		      sec
    102  2879		       e5 52		      sbc	R0	; Get how many entries on queue
    103  287b		       85 52		      sta	R0
    104  287d		       a9 00		      lda	#0
    105  287f		       85 53		      sta	R0+1
    106  2881		       60		      rts
    107  2882							;=======================================================
    108  2882							; Support functions for messaging
    109  2882							;
    110  2882							; Enqueue message -> onto PID's MSG Q
    111  2882							; on entry top of stack contains the PID
    112  2882							;	    second contains the Message of the task
    113  2882							; on exit contains c set if failed
    114  2882							;		    c cleared if success
    115  2882							;		    PID's MSG Q PTR points to the message
    116  2882							;
    117  2882				   ipc_enqueue
    118  2882		       20 e3 2b 	      jsr	popR1	; Get the pid
    119  2885		       20 fd 28 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  2888
    121  2888		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  288a		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  288c		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  288e		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  2890		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  2892
    127  2892
    128  2892							; Get the PID'S stack address into R0
    129  2892		       a0 0b		      ldy	#GOSUBSTKPOS
    130  2894		       b1 56		      lda	(MQ),y
    131  2896		       85 52		      sta	R0
    132  2898		       c8		      iny
    133  2899		       b1 56		      lda	(MQ),y
    134  289b		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  289d
    136  289d							; Set y to point to the msg q entry
    137  289d		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  289f		       b1 56		      lda	(MQ),y	; Get the index
    139  28a1		       a8		      tay		; Set y to queue offset
    140  28a2
    141  28a2							; enqueue the message
    142  28a2		       88		      dey		; First byte to save to
    143  28a3		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  28a5		       91 52		      sta	(R0),y	; Set the entry type
    145  28a7
    146  28a7		       88		      dey
    147  28a8		       ad a3 35 	      lda	taskPtr	; Store the PID into queue
    148  28ab		       91 52		      sta	(R0),y
    149  28ad		       20 e3 2b 	      jsr	popR1	; Get the actual message value
    150  28b0		       20 31 29 	      jsr	ipc_pushR1	; Store Message value into queue
    151  28b3
    152  28b3		       98		      tya		; Save the new q ptr
    153  28b4		       a0 0e		      ldy	#MSGPTRPOS
    154  28b6		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  28b8		       a0 00		      ldy	#0	; points to context root
    156  28ba		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  28bc		       51 56		      eor	(MQ),y	; Turn off the bit
    158  28be		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  28c0		       18		      clc
    160  28c1		       60		      rts
    161  28c2				   ipc_enq_full
    162  28c2		       38		      sec
    163  28c3		       60		      rts
    164  28c4							;=============================================================
    165  28c4							; De-queue for message stack -> local tasks msg q
    166  28c4							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  28c4							;  message into
    168  28c4							;  on exit   math stack contains value of message
    169  28c4							;				  Variable if provided is pid
    170  28c4				   ipc_dequeue
    171  28c4		       20 fa 2b 	      jsr	popMQ	; Variable address to put PID into
    172  28c7
    173  28c7		       a4 4e		      ldy	MESSAGEPTR
    174  28c9		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    175  28cb		       b0 2e		      bcs	ipc_deq_empty
    176  28cd		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  28cf		       85 52		      sta	R0
    178  28d1		       c8		      iny
    179  28d2		       b1 4b		      lda	(GOSUBSTACK),y
    180  28d4		       85 53		      sta	R0+1
    181  28d6		       c8		      iny
    182  28d7		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  28d9		       85 54		      sta	R1
    184  28db		       c8		      iny
    185  28dc		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  28de		       c8		      iny
    187  28df		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  28e1
    189  28e1		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  28e3		       d0 16		      bne	ipc_deq_empty
    191  28e5
    192  28e5		       20 39 2b 	      jsr	pushR0	; place value on stack
    193  28e8
    194  28e8		       a5 56		      lda	MQ
    195  28ea		       05 57		      ora	MQ+1
    196  28ec		       f0 0b		      beq	ipc_deq_done
    197  28ee		       a5 54		      lda	R1
    198  28f0		       a0 00		      ldy	#0
    199  28f2		       91 56		      sta	(MQ),y
    200  28f4		       c8		      iny
    201  28f5		       a9 00		      lda	#0
    202  28f7		       91 56		      sta	(MQ),y
    203  28f9				   ipc_deq_done
    204  28f9		       18		      clc
    205  28fa		       60		      rts
    206  28fb
    207  28fb				   ipc_deq_empty
    208  28fb		       38		      sec
    209  28fc		       60		      rts
    210  28fd
    211  28fd							;=============================================
    212  28fd							;  Get the context address into MQ from R1 with
    213  28fd							;  context/index/pid
    214  28fd				   ipc_getcontext
    215  28fd		       18		      clc		; Get pointer to Task context
    216  28fe		       a9 a4		      lda	#taskTable&$FF	; change ptr to address
    217  2900		       65 54		      adc	R1
    218  2902		       85 56		      sta	MQ
    219  2904		       a9 35		      lda	#taskTable>>8
    220  2906		       65 55		      adc	R1+1
    221  2908		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  290a		       60		      rts
    223  290b							;
    224  290b							;==============================================
    225  290b							; on entry R1 has a context value,
    226  290b							; on exit c is set if fails
    227  290b							;
    228  290b				   ipc_CONTEXTVALUES
      0  290b					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  290b		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  290f					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  290f		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  2913					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  2913		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    232  2915
    233  2915				   ipc_ValidateContext
    234  2915		       48		      pha
    235  2916		       8a		      txa
    236  2917		       48		      pha
    237  2918		       a5 55		      lda	R1+1
    238  291a		       d0 0e		      bne	ipc_Validate_Fail
    239  291c		       a2 00		      ldx	#0
    240  291e		       a5 54		      lda	R1
    241  2920				   ipc_ValidateLoop
    242  2920		       dd 0b 29 	      cmp	ipc_CONTEXTVALUES,x
    243  2923		       f0 09		      beq	ipc_Valid_Context
    244  2925		       e8		      inx
    245  2926		       e0 0a		      cpx	#TASKCOUNT
    246  2928		       90 f6		      bcc	ipc_ValidateLoop
    247  292a
    248  292a				   ipc_Validate_Fail
    249  292a		       68		      pla
    250  292b		       aa		      tax
    251  292c		       68		      pla
      0  292d					      rtn
      0  292d					      db	25
      1  292d		       19		      .byte.b	25
    253  292e
    254  292e				   ipc_Valid_Context
    255  292e		       18		      clc
    256  292f		       90 f9		      bcc	ipc_Validate_Fail
    257  2931							;
    258  2931							;==============================================
    259  2931							;Push R1 onto the stack
    260  2931							;on entry y = next entry
    261  2931							;R0 points to the stack space
    262  2931							;on exit y points to next free byte
    263  2931				   ipc_pushR1
    264  2931		       88		      dey
    265  2932		       a5 55		      lda	R1+1	; PID first
    266  2934		       91 52		      sta	(R0),y
    267  2936		       88		      dey
    268  2937		       a5 54		      lda	R1
    269  2939		       91 52		      sta	(R0),y
    270  293b		       60		      rts
    271  293c
    272  293c
    273  293c
    274  293c
    275  293c
    276  293c
    277  293c
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  293c					      include	"support.asm"
      1  293c							;
      2  293c							;=====================================================
      3  293c							;=====================================================
      4  293c							;=====================================================
      5  293c							; This marks the start of support functions used by
      6  293c							; the IL opcodes.  These are support functions, NOT
      7  293c							; the IL code.
      8  293c							;=====================================================
      9  293c							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  293c							;=====================================================
     11  293c					      Seg	Code
     12  293c							;=====================================================
     13  293c							; This gets the next two bytes pointed to by ILPC and
     14  293c							; returns them; X contains LSB, A contains MSB.  ILPC
     15  293c							; is advanced by two, and Y contains 0 on return.
     16  293c
     17  293c							;
     18  293c		       20 40 29    getILWord  jsr	getILByte	;LSB
     19  293f		       aa		      tax
     20  2940							;
     21  2940							;=====================================================
     22  2940							; This gets the next byte pointed to by ILPC and
     23  2940							; returns it in A.  On return, X is unchanged but Y
     24  2940							; contains 0.
     25  2940							;
     26  2940		       a0 00	   getILByte  ldy	#0
     27  2942		       b1 43		      lda	(ILPC),y	;get byte
     28  2944		       08		      php		;save status
     29  2945		       e6 43		      inc	ILPC	;inc LSB
     30  2947		       d0 02		      bne	getILb2	;branch if no overflow
     31  2949		       e6 44		      inc	ILPC+1	;inc MSB
     32  294b		       28	   getILb2    plp		;restore status
     33  294c		       60		      rts
     34  294d							;
     35  294d							;=====================================================
     36  294d							; Decrement ILPC by one.
     37  294d							;
     38  294d		       a5 43	   decIL      lda	ILPC
     39  294f		       d0 02		      bne	decIL2
     40  2951		       c6 44		      dec	ILPC+1
     41  2953		       c6 43	   decIL2     dec	ILPC
     42  2955		       60		      rts
     43  2956							;
     44  2956							;=====================================================
     45  2956							; Push the ILPC onto the return stack.  Actually, this
     46  2956							; pushes the address of ILPC+2 since that's the next
     47  2956							; address to execute.
     48  2956							;
     49  2956		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  2958		       c0 64		      cpy	#ILSTACKSIZE<<1
     51  295a		       b0 15		      bcs	pushErr
     52  295c		       a5 43		      lda	ILPC
     53  295e		       18		      clc
     54  295f		       69 02		      adc	#2
     55  2961		       91 45		      sta	(ILSTACK),y
     56  2963		       08		      php		;save C bit
     57  2964		       c8		      iny
     58  2965		       a5 44		      lda	ILPC+1
     59  2967		       28		      plp		;restore C
     60  2968		       69 00		      adc	#0
     61  296a		       91 45		      sta	(ILSTACK),y
     62  296c		       c8		      iny
     63  296d		       84 47		      sty	ILSTACKPTR
     64  296f		       18		      clc
     65  2970		       60		      rts
     66  2971				   pushErr
     67  2971		       38		      sec
     68  2972		       60		      rts
     69  2973							;
     70  2973							;=====================================================
     71  2973							; Pull the top entry from return stack and put into
     72  2973							; ILPC.
     73  2973							;
     74  2973		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  2975		       f0 fa		      beq	pushErr
     76  2977		       88		      dey
     77  2978		       b1 45		      lda	(ILSTACK),y
     78  297a		       85 44		      sta	ILPC+1
     79  297c		       88		      dey
     80  297d		       b1 45		      lda	(ILSTACK),y
     81  297f		       85 43		      sta	ILPC
     82  2981		       84 47		      sty	ILSTACKPTR
     83  2983		       18		      clc
     84  2984		       60		      rts
     85  2985							;
     86  2985							;=====================================================
     87  2985							; This searches for a specific line number that is in
     88  2985							; R0.	There are three possible return conditions:
     89  2985							; Line numbers are now the third byte, the first byte is now
     90  2985							; a pointer to the next line, of course no longer than 255 byte
     91  2985							; per line.
     92  2985							;
     93  2985							; Exact match was found:
     94  2985							;    * Z set
     95  2985							;    * CURPTR points to two-byte line number for that
     96  2985							;	line.
     97  2985							;
     98  2985							; Next highest line found:
     99  2985							;    * Z cleared
    100  2985							;    * C set
    101  2985							;    * CURPTR points to two-byte line number for that
    102  2985							;	line.
    103  2985							;
    104  2985							; End of program reached:
    105  2985							;    * Z cleared
    106  2985							;    * C cleared
    107  2985							;    * CURPTR points to first free byte at end of
    108  2985							;	program.  Ie, it has save value as PROGRAMEND.
    109  2985							;
    110  2985							; A, X, and Y are all undefined on return.
    111  2985							;
    112  2985
    113  2985				   findLine
    114  2985		       ad 18 42 	      lda	ProgramStart	;Start of program -> CURPTR
    115  2988		       85 4f		      sta	CURPTR
    116  298a		       ad 19 42 	      lda	ProgramStart+1
    117  298d		       85 50		      sta	CURPTR+1
    118  298f							;
    119  298f							; At end of code?
    120  298f							;
    121  298f				   iXFER1
    122  298f		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  2991		       cd 1a 42 	      cmp	ProgramEnd	; at end of program then stop run
    124  2994		       d0 0b		      bne	xfer2	; not end
    125  2996		       a5 50		      lda	CURPTR+1
    126  2998		       cd 1b 42 	      cmp	ProgramEnd+1
    127  299b		       d0 04		      bne	xfer2	;Not at end
    128  299d							;
    129  299d							; Line not found and the end of the program was
    130  299d							; reached.  Return Z and C both clear.
    131  299d							;
    132  299d		       a9 01		      lda	#1	;clear Z
    133  299f		       18		      clc		;clear C
    134  29a0		       60		      rts
    135  29a1							;
    136  29a1							; Check for an exact line number match
    137  29a1							;
    138  29a1		       a5 52	   xfer2      lda	R0
    139  29a3		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  29a5		       d1 4f		      cmp	(CURPTR),y
    141  29a7		       d0 08		      bne	xfernotit
    142  29a9		       c8		      iny
    143  29aa		       a5 53		      lda	R0+1
    144  29ac		       d1 4f		      cmp	(CURPTR),y
    145  29ae		       d0 01		      bne	xfernotit	; not a matching line number
    146  29b0							;
    147  29b0							; This is exactly the line we want.
    148  29b0							;
    149  29b0		       60		      rts		;it matches exactly
    150  29b1							;
    151  29b1							; See if this line is greater than the one we're
    152  29b1							; searching for.
    153  29b1							;
    154  29b1		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  29b3		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  29b5		       c5 53		      cmp	R0+1
    157  29b7		       90 0b		      bcc	xfer3
    158  29b9		       d0 07		      bne	xfer4
    159  29bb		       88		      dey
    160  29bc		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  29be		       c5 52		      cmp	R0
    162  29c0		       90 02		      bcc	xfer3
    163  29c2							;
    164  29c2							; This line is greater than the one we want, so
    165  29c2							; return Z clear and C set.
    166  29c2							;
    167  29c2		       38	   xfer4      sec		;We found a line number greater
    168  29c3		       60		      rts		;both conditions set
    169  29c4							;
    170  29c4							; Not the line (or droid) we're looking for.  Move to
    171  29c4							; the next line.
    172  29c4							;
    173  29c4		       20 ca 29    xfer3      jsr	FindNextLine
    174  29c7		       4c 8f 29 	      jmp	iXFER1
    175  29ca							;
    176  29ca							;=====================================================
    177  29ca							; This advances CURPTR to the next line.  If there
    178  29ca							; are no more lines, this leaves CURPTR equal to
    179  29ca							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  29ca							; CURPTR is pointing to a valid line on entry.  This
    181  29ca							; pointer points to the two-byte line number.
    182  29ca							; Update this points to the 1 byte line length  ****************
    183  29ca							;
    184  29ca				   FindNextLine
    185  29ca		       a0 03		      ldy	#3	;skip line number and length byte
    186  29cc		       84 51		      sty	CUROFF	;this is the new offset
    187  29ce		       a0 00		      ldy	#0
    188  29d0		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  29d2		       18		      clc
    190  29d3		       65 4f		      adc	CURPTR
    191  29d5		       85 4f		      sta	CURPTR
    192  29d7		       a5 50		      lda	CURPTR+1
    193  29d9		       69 00		      adc	#0
    194  29db		       85 50		      sta	CURPTR+1
    195  29dd		       60	   FindNext4  rts
    196  29de							;
    197  29de							;=====================================================
    198  29de							; This compares CURPTR to PROGRAMEND and returns Z set
    199  29de							; if they are equal, Z clear if not.
    200  29de							;
    201  29de		       a5 4f	   AtEnd      lda	CURPTR
    202  29e0		       cd 1a 42 	      cmp	ProgramEnd
    203  29e3		       d0 05		      bne	atendexit
    204  29e5		       a5 50		      lda	CURPTR+1
    205  29e7		       cd 1b 42 	      cmp	ProgramEnd+1
    206  29ea		       60	   atendexit  rts
    207  29eb							;
    208  29eb
    209  29eb							;
    210  29eb							;=====================================================
    211  29eb							; Convert an ASCII string to a number.  On input,
    212  29eb							; (CURPTR),Y points to the first digit.  This gets
    213  29eb							; digit-by-digit until finding a non-number.  Returns
    214  29eb							; Y pointing to the non-digit, and R0 contains the
    215  29eb							; number.  This does NOT check for valid ranges, so
    216  29eb							; a value like "123456789" will produce something,
    217  29eb							; but not what you had expected.
    218  29eb							;
    219  29eb		       a9 00	   getDecimal lda	#0
    220  29ed		       85 52		      sta	R0
    221  29ef		       85 53		      sta	R0+1
    222  29f1		       85 59		      sta	dpl	;temporary negative flag
    223  29f3							;
    224  29f3							; See if it's negative...
    225  29f3							;
    226  29f3							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  29f3		       b1 4f		      lda	(CURPTR),y
    228  29f5		       c9 2d		      cmp	#'-
    229  29f7		       d0 02		      bne	getDecLoop
    230  29f9		       e6 59		      inc	dpl	;it's negative
    231  29fb							;
    232  29fb		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  29fd		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  29ff		       c9 30		      cmp	#'0
    235  2a01		       90 36		      bcc	getDdone
    236  2a03		       c9 3a		      cmp	#'9+1
    237  2a05		       b0 32		      bcs	getDdone
    238  2a07		       38		      sec
    239  2a08		       e9 30		      sbc	#'0	;convert to binary
    240  2a0a		       48		      pha
    241  2a0b							;
    242  2a0b							; Now multiply R0 by 10.  Remember that
    243  2a0b							; 2*N + 8*N = 10*N.
    244  2a0b							;
    245  2a0b		       06 52		      asl	R0
    246  2a0d		       26 53		      rol	R0+1	;*2
    247  2a0f		       a5 52		      lda	R0
    248  2a11		       85 54		      sta	R1
    249  2a13		       a5 53		      lda	R0+1
    250  2a15		       85 55		      sta	R1+1
    251  2a17		       06 52		      asl	R0
    252  2a19		       26 53		      rol	R0+1	;*4
    253  2a1b		       06 52		      asl	R0
    254  2a1d		       26 53		      rol	R0+1	;*8
    255  2a1f		       18		      clc		;now add the partial sums...
    256  2a20		       a5 52		      lda	R0	;...to get *10
    257  2a22		       65 54		      adc	R1
    258  2a24		       85 52		      sta	R0
    259  2a26		       a5 53		      lda	R0+1
    260  2a28		       65 55		      adc	R1+1
    261  2a2a		       85 53		      sta	R0+1
    262  2a2c							;
    263  2a2c							; Add in the new digit
    264  2a2c							;
    265  2a2c		       68		      pla
    266  2a2d		       18		      clc
    267  2a2e		       65 52		      adc	R0
    268  2a30		       85 52		      sta	R0
    269  2a32		       90 02		      bcc	getD2
    270  2a34		       e6 53		      inc	R0+1
    271  2a36							;
    272  2a36							; Move to next character
    273  2a36							;
    274  2a36		       c8	   getD2      iny
    275  2a37		       d0 c2		      bne	getDecLoop
    276  2a39							;
    277  2a39							; All done with digits, so now deal with it being
    278  2a39							; negative.  If zero, then don't check for negative
    279  2a39							; flag.  Ie, -0 is stored as 0.
    280  2a39							;
    281  2a39		       a5 52	   getDdone   lda	R0
    282  2a3b		       05 53		      ora	R0+1
    283  2a3d		       f0 16		      beq	getDone2	;zero
    284  2a3f		       a5 59		      lda	dpl
    285  2a41		       f0 12		      beq	getDone2	;positive
    286  2a43							;
    287  2a43							; Invert all the bits, then add one.
    288  2a43							;
    289  2a43		       a5 52		      lda	R0
    290  2a45		       49 ff		      eor	#$ff
    291  2a47		       85 52		      sta	R0
    292  2a49		       a5 53		      lda	R0+1
    293  2a4b		       49 ff		      eor	#$ff
    294  2a4d		       85 53		      sta	R0+1
    295  2a4f							;
    296  2a4f		       e6 52		      inc	R0
    297  2a51		       d0 02		      bne	getDone2
    298  2a53		       e6 53		      inc	R0+1
    299  2a55				   getDone2
    300  2a55							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  2a55							;lda	  R0
    302  2a55							;sta	  $0010
    303  2a55							;lda	  R0+1
    304  2a55							;sta	  $0011
    305  2a55							;lda	  dpl
    306  2a55							;sta	  $012
    307  2a55
    308  2a55		       60		      rts
    309  2a56
    310  2a56							;=====================================================
    311  2a56							; Gets a line of input into LINBUF.
    312  2a56							;
    313  2a56							; On entry:
    314  2a56							;    A contains the prompt character, or 0 if none.
    315  2a56							;    X = 1 Background read
    316  2a56							;    x = 0 Forground read with wait
    317  2a56							;
    318  2a56							; On exit:
    319  2a56							;    CURPTR points to LINBUF
    320  2a56							;    LINBUF contains the line with 0 at the end.
    321  2a56							;    Y has offset to first non-space character
    322  2a56							;    CURROFF has the same as Y.
    323  2a56							;
    324  2a56		       20 a5 2a    GetLine    jsr	ReadPrompt
    325  2a59		       e0 00		      cpx	#0
    326  2a5b		       f0 14		      beq	GetLineRetry
    327  2a5d		       ae a3 35 	      ldx	taskPtr
    328  2a60		       bd a4 35 	      lda	taskTable,x
    329  2a63		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  2a65		       d0 3d		      bne	taskWaitingIO
    331  2a67		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  2a69		       9d a4 35 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  2a6c		       ce a4 2a 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  2a6f		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  2a71
    336  2a71							;
    337  2a71							; Now read a line and wait for the CR
    338  2a71							;
    339  2a71				   GetLineRetry
    340  2a71		       a9 00		      lda	#0	;Wait for input to complete
    341  2a73		       20 bd 2a 	      jsr	ReadLine
    342  2a76
    343  2a76							;
    344  2a76							; Point to the line we just read
    345  2a76							; Set the current pointer to point to the input line
    346  2a76							;
    347  2a76		       a0 00	   ReadComplete ldy	#0
    348  2a78		       84 51		      sty	CUROFF
    349  2a7a		       a2 7f		      ldx	#LINBUF&$ff
    350  2a7c		       86 4f		      stx	CURPTR
    351  2a7e		       a2 41		      ldx	#LINBUF>>8
    352  2a80		       86 50		      stx	CURPTR+1
    353  2a82							;
    354  2a82							; Output a CR/LF
    355  2a82							;
    356  2a82		       20 84 2c 	      jsr	CRLF
    357  2a85							;
    358  2a85							; If a blank line, prompt again.
    359  2a85							;
    360  2a85		       20 7b 2c 	      jsr	SkipSpaces
    361  2a88		       b1 4f		      lda	(CURPTR),y
    362  2a8a		       d0 10		      bne	GetLineDone	;We have data then exit
    363  2a8c		       20 a8 2a 	      jsr	ReadPromptRetry
    364  2a8f		       ae a3 35 	      ldx	taskPtr	;if this task is waiting for IO
    365  2a92		       bd a4 35 	      lda	taskTable,x	;then get out, wait for line to
    366  2a95		       29 40		      and	#TASKWAITIO	;Complete again
    367  2a97		       d0 0b		      bne	taskWaitingIO
    368  2a99		       4c 71 2a 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  2a9c
    370  2a9c				   GetLineDone
    371  2a9c		       ae a3 35 	      ldx	taskPtr
    372  2a9f		       a9 80		      lda	#TASKACTIVE
    373  2aa1		       9d a4 35 	      sta	taskTable,x	;IO is complete
    374  2aa4
    375  2aa4				   taskWaitingIO
    376  2aa4		       60		      rts
    377  2aa5
    378  2aa5							;
    379  2aa5							;=======================================================================
    380  2aa5							; Display the prompt character
    381  2aa5							; On entry
    382  2aa5							;	    A contains the prompt character
    383  2aa5							; On exit
    384  2aa5							;	    The readbuffer index is reset to 0
    385  2aa5							;
    386  2aa5		       8d 06 42    ReadPrompt sta	promptChar
    387  2aa8
    388  2aa8							;
    389  2aa8							; Prompt
    390  2aa8							;
    391  2aa8
    392  2aa8		       ad 06 42    ReadPromptRetry lda	promptChar
    393  2aab		       09 00		      ora	#0	;any prompt?
    394  2aad		       f0 08		      beq	getlinenp
    395  2aaf		       20 c8 19 	      jsr	VOUTCH
    396  2ab2		       a9 20		      lda	#$20
    397  2ab4		       20 c8 19 	      jsr	VOUTCH	;Space after prompt
    398  2ab7							;
    399  2ab7		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  2ab9		       8e 03 42 	      stx	getlinx
    401  2abc		       60		      rts
    402  2abd							;
    403  2abd							;===============================================================
    404  2abd							; This fuction is the driver for the line input
    405  2abd							; on call if a = 0 then it waits for all input
    406  2abd							;	      a = 1 then nowait for input
    407  2abd							; On exit
    408  2abd							;		       c clear if not complete line
    409  2abd							;		       c set if it was a complete line
    410  2abd
    411  2abd				   ReadLine
    412  2abd		       8d 05 42 	      sta	inputNoWait
    413  2ac0		       c9 00		      cmp	#0
    414  2ac2		       f0 05		      beq	getline1
    415  2ac4		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  2ac7		       f0 2b		      beq	GetLineNoWait
    417  2ac9		       20 cb 19    getline1   jsr	VGETCH
    418  2acc					      if	CTMON65
    419  2acc		       48		      pha
    420  2acd		       20 c8 19 	      jsr	VOUTCH	;echo echo echo
    421  2ad0		       68		      pla
    422  2ad1					      endif
    423  2ad1		       c9 0d		      cmp	#CR
    424  2ad3		       f0 15		      beq	getlind	;end of line
    425  2ad5		       c9 08		      cmp	#BS	;backspace?
    426  2ad7		       f0 1d		      beq	getlinebs
    427  2ad9		       ae 03 42 	      ldx	getlinx
    428  2adc		       9d 7f 41 	      sta	LINBUF,x
    429  2adf		       e8		      inx
    430  2ae0		       8e 03 42 	      stx	getlinx
    431  2ae3		       ad 05 42 	      lda	inputNoWait
    432  2ae6		       f0 e1		      beq	getline1
    433  2ae8		       d0 0a		      bne	GetLineNoWait
    434  2aea							;
    435  2aea							; CR was hit
    436  2aea							;
    437  2aea		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  2aec		       ae 03 42 	      ldx	getlinx
    439  2aef		       9d 7f 41 	      sta	LINBUF,x
    440  2af2
    441  2af2		       38		      sec		; Carry set then cr received
    442  2af3		       60		      rts
    443  2af4
    444  2af4				   GetLineNoWait
    445  2af4		       18		      clc		; Carry clear no end of line
    446  2af5		       60		      rts
    447  2af6							;
    448  2af6							; Backspace was hit
    449  2af6							;
    450  2af6		       ae 03 42    getlinebs  ldx	getlinx
    451  2af9		       f0 0e		      beq	getlineEOL	;at start of line
    452  2afb		       ca		      dex
    453  2afc		       8e 03 42 	      stx	getlinx
    454  2aff		       20 f8 20    getlinepbs jsr	puts
      0  2b02					      db	27,"[K",0
      1  2b02		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  2b06		       4c c9 2a 	      jmp	getline1
    457  2b09		       a9 20	   getlineEOL lda	#SPACE
    458  2b0b		       20 c8 19 	      jsr	VOUTCH
    459  2b0e		       d0 ef		      bne	getlinepbs
    460  2b10							;
    461  2b10							;=====================================================
    462  2b10							; Count the length of the line currently in LINBUF
    463  2b10							; starting at offset Y.  Returns the length in X.  The
    464  2b10							; starting offset in Y should point past the ASCII
    465  2b10							; line number.  Also counts the trailing NULL and two
    466  2b10							; extra bytes for where the line number will be.
    467  2b10							; Update must now include leading length byte not the null at end ****************
    468  2b10							;
    469  2b10				   getLineLength
    470  2b10		       a2 00		      ldx	#0	;size
    471  2b12		       b9 7f 41    getLineL2  lda	LINBUF,y
    472  2b15		       f0 04		      beq	getLineL3
    473  2b17		       c8		      iny
    474  2b18		       e8		      inx
    475  2b19		       d0 f7		      bne	getLineL2
    476  2b1b		       e8	   getLineL3  inx		;count null at end
    477  2b1c		       e8		      inx		;line number LSB
    478  2b1d		       e8		      inx		;MSB
    479  2b1e		       e8		      inx		;change: count new leading line length
    480  2b1f		       8e 15 42 	      stx	lineLength
    481  2b22		       60		      rts
    482  2b23							;
    483  2b23							;=====================================================
    484  2b23							; Count the length of the line pointed to by CURPTR.
    485  2b23							; This also counts the line number and the terminating
    486  2b23							; null.  Ie, this string returns 8:
    487  2b23							;
    488  2b23							; <lineLow><lineHi>Hello<null>
    489  2b23							;
    490  2b23							; Another way of looking at it: add the return value
    491  2b23							; to the CURPTR and it'll point to the next line's
    492  2b23							; line number.  Returns the value in Y.
    493  2b23							; Update to ject get the leading byte length ********************
    494  2b23							;
    495  2b23							;getCURPTRLength
    496  2b23							;		ldy	CURPTR
    497  2b23							;		ldy	#3	;change: skip line number and leading length byte
    498  2b23							;getCLineL2	lda	(CURPTR),y
    499  2b23							;		beq	getCLineL3
    500  2b23							;		iny
    501  2b23							;		bne	getCLineL2
    502  2b23							;getCLineL3	iny		;count null at end
    503  2b23							;		rts
    504  2b23
    505  2b23							;
    506  2b23							;=====================================================
    507  2b23							; This saves ILPC.  This saves to a single save area,
    508  2b23							; so it can't be called more than once.
    509  2b23							;
    510  2b23		       a5 43	   saveIL     lda	ILPC
    511  2b25		       8d 11 42 	      sta	tempIL
    512  2b28		       a5 44		      lda	ILPC+1
    513  2b2a		       8d 12 42 	      sta	tempIL+1
    514  2b2d		       60		      rts
    515  2b2e							;
    516  2b2e							;=====================================================
    517  2b2e							; This restores ILPC.
    518  2b2e							;
    519  2b2e		       ad 11 42    restoreIL  lda	tempIL
    520  2b31		       85 43		      sta	ILPC
    521  2b33		       ad 12 42 	      lda	tempIL+1
    522  2b36		       85 44		      sta	ILPC+1
    523  2b38		       60		      rts
    524  2b39							;
    525  2b39							;=====================================================
    526  2b39							; This pushes R0 onto the stack.
    527  2b39							;
    528  2b39		       8c 0c 42    pushR0     sty	rtemp1
    529  2b3c		       a4 4a		      ldy	MATHSTACKPTR
    530  2b3e		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  2b40		       b0 38		      bcs	pusherr
    532  2b42		       a5 52		      lda	R0
    533  2b44		       91 48		      sta	(MATHSTACK),y
    534  2b46		       c8		      iny
    535  2b47		       a5 53		      lda	R0+1
    536  2b49		       91 48		      sta	(MATHSTACK),y
    537  2b4b		       c8		      iny
    538  2b4c		       84 4a		      sty	MATHSTACKPTR
    539  2b4e		       ac 0c 42 	      ldy	rtemp1
    540  2b51		       18		      clc
    541  2b52		       60		      rts
    542  2b53
    543  2b53							;=====================================================
    544  2b53							; This pushes curptr basic current line onto the call stack.
    545  2b53							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  2b53
    547  2b53				   pushLN
    548  2b53		       8d 0d 42 	      STA	rtemp1+1	; Store type of push being done
    549  2b56		       8c 0c 42 	      sty	rtemp1
    550  2b59		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  2b5b		       c5 4d		      cmp	GOSUBSTACKPTR
    552  2b5d		       90 1b		      bcc	pusherr	; No error
    553  2b5f		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  2b61		       a2 00		      ldx	#0	; Start of bytes to copy
    555  2b63				   pushLoop
    556  2b63		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  2b65		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  2b67		       c8		      iny		; Next destination
    559  2b68		       e8		      inx		; Next Source byte
    560  2b69		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  2b6b		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  2b6d
    563  2b6d		       ad 0d 42    pushDone   lda	rtemp1+1	; Type of stack entry
    564  2b70		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  2b72		       c8		      iny		; Next entry
    566  2b73
    567  2b73		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  2b75		       ac 0c 42 	      ldy	rtemp1
    569  2b78		       18		      clc
    570  2b79		       60		      rts
    571  2b7a				   pusherr
    572  2b7a		       38		      sec
    573  2b7b		       60		      rts
    574  2b7c							;=====================================================
    575  2b7c							; This pops Top Off gosub call Stack and
    576  2b7c							; places it in CURPTR/CUROFF.
    577  2b7c							; This checks if the type = 1 GOSUB
    578  2b7c							; if not it removes what ever is on the stack
    579  2b7c							; until it finds the next return. Allowing
    580  2b7c							; a return from within a for/next
    581  2b7c							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  2b7c		       8c 0c 42    popLN      sty	rtemp1
    583  2b7f		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  2b81		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  2b83
    586  2b83				   popContinue
    587  2b83		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  2b85		       90 22		      bcc	poperr	; Process an error
    589  2b87
    590  2b87		       88		      dey		; Position to read entry type
    591  2b88		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  2b8a		       8d 0d 42 	      sta	rtemp1+1	; Save to be returned
    593  2b8d		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  2b8f		       f0 04		      beq	popLoop	; Restore the line
    595  2b91		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  2b93		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  2b95
    598  2b95				   popLoop
    599  2b95		       88		      dey
    600  2b96		       ca		      dex
    601  2b97		       b1 4b		      lda	(GOSUBSTACK),y
    602  2b99		       95 4f		      sta	CURPTR,x
    603  2b9b		       e0 00		      cpx	#0
    604  2b9d		       d0 f6		      bne	popLoop	; Loop until all moved
    605  2b9f
    606  2b9f
    607  2b9f		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  2ba1		       ac 0c 42 	      ldy	rtemp1
    609  2ba4		       ad 0d 42 	      lda	rtemp1+1	; get the type of return
    610  2ba7		       18		      clc
    611  2ba8		       60		      rts
    612  2ba9
    613  2ba9		       38	   poperr     sec
    614  2baa		       60		      rts
    615  2bab
    616  2bab		       88	   popSkipEntry dey
    617  2bac		       88		      dey
    618  2bad		       88		      dey
    619  2bae		       4c 83 2b 	      jmp	popContinue
    620  2bb1
    621  2bb1							;
    622  2bb1							;=====================================================
    623  2bb1							; This pushes R1 onto the stack
    624  2bb1							;
    625  2bb1		       8c 0c 42    pushR1     sty	rtemp1
    626  2bb4		       a4 4a		      ldy	MATHSTACKPTR
    627  2bb6		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  2bb8		       b0 ef		      bcs	poperr
    629  2bba		       a5 54		      lda	R1
    630  2bbc		       91 48		      sta	(MATHSTACK),y
    631  2bbe		       c8		      iny
    632  2bbf		       a5 55		      lda	R1+1
    633  2bc1		       91 48		      sta	(MATHSTACK),y
    634  2bc3		       c8		      iny
    635  2bc4		       84 4a		      sty	MATHSTACKPTR
    636  2bc6		       ac 0c 42 	      ldy	rtemp1
    637  2bc9		       18		      clc
    638  2bca		       60		      rts
    639  2bcb							;
    640  2bcb							;=====================================================
    641  2bcb							; This pops Top Of Stack and places it in R0.
    642  2bcb							;
    643  2bcb		       8c 0c 42    popR0      sty	rtemp1
    644  2bce		       a4 4a		      ldy	MATHSTACKPTR
    645  2bd0		       f0 d7		      beq	poperr
    646  2bd2		       88		      dey
    647  2bd3		       b1 48		      lda	(MATHSTACK),y
    648  2bd5		       85 53		      sta	R0+1
    649  2bd7		       88		      dey
    650  2bd8		       b1 48		      lda	(MATHSTACK),y
    651  2bda		       85 52		      sta	R0
    652  2bdc		       84 4a		      sty	MATHSTACKPTR
    653  2bde		       ac 0c 42 	      ldy	rtemp1
    654  2be1		       18		      clc
    655  2be2		       60		      rts
    656  2be3
    657  2be3							;
    658  2be3							;=====================================================
    659  2be3							; This pops TOS and places it in R1.
    660  2be3							;
    661  2be3		       8c 0c 42    popR1      sty	rtemp1
    662  2be6		       a4 4a		      ldy	MATHSTACKPTR
    663  2be8		       f0 bf		      beq	poperr
    664  2bea		       88		      dey
    665  2beb		       b1 48		      lda	(MATHSTACK),y
    666  2bed		       85 55		      sta	R1+1
    667  2bef		       88		      dey
    668  2bf0		       b1 48		      lda	(MATHSTACK),y
    669  2bf2		       85 54		      sta	R1
    670  2bf4		       84 4a		      sty	MATHSTACKPTR
    671  2bf6		       ac 0c 42 	      ldy	rtemp1
    672  2bf9		       60		      rts
    673  2bfa							;
    674  2bfa							;=====================================================
    675  2bfa							; This pops TOS and places it in MQ.
    676  2bfa							;
    677  2bfa		       8c 0c 42    popMQ      sty	rtemp1
    678  2bfd		       a4 4a		      ldy	MATHSTACKPTR
    679  2bff		       f0 a8		      beq	poperr
    680  2c01		       88		      dey
    681  2c02		       b1 48		      lda	(MATHSTACK),y
    682  2c04		       85 57		      sta	MQ+1
    683  2c06		       88		      dey
    684  2c07		       b1 48		      lda	(MATHSTACK),y
    685  2c09		       85 56		      sta	MQ
    686  2c0b		       84 4a		      sty	MATHSTACKPTR
    687  2c0d		       ac 0c 42 	      ldy	rtemp1
    688  2c10		       60		      rts
    689  2c11							;
    690  2c11							;=====================================================
    691  2c11							; This assists with multiplication and division by
    692  2c11							; looking at R0 and R1 and saving a flag as to what
    693  2c11							; sign the result will be.  Math is always done on
    694  2c11							; positive numbers, so this converts negative numbers
    695  2c11							; into positives.  On exit, R0 and R1 are both
    696  2c11							; positive.  If the signs were different then 'signs'
    697  2c11							; will be non-zero.
    698  2c11							;
    699  2c11		       a9 00	   SaveSigns  lda	#0
    700  2c13		       8d 0b 42 	      sta	sign	;assume positive
    701  2c16		       a5 53		      lda	R0+1	;MSB
    702  2c18		       10 13		      bpl	SaveSigns1
    703  2c1a		       ee 0b 42 	      inc	sign	;it's negative
    704  2c1d		       49 ff		      eor	#$ff	;flip bits
    705  2c1f		       85 53		      sta	R0+1
    706  2c21		       a5 52		      lda	R0
    707  2c23		       49 ff		      eor	#$ff
    708  2c25		       85 52		      sta	R0
    709  2c27		       e6 52		      inc	R0
    710  2c29		       d0 02		      bne	SaveSigns1
    711  2c2b		       e6 53		      inc	R0+1
    712  2c2d		       a5 55	   SaveSigns1 lda	R1+1
    713  2c2f		       10 1a		      bpl	SaveSigns2
    714  2c31		       48		      pha
    715  2c32		       ad 0b 42 	      lda	sign
    716  2c35		       49 01		      eor	#1
    717  2c37		       8d 0b 42 	      sta	sign
    718  2c3a		       68		      pla
    719  2c3b		       49 ff		      eor	#$ff	;flip bits
    720  2c3d		       85 55		      sta	R1+1
    721  2c3f		       a5 54		      lda	R1
    722  2c41		       49 ff		      eor	#$ff
    723  2c43		       85 54		      sta	R1
    724  2c45		       e6 54		      inc	R1
    725  2c47		       d0 02		      bne	SaveSigns2
    726  2c49		       e6 55		      inc	R1+1
    727  2c4b		       60	   SaveSigns2 rts
    728  2c4c							;
    729  2c4c							;=====================================================
    730  2c4c							; This looks at the value of 'signs' and will convert
    731  2c4c							; both R0 and R1 to negative if set.
    732  2c4c							;
    733  2c4c				   RestoreSigns
    734  2c4c		       ad 0b 42 	      lda	sign
    735  2c4f		       f0 28		      beq	restoresigns2
    736  2c51							;
    737  2c51		       a5 52		      lda	R0
    738  2c53		       d0 02		      bne	restoresigns3
    739  2c55		       c6 53		      dec	R0+1
    740  2c57				   restoresigns3
    741  2c57		       c6 52		      dec	R0
    742  2c59		       a5 52		      lda	R0
    743  2c5b		       49 ff		      eor	#$ff
    744  2c5d		       85 52		      sta	R0
    745  2c5f		       a5 53		      lda	R0+1
    746  2c61		       49 ff		      eor	#$ff
    747  2c63		       85 53		      sta	R0+1
    748  2c65							;
    749  2c65		       a5 54		      lda	R1
    750  2c67		       d0 02		      bne	restoresigns4
    751  2c69		       c6 55		      dec	R1+1
    752  2c6b				   restoresigns4
    753  2c6b		       c6 54		      dec	R1
    754  2c6d		       a5 54		      lda	R1
    755  2c6f		       49 ff		      eor	#$ff
    756  2c71		       85 54		      sta	R1
    757  2c73		       a5 55		      lda	R1+1
    758  2c75		       49 ff		      eor	#$ff
    759  2c77		       85 55		      sta	R1+1
    760  2c79							;
    761  2c79				   restoresigns2
    762  2c79		       60		      rts
    763  2c7a							;
    764  2c7a							;=====================================================
    765  2c7a							; Skip over spaces.  Returns Y with the offset to
    766  2c7a							; either the last character in the line, or the first
    767  2c7a							; non-space character.
    768  2c7a							;
    769  2c7a
    770  2c7a		       c8	   skipsp2    iny
    771  2c7b		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  2c7d		       f0 04		      beq	Skip3	;end of line
    773  2c7f		       c9 20		      cmp	#SPACE
    774  2c81		       f0 f7		      beq	skipsp2
    775  2c83		       60	   Skip3      rts
    776  2c84							;*********************************************************
    777  2c84							; Output a CR/LF combination to the console.  Preserves
    778  2c84							; all registers.
    779  2c84							;
    780  2c84		       48	   tbcrlf     pha
    781  2c85		       a9 0d		      lda	#CR
    782  2c87		       20 c8 19 	      jsr	VOUTCH
    783  2c8a		       a9 0a		      lda	#LF
    784  2c8c		       20 c8 19 	      jsr	VOUTCH
    785  2c8f		       68		      pla
    786  2c90		       60		      rts
    787  2c91							;
    788  2c91							;=====================================================
    789  2c91							; Some logic to print the Line of basic code being executed
    790  2c91		       24 40	   idbgBasic  bit	ILTrace
    791  2c93		       50 75		      bvc	dbgBasicNone
    792  2c95		       98		      tya
    793  2c96		       48		      pha
    794  2c97		       20 13 2e 	      jsr	SetOutDebug
    795  2c9a
    796  2c9a		       a5 4f		      lda	CURPTR
    797  2c9c		       85 59		      sta	dpl
    798  2c9e		       a5 50		      lda	CURPTR+1
    799  2ca0		       85 5a		      sta	dpl+1
    800  2ca2
    801  2ca2		       20 90 21 	      jsr	PrintProgramLine
    802  2ca5
    803  2ca5		       a5 40		      lda	ILTrace
    804  2ca7		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  2ca9		       f0 5a		      beq	dbgBasicDone
    806  2cab		       20 2a 2e 	      jsr	SetInDebug
    807  2cae		       20 f8 20 	      jsr	puts
      0  2cb1					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  2cb1		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  2cee				   dbgBasicLoop
    810  2cee		       20 cb 19 	      jsr	VGETCH
    811  2cf1		       20 84 2c 	      jsr	CRLF
    812  2cf4		       20 4e 2e 	      jsr	SetInDebugEnd
    813  2cf7
    814  2cf7		       c9 73		      cmp	#'s	; Quit program
    815  2cf9		       f0 12		      beq	dbgBasicStop
    816  2cfb
    817  2cfb		       c9 64		      cmp	#'d	; Display Variables
    818  2cfd		       d0 06		      bne	dbgBasicDone
    819  2cff
    820  2cff		       20 53 21 	      jsr	PrintAllVars
    821  2d02		       18		      clc
    822  2d03		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  2d05
    824  2d05		       20 41 2e    dbgBasicDone jsr	SetOutDebugEnd
    825  2d08		       68		      pla
    826  2d09		       a8		      tay
    827  2d0a		       4c b1 02    dbgBasicNone jmp	NextIL
    828  2d0d
    829  2d0d				   dbgBasicStop
    830  2d0d		       20 41 2e 	      jsr	SetOutDebugEnd
    831  2d10		       68		      pla
    832  2d11		       a8		      tay
    833  2d12		       4c e3 05 	      jmp	iFIN
    834  2d15							;
    835  2d15							;=====================================================
    836  2d15							; This is some debug logic which displays the current
    837  2d15							; value of the ILPC and the line buffer.
    838  2d15							;
    839  2d15		       24 40	   dbgLine    bit	ILTrace
    840  2d17		       30 01		      bmi	dbgPrt
    841  2d19		       60		      rts
    842  2d1a				   dbgPrt
    843  2d1a		       20 13 2e 	      jsr	SetOutDebug
    844  2d1d		       20 f8 20 	      jsr	puts
      0  2d20					      db	"ILPC:",0
      1  2d20		       49 4c 50 43*	      .byte.b	"ILPC:",0
    846  2d26		       a5 44		      lda	ILPC+1
    847  2d28		       20 db 20 	      jsr	OUTHEX
    848  2d2b		       a5 43		      lda	ILPC
    849  2d2d		       20 db 20 	      jsr	OUTHEX
    850  2d30		       a9 20		      lda	#SPACE
    851  2d32		       20 c8 19 	      jsr	VOUTCH
    852  2d35
    853  2d35		       a0 00		      ldy	#0
    854  2d37		       b1 43		      lda	(ILPC),y	;Get the il pcode value
    855  2d39					      if	IL_DEBUG_TEXT
    856  2d39		       20 d9 18 	      jsr	PrintILText
    857  2d3c				  -	      else
    858  2d3c				  -	      jsr	OUTHEX
    859  2d3c					      endif
    860  2d3c		       20 f8 20 	      jsr	puts
      0  2d3f					      db	" ILSP:",0
      1  2d3f		       20 49 4c 53*	      .byte.b	" ILSP:",0
    862  2d46		       a5 47		      lda	ILSTACKPTR
    863  2d48		       20 db 20 	      jsr	OUTHEX
    864  2d4b		       a9 20		      lda	#SPACE
    865  2d4d		       20 c8 19 	      jsr	VOUTCH
    866  2d50
    867  2d50							; Display the CURPTR value and offset
    868  2d50							;
    869  2d50		       20 f8 20 	      jsr	puts
      0  2d53					      db	", CURPTR: ",0
      1  2d53		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    871  2d5e		       a5 50		      lda	CURPTR+1
    872  2d60		       20 db 20 	      jsr	OUTHEX
    873  2d63		       a5 4f		      lda	CURPTR
    874  2d65		       20 db 20 	      jsr	OUTHEX
    875  2d68		       a9 2b		      lda	#'+
    876  2d6a		       20 c8 19 	      jsr	VOUTCH
    877  2d6d		       a5 51		      lda	CUROFF
    878  2d6f		       20 db 20 	      jsr	OUTHEX
    879  2d72							;
    880  2d72		       20 84 2c 	      jsr	CRLF
    881  2d75		       20 41 2e 	      jsr	SetOutDebugEnd
    882  2d78		       20 ab 2d 	      jsr	ILChkRange
    883  2d7b		       b0 02		      bcs	dbgLineErr
    884  2d7d		       18		      clc
    885  2d7e		       60		      rts
    886  2d7f
    887  2d7f				   dbgLineErr
    888  2d7f		       20 13 2e 	      jsr	SetOutDebug
    889  2d82		       20 f8 20 	      jsr	puts
      0  2d85					      db	"Outside Valid IL Address Range",CR,LF,0
      1  2d85		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    891  2da6		       20 41 2e 	      jsr	SetOutDebugEnd
    892  2da9		       38		      sec
    893  2daa		       60		      rts
    894  2dab
    895  2dab		       a5 44	   ILChkRange lda	ILPC+1
    896  2dad		       c9 30		      cmp	#IL>>8
    897  2daf		       90 18		      bcc	ILBadRange
    898  2db1		       d0 06		      bne	ILChkHigh
    899  2db3
    900  2db3		       a5 43		      lda	ILPC
    901  2db5		       c9 f7		      cmp	#IL&$ff
    902  2db7		       90 10		      bcc	ILBadRange
    903  2db9
    904  2db9		       a5 44	   ILChkHigh  lda	ILPC+1
    905  2dbb		       c9 35		      cmp	#ILEND>>8
    906  2dbd		       90 08		      bcc	ILGoodRange
    907  2dbf		       d0 08		      bne	ILBadRange
    908  2dc1
    909  2dc1		       a5 43		      lda	ILPC
    910  2dc3		       c9 50		      cmp	#ILEND&$ff
    911  2dc5		       b0 02		      bcs	ILBadRange
    912  2dc7
    913  2dc7		       18	   ILGoodRange clc
    914  2dc8		       60		      rts
    915  2dc9				   ILBadRange
    916  2dc9		       38		      sec
    917  2dca		       60		      rts
    918  2dcb
    919  2dcb
    920  2dcb							;=====================================================
    921  2dcb							; Set output vector to the console output function
    922  2dcb							;
    923  2dcb				   SetOutConsole
    924  2dcb		       48		      pha
    925  2dcc		       a9 0c		      lda	#OUTCH&$ff
    926  2dce		       8d 55 35 	      sta	BOutVec
    927  2dd1		       a9 f0		      lda	#OUTCH>>8
    928  2dd3		       8d 56 35 	      sta	BOutVec+1
    929  2dd6		       68		      pla
    930  2dd7		       60		      rts
    931  2dd8
    932  2dd8				   SetInConsole
    933  2dd8		       48		      pha
    934  2dd9		       a9 09		      lda	#GETCH&$ff
    935  2ddb		       8d 53 35 	      sta	BInVec
    936  2dde		       a9 f0		      lda	#GETCH>>8
    937  2de0		       8d 54 35 	      sta	BInVec+1
    938  2de3		       68		      pla
    939  2de4		       60		      rts
    940  2de5
    941  2de5
    942  2de5
    943  2de5							;====================================================
    944  2de5							;Clear the terminal assume it is ansii or vt100
    945  2de5							;
    946  2de5				   iCLEARSCREEN
    947  2de5		       20 f8 20 	      jsr	puts
      0  2de8					      db	$1b,'[,'2,'J,0
      1  2de8		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,0
    949  2ded		       4c b1 02 	      jmp	NextIL
    950  2df0
    951  2df0							;====================================================
    952  2df0							; Push true and false onto math stack
    953  2df0				   pushTrue
    954  2df0		       a9 ff		      lda	#$ff
    955  2df2		       85 52	   pushTF     sta	R0
    956  2df4		       85 53		      sta	R0+1
    957  2df6		       20 39 2b 	      jsr	pushR0
    958  2df9		       60		      rts
    959  2dfa		       a9 00	   pushFalse  lda	#0
    960  2dfc		       f0 f4		      beq	pushTF
    961  2dfe
    962  2dfe							;======================================================
    963  2dfe							; Copy stack top to R1
    964  2dfe				   CopyStackR1
    965  2dfe		       98		      tya
    966  2dff		       48		      pha
    967  2e00		       a4 4a		      ldy	MATHSTACKPTR
    968  2e02		       88		      dey
    969  2e03		       b1 48		      lda	(MATHSTACK),y
    970  2e05		       85 55		      sta	R1+1
    971  2e07		       88		      dey
    972  2e08		       b1 48		      lda	(MATHSTACK),y
    973  2e0a		       85 54		      sta	R1
    974  2e0c		       68		      pla
    975  2e0d		       a8		      tay
    976  2e0e		       60		      rts
    977  2e0f
    978  2e0f
    979  2e0f							;====================================================
    980  2e0f							;Swap the out debug call for standard calls
    981  2e0f		       00 00	   DebugIOSave ds	2
    982  2e11		       00 00	   DebugInSave ds	2
    983  2e13				   SetOutDebug
    984  2e13		       ad 55 35 	      lda	BOutVec
    985  2e16		       8d 0f 2e 	      sta	DebugIOSave
    986  2e19		       ad 56 35 	      lda	BOutVec+1
    987  2e1c		       8d 10 2e 	      sta	DebugIOSave+1
    988  2e1f		       a9 a7		      lda	#OUTDEBUG&$ff	; Put the Debug output
    989  2e21		       8d 55 35 	      sta	BOutVec
    990  2e24		       a9 2e		      lda	#OUTDEBUG>>8
    991  2e26		       8d 56 35 	      sta	BOutVec+1
    992  2e29		       60		      rts
    993  2e2a				   SetInDebug
    994  2e2a		       ad 53 35 	      lda	BInVec
    995  2e2d		       8d 11 2e 	      sta	DebugInSave
    996  2e30		       ad 54 35 	      lda	BInVec+1
    997  2e33		       8d 12 2e 	      sta	DebugInSave+1
    998  2e36		       a9 ab		      lda	#INDEBUG&$ff
    999  2e38		       8d 53 35 	      sta	BInVec
   1000  2e3b		       a9 2e		      lda	#INDEBUG>>8
   1001  2e3d		       8d 54 35 	      sta	BInVec+1
   1002  2e40		       60		      rts
   1003  2e41				   SetOutDebugEnd
   1004  2e41		       ad 0f 2e 	      lda	DebugIOSave
   1005  2e44		       8d 55 35 	      sta	BOutVec
   1006  2e47		       ad 10 2e 	      lda	DebugIOSave+1
   1007  2e4a		       8d 56 35 	      sta	BOutVec+1
   1008  2e4d		       60		      rts
   1009  2e4e				   SetInDebugEnd
   1010  2e4e		       ad 11 2e 	      lda	DebugInSave
   1011  2e51		       8d 53 35 	      sta	BInVec
   1012  2e54		       ad 12 2e 	      lda	DebugInSave+1
   1013  2e57		       8d 54 35 	      sta	BInVec+1
   1014  2e5a		       60		      rts
   1015  2e5b							;
   1016  2e5b							;====================================================
   1017  2e5b							; Set the input and output terminal address
   1018  2e5b							; The math stack stack byte is the output io slot
   1019  2e5b							; The math stack  is the input io slot
   1020  2e5b
   1021  2e5b				   iSetTerminal
   1022  2e5b		       20 cb 2b 	      jsr	popR0	; Process the output io addresses
   1023  2e5e		       20 88 2e 	      jsr	CalcSlot
   1024  2e61		       a5 52		      lda	R0
   1025  2e63		       09 01		      ora	#1
   1026  2e65		       8d a8 2e 	      sta	TerminalOutputPort
   1027  2e68		       a5 53		      lda	R0+1
   1028  2e6a		       8d a9 2e 	      sta	TerminalOutputPort+1
   1029  2e6d
   1030  2e6d		       20 cb 2b 	      jsr	popR0	; Process the input io address
   1031  2e70		       20 88 2e 	      jsr	CalcSlot
   1032  2e73		       a5 52		      lda	R0
   1033  2e75		       8d ac 2e 	      sta	TerminalStatusPort
   1034  2e78		       09 01		      ora	#1
   1035  2e7a		       8d b3 2e 	      sta	TerminalInputPort
   1036  2e7d		       a5 53		      lda	R0+1
   1037  2e7f		       8d b4 2e 	      sta	TerminalInputPort+1
   1038  2e82		       8d ad 2e 	      sta	TerminalStatusPort+1
   1039  2e85		       4c b1 02 	      jmp	NextIL
   1040  2e88
   1041  2e88							;===================================================
   1042  2e88							; Calculate the slot address the the slot number
   1043  2e88							; R0 contains the slot number 0-255
   1044  2e88
   1045  2e88				   CalcSlot
   1046  2e88		       8a		      txa
   1047  2e89		       48		      pha
   1048  2e8a
   1049  2e8a		       a2 04		      ldx	#4
   1050  2e8c				   CalcSlotLoop
   1051  2e8c		       18		      clc
   1052  2e8d		       26 52		      rol	R0
   1053  2e8f		       26 53		      rol	R0+1
   1054  2e91		       ca		      dex
   1055  2e92		       d0 f8		      bne	CalcSlotLoop
   1056  2e94
   1057  2e94		       a9 e0		      lda	#$E0
   1058  2e96		       05 53		      ora	R0+1
   1059  2e98		       85 53		      sta	R0+1
   1060  2e9a		       68		      pla
   1061  2e9b
   1062  2e9b		       aa		      tax
   1063  2e9c		       60		      rts
   1064  2e9d							;
   1065  2e9d							;====================================================
   1066  2e9d							; Output to the Terminal/Debug console
   1067  2e9d							;     x = high address byte
   1068  2e9d							;     y = low address byte
   1069  2e9d							;     a = Terminator for string
   1070  2e9d				   TerminalWrite
   1071  2e9d				   DebugWrite
   1072  2e9d		       20 13 2e 	      jsr	SetOutDebug
   1073  2ea0		       20 36 21 	      jsr	PrtStr
   1074  2ea3		       20 41 2e 	      jsr	SetOutDebugEnd
   1075  2ea6		       60		      rts
   1076  2ea7
   1077  2ea7				   TerminalIOblock
   1078  2ea7				   OUTDEBUG
   1079  2ea7		       8d		      .byte.b	$8D	; STA
   1080  2ea8				   TerminalOutputPort
   1081  2ea8		       21 e0	   DEBUGPORT  .word.w	$E021	; Dont check anything just output the byte
   1082  2eaa		       60		      RTS
   1083  2eab
   1084  2eab				   TerminalRead
   1085  2eab				   INDEBUG
   1086  2eab		       ad		      .byte.b	$AD	; LDA
   1087  2eac				   TerminalStatusPort
   1088  2eac		       20 e0	   DEBUGPORTSTATUS .word.w	$E020
   1089  2eae
   1090  2eae		       29 01		      and	#$01
   1091  2eb0		       f0 f9		      beq	INDEBUG
   1092  2eb2
   1093  2eb2		       ad		      .byte.b	$AD	; LDA
   1094  2eb3				   TerminalInputPort
   1095  2eb3		       21 e0	   DEBUGPORTIN .word.w	$E021
   1096  2eb5		       60		      rts
   1097  2eb6				   TerminalIOblockEnd
   1098  2eb6							;======================================================================
   1099  2eb6							;Copy Quoted string to buffer, terminate with 0 byte
   1100  2eb6							; R0  Source tring points to tString type
   1101  2eb6							; x is terminator
   1102  2eb6							; R1 points to destinition location
   1103  2eb6							; On exit R0 contains length of copy Plus Term and leading bytes
   1104  2eb6
   1105  2eb6				   qstrcpy
   1106  2eb6		       20 39 2b 	      jsr	pushR0
   1107  2eb9		       20 06 2f 	      jsr	IncR0	; point past the tString
   1108  2ebc		       20 06 2f 	      jsr	IncR0	; Point Past the opening "
   1109  2ebf		       a2 22		      ldx	#'"	; copy Termination
   1110  2ec1		       20 db 2e 	      jsr	pstrcpy
   1111  2ec4		       20 06 2f 	      jsr	IncR0	; point to "
   1112  2ec7		       20 06 2f 	      jsr	IncR0	; Point to next free byte
   1113  2eca		       20 e3 2b 	      jsr	popR1
   1114  2ecd		       38		      sec
   1115  2ece		       a5 52		      lda	R0
   1116  2ed0		       e5 54		      sbc	R1
   1117  2ed2		       85 52		      sta	R0
   1118  2ed4		       a5 53		      lda	R0+1
   1119  2ed6		       e5 55		      sbc	R1+1
   1120  2ed8		       85 53		      sta	R0+1
   1121  2eda		       60		      rts
   1122  2edb
   1123  2edb							;=========================================================================
   1124  2edb							;Copy string from R0 to R1, terminator in x
   1125  2edb							; On exit    R0 contains the length of the copy
   1126  2edb				   pstrcpy
   1127  2edb		       a0 00		      ldy	#0
   1128  2edd		       86 58		      stx	R2
   1129  2edf
   1130  2edf				   strcpyLoop
   1131  2edf		       b1 52		      lda	(R0),y
   1132  2ee1		       c5 58		      cmp	R2
   1133  2ee3		       f0 0a		      beq	strcpyDone
   1134  2ee5		       91 54		      sta	(R1),y
   1135  2ee7		       20 06 2f 	      jsr	IncR0
   1136  2eea		       20 f4 2e 	      jsr	IncR1
   1137  2eed		       90 f0		      bcc	strcpyLoop
   1138  2eef				   strcpyDone
   1139  2eef		       a9 00		      lda	#0
   1140  2ef1		       91 54		      sta	(R1),y
   1141  2ef3
   1142  2ef3		       60		      rts
   1143  2ef4
   1144  2ef4							;=========================================================================
   1145  2ef4							; on exit c is set on overflow
   1146  2ef4				   IncR1
   1147  2ef4		       48		      pha
   1148  2ef5		       18		      clc
   1149  2ef6		       a9 01		      lda	#1
   1150  2ef8		       65 54		      adc	R1
   1151  2efa		       85 54		      sta	R1
   1152  2efc		       90 06		      bcc	IncR1Done
   1153  2efe		       a9 00		      lda	#0
   1154  2f00		       65 55		      adc	R1+1
   1155  2f02		       85 55		      sta	R1+1
   1156  2f04				   IncR1Done
   1157  2f04		       68		      pla
   1158  2f05		       60		      rts
   1159  2f06							;=========================================================================
   1160  2f06							; on exit c is set on overflow
   1161  2f06				   IncR0
   1162  2f06		       48		      pha
   1163  2f07		       18		      clc
   1164  2f08		       a9 01		      lda	#1
   1165  2f0a		       65 52		      adc	R0
   1166  2f0c		       85 52		      sta	R0
   1167  2f0e		       90 06		      bcc	IncR0Done
   1168  2f10		       a9 00		      lda	#0
   1169  2f12		       65 53		      adc	R0+1
   1170  2f14		       85 53		      sta	R0+1
   1171  2f16				   IncR0Done
   1172  2f16		       68		      pla
   1173  2f17		       60		      rts
   1174  2f18
   1175  2f18
   1176  2f18
   1177  2f18
   1178  2f18
   1179  2f18
   1180  2f18
   1181  2f18
   1182  2f18
   1183  2f18
   1184  2f18
   1185  2f18
   1186  2f18
   1187  2f18
   1188  2f18
   1189  2f18
------- FILE mytb.asm
   2472  2f18
   2473  2f18					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  2f18					      include	"storage.asm"
      1  2f18							;
      2  2f18							;=====================================================
      3  2f18							;=====================================================
      4  2f18							;=====================================================
      5  2f18							; This file contains the functions for saving and
      6  2f18							; restoring programs from some sort of mass storage
      7  2f18							; device.  This particular version is for using the
      8  2f18							; Corsham Tech SD Card System.
      9  2f18							;=====================================================
     10  2f18							;=====================================================
     11  2f18							;=====================================================
     12  2f18
     13 U3561					      seg.u	TBData
     14 U3561		       00	   diskBufLength ds	1
     15 U3562		       00	   diskBufOffset ds	1
     16 U3563		       00 00 00 00*DiskFileName ds	64
     17 U35a3
     18  2f18					      SEG	Code
     19  2f18
     20  2f18							;
     21  2f18							;=====================================================
     22  2f18							; Open a file for reading as a program.  The next
     23  2f18							; thing on the line should be the filename.
     24  2f18							;
     25  2f18				   iOPENREAD
     26  2f18					      if	XKIM || CTMON65
     27  2f18		       20 32 2f 	      jsr	setFileName	;Set the file name to open
     28  2f1b		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  2f1e		       90 07		      bcc	Ropenok	;branch if opened ok
     30  2f20							;
     31  2f20							; Open failed
     32  2f20							;
     33  2f20		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  2f22		       a9 00	   Rdfail2    lda	#0
     35  2f24		       4c 5e 06 	      jmp	iErr2
     36  2f27							;
     37  2f27							; Clear counts and offsets so the next read will
     38  2f27							; cause the file to be read.
     39  2f27							;
     40  2f27		       a9 00	   Ropenok    lda	#0
     41  2f29		       8d 62 35 	      sta	diskBufOffset
     42  2f2c		       8d 61 35 	      sta	diskBufLength
     43  2f2f		       4c b1 02 	      jmp	NextIL
     44  2f32					      endif
     45  2f32
     46  2f32							;===============================================================
     47  2f32							; Set file name
     48  2f32				   setFileName
     49  2f32		       a4 51		      ldy	CUROFF
     50  2f34		       b1 4f		      lda	(CURPTR),y
     51  2f36		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  2f38		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  2f3a
     54  2f3a		       18		      clc
     55  2f3b		       98		      tya
     56  2f3c		       65 4f		      adc	CURPTR
     57  2f3e		       85 52		      sta	R0	;LSB
     58  2f40		       a5 50		      lda	CURPTR+1
     59  2f42		       69 00		      adc	#0
     60  2f44		       85 53		      sta	R0+1
     61  2f46		       a9 63		      lda	#DiskFileName&$ff
     62  2f48		       85 54		      sta	R1
     63  2f4a		       a9 35		      lda	#DiskFileName>>8
     64  2f4c		       85 55		      sta	R1+1
     65  2f4e		       20 b6 2e 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  2f51		       a5 52		      lda	R0
     67  2f53		       18		      clc
     68  2f54		       65 51		      adc	CUROFF	; add the current offset
     69  2f56		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  2f58				   ResetFileName
     71  2f58		       a0 63		      ldy	#DiskFileName&$ff
     72  2f5a		       a2 35		      ldx	#DiskFileName>>8
     73  2f5c		       18		      clc
     74  2f5d		       60		      rts
     75  2f5e
     76  2f5e				   setFileNameNotFound
     77  2f5e		       68		      pla
     78  2f5f		       68		      pla		; remove the return address from the stack
     79  2f60		       a9 00		      lda	#0
     80  2f62		       a2 09		      ldx	#ERR_NO_FILENAME
     81  2f64		       4c 5e 06 	      jmp	iErr2
     82  2f67
     83  2f67							;
     84  2f67							;==============================JUSTLOSTINTIME 08/02/2022========
     85  2f67							;Remove a file from the disk
     86  2f67				   iRMFILE
     87  2f67					      if	XKIM || CTMON65
     88  2f67		       20 32 2f 	      jsr	setFileName
     89  2f6a		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  2f6d		       90 07		      bcc	wrmOk	;branch if removed ok
     91  2f6f		       a9 00		      lda	#0
     92  2f71		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  2f73		       4c 5e 06 	      jmp	iErr2
     94  2f76				   wrmOk
     95  2f76		       4c b1 02 	      jmp	NextIL
     96  2f79
     97  2f79					      endif
     98  2f79							;
     99  2f79							;=====================================================
    100  2f79				   iOPENWRITE
    101  2f79					      if	XKIM || CTMON65
    102  2f79		       20 32 2f 	      jsr	setFileName
    103  2f7c		       20 40 29 	      jsr	getILByte	;get the append or create byte
    104  2f7f		       c9 01		      cmp	#1	;create/truncate
    105  2f81		       d0 06		      bne	iopencont
    106  2f83		       20 45 f0 	      jsr	DiskRmFile	;by default files opened for write are append
    107  2f86		       20 58 2f 	      jsr	ResetFileName	;point back to the file name
    108  2f89				   iopencont
    109  2f89
    110  2f89		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    111  2f8c		       90 07		      bcc	Wopenok	;branch if opened ok
    112  2f8e							;
    113  2f8e							; Open failed
    114  2f8e							;
    115  2f8e		       a9 00	   Wdfail     lda	#0
    116  2f90		       a2 08		      ldx	#ERR_WRITE_FAIL
    117  2f92		       4c 5e 06 	      jmp	iErr2
    118  2f95							;
    119  2f95		       4c b1 02    Wopenok    jmp	NextIL
    120  2f98					      endif
    121  2f98							;
    122  2f98							;=====================================================
    123  2f98							; Gets a line of input from the disk file and puts it
    124  2f98							; into LINBUF.
    125  2f98							;
    126  2f98							; On exit:
    127  2f98							;    CURPTR points to LINBUF
    128  2f98							;    LINBUF contains the line with 0 at the end.
    129  2f98							;    Y has offset to first non-space character
    130  2f98							;    CURROFF has the same as Y.
    131  2f98							;
    132  2f98				   iDGETLINE
    133  2f98					      if	XKIM || CTMON65
    134  2f98		       a2 7f		      ldx	#LINBUF&$ff
    135  2f9a		       86 4f		      stx	CURPTR
    136  2f9c		       a2 41		      ldx	#LINBUF>>8
    137  2f9e		       86 50		      stx	CURPTR+1
    138  2fa0							;
    139  2fa0		       a2 00		      ldx	#0	;offset
    140  2fa2		       8e 03 42    iDgetLoop  stx	getlinx
    141  2fa5		       20 10 30 	      jsr	getNextFileByte
    142  2fa8		       b0 16		      bcs	iGetEOF
    143  2faa		       c9 0d		      cmp	#CR
    144  2fac		       f0 0d		      beq	iGetEOL
    145  2fae		       c9 0a		      cmp	#LF
    146  2fb0		       f0 09		      beq	iGetEOL
    147  2fb2		       ae 03 42 	      ldx	getlinx
    148  2fb5		       9d 7f 41 	      sta	LINBUF,x
    149  2fb8		       e8		      inx
    150  2fb9		       d0 e7		      bne	iDgetLoop
    151  2fbb							;
    152  2fbb							; Handle end of line.	If the line has nothing, loop
    153  2fbb							; back and get another line.
    154  2fbb							;
    155  2fbb		       ae 03 42    iGetEOL    ldx	getlinx	;blank line?
    156  2fbe		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    157  2fc0							;
    158  2fc0							; This can fall through when there is a line, or
    159  2fc0							; called directly when EOF is encountered.
    160  2fc0							;
    161  2fc0		       ae 03 42    iGetEOF    ldx	getlinx
    162  2fc3		       a9 00		      lda	#0
    163  2fc5		       9d 7f 41 	      sta	LINBUF,x
    164  2fc8		       a0 00		      ldy	#0
    165  2fca		       20 7b 2c 	      jsr	SkipSpaces
    166  2fcd		       20 a2 1c 	      jsr	ParseInputLine
    167  2fd0		       a9 9f		      lda	#TOKENBUFFER&$ff
    168  2fd2		       85 4f		      sta	CURPTR
    169  2fd4		       a9 1b		      lda	#TOKENBUFFER>>8
    170  2fd6		       85 50		      sta	CURPTR+1
    171  2fd8		       a9 01		      lda	#1
    172  2fda		       85 51		      sta	CUROFF
    173  2fdc		       4c b1 02 	      jmp	NextIL
    174  2fdf					      endif
    175  2fdf
    176  2fdf							;
    177  2fdf							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    178  2fdf							; DISK
    179  2fdf							;
    180  2fdf				   iDDIR
    181  2fdf					      if	XKIM || CTMON65
    182  2fdf		       20 30 f0 	      jsr	DiskDir
    183  2fe2							;
    184  2fe2							; Get/Display each entry
    185  2fe2							;
    186  2fe2		       a2 35	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    187  2fe4		       a0 63		      ldy	#DiskFileName&$ff
    188  2fe6		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    189  2fe9		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    190  2feb		       20 f8 20 	      jsr	puts
      0  2fee					      db	"   ",0
      1  2fee		       20 20 20 00	      .byte.b	"   ",0
    192  2ff2							; Print the line to the console
    193  2ff2		       a2 35		      ldx	#DiskFileName>>8	;pointer to buffer
    194  2ff4		       a0 63		      ldy	#DiskFileName&$ff
    195  2ff6		       a5 00		      lda	0
    196  2ff8		       20 36 21 	      jsr	PrtStr	;else print name
    197  2ffb		       20 18 f0 	      jsr	crlf
    198  2ffe
    199  2ffe		       4c e2 2f 	      jmp	DiskDirLoop	;do next entry
    200  3001
    201  3001		       4c b1 02    DiskDirEnd jmp	NextIL
    202  3004					      endif
    203  3004							;
    204  3004							;=====================================================
    205  3004							; Does a LIST to a Disk file.
    206  3004							;
    207  3004				   iDLIST
    208  3004					      if	XKIM || CTMON65
    209  3004		       20 3f 30 	      jsr	SetOutDisk
    210  3007		       4c 19 08 	      jmp	iLST2
    211  300a					      endif
    212  300a							;
    213  300a							;=====================================================
    214  300a							; Closes any pending disk file.  Okay to call if there
    215  300a							; is no open file.
    216  300a							;
    217  300a				   iDCLOSE
    218  300a					      if	XKIM || CTMON65
    219  300a		       20 42 f0 	      jsr	DiskClose
    220  300d		       4c b1 02 	      jmp	NextIL
    221  3010					      endif
    222  3010							;
    223  3010							;=====================================================
    224  3010							; This gets the next byte from an open disk file.  If
    225  3010							; there are no more bytes left, this returns C set.
    226  3010							; Else, C is clear and A contains the character.
    227  3010							;
    228  3010				   getNextFileByte
    229  3010					      if	XKIM || CTMON65
    230  3010		       ae 62 35 	      ldx	diskBufOffset
    231  3013		       ec 61 35 	      cpx	diskBufLength
    232  3016		       d0 14		      bne	hasdata	;branch if still data
    233  3018							;
    234  3018							; There is no data left in the buffer, so read a
    235  3018							; block from the SD system.
    236  3018							;
    237  3018		       a9 84		      lda	#BUFFER_SIZE
    238  301a		       a2 df		      ldx	#buffer>>8
    239  301c		       a0 0a		      ldy	#buffer&$ff
    240  301e		       20 3c f0 	      jsr	DiskRead
    241  3021		       b0 12		      bcs	getNextEof
    242  3023							;
    243  3023							; A contains the number of bytes actually read.
    244  3023							;
    245  3023		       8d 61 35 	      sta	diskBufLength	;save length
    246  3026		       c9 00		      cmp	#0	;shouldn't happen
    247  3028		       f0 0b		      beq	getNextEof
    248  302a							;
    249  302a		       a2 00		      ldx	#0
    250  302c		       bd 0a df    hasdata    lda	buffer,x
    251  302f		       e8		      inx
    252  3030		       8e 62 35 	      stx	diskBufOffset
    253  3033		       18		      clc
    254  3034		       60		      rts
    255  3035							;
    256  3035		       a9 00	   getNextEof lda	#0
    257  3037		       8d 62 35 	      sta	diskBufOffset
    258  303a		       8d 61 35 	      sta	diskBufLength
    259  303d		       38		      sec
    260  303e		       60		      rts
    261  303f							;
    262  303f							;=====================================================
    263  303f							; Set output vector to the disk output function
    264  303f							;
    265  303f		       a9 4a	   SetOutDisk lda	#DOUT&$ff
    266  3041		       8d 55 35 	      sta	BOutVec
    267  3044		       a9 30		      lda	#DOUT/256
    268  3046		       8d 56 35 	      sta	BOutVec+1
    269  3049		       60		      rts
    270  304a							;
    271  304a							;=====================================================
    272  304a							; input a contains charater to write to open file
    273  304a							; output:
    274  304a							;	    C flag clear if no error
    275  304a							;
    276  304a		       8e 63 35    DOUT       stx	DiskFileName	; Save the x value, fulename not used
    277  304d		       8c 64 35 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    278  3050		       8d 0a df 	      sta	buffer	; Store the byte to send into the buffer
    279  3053		       a9 01		      lda	#1	; set number of bytes to send to 1
    280  3055		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    281  3057		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    282  3059		       20 3f f0 	      jsr	DiskWrite	; Place the character to disk if a file is open
    283  305c		       ae 63 35 	      ldx	DiskFileName	; Restore the x value that was saved
    284  305f		       ac 64 35 	      ldy	DiskFileName+1	; Restore the y value saved
    285  3062		       60		      rts
    286  3063							;=======================================================
    287  3063							; output:
    288  3063							;	  c flag is clear if no error, a contains bytes read
    289  3063							;	  c flag set Reached eof, a undefined
    290  3063							;
    291  3063		       8e 63 35    DIN	      stx	DiskFileName	; Save the x value, filename not used just storage
    292  3066		       8c 64 35 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    293  3069		       a9 01		      lda	#1	; set number of bytes to read to 1
    294  306b		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    295  306d		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    296  306f		       20 3c f0 	      jsr	DiskRead
    297  3072		       ad 0a df 	      lda	buffer	; Get the byte just read
    298  3075		       ae 63 35 	      ldx	DiskFileName
    299  3078		       ac 64 35 	      ldy	DiskFileName+1
    300  307b		       60		      rts
    301  307c
    302  307c							;========================================================
    303  307c							; Dstat / open/close/stat files
    304  307c				   DSTAT
    305  307c		       60		      rts
    306  307d							;========================================================
    307  307d					      endif
------- FILE mytb.asm
   2475  307d					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  307d					      include	"IL.inc"
      1  307d
      2  307d							;=====================================================
      3  307d							; IL.inc
      4  307d							; These are macros for IL instructions
      5  307d							;
      6  307d					      mac	dw
      7  307d					      .word	{0}
      8  307d					      endm
      9  307d					      mac	db
     10  307d					      .byte	{0}
     11  307d					      endm
     12  307d					      macro	xinit
     13  307d					      db	0
     14  307d					      endm		;reset the il to start clear all
     15  307d							;
     16  307d					      macro	done
     17  307d					      db	1
     18  307d					      endm		;print an error if not end of line
     19  307d							;
     20  307d					      macro	prs
     21  307d					      db	2
     22  307d					      endm		;print a quoted string
     23  307d							;
     24  307d					      macro	prn
     25  307d					      db	3
     26  307d					      endm		;print a number
     27  307d							;
     28  307d					      macro	spc
     29  307d					      db	4
     30  307d					      endm		;print space til new tabstop
     31  307d							;
     32  307d					      macro	nline
     33  307d					      db	5
     34  307d					      endm		;print a new line crlf
     35  307d							;
     36  307d							; My NXT is a bit different in that it takes one
     37  307d							; parameter, which is an address.  If the BASIC
     38  307d							; program is currently running then move to the
     39  307d							; next line and continue execution.  However, if
     40  307d							; in direct mode, jump to the specified IL label.
     41  307d							;
     42  307d					      macro	nxt
     43  307d					      db	6
     44  307d					      dw	{1}	; addr
     45  307d					      endm		; addr
     46  307d							;
     47  307d					      macro	xfer
     48  307d					      db	7
     49  307d					      endm
     50  307d							;
     51  307d					      macro	sav
     52  307d					      db	8
     53  307d					      db	{1}
     54  307d					      endm
     55  307d							;
     56  307d							;  Passed jump if function called, and true false value returned
     57  307d					      macro	rstr
     58  307d					      db	9
     59  307d					      db	({1}-*)-1	;(addr-*)-1
     60  307d					      db	{2}
     61  307d					      endm
     62  307d							;
     63  307d					      macro	cmpr
     64  307d					      db	10
     65  307d					      endm
     66  307d							;
     67  307d					      macro	innum
     68  307d					      db	11
     69  307d					      endm
     70  307d							;
     71  307d					      macro	fin
     72  307d					      db	12
     73  307d					      endm
     74  307d							;
     75  307d							; ERR is followed by an error number.	The error
     76  307d							; code is printed along with the line number.
     77  307d							; Control is passed to the statement set with
     78  307d							; the ERRGOTO statement.
     79  307d							;
     80  307d					      macro	errmsg
     81  307d					      db	13
     82  307d					      dw	{1}	;ecode
     83  307d					      endm		;ecode
     84  307d							;
     85  307d					      macro	add
     86  307d					      db	14
     87  307d					      endm
     88  307d							;
     89  307d					      macro	sub
     90  307d					      db	15
     91  307d					      endm
     92  307d							;
     93  307d					      macro	neg
     94  307d					      db	16
     95  307d					      endm
     96  307d							;
     97  307d					      macro	mul
     98  307d					      db	17
     99  307d					      endm
    100  307d							;
    101  307d					      macro	div
    102  307d					      db	18
    103  307d					      endm
    104  307d							;
    105  307d					      macro	store
    106  307d					      db	19
    107  307d					      endm
    108  307d							;
    109  307d					      macro	ind
    110  307d					      db	20
    111  307d					      endm
    112  307d							;
    113  307d					      macro	lst
    114  307d					      db	21
    115  307d					      endm
    116  307d							;
    117  307d					      macro	init
    118  307d					      db	22
    119  307d					      endm
    120  307d							;
    121  307d					      macro	getline
    122  307d					      db	23
    123  307d					      endm
    124  307d							;
    125  307d					      macro	insert
    126  307d					      db	24
    127  307d					      endm
    128  307d							;
    129  307d					      macro	rtn
    130  307d					      db	25
    131  307d					      endm
    132  307d							;
    133  307d					      macro	exit
    134  307d					      db	26
    135  307d					      endm
    136  307d							;
    137  307d					      macro	lit
    138  307d					      db	27
    139  307d					      dw	{1}	;value
    140  307d					      endm		; value LIT
    141  307d							;
    142  307d					      macro	call
    143  307d					      db	28
    144  307d					      dw	{1}	;addr
    145  307d					      endm		;addr
    146  307d							;
    147  307d							; IJMP will set the IL PC to the specified value.
    148  307d							;
    149  307d					      macro	ijmp
    150  307d					      db	29
    151  307d					      dw	{1}	;addr
    152  307d					      endm		;addr
    153  307d							;
    154  307d					      macro	vinit
    155  307d					      db	30
    156  307d					      endm
    157  307d							;
    158  307d							; ERRGOTO sets the point in the code where the IL
    159  307d							; interpreter will go after any error.
    160  307d							;
    161  307d					      macro	errgoto
    162  307d					      db	31
    163  307d					      dw	{1}	;addr
    164  307d					      endm		;addr
    165  307d							;
    166  307d					      macro	tst
    167  307d					      db	32
    168  307d					      db	({1}-*)-1	;(addr-*)-1
    169  307d					      db	{2},0	;string,0
    170  307d					      endm		;addr,string
    171  307d							;
    172  307d					      macro	tstv
    173  307d					      db	33
    174  307d					      db	({1}-*)-1	;(addr-*)-1
    175  307d					      endm		;addr
    176  307d							;
    177  307d					      macro	tstl
    178  307d					      db	34
    179  307d					      db	({1}-*)-1	;(addr-*)-1
    180  307d					      endm		;addr
    181  307d							;
    182  307d					      macro	tstn
    183  307d					      db	35
    184  307d					      db	({1}-*)-1	;(addr-*)-1
    185  307d					      endm		;addr
    186  307d							;
    187  307d							; FREE returns the amount of free RAM on top of
    188  307d							; the stack.  This is the amount of room the user
    189  307d							; program has available.
    190  307d							;
    191  307d					      macro	free
    192  307d					      db	36
    193  307d					      endm
    194  307d							;
    195  307d							; RANDOM takes the top item off the stack and
    196  307d							; replaces it with a random number that is
    197  307d							; MOD the initial value.  Ie, if the TOS is
    198  307d							; 42 then RANDOM returns a value from 0 to 41.
    199  307d							;
    200  307d					      macro	random
    201  307d					      db	37
    202  307d					      endm
    203  307d							;
    204  307d							; ABS will replace the top of stack with the
    205  307d							; absolute value.
    206  307d							;
    207  307d					      macro	abs
    208  307d					      db	38
    209  307d					      endm
    210  307d							;
    211  307d							; OPENREAD opens a file for reading, as in getting
    212  307d							; statements from it.
    213  307d							;
    214  307d					      macro	openread
    215  307d					      db	39
    216  307d					      endm
    217  307d							;
    218  307d							; OPENWRITE opens a file for writing, as in saving
    219  307d							; the current program to it.
    220  307d							;
    221  307d					      macro	openwrite
    222  307d					      db	40
    223  307d					      db	{1}	; 0= append 1 = create/truncate
    224  307d					      endm
    225  307d							;
    226  307d							; DCLOSE closes any open disk file.
    227  307d							;
    228  307d					      macro	dclose
    229  307d					      db	41
    230  307d					      endm
    231  307d							;
    232  307d							; DGETLINE gets one line from the disk file and puts it
    233  307d							; into LINBUFF.
    234  307d							;
    235  307d					      macro	dgetline
    236  307d					      db	42
    237  307d					      endm
    238  307d							;
    239  307d							; DLIST saves the program to an open disk file.
    240  307d							;
    241  307d					      macro	dlist
    242  307d					      db	43
    243  307d					      endm
    244  307d							; DDIR list the current directory
    245  307d							;
    246  307d					      macro	ddir
    247  307d					      db	44
    248  307d					      endm
    249  307d
    250  307d							; RMFILE remove a fle from disk
    251  307d					      macro	rmfile
    252  307d					      db	45
    253  307d					      endm
    254  307d
    255  307d							; CLEARSCREEN clear the screen
    256  307d					      macro	clearscreen
    257  307d					      db	46
    258  307d					      endm
    259  307d							; POKEMEM Poke value into memory
    260  307d					      macro	pokemem
    261  307d					      db	47
    262  307d					      endm
    263  307d							; PEEKMEM peek at value in memory
    264  307d					      macro	peekmem
    265  307d					      db	48
    266  307d					      endm
    267  307d							; TSTLET Test if the statement is a let without the keyword let
    268  307d					      macro	tstlet
    269  307d					      db	49
    270  307d					      db	({1}-*)-1	;(addr-*)-1
    271  307d					      endm		;addr
    272  307d							; TSTDONE if we reach the end of a statement
    273  307d					      macro	tstdone
    274  307d					      db	50
    275  307d					      db	({1}-*)-1	;(addr-*)-1
    276  307d					      endm		;addr
    277  307d							; GETCHAR	get a character from the input line leave it in RO
    278  307d					      macro	getchar
    279  307d					      db	51
    280  307d					      endm
    281  307d							; PUTCHAR	Put a character to the terminal
    282  307d					      macro	putchar
    283  307d					      db	52
    284  307d					      endm
    285  307d							; Call		Call a machine function return a to stack
    286  307d					      macro	callfunc
    287  307d					      db	53
    288  307d					      endm
    289  307d
    290  307d							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    291  307d					      macro	ibranch
    292  307d					      db	54
    293  307d					      endm
    294  307d
    295  307d							; TSTSTR	 Tests for the open quote in a string
    296  307d					      macro	tststr
    297  307d					      db	55
    298  307d					      db	({1}-*)-1	;(addr-*)-1
    299  307d					      endm
    300  307d							; SETIRQ	Sets the line number to run when an irq happens irq 550
    301  307d					      macro	setirq
    302  307d					      db	56
    303  307d					      endm
    304  307d
    305  307d							; TSTIRQ	Test for irq pending,
    306  307d							;		if so push the IRQ LINE NUMBER into RO, onto stack
    307  307d					      macro	tstirq
    308  307d					      db	57
    309  307d					      db	({1}-*)-1	;(addr-*)-1
    310  307d					      endm
    311  307d
    312  307d							; IRET    return from interupt service
    313  307d					      macro	iret
    314  307d					      db	58
    315  307d					      endm
    316  307d
    317  307d							; INSTR   read a string from the input
    318  307d					      macro	instr
    319  307d					      db	59
    320  307d					      endm
    321  307d
    322  307d							; MODULO Returns the remainder of the division
    323  307d					      macro	modulo
    324  307d					      db	60
    325  307d					      endm
    326  307d							; Set a task line
    327  307d					      macro	taskcreate
    328  307d					      db	61
    329  307d					      endm
    330  307d							; End a task
    331  307d					      macro	etask
    332  307d					      db	62
    333  307d					      endm
    334  307d							; Skip to next task
    335  307d					      macro	ntask
    336  307d					      db	63
    337  307d					      endm
    338  307d							; Subscript
    339  307d					      macro	subscript
    340  307d					      db	64
    341  307d					      db	{1}
    342  307d					      endm
    343  307d							; KILL Task
    344  307d					      macro	taskkill
    345  307d					      db	65
    346  307d					      endm
    347  307d							; STAT Task
    348  307d					      macro	taskstat
    349  307d					      db	66
    350  307d					      endm
    351  307d							;  output value as hex
    352  307d					      macro	hexprt
    353  307d					      db	67
    354  307d					      endm
    355  307d							;  Read in background has completed
    356  307d					      macro	readcomplete
    357  307d					      db	68
    358  307d					      endm
    359  307d							;  ReadInput line
    360  307d					      macro	readstart
    361  307d					      db	69
    362  307d					      endm
    363  307d							; Startio request
    364  307d					      macro	startio
    365  307d					      db	70
    366  307d					      endm
    367  307d							; Endio
    368  307d					      macro	endio
    369  307d					      db	71
    370  307d					      endm
    371  307d							; Logical not
    372  307d					      macro	lognot
    373  307d					      db	72
    374  307d					      endm
    375  307d							; Logical OR
    376  307d					      macro	logor
    377  307d					      db	73
    378  307d					      endm
    379  307d							;Logical and
    380  307d					      macro	logand
    381  307d					      db	74
    382  307d					      endm
    383  307d							;Logical XOR
    384  307d					      macro	logxor
    385  307d					      db	75
    386  307d					      endm
    387  307d							;Wait for task to complete, or list of tasks
    388  307d					      macro	wtask
    389  307d					      db	76
    390  307d					      db	({1}-*)-1	;(addr-*)-1
    391  307d					      endm
    392  307d							;Get the current task id
    393  307d					      MACRO	taskpid
    394  307d					      db	77
    395  307d					      endm
    396  307d							;Trace the basic execution
    397  307d					      Macro	traceprogram
    398  307d					      db	78
    399  307d					      endm
    400  307d							;Do a basic program Trace
    401  307d					      Macro	debugbasic
    402  307d					      db	79
    403  307d					      endm
    404  307d
    405  307d							; Inter Process communications instructions
    406  307d					      Macro	ipcsend
    407  307d					      db	80
    408  307d					      endm
    409  307d					      Macro	ipcreceive
    410  307d					      db	81
    411  307d					      endm
    412  307d					      Macro	ipccheck
    413  307d					      db	82
    414  307d					      endm
    415  307d					      Macro	ipcio
    416  307d					      db	83
    417  307d					      endm
    418  307d					      Macro	pushmathstack
    419  307d					      db	84
    420  307d					      endm
    421  307d					      Macro	popmathstack
    422  307d					      db	85
    423  307d					      endm
    424  307d					      Macro	savemathstack
    425  307d					      db	86
    426  307d					      endm
    427  307d					      Macro	restoremathstack
    428  307d					      db	87
    429  307d					      endm
    430  307d					      Macro	incparmcount
    431  307d					      db	88
    432  307d					      endm
    433  307d					      Macro	taskgetmathstack
    434  307d					      db	89
    435  307d					      endm
    436  307d					      Macro	taskenable
    437  307d					      db	90
    438  307d					      endm
    439  307d					      Macro	tasksuspend
    440  307d					      db	91
    441  307d					      endm
    442  307d					      Macro	taskputmathptr
    443  307d					      db	92
    444  307d					      endm
    445  307d							; Test for an extension type of variable that allows access to a tasks variables
    446  307d							; Using  PID!<Var name>
    447  307d					      Macro	tstvt
    448  307d					      db	93
    449  307d					      db	({1}-*)-1	;(addr-*)-1
    450  307d					      endm
    451  307d
    452  307d							; Provide access to R2 for the IL program
    453  307d					      Macro	setr2
    454  307d					      db	94
    455  307d					      db	{1}	; R2 is only one byte
    456  307d					      endm
    457  307d
    458  307d							;Move stack top to temp
    459  307d					      Macro	stk2tmp
    460  307d					      db	95
    461  307d					      endm
    462  307d
    463  307d					      Macro	tmp2stk
    464  307d					      db	96
    465  307d					      endm
    466  307d
    467  307d					      Macro	tstbyte
    468  307d					      db	97
    469  307d					      db	({1}-*)-1	; (addr-*)-1 goto if match
    470  307d					      dw	{2}	; address to check
    471  307d					      db	{3}	; Value to compare
    472  307d					      endm
    473  307d
    474  307d					      Macro	incvar
    475  307d					      db	98
    476  307d					      endm
    477  307d					      Macro	decvar
    478  307d					      db	99
    479  307d					      endm
    480  307d
    481  307d					      Macro	slice
    482  307d					      db	100
    483  307d					      endm
    484  307d
    485  307d					      Macro	tstb
    486  307d					      db	101
    487  307d					      db	({1}-*)-1
    488  307d					      db	{2}
    489  307d					      endm
    490  307d
    491  307d					      Macro	tstw
    492  307d					      db	102
    493  307d					      db	({1}-*)-1
    494  307d					      dw	{2}
    495  307d					      endm
    496  307d
    497  307d					      Macro	ongoto
    498  307d					      db	103
    499  307d					      dw	{1}
    500  307d					      dw	{2}
    501  307d					      endm
    502  307d
    503  307d					      Macro	tstrelop
    504  307d					      db	104
    505  307d					      db	({1}-*)-1
    506  307d					      endm
    507  307d
    508  307d					      Macro	repeatline
    509  307d					      db	105
    510  307d					      endm
    511  307d
    512  307d							; Check for a precompiled branch, will take branch if precompiled value present
    513  307d					      Macro	tstbranch
    514  307d					      db	106
    515  307d					      db	({1}-*)-1
    516  307d					      endm
    517  307d
    518  307d					      Macro	fastxfer
    519  307d					      db	107
    520  307d					      endm
    521  307d
    522  307d							; Set all io to to a terminal for input output
    523  307d							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    524  307d							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    525  307d					      Macro	setterminal
    526  307d					      db	108
    527  307d					      endm
    528  307d
    529  307d							;Fetch a single byte from memory
    530  307d					      Macro	indb
    531  307d					      db	109
    532  307d					      endm
    533  307d
    534  307d							; Set a block of memory to a fixed value, byte or word
    535  307d							; Stack must contain destiniation address, length to set in bytes, value {byte of word} to initialize to
    536  307d					      Macro	setblock
    537  307d					      db	110
    538  307d					      db	{1}	; the data type to initialize	tByte or tInteger
    539  307d					      endm
    540  307d
    541  307d							; Copy a block of memory
    542  307d							; Stack must contain source address, destination address, length in bytes
    543  307d					      Macro	copyblock
    544  307d					      db	111
    545  307d					      endm
    546  307d
    547  307d							; Compare one block of memory to another
    548  307d							; Stack contains Length, Source1 Source 2
    549  307d							; Place on stack 0 equal, 1 s1>s2, -1 s1 < s2
    550  307d					      Macro	cmpmem
    551  307d					      db	112
    552  307d					      endm
    553  307d
    554  307d							; Shift Left and Right
    555  307d					      Macro	shift
    556  307d					      db	113
    557  307d					      db	{1}	; direction  0 = left 1 = right
    558  307d					      endm
------- FILE mytb.asm
   2477  307d							;
   2478  307d				  -	      if	FIXED
   2479  307d				  -	      org	$1000
   2480  307d					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  307d					      include	"basic.il"
      1  307d					      seg	Code
      2  307d							; on goto table
      3  307d							; format :   first byte is value Base, subtracted from value found
      4  307d							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  307d				   BasicStmts
      0  307d					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  307d		       01 23		      .byte.b	kBeginKey,(kKeyCount+1)
      0  307f					      dw	ekLet
      1  307f		       0a 31		      .word.w	ekLet
      0  3081					      dw	ekInc
      1  3081		       3c 31		      .word.w	ekInc
      0  3083					      dw	ekDec
      1  3083		       49 31		      .word.w	ekDec
      0  3085					      dw	ekIreturn
      1  3085		       56 31		      .word.w	ekIreturn
      0  3087					      dw	ekIf
      1  3087		       5b 31		      .word.w	ekIf
      0  3089					      dw	ekThen
      1  3089		       61 31		      .word.w	ekThen
      0  308b					      dw	ekGoto
      1  308b		       65 31		      .word.w	ekGoto
      0  308d					      dw	ekGosub
      1  308d		       f7 34		      .word.w	ekGosub
      0  308f					      dw	ekReturn
      1  308f		       05 35		      .word.w	ekReturn
      0  3091					      dw	ekRem
      1  3091		       79 31		      .word.w	ekRem
      0  3093					      dw	ekPrint	; should be entry for print
      1  3093		       8f 31		      .word.w	ekPrint
      0  3095					      dw	ekTaske
      1  3095		       dc 31		      .word.w	ekTaske
      0  3097					      dw	ekTaskn
      1  3097		       f2 31		      .word.w	ekTaskn
      0  3099					      dw	ekTaskw
      1  3099		       f9 31		      .word.w	ekTaskw
      0  309b					      dw	ekPoke
      1  309b		       14 32		      .word.w	ekPoke
      0  309d					      dw	ekPutch
      1  309d		       76 32		      .word.w	ekPutch
      0  309f					      dw	ekCls
      1  309f		       81 32		      .word.w	ekCls
      0  30a1					      dw	ekInput
      1  30a1		       88 32		      .word.w	ekInput
      0  30a3					      dw	ekEnd
      1  30a3		       b1 32		      .word.w	ekEnd
      0  30a5					      dw	ekIrq
      1  30a5		       b5 32		      .word.w	ekIrq
      0  30a7					      dw	ekKill
      1  30a7		       c0 32		      .word.w	ekKill
      0  30a9					      dw	ekList
      1  30a9		       cb 32		      .word.w	ekList
      0  30ab					      dw	ekRun
      1  30ab		       d0 32		      .word.w	ekRun
      0  30ad					      dw	ekNew
      1  30ad		       d9 32		      .word.w	ekNew
      0  30af					      dw	ekSlice
      1  30af		       dd 32		      .word.w	ekSlice
      0  30b1					      dw	ekTrace
      1  30b1		       e8 32		      .word.w	ekTrace
      0  30b3					      dw	ekExit
      1  30b3		       f9 32		      .word.w	ekExit
      0  30b5					      dw	ekSave
      1  30b5		       fa 32		      .word.w	ekSave
      0  30b7					      dw	ekLoad
      1  30b7		       01 33		      .word.w	ekLoad
      0  30b9					      dw	ekErase
      1  30b9		       11 33		      .word.w	ekErase
      0  30bb					      dw	ekDir
      1  30bb		       0d 33		      .word.w	ekDir
      0  30bd					      dw	ekSetTerm
      1  30bd		       7f 31		      .word.w	ekSetTerm
      0  30bf					      dw	ekSetMemB
      1  30bf		       2b 32		      .word.w	ekSetMemB
      0  30c1					      dw	ekSetMemW
      1  30c1		       37 32		      .word.w	ekSetMemW
      0  30c3					      dw	ekCopyMem
      1  30c3		       59 32		      .word.w	ekCopyMem
     42  30c5							;
     43  30c5							; Logical operators
      0  30c5				   BasicLogical db	kOr,3
      1  30c5		       25 03		      .byte.b	kOr,3
      0  30c7					      dw	ekOr
      1  30c7		       4d 33		      .word.w	ekOr
      0  30c9					      dw	ekXor
      1  30c9		       52 33		      .word.w	ekXor
      0  30cb					      dw	ekAnd
      1  30cb		       48 33		      .word.w	ekAnd
     48  30cd
      0  30cd				   BasicShift db	kShr,2
      1  30cd		       28 02		      .byte.b	kShr,2
      0  30cf					      dw	ekShiftRight
      1  30cf		       3d 33		      .word.w	ekShiftRight
      0  30d1					      dw	ekShiftLeft
      1  30d1		       37 33		      .word.w	ekShiftLeft
     52  30d3
     53  30d3							;functions returning values
     54  30d3
      0  30d3				   BasicFuncs db	kBeginFunc,kFuncCount
      1  30d3		       2a 11		      .byte.b	kBeginFunc,kFuncCount
      0  30d5					      dw	ekTrue
      1  30d5		       b2 33		      .word.w	ekTrue
      0  30d7					      dw	ekFalse
      1  30d7		       b6 33		      .word.w	ekFalse
      0  30d9					      dw	ekFree
      1  30d9		       ba 33		      .word.w	ekFree
      0  30db					      dw	ekGetch
      1  30db		       c2 33		      .word.w	ekGetch
      0  30dd					      dw	ekPeek
      1  30dd		       f0 33		      .word.w	ekPeek
      0  30df					      dw	ekTask
      1  30df		       fb 33		      .word.w	ekTask
      0  30e1					      dw	ekIpcc
      1  30e1		       47 34		      .word.w	ekIpcc
      0  30e3					      dw	ekIpcs
      1  30e3		       22 34		      .word.w	ekIpcs
      0  30e5					      dw	ekIpcr
      1  30e5		       33 34		      .word.w	ekIpcr
      0  30e7					      dw	ekRnd
      1  30e7		       52 34		      .word.w	ekRnd
      0  30e9					      dw	ekStat
      1  30e9		       70 34		      .word.w	ekStat
      0  30eb					      dw	ekAbs
      1  30eb		       65 34		      .word.w	ekAbs
      0  30ed					      dw	ekCall
      1  30ed		       7d 34		      .word.w	ekCall
      0  30ef					      dw	ekGofn
      1  30ef		       fe 34		      .word.w	ekGofn
      0  30f1					      dw	ekPid
      1  30f1		       7b 34		      .word.w	ekPid
      0  30f3					      dw	ekAddr
      1  30f3		       ca 33		      .word.w	ekAddr
      0  30f5					      dw	ekCmpMem
      1  30f5		       d9 33		      .word.w	ekCmpMem
     73  30f7							;====================================================
     74  30f7							; file constants
     75  30f7		       00 00	   OPEN_APPEND equ	0	; append to file
     76  30f7		       00 01	   OPEN_CREATE equ	1	; truncate/create file
     77  30f7
     78  30f7							;=====================================================
     79  30f7							; This is the IL of the BASIC (or whatever) language.
     80  30f7							; Because of the way macros are implemented by as65,
     81  30f7							; labels can't be on the same line as a macro
     82  30f7							; invocation, so that's why labels are on separate
     83  30f7							; lines.
     84  30f7							;
     85  30f7		       30 f7	   IL	      equ	*
     86  30f7
     87  30f7							;THE IL CONTROL SECTION
     88  30f7
     89  30f7				   START
      0  30f7					      INIT		;INITIALIZE
      0  30f7					      db	22
      1  30f7		       16		      .byte.b	22
      0  30f8					      NLINE		;WRITE CRLF
      0  30f8					      db	5
      1  30f8		       05		      .byte.b	5
      0  30f9					      ERRGOTO	CO	;where to go after an error
      0  30f9					      db	31
      1  30f9		       1f		      .byte.b	31
      0  30fa					      dw	CO
      1  30fa		       fd 30		      .word.w	CO
      0  30fc					      VINIT		;clear all variables
      0  30fc					      db	30
      1  30fc		       1e		      .byte.b	30
     94  30fd							;
     95  30fd							; This is where we jump to get a line of commands or
     96  30fd							; a program from the user.
     97  30fd							;
     98  30fd				   CO
      0  30fd					      GETLINE		;WRITE PROMPT AND GET LINE
      0  30fd					      db	23
      1  30fd		       17		      .byte.b	23
      0  30fe					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  30fe					      db	34
      1  30fe		       22		      .byte.b	34
      0  30ff					      db	(XEC-*)-1
      1  30ff		       04		      .byte.b	(XEC-*)-1
      0  3100					      INSERT		;INSERT IT (MAY BE DELETE)
      0  3100					      db	24
      1  3100		       18		      .byte.b	24
      0  3101					      IJMP	CO
      0  3101					      db	29
      1  3101		       1d		      .byte.b	29
      0  3102					      dw	CO
      1  3102		       fd 30		      .word.w	CO
    103  3104				   XEC
      0  3104					      XINIT		;INITIALIZE
      0  3104					      db	0
      1  3104		       00		      .byte.b	0
    105  3105							;============================================================================
    106  3105							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
    107  3105							;
    108  3105				   STMT
      0  3105					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  3105					      db	57
      1  3105		       39		      .byte.b	57
      0  3106					      db	(notirq-*)-1
      1  3106		       01		      .byte.b	(notirq-*)-1
      0  3107					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  3107					      db	79
      1  3107		       4f		      .byte.b	79
    111  3108
    112  3108							;==========================================================================================
    113  3108							; Process a let statement implied or explicit.
    114  3108							;
    115  3108				   notirq
      0  3108					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  3108					      db	49
      1  3108		       31		      .byte.b	49
      0  3109					      db	(DoVector-*)-1
      1  3109		       2d		      .byte.b	(DoVector-*)-1
    117  310a				   ekLet
      0  310a					      TSTV	DoVector	; Test for variable
      0  310a					      db	33
      1  310a		       21		      .byte.b	33
      0  310b					      db	(DoVector-*)-1
      1  310b		       2b		      .byte.b	(DoVector-*)-1
      0  310c					      CALL	FactVarPtrNoTst	; get a pointer to the variable
      0  310c					      db	28
      1  310c		       1c		      .byte.b	28
      0  310d					      dw	FactVarPtrNoTst
      1  310d		       c6 34		      .word.w	FactVarPtrNoTst
    120  310f
    121  310f				   LETINDEX_ALL
      0  310f					      TSTB	ERRMissingEquals,oEqual	; (This line originally omitted)
      0  310f					      db	101
      1  310f		       65		      .byte.b	101
      0  3110					      db	(ERRMissingEquals-*)-1
      1  3110		       20		      .byte.b	(ERRMissingEquals-*)-1
      0  3111					      db	oEqual
      1  3111		       f2		      .byte.b	oEqual
    123  3112				   LETBE
      0  3112					      TSTBYTE	LETAssignByte,R2,tByte	; Check for a byte conversion
      0  3112					      db	97
      1  3112		       61		      .byte.b	97
      0  3113					      db	(LETAssignByte-*)-1
      1  3113		       10		      .byte.b	(LETAssignByte-*)-1
      0  3114					      dw	R2
      1  3114		       58 00		      .word.w	R2
      0  3116					      db	tByte
      1  3116		       a2		      .byte.b	tByte
      0  3117					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  3117					      db	28
      1  3117		       1c		      .byte.b	28
      0  3118					      dw	EXPR
      1  3118		       19 33		      .word.w	EXPR
      0  311a					      DONE		; REPORT ERROR IF NOT NEXT
      0  311a					      db	1
      1  311a		       01		      .byte.b	1
      0  311b					      SETR2	tInteger	; Store an integer type
      0  311b					      db	94
      1  311b		       5e		      .byte.b	94
      0  311c					      db	tInteger
      1  311c		       a4		      .byte.b	tInteger
      0  311d					      STORE		; STORE RESULT at variable address
      0  311d					      db	19
      1  311d		       13		      .byte.b	19
      0  311e					      NXT	CO	; AND SEQUENCE TO NEXT
      0  311e					      db	6
      1  311e		       06		      .byte.b	6
      0  311f					      dw	CO
      1  311f		       fd 30		      .word.w	CO
      0  3121					      IJMP	STMT	; Next statement
      0  3121					      db	29
      1  3121		       1d		      .byte.b	29
      0  3122					      dw	STMT
      1  3122		       05 31		      .word.w	STMT
    131  3124
    132  3124				   LETAssignByte
      0  3124					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  3124					      db	28
      1  3124		       1c		      .byte.b	28
      0  3125					      dw	EXPR
      1  3125		       19 33		      .word.w	EXPR
      0  3127					      DONE		; REPORT ERROR IF NOT NEXT
      0  3127					      db	1
      1  3127		       01		      .byte.b	1
      0  3128					      SETR2	tByte	; Set to store a byte value
      0  3128					      db	94
      1  3128		       5e		      .byte.b	94
      0  3129					      db	tByte
      1  3129		       a2		      .byte.b	tByte
      0  312a					      STORE		; STORE RESULT at variable address
      0  312a					      db	19
      1  312a		       13		      .byte.b	19
      0  312b					      NXT	CO	; AND SEQUENCE TO NEXT
      0  312b					      db	6
      1  312b		       06		      .byte.b	6
      0  312c					      dw	CO
      1  312c		       fd 30		      .word.w	CO
      0  312e					      IJMP	STMT	; Next statement
      0  312e					      db	29
      1  312e		       1d		      .byte.b	29
      0  312f					      dw	STMT
      1  312f		       05 31		      .word.w	STMT
    139  3131
    140  3131				   ERRMissingEquals
      0  3131					      ERRMSG	ERR_MISSINGEQUALSIGN	; Missing asignment
      0  3131					      db	13
      1  3131		       0d		      .byte.b	13
      0  3132					      dw	ERR_MISSINGEQUALSIGN
      1  3132		       18 00		      .word.w	ERR_MISSINGEQUALSIGN
    142  3134
    143  3134				   ERRVEC2
      0  3134					      IJMP	UNKNOWN
      0  3134					      db	29
      1  3134		       1d		      .byte.b	29
      0  3135					      dw	UNKNOWN
      1  3135		       15 33		      .word.w	UNKNOWN
    145  3137							;=============================================================
    146  3137							;Branch on a valid statement start
    147  3137				   DoVector
      0  3137					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  3137					      db	103
      1  3137		       67		      .byte.b	103
      0  3138					      dw	BasicStmts
      1  3138		       7d 30		      .word.w	BasicStmts
      0  313a					      dw	UNKNOWN
      1  313a		       15 33		      .word.w	UNKNOWN
    149  313c							;This will never return here!
    150  313c							;=============================================================
    151  313c							; Inc or dec a variable
    152  313c				   ekInc
      0  313c					      TSTV	ERRVEC2	; Verify we have a variable
      0  313c					      db	33
      1  313c		       21		      .byte.b	33
      0  313d					      db	(ERRVEC2-*)-1
      1  313d		       f6		      .byte.b	(ERRVEC2-*)-1
      0  313e					      CALL	FactVarPtrNoTst	; Get a pointer to the memory location to increment
      0  313e					      db	28
      1  313e		       1c		      .byte.b	28
      0  313f					      dw	FactVarPtrNoTst
      1  313f		       c6 34		      .word.w	FactVarPtrNoTst
    155  3141							;	  TSTB	     eDoInc,oBang		    ; Allow to inc or dec other tasks variables
    156  3141							;	  IND					    ; we just got a pid
    157  3141							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    158  3141				   eDoInc
      0  3141					      INCVAR		; Do the increment of the variable
      0  3141					      db	98
      1  3141		       62		      .byte.b	98
      0  3142					      DONE		; Test for end of line or end of statement ":"
      0  3142					      db	1
      1  3142		       01		      .byte.b	1
      0  3143					      NXT	CO	; Get the next statement, branch CO if end of program
      0  3143					      db	6
      1  3143		       06		      .byte.b	6
      0  3144					      dw	CO
      1  3144		       fd 30		      .word.w	CO
      0  3146					      IJMP	STMT	; Process the next statement
      0  3146					      db	29
      1  3146		       1d		      .byte.b	29
      0  3147					      dw	STMT
      1  3147		       05 31		      .word.w	STMT
    163  3149							;S1Dec:
    164  3149							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    165  3149				   ekDec
      0  3149					      TSTV	ERRVEC2	; Must be followed by a variable
      0  3149					      db	33
      1  3149		       21		      .byte.b	33
      0  314a					      db	(ERRVEC2-*)-1
      1  314a		       e9		      .byte.b	(ERRVEC2-*)-1
      0  314b					      CALL	FactVarPtrNoTst	; Get a pointer to the variable to update
      0  314b					      db	28
      1  314b		       1c		      .byte.b	28
      0  314c					      dw	FactVarPtrNoTst
      1  314c		       c6 34		      .word.w	FactVarPtrNoTst
    168  314e							;	  TSTB	     eDoDec,oBang		    ; Allow to inc or dec other tasks variables
    169  314e							;	  IND					    ; we just got a pid
    170  314e							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    171  314e				   eDoDec
      0  314e					      DECVAR		; Decrement the actual variable
      0  314e					      db	99
      1  314e		       63		      .byte.b	99
      0  314f					      DONE		; Test if end of line or : statement
      0  314f					      db	1
      1  314f		       01		      .byte.b	1
      0  3150					      NXT	CO	; If at end of program then got the console
      0  3150					      db	6
      1  3150		       06		      .byte.b	6
      0  3151					      dw	CO
      1  3151		       fd 30		      .word.w	CO
      0  3153					      IJMP	STMT	; Process the next statement of command line
      0  3153					      db	29
      1  3153		       1d		      .byte.b	29
      0  3154					      dw	STMT
      1  3154		       05 31		      .word.w	STMT
    176  3156							;=============================================================================================================================
    177  3156							; iret or ireturn, Return from interupt process
    178  3156							;
    179  3156							;S1Iret:
    180  3156							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    181  3156							;S1Sa:
    182  3156				   ekIreturn
      0  3156					      DONE		; Must be only thing on the line
      0  3156					      db	1
      1  3156		       01		      .byte.b	1
      0  3157					      IRET		; RESTORE LINE NUMBER OF CALL
      0  3157					      db	58
      1  3157		       3a		      .byte.b	58
      0  3158					      IJMP	STMT
      0  3158					      db	29
      1  3158		       1d		      .byte.b	29
      0  3159					      dw	STMT
      1  3159		       05 31		      .word.w	STMT
    186  315b							;==============================================================================================================================
    187  315b							;Process if statement, if true then process all statements until end of line reached
    188  315b							;S1S1:
    189  315b							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    190  315b				   ekIf
      0  315b					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  315b					      db	28
      1  315b		       1c		      .byte.b	28
      0  315c					      dw	EXPR
      1  315c		       19 33		      .word.w	EXPR
      0  315e					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  315e					      db	101
      1  315e		       65		      .byte.b	101
      0  315f					      db	(S1W-*)-1
      1  315f		       01		      .byte.b	(S1W-*)-1
      0  3160					      db	kThen
      1  3160		       06		      .byte.b	kThen
    193  3161				   ekThen
    194  3161				   S1W
      0  3161					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  3161					      db	54
      1  3161		       36		      .byte.b	54
      0  3162					      IJMP	STMT
      0  3162					      db	29
      1  3162		       1d		      .byte.b	29
      0  3163					      dw	STMT
      1  3163		       05 31		      .word.w	STMT
    197  3165							;===============================================================================================================================
    198  3165							; Test for GOTO
    199  3165							;S1Z:
    200  3165							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    201  3165							;
    202  3165				   ekGoto
      0  3165					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  3165					      db	106
      1  3165		       6a		      .byte.b	106
      0  3166					      db	(ekGotoCompiled-*)-1
      1  3166		       0e		      .byte.b	(ekGotoCompiled-*)-1
    204  3167							; Else we have the address ad just goto that address
      0  3167					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  3167					      db	101
      1  3167		       65		      .byte.b	101
      0  3168					      db	(ekGotoLine-*)-1
      1  3168		       05		      .byte.b	(ekGotoLine-*)-1
      0  3169					      db	oPeriod
      1  3169		       e9		      .byte.b	oPeriod
      0  316a					      REPEATLINE		; Repeat the same line again
      0  316a					      db	105
      1  316a		       69		      .byte.b	105
      0  316b					      IJMP	STMT	; Go do the statement
      0  316b					      db	29
      1  316b		       1d		      .byte.b	29
      0  316c					      dw	STMT
      1  316c		       05 31		      .word.w	STMT
    208  316e
    209  316e				   ekGotoLine
      0  316e					      CALL	EXPR	; GET LABEL
      0  316e					      db	28
      1  316e		       1c		      .byte.b	28
      0  316f					      dw	EXPR
      1  316f		       19 33		      .word.w	EXPR
      0  3171					      lit	0	; Place indicator for line num on stack
      0  3171					      db	27
      1  3171		       1b		      .byte.b	27
      0  3172					      dw	0
      1  3172		       00 00		      .word.w	0
      0  3174					      FASTXFER
      0  3174					      db	107
      1  3174		       6b		      .byte.b	107
    213  3175				   ekGotoCompiled
      0  3175					      lit	1	; tell it that mempointer on the stack
      0  3175					      db	27
      1  3175		       1b		      .byte.b	27
      0  3176					      dw	1
      1  3176		       01 00		      .word.w	1
      0  3178					      FASTXFER		; put top of stack into curptr
      0  3178					      db	107
      1  3178		       6b		      .byte.b	107
    216  3179
    217  3179
    218  3179							;==================================================================================================================================
    219  3179							; Process REM statement
    220  3179							;
    221  3179							;S2a:
    222  3179							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    223  3179				   ekRem
      0  3179					      NXT	CO	; The rest of the line is ignored
      0  3179					      db	6
      1  3179		       06		      .byte.b	6
      0  317a					      dw	CO
      1  317a		       fd 30		      .word.w	CO
      0  317c					      IJMP	STMT	; Process the next statement
      0  317c					      db	29
      1  317c		       1d		      .byte.b	29
      0  317d					      dw	STMT
      1  317d		       05 31		      .word.w	STMT
    226  317f							;====================================================================================================================================
    227  317f							; Set the Task input output slot each slot is 16 byte starting at e000
    228  317f							; so 0,1,...
    229  317f				   ekSetTerm
      0  317f					      CALL	EXPR
      0  317f					      db	28
      1  317f		       1c		      .byte.b	28
      0  3180					      dw	EXPR
      1  3180		       19 33		      .word.w	EXPR
      0  3182					      TSTB	ERRVEC,oComma
      0  3182					      db	101
      1  3182		       65		      .byte.b	101
      0  3183					      db	(ERRVEC-*)-1
      1  3183		       2f		      .byte.b	(ERRVEC-*)-1
      0  3184					      db	oComma
      1  3184		       e2		      .byte.b	oComma
      0  3185					      CALL	EXPR
      0  3185					      db	28
      1  3185		       1c		      .byte.b	28
      0  3186					      dw	EXPR
      1  3186		       19 33		      .word.w	EXPR
      0  3188					      SETTERMINAL
      0  3188					      db	108
      1  3188		       6c		      .byte.b	108
      0  3189					      NXT	CO	;Next statement to execute
      0  3189					      db	6
      1  3189		       06		      .byte.b	6
      0  318a					      dw	CO
      1  318a		       fd 30		      .word.w	CO
      0  318c					      IJMP	STMT
      0  318c					      db	29
      1  318c		       1d		      .byte.b	29
      0  318d					      dw	STMT
      1  318d		       05 31		      .word.w	STMT
    236  318f							;==================================================================================================================================
    237  318f							; Print statement
    238  318f							;
    239  318f							;S3:
    240  318f							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    241  318f				   ekPrint
      0  318f					      STARTIO		; Lock task until io completes
      0  318f					      db	70
      1  318f		       46		      .byte.b	70
    243  3190				   S4
      0  3190					      TSTDONE	S4a	; Test if we just want crlf printed
      0  3190					      db	50
      1  3190		       32		      .byte.b	50
      0  3191					      db	(S4a-*)-1
      1  3191		       03		      .byte.b	(S4a-*)-1
      0  3192					      IJMP	S6
      0  3192					      db	29
      1  3192		       1d		      .byte.b	29
      0  3193					      dw	S6
      1  3193		       aa 31		      .word.w	S6
    246  3195
    247  3195				   S4a
      0  3195					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  3195					      db	101
      1  3195		       65		      .byte.b	101
      0  3196					      db	(S7-*)-1
      1  3196		       1f		      .byte.b	(S7-*)-1
      0  3197					      db	tString
      1  3197		       a0		      .byte.b	tString
      0  3198					      PRS		; PRINT STRING
      0  3198					      db	2
      1  3198		       02		      .byte.b	2
    250  3199				   S5
      0  3199					      TSTB	S6A,oComma	; IS THERE MORE?
      0  3199					      db	101
      1  3199		       65		      .byte.b	101
      0  319a					      db	(S6A-*)-1
      1  319a		       07		      .byte.b	(S6A-*)-1
      0  319b					      db	oComma
      1  319b		       e2		      .byte.b	oComma
      0  319c					      SPC		; SPACE TO NEXT ZONE
      0  319c					      db	4
      1  319c		       04		      .byte.b	4
      0  319d					      TSTDONE	S4	; Not end of line jump back
      0  319d					      db	50
      1  319d		       32		      .byte.b	50
      0  319e					      db	(S4-*)-1
      1  319e		       f1		      .byte.b	(S4-*)-1
      0  319f					      IJMP	S6Z	; YES JUMP BACK
      0  319f					      db	29
      1  319f		       1d		      .byte.b	29
      0  31a0					      dw	S6Z
      1  31a0		       ac 31		      .word.w	S6Z
    255  31a2
    256  31a2							;
    257  31a2							; If a semicolon, don't do anything.
    258  31a2							;
    259  31a2				   S6A
      0  31a2					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  31a2					      db	101
      1  31a2		       65		      .byte.b	101
      0  31a3					      db	(S6-*)-1
      1  31a3		       06		      .byte.b	(S6-*)-1
      0  31a4					      db	oSemiColon
      1  31a4		       e3		      .byte.b	oSemiColon
      0  31a5					      TSTDONE	S4	; Jump Back if not end of line
      0  31a5					      db	50
      1  31a5		       32		      .byte.b	50
      0  31a6					      db	(S4-*)-1
      1  31a6		       e9		      .byte.b	(S4-*)-1
      0  31a7					      IJMP	S6Z
      0  31a7					      db	29
      1  31a7		       1d		      .byte.b	29
      0  31a8					      dw	S6Z
      1  31a8		       ac 31		      .word.w	S6Z
    263  31aa
    264  31aa				   S6
    265  31aa
      0  31aa					      DONE		; ERROR IF CR NOT NEXT
      0  31aa					      db	1
      1  31aa		       01		      .byte.b	1
      0  31ab					      NLINE
      0  31ab					      db	5
      1  31ab		       05		      .byte.b	5
    268  31ac				   S6Z
      0  31ac					      ENDIO		; release task io completed
      0  31ac					      db	71
      1  31ac		       47		      .byte.b	71
      0  31ad					      NXT	CO	; exit here if , or ; at end of print
      0  31ad					      db	6
      1  31ad		       06		      .byte.b	6
      0  31ae					      dw	CO
      1  31ae		       fd 30		      .word.w	CO
      0  31b0					      IJMP	STMT
      0  31b0					      db	29
      1  31b0		       1d		      .byte.b	29
      0  31b1					      dw	STMT
      1  31b1		       05 31		      .word.w	STMT
    272  31b3							;
    273  31b3							; A jump for code too far away for relative branch
    274  31b3							;
    275  31b3				   ERRVEC
      0  31b3					      IJMP	UNKNOWN
      0  31b3					      db	29
      1  31b3		       1d		      .byte.b	29
      0  31b4					      dw	UNKNOWN
      1  31b4		       15 33		      .word.w	UNKNOWN
    277  31b6							;
    278  31b6							; Get here if there is an expression to print
    279  31b6				   S7
      0  31b6					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  31b6					      db	101
      1  31b6		       65		      .byte.b	101
      0  31b7					      db	(S7AUnsigned-*)-1
      1  31b7		       08		      .byte.b	(S7AUnsigned-*)-1
      0  31b8					      db	oDollar
      1  31b8		       e7		      .byte.b	oDollar
      0  31b9					      CALL	EXPR
      0  31b9					      db	28
      1  31b9		       1c		      .byte.b	28
      0  31ba					      dw	EXPR
      1  31ba		       19 33		      .word.w	EXPR
      0  31bc					      HEXPRT
      0  31bc					      db	67
      1  31bc		       43		      .byte.b	67
      0  31bd					      IJMP	S5
      0  31bd					      db	29
      1  31bd		       1d		      .byte.b	29
      0  31be					      dw	S5
      1  31be		       99 31		      .word.w	S5
    284  31c0
    285  31c0				   S7AUnsigned
    286  31c0
      0  31c0					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  31c0					      db	101
      1  31c0		       65		      .byte.b	101
      0  31c1					      db	(S7A-*)-1
      1  31c1		       0a		      .byte.b	(S7A-*)-1
      0  31c2					      db	oPercent
      1  31c2		       ed		      .byte.b	oPercent
      0  31c3					      CALL	EXPR
      0  31c3					      db	28
      1  31c3		       1c		      .byte.b	28
      0  31c4					      dw	EXPR
      1  31c4		       19 33		      .word.w	EXPR
      0  31c6					      SETR2	tUint
      0  31c6					      db	94
      1  31c6		       5e		      .byte.b	94
      0  31c7					      db	tUint
      1  31c7		       a9		      .byte.b	tUint
      0  31c8					      PRN
      0  31c8					      db	3
      1  31c8		       03		      .byte.b	3
      0  31c9					      IJMP	S5
      0  31c9					      db	29
      1  31c9		       1d		      .byte.b	29
      0  31ca					      dw	S5
      1  31ca		       99 31		      .word.w	S5
    292  31cc
    293  31cc				   S7A
    294  31cc
      0  31cc					      CALL	EXPR
      0  31cc					      db	28
      1  31cc		       1c		      .byte.b	28
      0  31cd					      dw	EXPR
      1  31cd		       19 33		      .word.w	EXPR
      0  31cf					      TSTB	S7B,oDollar	; Print the value as a single character
      0  31cf					      db	101
      1  31cf		       65		      .byte.b	101
      0  31d0					      db	(S7B-*)-1
      1  31d0		       05		      .byte.b	(S7B-*)-1
      0  31d1					      db	oDollar
      1  31d1		       e7		      .byte.b	oDollar
      0  31d2					      PUTCHAR
      0  31d2					      db	52
      1  31d2		       34		      .byte.b	52
      0  31d3					      IJMP	S5
      0  31d3					      db	29
      1  31d3		       1d		      .byte.b	29
      0  31d4					      dw	S5
      1  31d4		       99 31		      .word.w	S5
    299  31d6
    300  31d6				   S7B
      0  31d6					      SETR2	tInteger	; Print the value as a signed number
      0  31d6					      db	94
      1  31d6		       5e		      .byte.b	94
      0  31d7					      db	tInteger
      1  31d7		       a4		      .byte.b	tInteger
      0  31d8					      PRN		; PRINT IT
      0  31d8					      db	3
      1  31d8		       03		      .byte.b	3
      0  31d9					      IJMP	S5	; IS THERE MORE?
      0  31d9					      db	29
      1  31d9		       1d		      .byte.b	29
      0  31da					      dw	S5
      1  31da		       99 31		      .word.w	S5
    304  31dc							;
    305  31dc							;===========================================================
    306  31dc							; PROCESS ALL THE TASK STATEMENTS
    307  31dc							;
    308  31dc							;S8:
    309  31dc							;	  TSTB	      S8G,kTaske		 ; End Task
    310  31dc				   ekTaske
      0  31dc					      TSTB	S8NoParm,oLeftBracket
      0  31dc					      db	101
      1  31dc		       65		      .byte.b	101
      0  31dd					      db	(S8NoParm-*)-1
      1  31dd		       0c		      .byte.b	(S8NoParm-*)-1
      0  31de					      db	oLeftBracket
      1  31de		       e0		      .byte.b	oLeftBracket
      0  31df					      CALL	EXPR
      0  31df					      db	28
      1  31df		       1c		      .byte.b	28
      0  31e0					      dw	EXPR
      1  31e0		       19 33		      .word.w	EXPR
      0  31e2					      TSTB	UNKNOWNLnk,oRightBracket
      0  31e2					      db	101
      1  31e2		       65		      .byte.b	101
      0  31e3					      db	(UNKNOWNLnk-*)-1
      1  31e3		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  31e4					      db	oRightBracket
      1  31e4		       e1		      .byte.b	oRightBracket
      0  31e5					      ETASK
      0  31e5					      db	62
      1  31e5		       3e		      .byte.b	62
      0  31e6					      DONE
      0  31e6					      db	1
      1  31e6		       01		      .byte.b	1
      0  31e7					      IJMP	STMT
      0  31e7					      db	29
      1  31e7		       1d		      .byte.b	29
      0  31e8					      dw	STMT
      1  31e8		       05 31		      .word.w	STMT
    317  31ea				   S8NoParm
      0  31ea					      LIT	0
      0  31ea					      db	27
      1  31ea		       1b		      .byte.b	27
      0  31eb					      dw	0
      1  31eb		       00 00		      .word.w	0
      0  31ed					      ETASK
      0  31ed					      db	62
      1  31ed		       3e		      .byte.b	62
      0  31ee					      DONE		; Must be last thing on a line
      0  31ee					      db	1
      1  31ee		       01		      .byte.b	1
      0  31ef					      IJMP	STMT
      0  31ef					      db	29
      1  31ef		       1d		      .byte.b	29
      0  31f0					      dw	STMT
      1  31f0		       05 31		      .word.w	STMT
    322  31f2							;
    323  31f2							;===========================================================
    324  31f2							; The task gives up the rest of the cycles
    325  31f2							;S8G:
    326  31f2							;	  TSTB	      S8a,kTaskn	 ;Next task
    327  31f2				   ekTaskn
      0  31f2					      NTASK
      0  31f2					      db	63
      1  31f2		       3f		      .byte.b	63
      0  31f3					      NXT	CO	;Next statement to execute
      0  31f3					      db	6
      1  31f3		       06		      .byte.b	6
      0  31f4					      dw	CO
      1  31f4		       fd 30		      .word.w	CO
      0  31f6					      IJMP	STMT
      0  31f6					      db	29
      1  31f6		       1d		      .byte.b	29
      0  31f7					      dw	STMT
      1  31f7		       05 31		      .word.w	STMT
    331  31f9							;
    332  31f9							;===========================================================
    333  31f9							; Waits for a task or list of tasks to complete
    334  31f9
    335  31f9				   ekTaskw
      0  31f9					      TSTB	UNKNOWNLnk,oLeftBracket
      0  31f9					      db	101
      1  31f9		       65		      .byte.b	101
      0  31fa					      db	(UNKNOWNLnk-*)-1
      1  31fa		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  31fb					      db	oLeftBracket
      1  31fb		       e0		      .byte.b	oLeftBracket
    337  31fc				   S8TSK
      0  31fc					      Call	EXPR	;Gets the PID of task to wait for
      0  31fc					      db	28
      1  31fc		       1c		      .byte.b	28
      0  31fd					      dw	EXPR
      1  31fd		       19 33		      .word.w	EXPR
    339  31ff				   S8LOOP
      0  31ff					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  31ff					      db	76
      1  31ff		       4c		      .byte.b	76
      0  3200					      db	(S8LOOP-*)-1
      1  3200		       fe		      .byte.b	(S8LOOP-*)-1
      0  3201					      TSTB	S8aa,oComma	;Checks for more tasks
      0  3201					      db	101
      1  3201		       65		      .byte.b	101
      0  3202					      db	(S8aa-*)-1
      1  3202		       04		      .byte.b	(S8aa-*)-1
      0  3203					      db	oComma
      1  3203		       e2		      .byte.b	oComma
      0  3204					      IJMP	S8TSK	;Go for the next task number
      0  3204					      db	29
      1  3204		       1d		      .byte.b	29
      0  3205					      dw	S8TSK
      1  3205		       fc 31		      .word.w	S8TSK
    343  3207				   S8aa
      0  3207					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  3207					      db	101
      1  3207		       65		      .byte.b	101
      0  3208					      db	(UNKNOWNLnk-*)-1
      1  3208		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  3209					      db	oRightBracket
      1  3209		       e1		      .byte.b	oRightBracket
      0  320a					      DONE
      0  320a					      db	1
      1  320a		       01		      .byte.b	1
      0  320b					      NXT	CO
      0  320b					      db	6
      1  320b		       06		      .byte.b	6
      0  320c					      dw	CO
      1  320c		       fd 30		      .word.w	CO
      0  320e					      IJMP	STMT	;Next Statement
      0  320e					      db	29
      1  320e		       1d		      .byte.b	29
      0  320f					      dw	STMT
      1  320f		       05 31		      .word.w	STMT
    348  3211
    349  3211
    350  3211
    351  3211				   UNKNOWNLnk
      0  3211					      iJMP	UNKNOWN
      0  3211					      db	29
      1  3211		       1d		      .byte.b	29
      0  3212					      dw	UNKNOWN
      1  3212		       15 33		      .word.w	UNKNOWN
    353  3214
    354  3214							;
    355  3214							;===========================================================
    356  3214							; Update a memory location with a value
    357  3214							;  Use @[offset] to write a word value to memory
    358  3214							;
    359  3214							;S8a1:
    360  3214							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    361  3214				   ekPoke
      0  3214					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3214					      db	101
      1  3214		       65		      .byte.b	101
      0  3215					      db	(UNKNOWNV-*)-1
      1  3215		       9c		      .byte.b	(UNKNOWNV-*)-1
      0  3216					      db	oLeftBracket
      1  3216		       e0		      .byte.b	oLeftBracket
      0  3217					      CALL	EXPR	; Get address to write to
      0  3217					      db	28
      1  3217		       1c		      .byte.b	28
      0  3218					      dw	EXPR
      1  3218		       19 33		      .word.w	EXPR
      0  321a					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  321a					      db	101
      1  321a		       65		      .byte.b	101
      0  321b					      db	(UNKNOWNV-*)-1
      1  321b		       96		      .byte.b	(UNKNOWNV-*)-1
      0  321c					      db	oComma
      1  321c		       e2		      .byte.b	oComma
      0  321d					      CALL	EXPR	; Get the value to poke
      0  321d					      db	28
      1  321d		       1c		      .byte.b	28
      0  321e					      dw	EXPR
      1  321e		       19 33		      .word.w	EXPR
      0  3220					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3220					      db	101
      1  3220		       65		      .byte.b	101
      0  3221					      db	(UNKNOWNV-*)-1
      1  3221		       90		      .byte.b	(UNKNOWNV-*)-1
      0  3222					      db	oRightBracket
      1  3222		       e1		      .byte.b	oRightBracket
      0  3223					      POKEMEM
      0  3223					      db	47
      1  3223		       2f		      .byte.b	47
      0  3224					      DONE
      0  3224					      db	1
      1  3224		       01		      .byte.b	1
      0  3225					      NXT	CO	;AND SEQUENCE TO NEXT
      0  3225					      db	6
      1  3225		       06		      .byte.b	6
      0  3226					      dw	CO
      1  3226		       fd 30		      .word.w	CO
      0  3228					      IJMP	STMT
      0  3228					      db	29
      1  3228		       1d		      .byte.b	29
      0  3229					      dw	STMT
      1  3229		       05 31		      .word.w	STMT
    371  322b							;
    372  322b							;================================================================
    373  322b							; Set a block of memory to a value word or byte
    374  322b							; SetMem(Value, Length, Destination)
    375  322b				   ekSetMemB
      0  322b					      CALL	ekSetMem
      0  322b					      db	28
      1  322b		       1c		      .byte.b	28
      0  322c					      dw	ekSetMem
      1  322c		       43 32		      .word.w	ekSetMem
      0  322e					      SETBLOCK	tByte	; set value as byte
      0  322e					      db	110
      1  322e		       6e		      .byte.b	110
      0  322f					      db	tByte
      1  322f		       a2		      .byte.b	tByte
      0  3230					      DONE
      0  3230					      db	1
      1  3230		       01		      .byte.b	1
      0  3231					      NXT	CO
      0  3231					      db	6
      1  3231		       06		      .byte.b	6
      0  3232					      dw	CO
      1  3232		       fd 30		      .word.w	CO
      0  3234					      IJMP	STMT
      0  3234					      db	29
      1  3234		       1d		      .byte.b	29
      0  3235					      dw	STMT
      1  3235		       05 31		      .word.w	STMT
    381  3237
    382  3237				   ekSetMemW
      0  3237					      CALL	ekSetMem
      0  3237					      db	28
      1  3237		       1c		      .byte.b	28
      0  3238					      dw	ekSetMem
      1  3238		       43 32		      .word.w	ekSetMem
      0  323a					      SETBLOCK	tInteger	; set value as byte
      0  323a					      db	110
      1  323a		       6e		      .byte.b	110
      0  323b					      db	tInteger
      1  323b		       a4		      .byte.b	tInteger
      0  323c					      DONE
      0  323c					      db	1
      1  323c		       01		      .byte.b	1
      0  323d					      NXT	CO
      0  323d					      db	6
      1  323d		       06		      .byte.b	6
      0  323e					      dw	CO
      1  323e		       fd 30		      .word.w	CO
      0  3240					      IJMP	STMT
      0  3240					      db	29
      1  3240		       1d		      .byte.b	29
      0  3241					      dw	STMT
      1  3241		       05 31		      .word.w	STMT
    388  3243
    389  3243				   ekSetMem
      0  3243					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3243					      db	101
      1  3243		       65		      .byte.b	101
      0  3244					      db	(UNKNOWNV-*)-1
      1  3244		       6d		      .byte.b	(UNKNOWNV-*)-1
      0  3245					      db	oLeftBracket
      1  3245		       e0		      .byte.b	oLeftBracket
      0  3246					      CALL	EXPR	; Value to set
      0  3246					      db	28
      1  3246		       1c		      .byte.b	28
      0  3247					      dw	EXPR
      1  3247		       19 33		      .word.w	EXPR
      0  3249					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3249					      db	101
      1  3249		       65		      .byte.b	101
      0  324a					      db	(UNKNOWNV-*)-1
      1  324a		       67		      .byte.b	(UNKNOWNV-*)-1
      0  324b					      db	oComma
      1  324b		       e2		      .byte.b	oComma
      0  324c					      CALL	EXPR	; Get The Length
      0  324c					      db	28
      1  324c		       1c		      .byte.b	28
      0  324d					      dw	EXPR
      1  324d		       19 33		      .word.w	EXPR
      0  324f					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  324f					      db	101
      1  324f		       65		      .byte.b	101
      0  3250					      db	(UNKNOWNV-*)-1
      1  3250		       61		      .byte.b	(UNKNOWNV-*)-1
      0  3251					      db	oComma
      1  3251		       e2		      .byte.b	oComma
      0  3252					      CALL	EXPR	; GET the address to start at
      0  3252					      db	28
      1  3252		       1c		      .byte.b	28
      0  3253					      dw	EXPR
      1  3253		       19 33		      .word.w	EXPR
      0  3255					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3255					      db	101
      1  3255		       65		      .byte.b	101
      0  3256					      db	(UNKNOWNV-*)-1
      1  3256		       5b		      .byte.b	(UNKNOWNV-*)-1
      0  3257					      db	oRightBracket
      1  3257		       e1		      .byte.b	oRightBracket
      0  3258					      RTN
      0  3258					      db	25
      1  3258		       19		      .byte.b	25
    398  3259							;
    399  3259							;================================================================
    400  3259							; Copy a block of memory
    401  3259							; CopyMem(Length, Destination, Source)
    402  3259				   ekCopyMem
      0  3259					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3259					      db	101
      1  3259		       65		      .byte.b	101
      0  325a					      db	(UNKNOWNV-*)-1
      1  325a		       57		      .byte.b	(UNKNOWNV-*)-1
      0  325b					      db	oLeftBracket
      1  325b		       e0		      .byte.b	oLeftBracket
      0  325c					      CALL	EXPR	; Length
      0  325c					      db	28
      1  325c		       1c		      .byte.b	28
      0  325d					      dw	EXPR
      1  325d		       19 33		      .word.w	EXPR
      0  325f					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  325f					      db	101
      1  325f		       65		      .byte.b	101
      0  3260					      db	(UNKNOWNV-*)-1
      1  3260		       51		      .byte.b	(UNKNOWNV-*)-1
      0  3261					      db	oComma
      1  3261		       e2		      .byte.b	oComma
      0  3262					      CALL	EXPR	; Destination
      0  3262					      db	28
      1  3262		       1c		      .byte.b	28
      0  3263					      dw	EXPR
      1  3263		       19 33		      .word.w	EXPR
      0  3265					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3265					      db	101
      1  3265		       65		      .byte.b	101
      0  3266					      db	(UNKNOWNV-*)-1
      1  3266		       4b		      .byte.b	(UNKNOWNV-*)-1
      0  3267					      db	oComma
      1  3267		       e2		      .byte.b	oComma
      0  3268					      CALL	EXPR	; Source
      0  3268					      db	28
      1  3268		       1c		      .byte.b	28
      0  3269					      dw	EXPR
      1  3269		       19 33		      .word.w	EXPR
      0  326b					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  326b					      db	101
      1  326b		       65		      .byte.b	101
      0  326c					      db	(UNKNOWNV-*)-1
      1  326c		       45		      .byte.b	(UNKNOWNV-*)-1
      0  326d					      db	oRightBracket
      1  326d		       e1		      .byte.b	oRightBracket
      0  326e					      COPYBLOCK		; Copy the memory
      0  326e					      db	111
      1  326e		       6f		      .byte.b	111
      0  326f					      DONE
      0  326f					      db	1
      1  326f		       01		      .byte.b	1
      0  3270					      NXT	CO
      0  3270					      db	6
      1  3270		       06		      .byte.b	6
      0  3271					      dw	CO
      1  3271		       fd 30		      .word.w	CO
      0  3273					      IJMP	STMT
      0  3273					      db	29
      1  3273		       1d		      .byte.b	29
      0  3274					      dw	STMT
      1  3274		       05 31		      .word.w	STMT
    414  3276
    415  3276							;================================================================
    416  3276							; Write a single byte to the output device
    417  3276							;
    418  3276				   ekPutch
      0  3276					      CALL	EXPR
      0  3276					      db	28
      1  3276		       1c		      .byte.b	28
      0  3277					      dw	EXPR
      1  3277		       19 33		      .word.w	EXPR
      0  3279					      PUTCHAR
      0  3279					      db	52
      1  3279		       34		      .byte.b	52
      0  327a					      DONE
      0  327a					      db	1
      1  327a		       01		      .byte.b	1
      0  327b					      NXT	CO	;AND SEQUENCE TO NEXT
      0  327b					      db	6
      1  327b		       06		      .byte.b	6
      0  327c					      dw	CO
      1  327c		       fd 30		      .word.w	CO
      0  327e					      IJMP	STMT
      0  327e					      db	29
      1  327e		       1d		      .byte.b	29
      0  327f					      dw	STMT
      1  327f		       05 31		      .word.w	STMT
    424  3281							;================================================================
    425  3281							; Clear the screen lines
    426  3281							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    427  3281							;
    428  3281				   ekCls
      0  3281					      CLEARSCREEN
      0  3281					      db	46
      1  3281		       2e		      .byte.b	46
      0  3282					      NXT	CO	;AND SEQUENCE TO NEXT
      0  3282					      db	6
      1  3282		       06		      .byte.b	6
      0  3283					      dw	CO
      1  3283		       fd 30		      .word.w	CO
      0  3285					      IJMP	STMT
      0  3285					      db	29
      1  3285		       1d		      .byte.b	29
      0  3286					      dw	STMT
      1  3286		       05 31		      .word.w	STMT
    432  3288							;==================================================================
    433  3288							; Get input from the terminal
    434  3288							;   Reads from the currently active input device
    435  3288							;
    436  3288				   ekInput
    437  3288				   S10
      0  3288					      TSTB	S10A,tString	;If there is a string print the prompt
      0  3288					      db	101
      1  3288		       65		      .byte.b	101
      0  3289					      db	(S10A-*)-1
      1  3289		       05		      .byte.b	(S10A-*)-1
      0  328a					      db	tString
      1  328a		       a0		      .byte.b	tString
      0  328b					      PRS
      0  328b					      db	2
      1  328b		       02		      .byte.b	2
      0  328c					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  328c					      db	101
      1  328c		       65		      .byte.b	101
      0  328d					      db	(S10Z-*)-1
      1  328d		       19		      .byte.b	(S10Z-*)-1
      0  328e					      db	oSemiColon
      1  328e		       e3		      .byte.b	oSemiColon
    441  328f				   S10A
      0  328f					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  328f					      db	33
      1  328f		       21		      .byte.b	33
      0  3290					      db	(UNKNOWN-*)-1
      1  3290		       84		      .byte.b	(UNKNOWN-*)-1
      0  3291					      CALL	FactVarPtrNoTst
      0  3291					      db	28
      1  3291		       1c		      .byte.b	28
      0  3292					      dw	FactVarPtrNoTst
      1  3292		       c6 34		      .word.w	FactVarPtrNoTst
    444  3294							;	  TSTB	     S10ACONT,oBang	      ; Print from another task
    445  3294							;	  IND
    446  3294							;	  TSTVT      UNKNOWN
    447  3294
    448  3294				   S10ACONT
      0  3294					      TSTB	S10A1,oDollar
      0  3294					      db	101
      1  3294		       65		      .byte.b	101
      0  3295					      db	(S10A1-*)-1
      1  3295		       07		      .byte.b	(S10A1-*)-1
      0  3296					      db	oDollar
      1  3296		       e7		      .byte.b	oDollar
      0  3297					      INSTR		;Move character From tty to AESTK
      0  3297					      db	59
      1  3297		       3b		      .byte.b	59
      0  3298					      SETR2	tByte
      0  3298					      db	94
      1  3298		       5e		      .byte.b	94
      0  3299					      db	tByte
      1  3299		       a2		      .byte.b	tByte
      0  329a					      IJMP	S10A2
      0  329a					      db	29
      1  329a		       1d		      .byte.b	29
      0  329b					      dw	S10A2
      1  329b		       a0 32		      .word.w	S10A2
    453  329d				   S10A1
      0  329d					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  329d					      db	11
      1  329d		       0b		      .byte.b	11
      0  329e					      SETR2	tInteger
      0  329e					      db	94
      1  329e		       5e		      .byte.b	94
      0  329f					      db	tInteger
      1  329f		       a4		      .byte.b	tInteger
    456  32a0				   S10A2
      0  32a0					      STORE		;STORE IT
      0  32a0					      db	19
      1  32a0		       13		      .byte.b	19
      0  32a1					      TSTB	S11,oComma	;IS THERE MORE?
      0  32a1					      db	101
      1  32a1		       65		      .byte.b	101
      0  32a2					      db	(S11-*)-1
      1  32a2		       07		      .byte.b	(S11-*)-1
      0  32a3					      db	oComma
      1  32a3		       e2		      .byte.b	oComma
      0  32a4					      IJMP	S10	;YES
      0  32a4					      db	29
      1  32a4		       1d		      .byte.b	29
      0  32a5					      dw	S10
      1  32a5		       88 32		      .word.w	S10
    460  32a7				   S10Z
      0  32a7					      iJMP	UNKNOWN
      0  32a7					      db	29
      1  32a7		       1d		      .byte.b	29
      0  32a8					      dw	UNKNOWN
      1  32a8		       15 33		      .word.w	UNKNOWN
    462  32aa				   S11
      0  32aa					      DONE		;MUST BE CR
      0  32aa					      db	1
      1  32aa		       01		      .byte.b	1
      0  32ab					      NXT	CO	;SEQUENCE TO NEXT
      0  32ab					      db	6
      1  32ab		       06		      .byte.b	6
      0  32ac					      dw	CO
      1  32ac		       fd 30		      .word.w	CO
      0  32ae					      IJMP	STMT
      0  32ae					      db	29
      1  32ae		       1d		      .byte.b	29
      0  32af					      dw	STMT
      1  32af		       05 31		      .word.w	STMT
    466  32b1							;=====================================================================
    467  32b1							; End of program, return to command line process
    468  32b1							; Main Task may also use taske or return to stopped
    469  32b1							;
    470  32b1				   ekEnd
      0  32b1					      FIN
      0  32b1					      db	12
      1  32b1		       0c		      .byte.b	12
    472  32b2				   UNKNOWNV
      0  32b2					      IJMP	UNKNOWN
      0  32b2					      db	29
      1  32b2		       1d		      .byte.b	29
      0  32b3					      dw	UNKNOWN
      1  32b3		       15 33		      .word.w	UNKNOWN
    474  32b5							;====================================================================
    475  32b5							; IRQ <IRQ-HANDLER-Line expression>
    476  32b5							;   Specify a line number subroutine to call when an interupt is processed
    477  32b5							;   These subroutines must use iret to return.
    478  32b5							;
    479  32b5				   ekIrq
      0  32b5					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  32b5					      db	28
      1  32b5		       1c		      .byte.b	28
      0  32b6					      dw	EXPR
      1  32b6		       19 33		      .word.w	EXPR
      0  32b8					      DONE		;must be CR
      0  32b8					      db	1
      1  32b8		       01		      .byte.b	1
      0  32b9					      SETIRQ		;Set the line number now
      0  32b9					      db	56
      1  32b9		       38		      .byte.b	56
      0  32ba					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  32ba					      db	6
      1  32ba		       06		      .byte.b	6
      0  32bb					      dw	CO
      1  32bb		       fd 30		      .word.w	CO
      0  32bd					      IJMP	STMT
      0  32bd					      db	29
      1  32bd		       1d		      .byte.b	29
      0  32be					      dw	STMT
      1  32be		       05 31		      .word.w	STMT
    485  32c0
    486  32c0							;=========================================================================
    487  32c0							; KILL PID-expression	 kill a running task
    488  32c0							;  ignored of task has already stopped
    489  32c0							;
    490  32c0				   ekKill
      0  32c0					      CALL	EXPR
      0  32c0					      db	28
      1  32c0		       1c		      .byte.b	28
      0  32c1					      dw	EXPR
      1  32c1		       19 33		      .word.w	EXPR
      0  32c3					      DONE
      0  32c3					      db	1
      1  32c3		       01		      .byte.b	1
      0  32c4					      TASKKILL
      0  32c4					      db	65
      1  32c4		       41		      .byte.b	65
      0  32c5					      NXT	CO
      0  32c5					      db	6
      1  32c5		       06		      .byte.b	6
      0  32c6					      dw	CO
      1  32c6		       fd 30		      .word.w	CO
      0  32c8					      IJMP	STMT
      0  32c8					      db	29
      1  32c8		       1d		      .byte.b	29
      0  32c9					      dw	STMT
      1  32c9		       05 31		      .word.w	STMT
    496  32cb
    497  32cb							;============================================================================
    498  32cb							; List all program lines
    499  32cb							;
    500  32cb				   ekList
      0  32cb					      DONE
      0  32cb					      db	1
      1  32cb		       01		      .byte.b	1
      0  32cc					      LST
      0  32cc					      db	21
      1  32cc		       15		      .byte.b	21
      0  32cd					      IJMP	CO
      0  32cd					      db	29
      1  32cd		       1d		      .byte.b	29
      0  32ce					      dw	CO
      1  32ce		       fd 30		      .word.w	CO
    504  32d0							;=======================================================================
    505  32d0							;RUN begin to executed the program in memory
    506  32d0							;
    507  32d0				   ekRun
      0  32d0					      DONE
      0  32d0					      db	1
      1  32d0		       01		      .byte.b	1
      0  32d1					      VINIT		;clear variables compile the line numbers
      0  32d1					      db	30
      1  32d1		       1e		      .byte.b	30
      0  32d2					      LIT	1	;GOTO line 1
      0  32d2					      db	27
      1  32d2		       1b		      .byte.b	27
      0  32d3					      dw	1
      1  32d3		       01 00		      .word.w	1
      0  32d5					      XFER		;Bob's addition
      0  32d5					      db	7
      1  32d5		       07		      .byte.b	7
    512  32d6							; EXIT
      0  32d6					      IJMP	STMT	;and run!
      0  32d6					      db	29
      1  32d6		       1d		      .byte.b	29
      0  32d7					      dw	STMT
      1  32d7		       05 31		      .word.w	STMT
    514  32d9							;=========================================================================
    515  32d9							;Clear the program memory, delete all proram lines
    516  32d9							;
    517  32d9				   ekNew
      0  32d9					      DONE
      0  32d9					      db	1
      1  32d9		       01		      .byte.b	1
      0  32da					      IJMP	START
      0  32da					      db	29
      1  32da		       1d		      .byte.b	29
      0  32db					      dw	START
      1  32db		       f7 30		      .word.w	START
    520  32dd
    521  32dd							;========================================================================
    522  32dd							; Slice(slice legth expression)
    523  32dd							;   set the length of time between task switches
    524  32dd							;
    525  32dd				   ekSlice
      0  32dd					      CALL	EXPR
      0  32dd					      db	28
      1  32dd		       1c		      .byte.b	28
      0  32de					      dw	EXPR
      1  32de		       19 33		      .word.w	EXPR
      0  32e0					      SLICE
      0  32e0					      db	100
      1  32e0		       64		      .byte.b	100
      0  32e1					      DONE
      0  32e1					      db	1
      1  32e1		       01		      .byte.b	1
      0  32e2					      NXT	CO
      0  32e2					      db	6
      1  32e2		       06		      .byte.b	6
      0  32e3					      dw	CO
      1  32e3		       fd 30		      .word.w	CO
      0  32e5					      IJMP	STMT
      0  32e5					      db	29
      1  32e5		       1d		      .byte.b	29
      0  32e6					      dw	STMT
      1  32e6		       05 31		      .word.w	STMT
    531  32e8							;==========================================================================
    532  32e8							; Turn off and on the thrace functions
    533  32e8							; a debug terminal needs to be available
    534  32e8							; Trace( Trace flag expression)
    535  32e8							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    536  32e8							;	for individual lines of basic code. These can be combined
    537  32e8				   ekTrace
      0  32e8					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  32e8					      db	101
      1  32e8		       65		      .byte.b	101
      0  32e9					      db	(UNKNOWN-*)-1
      1  32e9		       2b		      .byte.b	(UNKNOWN-*)-1
      0  32ea					      db	oLeftBracket
      1  32ea		       e0		      .byte.b	oLeftBracket
      0  32eb					      CALL	EXPR
      0  32eb					      db	28
      1  32eb		       1c		      .byte.b	28
      0  32ec					      dw	EXPR
      1  32ec		       19 33		      .word.w	EXPR
      0  32ee					      TSTB	UNKNOWN,oRightBracket
      0  32ee					      db	101
      1  32ee		       65		      .byte.b	101
      0  32ef					      db	(UNKNOWN-*)-1
      1  32ef		       25		      .byte.b	(UNKNOWN-*)-1
      0  32f0					      db	oRightBracket
      1  32f0		       e1		      .byte.b	oRightBracket
      0  32f1					      TRACEPROGRAM
      0  32f1					      db	78
      1  32f1		       4e		      .byte.b	78
      0  32f2					      DONE
      0  32f2					      db	1
      1  32f2		       01		      .byte.b	1
      0  32f3					      NXT	CO
      0  32f3					      db	6
      1  32f3		       06		      .byte.b	6
      0  32f4					      dw	CO
      1  32f4		       fd 30		      .word.w	CO
      0  32f6					      IJMP	STMT
      0  32f6					      db	29
      1  32f6		       1d		      .byte.b	29
      0  32f7					      dw	STMT
      1  32f7		       05 31		      .word.w	STMT
    545  32f9							;=====================================================================
    546  32f9							; Exit basic to machine monitor
    547  32f9							;
    548  32f9				   ekExit
      0  32f9					      EXIT
      0  32f9					      db	26
      1  32f9		       1a		      .byte.b	26
    550  32fa
    551  32fa							;=======================================================================
    552  32fa							; Commands related to saving/restoring programs
    553  32fa							; to/from mass storage.
    554  32fa							;=======================================================================
    555  32fa							; Save a program file
    556  32fa							;
    557  32fa					      if	(XKIM || CTMON65) && DISK_ACCESS
    558  32fa
    559  32fa				   ekSave
      0  32fa					      OPENWRITE	OPEN_CREATE
      0  32fa					      db	40
      1  32fa		       28		      .byte.b	40
      0  32fb					      db	OPEN_CREATE
      1  32fb		       01		      .byte.b	OPEN_CREATE
      0  32fc					      DLIST
      0  32fc					      db	43
      1  32fc		       2b		      .byte.b	43
      0  32fd					      DCLOSE
      0  32fd					      db	41
      1  32fd		       29		      .byte.b	41
      0  32fe					      IJMP	CO
      0  32fe					      db	29
      1  32fe		       1d		      .byte.b	29
      0  32ff					      dw	CO
      1  32ff		       fd 30		      .word.w	CO
    564  3301							;=========================================================================
    565  3301							; Load a program file
    566  3301							;
    567  3301				   ekLoad
      0  3301					      OPENREAD
      0  3301					      db	39
      1  3301		       27		      .byte.b	39
    569  3302				   S17CLP
      0  3302					      DGETLINE		;get line from file
      0  3302					      db	42
      1  3302		       2a		      .byte.b	42
      0  3303					      TSTL	S17EOL	;no line num means EOL
      0  3303					      db	34
      1  3303		       22		      .byte.b	34
      0  3304					      db	(S17EOL-*)-1
      1  3304		       04		      .byte.b	(S17EOL-*)-1
      0  3305					      INSERT		;put it into the program
      0  3305					      db	24
      1  3305		       18		      .byte.b	24
      0  3306					      IJMP	S17CLP	;keep going
      0  3306					      db	29
      1  3306		       1d		      .byte.b	29
      0  3307					      dw	S17CLP
      1  3307		       02 33		      .word.w	S17CLP
    574  3309				   S17EOL
      0  3309					      DCLOSE		;close disk file
      0  3309					      db	41
      1  3309		       29		      .byte.b	41
      0  330a					      IJMP	CO	;back to start
      0  330a					      db	29
      1  330a		       1d		      .byte.b	29
      0  330b					      dw	CO
      1  330b		       fd 30		      .word.w	CO
    577  330d							;=========================================================================
    578  330d							; Display the directory content
    579  330d							;
    580  330d				   ekDir
      0  330d					      DDIR		;Display the directory content
      0  330d					      db	44
      1  330d		       2c		      .byte.b	44
      0  330e					      IJMP	CO
      0  330e					      db	29
      1  330e		       1d		      .byte.b	29
      0  330f					      dw	CO
      1  330f		       fd 30		      .word.w	CO
    583  3311							;=========================================================================
    584  3311							; Erase a file from disk
    585  3311							;
    586  3311				   ekErase
      0  3311					      RMFILE		;Erase the file from the disk
      0  3311					      db	45
      1  3311		       2d		      .byte.b	45
      0  3312					      IJMP	CO
      0  3312					      db	29
      1  3312		       1d		      .byte.b	29
      0  3313					      dw	CO
      1  3313		       fd 30		      .word.w	CO
    589  3315
    590  3315					      endif
    591  3315
    592  3315							;===========================================================================
    593  3315							; Else, unknown command.
    594  3315							;
    595  3315				   UNKNOWN
      0  3315					      ENDIO
      0  3315					      db	71
      1  3315		       47		      .byte.b	71
    597  3316
    598  3316				   NotKnownStatement
    599  3316
      0  3316					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  3316					      db	13
      1  3316		       0d		      .byte.b	13
      0  3317					      dw	ERR_SYNTAX
      1  3317		       05 00		      .word.w	ERR_SYNTAX
    601  3319
    602  3319							;=======================================================
    603  3319							; Process Expresions, precidence is represented by the
    604  3319							; various call levels
    605  3319							;
      0  3319				   EXPR       TSTB	EXPRNEXT,oLeftBracket
      0  3319					      db	101
      1  3319		       65		      .byte.b	101
      0  331a					      db	(EXPRNEXT-*)-1
      1  331a		       0c		      .byte.b	(EXPRNEXT-*)-1
      0  331b					      db	oLeftBracket
      1  331b		       e0		      .byte.b	oLeftBracket
      0  331c					      Call	EXPR
      0  331c					      db	28
      1  331c		       1c		      .byte.b	28
      0  331d					      dw	EXPR
      1  331d		       19 33		      .word.w	EXPR
      0  331f					      TSTB	ExpectBrace,oRightBracket
      0  331f					      db	101
      1  331f		       65		      .byte.b	101
      0  3320					      db	(ExpectBrace-*)-1
      1  3320		       02		      .byte.b	(ExpectBrace-*)-1
      0  3321					      db	oRightBracket
      1  3321		       e1		      .byte.b	oRightBracket
      0  3322					      RTN
      0  3322					      db	25
      1  3322		       19		      .byte.b	25
    610  3323
    611  3323				   ExpectBrace
      0  3323					      ENDIO
      0  3323					      db	71
      1  3323		       47		      .byte.b	71
      0  3324					      ERRMSG	ERR_CLOSINGBRACKET
      0  3324					      db	13
      1  3324		       0d		      .byte.b	13
      0  3325					      dw	ERR_CLOSINGBRACKET
      1  3325		       17 00		      .word.w	ERR_CLOSINGBRACKET
    614  3327
    615  3327				   EXPRNEXT
      0  3327					      TSTB	EXPRLOGS,kNot
      0  3327					      db	101
      1  3327		       65		      .byte.b	101
      0  3328					      db	(EXPRLOGS-*)-1
      1  3328		       06		      .byte.b	(EXPRLOGS-*)-1
      0  3329					      db	kNot
      1  3329		       24		      .byte.b	kNot
    617  332a				   ekNot
      0  332a					      Call	EXPR
      0  332a					      db	28
      1  332a		       1c		      .byte.b	28
      0  332b					      dw	EXPR
      1  332b		       19 33		      .word.w	EXPR
      0  332d					      LOGNOT
      0  332d					      db	72
      1  332d		       48		      .byte.b	72
      0  332e					      RTN
      0  332e					      db	25
      1  332e		       19		      .byte.b	25
    621  332f
    622  332f
    623  332f							;=========================================================
    624  332f							;Look for logical operators, but does get first part of expression
    625  332f				   EXPRLOGS
      0  332f					      Call	EXPRCMP
      0  332f					      db	28
      1  332f		       1c		      .byte.b	28
      0  3330					      dw	EXPRCMP
      1  3330		       57 33		      .word.w	EXPRCMP
    627  3332							;=========================================================
    628  3332							;Look for shift left and shift right level
    629  3332				   EXPSHIFT
      0  3332					      OnGoto	BasicShift,EXPRLOGICAL
      0  3332					      db	103
      1  3332		       67		      .byte.b	103
      0  3333					      dw	BasicShift
      1  3333		       cd 30		      .word.w	BasicShift
      0  3335					      dw	EXPRLOGICAL
      1  3335		       43 33		      .word.w	EXPRLOGICAL
    631  3337
    632  3337				   ekShiftLeft
      0  3337					      Call	EXPR
      0  3337					      db	28
      1  3337		       1c		      .byte.b	28
      0  3338					      dw	EXPR
      1  3338		       19 33		      .word.w	EXPR
      0  333a					      SHIFT	0
      0  333a					      db	113
      1  333a		       71		      .byte.b	113
      0  333b					      db	0
      1  333b		       00		      .byte.b	0
      0  333c					      RTN
      0  333c					      db	25
      1  333c		       19		      .byte.b	25
    636  333d
    637  333d				   ekShiftRight
      0  333d					      Call	EXPR
      0  333d					      db	28
      1  333d		       1c		      .byte.b	28
      0  333e					      dw	EXPR
      1  333e		       19 33		      .word.w	EXPR
      0  3340					      SHIFT	1
      0  3340					      db	113
      1  3340		       71		      .byte.b	113
      0  3341					      db	1
      1  3341		       01		      .byte.b	1
      0  3342					      RTN
      0  3342					      db	25
      1  3342		       19		      .byte.b	25
    641  3343
    642  3343							;======================================================================
    643  3343				   EXPRLOGICAL
      0  3343					      OnGoto	BasicLogical,iLOGExit
      0  3343					      db	103
      1  3343		       67		      .byte.b	103
      0  3344					      dw	BasicLogical
      1  3344		       c5 30		      .word.w	BasicLogical
      0  3346					      dw	iLOGExit
      1  3346		       56 33		      .word.w	iLOGExit
    645  3348				   ekAnd
      0  3348					      Call	EXPR
      0  3348					      db	28
      1  3348		       1c		      .byte.b	28
      0  3349					      dw	EXPR
      1  3349		       19 33		      .word.w	EXPR
      0  334b					      LOGAND
      0  334b					      db	74
      1  334b		       4a		      .byte.b	74
      0  334c					      RTN
      0  334c					      db	25
      1  334c		       19		      .byte.b	25
    649  334d				   ekOr
      0  334d					      Call	EXPR
      0  334d					      db	28
      1  334d		       1c		      .byte.b	28
      0  334e					      dw	EXPR
      1  334e		       19 33		      .word.w	EXPR
      0  3350					      LOGOR
      0  3350					      db	73
      1  3350		       49		      .byte.b	73
      0  3351					      RTN
      0  3351					      db	25
      1  3351		       19		      .byte.b	25
    653  3352				   ekXor
      0  3352					      Call	EXPR
      0  3352					      db	28
      1  3352		       1c		      .byte.b	28
      0  3353					      dw	EXPR
      1  3353		       19 33		      .word.w	EXPR
      0  3355					      LOGXOR
      0  3355					      db	75
      1  3355		       4b		      .byte.b	75
    656  3356				   iLOGExit
      0  3356					      RTN
      0  3356					      db	25
      1  3356		       19		      .byte.b	25
    658  3357							;========================================================================
    659  3357							; Process relational operators
    660  3357							;
    661  3357				   EXPRCMP
      0  3357					      Call	EXPR2	; get the left first expression
      0  3357					      db	28
      1  3357		       1c		      .byte.b	28
      0  3358					      dw	EXPR2
      1  3358		       62 33		      .word.w	EXPR2
      0  335a					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  335a					      db	104
      1  335a		       68		      .byte.b	104
      0  335b					      db	(iRDone-*)-1
      1  335b		       05		      .byte.b	(iRDone-*)-1
    664  335c							;	  TSTB	     iR0,oEqual
    665  335c							;	  LIT	     2		     ;=
    666  335c							;	  IJMP	     iRFound
    667  335c							;iR0:
    668  335c							;	  TSTB	      iR1,oLessEqual
    669  335c							;	  LIT	      3 	      ;<=
    670  335c							;	  IJMP	     iRFound
    671  335c							;iR1:
    672  335c							;	  TSTB	     iR3,oNotEqual
    673  335c							;	  LIT	     5		      ;<>
    674  335c							;	      IJMP	  iRFound
    675  335c							;iR3:
    676  335c							;	  TSTB	     iR4,oLess
    677  335c							;	  LIT	     1		     ;<
    678  335c							;	      IJMP	  iRFound
    679  335c							;iR4:
    680  335c							;	  TST	     iR5,oGreaterEqual
    681  335c							;	  LIT	     6		     ;>=
    682  335c							;	      IJMP	  iRFound
    683  335c							;iR5:
    684  335c							;	  TSTB	     iRDone,oGreater
    685  335c							;	  LIT	     4		     ;>
    686  335c				   iRFound
      0  335c					      Call	EXPR	; get the right side of the expression
      0  335c					      db	28
      1  335c		       1c		      .byte.b	28
      0  335d					      dw	EXPR
      1  335d		       19 33		      .word.w	EXPR
      0  335f					      CMPR		; Push the value of the true false onto the stack
      0  335f					      db	10
      1  335f		       0a		      .byte.b	10
      0  3360					      RTN
      0  3360					      db	25
      1  3360		       19		      .byte.b	25
    690  3361
    691  3361				   iRDone
      0  3361					      RTN
      0  3361					      db	25
      1  3361		       19		      .byte.b	25
    693  3362
    694  3362				   EXPR2
      0  3362					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  3362					      db	101
      1  3362		       65		      .byte.b	101
      0  3363					      db	(E0-*)-1
      1  3363		       08		      .byte.b	(E0-*)-1
      0  3364					      db	oMinus
      1  3364		       eb		      .byte.b	oMinus
      0  3365					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  3365					      db	28
      1  3365		       1c		      .byte.b	28
      0  3366					      dw	TERM
      1  3366		       88 33		      .word.w	TERM
      0  3368					      NEG		; Make value negated
      0  3368					      db	16
      1  3368		       10		      .byte.b	16
      0  3369					      IJMP	E1	; We have Left term process operators next
      0  3369					      db	29
      1  3369		       1d		      .byte.b	29
      0  336a					      dw	E1
      1  336a		       72 33		      .word.w	E1
    699  336c				   E0
      0  336c					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  336c					      db	101
      1  336c		       65		      .byte.b	101
      0  336d					      db	(E1A-*)-1
      1  336d		       01		      .byte.b	(E1A-*)-1
      0  336e					      db	oPlus
      1  336e		       ea		      .byte.b	oPlus
    701  336f				   E1A
      0  336f					      CALL	TERM	; Get the left term if it was not negated
      0  336f					      db	28
      1  336f		       1c		      .byte.b	28
      0  3370					      dw	TERM
      1  3370		       88 33		      .word.w	TERM
    703  3372				   E1
      0  3372					      TST	E2,oPlus	; Check if we are adding left term to something
      0  3372					      db	32
      1  3372		       20		      .byte.b	32
      0  3373					      db	(E2-*)-1
      1  3373		       09		      .byte.b	(E2-*)-1
      0  3374					      db	oPlus,0
      1  3374		       ea 00		      .byte.b	oPlus,0
      0  3376					      CALL	TERM	; if adding then get the right side term
      0  3376					      db	28
      1  3376		       1c		      .byte.b	28
      0  3377					      dw	TERM
      1  3377		       88 33		      .word.w	TERM
      0  3379					      ADD		; Add it to left term
      0  3379					      db	14
      1  3379		       0e		      .byte.b	14
      0  337a					      IJMP	E1	; look for next + or -
      0  337a					      db	29
      1  337a		       1d		      .byte.b	29
      0  337b					      dw	E1
      1  337b		       72 33		      .word.w	E1
    708  337d				   E2
      0  337d					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  337d					      db	101
      1  337d		       65		      .byte.b	101
      0  337e					      db	(E3-*)-1
      1  337e		       08		      .byte.b	(E3-*)-1
      0  337f					      db	oMinus
      1  337f		       eb		      .byte.b	oMinus
      0  3380					      CALL	TERM	; get right side to subtract Diffrence
      0  3380					      db	28
      1  3380		       1c		      .byte.b	28
      0  3381					      dw	TERM
      1  3381		       88 33		      .word.w	TERM
      0  3383					      SUB		; Subtract the value
      0  3383					      db	15
      1  3383		       0f		      .byte.b	15
      0  3384					      IJMP	E1	; Look for next + or -
      0  3384					      db	29
      1  3384		       1d		      .byte.b	29
      0  3385					      dw	E1
      1  3385		       72 33		      .word.w	E1
    713  3387				   E3			; Finish processing the expression
      0  3387					      RTN		; We are finished processing the Expression
      0  3387					      db	25
      1  3387		       19		      .byte.b	25
    715  3388							;
    716  3388							; Get one of the terms of an expression
    717  3388							;
    718  3388				   TERM
      0  3388					      CALL	FACT	; Get a value
      0  3388					      db	28
      1  3388		       1c		      .byte.b	28
      0  3389					      dw	FACT
      1  3389		       ad 33		      .word.w	FACT
    720  338b				   T0			; Check for higher precidence operators
      0  338b					      TSTB	T1,oMultiply	; Check for *
      0  338b					      db	101
      1  338b		       65		      .byte.b	101
      0  338c					      db	(T1-*)-1
      1  338c		       08		      .byte.b	(T1-*)-1
      0  338d					      db	oMultiply
      1  338d		       ee		      .byte.b	oMultiply
      0  338e					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  338e					      db	28
      1  338e		       1c		      .byte.b	28
      0  338f					      dw	FACT
      1  338f		       ad 33		      .word.w	FACT
      0  3391					      MUL		; Multiply factors
      0  3391					      db	17
      1  3391		       11		      .byte.b	17
      0  3392					      IJMP	T0	; Check for * or /
      0  3392					      db	29
      1  3392		       1d		      .byte.b	29
      0  3393					      dw	T0
      1  3393		       8b 33		      .word.w	T0
    725  3395				   T1
      0  3395					      TSTB	T2,oDivide	; Check for a division
      0  3395					      db	101
      1  3395		       65		      .byte.b	101
      0  3396					      db	(T2-*)-1
      1  3396		       08		      .byte.b	(T2-*)-1
      0  3397					      db	oDivide
      1  3397		       ec		      .byte.b	oDivide
      0  3398					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  3398					      db	28
      1  3398		       1c		      .byte.b	28
      0  3399					      dw	FACT
      1  3399		       ad 33		      .word.w	FACT
      0  339b					      DIV		; do division
      0  339b					      db	18
      1  339b		       12		      .byte.b	18
      0  339c					      IJMP	T0	; check for more * or /
      0  339c					      db	29
      1  339c		       1d		      .byte.b	29
      0  339d					      dw	T0
      1  339d		       8b 33		      .word.w	T0
    730  339f				   T2
      0  339f					      TSTB	T3,oModulo	; Check for a division
      0  339f					      db	101
      1  339f		       65		      .byte.b	101
      0  33a0					      db	(T3-*)-1
      1  33a0		       08		      .byte.b	(T3-*)-1
      0  33a1					      db	oModulo
      1  33a1		       ed		      .byte.b	oModulo
      0  33a2					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  33a2					      db	28
      1  33a2		       1c		      .byte.b	28
      0  33a3					      dw	FACT
      1  33a3		       ad 33		      .word.w	FACT
      0  33a5					      MODULO		; do division for remainder
      0  33a5					      db	60
      1  33a5		       3c		      .byte.b	60
      0  33a6					      IJMP	T0	; check for more * or / or %
      0  33a6					      db	29
      1  33a6		       1d		      .byte.b	29
      0  33a7					      dw	T0
      1  33a7		       8b 33		      .word.w	T0
    735  33a9				   T3			; Finish processing the Term
      0  33a9					      RTN
      0  33a9					      db	25
      1  33a9		       19		      .byte.b	25
    737  33aa
    738  33aa				   UNKNOWNVEC
      0  33aa					      IJMP	UNKNOWN
      0  33aa					      db	29
      1  33aa		       1d		      .byte.b	29
      0  33ab					      dw	UNKNOWN
      1  33ab		       15 33		      .word.w	UNKNOWN
    740  33ad
    741  33ad							;=============================================================================================
    742  33ad							; Factor an expression.  Always test for functions
    743  33ad							; first or else they'll be confused for variables.
    744  33ad							;
    745  33ad				   FACT
      0  33ad					      OnGoto	BasicFuncs,FactNumber
      0  33ad					      db	103
      1  33ad		       67		      .byte.b	103
      0  33ae					      dw	BasicFuncs
      1  33ae		       d3 30		      .word.w	BasicFuncs
      0  33b0					      dw	FactNumber
      1  33b0		       96 34		      .word.w	FactNumber
    747  33b2
    748  33b2							;FACTCONTINUE:
    749  33b2							;	  TSTB	     F1AA,kTrue
    750  33b2				   ekTrue
      0  33b2					      LIT	-1
      0  33b2					      db	27
      1  33b2		       1b		      .byte.b	27
      0  33b3					      dw	-1
      1  33b3		       ff ff		      .word.w	-1
      0  33b5					      RTN
      0  33b5					      db	25
      1  33b5		       19		      .byte.b	25
    753  33b6							;F1AA:
    754  33b6							;	  TSTB	     F1AB,kFalse
    755  33b6				   ekFalse
      0  33b6					      LIT	0
      0  33b6					      db	27
      1  33b6		       1b		      .byte.b	27
      0  33b7					      dw	0
      1  33b7		       00 00		      .word.w	0
      0  33b9					      RTN
      0  33b9					      db	25
      1  33b9		       19		      .byte.b	25
    758  33ba							;==================================================================================
    759  33ba							; Returns the amount of free SPACE
    760  33ba				   ekFree
      0  33ba					      TSTB	UNKNOWNVEC,oLeftBracket
      0  33ba					      db	101
      1  33ba		       65		      .byte.b	101
      0  33bb					      db	(UNKNOWNVEC-*)-1
      1  33bb		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  33bc					      db	oLeftBracket
      1  33bc		       e0		      .byte.b	oLeftBracket
      0  33bd					      TSTB	UNKNOWNVEC,oRightBracket
      0  33bd					      db	101
      1  33bd		       65		      .byte.b	101
      0  33be					      db	(UNKNOWNVEC-*)-1
      1  33be		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  33bf					      db	oRightBracket
      1  33bf		       e1		      .byte.b	oRightBracket
      0  33c0					      FREE
      0  33c0					      db	36
      1  33c0		       24		      .byte.b	36
      0  33c1					      RTN
      0  33c1					      db	25
      1  33c1		       19		      .byte.b	25
    765  33c2							;===================================================================================
    766  33c2							; getch() read a character from the input device
    767  33c2							;
    768  33c2				   ekGetch
      0  33c2					      TSTB	UNKNOWNVEC,oLeftBracket
      0  33c2					      db	101
      1  33c2		       65		      .byte.b	101
      0  33c3					      db	(UNKNOWNVEC-*)-1
      1  33c3		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  33c4					      db	oLeftBracket
      1  33c4		       e0		      .byte.b	oLeftBracket
      0  33c5					      TSTB	UNKNOWNVEC,oRightBracket
      0  33c5					      db	101
      1  33c5		       65		      .byte.b	101
      0  33c6					      db	(UNKNOWNVEC-*)-1
      1  33c6		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  33c7					      db	oRightBracket
      1  33c7		       e1		      .byte.b	oRightBracket
      0  33c8					      GETCHAR
      0  33c8					      db	51
      1  33c8		       33		      .byte.b	51
      0  33c9					      RTN
      0  33c9					      db	25
      1  33c9		       19		      .byte.b	25
    773  33ca							;
    774  33ca							;====================================================================================
    775  33ca							; addr(variable definition)
    776  33ca							; Returns the address of a variable on top of the stack
    777  33ca				   ekAddr
      0  33ca					      TSTB	UNKNOWNVEC,oLeftBracket
      0  33ca					      db	101
      1  33ca		       65		      .byte.b	101
      0  33cb					      db	(UNKNOWNVEC-*)-1
      1  33cb		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  33cc					      db	oLeftBracket
      1  33cc		       e0		      .byte.b	oLeftBracket
      0  33cd					      TSTV	ExpectedVariable
      0  33cd					      db	33
      1  33cd		       21		      .byte.b	33
      0  33ce					      db	(ExpectedVariable-*)-1
      1  33ce		       07		      .byte.b	(ExpectedVariable-*)-1
      0  33cf					      CALL	FactVarPtrNoTst
      0  33cf					      db	28
      1  33cf		       1c		      .byte.b	28
      0  33d0					      dw	FactVarPtrNoTst
      1  33d0		       c6 34		      .word.w	FactVarPtrNoTst
      0  33d2					      TSTB	UNKNOWNVEC,oRightBracket
      0  33d2					      db	101
      1  33d2		       65		      .byte.b	101
      0  33d3					      db	(UNKNOWNVEC-*)-1
      1  33d3		       d6		      .byte.b	(UNKNOWNVEC-*)-1
      0  33d4					      db	oRightBracket
      1  33d4		       e1		      .byte.b	oRightBracket
      0  33d5					      RTN
      0  33d5					      db	25
      1  33d5		       19		      .byte.b	25
    783  33d6
    784  33d6				   ExpectedVariable
      0  33d6					      ERRMSG	ERR_SYNTAX	;Expected Variable
      0  33d6					      db	13
      1  33d6		       0d		      .byte.b	13
      0  33d7					      dw	ERR_SYNTAX
      1  33d7		       05 00		      .word.w	ERR_SYNTAX
    786  33d9							;
    787  33d9							;================================================================
    788  33d9							; Compare a block of memory
    789  33d9							; CmpMem(Length, Source 1, Source 2)
    790  33d9							; returns on the stack 0 equal, 1 s1>s2, -1 s1<s2
    791  33d9				   ekCmpMem
      0  33d9					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  33d9					      db	101
      1  33d9		       65		      .byte.b	101
      0  33da					      db	(UNKNOWNVEC-*)-1
      1  33da		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  33db					      db	oLeftBracket
      1  33db		       e0		      .byte.b	oLeftBracket
      0  33dc					      CALL	EXPR	; Length
      0  33dc					      db	28
      1  33dc		       1c		      .byte.b	28
      0  33dd					      dw	EXPR
      1  33dd		       19 33		      .word.w	EXPR
      0  33df					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  33df					      db	101
      1  33df		       65		      .byte.b	101
      0  33e0					      db	(UNKNOWNVEC-*)-1
      1  33e0		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  33e1					      db	oComma
      1  33e1		       e2		      .byte.b	oComma
      0  33e2					      CALL	EXPR	; Source 1
      0  33e2					      db	28
      1  33e2		       1c		      .byte.b	28
      0  33e3					      dw	EXPR
      1  33e3		       19 33		      .word.w	EXPR
      0  33e5					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  33e5					      db	101
      1  33e5		       65		      .byte.b	101
      0  33e6					      db	(UNKNOWNVEC-*)-1
      1  33e6		       c3		      .byte.b	(UNKNOWNVEC-*)-1
      0  33e7					      db	oComma
      1  33e7		       e2		      .byte.b	oComma
      0  33e8					      CALL	EXPR	; Source 2
      0  33e8					      db	28
      1  33e8		       1c		      .byte.b	28
      0  33e9					      dw	EXPR
      1  33e9		       19 33		      .word.w	EXPR
      0  33eb					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  33eb					      db	101
      1  33eb		       65		      .byte.b	101
      0  33ec					      db	(UNKNOWNVEC-*)-1
      1  33ec		       bd		      .byte.b	(UNKNOWNVEC-*)-1
      0  33ed					      db	oRightBracket
      1  33ed		       e1		      .byte.b	oRightBracket
      0  33ee					      CMPMEM		; Compare the memory
      0  33ee					      db	112
      1  33ee		       70		      .byte.b	112
      0  33ef					      RTN
      0  33ef					      db	25
      1  33ef		       19		      .byte.b	25
    801  33f0							;====================================================================================
    802  33f0							; peek(mem address) return the value of a byte in memory
    803  33f0							; @[offset] return a word value from offset -- see tstv
    804  33f0							;
    805  33f0							;F1A2:
    806  33f0							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    807  33f0				   ekPeek
      0  33f0					      TSTB	UNKNOWNVEC,oLeftBracket
      0  33f0					      db	101
      1  33f0		       65		      .byte.b	101
      0  33f1					      db	(UNKNOWNVEC-*)-1
      1  33f1		       b8		      .byte.b	(UNKNOWNVEC-*)-1
      0  33f2					      db	oLeftBracket
      1  33f2		       e0		      .byte.b	oLeftBracket
      0  33f3					      CALL	EXPR	;Get the address to write to
      0  33f3					      db	28
      1  33f3		       1c		      .byte.b	28
      0  33f4					      dw	EXPR
      1  33f4		       19 33		      .word.w	EXPR
      0  33f6					      TSTB	UNKNOWNVEC,oRightBracket
      0  33f6					      db	101
      1  33f6		       65		      .byte.b	101
      0  33f7					      db	(UNKNOWNVEC-*)-1
      1  33f7		       b2		      .byte.b	(UNKNOWNVEC-*)-1
      0  33f8					      db	oRightBracket
      1  33f8		       e1		      .byte.b	oRightBracket
      0  33f9					      PEEKMEM
      0  33f9					      db	48
      1  33f9		       30		      .byte.b	48
      0  33fa					      RTN
      0  33fa					      db	25
      1  33fa		       19		      .byte.b	25
    813  33fb							;=======================================================================================
    814  33fb							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    815  33fb							;
    816  33fb							;F2AZ:
    817  33fb							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    818  33fb				   ekTask
      0  33fb					      TSTBRANCH	ekTaskCompiled
      0  33fb					      db	106
      1  33fb		       6a		      .byte.b	106
      0  33fc					      db	(ekTaskCompiled-*)-1
      1  33fc		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  33fd					      TSTB	UNKNOWNVEC,oLeftBracket
      0  33fd					      db	101
      1  33fd		       65		      .byte.b	101
      0  33fe					      db	(UNKNOWNVEC-*)-1
      1  33fe		       ab		      .byte.b	(UNKNOWNVEC-*)-1
      0  33ff					      db	oLeftBracket
      1  33ff		       e0		      .byte.b	oLeftBracket
      0  3400					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  3400					      db	28
      1  3400		       1c		      .byte.b	28
      0  3401					      dw	EXPR
      1  3401		       19 33		      .word.w	EXPR
      0  3403					      lit	0
      0  3403					      db	27
      1  3403		       1b		      .byte.b	27
      0  3404					      dw	0
      1  3404		       00 00		      .word.w	0
      0  3406					      iJMP	ekTaskLinenum
      0  3406					      db	29
      1  3406		       1d		      .byte.b	29
      0  3407					      dw	ekTaskLinenum
      1  3407		       0c 34		      .word.w	ekTaskLinenum
    824  3409
    825  3409				   ekTaskCompiled
      0  3409					      lit	1
      0  3409					      db	27
      1  3409		       1b		      .byte.b	27
      0  340a					      dw	1
      1  340a		       01 00		      .word.w	1
    827  340c
    828  340c				   ekTaskLinenum
      0  340c					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  340c					      db	61
      1  340c		       3d		      .byte.b	61
      0  340d					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  340d					      db	101
      1  340d		       65		      .byte.b	101
      0  340e					      db	(F2AZNoParms-*)-1
      1  340e		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  340f					      db	oComma
      1  340f		       e2		      .byte.b	oComma
      0  3410					      SAVEMATHSTACK		;Push The mathstack
      0  3410					      db	86
      1  3410		       56		      .byte.b	86
      0  3411					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  3411					      db	89
      1  3411		       59		      .byte.b	89
    833  3412				   F2AZLOOP
      0  3412					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  3412					      db	28
      1  3412		       1c		      .byte.b	28
      0  3413					      dw	EXPR
      1  3413		       19 33		      .word.w	EXPR
      0  3415					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  3415					      db	101
      1  3415		       65		      .byte.b	101
      0  3416					      db	(F2AZEndParm-*)-1
      1  3416		       04		      .byte.b	(F2AZEndParm-*)-1
      0  3417					      db	oComma
      1  3417		       e2		      .byte.b	oComma
      0  3418					      IJMP	F2AZLOOP	;check for more
      0  3418					      db	29
      1  3418		       1d		      .byte.b	29
      0  3419					      dw	F2AZLOOP
      1  3419		       12 34		      .word.w	F2AZLOOP
    837  341b
    838  341b				   F2AZEndParm
      0  341b					      RESTOREMATHSTACK		;Back to normal stack
      0  341b					      db	87
      1  341b		       57		      .byte.b	87
      0  341c					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  341c					      db	92
      1  341c		       5c		      .byte.b	92
    841  341d
    842  341d				   F2AZNoParms
      0  341d					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  341d					      db	101
      1  341d		       65		      .byte.b	101
      0  341e					      db	(UNKNOWNVEC-*)-1
      1  341e		       8b		      .byte.b	(UNKNOWNVEC-*)-1
      0  341f					      db	oRightBracket
      1  341f		       e1		      .byte.b	oRightBracket
    844  3420
      0  3420					      TASKENABLE		;Enable the task to execute
      0  3420					      db	90
      1  3420		       5a		      .byte.b	90
    846  3421
      0  3421					      RTN		;Returns the Task number
      0  3421					      db	25
      1  3421		       19		      .byte.b	25
    848  3422							;=========================================================================================
    849  3422							; Check for IPC interproccess instructions
    850  3422							;   IPCS  - Send a message
    851  3422							;
    852  3422							;F2AZ1:
    853  3422							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    854  3422				   ekIpcs
      0  3422					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  3422					      db	101
      1  3422		       65		      .byte.b	101
      0  3423					      db	(UNKNOWNVEC-*)-1
      1  3423		       86		      .byte.b	(UNKNOWNVEC-*)-1
      0  3424					      db	oLeftBracket
      1  3424		       e0		      .byte.b	oLeftBracket
      0  3425					      CALL	EXPR	;Get the message value
      0  3425					      db	28
      1  3425		       1c		      .byte.b	28
      0  3426					      dw	EXPR
      1  3426		       19 33		      .word.w	EXPR
      0  3428					      TSTB	UNKNOWNVEC,oComma
      0  3428					      db	101
      1  3428		       65		      .byte.b	101
      0  3429					      db	(UNKNOWNVEC-*)-1
      1  3429		       80		      .byte.b	(UNKNOWNVEC-*)-1
      0  342a					      db	oComma
      1  342a		       e2		      .byte.b	oComma
      0  342b					      CALL	EXPR	;Get pid of task to send to
      0  342b					      db	28
      1  342b		       1c		      .byte.b	28
      0  342c					      dw	EXPR
      1  342c		       19 33		      .word.w	EXPR
      0  342e					      TSTB	UNKNOWNVEC,oRightBracket
      0  342e					      db	101
      1  342e		       65		      .byte.b	101
      0  342f					      db	(UNKNOWNVEC-*)-1
      1  342f		       7a		      .byte.b	(UNKNOWNVEC-*)-1
      0  3430					      db	oRightBracket
      1  3430		       e1		      .byte.b	oRightBracket
      0  3431					      IPCSEND		;Send msg and clear pid msg pending
      0  3431					      db	80
      1  3431		       50		      .byte.b	80
      0  3432					      RTN
      0  3432					      db	25
      1  3432		       19		      .byte.b	25
    862  3433							;================================================================================
    863  3433							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    864  3433							;
    865  3433				   ekIpcr
      0  3433					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  3433					      db	101
      1  3433		       65		      .byte.b	101
      0  3434					      db	(UNKNOWNVEC-*)-1
      1  3434		       75		      .byte.b	(UNKNOWNVEC-*)-1
      0  3435					      db	oLeftBracket
      1  3435		       e0		      .byte.b	oLeftBracket
      0  3436					      TSTB	F2AZa1,oRightBracket
      0  3436					      db	101
      1  3436		       65		      .byte.b	101
      0  3437					      db	(F2AZa1-*)-1
      1  3437		       07		      .byte.b	(F2AZa1-*)-1
      0  3438					      db	oRightBracket
      1  3438		       e1		      .byte.b	oRightBracket
      0  3439					      LIT	0	;We dont want the pid returned to us
      0  3439					      db	27
      1  3439		       1b		      .byte.b	27
      0  343a					      dw	0
      1  343a		       00 00		      .word.w	0
      0  343c					      IJMP	ekIpcrComplete
      0  343c					      db	29
      1  343c		       1d		      .byte.b	29
      0  343d					      dw	ekIpcrComplete
      1  343d		       44 34		      .word.w	ekIpcrComplete
    870  343f				   F2AZa1
      0  343f					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  343f					      db	33
      1  343f		       21		      .byte.b	33
      0  3440					      db	(UNKNOWNVEC-*)-1
      1  3440		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  3441					      TSTB	UNKNOWNVEC,oRightBracket
      0  3441					      db	101
      1  3441		       65		      .byte.b	101
      0  3442					      db	(UNKNOWNVEC-*)-1
      1  3442		       67		      .byte.b	(UNKNOWNVEC-*)-1
      0  3443					      db	oRightBracket
      1  3443		       e1		      .byte.b	oRightBracket
    873  3444
    874  3444				   ekIpcrComplete
      0  3444					      IPCIO		;Set the io bit and exit task till message
      0  3444					      db	83
      1  3444		       53		      .byte.b	83
      0  3445					      IPCRECEIVE		;Get the message
      0  3445					      db	81
      1  3445		       51		      .byte.b	81
      0  3446					      RTN
      0  3446					      db	25
      1  3446		       19		      .byte.b	25
    878  3447							;===============================================================================
    879  3447							; IPCC ---- check if a message is available
    880  3447				   ekIpcc
      0  3447					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3447					      db	101
      1  3447		       65		      .byte.b	101
      0  3448					      db	(UNKNOWNVEC-*)-1
      1  3448		       61		      .byte.b	(UNKNOWNVEC-*)-1
      0  3449					      db	oLeftBracket
      1  3449		       e0		      .byte.b	oLeftBracket
      0  344a					      TSTB	UNKNOWNVEC,oRightBracket
      0  344a					      db	101
      1  344a		       65		      .byte.b	101
      0  344b					      db	(UNKNOWNVEC-*)-1
      1  344b		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  344c					      db	oRightBracket
      1  344c		       e1		      .byte.b	oRightBracket
      0  344d					      IPCCHECK
      0  344d					      db	82
      1  344d		       52		      .byte.b	82
      0  344e					      RTN
      0  344e					      db	25
      1  344e		       19		      .byte.b	25
    885  344f
    886  344f				   UNKNOWNID
      0  344f					      IJMP	UNKNOWN
      0  344f					      db	29
      1  344f		       1d		      .byte.b	29
      0  3450					      dw	UNKNOWN
      1  3450		       15 33		      .word.w	UNKNOWN
    888  3452							;============================================================
    889  3452							; RND() is supposed to have an argument but if none
    890  3452							; was provided, just assume a large value.
    891  3452							;
    892  3452				   ekRnd
      0  3452					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3452					      db	101
      1  3452		       65		      .byte.b	101
      0  3453					      db	(UNKNOWNVEC-*)-1
      1  3453		       56		      .byte.b	(UNKNOWNVEC-*)-1
      0  3454					      db	oLeftBracket
      1  3454		       e0		      .byte.b	oLeftBracket
      0  3455					      TSTB	F2A1,oRightBracket
      0  3455					      db	101
      1  3455		       65		      .byte.b	101
      0  3456					      db	(F2A1-*)-1
      1  3456		       06		      .byte.b	(F2A1-*)-1
      0  3457					      db	oRightBracket
      1  3457		       e1		      .byte.b	oRightBracket
      0  3458					      LIT	32766
      0  3458					      db	27
      1  3458		       1b		      .byte.b	27
      0  3459					      dw	32766
      1  3459		       fe 7f		      .word.w	32766
      0  345b					      RANDOM
      0  345b					      db	37
      1  345b		       25		      .byte.b	37
      0  345c					      RTN
      0  345c					      db	25
      1  345c		       19		      .byte.b	25
    898  345d
    899  345d				   F2A1
      0  345d					      CALL	EXPR	;GET RANGE
      0  345d					      db	28
      1  345d		       1c		      .byte.b	28
      0  345e					      dw	EXPR
      1  345e		       19 33		      .word.w	EXPR
      0  3460					      TSTB	UNKNOWNVEC,oRightBracket
      0  3460					      db	101
      1  3460		       65		      .byte.b	101
      0  3461					      db	(UNKNOWNVEC-*)-1
      1  3461		       48		      .byte.b	(UNKNOWNVEC-*)-1
      0  3462					      db	oRightBracket
      1  3462		       e1		      .byte.b	oRightBracket
      0  3463					      RANDOM
      0  3463					      db	37
      1  3463		       25		      .byte.b	37
      0  3464					      RTN
      0  3464					      db	25
      1  3464		       19		      .byte.b	25
    904  3465							;==========================================================
    905  3465							;	Return absolute value of expresion
    906  3465							;
    907  3465				   ekAbs
      0  3465					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3465					      db	101
      1  3465		       65		      .byte.b	101
      0  3466					      db	(UNKNOWNVEC-*)-1
      1  3466		       43		      .byte.b	(UNKNOWNVEC-*)-1
      0  3467					      db	oLeftBracket
      1  3467		       e0		      .byte.b	oLeftBracket
      0  3468					      CALL	EXPR	;get value
      0  3468					      db	28
      1  3468		       1c		      .byte.b	28
      0  3469					      dw	EXPR
      1  3469		       19 33		      .word.w	EXPR
      0  346b					      TSTB	UNKNOWNVEC,oRightBracket
      0  346b					      db	101
      1  346b		       65		      .byte.b	101
      0  346c					      db	(UNKNOWNVEC-*)-1
      1  346c		       3d		      .byte.b	(UNKNOWNVEC-*)-1
      0  346d					      db	oRightBracket
      1  346d		       e1		      .byte.b	oRightBracket
      0  346e					      ABS
      0  346e					      db	38
      1  346e		       26		      .byte.b	38
      0  346f					      RTN
      0  346f					      db	25
      1  346f		       19		      .byte.b	25
    913  3470							;============================================================
    914  3470							;     Return the the status of a task, provide the PID
    915  3470							;
    916  3470				   ekStat
      0  3470					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3470					      db	101
      1  3470		       65		      .byte.b	101
      0  3471					      db	(UNKNOWNVEC-*)-1
      1  3471		       38		      .byte.b	(UNKNOWNVEC-*)-1
      0  3472					      db	oLeftBracket
      1  3472		       e0		      .byte.b	oLeftBracket
      0  3473					      Call	EXPR
      0  3473					      db	28
      1  3473		       1c		      .byte.b	28
      0  3474					      dw	EXPR
      1  3474		       19 33		      .word.w	EXPR
      0  3476					      TSTB	UNKNOWNVEC,oRightBracket
      0  3476					      db	101
      1  3476		       65		      .byte.b	101
      0  3477					      db	(UNKNOWNVEC-*)-1
      1  3477		       32		      .byte.b	(UNKNOWNVEC-*)-1
      0  3478					      db	oRightBracket
      1  3478		       e1		      .byte.b	oRightBracket
      0  3479					      TASKSTAT
      0  3479					      db	66
      1  3479		       42		      .byte.b	66
      0  347a					      RTN
      0  347a					      db	25
      1  347a		       19		      .byte.b	25
    922  347b							;==============================================================
    923  347b							; Return the current tasks pid
    924  347b							;
    925  347b				   ekPid
      0  347b					      TASKPID
      0  347b					      db	77
      1  347b		       4d		      .byte.b	77
      0  347c					      RTN
      0  347c					      db	25
      1  347c		       19		      .byte.b	25
    928  347d							;===========================================================================
    929  347d							; Call a machine function, provide the address to call and optionally
    930  347d							; the value to be passed in reg A
    931  347d				   ekCall
      0  347d					      TSTB	UNKNOWNVEC,oLeftBracket
      0  347d					      db	101
      1  347d		       65		      .byte.b	101
      0  347e					      db	(UNKNOWNVEC-*)-1
      1  347e		       2b		      .byte.b	(UNKNOWNVEC-*)-1
      0  347f					      db	oLeftBracket
      1  347f		       e0		      .byte.b	oLeftBracket
      0  3480					      CALL	EXPR
      0  3480					      db	28
      1  3480		       1c		      .byte.b	28
      0  3481					      dw	EXPR
      1  3481		       19 33		      .word.w	EXPR
      0  3483					      TSTB	F2B2A,oComma
      0  3483					      db	101
      1  3483		       65		      .byte.b	101
      0  3484					      db	(F2B2A-*)-1
      1  3484		       09		      .byte.b	(F2B2A-*)-1
      0  3485					      db	oComma
      1  3485		       e2		      .byte.b	oComma
      0  3486					      CALL	EXPR
      0  3486					      db	28
      1  3486		       1c		      .byte.b	28
      0  3487					      dw	EXPR
      1  3487		       19 33		      .word.w	EXPR
      0  3489					      TSTB	UNKNOWNVEC,oRightBracket
      0  3489					      db	101
      1  3489		       65		      .byte.b	101
      0  348a					      db	(UNKNOWNVEC-*)-1
      1  348a		       1f		      .byte.b	(UNKNOWNVEC-*)-1
      0  348b					      db	oRightBracket
      1  348b		       e1		      .byte.b	oRightBracket
      0  348c					      CALLFUNC
      0  348c					      db	53
      1  348c		       35		      .byte.b	53
      0  348d					      RTN
      0  348d					      db	25
      1  348d		       19		      .byte.b	25
    939  348e							; Run the gosub within this function
    940  348e				   F2B2A
      0  348e					      TSTB	UNKNOWNID,oRightBracket
      0  348e					      db	101
      1  348e		       65		      .byte.b	101
      0  348f					      db	(UNKNOWNID-*)-1
      1  348f		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  3490					      db	oRightBracket
      1  3490		       e1		      .byte.b	oRightBracket
      0  3491					      LIT	0	; No parameter passed so just load zero to A
      0  3491					      db	27
      1  3491		       1b		      .byte.b	27
      0  3492					      dw	0
      1  3492		       00 00		      .word.w	0
      0  3494					      CALLFUNC
      0  3494					      db	53
      1  3494		       35		      .byte.b	53
      0  3495					      RTN
      0  3495					      db	25
      1  3495		       19		      .byte.b	25
    945  3496
    946  3496
    947  3496							;=================================================================================
    948  3496							;Check for a number !
    949  3496							;
    950  3496				   FactNumber
      0  3496					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  3496					      db	35
      1  3496		       23		      .byte.b	35
      0  3497					      db	(FactVariable-*)-1
      1  3497		       0f		      .byte.b	(FactVariable-*)-1
      0  3498					      RTN
      0  3498					      db	25
      1  3498		       19		      .byte.b	25
    953  3499
    954  3499				   FactWithBracket
      0  3499					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  3499					      db	101
      1  3499		       65		      .byte.b	101
      0  349a					      db	(F2RTN-*)-1
      1  349a		       08		      .byte.b	(F2RTN-*)-1
      0  349b					      db	oLeftBracket
      1  349b		       e0		      .byte.b	oLeftBracket
      0  349c					      CALL	EXPR
      0  349c					      db	28
      1  349c		       1c		      .byte.b	28
      0  349d					      dw	EXPR
      1  349d		       19 33		      .word.w	EXPR
      0  349f					      TST	F2,oRightBracket
      0  349f					      db	32
      1  349f		       20		      .byte.b	32
      0  34a0					      db	(F2-*)-1
      1  34a0		       03		      .byte.b	(F2-*)-1
      0  34a1					      db	oRightBracket,0
      1  34a1		       e1 00		      .byte.b	oRightBracket,0
    958  34a3				   F2RTN
      0  34a3					      RTN
      0  34a3					      db	25
      1  34a3		       19		      .byte.b	25
    960  34a4
    961  34a4				   F2
      0  34a4					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  34a4					      db	13
      1  34a4		       0d		      .byte.b	13
      0  34a5					      dw	ERR_SYNTAX
      1  34a5		       05 00		      .word.w	ERR_SYNTAX
    963  34a7							;
    964  34a7							;=============================================================================
    965  34a7							; See if this is just a simple variable
    966  34a7							;  Allow a subscript for any variable
    967  34a7							;
    968  34a7				   FactVariable
    969  34a7
      0  34a7					      SETR2	tInteger
      0  34a7					      db	94
      1  34a7		       5e		      .byte.b	94
      0  34a8					      db	tInteger
      1  34a8		       a4		      .byte.b	tInteger
      0  34a9					      TSTV	FactWithBracket
      0  34a9					      db	33
      1  34a9		       21		      .byte.b	33
      0  34aa					      db	(FactWithBracket-*)-1
      1  34aa		       ee		      .byte.b	(FactWithBracket-*)-1
      0  34ab					      TSTBYTE	FactFNParm,R2,GOSUB_RTN_VALUE
      0  34ab					      db	97
      1  34ab		       61		      .byte.b	97
      0  34ac					      db	(FactFNParm-*)-1
      1  34ac		       0a		      .byte.b	(FactFNParm-*)-1
      0  34ad					      dw	R2
      1  34ad		       58 00		      .word.w	R2
      0  34af					      db	GOSUB_RTN_VALUE
      1  34af		       81		      .byte.b	GOSUB_RTN_VALUE
      0  34b0					      CALL	FactVarPTR
      0  34b0					      db	28
      1  34b0		       1c		      .byte.b	28
      0  34b1					      dw	FactVarPTR
      1  34b1		       c6 34		      .word.w	FactVarPTR
      0  34b3					      CALL	FactVariableValue
      0  34b3					      db	28
      1  34b3		       1c		      .byte.b	28
      0  34b4					      dw	FactVariableValue
      1  34b4		       ef 34		      .word.w	FactVariableValue
      0  34b6					      RTN
      0  34b6					      db	25
      1  34b6		       19		      .byte.b	25
    976  34b7
    977  34b7				   FactFNParm
      0  34b7					      TSTB	FactExpectedOpeningBracket,oLeftSQBracket
      0  34b7					      db	101
      1  34b7		       65		      .byte.b	101
      0  34b8					      db	(FactExpectedOpeningBracket-*)-1
      1  34b8		       3b		      .byte.b	(FactExpectedOpeningBracket-*)-1
      0  34b9					      db	oLeftSQBracket
      1  34b9		       e4		      .byte.b	oLeftSQBracket
      0  34ba					      CALL	EXPR
      0  34ba					      db	28
      1  34ba		       1c		      .byte.b	28
      0  34bb					      dw	EXPR
      1  34bb		       19 33		      .word.w	EXPR
      0  34bd					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  34bd					      db	101
      1  34bd		       65		      .byte.b	101
      0  34be					      db	(FactMissingRightBracket-*)-1
      1  34be		       32		      .byte.b	(FactMissingRightBracket-*)-1
      0  34bf					      db	oRightSQBracket
      1  34bf		       e5		      .byte.b	oRightSQBracket
      0  34c0					      SUBSCRIPT	GOSUB_RTN_VALUE
      0  34c0					      db	64
      1  34c0		       40		      .byte.b	64
      0  34c1					      db	GOSUB_RTN_VALUE
      1  34c1		       81		      .byte.b	GOSUB_RTN_VALUE
      0  34c2					      SETR2	tInteger
      0  34c2					      db	94
      1  34c2		       5e		      .byte.b	94
      0  34c3					      db	tInteger
      1  34c3		       a4		      .byte.b	tInteger
      0  34c4					      IND
      0  34c4					      db	20
      1  34c4		       14		      .byte.b	20
      0  34c5					      RTN
      0  34c5					      db	25
      1  34c5		       19		      .byte.b	25
    985  34c6
    986  34c6				   FactVarPTR
    987  34c6				   FactVarPtrNoTst
      0  34c6					      TSTB	F2CLocalTask,oBang
      0  34c6					      db	101
      1  34c6		       65		      .byte.b	101
      0  34c7					      db	(F2CLocalTask-*)-1
      1  34c7		       04		      .byte.b	(F2CLocalTask-*)-1
      0  34c8					      db	oBang
      1  34c8		       e8		      .byte.b	oBang
      0  34c9					      IND		; we just got a pid
      0  34c9					      db	20
      1  34c9		       14		      .byte.b	20
      0  34ca					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  34ca					      db	93
      1  34ca		       5d		      .byte.b	93
      0  34cb					      db	(UNKNOWNID-*)-1
      1  34cb		       83		      .byte.b	(UNKNOWNID-*)-1
    991  34cc
    992  34cc				   F2CLocalTask
      0  34cc					      SETR2	tInteger	; Sets the default type to integer
      0  34cc					      db	94
      1  34cc		       5e		      .byte.b	94
      0  34cd					      db	tInteger
      1  34cd		       a4		      .byte.b	tInteger
      0  34ce					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  34ce					      db	101
      1  34ce		       65		      .byte.b	101
      0  34cf					      db	(F2INTEGER-*)-1
      1  34cf		       11		      .byte.b	(F2INTEGER-*)-1
      0  34d0					      db	oDollar
      1  34d0		       e7		      .byte.b	oDollar
      0  34d1					      SETR2	tByte
      0  34d1					      db	94
      1  34d1		       5e		      .byte.b	94
      0  34d2					      db	tByte
      1  34d2		       a2		      .byte.b	tByte
      0  34d3					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  34d3					      db	101
      1  34d3		       65		      .byte.b	101
      0  34d4					      db	(F2PTRLOADED-*)-1
      1  34d4		       19		      .byte.b	(F2PTRLOADED-*)-1
      0  34d5					      db	oLeftSQBracket
      1  34d5		       e4		      .byte.b	oLeftSQBracket
      0  34d6					      CALL	EXPR
      0  34d6					      db	28
      1  34d6		       1c		      .byte.b	28
      0  34d7					      dw	EXPR
      1  34d7		       19 33		      .word.w	EXPR
      0  34d9					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  34d9					      db	101
      1  34d9		       65		      .byte.b	101
      0  34da					      db	(FactMissingRightBracket-*)-1
      1  34da		       16		      .byte.b	(FactMissingRightBracket-*)-1
      0  34db					      db	oRightSQBracket
      1  34db		       e5		      .byte.b	oRightSQBracket
      0  34dc					      SUBSCRIPT	tByte	; Byte type array
      0  34dc					      db	64
      1  34dc		       40		      .byte.b	64
      0  34dd					      db	tByte
      1  34dd		       a2		      .byte.b	tByte
      0  34de					      SETR2	tByte	; Set byte data type
      0  34de					      db	94
      1  34de		       5e		      .byte.b	94
      0  34df					      db	tByte
      1  34df		       a2		      .byte.b	tByte
      0  34e0					      RTN
      0  34e0					      db	25
      1  34e0		       19		      .byte.b	25
   1002  34e1
   1003  34e1				   F2INTEGER
      0  34e1					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  34e1					      db	101
      1  34e1		       65		      .byte.b	101
      0  34e2					      db	(F2PTRLOADED-*)-1
      1  34e2		       0b		      .byte.b	(F2PTRLOADED-*)-1
      0  34e3					      db	oLeftSQBracket
      1  34e3		       e4		      .byte.b	oLeftSQBracket
      0  34e4					      CALL	EXPR
      0  34e4					      db	28
      1  34e4		       1c		      .byte.b	28
      0  34e5					      dw	EXPR
      1  34e5		       19 33		      .word.w	EXPR
      0  34e7					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  34e7					      db	101
      1  34e7		       65		      .byte.b	101
      0  34e8					      db	(FactMissingRightBracket-*)-1
      1  34e8		       08		      .byte.b	(FactMissingRightBracket-*)-1
      0  34e9					      db	oRightSQBracket
      1  34e9		       e5		      .byte.b	oRightSQBracket
      0  34ea					      SUBSCRIPT	tInteger	; Integer type array
      0  34ea					      db	64
      1  34ea		       40		      .byte.b	64
      0  34eb					      db	tInteger
      1  34eb		       a4		      .byte.b	tInteger
      0  34ec					      SETR2	tInteger	; Set word datatype
      0  34ec					      db	94
      1  34ec		       5e		      .byte.b	94
      0  34ed					      db	tInteger
      1  34ed		       a4		      .byte.b	tInteger
   1009  34ee				   F2PTRLOADED
      0  34ee					      RTN
      0  34ee					      db	25
      1  34ee		       19		      .byte.b	25
   1011  34ef
   1012  34ef				   FactVariableValue
      0  34ef					      IND		; YES, GET THE VALUE as word
      0  34ef					      db	20
      1  34ef		       14		      .byte.b	20
      0  34f0					      RTN
      0  34f0					      db	25
      1  34f0		       19		      .byte.b	25
   1015  34f1
   1016  34f1				   FactMissingRightBracket
      0  34f1					      IJMP	ReturnExpectBracket
      0  34f1					      db	29
      1  34f1		       1d		      .byte.b	29
      0  34f2					      dw	ReturnExpectBracket
      1  34f2		       25 35		      .word.w	ReturnExpectBracket
   1018  34f4				   FactExpectedOpeningBracket
      0  34f4					      ERRMSG	ERR_EXPECTED_OPENING_BRACKET
      0  34f4					      db	13
      1  34f4		       0d		      .byte.b	13
      0  34f5					      dw	ERR_EXPECTED_OPENING_BRACKET
      1  34f5		       1a 00		      .word.w	ERR_EXPECTED_OPENING_BRACKET
   1020  34f7							;===============================================================================================================================
   1021  34f7							;========================= Gosub and function interface ========================================================================
   1022  34f7							; Process gosub no return value
   1023  34f7							;
   1024  34f7				   ekGosub
      0  34f7					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  34f7					      db	28
      1  34f7		       1c		      .byte.b	28
      0  34f8					      dw	GOSUBSTATEMENT
      1  34f8		       29 35		      .word.w	GOSUBSTATEMENT
      0  34fa					      DONE		; ERROR IF CR NOT NEXT
      0  34fa					      db	1
      1  34fa		       01		      .byte.b	1
      0  34fb					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  34fb					      db	8
      1  34fb		       08		      .byte.b	8
      0  34fc					      db	GOSUB_RTN
      1  34fc		       01		      .byte.b	GOSUB_RTN
      0  34fd					      FASTXFER		; AND JUMP to sub rtn
      0  34fd					      db	107
      1  34fd		       6b		      .byte.b	107
   1029  34fe							;
   1030  34fe							; End of gosub processing
   1031  34fe							;===========================================================================
   1032  34fe							; Same as gosub but expects a return value
   1033  34fe							;   FN 1000(parm1, ....)  Expects an integer to be returned
   1034  34fe							;
   1035  34fe				   ekGofn
      0  34fe					      Call	GOSUBSTATEMENT
      0  34fe					      db	28
      1  34fe		       1c		      .byte.b	28
      0  34ff					      dw	GOSUBSTATEMENT
      1  34ff		       29 35		      .word.w	GOSUBSTATEMENT
      0  3501					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  3501					      db	8
      1  3501		       08		      .byte.b	8
      0  3502					      db	GOSUB_RTN_VALUE
      1  3502		       81		      .byte.b	GOSUB_RTN_VALUE
      0  3503					      FASTXFER
      0  3503					      db	107
      1  3503		       6b		      .byte.b	107
   1039  3504
   1040  3504				   GOFNRet
      0  3504					      RTN
      0  3504					      db	25
      1  3504		       19		      .byte.b	25
   1042  3505							;===============================================================================================================================
   1043  3505							; Return from a gosub
   1044  3505							;
   1045  3505				   ekReturn
      0  3505					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  3505					      db	101
      1  3505		       65		      .byte.b	101
      0  3506					      db	(S2NoReturnValue-*)-1
      1  3506		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  3507					      db	oLeftBracket
      1  3507		       e0		      .byte.b	oLeftBracket
      0  3508					      CALL	EXPR
      0  3508					      db	28
      1  3508		       1c		      .byte.b	28
      0  3509					      dw	EXPR
      1  3509		       19 33		      .word.w	EXPR
      0  350b					      TSTB	ReturnExpectBracket,oRightBracket	; Now a value is on the stack
      0  350b					      db	101
      1  350b		       65		      .byte.b	101
      0  350c					      db	(ReturnExpectBracket-*)-1
      1  350c		       18		      .byte.b	(ReturnExpectBracket-*)-1
      0  350d					      db	oRightBracket
      1  350d		       e1		      .byte.b	oRightBracket
      0  350e					      DONE
      0  350e					      db	1
      1  350e		       01		      .byte.b	1
      0  350f					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  350f					      db	9
      1  350f		       09		      .byte.b	9
      0  3510					      db	(S2RetFunc-*)-1
      1  3510		       11		      .byte.b	(S2RetFunc-*)-1
      0  3511					      db	1
      1  3511		       01		      .byte.b	1
      0  3512					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3512					      db	6
      1  3512		       06		      .byte.b	6
      0  3513					      dw	CO
      1  3513		       fd 30		      .word.w	CO
      0  3515					      IJMP	STMT	; Process the new statement
      0  3515					      db	29
      1  3515		       1d		      .byte.b	29
      0  3516					      dw	STMT
      1  3516		       05 31		      .word.w	STMT
   1053  3518
   1054  3518				   S2NoReturnValue
      0  3518					      DONE
      0  3518					      db	1
      1  3518		       01		      .byte.b	1
      0  3519					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  3519					      db	9
      1  3519		       09		      .byte.b	9
      0  351a					      db	(S2RetFunc-*)-1
      1  351a		       07		      .byte.b	(S2RetFunc-*)-1
      0  351b					      db	0
      1  351b		       00		      .byte.b	0
      0  351c					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  351c					      db	6
      1  351c		       06		      .byte.b	6
      0  351d					      dw	CO
      1  351d		       fd 30		      .word.w	CO
      0  351f					      IJMP	STMT	; Process the new statement
      0  351f					      db	29
      1  351f		       1d		      .byte.b	29
      0  3520					      dw	STMT
      1  3520		       05 31		      .word.w	STMT
   1059  3522
   1060  3522				   S2RetFunc
      0  3522					      IJMP	GOFNRet	; Back into the Function
      0  3522					      db	29
      1  3522		       1d		      .byte.b	29
      0  3523					      dw	GOFNRet
      1  3523		       04 35		      .word.w	GOFNRet
   1062  3525
   1063  3525				   ReturnExpectBracket
      0  3525					      ENDIO
      0  3525					      db	71
      1  3525		       47		      .byte.b	71
      0  3526					      ERRMSG	ERR_CLOSINGBRACKET
      0  3526					      db	13
      1  3526		       0d		      .byte.b	13
      0  3527					      dw	ERR_CLOSINGBRACKET
      1  3527		       17 00		      .word.w	ERR_CLOSINGBRACKET
   1066  3529							;
   1067  3529							; End of return from gosub
   1068  3529							;=============================================================
   1069  3529							; Gosub can be both a Function and a Subroutine
   1070  3529				   GOSUBSTATEMENT
      0  3529					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  3529					      db	106
      1  3529		       6a		      .byte.b	106
      0  352a					      db	(GOSUBCOMPILED-*)-1
      1  352a		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  352b					      CALL	EXPR	; GET DESTINATION
      0  352b					      db	28
      1  352b		       1c		      .byte.b	28
      0  352c					      dw	EXPR
      1  352c		       19 33		      .word.w	EXPR
      0  352e					      CALL	GOSUBCONT
      0  352e					      db	28
      1  352e		       1c		      .byte.b	28
      0  352f					      dw	GOSUBCONT
      1  352f		       3c 35		      .word.w	GOSUBCONT
      0  3531					      lit	0	; mark as lookup on stack
      0  3531					      db	27
      1  3531		       1b		      .byte.b	27
      0  3532					      dw	0
      1  3532		       00 00		      .word.w	0
      0  3534					      RTN
      0  3534					      db	25
      1  3534		       19		      .byte.b	25
   1076  3535
   1077  3535				   GOSUBCOMPILED
      0  3535					      CALL	GOSUBCONT
      0  3535					      db	28
      1  3535		       1c		      .byte.b	28
      0  3536					      dw	GOSUBCONT
      1  3536		       3c 35		      .word.w	GOSUBCONT
      0  3538					      lit	1	;mark as compiled on stack
      0  3538					      db	27
      1  3538		       1b		      .byte.b	27
      0  3539					      dw	1
      1  3539		       01 00		      .word.w	1
      0  353b					      RTN
      0  353b					      db	25
      1  353b		       19		      .byte.b	25
   1081  353c
   1082  353c				   GOSUBCONT
      0  353c					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  353c					      db	101
      1  353c		       65		      .byte.b	101
      0  353d					      db	(GOSUBDONE-*)-1
      1  353d		       11		      .byte.b	(GOSUBDONE-*)-1
      0  353e					      db	oLeftBracket
      1  353e		       e0		      .byte.b	oLeftBracket
      0  353f					      STK2TMP		;Transfer stack top to temp
      0  353f					      db	95
      1  353f		       5f		      .byte.b	95
      0  3540					      PUSHMATHSTACK		;Record stack frame for return
      0  3540					      db	84
      1  3540		       54		      .byte.b	84
   1086  3541				   GOSUBLOOP
      0  3541					      CALL	EXPR	; Allows what ever fits onto stack
      0  3541					      db	28
      1  3541		       1c		      .byte.b	28
      0  3542					      dw	EXPR
      1  3542		       19 33		      .word.w	EXPR
      0  3544					      INCPARMCOUNT
      0  3544					      db	88
      1  3544		       58		      .byte.b	88
      0  3545					      TSTB	GOSUBParmDONE,oComma
      0  3545					      db	101
      1  3545		       65		      .byte.b	101
      0  3546					      db	(GOSUBParmDONE-*)-1
      1  3546		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  3547					      db	oComma
      1  3547		       e2		      .byte.b	oComma
      0  3548					      IJMP	GOSUBLOOP
      0  3548					      db	29
      1  3548		       1d		      .byte.b	29
      0  3549					      dw	GOSUBLOOP
      1  3549		       41 35		      .word.w	GOSUBLOOP
   1091  354b				   GOSUBParmDONE
      0  354b					      TSTB	ReturnExpectBracket,oRightBracket
      0  354b					      db	101
      1  354b		       65		      .byte.b	101
      0  354c					      db	(ReturnExpectBracket-*)-1
      1  354c		       d8		      .byte.b	(ReturnExpectBracket-*)-1
      0  354d					      db	oRightBracket
      1  354d		       e1		      .byte.b	oRightBracket
      0  354e					      TMP2STK		; Restore line to goto
      0  354e					      db	96
      1  354e		       60		      .byte.b	96
   1094  354f				   GOSUBDONE
      0  354f					      RTN
      0  354f					      db	25
      1  354f		       19		      .byte.b	25
   1096  3550
   1097  3550		       35 50	   ILEND      equ	*
------- FILE mytb.asm
   2482  3550		       35 50	   PROGEND    equ	*
   2483  3550
   2484  3550
   2485  3550							;=====================================================
   2486  3550							; Define start of non page zero data
   2487 U35a3					      seg.u	TBData
   2488 U35a3
   2489 U35a3							;=====================================================
   2490 U35a3							; These are storage items not in page zero.
   2491 U35a3							;==================================================================================================
   2492 U35a3							; Task Management information
   2493 U35a3							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2494 U35a3							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2495 U35a3							; Task switchs happen at the beginning of the next Basic command line
   2496 U35a3							; It will not happen during an input or output operations
   2497 U35a3							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2498 U35a3							; Task Zero is always the root task, main line program
   2499 U35a3							;
   2500 U35a3							; Layout is repeated for each configured task
   2501 U35a3							; Task Table Byte   use masks follow
   2502 U35a3		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2503 U35a3		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2504 U35a3		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2505 U35a3		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2506 U35a3		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2507 U35a3
   2508 U35a3		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2509 U35a4		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2510 U35a4		       36 9e	   TASKTABLEEND equ	*	; End of task table
   2511 U35a4		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2512 U369e
   2513 U369e							;Task Cycle Counter and reset count
   2514 U369e		       00 00	   taskCurrentCycles ds	2
   2515 U36a0		       00 00	   taskResetValue ds	2
   2516 U36a2		       00	   taskCounter ds	1	; Count of active tasks
   2517 U36a3
   2518 U36a3							;
   2519 U36a3							; Math stack and IL call and Gosub/For-next return stack definitions
   2520 U36a3							;
   2521 U36a3		       36 a3	   STACKSTART equ	*
   2522 U36a3		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2523 U3833		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2524 U3c1b		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2525 U3e9b		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code,taskio block stdin,stdout,stdstat,iostatus
   2526 U3e9b		       00 48	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2527 U3e9b		       41 7f	   STACKEND   equ	*
   2528 U3e9b		       0a dc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2529 U417f							;
   2530 U417f							;
   2531 U417f		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2532 U4203		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2533 U4204		       00	   printtx    ds	1	;temp X for print funcs
   2534 U4205		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2535 U4206		       00	   promptChar ds	1	;the character to use for a prompt
   2536 U4207		       00	   diddigit   ds	1	;for leading zero suppression
   2537 U4208		       00	   putsy      ds	1
   2538 U4209		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2539 U420b		       00	   sign       ds	1	;0 = positive, else negative
   2540 U420c		       00 00	   rtemp1     ds	2	;Temp for x and y
   2541 U420e		       00 00	   random     ds	2
   2542 U4210		       00	   tempy      ds	1	;temp y storage
   2543 U4211
   2544 U4211
   2545 U4211							; Moved from page zero as one clock cycle diff gives more space on page zero
   2546 U4211		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2547 U4213		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2548 U4214		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2549 U4215		       00	   lineLength ds	1	;Length of current line
   2550 U4216
   2551 U4216		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2552 U4217		       00	   taskRDPending ds	1	; 1 = background read is pending
   2553 U4218
   2554 U4218				  -	      if	XKIM
   2555 U4218				  -buffer     ds	BUFFER_SIZE
   2556 U4218					      endif
   2557 U4218							;
   2558 U4218							; PROGRAMEND is the end of the user's BASIC program.
   2559 U4218							; More precisely, it is one byte past the end.  Or,
   2560 U4218							; it's where the next line added to the end will be
   2561 U4218							; placed.
   2562 U4218							;
   2563 U4218		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2564 U421a		       00 00	   ProgramEnd ds	2	; End of users basic program, Next free byte after end
   2565 U421c		       00 00	   HighMem    ds	2	; highest location
   2566 U421e		       00 00	   UsedMem    ds	2	; size of user program
   2567 U4220		       00 00	   FreeMem    ds	2	; amount of free memory
   2568 U4222							;
   2569 U4222							;=====================================================
   2570 U4222							; This is the start of the user's BASIC program space.
   2571 U4222							;
   2572 U4222							; PERSONAL GOAL: This should be no larger than $0DFF.
   2573 U4222							;		  0200-05FF = 1K
   2574 U4222							;		  0200-09FF = 2K
   2575 U4222							;		  0200-0DFF = 3K
   2576 U4222							;		  0200-11FF = 4K
   2577 U4222							;		  0200-13FF = 4.5K
   2578 U4222							;
   2579 U4222				  -	      if	FIXED
   2580 U4222				  -	      org	$2000
   2581 U4222					      endif
   2582 U4222
   2583 U4222		       42 22	   FreeMemStart equ	*
   2584 U4222							;/*
   2585 U4222							;  if	  CTMON65 || XKIM
   2586 U4222							;	  SEG Code
   2587 U4222							;	  org	  AutoRun
   2588 U4222							;	  dw	  TBasicCold
   2589 U4222							;  endif
   2590 U4222							;*/
   2591 U4222					      end
