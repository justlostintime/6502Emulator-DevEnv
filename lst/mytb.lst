------- FILE mytb.asm LEVEL 1 PASS 6
      1 U428d				   input      processor	6502
      2 U428d ????						;=====================================================
      3 U428d ????						; Concurrent Tiny Basic, no longer Tiny
      4 U428d ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U428d ????						; Free Time. Now abiut 6K Full OS features.
      6 U428d ????						;
      7 U428d ????						; While working on the Corsham Technologies KIM Clone
      8 U428d ????						; project, I wanted to include a TINY BASIC since that
      9 U428d ????						; was a highly desirable feature of early computers.
     10 U428d ????						;
     11 U428d ????						; Rather than negotiating copyright issues for
     12 U428d ????						; existing BASICs, I decided to just write one from
     13 U428d ????						; scratch.
     14 U428d ????						;
     15 U428d ????						; 10/07/2017
     16 U428d ????						;
     17 U428d ????						; This implements a stripped down Tiny BASIC
     18 U428d ????						; interpreter using the Interpretive Language (IL)
     19 U428d ????						; method as described in the first few issues of
     20 U428d ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U428d ????						; to write various languages simply by changing the
     22 U428d ????						; IL code rather than the interpreter itself.
     23 U428d ????						;
     24 U428d ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U428d ????						;		* Fixed major bug in findLine that
     26 U428d ????						;		  caused corrupted lines, crashes, etc.
     27 U428d ????						;		* If no parameter given to RND, assume
     28 U428d ????						;		  32766.
     29 U428d ????						;		* No more error 5 when a program
     30 U428d ????						;		  reaches the end without an END.
     31 U428d ????						;
     32 U428d ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U428d ????						;		 * Unexpanded version to play with everything
     34 U428d ????						;		 * Add some usefull system level functions
     35 U428d ????						;		 * allow a larger number of tiny basic formats
     36 U428d ????						;		 * Add byte at start of line holding length
     37 U428d ????						;		   for faster execution of goto and gosub
     38 U428d ????						;		 * Re-added gosub
     39 U428d ????						;		 * allow ; or , at end if print stmt
     40 U428d ????						;		   without CRLF being added.
     41 U428d ????						;		 * Added extended function erase to
     42 U428d ????						;		   use the extended ctmon65 rm file
     43 U428d ????						;		 * Fix quoted text to not have to backtrack
     44 U428d ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U428d ????						;		 * Add concurrency features
     46 U428d ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U428d ????						;
     48 U428d ????						; www.corshamtech.com
     49 U428d ????						; bob@corshamtech.com
     50 U428d ????						; JustLostInTime@gmail.com
     51 U428d ????						;
     52 U428d ????						;=====================================================
     53 U428d ????						;
     54 U428d ????						; Create TRUE and FALSE values for conditionals.
     55 U428d ????						;
     56 U428d ????
     57 U428d ????	       00 00	   FALSE      equ	0
     58 U428d ????	       ff ff ff ff TRUE       equ	~FALSE
     59 U428d ????						;
     60 U428d ????						;---------------------------------------------------------
     61 U428d ????						; One of these must be set to indicate which environment
     62 U428d ????						; Tiny BASIC will be running in.  Here are the current
     63 U428d ????						; environments:
     64 U428d ????						;
     65 U428d ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     66 U428d ????						; more K of RAM.
     67 U428d ????						;
     68 U428d ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     69 U428d ????						; which enhances, without replacing, the standard KIM
     70 U428d ????						; monitor.  It gives access to routines to save/load files
     71 U428d ????						; to a micro SD card.
     72 U428d ????						;
     73 U428d ????						; CTMON65 is a from-scratch monitor written for the
     74 U428d ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     75 U428d ????						; easily be ported to other systems.  It has support for
     76 U428d ????						; using a micro SD card for file storage/retrieval.
     77 U428d ????						;
     78 U428d ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     79 U428d ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     80 U428d ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     81 U428d ????	       ff ff ff ff IL_DEBUG_TEXT equ	TRUE	;Print out as text IL instructions
     82 U428d ????						;
     83 U428d ????						;   Need to define some macros for the dasm assembler
     84 U428d ????						;
     85 U428d ????				      MACRO	dw
     86 U428d ????				      .word	{0}
     87 U428d ????				      ENDM
     88 U428d ????
     89 U428d ????				      MACRO	db
     90 U428d ????				      .byte	{0}
     91 U428d ????				      ENDM
     92 U428d ????
     93 U428d ????						;
     94 U428d ????						; If set, include disk functions.
     95 U428d ????						;
     96 U428d ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U428d ????						;
     98 U428d ????						; If ILTRACE is set then dump out the address of every
     99 U428d ????						; IL opcode before executing it.
    100 U428d ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U428d ????						;
    102 U428d ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U428d ????						;
    104 U428d ????						; If FIXED is set, put the IL code and the user
    105 U428d ????						; program space at fixed locations in memory.	This is
    106 U428d ????						; meant only for debugging.
    107 U428d ????						;
    108 U428d ????	       00 00	   FIXED      equ	FALSE
    109 U428d ????
    110 U428d ????	       00 0f	   terminalIOblockLen equ	[TerminalIOblockEnd - TerminalIOblock]
    111 U428d ????
    112 U428d ????						;
    113 U428d ????						; Sets the arithmetic stack depth.  This is *TINY*
    114 U428d ????						; BASIC, so keep this small!
    115 U428d ????						;
    116 U428d ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    117 U428d ????	       00 32	   ILSTACKSIZE equ	50	;number of entries in ilstack
    118 U428d ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    119 U428d ????	       00 25	   VARIABLESSIZE equ	37	;26 variables + 1 for exit code + 10 entries (20bytes) for ioblock
    120 U428d ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    121 U428d ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    122 U428d ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    123 U428d ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    124 U428d ????
    125 U428d ????	       00 36	   taskSTDIN  equ	[[VARIABLESSIZE - 10]*2]	;io vector
    126 U428d ????	       00 38	   taskSTDOUT equ	[[[VARIABLESSIZE - 10]*2]+2]	;io vector
    127 U428d ????
    128 U428d ????	       00 3f	   taskIOinPort equ	[[[VARIABLESSIZE - 10]*2]+4+5]	;Offset into the ioblock
    129 U428d ????	       00 3b	   taskIOoutPort equ	[[[VARIABLESSIZE - 10]*2]+4+1]	;Offset into the ioblock
    130 U428d ????	       00 46	   taskIOstatusPort equ	[[[VARIABLESSIZE - 10]*2]+4+12]	;Offset into the ioblock
    131 U428d ????						;
    132 U428d ????						; Gosub entry types
    133 U428d ????
    134 U428d ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    135 U428d ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    136 U428d ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    137 U428d ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    138 U428d ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    139 U428d ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    140 U428d ????						; 0 byte is the original stack offset, byte 1 is the parameter count
    141 U428d ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    142 U428d ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    143 U428d ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    144 U428d ????						;
    145 U428d ????						; Common ASCII constants
    146 U428d ????						;
    147 U428d ????	       00 07	   BEL	      equ	$07
    148 U428d ????	       00 08	   BS	      equ	$08
    149 U428d ????	       00 09	   TAB	      equ	$09
    150 U428d ????	       00 0a	   LF	      equ	$0A
    151 U428d ????	       00 0d	   CR	      equ	$0D
    152 U428d ????	       00 22	   quote      equ	$22
    153 U428d ????	       00 20	   SPACE      equ	$20
    154 U428d ????	       00 2c	   COMMA      equ	',
    155 U428d ????	       00 3b	   SEMICOLON  equ	';
    156 U428d ????	       00 3a	   COLON      equ	':
    157 U428d ????	       00 24	   DOLLAR     equ	'$
    158 U428d ????						;
    159 U428d ????						; These are error codes
    160 U428d ????						;
    161 U428d ????	       00 00	   ERR_NONE   equ	0	;No Errror
    162 U428d ????	       00 01	   ERR_EXPR   equ	1	;expression error
    163 U428d ????	       00 02	   ERR_UNDER  equ	2	;The Math stack underflow
    164 U428d ????	       00 03	   ERR_OVER   equ	3	;The Math stack overflow
    165 U428d ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    166 U428d ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    167 U428d ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    168 U428d ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    169 U428d ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    170 U428d ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    171 U428d ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    172 U428d ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    173 U428d ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;the gosub Stack overflow
    174 U428d ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    175 U428d ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    176 U428d ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    177 U428d ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    178 U428d ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    179 U428d ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    180 U428d ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    181 U428d ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    182 U428d ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    183 U428d ????	       00 16	   ERR_EXPECTVAR equ	22	;Expected a variable name or definition
    184 U428d ????	       00 17	   ERR_CLOSINGBRACKET equ	23	;Expected a closing bracket
    185 U428d ????	       00 18	   ERR_MISSINGEQUALSIGN equ	24	;Expected an equal sign for assignment
    186 U428d ????	       00 19	   ERR_FUNCTION_EXPECTED_PARAMETERS equ	25	;Function expected parameters
    187 U428d ????	       00 1a	   ERR_EXPECTED_OPENING_BRACKET equ	26	;Expected opening bracket [ or (
    188 U428d ????						;
    189 U428d ????						;=====================================================
    190 U428d ????						; Zero page storage.
    191 U428d ????						;
    192 U00f6 ????				      SEG.U	ZEROPAGE
    193 U0040					      org	$0040
    194 U0040
    195 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    196 U0041
    197 U0041							; The context is used to locate a task switch
    198 U0041							; it copies from here till all task fields are saved/swapped
    199 U0041							; The max number of tasks is 256 / context length
    200 U0041							; All positions POS values are plus one task table incldues
    201 U0041							; a leading status byte .
    202 U0041							;
    203 U0041		       00 41	   CONTEXT    equ	*
    204 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    205 U0041
    206 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    207 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    208 U0043
    209 U0043		       00 00	   ILPC       ds	2	; IL program counter
    210 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    211 U0047		       00	   ILSTACKPTR ds	1
    212 U0048
    213 U0048
    214 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    215 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    216 U004a
    217 U004a
    218 U004a		       00	   MATHSTACKPTR ds	1
    219 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    220 U004b
    221 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    222 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT + 1	; Get the offset to the gosub/msg stack
    223 U004d
    224 U004d
    225 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    226 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    227 U004e
    228 U004e
    229 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    230 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    231 U004f							;
    232 U004f							; CURPTR is a pointer to curent BASIC line being
    233 U004f							; executed.  Always points to start of line, CUROFF
    234 U004f							; is the offset to the current character.
    235 U004f							; The order of these fields is important
    236 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    237 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    238 U0052							;
    239 U0052							;The order of these fields in important
    240 U0052
    241 U0052							;
    242 U0052							; R0, R1 and MQ are used for arithmetic operations and
    243 U0052							; general use.
    244 U0052							;
    245 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    246 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    247 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    248 U0056		       00 00	   MQ	      ds	2	;used for some math
    249 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    250 U0058		       00 59	   REGISTERSEND equ	*
    251 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    252 U0059
    253 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    254 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    255 U0059
    256 U0059		       00 00	   dpl	      ds	2	; Used as a pointer to call il instructions
    257 U005b							;
    258 U005b							; This is zero if in immediate mode, or non-zero
    259 U005b							; if currently running a program.  Any input from
    260 U005b							; the main loop clears this, and the XFER IL
    261 U005b							; statement will set it.
    262 U005b							;
    263 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    264 U005c							;
    265 U005c							; Used for line insertion/removal.
    266 U005c							;
    267 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    268 U005e
    269 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    270 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    271 U005e							;
    272 U005e		       00 00	   PrtFrom    ds	2	; FROM
    273 U0060
    274 U0060							;
    275 U0060							;=====================================================
    276 U0060							;
    277  35bb ????				      SEG	Code
    278  0200					      org	$0200
    279  0200							;
    280  0200							; Cold start is at $0200.  Warm start is at $0203.
    281  0200							;
    282  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    283  0203		       4c 82 02    warm       jmp	warm2	;Entry point for worm restart
    284  0206							;
    285  0206							; These are the user-supplied vectors to I/O routines.
    286  0206							; If you want, you can just patch these in the binary
    287  0206							; file, but it would be better to change the source
    288  0206							; code.
    289  0206							;
    290  0206				  -	      if	KIM
    291  0206				  -OUTCH      jmp	$1ea0	;output char in A
    292  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    293  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    294  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    295  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    296  0206					      endif
    297  0206				  -	      if	XKIM
    298  0206				  -	      include	"xkim.inc"
    299  0206				  -	      SEG	Code
    300  0206				  -OUTCH      jmp	$1ea0
    301  0206				  -GETCH      jmp	xkGETCH
    302  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    303  0206				  -OUTHEX     jmp	xkPRTBYT
    304  0206				  -MONITOR    jmp	extKIM
    305  0206				  -puts       equ	putsil
    306  0206				  -BUFFER_SIZE equ	132
    307  0206					      endif
    308  0206
    309  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0060					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    311 Udf8e
    312  0206					      SEG	Code
    313  0206							;
    314  0206		       f0 0c	   OUTCH      equ	cout
    315  0206		       f0 09	   GETCH      equ	cin
    316  0206		       2c f4	   CRLF       equ	tbcrlf
    317  0206		       21 15	   OUTHEX     equ	HexToOut
    318  0206		       f0 03	   MONITOR    equ	WARM
    319  0206		       f0 0f	   ISCHAR     equ	cstatus
    320  0206		       21 32	   puts       equ	tbputs
    321  0206					      endif
    322  0206							;
    323  0206		       20 3b 2e    cold2      jsr	SetOutConsole
    324  0209		       20 48 2e 	      jsr	SetInConsole
    325  020c		       20 32 21 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      0  0241					      db	CR,LF,0
      1  0241		       0d 0a 00 	      .byte.b	CR,LF,0
    329  0244							;
    330  0244		       20 26 23 	      jsr	MemInit	;setup the free space available
    331  0247
    332  0247		       a9 01	   calcstack  lda	#1
    333  0249		       8d 0d 37 	      sta	taskCounter	; Initialize number of tasks to 1
    334  024c		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    335  024e		       8d 0f 36 	      sta	taskTable	; mark the main task as active
    336  0251		       20 73 25 	      jsr	taskSetStacks	; setup all the task stacks/Variables, Init task io block
    337  0254		       a9 70		      lda	#IL&$ff
    338  0256		       85 43		      sta	ILPC
    339  0258		       a9 31		      lda	#IL>>8
    340  025a		       85 44		      sta	ILPC+1
    341  025c							;
    342  025c							;		  lda	  ProgramStart		     ; user prog
    343  025c							;		  sta	  ProgramEnd
    344  025c							;		  lda	  ProgramStart+1
    345  025c							;		  sta	  ProgramEnd+1
    346  025c							;
    347  025c
    348  025c							;  Init time slices defaults
    349  025c		       a9 02		      lda	#TASKCYCLESHIGH
    350  025e		       8d 0c 37 	      sta	taskResetValue+1
    351  0261		       a9 ff		      lda	#TASKCYCLESDEFAULT
    352  0263		       8d 0b 37 	      sta	taskResetValue
    353  0266							;
    354  0266							; Initialize the pseudo-random number sequence...
    355  0266							;
    356  0266		       a9 5a		      lda	#$5a
    357  0268		       8d 77 42 	      sta	rtemp1
    358  026b		       a9 9d		      lda	#%10011101
    359  026d		       8d 79 42 	      sta	random
    360  0270		       a9 5b		      lda	#%01011011
    361  0272		       8d 7a 42 	      sta	random+1
    362  0275							;
    363  0275							;   Insert a Basic irq handler for the basic Language
    364  0275		       a9 d1		      lda	#ServiceIrq&$ff
    365  0277		       8d 00 df 	      sta	IRQvec
    366  027a		       a9 19		      lda	#ServiceIrq>>8
    367  027c		       8d 01 df 	      sta	IRQvec+1
    368  027f		       4c 95 02 	      jmp	coldtwo
    369  0282
    370  0282							;
    371  0282							;
    372  0282							; This is the warm start entry point
    373  0282							;
    374  0282		       20 3b 2e    warm2      jsr	SetOutConsole
    375  0285		       20 48 2e 	      jsr	SetInConsole
    376  0288		       20 f4 2c 	      jsr	CRLF
    377  028b		       ad 74 42 	      lda	errGoto
    378  028e		       85 43		      sta	ILPC
    379  0290		       ad 75 42 	      lda	errGoto+1
    380  0293		       85 44		      sta	ILPC+1
    381  0295							;
    382  0295							; And continue with both starts here
    383  0295							;
    384  0295				   coldtwo
    385  0295							;
    386  0295							; The ILTrace flag is now run-time settable.
    387  0295							;
    388  0295		       a9 00		      lda	#ILTRACE&$ff
    389  0297		       85 40		      sta	ILTrace
    390  0299							;
    391  0299
    392  0299		       a9 00		      lda	#0
    393  029b		       85 5b		      sta	RunMode
    394  029d		       8d ea 41 	      sta	LINBUF
    395  02a0
    396  02a0							; Clear everything from the stacks
    397  02a0
    398  02a0		       8d 81 42 	      sta	taskIOPending	; No one waiting for io
    399  02a3		       8d 82 42 	      sta	taskRDPending	; No one waiting for bg io
    400  02a6
    401  02a6		       20 ef 25 	      jsr	taskReset
    402  02a9							;
    403  02a9		       a9 ea		      lda	#LINBUF&$ff
    404  02ab		       85 4f		      sta	CURPTR
    405  02ad		       a9 41		      lda	#LINBUF>>8
    406  02af		       85 50		      sta	CURPTR+1	;fall through...
    407  02b1
    408  02b1							;=====================================================
    409  02b1							; This is the top of the IL interpreter.  This fetches
    410  02b1							; and executes the instruction currently pointed to
    411  02b1							; by ILPC and adjusts ILPC to point to the next
    412  02b1							; instruction to execute.
    413  02b1							;
    414  02b1				   NextIL
    415  02b1		       ba		      tsx		; Get the stack pointer value
    416  02b2		       e0 ff		      cpx	#$FF	; Should be empty
    417  02b4		       d0 29		      bne	ILbad	; Halt and catch fire now!
    418  02b6
    419  02b6		       ce 09 37 	      dec	taskCurrentCycles
    420  02b9		       d0 03		      bne	NextIlNow
    421  02bb		       20 18 26 	      jsr	iTaskSwitch	;check for a task switch
    422  02be		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    423  02c0		       f0 03		      beq	NextIL2	;Skip if no bits set
    424  02c2
    425  02c2		       20 85 2d 	      jsr	dbgLine	;Print the IL trace information
    426  02c5
    427  02c5		       a4 51	   NextIL2    ldy	CUROFF
    428  02c7							;		  jsr	  SkipSpaces	       ; no longer needed as tokenizer takes care of this
    429  02c7							;		  sty	  CUROFF
    430  02c7							;Task IO Management
    431  02c7		       ad 82 42 	      lda	taskRDPending	; if it is zero then Nothing pending
    432  02ca		       f0 08		      beq	NextILStr
    433  02cc		       20 2d 2b 	      jsr	ReadLine	; else Pending and poll keyboard
    434  02cf		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    435  02d1		       ce 82 42 	      dec	taskRDPending	; Carry is set if CR has been recieved
    436  02d4							;
    437  02d4		       20 b0 29    NextILStr  jsr	getILByte
    438  02d7							;
    439  02d7							; When the handler is called, these are the conditions
    440  02d7							; of several important items:
    441  02d7							;
    442  02d7							;    (ILPC) will point to the byte AFTER the IL
    443  02d7							;    opcode being executed.
    444  02d7							;
    445  02d7							;    (CURPTR),CUROFF will point to the start of the
    446  02d7							;    next word in the input buffer.  Ie, the next word
    447  02d7							;    in the user program.
    448  02d7							;
    449  02d7		       18		      clc		; Clear carry before shift
    450  02d8		       0a		      asl		; valid for 0-127
    451  02d9		       b0 04		      bcs	ILbad	; Out of range
    452  02db		       aa		      tax		; Move value to x
      0  02dc					      db	$7c	; jmp (ILTBL,X) ; dasm does not support 65c02 inst
      1  02dc		       7c		      .byte.b	$7c
      0  02dd					      dw	ILTBL	; Actual IL table address
      1  02dd		       20 03		      .word.w	ILTBL
    455  02df
    456  02df							;		asl
    457  02df							;		cmp	#ILTBLend-ILTBL+2
    458  02df							;		bcc	ILgood
    459  02df							;
    460  02df							; This handles an illegal IL opcode.  This is serious
    461  02df							; and there's no way to recover.
    462  02df							;
    463  02df				   iBadOP
    464  02df		       20 32 21    ILbad      jsr	puts
      0  02e2					      db	CR,LF
      1  02e2		       0d 0a		      .byte.b	CR,LF
      0  02e4					      db	"Illegal IL "
      1  02e4		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02ef					      db	0
      1  02ef		       00		      .byte.b	0
    468  02f0							;
    469  02f0							; Well this is awkward, we need to back up the IL
    470  02f0							; by one since it no longer points to the current
    471  02f0							; opcode.
    472  02f0							;
    473  02f0		       20 bd 29 	      jsr	decIL
    474  02f3							;
    475  02f3		       a0 00		      ldy	#0
    476  02f5		       b1 43		      lda	(ILPC),y
    477  02f7		       20 15 21 	      jsr	OUTHEX
    478  02fa		       20 32 21 	      jsr	puts
      0  02fd					      db	" at ",0
      1  02fd		       20 61 74 20*	      .byte.b	" at ",0
    480  0302		       a5 44		      lda	ILPC+1
    481  0304		       20 15 21 	      jsr	OUTHEX
    482  0307		       a5 43		      lda	ILPC
    483  0309		       20 15 21 	      jsr	OUTHEX
    484  030c		       20 f4 2c 	      jsr	CRLF
    485  030f		       4c 03 f0 	      jmp	MONITOR
    486  0312							;
    487  0312							; Just jump to the address (ILPC),y.  Have to do
    488  0312							; some goofy stuff.
    489  0312							;
    490  0312		       a8	   ILgood     tay		;move index into Y
    491  0313		       b9 20 03 	      lda	ILTBL,y
    492  0316		       85 59		      sta	dpl
    493  0318		       b9 21 03 	      lda	ILTBL+1,y
    494  031b		       85 5a		      sta	dpl+1
    495  031d		       6c 59 00 	      jmp	(dpl)	;go to handler
    496  0320							;
    497  0320							;=====================================================
    498  0320							; This is the IL jump table.  The IL opcode is
    499  0320							; mulitplied by two, then looked-up in this table.
    500  0320							; There is absolutely nothing special about the order
    501  0320							; of entries here... they all decode at exactly the
    502  0320							; same speed.	However the entry number must match the
    503  0320							; values in IL.inc.
    504  0320							;
    505  0320				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0320					      include	"ilvectortable.asm"
      1  0320					      seg	Code
      2  0320				   ILTBL1
      0  0320					      dw	iXINIT	;0
      1  0320		       58 04		      .word.w	iXINIT
      0  0322					      dw	iDONE	;1
      1  0322		       75 04		      .word.w	iDONE
      0  0324					      dw	iPRS	;2
      1  0324		       8c 04		      .word.w	iPRS
      0  0326					      dw	iPRN	;3
      1  0326		       94 04		      .word.w	iPRN
      0  0328					      dw	iSPC	;4
      1  0328		       9d 04		      .word.w	iSPC
      0  032a					      dw	iNLINE	;5
      1  032a		       3b 09		      .word.w	iNLINE
      0  032c					      dw	iNXT	;6
      1  032c		       a5 04		      .word.w	iNXT
      0  032e					      dw	iXFER	;7
      1  032e		       e7 04		      .word.w	iXFER
      0  0330					      dw	iSAV	;8
      1  0330		       05 05		      .word.w	iSAV
      0  0332					      dw	iRSTR	;9
      1  0332		       ee 24		      .word.w	iRSTR
      0  0334					      dw	iCMPR	;10
      1  0334		       4b 05		      .word.w	iCMPR
      0  0336					      dw	iINNUM	;11
      1  0336		       ca 05		      .word.w	iINNUM
      0  0338					      dw	iFIN	;12
      1  0338		       02 06		      .word.w	iFIN
      0  033a					      dw	iERR	;13
      1  033a		       16 06		      .word.w	iERR
      0  033c					      dw	iADD	;14
      1  033c		       98 06		      .word.w	iADD
      0  033e					      dw	iSUB	;15
      1  033e		       ae 06		      .word.w	iSUB
      0  0340					      dw	iNEG	;16
      1  0340		       c4 06		      .word.w	iNEG
      0  0342					      dw	iMUL	;17
      1  0342		       dc 06		      .word.w	iMUL
      0  0344					      dw	iDIV	;18
      1  0344		       1c 07		      .word.w	iDIV
      0  0346					      dw	iSTORE	;19
      1  0346		       72 07		      .word.w	iSTORE
      0  0348					      dw	iIND	;20
      1  0348		       90 07		      .word.w	iIND
      0  034a					      dw	iLST	;21
      1  034a		       31 08		      .word.w	iLST
      0  034c					      dw	iINIT	;22
      1  034c		       20 04		      .word.w	iINIT
      0  034e					      dw	iGETLINE	;23
      1  034e		       67 08		      .word.w	iGETLINE
      0  0350					      dw	iINSRT	;24
      1  0350		       84 08		      .word.w	iINSRT
      0  0352					      dw	iRTN	;25
      1  0352		       35 09		      .word.w	iRTN
      0  0354					      dw	MONITOR	;26
      1  0354		       03 f0		      .word.w	MONITOR
      0  0356					      dw	iLIT	;27
      1  0356		       5f 09		      .word.w	iLIT
      0  0358					      dw	iCALL	;28
      1  0358		       41 09		      .word.w	iCALL
      0  035a					      dw	iJMP	;29
      1  035a		       4d 09		      .word.w	iJMP
      0  035c					      dw	iVINIT	;30
      1  035c		       84 09		      .word.w	iVINIT
      0  035e					      dw	iERRGOTO	;31
      1  035e		       8d 09		      .word.w	iERRGOTO
      0  0360					      dw	iTST	;32
      1  0360		       99 09		      .word.w	iTST
      0  0362					      dw	iTSTV	;33
      1  0362		       be 0a		      .word.w	iTSTV
      0  0364					      dw	iTSTL	;34
      1  0364		       64 0b		      .word.w	iTSTL
      0  0366					      dw	iTSTN	;35
      1  0366		       7f 0b		      .word.w	iTSTN
      0  0368					      dw	iFREE	;36
      1  0368		       38 0c		      .word.w	iFREE
      0  036a					      dw	iRANDOM	;37
      1  036a		       3e 0c		      .word.w	iRANDOM
      0  036c					      dw	iABS	;38
      1  036c		       0f 0d		      .word.w	iABS
     42  036e							;
     43  036e							; Disk functions.  There must be pointers
     44  036e							; to functions even if no disk is supported.
     45  036e							; Makes things easier in IL.inc.
     46  036e							;
     47  036e					      if	DISK_ACCESS
      0  036e					      dw	iOPENREAD	;39
      1  036e		       8e 2f		      .word.w	iOPENREAD
      0  0370					      dw	iOPENWRITE	;40
      1  0370		       ef 2f		      .word.w	iOPENWRITE
      0  0372					      dw	iDCLOSE	;41
      1  0372		       83 30		      .word.w	iDCLOSE
      0  0374					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0374		       11 30		      .word.w	iDGETLINE
      0  0376					      dw	iDLIST	;43 Did you remember your towel?
      1  0376		       7d 30		      .word.w	iDLIST
      0  0378					      dw	iDDIR	;44
      1  0378		       58 30		      .word.w	iDDIR
      0  037a					      dw	iRMFILE	;45
      1  037a		       dd 2f		      .word.w	iRMFILE
     55  037c				  -	      else
     56  037c				  -	      dw	NextIL	;39
     57  037c				  -	      dw	NextIL	;40
     58  037c				  -	      dw	NextIL	;41
     59  037c				  -	      dw	NextIL	;42
     60  037c				  -	      dw	NextIL	;43
     61  037c				  -	      dw	NextIL	;44
     62  037c				  -	      dw	NextIL	;45
     63  037c					      endif
     64  037c							;
      0  037c					      dw	iCLEARSCREEN	;46
      1  037c		       55 2e		      .word.w	iCLEARSCREEN
      0  037e					      dw	iPOKEMEMORY	;47
      1  037e		       9c 0c		      .word.w	iPOKEMEMORY
      0  0380					      dw	iPEEKMEMORY	;48
      1  0380		       b1 0c		      .word.w	iPEEKMEMORY
      0  0382					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0382		       e0 09		      .word.w	iTSTLET
      0  0384					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0384		       65 0a		      .word.w	iTSTDONE
      0  0386					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0386		       de 0c		      .word.w	iGETCHAR
      0  0388					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0388		       f2 0c		      .word.w	iPUTCHAR
      0  038a					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  038a		       c7 0c		      .word.w	iCallFunc
      0  038c					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  038c		       98 05		      .word.w	iBranch
      0  038e					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  038e		       c3 09		      .word.w	iTSTStr
      0  0390					      dw	iSetIrq	;56	   sets the irq handler
      1  0390		       b6 0d		      .word.w	iSetIrq
      0  0392					      dw	iTstIrq	;57	   test if irq is pending
      1  0392		       f6 0b		      .word.w	iTstIrq
      0  0394					      dw	iRET	;58	   return from interupt
      1  0394		       39 05		      .word.w	iRET
      0  0396					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0396		       e3 05		      .word.w	iINSTR
      0  0398					      dw	iMOD	;60	   returns remainder of division
      1  0398		       25 07		      .word.w	iMOD
      0  039a					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  039a		       6c 26		      .word.w	iTaskSet
      0  039c					      dw	iETask	;62	   Terminates a task
      1  039c		       a9 27		      .word.w	iETask
      0  039e					      dw	iNTask	;63	   goto next task
      1  039e		       5c 27		      .word.w	iNTask
     83  03a0				   ILTBL2
      0  03a0					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a0		       af 07		      .word.w	iArray
      0  03a2					      dw	iTaskKill	;65	   kill a running task
      1  03a2		       54 27		      .word.w	iTaskKill
      0  03a4					      dw	iTaskStat	;66	   return the state of a task PID
      1  03a4		       28 27		      .word.w	iTaskStat
      0  03a6					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03a6		       fd 0c		      .word.w	iHexOut
      0  03a8					      dw	iReadComplete	;68	   Called after a background read completes
      1  03a8		       b4 05		      .word.w	iReadComplete
      0  03aa					      dw	iReadStart	;69	   Called to start a background read request
      1  03aa		       aa 05		      .word.w	iReadStart
      0  03ac					      dw	iStartIO	;70	   Lock task until io complete
      1  03ac		       8c 27		      .word.w	iStartIO
      0  03ae					      dw	iEndIO	;71	   release task lock for io
      1  03ae		       92 27		      .word.w	iEndIO
      0  03b0					      dw	iLogNot	;72	   Logical not
      1  03b0		       68 0d		      .word.w	iLogNot
      0  03b2					      dw	iLogOr	;73	   Logical Or
      1  03b2		       3e 0d		      .word.w	iLogOr
      0  03b4					      dw	iLogAnd	;74	   Logical And
      1  03b4		       29 0d		      .word.w	iLogAnd
      0  03b6					      dw	iLogXor	;75	   Logical Xor
      1  03b6		       53 0d		      .word.w	iLogXor
      0  03b8					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03b8		       67 27		      .word.w	iWTASK
      0  03ba					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03ba		       9d 27		      .word.w	iTASKPID
      0  03bc					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03bc		       f4 0d		      .word.w	iTRACEPROG
      0  03be					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03be		       01 2d		      .word.w	idbgBasic
      0  03c0					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c0		       89 28		      .word.w	iIPCS
      0  03c2					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c2		       a0 28		      .word.w	iIPCR
      0  03c4					      dw	iIPCC	;82	   Check if any message available for task
      1  03c4		       b4 28		      .word.w	iIPCC
      0  03c6					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03c6		       c1 28		      .word.w	iIPCIO
      0  03c8					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03c8		       54 24		      .word.w	iPushMathStack
      0  03ca					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03ca		       84 24		      .word.w	iPopMathStack
      0  03cc					      dw	iSaveMathStack	;86	   Save all math info
      1  03cc		       a1 24		      .word.w	iSaveMathStack
      0  03ce					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03ce		       c0 24		      .word.w	iRestoreMathStack
      0  03d0					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d0		       71 24		      .word.w	iIncParmCount
      0  03d2					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d2		       c9 27		      .word.w	iTaskGetMathStack
      0  03d4					      dw	iTaskEnable	;90	   enable a suspended task
      1  03d4		       f6 26		      .word.w	iTaskEnable
      0  03d6					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03d6		       10 27		      .word.w	iTaskSuspend
      0  03d8					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03d8		       e3 27		      .word.w	iTaskPutMathPtr
      0  03da					      dw	iTSTVT	;93	   test for another tasks variable
      1  03da		       b5 0a		      .word.w	iTSTVT
      0  03dc					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03dc		       57 09		      .word.w	iSetR2
      0  03de					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03de		       17 05		      .word.w	iStk2Tmp
      0  03e0					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e0		       28 05		      .word.w	iTmp2Stk
      0  03e2					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e2		       01 0a		      .word.w	iTSTBYTE
      0  03e4					      dw	iINCVAR	;98	   Increment variable
      1  03e4		       87 0a		      .word.w	iINCVAR
      0  03e6					      dw	iDECVAR	;99	   Decrement variable
      1  03e6		       9f 0a		      .word.w	iDECVAR
      0  03e8					      dw	iSLICE	;100	   set the time slice for tasks
      1  03e8		       1c 28		      .word.w	iSLICE
      0  03ea					      dw	iTSTB	;101	   Test if byte equals
      1  03ea		       20 0a		      .word.w	iTSTB
      0  03ec					      dw	iTSTW	;102	   Test If word equals
      1  03ec		       3b 0a		      .word.w	iTSTW
      0  03ee					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03ee		       cb 1e		      .word.w	iOnGoto
      0  03f0					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03f0		       fc 1e		      .word.w	iTSTRELOP
      0  03f2					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03f2		       cb 04		      .word.w	iRepeatLine
      0  03f4					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch if is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03f4		       23 1f		      .word.w	iTSTBRANCH
      0  03f6					      dw	iFastXfer	;107	   move top of stack to curptr
      1  03f6		       d2 04		      .word.w	iFastXfer
      0  03f8					      dw	iSetTerminal	;108	   Set the Io Terminal to be used by print and input statements
      1  03f8		       d1 2e		      .word.w	iSetTerminal
      0  03fa					      dw	iINDB	;109	   fetch a single byte from memory indirect
      1  03fa		       9d 07		      .word.w	iINDB
      0  03fc					      dw	iSetBlock	;110	   Set a block or words or byte to a value 16 bit length
      1  03fc		       7b 23		      .word.w	iSetBlock
      0  03fe					      dw	iCopyBlock	;111	   Copy a block or memory from one location to another 16 bit length
      1  03fe		       d1 23		      .word.w	iCopyBlock
      0  0400					      dw	iCmpBlock	;112	   Compare to parts of memory
      1  0400		       05 24		      .word.w	iCmpBlock
      0  0402					      dw	iShift	;113	   Shift left 0 or right 1
      1  0402		       8c 0d		      .word.w	iShift
    134  0404
      0  0404					      dw	iBadOP	;114	   Invalid IL op code
      1  0404		       df 02		      .word.w	iBadOP
      0  0406					      dw	iBadOP	;115	   Invalid IL op code
      1  0406		       df 02		      .word.w	iBadOP
      0  0408					      dw	iBadOP	;116	   Invalid IL op code
      1  0408		       df 02		      .word.w	iBadOP
      0  040a					      dw	iBadOP	;117	   Invalid IL op code
      1  040a		       df 02		      .word.w	iBadOP
      0  040c					      dw	iBadOP	;118	   Invalid IL op code
      1  040c		       df 02		      .word.w	iBadOP
      0  040e					      dw	iBadOP	;119	   Invalid IL op code
      1  040e		       df 02		      .word.w	iBadOP
      0  0410					      dw	iBadOP	;120	   Invalid IL op code
      1  0410		       df 02		      .word.w	iBadOP
      0  0412					      dw	iBadOP	;121	   Invalid IL op code
      1  0412		       df 02		      .word.w	iBadOP
      0  0414					      dw	iBadOP	;122	   Invalid IL op code
      1  0414		       df 02		      .word.w	iBadOP
      0  0416					      dw	iBadOP	;123	   Invalid IL op code
      1  0416		       df 02		      .word.w	iBadOP
      0  0418					      dw	iBadOP	;124	   Invalid IL op code
      1  0418		       df 02		      .word.w	iBadOP
      0  041a					      dw	iBadOP	;125	   Invalid IL op code
      1  041a		       df 02		      .word.w	iBadOP
      0  041c					      dw	iBadOP	;126	   Invalid IL op code
      1  041c		       df 02		      .word.w	iBadOP
      0  041e					      dw	iBadOP	;127	   Invalid IL op code
      1  041e		       df 02		      .word.w	iBadOP
    149  0420
    150  0420
    151  0420
    152  0420
------- FILE mytb.asm
    507  0420		       04 20	   ILTBLend   equ	*
    508  0420
    509  0420							;
    510  0420							;=====================================================
    511  0420							;=====================================================
    512  0420							;=====================================================
    513  0420							; This marks the start of the handlers for IL opcodes.
    514  0420							;=====================================================
    515  0420							;=====================================================
    516  0420							;=====================================================
    517  0420							;
    518  0420							;
    519  0420		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    520  0422		       85 47		      sta	ILSTACKPTR
    521  0424		       85 4a		      sta	MATHSTACKPTR
    522  0426		       85 4d		      sta	GOSUBSTACKPTR
    523  0428		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    524  042a		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    525  042c							;
    526  042c		       ad 83 42 	      lda	ProgramStart	; user prog
    527  042f		       85 4f		      sta	CURPTR
    528  0431		       8d 10 36 	      sta	taskTable+1
    529  0434		       8d 85 42 	      sta	ProgramEnd
    530  0437		       ad 84 42 	      lda	ProgramStart+1
    531  043a		       85 50		      sta	CURPTR+1
    532  043c		       8d 11 36 	      sta	taskTable+2
    533  043f		       8d 86 42 	      sta	ProgramEnd+1
    534  0442		       a9 80		      lda	#TASKACTIVE
    535  0444		       8d 0f 36 	      sta	taskTable	;Mark the first slot as active
    536  0447		       a9 01		      lda	#1
    537  0449		       8d 0d 37 	      sta	taskCounter	;there is always one task / Main task
    538  044c		       ad 0b 37 	      lda	taskResetValue
    539  044f		       8d 09 37 	      sta	taskCurrentCycles	; set up the task switch counts
    540  0452		       ad 0c 37 	      lda	taskResetValue+1
    541  0455		       8d 0a 37 	      sta	taskCurrentCycles+1
    542  0458							;
    543  0458							; fall into XINIT...
    544  0458							;
    545  0458							;=====================================================
    546  0458							; This initializes for the start of the next line of
    547  0458							; BASIC text.
    548  0458							;
    549  0458		       78	   iXINIT     sei		; ensure interupts are off
    550  0459		       20 ef 25 	      jsr	taskReset	; Clear the task table
    551  045c		       a9 00		      lda	#0	; Clear the irq flags
    552  045e		       8d 56 19 	      sta	IRQPending	; reset the irq pending
    553  0461		       8d 55 19 	      sta	IRQStatus	; Make sure irqs are off
    554  0464
    555  0464		       4c b1 02    goodExit   jmp	NextIL
    556  0467							;
    557  0467							;=====================================================
    558  0467							; This check if the escape key has been entered
    559  0467							; then changes out of run mode. z Set if esc found
    560  0467				   BreakSet
    561  0467		       20 0f f0 	      jsr	ISCHAR
    562  046a		       f0 06		      beq	BreakNo
    563  046c		       20 e6 19 	      jsr	VGETCH
    564  046f		       c9 1b		      cmp	#$1B
    565  0471		       60		      rts
    566  0472				   BreakNo
    567  0472		       a9 01		      lda	#1
    568  0474		       60		      rts
    569  0475
    570  0475							;
    571  0475
    572  0475							;=====================================================
    573  0475							; Verify there is nothing else on this input line.
    574  0475							; If there is, generate an error.
    575  0475							;
    576  0475		       a4 51	   iDONE      ldy	CUROFF
    577  0477		       b1 4f		      lda	(CURPTR),y
    578  0479		       f0 0e		      beq	doneadv
    579  047b		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    580  047d		       d0 03		      bne	idoneErr
    581  047f							;		  sty	  CUROFF
    582  047f		       4c b1 02 	      jmp	NextIL	; continue on this line
    583  0482
    584  0482				   idoneErr
    585  0482		       a2 04		      ldx	#ERR_EXTRA_STUFF
    586  0484		       a9 00		      lda	#0
    587  0486		       4c 7d 06 	      jmp	iErr2
    588  0489							;
    589  0489							; Advance to the next line
    590  0489							;
    591  0489				   doneadv
    592  0489		       4c b1 02 	      jmp	NextIL
    593  048c							;
    594  048c							;=====================================================
    595  048c							; Print the string until a closing quote
    596  048c							;
    597  048c				   iPRS
    598  048c		       20 55 21 	      jsr	PrtQuoted
    599  048f		       84 51		      sty	CUROFF
    600  0491		       4c b1 02 	      jmp	NextIL
    601  0494							;
    602  0494							;=====================================================
    603  0494							; Pop the top off the stack and print it as a signed
    604  0494							; decimal number.
    605  0494							;
    606  0494				   iPRN
    607  0494		       20 3b 2c 	      jsr	popR0
    608  0497		       20 61 20 	      jsr	PrintDecimal
    609  049a		       4c b1 02 	      jmp	NextIL
    610  049d							;
    611  049d							;=====================================================
    612  049d							; Space to next zone.	Currently the code does not
    613  049d							; keep track of which column the output is on, so
    614  049d							; just print a tab.
    615  049d							;
    616  049d				   iSPC
    617  049d		       a9 09		      lda	#TAB
    618  049f		       20 e3 19 	      jsr	VOUTCH
    619  04a2		       4c b1 02 	      jmp	NextIL
    620  04a5							;
    621  04a5							;=====================================================
    622  04a5							; If in immediate mode, jump to the address following
    623  04a5							; the NXT instruction.  Else move to the next line of
    624  04a5							; user code and continue.
    625  04a5							;
    626  04a5		       a5 5b	   iNXT       lda	RunMode
    627  04a7		       d0 03		      bne	iNxtRun	;in run mode
    628  04a9							;
    629  04a9							; Get address and jump to it.
    630  04a9							;
    631  04a9		       4c 4d 09 	      jmp	iJMP
    632  04ac							;
    633  04ac				   iNxtRun
    634  04ac		       a4 51		      ldy	CUROFF
    635  04ae		       b1 4f		      lda	(CURPTR),y
    636  04b0		       c9 e6		      cmp	#oColon
    637  04b2		       d0 06		      bne	iNxtRunGo
    638  04b4		       c8		      iny
    639  04b5		       84 51		      sty	CUROFF
    640  04b7		       4c c5 04 	      jmp	iNxtRun2
    641  04ba
    642  04ba				   iNxtRunGo
    643  04ba		       20 3a 2a 	      jsr	FindNextLine
    644  04bd		       20 4e 2a 	      jsr	AtEnd
    645  04c0		       d0 03		      bne	iNxtRun2	;not at end
    646  04c2							;
    647  04c2							; At the end of the program.  Pretend an END statement
    648  04c2							; was found.
    649  04c2							;
    650  04c2		       4c 02 06    iFINv      jmp	iFIN
    651  04c5							;
    652  04c5		       20 ac 29    iNxtRun2   jsr	getILWord	;ignore next word
    653  04c8		       4c b1 02 	      jmp	NextIL
    654  04cb							;=====================================================
    655  04cb							;Repeat the same line against
    656  04cb		       a0 03	   iRepeatLine ldy	#3
    657  04cd		       84 51		      sty	CUROFF
    658  04cf		       4c b1 02 	      jmp	NextIL
    659  04d2							;
    660  04d2							;=====================================================
    661  04d2							; XFER takes the number on top of the stack and looks
    662  04d2							; for that line in the program, or the next line
    663  04d2							; higher.  Ie, if it's 1 but there is no line 1, then
    664  04d2							; find the next one after that.
    665  04d2							;
    666  04d2				   iFastXfer
    667  04d2		       20 53 2c 	      jsr	popR1	; get type of transfer
    668  04d5		       a5 54		      lda	R1
    669  04d7		       f0 0e		      beq	iXFER
    670  04d9
    671  04d9		       20 3b 2c 	      jsr	popR0	; get where to transfer
    672  04dc				   FastFastXfer
    673  04dc		       a5 52		      lda	R0
    674  04de		       85 4f		      sta	CURPTR
    675  04e0		       a5 53		      lda	R0+1
    676  04e2		       85 50		      sta	CURPTR+1
    677  04e4		       4c ed 04 	      jmp	iXFER2
    678  04e7
    679  04e7				   iXFER
    680  04e7		       20 3b 2c 	      jsr	popR0
    681  04ea		       20 f5 29 	      jsr	findLine
    682  04ed
    683  04ed				   iXFER2
    684  04ed		       20 4e 2a 	      jsr	AtEnd	;at end of user program?
    685  04f0		       f0 d0		      beq	iFINv
    686  04f2
    687  04f2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    688  04f4		       84 51		      sty	CUROFF
    689  04f6
    690  04f6							;		  lda	  #$ff
    691  04f6							;		  sta	  RunMode
    692  04f6							;
    693  04f6							; Transfer IL to STMT.  I don't like having this
    694  04f6							; hard-coded; fix it.
    695  04f6							;
    696  04f6							;		  lda	  #STMT&$ff
    697  04f6							;		  sta	  ILPC
    698  04f6							;		  lda	  #STMT>>8
    699  04f6							;		  sta	  ILPC+1
    700  04f6							;		  jmp	  NextIL
    701  04f6							;
    702  04f6							; Run
    703  04f6							;
    704  04f6				   iXferok
    705  04f6		       a9 ff		      lda	#$ff
    706  04f8		       85 5b		      sta	RunMode	;we're running
    707  04fa							;
    708  04fa							; Need a more elegant way to do this
    709  04fa							;
    710  04fa		       a9 7e		      lda	#STMT&$ff
    711  04fc		       85 43		      sta	ILPC
    712  04fe		       a9 31		      lda	#STMT>>8
    713  0500		       85 44		      sta	ILPC+1
    714  0502		       4c b1 02 	      jmp	NextIL
    715  0505							;
    716  0505							;=====================================================
    717  0505							; Save the pointer to the next line to the call stack.
    718  0505							;
    719  0505		       20 b0 29    iSAV       jsr	getILByte	; load type of gosub
    720  0508		       20 c3 2b 	      jsr	pushLN	; Type passed in A
    721  050b		       b0 03		      bcs	iSAVErr
    722  050d		       4c b1 02 	      jmp	NextIL
    723  0510
    724  0510		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    725  0512		       a9 00	   iSAVErr2   lda	#0
    726  0514		       4c 7d 06 	      jmp	iErr2
    727  0517							;====================================================
    728  0517							; Move stack top to and from temp area
    729  0517				   iStk2Tmp
    730  0517		       20 3b 2c 	      jsr	popR0
    731  051a		       a5 52		      lda	R0
    732  051c		       a0 48		      ldy	#TASKEXITCODE	; can also be used as temp
    733  051e		       91 41		      sta	(VARIABLES),y
    734  0520		       c8		      iny
    735  0521		       a5 53		      lda	R0+1
    736  0523		       91 41		      sta	(VARIABLES),y
    737  0525		       4c b1 02 	      jmp	NextIL
    738  0528
    739  0528		       a0 48	   iTmp2Stk   ldy	#TASKEXITCODE
    740  052a		       b1 41		      lda	(VARIABLES),y
    741  052c		       85 52		      sta	R0
    742  052e		       c8		      iny
    743  052f		       b1 41		      lda	(VARIABLES),y
    744  0531		       85 53		      sta	R0+1
    745  0533		       20 a9 2b 	      jsr	pushR0
    746  0536		       4c b1 02 	      jmp	NextIL
    747  0539							;
    748  0539							;=====================================================
    749  0539							; Pop the next line from the call stack. IRQ return
    750  0539							;
    751  0539		       20 ec 2b    iRET       jsr	popLN
    752  053c		       b0 d2		      bcs	iSAVErr
    753  053e		       a0 03		      ldy	#3
    754  0540		       84 51		      sty	CUROFF
    755  0542		       a9 00		      lda	#0
    756  0544		       8d 56 19 	      sta	IRQPending
    757  0547		       58		      cli
    758  0548		       4c b1 02 	      jmp	NextIL
    759  054b							;
    760  054b							;=====================================================
    761  054b							; Compare items on stack.  Okay, so on input there are
    762  054b							; three things on the stack
    763  054b							;
    764  054b							;    EXPR2 <- Top of stack
    765  054b							;    OP    <- relational operator, next on stack
    766  054b							;    EXPR1 <- last item on stack
    767  054b							;
    768  054b							; Comparison is: EXPR1 <operator> EXPR2
    769  054b							;
    770  054b							; Operator is one of...
    771  054b							;
    772  054b							;    2 is =
    773  054b							;    1 is <
    774  054b							;    3 is <=
    775  054b							;    5 is <>
    776  054b							;    4 is >
    777  054b							;    6 is >=
    778  054b							;
    779  054b							; Those are bit-mapped:
    780  054b							;
    781  054b							;    xxxxxGEL
    782  054b							;
    783  054b							;    G = Greater than
    784  054b							;    E = Equal
    785  054b							;    L = Less than
    786  054b							;
    787  054b							; If the comparison is false, do a NXT, ie, move to the
    788  054b							; next line and continue.  If true, continue executing
    789  054b							; on this line.
    790  054b							;
    791  054b		       00 01	   REL_LT     equ	%001
    792  054b		       00 02	   REL_EQUAL  equ	%010
    793  054b		       00 04	   REL_GT     equ	%100
    794  054b							;
    795  054b		       20 53 2c    iCMPR      jsr	popR1
    796  054e		       20 6a 2c 	      jsr	popMQ	;operator in MQ
    797  0551		       20 3b 2c 	      jsr	popR0
    798  0554		       20 5d 05 	      jsr	iCMPRsub
    799  0557		       20 a9 2b 	      jsr	pushR0
    800  055a		       4c b1 02 	      jmp	NextIL
    801  055d							;
    802  055d							; See if they are equal or not
    803  055d							;
    804  055d				   iCMPRsub		; Called by internal functions
    805  055d
    806  055d		       a5 52		      lda	R0
    807  055f		       c5 54		      cmp	R1
    808  0561		       d0 0a		      bne	iCMPRnoteq	;try not equal
    809  0563		       a5 53		      lda	R0+1
    810  0565		       c5 55		      cmp	R1+1
    811  0567		       d0 04		      bne	iCMPRnoteq
    812  0569							;
    813  0569							; Equal, set the flag in MQ+1
    814  0569							;
    815  0569		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    816  056b		       d0 14		      bne	iCMPcom	;Exit it is equal
    817  056d							;
    818  056d							; See if EXPR1 (R0) < EXPR2 (R1)
    819  056d							; See www.6502.org/tutorials/compare_beyond.html
    820  056d							;
    821  056d				   iCMPRnoteq
    822  056d		       a5 52		      lda	R0
    823  056f		       c5 54		      cmp	R1	; Sets the carry flag
    824  0571		       a5 53		      lda	R0+1
    825  0573		       e5 55		      sbc	R1+1
    826  0575
    827  0575		       50 02		      bvc	iCMPR_2	; branch if N eor V
    828  0577		       49 80		      eor	#$80
    829  0579
    830  0579		       30 04	   iCMPR_2    bmi	iCMPlt
    831  057b		       a9 04		      lda	#REL_GT
    832  057d		       d0 02		      bne	iCMPcom
    833  057f
    834  057f		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    835  0581
    836  0581				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    837  0581							;
    838  0581							; Now compare the end result with what the caller
    839  0581							; was looking for.
    840  0581							;
    841  0581		       25 56		      and	MQ
    842  0583		       f0 0c		      beq	iCMPno	; no match
    843  0585		       a9 ff		      lda	#$FF	; true is $ffff
    844  0587		       85 52		      sta	R0
    845  0589		       85 53		      sta	R0+1
    846  058b		       d0 0a		      bne	iCMPDone
    847  058d							;
    848  058d							; R0 > R1
    849  058d							;
    850  058d		       a9 04	   iCMPgt     lda	#REL_GT
    851  058f		       d0 f0		      bne	iCMPcom
    852  0591				   iCMPno
    853  0591		       a9 00		      lda	#0
    854  0593		       85 52		      sta	R0
    855  0595		       85 53		      sta	R0+1
    856  0597
    857  0597				   iCMPDone
    858  0597		       60		      rts
    859  0598
    860  0598							;
    861  0598							; if Not a match, so jump to the next line of code.
    862  0598							; Branches based upon value on top of the stack
    863  0598				   iBranch
    864  0598		       20 3b 2c 	      jsr	popR0
    865  059b		       a5 52		      lda	R0
    866  059d		       05 53		      ora	R0+1
    867  059f		       f0 03		      beq	iBranchFalse	; not true
    868  05a1		       4c b1 02 	      jmp	NextIL	; It is true if any value not zero
    869  05a4							;
    870  05a4				   iBranchFalse
    871  05a4		       20 3a 2a 	      jsr	FindNextLine
    872  05a7		       4c ed 04 	      jmp	iXFER2
    873  05aa							;
    874  05aa							;=====================================================
    875  05aa							; Start a read of data in background
    876  05aa				   iReadStart
    877  05aa		       a9 3f		      lda	#'?	; Prompt with question mark
    878  05ac		       a6 01		      ldx	1	; Indicate to start read in background
    879  05ae		       20 c6 2a 	      jsr	GetLine	; Call the getline to start read
    880  05b1		       4c b1 02 	      jmp	NextIL	; next instruction
    881  05b4							;
    882  05b4							;=====================================================
    883  05b4							; Complete the read and return the curptr, curoff pointing to data
    884  05b4				   iReadComplete
    885  05b4		       a9 01		      lda	#GOSUB_RTN
    886  05b6		       20 c3 2b 	      jsr	pushLN
    887  05b9		       90 03		      bcc	iReadOk
    888  05bb		       4c 31 0c    iReadErr   jmp	ErrStkOver	; Check if there was an error
    889  05be				   iReadOk
    890  05be		       20 e6 2a 	      jsr	ReadComplete
    891  05c1		       4c b1 02 	      jmp	NextIL
    892  05c4		       20 ec 2b 	      jsr	popLN
    893  05c7		       4c b1 02 	      jmp	NextIL
    894  05ca							;=====================================================
    895  05ca							; Get a line of text from the user, convert to a
    896  05ca							; number, leave on top of stack.
    897  05ca							;
    898  05ca				   iINNUM
    899  05ca		       a9 01		      lda	#GOSUB_RTN
    900  05cc		       20 c3 2b 	      jsr	pushLN
    901  05cf		       b0 ea		      bcs	iReadErr	; Stack over flow error
    902  05d1							;
    903  05d1		       a9 3f		      lda	#'?
    904  05d3		       a2 00		      ldx	#0	;Wait for complete
    905  05d5		       20 c6 2a 	      jsr	GetLine
    906  05d8		       20 5b 2a 	      jsr	getDecimal
    907  05db		       20 a9 2b 	      jsr	pushR0	;put onto stack
    908  05de		       b0 db		      bcs	iReadErr	;StackOverflow error
    909  05e0							;
    910  05e0		       4c fc 05 	      jmp	ExitIn
    911  05e3							;
    912  05e3							;=====================================================
    913  05e3							; Get a line of text from the user, convert to a
    914  05e3							; character value , leave on top of stack. up to 2 characters
    915  05e3							;
    916  05e3				   iINSTR
    917  05e3		       a9 01		      lda	#GOSUB_RTN
    918  05e5		       20 c3 2b 	      jsr	pushLN
    919  05e8		       b0 d1		      bcs	iReadErr	; Stack overflow error
    920  05ea		       a9 3f		      lda	#'?
    921  05ec		       a2 00		      ldx	#0	;wait for read complete
    922  05ee		       20 c6 2a 	      jsr	GetLine
    923  05f1		       b1 4f		      lda	(CURPTR),y
    924  05f3		       85 52		      sta	R0
    925  05f5		       a9 00		      lda	#0
    926  05f7		       85 53		      sta	R0+1
    927  05f9		       20 a9 2b 	      jsr	pushR0	;put onto stack
    928  05fc				   ExitIn
    929  05fc		       20 ec 2b 	      jsr	popLN
    930  05ff		       4c b1 02 	      jmp	NextIL
    931  0602							;
    932  0602							;
    933  0602							;=====================================================
    934  0602							; Stop the currently running program.	Actually very
    935  0602							; simple to do... clear the RunMode flag, then set the
    936  0602							; ILPC to the standard handler and continue running.
    937  0602							;
    938  0602		       a9 00	   iFIN       lda	#0
    939  0604		       85 5b		      sta	RunMode
    940  0606		       20 ef 25 	      jsr	taskReset
    941  0609							;
    942  0609		       ad 74 42 	      lda	errGoto
    943  060c		       85 43		      sta	ILPC
    944  060e		       ad 75 42 	      lda	errGoto+1
    945  0611		       85 44		      sta	ILPC+1
    946  0613		       4c b1 02 	      jmp	NextIL
    947  0616							;
    948  0616							;=====================================================
    949  0616							; Handle the ERR opcode.  Following the instruction is
    950  0616							; a 16 bit error number.  Print an error message, and
    951  0616							; if we're in run mode, print the line number.  Stop
    952  0616							; program execution and return to the initial state.
    953  0616							;
    954  0616		       ad 81 42    iERR       lda	taskIOPending
    955  0619		       f0 03		      beq	iErrNext
    956  061b		       ce 81 42 	      dec	taskIOPending
    957  061e
    958  061e		       20 ac 29    iErrNext   jsr	getILWord	;get err code
    959  0621		       20 27 06 	      jsr	DisplayError
    960  0624		       4c 80 06 	      jmp	iErrComplete
    961  0627							;
    962  0627							; Enter here with the error code in X (LSB) and A (MSB).
    963  0627							;
    964  0627				   DisplayError
    965  0627		       86 52		      stx	R0
    966  0629		       85 53		      sta	R0+1
    967  062b							;
    968  062b		       20 32 21 	      jsr	puts
      0  062e					      db	CR,LF,"Error ",0
      1  062e		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    970  0637		       20 61 20 	      jsr	PrintDecimal
    971  063a							;
    972  063a		       a5 5b		      lda	RunMode	;running?
    973  063c		       f0 3b		      beq	iERR3	;nope
    974  063e		       20 32 21 	      jsr	puts
      0  0641					      db	" at line ",0
      1  0641		       20 61 74 20*	      .byte.b	" at line ",0
    976  064b		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    977  064d				   iErr2a
    978  064d		       b1 4f		      lda	(CURPTR),y
    979  064f		       85 52		      sta	R0
    980  0651		       c8		      iny
    981  0652		       b1 4f		      lda	(CURPTR),y
    982  0654		       85 53		      sta	R0+1
    983  0656		       20 61 20 	      jsr	PrintDecimal
    984  0659		       20 32 21 	      jsr	puts
      0  065c					      db	":",0
      1  065c		       3a 00		      .byte.b	":",0
    986  065e		       a9 00		      lda	#0
    987  0660		       85 53		      sta	R0+1
    988  0662		       a5 51		      lda	CUROFF
    989  0664		       18		      clc
    990  0665		       e9 03		      sbc	#3
    991  0667		       85 52		      sta	R0
    992  0669		       20 61 20 	      jsr	PrintDecimal
    993  066c		       20 32 21 	      jsr	puts
      0  066f					      db	":",0
      1  066f		       3a 00		      .byte.b	":",0
    995  0671		       ad 0e 36 	      lda	taskPtr
    996  0674		       85 52		      sta	R0
    997  0676		       20 15 21 	      jsr	HexToOut
    998  0679							;
    999  0679				   iERR3
   1000  0679		       20 f4 2c 	      jsr	CRLF
   1001  067c		       60		      rts
   1002  067d
   1003  067d				   iErr2
   1004  067d		       20 27 06 	      jsr	DisplayError
   1005  0680
   1006  0680				   iErrComplete
   1007  0680		       20 e7 25 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1008  0683		       a9 00		      lda	#0
   1009  0685		       85 5b		      sta	RunMode	; fall through...
   1010  0687							;
   1011  0687							;=====================================================
   1012  0687							; Reset the IL to be back at the idle loop.  Does not
   1013  0687							; clear variables so the user can see what state
   1014  0687							; the program is in.
   1015  0687							;
   1016  0687		       a9 00	   ResetIL    lda	#0
   1017  0689		       85 47		      sta	ILSTACKPTR
   1018  068b		       ad 74 42 	      lda	errGoto
   1019  068e		       85 43		      sta	ILPC
   1020  0690		       ad 75 42 	      lda	errGoto+1
   1021  0693		       85 44		      sta	ILPC+1
   1022  0695		       4c b1 02 	      jmp	NextIL
   1023  0698
   1024  0698							;
   1025  0698							;=====================================================
   1026  0698							; Pop two items off stack, add them, then place the
   1027  0698							; result back onto the stack.
   1028  0698							;
   1029  0698		       20 3b 2c    iADD       jsr	popR0
   1030  069b		       20 53 2c 	      jsr	popR1
   1031  069e				   iADDfast
   1032  069e		       18		      clc
   1033  069f		       a5 52		      lda	R0
   1034  06a1		       65 54		      adc	R1
   1035  06a3		       85 52		      sta	R0
   1036  06a5		       a5 53		      lda	R0+1
   1037  06a7		       65 55		      adc	R1+1
   1038  06a9		       85 53		      sta	R0+1
   1039  06ab		       4c 16 07 	      jmp	pushR0nextIl
   1040  06ae							;
   1041  06ae							;=====================================================
   1042  06ae							; Pop two items off the stack.  Subtract the top of
   1043  06ae							; stack from the lower entry.
   1044  06ae							;
   1045  06ae		       20 53 2c    iSUB       jsr	popR1
   1046  06b1		       20 3b 2c 	      jsr	popR0
   1047  06b4		       38		      sec
   1048  06b5		       a5 52		      lda	R0
   1049  06b7		       e5 54		      sbc	R1
   1050  06b9		       85 52		      sta	R0
   1051  06bb		       a5 53		      lda	R0+1
   1052  06bd		       e5 55		      sbc	R1+1
   1053  06bf		       85 53		      sta	R0+1
   1054  06c1		       4c 16 07 	      jmp	pushR0nextIl
   1055  06c4							;
   1056  06c4							;=====================================================
   1057  06c4							; Negate the top of stack.
   1058  06c4							;
   1059  06c4		       20 3b 2c    iNEG       jsr	popR0
   1060  06c7		       a5 52		      lda	R0
   1061  06c9		       49 ff		      eor	#$ff
   1062  06cb		       85 52		      sta	R0
   1063  06cd		       a5 53		      lda	R0+1
   1064  06cf		       49 ff		      eor	#$ff
   1065  06d1		       85 53		      sta	R0+1
   1066  06d3		       e6 52		      inc	R0
   1067  06d5		       d0 02		      bne	iNEG2
   1068  06d7		       e6 53		      inc	R0+1
   1069  06d9		       4c 16 07    iNEG2      jmp	pushR0nextIl
   1070  06dc							;
   1071  06dc							;=====================================================
   1072  06dc							; Multiply top two items on the stack, put the results
   1073  06dc							; on top.  This uses the algorithm documented on page
   1074  06dc							; 115 of "Microprocessor Programming for Computer
   1075  06dc							; Hobbyists" by Neill Graham.
   1076  06dc							;
   1077  06dc		       20 e2 06    iMUL       jsr	iMultiply
   1078  06df		       4c b1 02 	      jmp	NextIL
   1079  06e2
   1080  06e2				   iMultiply
   1081  06e2		       20 3b 2c 	      jsr	popR0	;AC
   1082  06e5		       20 53 2c 	      jsr	popR1	;OP
   1083  06e8							;
   1084  06e8		       a5 52		      lda	R0
   1085  06ea		       85 56		      sta	MQ
   1086  06ec		       a5 53		      lda	R0+1
   1087  06ee		       85 57		      sta	MQ+1
   1088  06f0		       a9 00		      lda	#0	;clear result
   1089  06f2		       85 52		      sta	R0
   1090  06f4		       85 53		      sta	R0+1
   1091  06f6							;
   1092  06f6		       a2 10		      ldx	#16	;number of bits in value
   1093  06f8		       06 52	   multloop   asl	R0
   1094  06fa		       26 53		      rol	R0+1
   1095  06fc		       06 56		      asl	MQ
   1096  06fe		       26 57		      rol	MQ+1
   1097  0700		       90 0d		      bcc	multno	;skip add if no carry
   1098  0702							;
   1099  0702							; Add R1 back into R0
   1100  0702							;
   1101  0702		       18		      clc
   1102  0703		       a5 52		      lda	R0
   1103  0705		       65 54		      adc	R1
   1104  0707		       85 52		      sta	R0
   1105  0709		       a5 53		      lda	R0+1
   1106  070b		       65 55		      adc	R1+1
   1107  070d		       85 53		      sta	R0+1
   1108  070f							;
   1109  070f		       ca	   multno     dex		;did all bits yet?
   1110  0710		       d0 e6		      bne	multloop
   1111  0712		       20 a9 2b 	      jsr	pushR0	;OP
   1112  0715		       60		      rts
   1113  0716							;
   1114  0716				   pushR0nextIl
   1115  0716		       20 a9 2b 	      jsr	pushR0	;OP
   1116  0719		       4c b1 02 	      jmp	NextIL
   1117  071c							;
   1118  071c							;=====================================================
   1119  071c							; Divide the top of stack into the next to top item.
   1120  071c							; Leave results on stack.  Taken from:
   1121  071c							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1122  071c							;
   1123  071c							; R0 = R0 / R1
   1124  071c							; Remainder is in MQ
   1125  071c							;
   1126  071c		       20 36 07    iDIV       jsr	iDoDiv
   1127  071f		       20 bc 2c 	      jsr	RestoreSigns
   1128  0722		       4c 16 07 	      jmp	pushR0nextIl
   1129  0725
   1130  0725		       20 36 07    iMOD       jsr	iDoDiv
   1131  0728		       20 bc 2c 	      jsr	RestoreSigns
   1132  072b		       a5 56		      lda	MQ
   1133  072d		       85 52		      sta	R0
   1134  072f		       a5 57		      lda	MQ+1
   1135  0731		       85 53		      sta	R0+1
   1136  0733		       4c 16 07 	      jmp	pushR0nextIl
   1137  0736
   1138  0736				   iDoDiv
   1139  0736		       20 53 2c 	      jsr	popR1
   1140  0739		       20 3b 2c 	      jsr	popR0
   1141  073c							;
   1142  073c							; Check for divide by zero
   1143  073c							;
   1144  073c
   1145  073c				   iDivNoPop
   1146  073c		       a5 54		      lda	R1
   1147  073e		       05 55		      ora	R1+1
   1148  0740		       f0 29		      beq	divby0
   1149  0742							;
   1150  0742		       20 81 2c 	      jsr	SaveSigns
   1151  0745		       a9 00		      lda	#0	;preset remainder to 0
   1152  0747		       85 56		      sta	MQ
   1153  0749		       85 57		      sta	MQ+1
   1154  074b		       a2 10		      ldx	#16	;repeat for each bit: ...
   1155  074d				   divloop
   1156  074d		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1157  074f		       26 53		      rol	R0+1
   1158  0751		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1159  0753		       26 57		      rol	MQ+1
   1160  0755		       a5 56		      lda	MQ
   1161  0757		       38		      sec
   1162  0758		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1163  075a		       a8		      tay		;lb result -> Y, for we may need it later
   1164  075b		       a5 57		      lda	MQ+1
   1165  075d		       e5 55		      sbc	R1+1
   1166  075f		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1167  0761
   1168  0761		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1169  0763		       84 56		      sty	MQ
   1170  0765		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1171  0767
   1172  0767		       ca	   skip       dex
   1173  0768		       d0 e3		      bne	divloop
   1174  076a		       60		      rts
   1175  076b							;
   1176  076b							; Indicate divide-by-zero error
   1177  076b							;
   1178  076b		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1179  076d		       a9 00		      lda	#0
   1180  076f		       4c 7d 06 	      jmp	iErr2
   1181  0772							;
   1182  0772							;=====================================================
   1183  0772							; This pops the top two items off the stack.  The top
   1184  0772							; item is a data value and the other is an ABSOLUTE address.
   1185  0772							; Save the value into that address.
   1186  0772							;
   1187  0772		       98	   iSTORE     tya
   1188  0773		       48		      pha
   1189  0774		       20 3b 2c 	      jsr	popR0	;data
   1190  0777		       20 53 2c 	      jsr	popR1	;Storage location
   1191  077a		       a0 01		      ldy	#1
   1192  077c		       a5 58		      lda	R2
   1193  077e		       c9 a2		      cmp	#tByte
   1194  0780		       f0 04		      beq	iStoreB
   1195  0782				   iStoreW
   1196  0782		       a5 53		      lda	R0+1
   1197  0784		       91 54		      sta	(R1),y
   1198  0786				   iStoreB
   1199  0786		       a5 52		      lda	R0
   1200  0788		       88		      dey
   1201  0789		       91 54		      sta	(R1),y
   1202  078b		       68		      pla
   1203  078c		       a8		      tay
   1204  078d		       4c b1 02 	      jmp	NextIL
   1205  0790							;
   1206  0790							;=====================================================
   1207  0790							; Replaces the top of stack with the Value
   1208  0790							; of the variable  whose absolute address it represents.
   1209  0790							;
   1210  0790
   1211  0790		       98	   iIND       tya
   1212  0791		       48		      pha
   1213  0792		       20 53 2c 	      jsr	popR1
   1214  0795		       a0 01		      ldy	#1
   1215  0797		       a5 58		      lda	R2
   1216  0799		       c9 a4		      cmp	#tInteger
   1217  079b		       f0 04		      beq	iINDW
   1218  079d				   iINDB
   1219  079d		       a9 00		      lda	#0
   1220  079f		       f0 02		      BEQ	iINDC
   1221  07a1				   iINDW
   1222  07a1		       b1 54		      lda	(R1),y
   1223  07a3				   iINDC
   1224  07a3		       85 53		      sta	R0+1
   1225  07a5		       88		      dey
   1226  07a6		       b1 54		      lda	(R1),y
   1227  07a8		       85 52		      sta	R0
   1228  07aa		       68		      pla
   1229  07ab		       a8		      tay
   1230  07ac		       4c 16 07 	      jmp	pushR0nextIl
   1231  07af
   1232  07af							;
   1233  07af							;=====================================================
   1234  07af							; Check which type of index to use byte or word and jmp to correct
   1235  07af							; function
   1236  07af		       98	   iArray     tya
   1237  07b0		       48		      pha
   1238  07b1
   1239  07b1		       20 3b 2c 	      jsr	popR0	; Get the array index
   1240  07b4		       20 53 2c 	      jsr	popR1	; Get the Variable address
   1241  07b7
   1242  07b7		       20 b0 29 	      jsr	getILByte	; Get type of number to process
   1243  07ba		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Are we testing a valid parameter
   1244  07bc		       f0 52		      beq	iArrayFNparm	; process a fn pramater index
   1245  07be
   1246  07be		       29 fe		      and	#$FE	; Turn off the unsigned bit
   1247  07c0		       c9 a2		      cmp	#tByte	; Test for a byte index
   1248  07c2		       f0 10		      beq	iArrayB	; yes so branch to process a byte
   1249  07c4							;=====================================================
   1250  07c4							; Process 32 bit index into memory
   1251  07c4		       c9 a6	   iArrayL    cmp	#tLong	; Are we working with 32 bit integers
   1252  07c6		       d0 06		      bne	iArrayW	; Process with sigle shift
   1253  07c8		       06 52		      asl	R0	; Do the multiply by 2
   1254  07ca		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1255  07cc		       b0 39		      bcs	iArrayError	; if the carry is set we have an error
   1256  07ce							;=====================================================
   1257  07ce							; Get the array index from top of stack get Current variable
   1258  07ce							; address from next on stack, add the offset
   1259  07ce							; push the result back onto the stack
   1260  07ce				   iArrayW		; pointers, arrays etc all use 16 bit unsigned integers
   1261  07ce		       06 52		      asl	R0	; Do the multiply by 2
   1262  07d0		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1263  07d2		       b0 33		      bcs	iArrayError	; if the carry is set we have an error
   1264  07d4
   1265  07d4							;=====================================================
   1266  07d4							; Get from Byte array not Integer array
   1267  07d4				   iArrayB
   1268  07d4		       18		      clc
   1269  07d5		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1270  07d7		       65 52		      adc	R0
   1271  07d9		       85 52		      sta	R0
   1272  07db		       a5 55		      lda	R1+1
   1273  07dd		       65 53		      adc	R0+1
   1274  07df		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1275  07e1		       a5 55		      lda	R1+1
   1276  07e3		       cd 86 42 	      cmp	ProgramEnd+1	; lets check if we are processing an @ buffer pointer to free memory
   1277  07e6		       d0 08		      bne	iArrayCheckVar
   1278  07e8				   iArrayExit
   1279  07e8		       20 a9 2b 	      jsr	pushR0	; Push R0 assume it is correct
   1280  07eb
   1281  07eb		       68		      pla
   1282  07ec		       a8		      tay
   1283  07ed		       4c b1 02 	      jmp	NextIL
   1284  07f0							; Check for valis variable and valid index to use
   1285  07f0		       a5 41	   iArrayCheckVar lda	VARIABLES
   1286  07f2		       18		      clc
   1287  07f3		       69 33		      adc	#[25*2]+1	; the number of actual variable valid bytes
   1288  07f5		       85 56		      sta	MQ	; mq contains the last valid byte we can use
   1289  07f7		       a9 00		      lda	#0
   1290  07f9		       65 42		      adc	VARIABLES+1	; Memory past last word R0+1 > A then invalid
   1291  07fb		       c5 53		      cmp	R0+1
   1292  07fd		       90 08		      bcc	iArrayError
   1293  07ff		       a5 52		      lda	R0	; a > m invalid past last byte of variable area
   1294  0801		       c5 56		      cmp	MQ
   1295  0803		       f0 e3		      beq	iArrayExit	; If it is equal then it is valid
   1296  0805		       90 e1		      bcc	iArrayExit	; if it is less it is valid
   1297  0807
   1298  0807							; Get here if array index is out of range
   1299  0807		       68	   iArrayError pla
   1300  0808		       98		      tya
   1301  0809		       a9 00		      lda	#0
   1302  080b		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1303  080d		       4c 7d 06 	      jmp	iErr2
   1304  0810							;=====================================================
   1305  0810							; Verify function paramater index is valid
   1306  0810		       20 3d 25    iArrayFNparm jsr	GosubFindParms	; Get a pointer to the current functions parameter list info
   1307  0813		       90 f2		      bcc	iArrayError	; There are no paramters for this call, should never be true
   1308  0815		       88		      dey
   1309  0816		       88		      dey		; Points to parameter count
   1310  0817		       a5 52		      lda	R0	; get parm to be accessed
   1311  0819		       d1 4b		      cmp	(GOSUBSTACK),y	; compare to max number allowed
   1312  081b		       b0 ea		      bcs	iArrayError	; the parameter index should be less than the count
   1313  081d		       06 52		      asl	R0	; Do the multiply by 2
   1314  081f		       26 53		      rol	R0+1
   1315  0821
   1316  0821		       18		      clc
   1317  0822		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1318  0824		       65 52		      adc	R0
   1319  0826		       85 52		      sta	R0
   1320  0828		       a5 55		      lda	R1+1
   1321  082a		       65 53		      adc	R0+1
   1322  082c		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1323  082e		       4c e8 07 	      jmp	iArrayExit	; Get ot we are done
   1324  0831							;
   1325  0831							;=====================================================
   1326  0831							; List the current BASIC program in memory.  Uses R0,
   1327  0831							; tempIly, and dpl.
   1328  0831							;
   1329  0831		       20 3b 2e    iLST       jsr	SetOutConsole
   1330  0834		       ad 83 42    iLST2      lda	ProgramStart
   1331  0837		       85 59		      sta	dpl
   1332  0839		       ad 84 42 	      lda	ProgramStart+1
   1333  083c		       85 5a		      sta	dpl+1
   1334  083e							;
   1335  083e							; dpl/dph point to the current line.  See if we're at
   1336  083e							; the end of the program.
   1337  083e							;
   1338  083e		       a5 59	   iLSTloop   lda	dpl
   1339  0840		       cd 85 42 	      cmp	ProgramEnd
   1340  0843		       d0 07		      bne	iLstNotEnd
   1341  0845		       a5 5a		      lda	dpl+1
   1342  0847		       cd 86 42 	      cmp	ProgramEnd+1
   1343  084a		       f0 15		      beq	iLstdone
   1344  084c							;
   1345  084c		       20 ca 21    iLstNotEnd jsr	PrintProgramLine
   1346  084f							;		  ldy	  #1		  ;Change:  Skip first byte length
   1347  084f							;		  lda	  (dpl),y	  ;line number LSB
   1348  084f							;		  sta	  R0
   1349  084f							;		  iny
   1350  084f							;		  lda	  (dpl),y		 ;line number MSB
   1351  084f							;		  sta	  R0+1
   1352  084f							;		  iny
   1353  084f							;		  sty	  tempIlY
   1354  084f							;		  jsr	  PrintDecimal
   1355  084f							;		  lda	  #SPACE
   1356  084f							;		  jsr	  VOUTCH
   1357  084f							;		  ldy	  tempIlY
   1358  084f							;iLSTl2	  lda	  (dpl),y
   1359  084f							;		  beq	  iLST3 	  ;end of this line 0 value
   1360  084f							;		  sty	  tempIlY
   1361  084f							;		  jsr	  VOUTCH
   1362  084f							;		  ldy	  tempIlY
   1363  084f							;		  iny
   1364  084f							;		  bne	  iLSTl2	  ;do next char
   1365  084f							;
   1366  084f							; End of this line.  Print CR/LF, then move to the
   1367  084f							; next line.
   1368  084f							;
   1369  084f		       a0 00	   iLST3      ldy	#0	;Move to next line
   1370  0851		       b1 59		      lda	(dpl),y	;Current line length
   1371  0853		       18		      clc		;Clear the carry flag
   1372  0854							;		  tya
   1373  0854		       65 59		      adc	dpl	;Add the offset to the pointer
   1374  0856		       85 59		      sta	dpl	;Save the new value
   1375  0858		       a5 5a		      lda	dpl+1	;Next byte
   1376  085a		       69 00		      adc	#0	;ad in the carry if any
   1377  085c		       85 5a		      sta	dpl+1	;Save it
   1378  085e							;
   1379  085e							; Have to manually do CR/LF so it uses the vectored
   1380  085e							; output function.
   1381  085e							;
   1382  085e							;		  lda	  #CR
   1383  085e							;		  jsr	  VOUTCH
   1384  085e							;		  lda	  #LF
   1385  085e							;		  jsr	  VOUTCH
   1386  085e		       4c 3e 08 	      jmp	iLSTloop	;do next line
   1387  0861							;
   1388  0861		       20 3b 2e    iLstdone   jsr	SetOutConsole
   1389  0864		       4c b1 02 	      jmp	NextIL
   1390  0867							;
   1391  0867							;=====================================================
   1392  0867							; Get a line of text into LINBUF.  Terminate with a
   1393  0867							; null byte.
   1394  0867							;
   1395  0867				   iGETLINE
   1396  0867		       a9 3e		      lda	#'>	;prompt character
   1397  0869		       a6 00		      ldx	0	;Wait for read to complete
   1398  086b		       20 c6 2a 	      jsr	GetLine
   1399  086e							;
   1400  086e		       a9 00		      lda	#0
   1401  0870		       85 5b		      sta	RunMode
   1402  0872				   iGetParseLine
   1403  0872							; lda	   CUROFF
   1404  0872							; pha
   1405  0872		       20 d5 1c 	      jsr	ParseInputLine
   1406  0875							; pla
   1407  0875							;  sta     CUROFF
   1408  0875		       a9 d2		      lda	#TOKENBUFFER&$FF
   1409  0877		       85 4f		      sta	CURPTR
   1410  0879		       a9 1b		      lda	#TOKENBUFFER>>8
   1411  087b		       85 50		      sta	CURPTR+1
   1412  087d		       a9 01		      lda	#1
   1413  087f		       85 51		      sta	CUROFF
   1414  0881		       4c b1 02 	      jmp	NextIL
   1415  0884							;
   1416  0884							;=====================================================
   1417  0884							; This is called when the input buffer contains a line
   1418  0884							; typed in by the user that starts with a line number.
   1419  0884							; Insert the line into the program or delete the line
   1420  0884							; if there is nothing after the line number,
   1421  0884							;
   1422  0884				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1423  0884		       ad d3 1b 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1424  0887		       85 52		      sta	R0	; place the number into R0
   1425  0889		       ad d4 1b 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1426  088c		       85 53		      STA	R0+1	; Place it into
   1427  088e							;
   1428  088e							; Now find the line OR the next higher line OR the
   1429  088e							; end of the program.
   1430  088e							;
   1431  088e		       20 f5 29 	      jsr	findLine	; Look for the line number in the current program
   1432  0891							; Returns Z and curptr point to the line if found
   1433  0891							; Returns C and curptr at next higher line if not found and there is a higher line
   1434  0891							; Returns ZC clear and curptr to end of program if higher than all other lines
   1435  0891							;
   1436  0891							; If the line exists, it needs to be removed.
   1437  0891							;
   1438  0891		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1439  0893							;
   1440  0893							; Get length of line to be removed, we fall thru to here if we find a matching line
   1441  0893							;
   1442  0893							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1443  0893		       a0 00		      ldy	#0
   1444  0895		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1445  0897		       a8		      tay
   1446  0898							;If it is equal we delete the line and replace it, get length
   1447  0898							;then adjust all program line after up or down depending on len of line
   1448  0898							;If next higher then just move everythimg down by length bytes
   1449  0898							;This call will return how many bytes in the line we found
   1450  0898		       8c 80 42 	      sty	lineLength	;Save the length of the line we found
   1451  089b							;
   1452  089b							; Compute the new end of the program first.
   1453  089b							;
   1454  089b		       38		      sec		;Set the carry bit
   1455  089c		       ad 85 42 	      lda	ProgramEnd	;Get low byte of program end
   1456  089f		       ed 80 42 	      sbc	lineLength	;Subtract the length of the current line
   1457  08a2		       8d 85 42 	      sta	ProgramEnd	;save it
   1458  08a5		       ad 86 42 	      lda	ProgramEnd+1
   1459  08a8		       e9 00		      sbc	#0	;Process the carry
   1460  08aa		       8d 86 42 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1461  08ad							;
   1462  08ad							; Copy CURPTR into R1 for working
   1463  08ad							;
   1464  08ad		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1465  08af		       85 54		      sta	R1
   1466  08b1		       a5 50		      lda	CURPTR+1
   1467  08b3		       85 55		      sta	R1+1
   1468  08b5							;
   1469  08b5							; See if we're at the end.
   1470  08b5							;
   1471  08b5		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1472  08b7		       cd 85 42 	      cmp	ProgramEnd
   1473  08ba		       d0 07		      bne	InsDelLoop
   1474  08bc		       a5 55		      lda	R1+1
   1475  08be		       cd 86 42 	      cmp	ProgramEnd+1
   1476  08c1		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1477  08c3							;
   1478  08c3							; Move one byte, move to next location.
   1479  08c3							;
   1480  08c3		       ac 80 42    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1481  08c6		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1482  08c8		       b1 54		      lda	(R1),y
   1483  08ca		       a0 00		      ldy	#0
   1484  08cc		       91 54		      sta	(R1),y
   1485  08ce		       e6 54		      inc	R1
   1486  08d0		       d0 e3		      bne	InsDelChk
   1487  08d2		       e6 55		      inc	R1+1
   1488  08d4		       4c b5 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1489  08d7							;
   1490  08d7							; Deletion is done.
   1491  08d7							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1492  08d7							;
   1493  08d7				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1494  08d7		       ad d2 1b 	      lda	TOKENBUFFER	; Get the length
   1495  08da		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1496  08dc							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1497  08dc		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1498  08de							;
   1499  08de							; CURPTR points to where the line will be inserted.
   1500  08de							;
   1501  08de							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1502  08de		       ae d2 1b 	      ldx	TOKENBUFFER
   1503  08e1		       8e 80 42 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1504  08e4							;
   1505  08e4		       ad 85 42 	      lda	ProgramEnd	;Load the start address for the copy
   1506  08e7							;At this point curptr still contains the location we will insert data
   1507  08e7		       85 5c		      sta	FROM
   1508  08e9		       ad 86 42 	      lda	ProgramEnd+1
   1509  08ec		       85 5d		      sta	FROM+1
   1510  08ee							;
   1511  08ee		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1512  08f0		       b1 5c		      lda	(FROM),y
   1513  08f2		       ac 80 42 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1514  08f5		       91 5c		      sta	(FROM),y	;Save the new byte
   1515  08f7							;
   1516  08f7		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1517  08f9		       c5 4f		      cmp	CURPTR
   1518  08fb		       d0 06		      bne	mvUpMore
   1519  08fd		       a5 5d		      lda	FROM+1
   1520  08ff		       c5 50		      cmp	CURPTR+1
   1521  0901		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1522  0903							;
   1523  0903							; Not done yet
   1524  0903							;
   1525  0903		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1526  0905		       d0 02		      bne	mvUpMore2
   1527  0907		       c6 5d		      dec	FROM+1
   1528  0909		       c6 5c	   mvUpMore2  dec	FROM
   1529  090b		       4c ee 08 	      jmp	mvup1	;Loop until everything is moved
   1530  090e							;
   1531  090e							; All done with copy.
   1532  090e							;
   1533  090e				   mvUpDone
   1534  090e		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1535  090f		       ad 80 42 	      lda	lineLength	;Number of bytes to copy from line buff
   1536  0912		       6d 85 42 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1537  0915		       8d 85 42 	      sta	ProgramEnd
   1538  0918		       ad 86 42 	      lda	ProgramEnd+1
   1539  091b		       69 00		      adc	#0
   1540  091d		       8d 86 42 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1541  0920							;
   1542  0920							;===================jlit use length before line newline
   1543  0920
   1544  0920		       a0 00		      ldy	#0	;Set offset of copy
   1545  0922							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1546  0922							;		  sta	  (CURPTR),y	  ;Store the length
   1547  0922							;		  iny
   1548  0922							;		  lda	  R0		  ;Store the line number next
   1549  0922							;		  sta	  (CURPTR),y
   1550  0922							;		  iny
   1551  0922							;		  lda	  R0+1
   1552  0922							;		  sta	  (CURPTR),y
   1553  0922							;		  iny
   1554  0922							;
   1555  0922							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1556  0922		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1557  0924				   mvUpLoop2
   1558  0924							;		  lda	  LINBUF,x	 ;get a byte
   1559  0924		       bd d2 1b 	      lda	TOKENBUFFER,x	;get a byte
   1560  0927		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1561  0929
   1562  0929		       e8		      inx
   1563  092a		       ec d2 1b 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1564  092d		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1565  092f		       c8		      iny
   1566  0930		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1567  0932							;
   1568  0932		       4c b1 02    mvUpFini   jmp	NextIL
   1569  0935							;
   1570  0935							;=====================================================
   1571  0935							; Pops the top value of the ILPC stack and stores it
   1572  0935							; in ILPC.  Ie, return from an IL subroutine.
   1573  0935							;
   1574  0935		       20 e3 29    iRTN       jsr	popILPC
   1575  0938		       4c b1 02 	      jmp	NextIL
   1576  093b							;
   1577  093b							;=====================================================
   1578  093b							; NLINE print a newline
   1579  093b							;
   1580  093b		       20 f4 2c    iNLINE     jsr	CRLF	;user supplied sub
   1581  093e		       4c b1 02 	      jmp	NextIL
   1582  0941							;
   1583  0941							;=====================================================
   1584  0941							; This saves the current ILPC value on the stack, then
   1585  0941							; jumps to the address specified by the next two bytes.
   1586  0941							;
   1587  0941		       20 c6 29    iCALL      jsr	pushILPC	;save ILPC
   1588  0944		       90 07		      bcc	iJMP
   1589  0946
   1590  0946							;If the push failed not enough stack space
   1591  0946		       a2 15	   ErrILStkOver ldx	#ERR_IL_STACK_OVER_FLOW	; Flag any error in line number
   1592  0948		       a9 00		      lda	#0	; stop the execution
   1593  094a		       4c 7d 06 	      jmp	iErr2
   1594  094d							;
   1595  094d							; Jmp to a specific location in the IL code.  The new
   1596  094d							; address immediately follows the opcode.
   1597  094d							;
   1598  094d		       20 ac 29    iJMP       jsr	getILWord
   1599  0950		       86 43		      stx	ILPC
   1600  0952		       85 44		      sta	ILPC+1
   1601  0954		       4c b1 02 	      jmp	NextIL
   1602  0957
   1603  0957
   1604  0957							;
   1605  0957							;=====================================================
   1606  0957							; Push the next two bytes onto the arithmetic stack.
   1607  0957							;
   1608  0957		       20 b0 29    iSetR2     jsr	getILByte
   1609  095a		       85 58		      sta	R2
   1610  095c		       4c b1 02 	      jmp	NextIL
   1611  095f							;
   1612  095f							;=====================================================
   1613  095f							; Push the next two bytes onto the arithmetic stack.
   1614  095f							;
   1615  095f		       20 ac 29    iLIT       jsr	getILWord
   1616  0962		       86 52		      stx	R0
   1617  0964		       85 53		      sta	R0+1
   1618  0966		       20 a9 2b 	      jsr	pushR0
   1619  0969		       4c b1 02 	      jmp	NextIL
   1620  096c							;
   1621  096c							;=====================================================
   1622  096c							; Initialize all variables for a single task.	Ie, set to zero.
   1623  096c							; And internal stack pointers
   1624  096c							;
   1625  096c		       98	   subVINIT   tya
   1626  096d		       48		      pha
   1627  096e
   1628  096e		       a9 00		      lda	#0
   1629  0970		       a0 00		      ldy	#0
   1630  0972		       91 41	   Vinit2     sta	(VARIABLES),y
   1631  0974		       c8		      iny
   1632  0975		       c0 48		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1633  0977		       90 f9		      bcc	Vinit2
   1634  0979		       85 4a		      sta	MATHSTACKPTR	; Clear the math stack
   1635  097b		       85 4d		      sta	GOSUBSTACKPTR	; Clear the gosub stack
   1636  097d		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reset the message queue
   1637  097f		       85 4e		      STA	MESSAGEPTR
   1638  0981
   1639  0981		       68		      pla
   1640  0982		       a8		      tay
   1641  0983		       60		      rts
   1642  0984
   1643  0984				   iVINIT
   1644  0984		       20 6c 09 	      jsr	subVINIT
   1645  0987		       20 6c 1f 	      jsr	Compile	; compile line numbers to memory pointers
   1646  098a		       4c b1 02 	      jmp	NextIL
   1647  098d							;
   1648  098d							;=====================================================
   1649  098d							; Set the address of the error handler.  After any
   1650  098d							; error, set to the ILPC to the specified location.
   1651  098d							;
   1652  098d		       20 ac 29    iERRGOTO   jsr	getILWord
   1653  0990		       8e 74 42 	      stx	errGoto
   1654  0993		       8d 75 42 	      sta	errGoto+1
   1655  0996		       4c b1 02 	      jmp	NextIL
   1656  0999							;
   1657  0999							;=====================================================
   1658  0999							; TST is followed by an 8 bit signed offset, then a
   1659  0999							; null terminated string.  Compare the string against
   1660  0999							; the string starting at (CURPTR),CUROFF.  If the
   1661  0999							; strings match, continue executing the next IL
   1662  0999							; opcode.  Else, add the offset to ILPC.
   1663  0999							;
   1664  0999		       20 b0 29    iTST       jsr	getILByte	;Get the relative jump address
   1665  099c		       8d 7f 42 	      sta	offset	;save it to use if test faile
   1666  099f		       20 93 2b 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1667  09a2
   1668  09a2		       a4 51		      ldy	CUROFF
   1669  09a4		       84 59		      sty	dpl	;save for later
   1670  09a6							;
   1671  09a6		       20 b0 29    iTSTloop   jsr	getILByte	;get next char
   1672  09a9		       f0 11		      beq	iTSTm	;match!
   1673  09ab		       a4 59		      ldy	dpl
   1674  09ad		       d1 4f		      cmp	(CURPTR),y
   1675  09af		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1676  09b1		       09 20		      ora	#$20	; lets allow lowercase as well
   1677  09b3		       d1 4f		      cmp	(CURPTR),y
   1678  09b5		       d0 23		      bne	iTSTfail	;mismatch
   1679  09b7		       c8	   iTSTUpper  iny
   1680  09b8		       84 59		      sty	dpl
   1681  09ba		       d0 ea		      bne	iTSTloop
   1682  09bc							;
   1683  09bc							; It's a match!  Clean up a bit.
   1684  09bc							;
   1685  09bc		       a4 59	   iTSTm      ldy	dpl
   1686  09be		       84 51		      sty	CUROFF
   1687  09c0		       4c b1 02 	      jmp	NextIL
   1688  09c3
   1689  09c3							; Test for a single quote string
   1690  09c3		       20 b0 29    iTSTStr    jsr	getILByte
   1691  09c6		       8d 7f 42 	      sta	offset
   1692  09c9		       20 93 2b 	      jsr	saveIL
   1693  09cc		       a4 51		      ldy	CUROFF
   1694  09ce		       a9 22		      lda	#'"
   1695  09d0		       d1 4f		      cmp	(CURPTR),y
   1696  09d2		       d0 06		      bne	iTSTfail
   1697  09d4		       c8		      iny
   1698  09d5		       84 51		      sty	CUROFF
   1699  09d7		       4c d4 02 	      jmp	NextILStr
   1700  09da							;
   1701  09da							; Not a match, reset ILPC and then move to the
   1702  09da							; offset.
   1703  09da							;
   1704  09da		       20 9e 2b    iTSTfail   jsr	restoreIL
   1705  09dd		       4c d7 0b 	      jmp	tstBranch
   1706  09e0							;
   1707  09e0							;=================================================JLIT=
   1708  09e0							; Test if we have a let statement without the let keyword
   1709  09e0		       20 b0 29    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1710  09e3		       8d 7f 42 	      sta	offset	; Save the jump offset for fails
   1711  09e6		       20 93 2b 	      jsr	saveIL	; save to restore when done if fail
   1712  09e9
   1713  09e9		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1714  09eb		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1715  09ed		       c9 01		      cmp	#kLet	; Is it a let keyword
   1716  09ef		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1717  09f1		       c9 80		      cmp	#tVa	; lets check for a variable
   1718  09f3		       90 e5		      bcc	iTSTfail	; Less than variable range
   1719  09f5		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1720  09f7		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1721  09f9		       b0 df		      bcs	iTSTfail	; return it failed
   1722  09fb
   1723  09fb				   iTSTLETGOOD
   1724  09fb		       c8		      iny
   1725  09fc		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1726  09fe				   iTSTGOODVAR
   1727  09fe		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1728  0a01
   1729  0a01							;=================================================JLIT=
   1730  0a01							; Test a byte at an indirect address
   1731  0a01							; fails if byte is not equal to the value at the address
   1732  0a01							; The tests an indirect byte and branches if true
   1733  0a01		       20 b0 29    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1734  0a04		       8d 7f 42 	      sta	offset	; Save the jump offset for fails
   1735  0a07		       20 93 2b 	      jsr	saveIL	; save to restore when done if fail
   1736  0a0a		       20 ac 29 	      jsr	getILWord	; Get a word into RO
   1737  0a0d		       86 52		      stx	R0
   1738  0a0f		       85 53		      sta	R0+1
   1739  0a11		       20 b0 29 	      jsr	getILByte	; Get byte into A
   1740  0a14		       a0 00		      ldy	#0
   1741  0a16		       d1 52		      cmp	(R0),y
   1742  0a18		       d0 03		      bne	iTSTByteNotEqual
   1743  0a1a		       4c da 09 	      jmp	iTSTfail
   1744  0a1d
   1745  0a1d				   iTSTByteNotEqual
   1746  0a1d		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1747  0a20
   1748  0a20							;=================================================JLIT=
   1749  0a20							; Test a byte	branch if it fails
   1750  0a20		       20 b0 29    iTSTB      jsr	getILByte	; Get the relative offset byte
   1751  0a23		       8d 7f 42 	      sta	offset	; Save the jump offset for fails
   1752  0a26		       20 93 2b 	      jsr	saveIL	; save to restore when done if fail
   1753  0a29		       20 b0 29 	      jsr	getILByte	; Get a byte into Acc
   1754  0a2c		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1755  0a2e		       d1 4f		      cmp	(CURPTR),y
   1756  0a30		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1757  0a32		       4c da 09 	      jmp	iTSTfail	; REcover and move on to next test
   1758  0a35
   1759  0a35				   iTSTBMatch
   1760  0a35		       c8		      iny
   1761  0a36		       84 51		      sty	CUROFF	; Point to the next byte
   1762  0a38		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1763  0a3b
   1764  0a3b							;=================================================JLIT=
   1765  0a3b							; Test a byte	branch if it fails
   1766  0a3b		       20 b0 29    iTSTW      jsr	getILByte	; Get the relative offset byte
   1767  0a3e		       8d 7f 42 	      sta	offset	; Save the jump offset for fails
   1768  0a41		       20 93 2b 	      jsr	saveIL	; save to restore when done if fail
   1769  0a44		       20 ac 29 	      jsr	getILWord	; Get a word into RO
   1770  0a47		       86 52		      stx	R0
   1771  0a49		       85 53		      sta	R0+1
   1772  0a4b		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1773  0a4d		       8a		      txa
   1774  0a4e		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1775  0a50		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1776  0a52		       4c da 09 	      jmp	iTSTfail	; REcover and move on to next test
   1777  0a55		       c8	   iTSTWM1    iny
   1778  0a56		       a5 53		      lda	R0+1
   1779  0a58		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1780  0a5a		       f0 03		      beq	iTSTWMatch
   1781  0a5c		       4c da 09 	      jmp	iTSTfail
   1782  0a5f
   1783  0a5f				   iTSTWMatch
   1784  0a5f		       c8		      iny
   1785  0a60		       84 51		      sty	CUROFF
   1786  0a62		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1787  0a65
   1788  0a65							;================================================jLIT=
   1789  0a65							;Test for end of line
   1790  0a65							;
   1791  0a65				   iTSTDONE
   1792  0a65		       20 b0 29 	      jsr	getILByte
   1793  0a68		       8d 7f 42 	      sta	offset
   1794  0a6b		       20 93 2b 	      jsr	saveIL
   1795  0a6e		       a4 51		      ldy	CUROFF
   1796  0a70		       84 59		      sty	dpl
   1797  0a72		       b1 4f		      lda	(CURPTR),y
   1798  0a74		       f0 0b		      beq	iTSTDONEtrue
   1799  0a76		       c9 e6		      cmp	#oColon
   1800  0a78		       f0 07		      beq	iTSTDONEtrue
   1801  0a7a		       a4 59		      ldy	dpl
   1802  0a7c		       84 51		      sty	CUROFF
   1803  0a7e		       4c da 09 	      jmp	iTSTfail
   1804  0a81							;
   1805  0a81							; Advance to the next line
   1806  0a81							;
   1807  0a81				   iTSTDONEtrue
   1808  0a81		       4c b1 02 	      jmp	NextIL
   1809  0a84
   1810  0a84		       4c d7 0b    tstBranchLink jmp	tstBranch
   1811  0a87							;
   1812  0a87							;=====================================================
   1813  0a87							; Inc and dec a variable , faster than a = a + 1
   1814  0a87				   iINCVAR
   1815  0a87		       20 3b 2c 	      jsr	popR0
   1816  0a8a		       a0 00		      ldy	#0
   1817  0a8c		       18		      clc
   1818  0a8d		       a9 01		      lda	#1
   1819  0a8f		       71 52		      adc	(R0),y
   1820  0a91		       91 52		      sta	(R0),y
   1821  0a93		       90 07		      bcc	iINCDONE
   1822  0a95		       c8		      iny
   1823  0a96		       a9 00		      lda	#0
   1824  0a98		       71 52		      adc	(R0),y
   1825  0a9a		       91 52		      sta	(R0),y
   1826  0a9c				   iINCDONE
   1827  0a9c		       4c b1 02 	      jmp	NextIL
   1828  0a9f
   1829  0a9f				   iDECVAR
   1830  0a9f		       20 3b 2c 	      jsr	popR0
   1831  0aa2		       a0 00		      ldy	#0
   1832  0aa4		       38		      sec
   1833  0aa5		       b1 52		      lda	(R0),y
   1834  0aa7		       e9 01		      sbc	#1
   1835  0aa9		       91 52		      sta	(R0),y
   1836  0aab		       c8		      iny
   1837  0aac		       b1 52		      lda	(R0),y
   1838  0aae		       e9 00		      sbc	#0
   1839  0ab0		       91 52		      sta	(R0),y
   1840  0ab2		       4c b1 02 	      jmp	NextIL
   1841  0ab5
   1842  0ab5
   1843  0ab5							;
   1844  0ab5							;=====================================================
   1845  0ab5							; TSTV is followed by an 8 bit signed offset.	If the
   1846  0ab5							; value at (CURPTR),CUROFF appears to be a variable
   1847  0ab5							; name, move to the next IL statement.  Else, add the
   1848  0ab5							; offset to ILPC. Converted to use actual absolute memory addresses
   1849  0ab5							; TSTVT Looks for the task context
   1850  0ab5							;
   1851  0ab5		       20 53 2c    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1852  0ab8		       a9 00		      lda	#0
   1853  0aba		       85 58		      sta	R2
   1854  0abc		       f0 04		      beq	iTSTVV
   1855  0abe
   1856  0abe							; Test for simple variable
   1857  0abe		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1858  0ac0		       85 58		      sta	R2
   1859  0ac2
   1860  0ac2		       20 b0 29    iTSTVV     jsr	getILByte	;offset
   1861  0ac5		       8d 7f 42 	      sta	offset
   1862  0ac8							;
   1863  0ac8		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1864  0aca		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1865  0acc		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1866  0ace		       4c 84 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1867  0ad1							;
   1868  0ad1				   iTSTVnext
   1869  0ad1		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1870  0ad3		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1871  0ad5
   1872  0ad5		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1873  0ad7		       f0 5b		      beq	iTSTVParm
   1874  0ad9
   1875  0ad9		       c9 9b		      cmp	#tVhat	; task exit code
   1876  0adb		       d0 04		      bne	iTSTV_A2Z
   1877  0add		       a9 48		      lda	#TASKEXITCODE
   1878  0adf		       d0 0b		      bne	iTSTVContinue
   1879  0ae1
   1880  0ae1				   iTSTV_A2Z
   1881  0ae1
   1882  0ae1		       c9 80		      cmp	#tVa
   1883  0ae3		       90 9f		      bcc	tstBranchLink
   1884  0ae5		       c9 9a		      cmp	#tVz+1
   1885  0ae7		       b0 9b		      bcs	tstBranchLink
   1886  0ae9
   1887  0ae9
   1888  0ae9							;
   1889  0ae9							; The condition is true, so convert to an index, push
   1890  0ae9							; it onto the stack and continue running.
   1891  0ae9							;
   1892  0ae9		       29 7f		      and	#%01111111	; Mask off the high bit
   1893  0aeb		       0a		      asl		; multiply by two
   1894  0aec
   1895  0aec				   iTSTVContinue
   1896  0aec		       c8		      iny
   1897  0aed		       84 51		      sty	CUROFF	; it is a valid variable
   1898  0aef		       48		      pha		; save the last variable pointer value
   1899  0af0		       a5 58		      lda	R2
   1900  0af2		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1901  0af4
   1902  0af4		       20 85 29 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1903  0af7		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1904  0af9
   1905  0af9		       68		      pla		; We have an invalid pid for getting variable value
   1906  0afa		       a2 10		      ldx	#ERR_INVALID_PID
   1907  0afc		       a9 00		      lda	#0
   1908  0afe		       4c 7d 06 	      jmp	iErr2
   1909  0b01
   1910  0b01				   iTSTVGOODPID
   1911  0b01		       20 6d 29 	      jsr	ipc_getcontext	; Get the other tasks variables
   1912  0b04		       a0 01		      ldy	#VARIABLEPOS
   1913  0b06		       b1 56		      lda	(MQ),y
   1914  0b08		       85 52		      sta	R0
   1915  0b0a		       c8		      iny
   1916  0b0b		       b1 56		      lda	(MQ),y
   1917  0b0d		       85 53		      sta	R0+1
   1918  0b0f		       4c 1a 0b 	      jmp	iTSTVAddOffset
   1919  0b12
   1920  0b12				   iTSTVLocalValue
   1921  0b12		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1922  0b14		       85 52		      sta	R0
   1923  0b16		       a5 42		      lda	VARIABLES+1
   1924  0b18		       85 53		      sta	R0+1
   1925  0b1a
   1926  0b1a				   iTSTVAddOffset
   1927  0b1a		       68		      pla
   1928  0b1b		       85 54		      sta	R1
   1929  0b1d		       a9 00		      lda	#0
   1930  0b1f		       85 55		      sta	R1+1
   1931  0b21
   1932  0b21				   iTSTVcontinue
   1933  0b21
   1934  0b21		       4c 9e 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1935  0b24
   1936  0b24							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1937  0b24							; an array of integer values or byte.
   1938  0b24				   iTSTVat
   1939  0b24		       c8		      iny
   1940  0b25		       84 51		      sty	CUROFF	;it is a valid variable
   1941  0b27		       ad 85 42 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1942  0b2a		       85 52		      sta	R0
   1943  0b2c		       ad 86 42 	      lda	ProgramEnd+1
   1944  0b2f		       85 53		      sta	R0+1
   1945  0b31		       4c 16 07 	      jmp	pushR0nextIl	;place this onto the stack
   1946  0b34
   1947  0b34							; When we get parameters passed we can access them using the # variable with[]
   1948  0b34							; example #[0] #[1] etc, we dont check yet if there is too many
   1949  0b34		       c8	   iTSTVParm  iny
   1950  0b35		       84 51		      sty	CUROFF	;it is a valid variable
   1951  0b37
   1952  0b37							; upon return the y register  point to the gosub Parms entry value entry
   1953  0b37		       20 3d 25 	      jsr	GosubFindParms
   1954  0b3a		       90 21		      bcc	iTSTMissingParms
   1955  0b3c
   1956  0b3c		       88		      dey
   1957  0b3d		       88		      dey
   1958  0b3e		       88		      dey		;Point to the actual index of first parameter in math stack
   1959  0b3f
   1960  0b3f		       a5 48		      lda	MATHSTACK
   1961  0b41		       85 52		      sta	R0
   1962  0b43		       a5 49		      lda	MATHSTACK+1
   1963  0b45		       85 53		      sta	R0+1
   1964  0b47		       b1 4b		      lda	(GOSUBSTACK),y	; Get the correct Offset to start of parameters
   1965  0b49		       f0 0b		      beq	iTSTVindex0	; no math if no offset
   1966  0b4b		       18		      clc
   1967  0b4c		       65 52		      adc	R0	; Point to the actual address that the variables start, not just top of stack
   1968  0b4e		       85 52		      sta	R0
   1969  0b50		       a9 00		      lda	#0
   1970  0b52		       65 53		      adc	R0+1
   1971  0b54		       85 53		      sta	R0+1
   1972  0b56				   iTSTVindex0
   1973  0b56		       a9 81		      lda	#GOSUB_RTN_VALUE
   1974  0b58		       85 58		      sta	R2	; Set the data type as a parameter to a function
   1975  0b5a		       4c 16 07 	      jmp	pushR0nextIl
   1976  0b5d
   1977  0b5d
   1978  0b5d				   iTSTMissingParms
   1979  0b5d		       a9 00		      lda	#0
   1980  0b5f		       a2 19		      ldx	#ERR_FUNCTION_EXPECTED_PARAMETERS
   1981  0b61		       4c 7d 06 	      jmp	iErr2
   1982  0b64
   1983  0b64							;
   1984  0b64							;=====================================================
   1985  0b64							; TSTL seems basically the same as TSTN, but leave the
   1986  0b64							; value in R0 instead of pushing onto stack.
   1987  0b64							; This tests for a valid line number
   1988  0b64							;
   1989  0b64		       20 b0 29    iTSTL      jsr	getILByte
   1990  0b67		       8d 7f 42 	      sta	offset
   1991  0b6a							;
   1992  0b6a		       a4 51		      ldy	CUROFF
   1993  0b6c		       b1 4f		      lda	(CURPTR),y
   1994  0b6e		       c8		      iny
   1995  0b6f		       11 4f		      ora	(CURPTR),y
   1996  0b71		       f0 06		      beq	iTSTLNotLineNo
   1997  0b73
   1998  0b73
   1999  0b73							; In Both cases we need to point to the first usefull byte to process.
   2000  0b73		       c8		      iny
   2001  0b74		       84 51		      sty	CUROFF
   2002  0b76		       4c b1 02 	      jmp	NextIL
   2003  0b79				   iTSTLNotLineNo
   2004  0b79		       c8		      iny
   2005  0b7a		       84 51		      sty	CUROFF
   2006  0b7c		       4c d7 0b 	      jmp	tstBranch
   2007  0b7f
   2008  0b7f							;
   2009  0b7f							;=====================================================
   2010  0b7f							; TSTN checks for a number.  This is very simplistic;
   2011  0b7f							; if the character is a digit, assume it's a number.
   2012  0b7f							; Convert to a number and push it onto the stack.
   2013  0b7f							;
   2014  0b7f		       20 b0 29    iTSTN      jsr	getILByte
   2015  0b82		       8d 7f 42 	      sta	offset
   2016  0b85							;
   2017  0b85		       a9 00		      lda	#0
   2018  0b87		       85 59		      sta	dpl
   2019  0b89		       a4 51		      ldy	CUROFF
   2020  0b8b				   chkType
   2021  0b8b		       b1 4f		      lda	(CURPTR),y
   2022  0b8d		       c9 a2		      cmp	#tByte
   2023  0b8f		       f0 0e		      beq	chkByte
   2024  0b91		       c9 a4		      cmp	#tInteger
   2025  0b93		       f0 16		      beq	chkInteger
   2026  0b95		       c9 eb		      cmp	#oMinus
   2027  0b97		       d0 3e		      bne	tstBranch
   2028  0b99		       e6 59		      inc	dpl
   2029  0b9b		       c8		      iny
   2030  0b9c		       4c 8b 0b 	      jmp	chkType
   2031  0b9f
   2032  0b9f				   chkByte
   2033  0b9f		       a9 00		      lda	#0
   2034  0ba1		       85 53		      sta	R0+1
   2035  0ba3		       c8		      iny
   2036  0ba4		       b1 4f		      lda	(CURPTR),y
   2037  0ba6		       85 52		      sta	R0
   2038  0ba8		       c8		      iny
   2039  0ba9		       d0 0b		      bne	iTSTN_1
   2040  0bab
   2041  0bab				   chkInteger
   2042  0bab		       c8		      iny
   2043  0bac		       b1 4f		      lda	(CURPTR),y
   2044  0bae		       85 52		      sta	R0
   2045  0bb0		       c8		      iny
   2046  0bb1		       b1 4f		      lda	(CURPTR),y
   2047  0bb3		       85 53		      sta	R0+1
   2048  0bb5		       c8		      iny
   2049  0bb6							;
   2050  0bb6							; Check if it is negative and make it so
   2051  0bb6							;
   2052  0bb6				   iTSTN_1
   2053  0bb6		       84 51		      sty	CUROFF
   2054  0bb8
   2055  0bb8		       a5 59		      lda	dpl
   2056  0bba		       f0 18		      beq	iTSTN_2	;positive
   2057  0bbc							;
   2058  0bbc		       a5 52		      lda	R0
   2059  0bbe		       05 53		      ora	R0+1
   2060  0bc0		       f0 12		      beq	iTSTN_2	;zero
   2061  0bc2
   2062  0bc2							; Invert all the bits, then add one.
   2063  0bc2							;
   2064  0bc2		       a5 52		      lda	R0
   2065  0bc4		       49 ff		      eor	#$ff
   2066  0bc6		       85 52		      sta	R0
   2067  0bc8		       a5 53		      lda	R0+1
   2068  0bca		       49 ff		      eor	#$ff
   2069  0bcc		       85 53		      sta	R0+1
   2070  0bce							;
   2071  0bce		       e6 52		      inc	R0
   2072  0bd0		       d0 02		      bne	iTSTN_2
   2073  0bd2		       e6 53		      inc	R0+1
   2074  0bd4				   iTSTN_2
   2075  0bd4		       4c 16 07 	      jmp	pushR0nextIl	;save onto stack
   2076  0bd7
   2077  0bd7							;
   2078  0bd7							; Common jump point for all TSTx instructions that
   2079  0bd7							; fail to meet the requirements.  This takes the
   2080  0bd7							; offset and adds/subtracts to/from ILPC.
   2081  0bd7							;
   2082  0bd7		       ad 7f 42    tstBranch  lda	offset	;get signed offset
   2083  0bda		       10 0e		      bpl	tstPositive
   2084  0bdc							;
   2085  0bdc							; Do negative branch.	Do sign extension.
   2086  0bdc							;
   2087  0bdc		       18	   tstNegative clc
   2088  0bdd		       65 43		      adc	ILPC
   2089  0bdf		       85 43		      sta	ILPC
   2090  0be1							;		  bcc	  tstBothDone
   2091  0be1							;		  dec	  ILPC+1
   2092  0be1							;		  jmp	  NextIL
   2093  0be1
   2094  0be1		       a5 44		      lda	ILPC+1
   2095  0be3		       69 ff		      adc	#$ff
   2096  0be5		       85 44		      sta	ILPC+1
   2097  0be7		       4c b1 02 	      jmp	NextIL	;keep going
   2098  0bea							;
   2099  0bea		       18	   tstPositive clc
   2100  0beb		       65 43		      adc	ILPC
   2101  0bed		       85 43		      sta	ILPC
   2102  0bef		       90 02		      bcc	tstBothDone
   2103  0bf1		       e6 44		      inc	ILPC+1
   2104  0bf3				   tstBothDone
   2105  0bf3		       4c b1 02 	      jmp	NextIL
   2106  0bf6
   2107  0bf6							;
   2108  0bf6							;====================================================
   2109  0bf6							; Test for IRQ pending, and test if a break key pressed
   2110  0bf6							; Yes I know but this handles all sorts of irq/break issues
   2111  0bf6							;
   2112  0bf6		       20 b0 29    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2113  0bf9		       8d 7f 42 	      sta	offset	; Store the not true jump address offset
   2114  0bfc		       ad 56 19    irqNo      lda	IRQPending	; Check if the pending value is set
   2115  0bff		       f0 20		      beq	tstBreak	; if no irq then check for an escape key pressed
   2116  0c01		       c9 01		      cmp	#1	; only do this if set to first time
   2117  0c03		       d0 1c		      bne	tstBreak	; We are in a irq service already
   2118  0c05				   iTSTProcessIRQ
   2119  0c05		       78		      sei		; disable the interupt until ireturn resets it
   2120  0c06		       ee 56 19 	      inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2121  0c09		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2122  0c0b		       20 c3 2b 	      jsr	pushLN	; Push the next line to be executed
   2123  0c0e		       b0 21		      bcs	ErrStkOver	; Check if there was an error
   2124  0c10		       ad 57 19 	      lda	IRQEntry	; Get the line number to branch to
   2125  0c13		       85 4f		      sta	CURPTR	; put line number into r0
   2126  0c15		       ad 58 19 	      lda	IRQEntry+1
   2127  0c18		       85 50		      sta	CURPTR+1
   2128  0c1a		       a9 03		      lda	#3	; Point to first byte of program text
   2129  0c1c		       85 51		      sta	CUROFF
   2130  0c1e		       4c b1 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2131  0c21
   2132  0c21				   tstBreak
   2133  0c21		       20 67 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2134  0c24		       d0 b1		      bne	tstBranch	; z not set of no break found
   2135  0c26		       ad 81 42 	      lda	taskIOPending
   2136  0c29		       f0 03		      beq	tstBrkComplete
   2137  0c2b		       ce 81 42 	      dec	taskIOPending
   2138  0c2e		       4c 02 06    tstBrkComplete jmp	iFIN	; Exit out of run mode
   2139  0c31
   2140  0c31		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2141  0c33		       a9 00		      lda	#0	; stop the execution
   2142  0c35		       4c 7d 06 	      jmp	iErr2
   2143  0c38							;
   2144  0c38
   2145  0c38							;=====================================================
   2146  0c38							; This places the number of free bytes on top of the
   2147  0c38							; stack.
   2148  0c38							;
   2149  0c38		       20 4b 23    iFREE      jsr	MemFree
   2150  0c3b		       4c 16 07 	      jmp	pushR0nextIl
   2151  0c3e							;
   2152  0c3e							;=====================================================
   2153  0c3e							; Generate a random number from 0-FFFF and then MOD
   2154  0c3e							; it with the value on top of stack.  Leaves number on
   2155  0c3e							; stack
   2156  0c3e							;
   2157  0c3e		       20 53 2c    iRANDOM    jsr	popR1	;mod value
   2158  0c41							;
   2159  0c41							; If the value is zero, just return a one.
   2160  0c41							;
   2161  0c41		       a5 54		      lda	R1
   2162  0c43		       05 55		      ora	R1+1
   2163  0c45		       f0 4a		      beq	irandom1
   2164  0c47							;
   2165  0c47		       ad 7a 42 	      lda	random+1
   2166  0c4a		       8d 77 42 	      sta	rtemp1
   2167  0c4d		       ad 79 42 	      lda	random
   2168  0c50		       0a		      asl
   2169  0c51		       2e 77 42 	      rol	rtemp1
   2170  0c54		       0a		      asl
   2171  0c55		       2e 77 42 	      rol	rtemp1
   2172  0c58		       18		      clc
   2173  0c59		       6d 79 42 	      adc	random
   2174  0c5c
   2175  0c5c		       48		      pha
   2176  0c5d
   2177  0c5d		       ad 77 42 	      lda	rtemp1
   2178  0c60		       6d 7a 42 	      adc	random+1
   2179  0c63		       8d 7a 42 	      sta	random+1
   2180  0c66
   2181  0c66		       68		      pla
   2182  0c67
   2183  0c67		       69 11		      adc	#$11
   2184  0c69		       8d 79 42 	      sta	random
   2185  0c6c		       ad 7a 42 	      lda	random+1
   2186  0c6f		       69 36		      adc	#$36
   2187  0c71		       8d 7a 42 	      sta	random+1
   2188  0c74
   2189  0c74		       ad 79 42 	      lda	random
   2190  0c77		       85 52		      sta	R0
   2191  0c79		       ad 7a 42 	      lda	random+1
   2192  0c7c		       29 7f		      and	#$7f	;make positive
   2193  0c7e		       85 53		      sta	R0+1
   2194  0c80							;
   2195  0c80							; R0 contains the number and R1 contains the max value.
   2196  0c80							;
   2197  0c80		       20 3c 07 	      jsr	iDivNoPop
   2198  0c83		       20 bc 2c 	      jsr	RestoreSigns
   2199  0c86		       a5 56		      lda	MQ
   2200  0c88		       85 52		      sta	R0
   2201  0c8a		       a5 57		      lda	MQ+1
   2202  0c8c		       85 53		      sta	R0+1
   2203  0c8e		       4c 16 07 	      jmp	pushR0nextIl
   2204  0c91				   irandom1
   2205  0c91		       a9 00		      lda	#0
   2206  0c93		       85 53		      sta	R0+1
   2207  0c95		       a9 01		      lda	#1
   2208  0c97		       85 52		      sta	R0
   2209  0c99		       4c 16 07 	      jmp	pushR0nextIl
   2210  0c9c
   2211  0c9c							; The following replaced by call to division/modulo
   2212  0c9c							;iRANDOM_2	lda	R0
   2213  0c9c							;		cmp	R1
   2214  0c9c							;		bne	iRANDOM_1
   2215  0c9c							;		lda	R0+1
   2216  0c9c							;		cmp	R1+1
   2217  0c9c							;		bne	iRANDOM_1	;need to subtract
   2218  0c9c							;
   2219  0c9c							; Subtract R1 from R0
   2220  0c9c							;
   2221  0c9c							;iRANDOM_sub	sec
   2222  0c9c							;		lda	R0
   2223  0c9c							;		sbc	R1
   2224  0c9c							;		sta	R0
   2225  0c9c							;		lda	R0+1
   2226  0c9c							;		sbc	R1+1
   2227  0c9c							;		sta	R0+1
   2228  0c9c							;		jmp	iRANDOM_2
   2229  0c9c							;
   2230  0c9c							; See if R1 > R0.  If so, branch to subtract.
   2231  0c9c							;
   2232  0c9c							;iRANDOM_1	lda	R0
   2233  0c9c							;		cmp	R1
   2234  0c9c							;		lda	R0+1
   2235  0c9c							;		sbc	R1+1
   2236  0c9c							;		bvc	iRANDOM_4
   2237  0c9c							;		eor	#$80
   2238  0c9c							;iRANDOM_4	bpl	iRANDOM_sub
   2239  0c9c							;
   2240  0c9c							; All done.  Almost.  Add one, then push the result.
   2241  0c9c							;
   2242  0c9c							;irandom1	inc	R0
   2243  0c9c							;		bne	iRANDOM_3
   2244  0c9c							;		inc	R0+1
   2245  0c9c							;iRANDOM_3
   2246  0c9c							;		  jsr	pushR0	;return value
   2247  0c9c							;		jmp	NextIL
   2248  0c9c							;
   2249  0c9c							; Poke a value into a memory location
   2250  0c9c		       8c 7b 42    iPOKEMEMORY sty	tempy
   2251  0c9f		       20 3b 2c 	      jsr	popR0
   2252  0ca2		       20 53 2c 	      jsr	popR1
   2253  0ca5		       a0 00		      ldy	#0
   2254  0ca7		       a5 52		      lda	R0
   2255  0ca9		       91 54		      sta	(R1),y
   2256  0cab		       ac 7b 42 	      ldy	tempy
   2257  0cae		       4c b1 02 	      jmp	NextIL
   2258  0cb1							;
   2259  0cb1							; Get a value from a memory location
   2260  0cb1							;
   2261  0cb1		       8c 7b 42    iPEEKMEMORY sty	tempy
   2262  0cb4		       20 3b 2c 	      jsr	popR0
   2263  0cb7		       a0 00		      ldy	#0
   2264  0cb9		       b1 52		      lda	(R0),y
   2265  0cbb		       ac 7b 42 	      ldy	tempy
   2266  0cbe		       85 52		      sta	R0
   2267  0cc0		       a9 00		      lda	#0
   2268  0cc2		       85 53		      sta	R0+1
   2269  0cc4		       4c 16 07 	      jmp	pushR0nextIl
   2270  0cc7							;
   2271  0cc7							; Call to address return what ever is in a to the stack
   2272  0cc7							; func2 will load a value into a before the call
   2273  0cc7		       20 53 2c    iCallFunc  jsr	popR1
   2274  0cca		       a5 54		      lda	R1
   2275  0ccc		       20 d8 0c 	      jsr	iCallRtn
   2276  0ccf		       85 52		      sta	R0
   2277  0cd1		       a9 00		      lda	#0
   2278  0cd3		       85 53		      sta	R0+1
   2279  0cd5		       20 16 07 	      jsr	pushR0nextIl
   2280  0cd8				   iCallRtn
   2281  0cd8		       20 3b 2c 	      jsr	popR0
   2282  0cdb		       6c 52 00 	      jmp	(R0)
   2283  0cde
   2284  0cde
   2285  0cde							;===========================================jlit======
   2286  0cde							;Get a character from the terminal convert to value
   2287  0cde							;leave the number on top of the stack
   2288  0cde							;
   2289  0cde				   iGETCHAR
   2290  0cde		       20 e6 19 	      jsr	VGETCH
   2291  0ce1					      if	CTMON65
   2292  0ce1		       48		      pha
   2293  0ce2		       20 e3 19 	      jsr	VOUTCH	;echo echo echo
   2294  0ce5		       68		      pla
   2295  0ce6					      endif
   2296  0ce6		       85 52		      sta	R0
   2297  0ce8		       a9 00		      lda	#0
   2298  0cea		       85 53		      sta	R0+1
   2299  0cec		       20 a9 2b 	      jsr	pushR0
   2300  0cef							;
   2301  0cef		       4c b1 02 	      jmp	NextIL
   2302  0cf2							;===========================================jusilostintim======
   2303  0cf2							;Put a character to the terminal convert to
   2304  0cf2							;
   2305  0cf2		       20 3b 2c    iPUTCHAR   jsr	popR0
   2306  0cf5		       a5 52		      lda	R0
   2307  0cf7		       20 e3 19 	      jsr	VOUTCH
   2308  0cfa		       4c b1 02 	      jmp	NextIL
   2309  0cfd							;=====================================================
   2310  0cfd							; Put the number on the stack out as hex, suppress leading 0
   2311  0cfd				   iHexOut
   2312  0cfd		       20 3b 2c 	      jsr	popR0
   2313  0d00		       a5 53		      lda	R0+1
   2314  0d02		       f0 03		      beq	iHexSecondByte
   2315  0d04		       20 15 21 	      jsr	OUTHEX
   2316  0d07				   iHexSecondByte
   2317  0d07		       a5 52		      lda	R0
   2318  0d09		       20 15 21 	      jsr	OUTHEX
   2319  0d0c		       4c b1 02 	      jmp	NextIL
   2320  0d0f							;
   2321  0d0f							;=====================================================
   2322  0d0f							; Replace TOS with its absolute value.
   2323  0d0f							;
   2324  0d0f		       20 3b 2c    iABS       jsr	popR0
   2325  0d12		       a5 53		      lda	R0+1
   2326  0d14		       10 10		      bpl	iABS_1	;already positive
   2327  0d16		       49 ff		      eor	#$ff
   2328  0d18		       85 53		      sta	R0+1
   2329  0d1a		       a5 52		      lda	R0
   2330  0d1c		       49 ff		      eor	#$ff
   2331  0d1e		       85 52		      sta	R0
   2332  0d20		       e6 52		      inc	R0
   2333  0d22		       d0 02		      bne	iABS_1
   2334  0d24		       e6 53		      inc	R0+1
   2335  0d26		       4c 16 07    iABS_1     jmp	pushR0nextIl
   2336  0d29
   2337  0d29							;
   2338  0d29							;================================================================
   2339  0d29							; The set of logical operators
   2340  0d29				   iLogAnd
   2341  0d29		       20 3b 2c 	      jsr	popR0
   2342  0d2c		       20 53 2c 	      jsr	popR1
   2343  0d2f		       a5 52		      lda	R0
   2344  0d31		       25 54		      and	R1
   2345  0d33		       85 52		      sta	R0
   2346  0d35		       a5 53		      lda	R0+1
   2347  0d37		       25 55		      and	R1+1
   2348  0d39		       85 53		      sta	R0+1
   2349  0d3b		       4c 16 07 	      jmp	pushR0nextIl
   2350  0d3e				   iLogOr
   2351  0d3e		       20 3b 2c 	      jsr	popR0
   2352  0d41		       20 53 2c 	      jsr	popR1
   2353  0d44		       a5 52		      lda	R0
   2354  0d46		       05 54		      ora	R1
   2355  0d48		       85 52		      sta	R0
   2356  0d4a		       a5 53		      lda	R0+1
   2357  0d4c		       05 55		      ora	R1+1
   2358  0d4e		       85 53		      sta	R0+1
   2359  0d50		       4c 16 07 	      jmp	pushR0nextIl
   2360  0d53				   iLogXor
   2361  0d53		       20 3b 2c 	      jsr	popR0
   2362  0d56		       20 53 2c 	      jsr	popR1
   2363  0d59		       a5 52		      lda	R0
   2364  0d5b		       45 54		      eor	R1
   2365  0d5d		       85 52		      sta	R0
   2366  0d5f		       a5 53		      lda	R0+1
   2367  0d61		       45 55		      eor	R1+1
   2368  0d63		       85 53		      sta	R0+1
   2369  0d65		       4c 16 07 	      jmp	pushR0nextIl
   2370  0d68				   iLogNot
   2371  0d68		       20 3b 2c 	      jsr	popR0
   2372  0d6b		       a5 52		      lda	R0
   2373  0d6d		       49 ff		      eor	#$FF
   2374  0d6f		       85 52		      sta	R0
   2375  0d71		       a5 53		      lda	R0+1
   2376  0d73		       49 ff		      eor	#$FF
   2377  0d75		       85 53		      sta	R0+1
   2378  0d77		       4c 16 07 	      jmp	pushR0nextIl
   2379  0d7a
   2380  0d7a				   iTruth
   2381  0d7a		       a9 ff		      lda	#$FF
   2382  0d7c		       85 52		      sta	R0
   2383  0d7e		       85 53		      sta	R0+1
   2384  0d80		       4c 16 07 	      jmp	pushR0nextIl
   2385  0d83				   iFalse
   2386  0d83		       a9 00		      lda	#$00
   2387  0d85		       85 52		      sta	R0
   2388  0d87		       85 53		      sta	R0+1
   2389  0d89		       4c 16 07 	      jmp	pushR0nextIl
   2390  0d8c							;===============================================================
   2391  0d8c							;Shift instruction right 1, left 0
   2392  0d8c							;
   2393  0d8c		       8a	   iShift     txa
   2394  0d8d		       48		      pha
   2395  0d8e		       20 3b 2c 	      jsr	popR0	; number of places to shift 0 to 16 really
   2396  0d91		       20 53 2c 	      jsr	popR1	; value to shift
   2397  0d94		       a6 52		      ldx	R0	; get number of times to shift
   2398  0d96		       20 b0 29 	      jsr	getILByte	; get direction to shift
   2399  0d99		       c9 01		      cmp	#1	; Should we be doing left
   2400  0d9b		       f0 0a		      beq	iShiftRight
   2401  0d9d							;
   2402  0d9d							; Shift r1 left n bits
   2403  0d9d				   iShiftLeft
   2404  0d9d		       18	   iShiftLloop clc
   2405  0d9e		       26 54		      rol	R1
   2406  0da0		       26 55		      rol	R1+1
   2407  0da2		       ca		      dex
   2408  0da3		       d0 f8		      bne	iShiftLloop
   2409  0da5		       f0 07		      beq	iShiftExit
   2410  0da7							;
   2411  0da7							; Shift R1 right n bits
   2412  0da7							;
   2413  0da7				   iShiftRight
   2414  0da7		       46 55	   iShiftRloop lsr	R1+1
   2415  0da9		       46 54		      lsr	R1
   2416  0dab		       ca		      dex
   2417  0dac		       d0 f9		      bne	iShiftRloop
   2418  0dae				   iShiftExit
   2419  0dae		       68		      pla
   2420  0daf		       aa		      tax
   2421  0db0		       20 21 2c 	      jsr	pushR1
   2422  0db3		       4c b1 02 	      jmp	NextIL
   2423  0db6
   2424  0db6							;================================================================
   2425  0db6							;Set the IRQ service rtn line number
   2426  0db6							;
   2427  0db6		       78	   iSetIrq    sei		; disable the interupts
   2428  0db7		       a9 00		      lda	#0	; Zero the Status flag
   2429  0db9		       8d 55 19 	      sta	IRQStatus
   2430  0dbc		       20 3b 2c 	      jsr	popR0	; get the line number
   2431  0dbf		       a5 52		      lda	R0
   2432  0dc1		       05 53		      ora	R0+1
   2433  0dc3		       f0 22		      beq	iSetExt	; if it is zero disable all
   2434  0dc5		       a9 01		      lda	#GOSUB_RTN	; default push type
   2435  0dc7		       20 c3 2b 	      jsr	pushLN	; Save the current line pointer
   2436  0dca		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2437  0dcc		       4c 31 0c 	      jmp	ErrStkOver	; Check if there was an error
   2438  0dcf				   iSetIrqOk
   2439  0dcf		       20 f5 29 	      jsr	findLine	; Find the IRQ func Line Pointer
   2440  0dd2		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2441  0dd4		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2442  0dd6		       8d 58 19 	      sta	IRQEntry+1
   2443  0dd9		       a5 4f		      lda	CURPTR
   2444  0ddb		       8d 57 19 	      sta	IRQEntry
   2445  0dde		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2446  0de0		       8d 55 19 	      sta	IRQStatus
   2447  0de3		       20 ec 2b 	      jsr	popLN	; Restore the old line number
   2448  0de6		       58		      cli		; Enable the interupts
   2449  0de7		       4c b1 02    iSetExt    jmp	NextIL
   2450  0dea
   2451  0dea		       20 ec 2b    iSetIrqErr jsr	popLN
   2452  0ded		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2453  0def		       a9 00		      lda	#0
   2454  0df1		       4c 7d 06 	      jmp	iErr2
   2455  0df4							;
   2456  0df4		       20 3b 2c    iTRACEPROG jsr	popR0
   2457  0df7		       a5 52		      lda	R0
   2458  0df9		       85 40		      sta	ILTrace
   2459  0dfb		       4c b1 02 	      jmp	NextIL
   2460  0dfe
   2461  0dfe							;=====================================================
   2462  0dfe							; Define start of non page zero data
   2463 U428d ????				      seg.u	TBData
   2464 U35bb					      org	PROGEND
   2465 U35bb							;=================================================================
   2466 U35bb							;
   2467 U35bb					      if	IL_DEBUG_TEXT
------- FILE ILKeyText.inc LEVEL 2 PASS 6
      0 U35bb					      include	"ILKeyText.inc"
      1  0dfe					      seg	Code
      2  0dfe					      if	IL_DEBUG_TEXT
      3  0dfe				   ILTEXTTABLE
      0  0dfe					      db	0,23,"iXINIT		   ",0
      1  0dfe		       00 17 69 58*	      .byte.b	0,23,"iXINIT		   ",0
      0  0e15					      db	1,23,"iDONE		   ",0
      1  0e15		       01 17 69 44*	      .byte.b	1,23,"iDONE		   ",0
      0  0e2c					      db	2,23,"iPRS		   ",0
      1  0e2c		       02 17 69 50*	      .byte.b	2,23,"iPRS		   ",0
      0  0e43					      db	3,23,"iPRN		   ",0
      1  0e43		       03 17 69 50*	      .byte.b	3,23,"iPRN		   ",0
      0  0e5a					      db	4,23,"iSPC		   ",0
      1  0e5a		       04 17 69 53*	      .byte.b	4,23,"iSPC		   ",0
      0  0e71					      db	5,23,"iNLINE		   ",0
      1  0e71		       05 17 69 4e*	      .byte.b	5,23,"iNLINE		   ",0
      0  0e88					      db	6,23,"iNXT		   ",0
      1  0e88		       06 17 69 4e*	      .byte.b	6,23,"iNXT		   ",0
      0  0e9f					      db	7,23,"iXFER		   ",0
      1  0e9f		       07 17 69 58*	      .byte.b	7,23,"iXFER		   ",0
      0  0eb6					      db	8,23,"iSAV		   ",0
      1  0eb6		       08 17 69 53*	      .byte.b	8,23,"iSAV		   ",0
      0  0ecd					      db	9,23,"iRSTR		   ",0
      1  0ecd		       09 17 69 52*	      .byte.b	9,23,"iRSTR		   ",0
      0  0ee4					      db	10,23,"iCMPR		    ",0
      1  0ee4		       0a 17 69 43*	      .byte.b	10,23,"iCMPR		    ",0
      0  0efb					      db	11,23,"iINNUM		    ",0
      1  0efb		       0b 17 69 49*	      .byte.b	11,23,"iINNUM		    ",0
      0  0f12					      db	12,23,"iFIN		    ",0
      1  0f12		       0c 17 69 46*	      .byte.b	12,23,"iFIN		    ",0
      0  0f29					      db	13,23,"iERR		    ",0
      1  0f29		       0d 17 69 45*	      .byte.b	13,23,"iERR		    ",0
      0  0f40					      db	14,23,"iADD		    ",0
      1  0f40		       0e 17 69 41*	      .byte.b	14,23,"iADD		    ",0
      0  0f57					      db	15,23,"iSUB		    ",0
      1  0f57		       0f 17 69 53*	      .byte.b	15,23,"iSUB		    ",0
      0  0f6e					      db	16,23,"iNEG		    ",0
      1  0f6e		       10 17 69 4e*	      .byte.b	16,23,"iNEG		    ",0
      0  0f85					      db	17,23,"iMUL		    ",0
      1  0f85		       11 17 69 4d*	      .byte.b	17,23,"iMUL		    ",0
      0  0f9c					      db	18,23,"iDIV		    ",0
      1  0f9c		       12 17 69 44*	      .byte.b	18,23,"iDIV		    ",0
      0  0fb3					      db	19,23,"iSTORE		    ",0
      1  0fb3		       13 17 69 53*	      .byte.b	19,23,"iSTORE		    ",0
      0  0fca					      db	20,23,"iIND		    ",0
      1  0fca		       14 17 69 49*	      .byte.b	20,23,"iIND		    ",0
      0  0fe1					      db	21,23,"iLST		    ",0
      1  0fe1		       15 17 69 4c*	      .byte.b	21,23,"iLST		    ",0
      0  0ff8					      db	22,23,"iINIT		    ",0
      1  0ff8		       16 17 69 49*	      .byte.b	22,23,"iINIT		    ",0
      0  100f					      db	23,23,"iGETLINE	    ",0
      1  100f		       17 17 69 47*	      .byte.b	23,23,"iGETLINE	    ",0
      0  1026					      db	24,23,"iINSRT		    ",0
      1  1026		       18 17 69 49*	      .byte.b	24,23,"iINSRT		    ",0
      0  103d					      db	25,23,"iRTN		    ",0
      1  103d		       19 17 69 52*	      .byte.b	25,23,"iRTN		    ",0
      0  1054					      db	26,23,"MONITOR 	    ",0
      1  1054		       1a 17 4d 4f*	      .byte.b	26,23,"MONITOR 	    ",0
      0  106b					      db	27,23,"iLIT		    ",0
      1  106b		       1b 17 69 4c*	      .byte.b	27,23,"iLIT		    ",0
      0  1082					      db	28,23,"iCALL		    ",0
      1  1082		       1c 17 69 43*	      .byte.b	28,23,"iCALL		    ",0
      0  1099					      db	29,23,"iJMP		    ",0
      1  1099		       1d 17 69 4a*	      .byte.b	29,23,"iJMP		    ",0
      0  10b0					      db	30,23,"iVINIT		    ",0
      1  10b0		       1e 17 69 56*	      .byte.b	30,23,"iVINIT		    ",0
      0  10c7					      db	31,23,"iERRGOTO	    ",0
      1  10c7		       1f 17 69 45*	      .byte.b	31,23,"iERRGOTO	    ",0
      0  10de					      db	32,23,"iTST		    ",0
      1  10de		       20 17 69 54*	      .byte.b	32,23,"iTST		    ",0
      0  10f5					      db	33,23,"iTSTV		    ",0
      1  10f5		       21 17 69 54*	      .byte.b	33,23,"iTSTV		    ",0
      0  110c					      db	34,23,"iTSTL		    ",0
      1  110c		       22 17 69 54*	      .byte.b	34,23,"iTSTL		    ",0
      0  1123					      db	35,23,"iTSTN		    ",0
      1  1123		       23 17 69 54*	      .byte.b	35,23,"iTSTN		    ",0
      0  113a					      db	36,23,"iFREE		    ",0
      1  113a		       24 17 69 46*	      .byte.b	36,23,"iFREE		    ",0
      0  1151					      db	37,23,"iRANDOM 	    ",0
      1  1151		       25 17 69 52*	      .byte.b	37,23,"iRANDOM 	    ",0
      0  1168					      db	38,23,"iABS		    ",0
      1  1168		       26 17 69 41*	      .byte.b	38,23,"iABS		    ",0
      0  117f					      db	39,23,"iOPENREAD	    ",0
      1  117f		       27 17 69 4f*	      .byte.b	39,23,"iOPENREAD	    ",0
      0  1196					      db	40,23,"iOPENWRITE	    ",0
      1  1196		       28 17 69 4f*	      .byte.b	40,23,"iOPENWRITE	    ",0
      0  11ad					      db	41,23,"iDCLOSE 	    ",0
      1  11ad		       29 17 69 44*	      .byte.b	41,23,"iDCLOSE 	    ",0
      0  11c4					      db	42,23,"iDGETLINE	    ",0
      1  11c4		       2a 17 69 44*	      .byte.b	42,23,"iDGETLINE	    ",0
      0  11db					      db	43,23,"iDLIST		    ",0
      1  11db		       2b 17 69 44*	      .byte.b	43,23,"iDLIST		    ",0
      0  11f2					      db	44,23,"iDDIR		    ",0
      1  11f2		       2c 17 69 44*	      .byte.b	44,23,"iDDIR		    ",0
      0  1209					      db	45,23,"iRMFILE 	    ",0
      1  1209		       2d 17 69 52*	      .byte.b	45,23,"iRMFILE 	    ",0
      0  1220					      db	39,23,"NextIL		    ",0
      1  1220		       27 17 4e 65*	      .byte.b	39,23,"NextIL		    ",0
      0  1237					      db	40,23,"NextIL		    ",0
      1  1237		       28 17 4e 65*	      .byte.b	40,23,"NextIL		    ",0
      0  124e					      db	41,23,"NextIL		    ",0
      1  124e		       29 17 4e 65*	      .byte.b	41,23,"NextIL		    ",0
      0  1265					      db	42,23,"NextIL		    ",0
      1  1265		       2a 17 4e 65*	      .byte.b	42,23,"NextIL		    ",0
      0  127c					      db	43,23,"NextIL		    ",0
      1  127c		       2b 17 4e 65*	      .byte.b	43,23,"NextIL		    ",0
      0  1293					      db	44,23,"NextIL		    ",0
      1  1293		       2c 17 4e 65*	      .byte.b	44,23,"NextIL		    ",0
      0  12aa					      db	45,23,"NextIL		    ",0
      1  12aa		       2d 17 4e 65*	      .byte.b	45,23,"NextIL		    ",0
      0  12c1					      db	46,23,"iCLEARSCREEN	    ",0
      1  12c1		       2e 17 69 43*	      .byte.b	46,23,"iCLEARSCREEN	    ",0
      0  12d8					      db	47,23,"iPOKEMEMORY	    ",0
      1  12d8		       2f 17 69 50*	      .byte.b	47,23,"iPOKEMEMORY	    ",0
      0  12ef					      db	48,23,"iPEEKMEMORY	    ",0
      1  12ef		       30 17 69 50*	      .byte.b	48,23,"iPEEKMEMORY	    ",0
      0  1306					      db	49,23,"iTSTLET 	    ",0
      1  1306		       31 17 69 54*	      .byte.b	49,23,"iTSTLET 	    ",0
      0  131d					      db	50,23,"iTSTDONE	    ",0
      1  131d		       32 17 69 54*	      .byte.b	50,23,"iTSTDONE	    ",0
      0  1334					      db	51,23,"iGETCHAR	    ",0
      1  1334		       33 17 69 47*	      .byte.b	51,23,"iGETCHAR	    ",0
      0  134b					      db	52,23,"iPUTCHAR	    ",0
      1  134b		       34 17 69 50*	      .byte.b	52,23,"iPUTCHAR	    ",0
      0  1362					      db	53,23,"iCallFunc	    ",0
      1  1362		       35 17 69 43*	      .byte.b	53,23,"iCallFunc	    ",0
      0  1379					      db	54,23,"iBranch 	    ",0
      1  1379		       36 17 69 42*	      .byte.b	54,23,"iBranch 	    ",0
      0  1390					      db	55,23,"iTSTStr 	    ",0
      1  1390		       37 17 69 54*	      .byte.b	55,23,"iTSTStr 	    ",0
      0  13a7					      db	56,23,"iSetIrq 	    ",0
      1  13a7		       38 17 69 53*	      .byte.b	56,23,"iSetIrq 	    ",0
      0  13be					      db	57,23,"iTstIrq 	    ",0
      1  13be		       39 17 69 54*	      .byte.b	57,23,"iTstIrq 	    ",0
      0  13d5					      db	58,23,"iRET		    ",0
      1  13d5		       3a 17 69 52*	      .byte.b	58,23,"iRET		    ",0
      0  13ec					      db	59,23,"iINSTR		    ",0
      1  13ec		       3b 17 69 49*	      .byte.b	59,23,"iINSTR		    ",0
      0  1403					      db	60,23,"iMOD		    ",0
      1  1403		       3c 17 69 4d*	      .byte.b	60,23,"iMOD		    ",0
      0  141a					      db	61,23,"iTaskSet	    ",0
      1  141a		       3d 17 69 54*	      .byte.b	61,23,"iTaskSet	    ",0
      0  1431					      db	62,23,"iETask		    ",0
      1  1431		       3e 17 69 45*	      .byte.b	62,23,"iETask		    ",0
      0  1448					      db	63,23,"iNTask		    ",0
      1  1448		       3f 17 69 4e*	      .byte.b	63,23,"iNTask		    ",0
      0  145f					      db	64,23,"iArray		    ",0
      1  145f		       40 17 69 41*	      .byte.b	64,23,"iArray		    ",0
      0  1476					      db	65,23,"iTaskKill	    ",0
      1  1476		       41 17 69 54*	      .byte.b	65,23,"iTaskKill	    ",0
      0  148d					      db	66,23,"iTaskStat	    ",0
      1  148d		       42 17 69 54*	      .byte.b	66,23,"iTaskStat	    ",0
      0  14a4					      db	67,23,"iHexOut 	    ",0
      1  14a4		       43 17 69 48*	      .byte.b	67,23,"iHexOut 	    ",0
      0  14bb					      db	68,23,"iReadComplete	    ",0
      1  14bb		       44 17 69 52*	      .byte.b	68,23,"iReadComplete	    ",0
      0  14d2					      db	69,23,"iReadStart	    ",0
      1  14d2		       45 17 69 52*	      .byte.b	69,23,"iReadStart	    ",0
      0  14e9					      db	70,23,"iStartIO	    ",0
      1  14e9		       46 17 69 53*	      .byte.b	70,23,"iStartIO	    ",0
      0  1500					      db	71,23,"iEndIO		    ",0
      1  1500		       47 17 69 45*	      .byte.b	71,23,"iEndIO		    ",0
      0  1517					      db	72,23,"iLogNot 	    ",0
      1  1517		       48 17 69 4c*	      .byte.b	72,23,"iLogNot 	    ",0
      0  152e					      db	73,23,"iLogOr		    ",0
      1  152e		       49 17 69 4c*	      .byte.b	73,23,"iLogOr		    ",0
      0  1545					      db	74,23,"iLogAnd 	    ",0
      1  1545		       4a 17 69 4c*	      .byte.b	74,23,"iLogAnd 	    ",0
      0  155c					      db	75,23,"iLogXor 	    ",0
      1  155c		       4b 17 69 4c*	      .byte.b	75,23,"iLogXor 	    ",0
      0  1573					      db	76,23,"iWTASK		    ",0
      1  1573		       4c 17 69 57*	      .byte.b	76,23,"iWTASK		    ",0
      0  158a					      db	77,23,"iTASKPID	    ",0
      1  158a		       4d 17 69 54*	      .byte.b	77,23,"iTASKPID	    ",0
      0  15a1					      db	78,23,"iTRACEPROG	    ",0
      1  15a1		       4e 17 69 54*	      .byte.b	78,23,"iTRACEPROG	    ",0
      0  15b8					      db	79,23,"idbgBasic	    ",0
      1  15b8		       4f 17 69 64*	      .byte.b	79,23,"idbgBasic	    ",0
      0  15cf					      db	80,23,"iIPCS		    ",0
      1  15cf		       50 17 69 49*	      .byte.b	80,23,"iIPCS		    ",0
      0  15e6					      db	81,23,"iIPCR		    ",0
      1  15e6		       51 17 69 49*	      .byte.b	81,23,"iIPCR		    ",0
      0  15fd					      db	82,23,"iIPCC		    ",0
      1  15fd		       52 17 69 49*	      .byte.b	82,23,"iIPCC		    ",0
      0  1614					      db	83,23,"iIPCIO		    ",0
      1  1614		       53 17 69 49*	      .byte.b	83,23,"iIPCIO		    ",0
      0  162b					      db	84,23,"iPushMathStack	    ",0
      1  162b		       54 17 69 50*	      .byte.b	84,23,"iPushMathStack	    ",0
      0  1642					      db	85,23,"iPopMathStack	    ",0
      1  1642		       55 17 69 50*	      .byte.b	85,23,"iPopMathStack	    ",0
      0  1659					      db	86,23,"iSaveMathStack	    ",0
      1  1659		       56 17 69 53*	      .byte.b	86,23,"iSaveMathStack	    ",0
      0  1670					      db	87,23,"iRestoreMathStack   ",0
      1  1670		       57 17 69 52*	      .byte.b	87,23,"iRestoreMathStack   ",0
      0  1687					      db	88,23,"iIncParmCount	    ",0
      1  1687		       58 17 69 49*	      .byte.b	88,23,"iIncParmCount	    ",0
      0  169e					      db	89,23,"iTaskGetMathStack   ",0
      1  169e		       59 17 69 54*	      .byte.b	89,23,"iTaskGetMathStack   ",0
      0  16b5					      db	90,23,"iTaskEnable	    ",0
      1  16b5		       5a 17 69 54*	      .byte.b	90,23,"iTaskEnable	    ",0
      0  16cc					      db	91,23,"iTaskSuspend	    ",0
      1  16cc		       5b 17 69 54*	      .byte.b	91,23,"iTaskSuspend	    ",0
      0  16e3					      db	92,23,"iTaskPutMathPtr     ",0
      1  16e3		       5c 17 69 54*	      .byte.b	92,23,"iTaskPutMathPtr     ",0
      0  16fa					      db	93,23,"iTSTVT		    ",0
      1  16fa		       5d 17 69 54*	      .byte.b	93,23,"iTSTVT		    ",0
      0  1711					      db	94,23,"iSetR2		    ",0
      1  1711		       5e 17 69 53*	      .byte.b	94,23,"iSetR2		    ",0
      0  1728					      db	95,23,"iStk2Tmp	    ",0
      1  1728		       5f 17 69 53*	      .byte.b	95,23,"iStk2Tmp	    ",0
      0  173f					      db	96,23,"iTmp2Stk	    ",0
      1  173f		       60 17 69 54*	      .byte.b	96,23,"iTmp2Stk	    ",0
      0  1756					      db	97,23,"iTSTBYTE	    ",0
      1  1756		       61 17 69 54*	      .byte.b	97,23,"iTSTBYTE	    ",0
      0  176d					      db	98,23,"iINCVAR 	    ",0
      1  176d		       62 17 69 49*	      .byte.b	98,23,"iINCVAR 	    ",0
      0  1784					      db	99,23,"iDECVAR 	    ",0
      1  1784		       63 17 69 44*	      .byte.b	99,23,"iDECVAR 	    ",0
      0  179b					      db	100,23,"iSLICE 	     ",0
      1  179b		       64 17 69 53*	      .byte.b	100,23,"iSLICE 	     ",0
      0  17b2					      db	101,23,"iTSTB		     ",0
      1  17b2		       65 17 69 54*	      .byte.b	101,23,"iTSTB		     ",0
      0  17c9					      db	102,23,"iTSTW		     ",0
      1  17c9		       66 17 69 54*	      .byte.b	102,23,"iTSTW		     ",0
      0  17e0					      db	103,23,"iOnGoto	     ",0
      1  17e0		       67 17 69 4f*	      .byte.b	103,23,"iOnGoto	     ",0
      0  17f7					      db	104,23,"iTSTRELOP	     ",0
      1  17f7		       68 17 69 54*	      .byte.b	104,23,"iTSTRELOP	     ",0
      0  180e					      db	105,23,"iRepeatLine	     ",0
      1  180e		       69 17 69 52*	      .byte.b	105,23,"iRepeatLine	     ",0
      0  1825					      db	106,23,"iTSTBRANCH	     ",0
      1  1825		       6a 17 69 54*	      .byte.b	106,23,"iTSTBRANCH	     ",0
      0  183c					      db	107,23,"iFastXfer	     ",0
      1  183c		       6b 17 69 46*	      .byte.b	107,23,"iFastXfer	     ",0
      0  1853					      db	108,23,"iSetTerminal	     ",0
      1  1853		       6c 17 69 53*	      .byte.b	108,23,"iSetTerminal	     ",0
      0  186a					      db	109,23,"iINDB		     ",0
      1  186a		       6d 17 69 49*	      .byte.b	109,23,"iINDB		     ",0
      0  1881					      db	110,23,"iSetBlock	     ",0
      1  1881		       6e 17 69 53*	      .byte.b	110,23,"iSetBlock	     ",0
      0  1898					      db	111,23,"iCopyBlock	     ",0
      1  1898		       6f 17 69 43*	      .byte.b	111,23,"iCopyBlock	     ",0
      0  18af					      db	112,23,"iCmpBlock	     ",0
      1  18af		       70 17 69 43*	      .byte.b	112,23,"iCmpBlock	     ",0
      0  18c6					      db	113,23,"iShift 	     ",0
      1  18c6		       71 17 69 53*	      .byte.b	113,23,"iShift 	     ",0
      0  18dd					      db	$FF,23,"0		     ",0
      1  18dd		       ff 17 30 20*	      .byte.b	$FF,23,"0		     ",0
    126  18f4
    127  18f4							; Search for the il instruction and print the correct text for it
    128  18f4							; on entry a contains the ip instruction to print
    129  18f4
    130 U35bb					      seg.u	TBData
    131 U35bb		       00 00	   R0TempIL   ds	2
    132 U35bd		       00	   ILSTA      ds	1
    133 U35be
    134  18f4					      Seg	Code
    135  18f4
    136  18f4		       8d bd 35    PrintILText sta	ILSTA
    137  18f7		       98		      tya
    138  18f8		       48		      pha
    139  18f9		       8a		      txa
    140  18fa		       48		      pha
    141  18fb		       a5 52		      lda	R0
    142  18fd		       8d bb 35 	      sta	R0TempIL
    143  1900		       a5 53		      lda	R0+1
    144  1902		       8d bb 35 	      sta	R0TempIL
    145  1905		       a9 fe		      lda	#ILTEXTTABLE&$FF
    146  1907		       85 52		      sta	R0
    147  1909		       a9 0d		      LDA	#ILTEXTTABLE>>8
    148  190b		       85 53		      sta	R0+1
    149  190d							;Loop Here for each entry
    150  190d		       a0 00	   PrintILLoop ldy	#0
    151  190f		       b1 52		      lda	(R0),y
    152  1911		       c9 ff		      cmp	#$FF
    153  1913		       f0 2a		      beq	PrintILNotFound
    154  1915		       cd bd 35 	      cmp	ILSTA
    155  1918		       f0 11		      beq	PrintILFound
    156  191a		       c8		      iny
    157  191b		       b1 52		      lda	(R0),y
    158  191d		       18		      clc
    159  191e		       65 52		      adc	R0
    160  1920		       85 52		      sta	R0
    161  1922		       a9 00		      lda	#0
    162  1924		       65 53		      adc	R0+1
    163  1926		       85 53		      sta	R0+1
    164  1928		       4c 0d 19 	      jmp	PrintILLoop
    165  192b							; The text was discovered
    166  192b		       c8	   PrintILFound iny		; point to length of instruction
    167  192c		       c8		      iny		; Point to start of text
    168  192d		       98		      tya
    169  192e		       18		      clc
    170  192f		       65 52		      adc	R0
    171  1931		       a8		      tay		; Low order byte of address
    172  1932		       a9 00		      lda	#0
    173  1934		       65 53		      adc	R0+1
    174  1936		       aa		      tax		; High order byte of address
    175  1937		       a9 00		      lda	#0	; Termination byte of string
    176  1939		       20 70 21 	      jsr	PrtStr	; print the string
    177  193c		       4c 45 19 	      jmp	PrintILDone
    178  193f
    179  193f		       ad bd 35    PrintILNotFound lda	ILSTA
    180  1942		       20 15 21 	      jsr	HexToOut
    181  1945
    182  1945		       ad bb 35    PrintILDone lda	R0TempIL
    183  1948		       85 52		      sta	R0
    184  194a		       ad bc 35 	      lda	R0TempIL+1
    185  194d		       85 52		      sta	R0
    186  194f		       68		      pla
    187  1950		       aa		      tax
    188  1951		       68		      pla
    189  1952		       a8		      tay
    190  1953		       60		      rts
    191  1954					      endif
------- FILE mytb.asm
   2469  1954					      endif
------- FILE time.asm LEVEL 2 PASS 6
      0  1954					      include	"time.asm"
------- FILE mytb.asm
------- FILE io.asm LEVEL 2 PASS 6
      0  1954					      include	"io.asm"
      1  1954							; This is the io blocks and function for reading and writing
      2  1954							; to devices attached to this computer.
      3  1954							; This supports devices mapped at e000 thru efff in slot sizes of 16 byte
      4  1954							;
      5  1954							;=====================================================================
      6  1954							; Device configuration equates
      7  1954		       00 00	   ConsoleID  equ	0
      8  1954		       00 08	   SerialID   equ	[1<<3]
      9  1954		       00 10	   ClockID    equ	[2<<3]
     10  1954		       00 18	   TimerID    equ	[3<<3]
     11  1954		       00 20	   DiskID     equ	[4<<3]
     12  1954
     13  1954		       00 0a	   IO_MAX_DEVICES equ	10
     14  1954		       00 06	   IO_VECT_LEN equ	6
     15  1954
     16  1954		       00 01	   IO_DEVICE_CLOSED equ	1	; The device is not open
     17  1954		       00 02	   IO_DEVICE_INVALID equ	2	; The Device number provided is invalid
     18  1954
     19  1954							;========================================================================================
     20  1954							; Uninitialized data segment
     21 U35be					      seg.u	TBData
     22 U35be
     23 U35be		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
     24 U35c0		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
     25 U35c2		       00 00	   BStatVec   ds	2	; This is used by inteface to read write status/config information
      0 U35c4				   BActiveDevice db	1	; the index of the current device block
      1 U35c4		       01		      .byte.b	1
      0 U35c5				   BActiveDriver db	1	; Index of the device drive block
      1 U35c5		       01		      .byte.b	1
     28 U35c6
     29 U35c6							;============================================================================================
     30  1954					      Seg	Code
     31  1954							; IRQ BASIC Code Service RTN Support
      0  1954				   SaveIrqReg db	0	; Store current setting
      1  1954		       00		      .byte.b	0
      0  1955				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1  1955		       00		      .byte.b	0
      0  1956				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1  1956		       00		      .byte.b	0
      0  1957				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1  1957		       00 00		      .byte.b	0,0
     36  1959
     37  1959							;============================================================================================
     38  1959							; Define the device interface blocks
     39  1959				   DeviceDriverBlocks
     40  1959				   ConsoleDevice		; Block 0
      0  1959					      dw	ConsoleID	; device idenifier Console
      1  1959		       00 00		      .word.w	ConsoleID
      0  195b					      dw	cin	; read function vector
      1  195b		       09 f0		      .word.w	cin
      0  195d					      dw	cout	; write function vector
      1  195d		       0c f0		      .word.w	cout
      0  195f					      dw	cstatus	; Get current Status info/Write config
      1  195f		       0f f0		      .word.w	cstatus
     45  1961
     46  1961				   SerialDevice 		; Block 1
      0  1961					      dw	SerialID	; device idenifier Serial
      1  1961		       08 00		      .word.w	SerialID
      0  1963					      dw	SerialIn	; read function vector
      1  1963		       3f 1a		      .word.w	SerialIn
      0  1965					      dw	SerialOut	; write function vector
      1  1965		       3f 1a		      .word.w	SerialOut
      0  1967					      dw	SerialStatus	; Get current Status info/Write config
      1  1967		       3f 1a		      .word.w	SerialStatus
     51  1969
     52  1969				   ClockDevice		; Block 2
      0  1969					      dw	ClockID	; Day/date Clock
      1  1969		       10 00		      .word.w	ClockID
      0  196b					      dw	ClockRead	; Read the date from clock
      1  196b		       3f 1a		      .word.w	ClockRead
      0  196d					      dw	ClockWrite	; Set the date/time of clock
      1  196d		       3f 1a		      .word.w	ClockWrite
      0  196f					      dw	#0	; No Status/Config Function
      1  196f		       00 00		      .word.w	#0
     57  1971
     58  1971				   TimerDevice		; Block 3
      0  1971					      dw	TimerID	; Timer/interrupt interface
      1  1971		       18 00		      .word.w	TimerID
      0  1973					      dw	TimerStart	; Start the timer
      1  1973		       3f 1a		      .word.w	TimerStart
      0  1975					      dw	TimerStop	; Stop the timer
      1  1975		       3f 1a		      .word.w	TimerStop
      0  1977					      dw	TimerStatus	; Config/read status
      1  1977		       3f 1a		      .word.w	TimerStatus
     63  1979
      0  1979				   DiskDevice dw	DiskID	; Block 4
      1  1979		       20 00		      .word.w	DiskID
      0  197b					      dw	DIN	; Disk Input / read function
      1  197b		       dc 30		      .word.w	DIN
      0  197d					      dw	DOUT	; Disk Output / write function
      1  197d		       c3 30		      .word.w	DOUT
      0  197f					      dw	DSTAT	; Disk Status/open/close etc information
      1  197f		       f5 30		      .word.w	DSTAT
     68  1981							;
     69  1981							;======================================================================
     70  1981							; Define the Device/Slot,driver control blocks
     71  1981							; entry format: ControlWord,DeviceDriver,PortAddress,StatusWord
     72  1981							; Fixed at 10 devices memory usage is getting pretty big!!!!!!
     73  1981							; Control word : bit 0 = active 1, Free 0
     74  1981
     75  1981				   DeviceIoBlocks
      0  1981					      dw	1, ConsoleID, $E000, 0	; Console device is 0 file
      1  1981		       01 00 00 00*	      .word.w	1, ConsoleID, $E000, 0
      0  1989					      dw	1, ClockID, $E010, 0	; Port for the day/time clock
      1  1989		       01 00 10 00*	      .word.w	1, ClockID, $E010, 0
      0  1991					      dw	1, TimerID, $E010, 0	; Timer interface
      1  1991		       01 00 18 00*	      .word.w	1, TimerID, $E010, 0
      0  1999					      dw	1, DiskID, $E010, 0	; Disk Driver interface
      1  1999		       01 00 20 00*	      .word.w	1, DiskID, $E010, 0
      0  19a1					      dw	1, SerialID, $E020, 0	; Second terminal(default Basic debug)
      1  19a1		       01 00 08 00*	      .word.w	1, SerialID, $E020, 0
      0  19a9					      dw	0, SerialID, $E030, 0	; Unused slot
      1  19a9		       00 00 08 00*	      .word.w	0, SerialID, $E030, 0
      0  19b1					      dw	0, SerialID, $E040, 0	; Unused slot
      1  19b1		       00 00 08 00*	      .word.w	0, SerialID, $E040, 0
      0  19b9					      dw	0, SerialID, $E050, 0	; Unused slot
      1  19b9		       00 00 08 00*	      .word.w	0, SerialID, $E050, 0
      0  19c1					      dw	0, SerialID, $E060, 0	; Unused slot
      1  19c1		       00 00 08 00*	      .word.w	0, SerialID, $E060, 0
      0  19c9					      dw	0, SerialID, $E070, 0	; Unused slot
      1  19c9		       00 00 08 00*	      .word.w	0, SerialID, $E070, 0
     86  19d1							;
     87  19d1							;======================================================================
     88  19d1							;
     89  19d1					      Seg	Code
     90  19d1							;======================================================================
     91  19d1							; This is the Basic IRQ handler, works with task manager
     92  19d1							;
     93  19d1		       48	   ServiceIrq pha
     94  19d2		       ad 55 19 	      lda	IRQStatus
     95  19d5		       f0 0a		      BEQ	RetIrq
     96  19d7		       ad 56 19 	      lda	IRQPending
     97  19da		       d0 05		      bne	RetIrq
     98  19dc		       a9 01		      lda	#1
     99  19de		       8d 56 19 	      sta	IRQPending
    100  19e1		       68	   RetIrq     pla
    101  19e2		       40		      rti
    102  19e3							;======================================================================
    103  19e3							; Jump to the output/input function in BOutVec/BInVec
    104  19e3							;
    105  19e3		       6c c0 35    VOUTCH     jmp	(BOutVec)	; Primary block io vectors
    106  19e6		       6c be 35    VGETCH     jmp	(BInVec)
    107  19e9		       6c c2 35    VSTAT      jmp	(BStatVec)
    108  19ec							;
    109  19ec							;======================================================================
    110  19ec							; IO Service functions
    111  19ec							; Validate the device index and set x to offest in table
    112  19ec							; does not return to ioInterface if invalid, returns to original caller
    113  19ec							; should be called immediatly after entering the ioInterface call
    114  19ec				   ioValidateDevice
    115  19ec		       e0 0a		      cpx	#IO_MAX_DEVICES
    116  19ee		       90 04		      bcc	ioValidIndex
    117  19f0		       a2 02		      ldx	#IO_DEVICE_INVALID
    118  19f2		       b0 13		      bcs	ioInvalidDevice
    119  19f4				   ioValidIndex
    120  19f4		       8a		      txa
    121  19f5		       0a		      asl		; Multiply by 8
    122  19f6		       0a		      asl
    123  19f7		       0a		      asl
    124  19f8		       aa		      tax		; Point to actual offset in the table
    125  19f9		       ec c4 35 	      cpx	BActiveDevice	; is it already active ?
    126  19fc		       f0 0d		      beq	ioValidDevice	; Shortcut if this is the active device already
    127  19fe		       a9 01		      lda	#1	; Active flag
    128  1a00		       3d 81 19 	      and	DeviceIoBlocks,x	; Check if the device is active
    129  1a03		       d0 06		      bne	ioValidDevice	; The device is active and valid index
    130  1a05		       a2 01		      ldx	#IO_DEVICE_CLOSED
    131  1a07
    132  1a07				   ioInvalidDevice
    133  1a07		       68		      pla		; Remove return address of IO interface
    134  1a08		       68		      pla
    135  1a09		       38		      sec		; ensure that carry is set
    136  1a0a		       60		      rts
    137  1a0b
    138  1a0b				   ioValidDevice
    139  1a0b		       18		      clc
    140  1a0c		       60		      rts
    141  1a0d							;
    142  1a0d							;===================================================================================
    143  1a0d							; Set the io device jmp vectors
    144  1a0d							; input x contains the vector to the active Device IO Block
    145  1a0d							; output a, x undefined y unchanged
    146  1a0d				   ioSetDeviceVectors
    147  1a0d		       ec c4 35 	      cpx	BActiveDevice	; Check if already set
    148  1a10		       f0 1b		      beq	ioSetDevExit	; if already set then do nothing
    149  1a12
    150  1a12		       8e c4 35 	      stx	BActiveDevice	; set the active device vector
    151  1a15		       98		      tya
    152  1a16		       48		      pha
    153  1a17
    154  1a17		       bc 83 19 	      ldy	DeviceIoBlocks+2,x	; Get the device driver index
    155  1a1a		       8c c5 35 	      sty	BActiveDriver	; Pointer to active Device driver
    156  1a1d		       a2 00		      ldx	#0	; Transfer the 6 pointers to the Vectors
    157  1a1f				   ioSetDevLoop
    158  1a1f		       b9 5b 19 	      lda	DeviceDriverBlocks+2,y
    159  1a22		       9d be 35 	      sta	BInVec,x
    160  1a25		       e8		      inx
    161  1a26		       c8		      iny
    162  1a27		       e0 06		      cpx	#IO_VECT_LEN	; Transfer the vector length to copy
    163  1a29		       d0 f4		      bne	ioSetDevLoop
    164  1a2b
    165  1a2b		       68		      pla
    166  1a2c		       a8		      tay
    167  1a2d				   ioSetDevExit
    168  1a2d		       60		      rts
    169  1a2e							;
    170  1a2e							;======================================================================
    171  1a2e							; Generic call interface for devices
    172  1a2e							; input x = DeviceIoBlockIndex
    173  1a2e							; Carry set if error, x contains the error code
    174  1a2e							; all other parameters are dependant upon the actual device interface
    175  1a2e							;
    176  1a2e							; ioPutCH  a contains the character to send
    177  1a2e		       20 ec 19    ioPutCH    jsr	ioValidateDevice
    178  1a31		       48		      pha
    179  1a32		       20 0d 1a 	      jsr	ioSetDeviceVectors
    180  1a35		       68		      pla
    181  1a36		       20 e3 19 	      jsr	VOUTCH
    182  1a39		       18		      clc
    183  1a3a		       60		      rts
    184  1a3b
    185  1a3b							; io Getch returns the character read from device
    186  1a3b		       20 ec 19    ioGetCH    jsr	ioValidateDevice
    187  1a3e
    188  1a3e		       60		      rts
    189  1a3f							;
    190  1a3f							;======================================================================
    191  1a3f							;TTY interface functions,
    192  1a3f							;	a contains the character to send
    193  1a3f							;	x contains the Device ID (equals index into io blocks)	of the io block to used
    194  1a3f							;
    195  1a3f				   SerialIn
    196  1a3f
    197  1a3f				   SerialOut
    198  1a3f
    199  1a3f				   SerialStatus
    200  1a3f
    201  1a3f							;
    202  1a3f							;======================================================================
    203  1a3f							; Date/Time clock interface
    204  1a3f				   ClockRead
    205  1a3f
    206  1a3f				   ClockWrite
    207  1a3f
    208  1a3f							;
    209  1a3f							;======================================================================
    210  1a3f							;
    211  1a3f				   TimerStart
    212  1a3f
    213  1a3f				   TimerStop
    214  1a3f
    215  1a3f				   TimerStatus
    216  1a3f
    217  1a3f
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  1a3f					      include	"tokenizer.asm"
      1  1a3f					      seg	Code
      2  1a3f		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  1a3f
      4  1a3f							; Define the types of tokens found, and identifiers
      5  1a3f		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  1a3f		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  1a3f		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  1a3f		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  1a3f
     10  1a3f		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  1a3f		       00 9c	   tVhash     equ	$9C	; Variable #
     12  1a3f		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  1a3f
     14  1a3f							; Base variable type supported by This basic
     15  1a3f							; Unsigned types always have the 0 bit set to 1
     16  1a3f		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     17  1a3f		       00 a2	   tByte      equ	$A2	; Signed Byte value
     18  1a3f		       00 a4	   tInteger   equ	$A4	; all tokenized integers start with 251 as first byte 16 bit signed number
     19  1a3f		       00 a6	   tLong      equ	$A6	; Signed 32 bit integer
     20  1a3f
     21  1a3f		       00 a1	   tArray     equ	$A1	; Identifies Array Type, the byte following defines the length of each element
     22  1a3f							; Arrays of string are arrays of pointers 2 bytes each
     23  1a3f		       00 a3	   tPointer   equ	$A3	; Pointer  unsigned 16 bit
     24  1a3f		       00 a5	   tIndirect  equ	$A5	; Points to an address that points to the data 16 bits
     25  1a3f		       00 a7	   tuByte     equ	$A7	; Unsigned byte value 8 bit unsigned value
     26  1a3f		       00 a9	   tUint      equ	$A9	; unsigned integer type 16 bit
     27  1a3f		       00 ab	   tUlong     equ	$AB	; Unsigned 32 bit integer
     28  1a3f
     29  1a3f		       3c 3e	   Operators  BYTE.b	"<>"
     30  1a41		       3c 3d		      BYTE.b	"<="
     31  1a43		       3e 3d		      BYTE.b	">="
     32  1a45		       3c 3c		      Byte.b	"<<"
     33  1a47		       3e 3e		      Byte.b	">>"
     34  1a49		       3c 00		      BYTE.b	"<",0
     35  1a4b		       3d 00		      BYTE.b	"=",0
     36  1a4d		       3e 00		      BYTE.b	">",0
     37  1a4f		       2b 2b		      Byte.b	"++"
     38  1a51		       2b 00		      BYTE.b	"+",0
     39  1a53		       2d 2d		      Byte.b	"--"
     40  1a55		       2d 00		      BYTE.b	"-",0
     41  1a57		       2f 00		      BYTE.b	"/",0
     42  1a59		       25 00		      BYTE.b	"%",0
     43  1a5b		       2a 00		      BYTE.b	"*",0
     44  1a5d		       28 00		      BYTE.b	"(",0
     45  1a5f		       29 00		      BYTE.b	")",0
     46  1a61		       2c 00		      BYTE.b	",",0
     47  1a63		       3b 00		      BYTE.b	";",0
     48  1a65		       5b 00		      BYTE.b	"[",0
     49  1a67		       5d 00		      BYTE.b	"]",0
     50  1a69		       3a 00		      BYTE.b	":",0
     51  1a6b		       24 00		      BYTE.b	"$",0
     52  1a6d		       21 00		      BYTE.b	"!",0
     53  1a6f		       3f 00		      BYTE.b	"?",0
     54  1a71		       2e 00		      BYTE.b	".",0
     55  1a73		       26 00		      BYTE.b	"&",0
     56  1a75		       27 00		      Byte.b	"'",0
     57  1a77		       7c 00		      Byte.b	"|",0
     58  1a79		       7e 00		      Byte.b	"~",0
     59  1a7b		       00 00		      BYTE.b	0,0
     60  1a7d
     61  1a7d		       f5 f3 f6 29*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oSHL,oSHR,oLess,oEqual,oGreater
     62  1a85		       02 ea 03 eb*	      BYTE.b	oINC, oPlus, oDEC, oMinus, oDivide, oModulo, oMultiply
     63  1a8c		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     64  1a92		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod, oAmphistan, oQuote, oBar,oTilde
     65  1a9b
     66  1a9b		       00 0b	   oQuestion  equ	kPrint
     67  1a9b							;    2 is =
     68  1a9b							;    1 is <
     69  1a9b							;    3 is <=
     70  1a9b							;    5 is <>
     71  1a9b							;    4 is >
     72  1a9b							;    6 is >=
     73  1a9b		       00 f1	   oLess      equ	$F1
     74  1a9b		       00 f2	   oEqual     equ	$F2
     75  1a9b		       00 f3	   oLessEqual equ	$F3
     76  1a9b		       00 f4	   oGreater   equ	$F4
     77  1a9b		       00 f5	   oNotEqual  equ	$F5
     78  1a9b		       00 f6	   oGreaterEqual equ	$F6
     79  1a9b
     80  1a9b		       00 e0	   oLeftBracket equ	$E0
     81  1a9b		       00 e1	   oRightBracket equ	$E1
     82  1a9b		       00 e2	   oComma     equ	$E2
     83  1a9b		       00 e3	   oSemiColon equ	$E3
     84  1a9b		       00 e4	   oLeftSQBracket equ	$E4
     85  1a9b		       00 e5	   oRightSQBracket equ	$E5
     86  1a9b		       00 e6	   oColon     equ	$E6
     87  1a9b		       00 e7	   oDollar    equ	$E7
     88  1a9b		       00 e8	   oBang      equ	$E8
     89  1a9b		       00 e9	   oPeriod    equ	$E9
     90  1a9b
     91  1a9b
     92  1a9b		       00 ea	   oPlus      equ	$EA
     93  1a9b		       00 eb	   oMinus     equ	$EB
     94  1a9b		       00 ec	   oDivide    equ	$EC
     95  1a9b		       00 ed	   oModulo    equ	$ED
     96  1a9b		       00 ee	   oMultiply  equ	$EE
     97  1a9b
     98  1a9b		       00 ed	   oPercent   equ	oModulo
     99  1a9b		       00 27	   oAmphistan equ	kAnd
    100  1a9b		       00 25	   oBar       equ	kOr
    101  1a9b		       00 0a	   oQuote     equ	kRem
    102  1a9b		       00 26	   oTilde     equ	kXor
    103  1a9b		       00 28	   oSHR       equ	kShr
    104  1a9b		       00 29	   oSHL       equ	kShl
    105  1a9b		       00 02	   oINC       equ	kInc
    106  1a9b		       00 03	   oDEC       equ	kDec
    107  1a9b
    108  1a9b		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
    109  1a9b
    110  1a9b		       00 ff	   tError     equ	$FF	; Error should never happen
    111  1a9b							;============================================================================================
    112  1a9b							; Keyword and seperator values
    113  1a9b				   '
    114  1a9b		       00 01	   kBeginKey  equ	kLet
    115  1a9b							;
    116  1a9b		       00 01	   kLet       equ	1
    117  1a9b		       00 02	   kInc       equ	kLet+1
    118  1a9b		       00 03	   kDec       equ	kInc+1
    119  1a9b		       00 04	   kIreturn   equ	kDec+1
    120  1a9b		       00 05	   kIf	      equ	kIreturn+1
    121  1a9b		       00 06	   kThen      equ	kIf+1
    122  1a9b		       00 07	   kGoto      equ	kThen+1
    123  1a9b		       00 08	   kGosub     equ	kGoto+1
    124  1a9b		       00 09	   kReturn    equ	kGosub+1
    125  1a9b		       00 0a	   kRem       equ	kReturn+1
    126  1a9b		       00 0b	   kPrint     equ	kRem+1
    127  1a9b		       00 0c	   kTaske     equ	kPrint+1
    128  1a9b		       00 0d	   kTaskn     equ	kTaske+1
    129  1a9b		       00 0e	   kTaskw     equ	kTaskn+1
    130  1a9b		       00 0f	   kPoke      equ	kTaskw+1
    131  1a9b		       00 10	   kPutch     equ	kPoke+1
    132  1a9b		       00 11	   kCls       equ	kPutch+1
    133  1a9b		       00 12	   kInput     equ	kCls+1
    134  1a9b		       00 13	   kEnd       equ	kInput+1
    135  1a9b		       00 14	   kIrq       equ	kEnd+1
    136  1a9b		       00 15	   kKill      equ	kIrq+1
    137  1a9b		       00 16	   kList      equ	kKill+1
    138  1a9b		       00 17	   kRun       equ	kList+1
    139  1a9b		       00 18	   kNew       equ	kRun+1
    140  1a9b		       00 19	   kSlice     equ	kNew+1
    141  1a9b		       00 1a	   kTrace     equ	kSlice+1
    142  1a9b		       00 1b	   kExit      equ	kTrace+1
    143  1a9b		       00 1c	   kSave      equ	kExit+1
    144  1a9b		       00 1d	   kLoad      equ	kSave+1
    145  1a9b		       00 1e	   kErase     equ	kLoad+1
    146  1a9b		       00 1f	   kDir       equ	kErase+1
    147  1a9b		       00 20	   kSetTerm   equ	kDir+1
    148  1a9b		       00 21	   kSetMemB   equ	kSetTerm+1
    149  1a9b		       00 22	   kSetMemW   equ	kSetMemB+1
    150  1a9b		       00 23	   kCopyMem   equ	kSetMemW+1
    151  1a9b							;
    152  1a9b							; End of actual key words
    153  1a9b							;
    154  1a9b		       00 22	   kKeyCount  equ	kCopyMem-kBeginKey
    155  1a9b							;
    156  1a9b							; Logical operators
    157  1a9b							;
    158  1a9b		       00 24	   kNot       equ	kCopyMem+1
    159  1a9b		       00 25	   kOr	      equ	kNot+1
    160  1a9b		       00 26	   kXor       equ	kOr+1
    161  1a9b		       00 27	   kAnd       equ	kXor+1
    162  1a9b							;
    163  1a9b							; Shift operators
    164  1a9b							;
    165  1a9b		       00 28	   kShr       equ	kAnd+1
    166  1a9b		       00 29	   kShl       equ	kShr+1
    167  1a9b
    168  1a9b							; numeric functions
    169  1a9b							;
    170  1a9b		       00 2a	   kBeginFunc equ	kTrue
    171  1a9b							;
    172  1a9b							; Truth operators
    173  1a9b							;
    174  1a9b		       00 2a	   kTrue      equ	kShl+1
    175  1a9b		       00 2b	   kFalse     equ	kTrue+1
    176  1a9b							; Functions
    177  1a9b		       00 2c	   kFree      equ	kFalse+1
    178  1a9b		       00 2d	   kGetch     equ	kFree+1
    179  1a9b		       00 2e	   kPeek      equ	kGetch+1
    180  1a9b		       00 2f	   kTask      equ	kPeek+1
    181  1a9b		       00 30	   kIpcc      equ	kTask+1
    182  1a9b		       00 31	   kIpcs      equ	kIpcc+1
    183  1a9b		       00 32	   kIpcr      equ	kIpcs+1
    184  1a9b		       00 33	   kRnd       equ	kIpcr+1
    185  1a9b		       00 34	   kStat      equ	kRnd+1
    186  1a9b		       00 35	   kAbs       equ	kStat+1
    187  1a9b		       00 36	   kCall      equ	kAbs+1
    188  1a9b		       00 37	   kGofn      equ	kCall+1
    189  1a9b		       00 38	   kPid       equ	kGofn+1
    190  1a9b		       00 39	   kAddr      equ	kPid+1
    191  1a9b		       00 3a	   kCmpMem    equ	kAddr+1
    192  1a9b							;
    193  1a9b		       00 11	   kFuncCount equ	((kCmpMem - kBeginFunc) + 1)
    194  1a9b
    195  1a9b							;
    196  1a9b							; Keyword table contains 54 keywords
    197  1a9b				   KeyWordTable
      0  1a9b					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  1a9b		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  1a9f					      db	kInc,"inC"
      1  1a9f		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  1aa3					      db	kDec,"deC"
      1  1aa3		       03 64 65 43	      .byte.b	kDec,"deC"
      0  1aa7					      db	kIreturn,"ireturN"
      1  1aa7		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  1aaf					      db	kIf,"iF"
      1  1aaf		       05 69 46 	      .byte.b	kIf,"iF"
      0  1ab2					      db	kThen,"theN"
      1  1ab2		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  1ab7					      db	kGoto,"gotO"
      1  1ab7		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  1abc					      db	kGosub,"gosuB"
      1  1abc		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  1ac2					      db	kReturn,"returN"
      1  1ac2		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  1ac9					      db	kRem,"reM"
      1  1ac9		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  1acd					      db	kPrint,"prinT"
      1  1acd		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  1ad3					      db	kTaske,"taskE"
      1  1ad3		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  1ad9					      db	kTaskn,"taskN"
      1  1ad9		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  1adf					      db	kTaskw,"taskW"
      1  1adf		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  1ae5					      db	kPoke,"pokE"
      1  1ae5		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  1aea					      db	kPutch,"putcH"
      1  1aea		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  1af0					      db	kCls,"clS"
      1  1af0		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  1af4					      db	kInput,"inpuT"
      1  1af4		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  1afa					      db	kEnd,"enD"
      1  1afa		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  1afe					      db	kIrq,"irQ"
      1  1afe		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  1b02					      db	kKill,"kilL"
      1  1b02		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  1b07					      db	kList,"lisT"
      1  1b07		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  1b0c					      db	kRun,"ruN"
      1  1b0c		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  1b10					      db	kNew,"neW"
      1  1b10		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  1b14					      db	kSlice,"slicE"
      1  1b14		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  1b1a					      db	kTrace,"tracE"
      1  1b1a		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  1b20					      db	kExit,"exiT"
      1  1b20		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  1b25					      db	kSave,"savE"
      1  1b25		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  1b2a					      db	kLoad,"loaD"
      1  1b2a		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  1b2f					      db	kErase,"erasE"
      1  1b2f		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  1b35					      db	kDir,"diR"
      1  1b35		       1f 64 69 52	      .byte.b	kDir,"diR"
    229  1b39							;Short form for statements:
      0  1b39					      db	kIreturn,"ireT"
      1  1b39		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  1b3e					      db	kReturn,"reT"
      1  1b3e		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  1b42					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  1b42		       0b 70 52 	      .byte.b	kPrint,"pR"
      0  1b45					      db	kSetTerm, "setterM"
      1  1b45		       20 73 65 74*	      .byte.b	kSetTerm, "setterM"
      0  1b4d					      db	kSetMemB, "setmemB"
      1  1b4d		       21 73 65 74*	      .byte.b	kSetMemB, "setmemB"
      0  1b55					      db	kSetMemW, "setmemW"
      1  1b55		       22 73 65 74*	      .byte.b	kSetMemW, "setmemW"
      0  1b5d					      db	kCopyMem, "copymeM"
      1  1b5d		       23 63 6f 70*	      .byte.b	kCopyMem, "copymeM"
    237  1b65
    238  1b65							; Shift operators
      0  1b65					      db	kShr,"shR"
      1  1b65		       28 73 68 52	      .byte.b	kShr,"shR"
      0  1b69					      db	kShl,"shL"
      1  1b69		       29 73 68 4c	      .byte.b	kShl,"shL"
    241  1b6d
    242  1b6d							;Logical and truth operators
      0  1b6d					      db	kNot,"noT"
      1  1b6d		       24 6e 6f 54	      .byte.b	kNot,"noT"
      0  1b71					      db	kOr,"oR"
      1  1b71		       25 6f 52 	      .byte.b	kOr,"oR"
      0  1b74					      db	kXor,"xoR"
      1  1b74		       26 78 6f 52	      .byte.b	kXor,"xoR"
      0  1b78					      db	kAnd,"anD"
      1  1b78		       27 61 6e 44	      .byte.b	kAnd,"anD"
    247  1b7c
    248  1b7c							; Truth values
      0  1b7c					      db	kTrue,"truE"
      1  1b7c		       2a 74 72 75*	      .byte.b	kTrue,"truE"
      0  1b81					      db	kFalse,"falsE"
      1  1b81		       2b 66 61 6c*	      .byte.b	kFalse,"falsE"
    251  1b87
    252  1b87
    253  1b87
    254  1b87							;functions returning values
    255  1b87
      0  1b87					      db	kFree,"freE"
      1  1b87		       2c 66 72 65*	      .byte.b	kFree,"freE"
      0  1b8c					      db	kGetch,"getcH"
      1  1b8c		       2d 67 65 74*	      .byte.b	kGetch,"getcH"
      0  1b92					      db	kPeek,"peeK"
      1  1b92		       2e 70 65 65*	      .byte.b	kPeek,"peeK"
      0  1b97					      db	kTask,"tasK"
      1  1b97		       2f 74 61 73*	      .byte.b	kTask,"tasK"
      0  1b9c					      db	kIpcc,"ipcC"
      1  1b9c		       30 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  1ba1					      db	kIpcs,"ipcS"
      1  1ba1		       31 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  1ba6					      db	kIpcr,"ipcR"
      1  1ba6		       32 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  1bab					      db	kRnd,"rnD"
      1  1bab		       33 72 6e 44	      .byte.b	kRnd,"rnD"
      0  1baf					      db	kStat,"staT"
      1  1baf		       34 73 74 61*	      .byte.b	kStat,"staT"
      0  1bb4					      db	kAbs,"abS"
      1  1bb4		       35 61 62 53	      .byte.b	kAbs,"abS"
      0  1bb8					      db	kCall,"calL"
      1  1bb8		       36 63 61 6c*	      .byte.b	kCall,"calL"
      0  1bbd					      db	kGofn,"fN"
      1  1bbd		       37 66 4e 	      .byte.b	kGofn,"fN"
      0  1bc0					      db	kPid,"piD"
      1  1bc0		       38 70 69 44	      .byte.b	kPid,"piD"
      0  1bc4					      db	kAddr,"addR"
      1  1bc4		       39 61 64 64*	      .byte.b	kAddr,"addR"
      0  1bc9					      db	kCmpMem, "cmpmeM"
      1  1bc9		       3a 63 6d 70*	      .byte.b	kCmpMem, "cmpmeM"
      0  1bd0					      db	0,0
      1  1bd0		       00 00		      .byte.b	0,0
    272  1bd2
    273  1bd2		       1b d2	   KeyWordTableEnd equ	*
    274  1bd2		       01 37	   KeyWordTableLength equ	* - KeyWordTable
    275  1bd2		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    276  1cd2		       00 00 00    printStorage ds	3
    277  1cd5							;==================================================================================================================
    278  1cd5							; Read accross the inputline and output to TOKENBUFFER
    279  1cd5							; Format   byte      Description
    280  1cd5							;	     0	      length of line 1-255
    281  1cd5							;	    0-1       Line Number
    282  1cd5							;	    Tokens and litteral values encoded into the line
    283  1cd5							;
    284  1cd5							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    285  1cd5							;  if fails then test for keywords
    286  1cd5							;  if fails then test for variables and arrays
    287  1cd5							;  if fails check for operators/seperators  + - < > = % / * () [] , ; : >> <<
    288  1cd5
    289  1cd5				   ParseInputLine
    290  1cd5				  -	      if	DEBUGPARSER
    291  1cd5				  -	      jsr	SetOutDebug
    292  1cd5				  -	      jsr	DebugClearBuffer
    293  1cd5					      endif
    294  1cd5		       a5 51		      lda	CUROFF
    295  1cd7		       48		      pha
    296  1cd8		       8a		      txa
    297  1cd9		       48		      pha
    298  1cda		       98		      tya
    299  1cdb		       48		      pha
    300  1cdc		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    301  1cde		       20 5b 2a 	      jsr	getDecimal	; Check for a line number, none is ok too
    302  1ce1		       84 51		      sty	CUROFF
    303  1ce3		       20 a1 1e 	      jsr	R02TOKEN	; Move R0 to token buffer
    304  1ce6
    305  1ce6				   ParseInputLoop
    306  1ce6		       a4 51		      ldy	CUROFF
    307  1ce8		       20 eb 2c 	      jsr	SkipSpaces	; Skip any spaces
    308  1ceb		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    309  1ced		       b9 ea 41 	      lda	LINBUF,y	; Check for end of line
    310  1cf0		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    311  1cf2
    312  1cf2				   ParseForNumber
    313  1cf2		       20 f5 1d 	      jsr	ParseNumeric	; Check for a numeric value
    314  1cf5		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    315  1cf7
    316  1cf7				   ParseForString
    317  1cf7		       20 cb 1d 	      jsr	ParseString	; Check for a string
    318  1cfa		       90 ea		      bcc	ParseInputLoop	; It was a string
    319  1cfc
    320  1cfc				   ParseForOp
    321  1cfc		       20 33 1e 	      jsr	ParseForOperator	; Check for operator or punctuation
    322  1cff		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    323  1d01
    324  1d01				   ParseForKey
    325  1d01		       20 28 1d 	      jsr	ParseLookupKey	; Check for a keyword value
    326  1d04		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    327  1d06
    328  1d06				   ParseForVar
    329  1d06		       20 6a 1e 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    330  1d09		       90 db		      bcc	ParseInputLoop
    331  1d0b
    332  1d0b				   ParseKeepChar		; if it does not parse just keep it safe
    333  1d0b		       b9 ea 41 	      lda	LINBUF,y
    334  1d0e		       9d d2 1b 	      sta	TOKENBUFFER,x
    335  1d11		       e8		      inx
    336  1d12		       c8		      iny
    337  1d13		       84 51		      sty	CUROFF
    338  1d15		       d0 cf		      bne	ParseInputLoop
    339  1d17
    340  1d17				   ParseComplete
    341  1d17		       a9 00		      lda	#0
    342  1d19		       9d d2 1b 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    343  1d1c		       e8		      inx
    344  1d1d		       8e d2 1b 	      stx	TOKENBUFFER	; Place size including null into buffer start
    345  1d20
    346  1d20		       68		      pla
    347  1d21		       a8		      tay
    348  1d22		       68		      pla
    349  1d23		       aa		      tax
    350  1d24		       68		      pla
    351  1d25		       85 51		      sta	CUROFF
    352  1d27
    353  1d27				  -	      if	DEBUGPARSER
    354  1d27				  -
    355  1d27				  -	      jsr	printTokenBuffer
    356  1d27				  -			;jsr	  DebugPrintProgramLine
    357  1d27				  -	      jsr	SetOutDebugEnd
    358  1d27				  -
    359  1d27					      endif
    360  1d27		       60		      rts
    361  1d28
    362  1d28							;==================================================================================================================
    363  1d28							; Look at curptr, curpos and check for a valid KeyWord
    364  1d28							; A contains the index value. c is clear
    365  1d28							;		     not found c set  A undefined
    366  1d28							; X is prerserved
    367  1d28							;
    368  1d28				   ParseLookupKey
    369  1d28		       86 58		      stx	R2
    370  1d2a		       a0 00		      ldy	#0
    371  1d2c		       a9 9b		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    372  1d2e		       85 54		      sta	R1
    373  1d30		       a9 1a		      lda	#KeyWordTable>>8
    374  1d32		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    375  1d34		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    376  1d36		       85 52		      sta	R0	; Save until next keyword
    377  1d38		       c8		      iny		; Point to first character of keyword
    378  1d39		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    379  1d3b
    380  1d3b				  -	      if	DEBUGPARSER
    381  1d3b				  -			;    jsr DebugKeyword
    382  1d3b					      endif
    383  1d3b
    384  1d3b				   ParseLookupLoop
    385  1d3b		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    386  1d3d		       29 df		      and	#%11011111	; Force Keyword to upper case
    387  1d3f		       dd ea 41 	      cmp	LINBUF,x	; Check the input buffer
    388  1d42		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    389  1d44		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    390  1d46		       dd ea 41 	      cmp	LINBUF,x	; Compare value to upercase
    391  1d49		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    392  1d4b
    393  1d4b				   ParseNextLetter
    394  1d4b		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    395  1d4d		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    396  1d4f		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    397  1d51		       e8		      inx		; Point to next char in the input buffer
    398  1d52		       c8		      iny		; Point to the next character in the Keyword table
    399  1d53		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    400  1d55		       dd ea 41 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    401  1d58		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    402  1d5a		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    403  1d5c
    404  1d5c				   ParseKeyFound
    405  1d5c		       a5 52		      lda	R0	; get the keyword index
    406  1d5e
    407  1d5e				   ParseKeyDone
    408  1d5e		       e8		      inx		; point past the last character
    409  1d5f		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    410  1d61		       a6 58		      ldx	R2	; Restore the original x pointer
    411  1d63		       9d d2 1b 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    412  1d66		       e8		      inx		; Point to next position in the output buffer
    413  1d67		       86 58		      stx	R2	; Save next position in buffer
    414  1d69		       c9 0a		      cmp	#kRem	; remark statement
    415  1d6b		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    416  1d6d		       c9 07		      cmp	#kGoto
    417  1d6f		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    418  1d71		       c9 08		      cmp	#kGosub
    419  1d73		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    420  1d75		       c9 37		      cmp	#kGofn
    421  1d77		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    422  1d79		       c9 2f		      cmp	#kTask
    423  1d7b		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    424  1d7d
    425  1d7d		       18		      clc		; C flag clear, we found it
    426  1d7e		       60		      rts
    427  1d7f
    428  1d7f							; Move forward to the next entry in table
    429  1d7f				   ParseNextEntry
    430  1d7f		       b1 54		      lda	(R1),y	; Get the next character in the token
    431  1d81		       29 20		      and	#%00100000	; Is it the last character
    432  1d83		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    433  1d85		       c8		      iny		; Point to next char in the entry
    434  1d86		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    435  1d88
    436  1d88				   ParseEndOfEntry
    437  1d88		       c8		      iny		; Point to the byte after the last character
    438  1d89		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    439  1d8a		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    440  1d8b		       65 54		      adc	R1
    441  1d8d		       85 54		      sta	R1
    442  1d8f		       a5 55		      lda	R1+1
    443  1d91		       69 00		      adc	#0
    444  1d93		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    445  1d95		       a0 00		      ldy	#0	; Reset the index back to zero
    446  1d97		       b1 54		      lda	(R1),y	; get keyword value
    447  1d99		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    448  1d9b		       85 52		      sta	R0	; save the next token value
    449  1d9d		       c8		      iny		; Inc past token value
    450  1d9e
    451  1d9e				  -	      if	DEBUGPARSER
    452  1d9e				  -			;    jsr DebugKeyword
    453  1d9e					      endif
    454  1d9e		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    455  1da0		       4c 3b 1d 	      jmp	ParseLookupLoop	; branch back for next key word
    456  1da3
    457  1da3				   ParseNoneFound
    458  1da3		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    459  1da5		       38		      sec		; c clear, not found
    460  1da6		       60		      rts
    461  1da7
    462  1da7							;===============================================================================
    463  1da7							; Move everything from current position until the end of line into the token buffer
    464  1da7							;
    465  1da7		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    466  1da9		       a6 58		      ldx	R2	; where to place in the buffer
    467  1dab				   ParseMoveLoop
    468  1dab		       b9 ea 41 	      lda	LINBUF,y	; get the next byte
    469  1dae		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    470  1db0		       9d d2 1b 	      sta	TOKENBUFFER,x	; save the byte
    471  1db3		       c8		      iny
    472  1db4		       e8		      inx
    473  1db5		       d0 f4		      bne	ParseMoveLoop
    474  1db7				   ParseMoveDone
    475  1db7		       84 51		      sty	CUROFF
    476  1db9		       18		      clc
    477  1dba		       60		      rts
    478  1dbb							;================================================================================================
    479  1dbb							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    480  1dbb							; transfer to a memory address
    481  1dbb				   ParseHandleBranches
    482  1dbb		       a6 58		      ldx	R2
    483  1dbd		       a9 00		      lda	#0
    484  1dbf		       9d d2 1b 	      sta	TOKENBUFFER,x
    485  1dc2		       e8		      inx
    486  1dc3		       9d d2 1b 	      sta	TOKENBUFFER,x
    487  1dc6		       e8		      inx
    488  1dc7		       86 58		      stx	R2
    489  1dc9		       18		      clc
    490  1dca		       60		      rts
    491  1dcb
    492  1dcb							;=========================================================================================================
    493  1dcb							;ParseString Parse a quotes string
    494  1dcb							; on input X = outbuf position
    495  1dcb							; y = inbuf position
    496  1dcb							; Copies string to output buffer, updates x and y
    497  1dcb				   ParseString
    498  1dcb		       a4 51		      ldy	CUROFF
    499  1dcd		       a9 a0		      lda	#tString
    500  1dcf		       9d d2 1b 	      sta	TOKENBUFFER,X
    501  1dd2		       b9 ea 41 	      lda	LINBUF,y
    502  1dd5		       c9 22		      cmp	#'"
    503  1dd7		       d0 1a		      bne	ParseStringInvalid
    504  1dd9		       e8		      inx
    505  1dda		       9d d2 1b 	      sta	TOKENBUFFER,x
    506  1ddd		       e8		      inx
    507  1dde		       c8		      iny
    508  1ddf
    509  1ddf				   ParseStringLoop
    510  1ddf		       b9 ea 41 	      lda	LINBUF,y
    511  1de2		       9d d2 1b 	      sta	TOKENBUFFER,x
    512  1de5		       c9 22		      cmp	#'"
    513  1de7		       f0 04		      beq	ParseStringDone
    514  1de9		       c8		      iny
    515  1dea		       e8		      inx
    516  1deb		       d0 f2		      bne	ParseStringLoop
    517  1ded
    518  1ded				   ParseStringDone
    519  1ded		       e8		      inx
    520  1dee		       c8		      iny
    521  1def		       84 51		      sty	CUROFF
    522  1df1		       18		      clc
    523  1df2		       60		      rts
    524  1df3
    525  1df3				   ParseStringInvalid
    526  1df3		       38		      sec
    527  1df4		       60		      rts
    528  1df5
    529  1df5							;=========================================================================================================
    530  1df5							; Get numeric values and return value in RO and type in a
    531  1df5							;
    532  1df5				   ParseNumeric
    533  1df5		       a4 51		      ldy	CUROFF
    534  1df7		       b9 ea 41 	      lda	LINBUF,y
    535  1dfa		       c9 30		      cmp	#'0
    536  1dfc		       90 33		      bcc	ParseNumInvalid
    537  1dfe		       c9 3a		      cmp	#'9+1
    538  1e00		       b0 2f		      bcs	ParseNumInvalid
    539  1e02		       86 58		      stx	R2
    540  1e04		       20 5b 2a 	      jsr	getDecimal
    541  1e07		       a6 58		      ldx	R2
    542  1e09		       84 51		      sty	CUROFF
    543  1e0b		       a5 53		      lda	R0+1
    544  1e0d		       f0 14		      beq	ParseByteValue
    545  1e0f
    546  1e0f				   ParseIntegerValue
    547  1e0f		       a9 a4		      lda	#tInteger
    548  1e11		       9d d2 1b 	      sta	TOKENBUFFER,x
    549  1e14		       e8		      inx
    550  1e15		       a5 52		      lda	R0
    551  1e17		       9d d2 1b 	      sta	TOKENBUFFER,x
    552  1e1a		       e8		      inx
    553  1e1b		       a5 53		      lda	R0+1
    554  1e1d		       9d d2 1b 	      sta	TOKENBUFFER,X
    555  1e20		       e8		      inx
    556  1e21		       18		      clc
    557  1e22		       60		      rts
    558  1e23
    559  1e23				   ParseByteValue
    560  1e23		       a9 a2		      lda	#tByte
    561  1e25		       9d d2 1b 	      sta	TOKENBUFFER,x
    562  1e28		       e8		      inx
    563  1e29		       a5 52		      lda	R0
    564  1e2b		       9d d2 1b 	      sta	TOKENBUFFER,x
    565  1e2e		       e8		      inx
    566  1e2f		       18		      clc
    567  1e30		       60		      rts
    568  1e31
    569  1e31				   ParseNumInvalid		;Not a valid Numeric
    570  1e31		       38		      sec
    571  1e32		       60		      rts
    572  1e33
    573  1e33							;=========================================================================================================
    574  1e33							;Parse for operators and seperators
    575  1e33							; on exit the A has the oper code, c is clear
    576  1e33							;		 not found then c is set
    577  1e33							;	x is preserved
    578  1e33							;
    579  1e33				   ParseForOperator
    580  1e33		       86 58		      stx	R2
    581  1e35		       a4 51		      ldy	CUROFF
    582  1e37		       a2 00		      ldx	#0
    583  1e39				  -	      if	DEBUGPARSER
    584  1e39				  -			;	jsr    DebugPrintOP
    585  1e39					      endif
    586  1e39
    587  1e39				   ParseOpLoop
    588  1e39		       bd 3f 1a 	      lda	Operators,x	; First byte of operator
    589  1e3c		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    590  1e3e
    591  1e3e		       d9 ea 41 	      cmp	LINBUF,y	; Check the first byte
    592  1e41		       d0 1c		      bne	ParseOpNext
    593  1e43
    594  1e43		       c8		      iny
    595  1e44
    596  1e44		       bd 40 1a 	      lda	Operators+1,x
    597  1e47		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    598  1e49
    599  1e49		       d9 ea 41 	      cmp	LINBUF,y
    600  1e4c		       d0 11		      bne	ParseOpNext
    601  1e4e
    602  1e4e				   ParseOpFound
    603  1e4e		       c8		      iny
    604  1e4f
    605  1e4f				   ParseOpFoundSingle
    606  1e4f		       84 51		      sty	CUROFF
    607  1e51
    608  1e51		       8a		      txa
    609  1e52		       4a		      lsr
    610  1e53		       aa		      tax
    611  1e54		       bd 7d 1a 	      lda	OperValues,x
    612  1e57		       a6 58		      ldx	R2
    613  1e59		       9d d2 1b 	      sta	TOKENBUFFER,x
    614  1e5c		       e8		      inx
    615  1e5d		       18		      clc
    616  1e5e		       60		      rts
    617  1e5f
    618  1e5f				   ParseOpNext
    619  1e5f		       e8		      inx
    620  1e60		       e8		      inx
    621  1e61
    622  1e61				  -	      if	DEBUGPARSER
    623  1e61				  -			;	 jsr	DebugPrintOP
    624  1e61					      endif
    625  1e61		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    626  1e63		       4c 39 1e 	      jmp	ParseOpLoop
    627  1e66
    628  1e66				   ParseOpNotFound
    629  1e66		       a6 58		      ldx	R2
    630  1e68		       38		      sec
    631  1e69		       60		      rts
    632  1e6a							;=========================================================================================================
    633  1e6a				  -	      if	DEBUGPARSER
    634  1e6a				  -			;Print the text of a keyword
    635  1e6a				  -			;Input R1    = offset into table
    636  1e6a				  -DebugKeyword
    637  1e6a				  -	      tya
    638  1e6a				  -	      pha
    639  1e6a				  -	      ldy	#1
    640  1e6a				  -DebugKeyLoop
    641  1e6a				  -	      lda	(R1),y
    642  1e6a				  -	      jsr	VOUTCH
    643  1e6a				  -	      and	#%00100000
    644  1e6a				  -	      beq	DebugKeyDone
    645  1e6a				  -	      iny
    646  1e6a				  -	      bne	DebugKeyLoop
    647  1e6a				  -
    648  1e6a				  -DebugKeyDone
    649  1e6a				  -	      jsr	CRLF
    650  1e6a				  -	      pla
    651  1e6a				  -	      tay
    652  1e6a				  -	      rts
    653  1e6a				  -			;========================================
    654  1e6a				  -DebugPrintOP
    655  1e6a				  -	      pha
    656  1e6a				  -	      lda	Operators,x
    657  1e6a				  -	      jsr	VOUTCH
    658  1e6a				  -	      lda	Operators+1,x
    659  1e6a				  -	      beq	DbgPrtOpDone
    660  1e6a				  -	      jsr	VOUTCH
    661  1e6a				  -
    662  1e6a				  -DbgPrtOpDone
    663  1e6a				  -	      jsr	CRLF
    664  1e6a				  -	      pla
    665  1e6a				  -	      rts
    666  1e6a				  -			;=======================================
    667  1e6a				  -DebugClearBuffer
    668  1e6a				  -	      txa
    669  1e6a				  -	      pha
    670  1e6a				  -	      ldx	#$FF
    671  1e6a				  -	      lda	#0
    672  1e6a				  -DebugClrLoop
    673  1e6a				  -	      sta	TOKENBUFFER,x
    674  1e6a				  -	      dex
    675  1e6a				  -	      bne	DebugClrLoop
    676  1e6a				  -	      sta	TOKENBUFFER,x
    677  1e6a				  -	      pla
    678  1e6a				  -	      tax
    679  1e6a				  -	      rts
    680  1e6a				  -
    681  1e6a				  -			;=====================================================
    682  1e6a				  -			; Print the parser buffer as hex values
    683  1e6a				  -printTokenBuffer
    684  1e6a				  -	      stx	printStorage
    685  1e6a				  -	      sty	printStorage+1
    686  1e6a				  -	      sta	printStorage+2
    687  1e6a				  -
    688  1e6a				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    689  1e6a				  -	      inx		; we want to show the last zero byte
    690  1e6a				  -	      ldy	#0
    691  1e6a				  -
    692  1e6a				  -printHexLoop
    693  1e6a				  -	      lda	TOKENBUFFER,y	; get the character
    694  1e6a				  -	      jsr	HexToOut	; print it
    695  1e6a				  -	      lda	#$20
    696  1e6a				  -	      jsr	VOUTCH
    697  1e6a				  -	      iny
    698  1e6a				  -	      dex
    699  1e6a				  -	      cpx	#0
    700  1e6a				  -	      bne	printHexLoop
    701  1e6a				  -	      jsr	CRLF
    702  1e6a				  -
    703  1e6a				  -	      ldy	printStorage+1
    704  1e6a				  -	      ldx	printStorage
    705  1e6a				  -	      lda	printStorage+2
    706  1e6a				  -printHexDone
    707  1e6a				  -	      clc
    708  1e6a				  -	      rts
    709  1e6a					      endif
    710  1e6a
    711  1e6a
    712  1e6a							;=========================================================================================================
    713  1e6a							; Parse for variables A-Z @, ^  x!x x[op]
    714  1e6a				   ParseForVariable
    715  1e6a		       a4 51		      ldy	CUROFF
    716  1e6c		       b9 ea 41 	      lda	LINBUF,y
    717  1e6f		       c9 5e		      cmp	#'^	; is it an exit code
    718  1e71		       d0 04		      bne	ParseVarMem
    719  1e73		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    720  1e75		       d0 1f		      bne	ParseVarSpecial
    721  1e77
    722  1e77				   ParseVarMem
    723  1e77		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    724  1e79		       d0 04		      bne	ParseVarStack
    725  1e7b		       a9 9d		      lda	#tVat
    726  1e7d		       d0 17		      bne	ParseVarSpecial
    727  1e7f
    728  1e7f				   ParseVarStack
    729  1e7f		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    730  1e81		       d0 04		      bne	ParseVarLetters
    731  1e83		       a9 9c		      lda	#tVhash
    732  1e85		       d0 0f		      bne	ParseVarSpecial
    733  1e87
    734  1e87				   ParseVarLetters
    735  1e87		       29 df		      and	#%11011111	; Force upper case
    736  1e89		       c9 41		      cmp	#'A
    737  1e8b		       90 12		      bcc	ParseVarInvalid
    738  1e8d		       c9 5b		      cmp	#'Z+1
    739  1e8f		       b0 0e		      bcs	ParseVarInvalid
    740  1e91							;
    741  1e91							; The condition is true, so convert to an index, push
    742  1e91							; it onto the stack and continue running.
    743  1e91							;
    744  1e91		       38		      sec
    745  1e92		       e9 41		      sbc	#'A	;index is zero based
    746  1e94		       09 80		      ora	#$80
    747  1e96
    748  1e96				   ParseVarSpecial
    749  1e96		       9d d2 1b 	      sta	TOKENBUFFER,x
    750  1e99		       e8		      inx
    751  1e9a		       c8		      iny
    752  1e9b		       84 51		      sty	CUROFF
    753  1e9d		       18		      clc
    754  1e9e		       60		      rts
    755  1e9f
    756  1e9f				   ParseVarInvalid
    757  1e9f		       38		      sec
    758  1ea0		       60		      rts
    759  1ea1
    760  1ea1
    761  1ea1							;=========================================================================================================
    762  1ea1							; Transfer R0 to the TOKENBUFFER
    763  1ea1							;
    764  1ea1				   R02TOKEN
    765  1ea1		       a5 52		      lda	R0
    766  1ea3		       9d d2 1b 	      sta	TOKENBUFFER,x
    767  1ea6		       e8		      inx
    768  1ea7		       a5 53		      lda	R0+1
    769  1ea9		       9d d2 1b 	      sta	TOKENBUFFER,x
    770  1eac		       e8		      inx
    771  1ead		       18		      clc
    772  1eae		       60		      rts
    773  1eaf							;=========================================================================
    774  1eaf							; Transfer word in Token Buffer to R0
    775  1eaf				   TOKEN2R0
    776  1eaf		       b9 d2 1b 	      lda	TOKENBUFFER,y
    777  1eb2		       85 52		      sta	R0
    778  1eb4		       c8		      iny
    779  1eb5		       ca		      dex
    780  1eb6		       b9 d2 1b 	      lda	TOKENBUFFER,y
    781  1eb9		       c8		      iny
    782  1eba		       ca		      dex
    783  1ebb		       85 53		      sta	R0+1
    784  1ebd		       60		      rts
    785  1ebe							;==========================================================================
    786  1ebe							; Transfer	Display Buffer position to R0
    787  1ebe							;
    788  1ebe				   DPL2R0
    789  1ebe		       b1 59		      lda	(dpl),y
    790  1ec0		       85 52		      sta	R0
    791  1ec2		       c8		      iny
    792  1ec3		       ca		      dex
    793  1ec4		       b1 59		      lda	(dpl),y
    794  1ec6		       c8		      iny
    795  1ec7		       ca		      dex
    796  1ec8		       85 53		      sta	R0+1
    797  1eca		       60		      rts
    798  1ecb
    799  1ecb
    800  1ecb							;=========================================================================
    801  1ecb							; Read an IL byte lookit up in the table, of words
    802  1ecb							; set the next ilpc to point to that address
    803  1ecb							; if not found then do ussual filter stuff
    804  1ecb							; ongoto ilvectortable, not found address
    805  1ecb		       20 ac 29    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    806  1ece		       86 52		      stx	R0
    807  1ed0		       85 53		      sta	R0+1
    808  1ed2
    809  1ed2		       a4 51		      ldy	CUROFF
    810  1ed4		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    811  1ed6		       a0 00		      ldy	#0
    812  1ed8		       38		      sec
    813  1ed9		       f1 52		      sbc	(R0),y	; Subract the base value
    814  1edb		       c8		      iny
    815  1edc		       d1 52		      cmp	(R0),y	; Check if we are in range
    816  1ede		       b0 12		      bcs	iOnGotoInvalid
    817  1ee0		       e6 51		      inc	CUROFF	; Save the offset
    818  1ee2
    819  1ee2		       0a		      asl
    820  1ee3		       a8		      tay		; Turn into vector
    821  1ee4		       c8		      iny		; Inc must include the table base and entry count
    822  1ee5		       c8		      iny
    823  1ee6
    824  1ee6		       b1 52		      lda	(R0),y
    825  1ee8		       85 43		      sta	ILPC
    826  1eea		       c8		      iny
    827  1eeb		       b1 52		      lda	(R0),y
    828  1eed		       85 44		      sta	ILPC+1
    829  1eef		       4c b1 02 	      jmp	NextIL
    830  1ef2
    831  1ef2				   iOnGotoInvalid
    832  1ef2		       20 ac 29 	      jsr	getILWord
    833  1ef5		       86 43		      stx	ILPC
    834  1ef7		       85 44		      sta	ILPC+1
    835  1ef9		       4c b1 02 	      jmp	NextIL
    836  1efc							;
    837  1efc							;==========================================================================================
    838  1efc							; Test the token for relop and push the value onto the stack if true
    839  1efc							;
    840  1efc				   iTSTRELOP
    841  1efc		       20 b0 29 	      jsr	getILByte
    842  1eff		       8d 7f 42 	      sta	offset
    843  1f02
    844  1f02		       a4 51		      ldy	CUROFF
    845  1f04		       b1 4f		      lda	(CURPTR),y
    846  1f06		       48		      pha
    847  1f07		       29 f0		      and	#$F0
    848  1f09		       c9 f0		      cmp	#$F0
    849  1f0b		       d0 12		      bne	iTSTRELOPNOT
    850  1f0d		       68		      pla
    851  1f0e		       29 0f		      and	#$0F	; get the actual value
    852  1f10		       85 52		      sta	R0	; save it for later
    853  1f12		       a9 00		      lda	#0
    854  1f14		       85 53		      sta	R0+1
    855  1f16		       20 a9 2b 	      jsr	pushR0
    856  1f19		       c8		      iny
    857  1f1a		       84 51		      sty	CUROFF	; save the y pointer
    858  1f1c		       4c b1 02 	      jmp	NextIL
    859  1f1f
    860  1f1f				   iTSTRELOPNOT
    861  1f1f		       68		      pla
    862  1f20		       4c d7 0b 	      jmp	tstBranch
    863  1f23
    864  1f23							;
    865  1f23							;===================================================================================================
    866  1f23							; Test the token and following info for precompiled address information
    867  1f23							; skip it if zero, transfer and skip next integer value if not zero
    868  1f23							; used by both gosub, goto and gofN
    869  1f23							;
    870  1f23				   iTSTBRANCH		; il format TSTBRANCH whereToGoIfFailed
    871  1f23		       20 b0 29 	      jsr	getILByte	; Get jump address if vector is valid
    872  1f26		       8d 7f 42 	      sta	offset	; Mark offset for later if vector found
    873  1f29		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    874  1f2b		       88		      dey		; point back to the type of branch
    875  1f2c		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    876  1f2e		       48		      pha		; Save till needed
    877  1f2f		       c8		      iny		; back to memory vectors
    878  1f30				   ITSTBRANCHCont
    879  1f30		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    880  1f32		       85 52		      sta	R0	; R0 will contain mem pointer of present
    881  1f34		       c8		      iny		; Point to next byte of mem vector
    882  1f35		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    883  1f37		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    884  1f39		       c8		      iny		; Point to the byte past memory vector
    885  1f3a		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    886  1f3c
    887  1f3c		       05 52		      ora	R0	; Get the second byte of the mem
    888  1f3e		       f0 28		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    889  1f40		       68		      pla
    890  1f41		       c9 07		      cmp	#kGoto	; Short cut lots if a goto stuff
    891  1f43		       d0 03		      bne	NotGoto
    892  1f45		       4c dc 04 	      jmp	FastFastXfer
    893  1f48				   NotGoto
    894  1f48		       c9 2f		      cmp	#kTask	; Task defined with Task() so bypass the first bracket
    895  1f4a		       d0 07		      bne	iTSTBRANCHCont
    896  1f4c		       b1 4f		      lda	(CURPTR),y
    897  1f4e		       c9 e0		      cmp	#oLeftBracket
    898  1f50		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    899  1f52		       c8		      iny		; Increment past the bracket
    900  1f53				   iTSTBRANCHCont
    901  1f53		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    902  1f55		       c9 a2		      cmp	#tByte	; A byte value is valid
    903  1f57		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    904  1f59		       c9 a4		      cmp	#tInteger	; An integer value is valid
    905  1f5b		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    906  1f5d		       c8		      iny		; skip type indicator for
    907  1f5e				   ITSTBRANCHBYTE
    908  1f5e		       c8		      iny		; skip first byte of value line number
    909  1f5f		       c8		      iny		; Skip second byte of line number
    910  1f60
    911  1f60				   iTSTBRANCHVALID
    912  1f60		       84 51		      sty	CUROFF
    913  1f62		       20 a9 2b 	      jsr	pushR0	; place transfer address on top of stack
    914  1f65		       4c d7 0b 	      jmp	tstBranch
    915  1f68
    916  1f68				   iTSTBRANCHNoCompile
    917  1f68		       68		      pla
    918  1f69				   iTSTBRANCHErr
    919  1f69		       4c b1 02 	      jmp	NextIL
    920  1f6c
    921  1f6c
    922  1f6c
    923  1f6c
    924  1f6c
    925  1f6c
    926  1f6c
    927  1f6c
    928  1f6c
    929  1f6c
------- FILE mytb.asm
------- FILE compile.asm LEVEL 2 PASS 6
      0  1f6c					      include	"compile.asm"
      1  1f6c					      Seg	Code
      2  1f6c							;
      3  1f6c							;=====================================================================
      4  1f6c							; Scan the loaded program just before running and insert memory locations of each
      5  1f6c							; line number branched to. goto gosub, gofn
      6  1f6c							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value}
      7  1f6c				   Compile
      8  1f6c		       a9 00		      lda	#0
      9  1f6e		       85 52		      sta	R0	; keep track of how many errors we find
     10  1f70		       a5 5b		      lda	RunMode
     11  1f72		       48		      pha
     12  1f73		       e6 5b		      inc	RunMode	; force run mode for error reporting
     13  1f75		       a5 4f		      lda	CURPTR
     14  1f77		       48		      pha
     15  1f78		       a5 50		      lda	CURPTR+1
     16  1f7a		       48		      pha
     17  1f7b		       a5 51		      lda	CUROFF
     18  1f7d		       48		      pha
     19  1f7e		       ad 83 42 	      lda	ProgramStart
     20  1f81		       85 59		      sta	dpl
     21  1f83		       ad 84 42 	      lda	ProgramStart+1
     22  1f86		       85 5a		      sta	dpl+1
     23  1f88
     24  1f88				   CompileLineStart
     25  1f88		       a5 59		      lda	dpl
     26  1f8a		       cd 85 42 	      cmp	ProgramEnd
     27  1f8d		       d0 07		      bne	CompileContinue
     28  1f8f		       a5 5a		      lda	dpl+1
     29  1f91		       cd 86 42 	      cmp	ProgramEnd+1
     30  1f94		       f0 3f		      beq	CompileComplete
     31  1f96
     32  1f96				   CompileContinue
     33  1f96		       a0 03		      ldy	#3	; first real character in the line
     34  1f98
     35  1f98				   CompileLoop
     36  1f98		       b1 59		      lda	(dpl),y	; get the byte
     37  1f9a		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     38  1f9c		       c8		      iny		; Pass this byte
     39  1f9d		       c9 07		      cmp	#kGoto
     40  1f9f		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     41  1fa1		       c9 08		      cmp	#kGosub
     42  1fa3		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     43  1fa5		       c9 37		      cmp	#kGofn
     44  1fa7		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  1fa9		       c9 2f		      cmp	#kTask
     46  1fab		       f0 4c		      beq	CompileField
     47  1fad		       c9 0a		      cmp	#kRem
     48  1faf		       f0 12		      beq	CompileRem	; Skip until end of line
     49  1fb1		       c9 a0		      cmp	#tString
     50  1fb3		       f0 2f		      beq	CompileString
     51  1fb5		       c9 a4		      cmp	#tInteger
     52  1fb7		       f0 06		      beq	CompileInteger
     53  1fb9		       c9 a2		      cmp	#tByte
     54  1fbb		       f0 03		      beq	CompileByte
     55  1fbd		       d0 d9		      bne	CompileLoop	; Next character
     56  1fbf
     57  1fbf				   CompileInteger
     58  1fbf		       c8		      iny
     59  1fc0				   CompileByte
     60  1fc0		       c8		      iny
     61  1fc1		       d0 d5		      bne	CompileLoop
     62  1fc3				   CompileRem
     63  1fc3				   CompileEndOfLine
     64  1fc3		       a0 00		      ldy	#0
     65  1fc5		       b1 59		      lda	(dpl),y
     66  1fc7		       18		      clc
     67  1fc8		       65 59		      adc	dpl
     68  1fca		       85 59		      sta	dpl
     69  1fcc		       a9 00		      lda	#0
     70  1fce		       65 5a		      adc	dpl+1
     71  1fd0		       85 5a		      sta	dpl+1
     72  1fd2
     73  1fd2		       4c 88 1f 	      jmp	CompileLineStart
     74  1fd5
     75  1fd5				   CompileComplete
     76  1fd5		       68		      pla
     77  1fd6		       85 51		      sta	CUROFF
     78  1fd8		       68		      pla
     79  1fd9		       85 50		      sta	CURPTR+1
     80  1fdb		       68		      pla
     81  1fdc		       85 4f		      sta	CURPTR
     82  1fde		       68		      pla
     83  1fdf		       85 5b		      sta	RunMode
     84  1fe1		       a5 52		      lda	R0	; returning the number of errors
     85  1fe3		       60		      rts
     86  1fe4
     87  1fe4
     88  1fe4				   CompileString
     89  1fe4		       c8		      iny		; point past first "
     90  1fe5				   CompileStringLoop
     91  1fe5		       b1 59		      lda	(dpl),y
     92  1fe7		       f0 0d		      beq	CompileStrDone2	; end of line
     93  1fe9		       c9 22		      cmp	#'"	; end of string
     94  1feb		       f0 08		      beq	CompileStrDone
     95  1fed		       c9 5c		      cmp	#'\	; escape character
     96  1fef		       d0 01		      bne	CompileStrNext
     97  1ff1		       c8		      iny		; skip the escape character
     98  1ff2				   CompileStrNext
     99  1ff2		       c8		      iny		; Next character
    100  1ff3		       d0 f0		      bne	CompileStringLoop	; test for end
    101  1ff5				   CompileStrDone
    102  1ff5		       c8		      iny
    103  1ff6				   CompileStrDone2
    104  1ff6		       4c 98 1f 	      Jmp	CompileLoop
    105  1ff9							;
    106  1ff9							;===============================================================
    107  1ff9							; on entry y points to storage location y+2 points to line number
    108  1ff9							; on exit y points to line number type
    109  1ff9
    110  1ff9		       85 52	   CompileField sta	R0
    111  1ffb		       98		      tya		; save the y pointer to store the memory value
    112  1ffc		       48		      pha
    113  1ffd		       c8		      iny		; Skip over the memory vector
    114  1ffe		       c8		      iny
    115  1fff		       a5 52		      lda	R0
    116  2001		       c9 2f		      cmp	#kTask	; for a task it is the next byte after a bracket
    117  2003		       d0 07		      bne	CompNoBracket
    118  2005
    119  2005		       b1 59		      lda	(dpl),y	; Lets make sure it is a )
    120  2007		       c9 e0		      cmp	#oLeftBracket
    121  2009		       d0 01		      bne	CompNoBracket	; in case of error
    122  200b		       c8		      iny		; skip the bracket
    123  200c
    124  200c				   CompNoBracket
    125  200c		       a9 00		      lda	#0	; In case the value is a byte
    126  200e		       85 53		      sta	R0+1
    127  2010
    128  2010		       b1 59		      lda	(dpl),Y	; get the type of the next byte t something or other
    129  2012		       c9 a2		      cmp	#tByte
    130  2014		       f0 15		      beq	CompByteLoad
    131  2016		       c9 a4		      cmp	#tInteger
    132  2018		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    133  201a		       68		      pla
    134  201b		       4c 98 1f 	      jmp	CompileLoop	; Ignore the saved stack
    135  201e				   CompIntLoad
    136  201e		       c8		      iny
    137  201f		       b1 59		      lda	(dpl),y
    138  2021		       85 52		      sta	R0
    139  2023		       c8		      iny
    140  2024		       b1 59		      lda	(dpl),y
    141  2026		       85 53		      sta	R0+1
    142  2028		       4c 30 20 	      jmp	CompFindLine
    143  202b				   CompByteLoad
    144  202b		       c8		      iny
    145  202c		       b1 59		      lda	(dpl),y
    146  202e		       85 52		      sta	R0
    147  2030				   CompFindLine
    148  2030		       20 f5 29 	      jsr	findLine
    149  2033		       f0 1d		      beq	CompFoundLine
    150  2035		       e6 52		      inc	R0	; number of errors
    151  2037
    152  2037		       a5 59		      lda	dpl
    153  2039		       85 4f		      sta	CURPTR
    154  203b		       a5 5a		      lda	dpl+1
    155  203d		       85 50		      sta	CURPTR+1
    156  203f		       84 51		      sty	CUROFF
    157  2041
    158  2041		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    159  2043		       a9 00		      lda	#0
    160  2045
    161  2045		       20 27 06 	      jsr	DisplayError
    162  2048		       20 ca 21 	      jsr	PrintProgramLine
    163  204b
    164  204b		       68		      pla
    165  204c		       a8		      tay
    166  204d		       c8		      iny
    167  204e		       c8		      iny
    168  204f		       4c 98 1f 	      jmp	CompileLoop
    169  2052
    170  2052				   CompFoundLine
    171  2052		       68		      pla
    172  2053		       a8		      tay
    173  2054		       a5 4f		      lda	CURPTR
    174  2056		       91 59		      sta	(dpl),y
    175  2058		       c8		      iny
    176  2059		       a5 50		      lda	CURPTR+1
    177  205b		       91 59		      sta	(dpl),y
    178  205d		       c8		      iny
    179  205e		       4c 98 1f 	      jmp	CompileLoop
    180  2061
    181  2061
    182  2061
    183  2061
    184  2061
    185  2061
    186  2061
    187  2061
    188  2061
    189  2061
    190  2061
    191  2061
    192  2061
    193  2061
    194  2061
    195  2061
    196  2061
    197  2061
    198  2061
    199  2061
    200  2061
    201  2061
    202  2061
    203  2061
    204  2061
    205  2061
    206  2061
    207  2061
    208  2061
    209  2061
    210  2061
    211  2061
    212  2061
    213  2061
    214  2061
    215  2061
    216  2061
    217  2061
    218  2061
    219  2061
    220  2061
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  2061					      include	"print.asm"
      1  2061					      Seg	Code
      2  2061							;---------------------------
      3  2061							; Print 24-bit decimal number or  16bit unsigned
      4  2061							; ---------------------------
      5  2061							; On entry, R0=number to print
      6  2061							;	     Defaults to pad=0 , y=21 default
      7  2061							;	     R2 = 1 unsigned 16 bit
      8  2061							;	     R2 = 0 Signed   16 bit
      9  2061
     10  2061							; On entry at PrintDecPadded:
     11  2061							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  2061
     13  2061							; On exit,  A,X,Y,num,pad corrupted
     14  2061							; Size      129 bytes, Table 24 bytes	--- total 153
     15  2061							; -----------------------------------------------------------------
     16  2061
     17  2061				   PrintDecimal
     18  2061		       8a		      TXA
     19  2062		       48		      pha
     20  2063		       98		      tya
     21  2064		       48		      pha
     22  2065		       a9 00		      lda	#0
     23  2067		       8d fc 20 	      sta	pad
     24  206a		       a0 15		      LDY	#21	; Offset to powers of ten
     25  206c		       4c 72 20 	      JMP	PrintDo
     26  206f
     27  206f				   PrintDecPadded
     28  206f		       8e fc 20 	      stx	pad
     29  2072
     30  2072				   PrintDo
     31  2072		       a9 00		      lda	#0
     32  2074		       85 54		      sta	R1
     33  2076
     34  2076		       a5 58		      lda	R2
     35  2078		       c9 a9		      cmp	#tUint
     36  207a		       f0 29		      beq	PrintPos
     37  207c
     38  207c		       a5 53		      lda	R0+1	;MSB has sign
     39  207e		       10 25		      bpl	PrintPos	;it's a positive number;
     40  2080
     41  2080
     42  2080							; Negative numbers need more work.  Invert all the bits,
     43  2080							; then add one.
     44  2080
     45  2080		       a9 2d		      lda	#'-
     46  2082		       20 e3 19 	      jsr	VOUTCH	;print the negative sign
     47  2085
     48  2085		       a9 ff		      lda	#$FF
     49  2087		       85 54		      sta	R1
     50  2089		       a5 52		      lda	R0	;invert bits
     51  208b		       49 ff		      eor	#$ff
     52  208d		       85 52		      sta	R0
     53  208f		       a5 53		      lda	R0+1
     54  2091		       49 ff		      eor	#$ff
     55  2093		       85 53		      sta	R0+1
     56  2095		       a5 54		      lda	R1
     57  2097		       49 ff		      eor	#$ff
     58  2099		       85 54		      sta	R1
     59  209b		       e6 52		      inc	R0	;add one
     60  209d		       d0 06		      bne	PrintPos
     61  209f		       e6 53		      inc	R0+1
     62  20a1		       d0 02		      bne	PrintPos
     63  20a3		       e6 54		      inc	R1
     64  20a5				   PrintPos
     65  20a5
     66  20a5				   PrDec24Lp1
     67  20a5		       a2 ff		      LDX	#$FF
     68  20a7		       38		      SEC		; Start with digit=-1
     69  20a8				   PrDec24Lp2
     70  20a8		       a5 52		      LDA	R0+0
     71  20aa		       f9 fd 20 	      SBC	PrDec24Tens+0,Y
     72  20ad		       85 52		      STA	R0+0	; Subtract current tens
     73  20af		       a5 53		      LDA	R0+1
     74  20b1		       f9 fe 20 	      SBC	PrDec24Tens+1,Y
     75  20b4		       85 53		      STA	R0+1
     76  20b6		       a5 54		      LDA	R0+2
     77  20b8		       f9 ff 20 	      SBC	PrDec24Tens+2,Y
     78  20bb		       85 54		      STA	R0+2
     79  20bd		       e8		      INX
     80  20be		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     81  20c0		       a5 52		      LDA	R0+0
     82  20c2		       79 fd 20 	      ADC	PrDec24Tens+0,Y
     83  20c5		       85 52		      STA	R0+0	; Add current tens back in
     84  20c7		       a5 53		      LDA	R0+1
     85  20c9		       79 fe 20 	      ADC	PrDec24Tens+1,Y
     86  20cc		       85 53		      STA	R0+1
     87  20ce		       a5 54		      LDA	R0+2
     88  20d0		       79 ff 20 	      ADC	PrDec24Tens+2,Y
     89  20d3		       85 54		      STA	R0+2
     90  20d5		       8a		      TXA
     91  20d6		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     92  20d8		       ad fc 20 	      LDA	pad
     93  20db		       d0 09		      BNE	PrDec24Print
     94  20dd		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     95  20df				   PrDec24Digit
     96  20df		       a2 30		      LDX	#'0
     97  20e1		       8e fc 20 	      STX	pad	; No more zero padding
     98  20e4		       09 30		      ORA	#'0	; Print this digit
     99  20e6				   PrDec24Print
    100  20e6		       20 e3 19 	      JSR	VOUTCH
    101  20e9				   PrDec24Next
    102  20e9		       88		      DEY
    103  20ea		       88		      DEY
    104  20eb		       88		      DEY
    105  20ec		       f0 07		      beq	PrDec24LastDigit
    106  20ee		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    107  20f0		       68		      pla
    108  20f1		       a8		      tay
    109  20f2		       68		      pla
    110  20f3		       aa		      tax
    111  20f4		       60		      RTS
    112  20f5				   PrDec24LastDigit
    113  20f5		       a2 30		      LDX	#'0
    114  20f7		       8e fc 20 	      STX	pad	; No more zero padding
    115  20fa		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    116  20fc
      0  20fc				   pad	      db	0
      1  20fc		       00		      .byte.b	0
    118  20fd
    119  20fd				   PrDec24Tens
      0  20fd					      dw	1
      1  20fd		       01 00		      .word.w	1
      0  20ff					      db	(1 / 65536)
      1  20ff		       00		      .byte.b	(1 / 65536)
      0  2100					      dw	10
      1  2100		       0a 00		      .word.w	10
      0  2102					      db	(10 / 65536)
      1  2102		       00		      .byte.b	(10 / 65536)
      0  2103					      dw	100
      1  2103		       64 00		      .word.w	100
      0  2105					      db	(100 / 65536)
      1  2105		       00		      .byte.b	(100 / 65536)
      0  2106					      dw	1000
      1  2106		       e8 03		      .word.w	1000
      0  2108					      db	(1000 / 65536)
      1  2108		       00		      .byte.b	(1000 / 65536)
      0  2109					      dw	10000
      1  2109		       10 27		      .word.w	10000
      0  210b					      db	(10000 / 65536)
      1  210b		       00		      .byte.b	(10000 / 65536)
      0  210c					      dw	100000
      1  210c		       a0 86		      .word.w	100000
      0  210e					      db	(100000 / 65536)
      1  210e		       01		      .byte.b	(100000 / 65536)
      0  210f					      dw	1000000
      1  210f		       40 42		      .word.w	1000000
      0  2111					      db	(1000000 / 65536)
      1  2111		       0f		      .byte.b	(1000000 / 65536)
      0  2112					      dw	10000000
      1  2112		       80 96		      .word.w	10000000
      0  2114					      db	(10000000 / 65536)
      1  2114		       98		      .byte.b	(10000000 / 65536)
    136  2115							;=====================================================
    137  2115							; Print character in A as two hex digits to the Console
    138  2115
    139  2115		       48	   HexToOut   pha		;save return value
    140  2116		       48		      pha
    141  2117		       4a		      lsr		;a  ;move top nibble to bottom
    142  2118		       4a		      lsr		;a
    143  2119		       4a		      lsr		;a
    144  211a		       4a		      lsr		;a
    145  211b		       20 24 21 	      jsr	hexta	;output nibble
    146  211e		       68		      pla
    147  211f		       20 24 21 	      jsr	hexta
    148  2122		       68		      pla		;restore
    149  2123		       60		      rts
    150  2124							;
    151  2124		       29 0f	   hexta      and	#%0001111
    152  2126		       c9 0a		      cmp	#$0a
    153  2128		       18		      clc
    154  2129		       30 02		      bmi	hexta1
    155  212b		       69 07		      adc	#7
    156  212d		       69 30	   hexta1     adc	#'0	;then fall into...
    157  212f		       4c e3 19 	      jmp	VOUTCH
    158  2132							;
    159  2132							;=====================================================
    160  2132							; Print the string that immediately follows the JSR to
    161  2132							; this function.  Stops when a null byte is found,
    162  2132							; then returns to the instruction immediately
    163  2132							; following the null.
    164  2132							;
    165  2132							; Thanks to Ross Archer for this code.
    166  2132							; http://www.6502.org/source/io/primm.htm
    167  2132							;
    168  2132
    169  2132		       68	   tbputs     pla		;Get the low part of "return" address
    170  2133							;(data start address)
    171  2133		       85 5e		      sta	PrtFrom
    172  2135		       68		      pla
    173  2136		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    174  2138							;(data start address)
    175  2138							;Note: actually we're pointing one short
    176  2138		       a0 01	   PSINB      ldy	#1
    177  213a		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    178  213c		       e6 5e		      inc	PrtFrom	;update the pointer
    179  213e		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    180  2140		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    181  2142		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    182  2144							;   Accumulator
    183  2144		       f0 06		      beq	PSIX1	;don't print the final NULL
    184  2146		       20 e3 19 	      jsr	VOUTCH	;write it out
    185  2149		       4c 38 21 	      jmp	PSINB	;back around
    186  214c		       e6 5e	   PSIX1      inc	PrtFrom
    187  214e		       d0 02		      bne	PSIX2
    188  2150		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    189  2152		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    190  2155
    191  2155							;+
    192  2155							;====================================================
    193  2155		       42 7b	   PrtTerm    equ	tempy
    194  2155
    195  2155							; on exit Print Y has the offset to use
    196  2155							; input y =	 addr low
    197  2155							;	 x =	 addr high
    198  2155							;	 a =	 termination string
    199  2155
    200  2155
    201  2155				   PrtQuoted		; Print a quoted string from the current program space
    202  2155		       a9 22		      lda	#'"
    203  2157		       a4 51		      ldy	CUROFF
    204  2159		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    205  215b		       d0 03		      bne	PrtNoInc
    206  215d		       c8		      iny
    207  215e		       84 51		      sty	CUROFF
    208  2160				   PrtNoInc
    209  2160		       8d 7b 42 	      sta	PrtTerm
    210  2163
    211  2163				   PrtPrgString 		; Print a terminated string from the static program space
    212  2163		       a4 51		      ldy	CUROFF
    213  2165		       a5 4f		      lda	CURPTR
    214  2167		       85 5e		      sta	PrtFrom
    215  2169		       a5 50		      lda	CURPTR+1
    216  216b		       85 5f		      sta	PrtFrom+1
    217  216d		       4c 79 21 	      jmp	PrtLoop
    218  2170
    219  2170							; Print a string pointed to by x= h, y=l terminated by value in  accumulator
    220  2170							; Return y as the length
    221  2170
    222  2170		       86 5f	   PrtStr     stx	PrtFrom+1
    223  2172		       84 5e		      sty	PrtFrom
    224  2174		       8d 7b 42 	      sta	PrtTerm
    225  2177		       a0 00		      ldy	#0
    226  2179							;
    227  2179							; On entry here ptrfrom and prtterm point to area to print
    228  2179							;
    229  2179		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    230  217b		       cd 7b 42 	      cmp	PrtTerm
    231  217e		       f0 0b		      beq	PrtEnd
    232  2180		       c9 00		      cmp	#0	; always end if 0 is found
    233  2182		       f0 07		      beq	PrtEnd
    234  2184		       20 e3 19 	      jsr	VOUTCH
    235  2187		       c8		      iny
    236  2188		       4c 79 21 	      jmp	PrtLoop
    237  218b		       c8	   PrtEnd     iny		;return byte after the write
    238  218c		       60		      rts
    239  218d
    240  218d							;
    241  218d							;=======================================================
    242  218d							; Print all Variables
    243  218d				   PrintAllVars
    244  218d		       a0 00		      ldy	#0
    245  218f		       a9 41		      lda	#'A
    246  2191				   PrintAllVarsLoop
    247  2191		       48		      pha
    248  2192		       b1 41		      lda	(VARIABLES),y
    249  2194		       85 52		      sta	R0
    250  2196		       c8		      iny
    251  2197		       b1 41		      lda	(VARIABLES),y
    252  2199		       85 53		      sta	R0+1
    253  219b
    254  219b		       68		      pla		;get the current letter
    255  219c		       48		      pha
    256  219d		       20 e3 19 	      jsr	VOUTCH
    257  21a0		       20 32 21 	      jsr	puts
      0  21a3					      db	"=",0
      1  21a3		       3d 00		      .byte.b	"=",0
    259  21a5		       68		      pla
    260  21a6		       aa		      tax
    261  21a7		       e8		      inx
    262  21a8		       8a		      txa
    263  21a9		       48		      pha		;
    264  21aa
    265  21aa		       98		      tya
    266  21ab		       48		      pha
    267  21ac		       20 61 20 	      jsr	PrintDecimal
    268  21af		       20 32 21 	      jsr	puts
      0  21b2					      db	" ",0
      1  21b2		       20 00		      .byte.b	" ",0
    270  21b4		       68		      pla
    271  21b5		       a8		      tay
    272  21b6		       c8		      iny
    273  21b7		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    274  21b9		       90 d6		      bcc	PrintAllVarsLoop
    275  21bb		       20 f4 2c 	      jsr	CRLF
    276  21be
    277  21be		       68		      pla
    278  21bf		       60		      rts
    279  21c0							;==========================================================================================================
    280  21c0							;Debug   Print a Program Line from compile buffer
    281  21c0							;
    282  21c0				   DebugPrintProgramLine
    283  21c0		       48		      pha
    284  21c1		       a9 d2		      lda	#TOKENBUFFER&$FF
    285  21c3		       85 59		      sta	dpl
    286  21c5		       a9 1b		      lda	#TOKENBUFFER>>8
    287  21c7		       85 5a		      sta	dpl+1
    288  21c9		       68		      pla
    289  21ca
    290  21ca							; Decode and print a line of program text
    291  21ca							; on entry	 dpl points to line of code to print
    292  21ca							; on exit	 no change in reg or dpl
    293  21ca							;
    294  21ca				   PrintProgramLine
    295  21ca
    296  21ca		       8e d2 1c 	      stx	printStorage
    297  21cd		       8c d3 1c 	      sty	printStorage+1
    298  21d0		       48		      pha
    299  21d1
    300  21d1		       a0 01		      ldy	#1	; index into the token buffer
    301  21d3		       84 58		      sty	R2	; print unsigned decimal
    302  21d5		       a0 00		      ldy	#0
    303  21d7		       b1 59		      lda	(dpl),y	; get number of bytes
    304  21d9		       aa		      tax		; place pointer into x
    305  21da		       c8		      iny
    306  21db		       ca		      dex		; Deduct the length byte
    307  21dc		       20 be 1e 	      jsr	DPL2R0	; Print the line number
    308  21df		       20 61 20 	      jsr	PrintDecimal
    309  21e2		       a9 20		      lda	#$20
    310  21e4		       20 e3 19 	      jsr	VOUTCH
    311  21e7
    312  21e7				   PrintProgLoop
    313  21e7		       b1 59		      lda	(dpl),y	; Get a character
    314  21e9		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    315  21eb		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    316  21ed		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    317  21ef
    318  21ef				   PrintProgVars
    319  21ef		       b1 59		      lda	(dpl),y
    320  21f1		       29 e0		      and	#$E0	; Check for operators and punctuation
    321  21f3		       c9 e0		      cmp	#$E0
    322  21f5		       f0 6b		      beq	PrintProgOperatorVect
    323  21f7
    324  21f7		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    325  21f9		       c9 9e		      cmp	#$9D+1
    326  21fb		       90 62		      bcc	PrintProgVariableVec
    327  21fd		       29 a0		      and	#$A0	; Check for a valid datatype
    328  21ff		       c9 a0		      cmp	#$A0
    329  2201		       f0 06		      beq	PrintDataType	; if not just print the character
    330  2203		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    331  2205		       ca		      dex		; Ok we are processing it
    332  2206		       c8		      iny
    333  2207		       d0 25		      bne	PrintContinue	; Print and do the next character
    334  2209
    335  2209				   PrintDataType
    336  2209		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    337  220b		       c9 a0		      cmp	#tString
    338  220d		       f0 31		      beq	PrintStringVariable
    339  220f
    340  220f				   PrintProgNumber
    341  220f		       c8		      iny		; we have a numerical integer value
    342  2210		       ca		      dex
    343  2211		       48		      pha
    344  2212		       a9 00		      lda	#0
    345  2214		       85 53		      sta	R0+1
    346  2216		       85 58		      sta	R2	; Set to print signed number
    347  2218		       b1 59		      lda	(dpl),y
    348  221a		       85 52		      sta	R0
    349  221c		       68		      pla
    350  221d		       c9 a4		      cmp	#tInteger
    351  221f		       d0 06		      bne	PrintProgNumDone
    352  2221		       c8		      iny
    353  2222		       ca		      dex
    354  2223		       b1 59		      lda	(dpl),y
    355  2225		       85 53		      sta	R0+1
    356  2227
    357  2227				   PrintProgNumDone
    358  2227		       c8		      iny
    359  2228		       ca		      dex
    360  2229		       20 61 20 	      jsr	PrintDecimal
    361  222c
    362  222c				   PrintProgNext
    363  222c		       a9 20		      lda	#$20
    364  222e				   PrintContinue
    365  222e		       20 e3 19 	      jsr	VOUTCH
    366  2231				   PrintProgSkipSpace
    367  2231		       e0 00		      cpx	#0
    368  2233		       d0 b2		      bne	PrintProgLoop
    369  2235				   PrintProgramComplete
    370  2235		       20 f4 2c 	      jsr	CRLF
    371  2238
    372  2238		       ae d2 1c 	      ldx	printStorage
    373  223b		       ac d3 1c 	      ldy	printStorage+1
    374  223e		       68		      pla
    375  223f
    376  223f		       60		      rts
    377  2240							;=================================================================================================================
    378  2240							; Print a string variable including the quotes
    379  2240							; On Input	 y is offset into buffer
    380  2240							; On Exit	 y is updated to new offset
    381  2240
    382  2240				   PrintStringVariable
    383  2240		       c8		      iny
    384  2241		       a9 22		      lda	#'"
    385  2243		       20 e3 19 	      jsr	VOUTCH
    386  2246		       c8		      iny
    387  2247		       a5 59		      lda	dpl
    388  2249		       85 5e		      sta	PrtFrom
    389  224b		       a5 5a		      lda	dpl+1
    390  224d		       85 5f		      sta	PrtFrom+1
    391  224f		       a9 22		      lda	#'"
    392  2251		       8d 7b 42 	      sta	PrtTerm
    393  2254		       20 79 21 	      jsr	PrtLoop
    394  2257		       a9 22		      lda	#'"
    395  2259		       20 e3 19 	      jsr	VOUTCH
    396  225c		       4c 2c 22 	      jmp	PrintProgNext
    397  225f
    398  225f				   PrintProgVariableVec
    399  225f		       4c ff 22 	      jmp	PrintProgVariable
    400  2262
    401  2262				   PrintProgOperatorVect
    402  2262		       4c d6 22 	      jmp	PrintProgOperator
    403  2265							;===============================================================================================================
    404  2265							; On entry dpl points to the buffer we are printing from
    405  2265							;	    y	current offset into the dpl buffer
    406  2265							; all registers preserved
    407  2265							;
    408  2265				   PrintKeyword
    409  2265
    410  2265		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    411  2267		       85 52		      sta	R0	; The value we are looking for
    412  2269		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    413  226b		       f0 0c		      beq	PrintKeyBranch
    414  226d		       c9 08		      cmp	#kGosub
    415  226f		       f0 08		      beq	PrintKeyBranch
    416  2271		       c9 2f		      cmp	#kTask
    417  2273		       f0 04		      beq	PrintKeyBranch
    418  2275		       c9 37		      cmp	#kGofn
    419  2277		       d0 04		      bne	PrintKeySkipped
    420  2279				   PrintKeyBranch
    421  2279		       c8		      iny		; Skip the compiled memory address
    422  227a		       c8		      iny
    423  227b		       ca		      dex		; Change number of bytes to print
    424  227c		       ca		      dex		; Remove the bytes to print
    425  227d
    426  227d				   PrintKeySkipped
    427  227d		       c8		      iny		; Inc y to point to the next char to be printed
    428  227e		       ca		      dex		; Reduce number of bytes to print
    429  227f		       98		      tya		; Save y and x for the return
    430  2280		       48		      pha
    431  2281		       8a		      txa
    432  2282		       48		      pha
    433  2283
    434  2283		       a9 9b		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    435  2285		       85 54		      sta	R1
    436  2287		       a9 1a		      lda	#KeyWordTable>>8
    437  2289		       85 55		      sta	R1+1
    438  228b
    439  228b
    440  228b				   PrintKeyLoop
    441  228b		       a0 00		      ldy	#0	; Index into the keyword entry
    442  228d		       b1 54		      lda	(R1),y	; Get token value for this entry
    443  228f		       c8		      iny		; Point to first byte of key
    444  2290		       c5 52		      cmp	R0	; Compare to the token we are looking for
    445  2292		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    446  2294
    447  2294				   PrintKeyNext
    448  2294		       b1 54		      lda	(R1),y	; Get key letter
    449  2296		       c8		      iny		; Point to next byte always
    450  2297		       29 20		      and	#%00100000	; Check for last character in key work
    451  2299		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    452  229b
    453  229b		       98		      tya		; Trabsfer y to a for the addition
    454  229c		       18		      clc		; Table > 256 bytes
    455  229d		       65 54		      adc	R1
    456  229f		       85 54		      sta	R1
    457  22a1		       a9 00		      lda	#0
    458  22a3		       65 55		      adc	R1+1
    459  22a5		       85 55		      sta	R1+1
    460  22a7		       4c 8b 22 	      jmp	PrintKeyLoop
    461  22aa
    462  22aa				   PrintKeyFound
    463  22aa		       b1 54		      lda	(R1),y	; letter from key table
    464  22ac		       48		      pha		; Save it for later check
    465  22ad		       09 20		      ora	#%00100000	; Force it to lower case
    466  22af		       20 e3 19 	      jsr	VOUTCH	; Print it out
    467  22b2		       c8		      iny		; Point to next character
    468  22b3		       68		      pla		; Restore the value
    469  22b4		       29 20		      and	#%00100000	; Check if it was last char in keyword
    470  22b6		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    471  22b8
    472  22b8		       68		      pla		; Restore the x and y values
    473  22b9		       aa		      tax
    474  22ba		       68		      pla
    475  22bb		       a8		      tay
    476  22bc
    477  22bc				   PrintChkRem
    478  22bc		       a9 0a		      lda	#kRem
    479  22be		       c5 52		      cmp	R0
    480  22c0		       d0 11		      bne	PrintKeyDone
    481  22c2				   PrintKeyRem
    482  22c2		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    483  22c4		       85 5e		      sta	PrtFrom
    484  22c6		       a5 5a		      lda	dpl+1
    485  22c8		       85 5f		      sta	PrtFrom+1
    486  22ca		       a9 00		      lda	#0
    487  22cc		       8d 7b 42 	      sta	PrtTerm
    488  22cf		       20 79 21 	      jsr	PrtLoop
    489  22d2		       88		      dey		; point back to the terminating null value
    490  22d3				   PrintKeyDone
    491  22d3		       4c 2c 22 	      jmp	PrintProgNext
    492  22d6							;==================================================================================================================
    493  22d6							;Print Variable, number or operator
    494  22d6				   PrintProgOperator
    495  22d6		       b1 59		      lda	(dpl),y
    496  22d8		       c8		      iny
    497  22d9		       ca		      dex
    498  22da		       8e d4 1c 	      stx	printStorage+2
    499  22dd		       a2 00		      ldx	#0
    500  22df				   PrintOprLoop
    501  22df		       dd 7d 1a 	      cmp	OperValues,x
    502  22e2		       f0 03		      beq	PrintOprFound
    503  22e4		       e8		      inx
    504  22e5		       d0 f8		      bne	PrintOprLoop
    505  22e7				   PrintOprFound
    506  22e7		       8a		      txa
    507  22e8		       0a		      asl
    508  22e9		       aa		      tax
    509  22ea		       bd 3f 1a 	      lda	Operators,x
    510  22ed		       20 e3 19 	      jsr	VOUTCH
    511  22f0		       e8		      inx
    512  22f1		       bd 3f 1a 	      lda	Operators,x
    513  22f4		       f0 03		      beq	PrintOprDone
    514  22f6		       20 e3 19 	      jsr	VOUTCH
    515  22f9				   PrintOprDone
    516  22f9		       ae d4 1c 	      ldx	printStorage+2
    517  22fc		       4c 2c 22 	      jmp	PrintProgNext
    518  22ff
    519  22ff							;=================================================================================================================
    520  22ff							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    521  22ff							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    522  22ff							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    523  22ff							;tVhat 	    equ     155 		   ; Variable ^
    524  22ff							;tVhash	    equ     156 		   ; Variable #
    525  22ff							;tVat		    equ     157 		   ; Variable @ = 0
    526  22ff				   PrintProgVariable
    527  22ff		       b1 59		      lda	(dpl),y
    528  2301		       c8		      iny
    529  2302		       ca		      dex
    530  2303		       c9 9b		      cmp	#tVhat
    531  2305		       d0 04		      bne	PrintProgChkHash
    532  2307		       a9 5e		      lda	#'^
    533  2309		       d0 15		      bne	PrintTheVar
    534  230b				   PrintProgChkHash
    535  230b		       c9 9c		      cmp	#tVhash
    536  230d		       d0 04		      bne	PrintProgChkAt
    537  230f		       a9 23		      lda	#'#
    538  2311		       d0 0d		      bne	PrintTheVar
    539  2313				   PrintProgChkAt
    540  2313		       c9 9d		      cmp	#tVat
    541  2315		       d0 04		      bne	PrintProgVarLetter
    542  2317		       a9 40		      lda	#'@
    543  2319		       d0 05		      bne	PrintTheVar
    544  231b				   PrintProgVarLetter
    545  231b		       29 7f		      and	#%01111111
    546  231d		       18		      clc
    547  231e		       69 41		      adc	#'A
    548  2320				   PrintTheVar
    549  2320		       20 e3 19 	      jsr	VOUTCH
    550  2323		       4c 2c 22 	      jmp	PrintProgNext
    551  2326
    552  2326
    553  2326							;==================================================================================================
    554  2326							; Size of print functions
    555  2326		       02 c5	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  2326					      include	"mem.asm"
      1  2326							;===================================================================
      2  2326							;This file contains the memory allocation and free functions
      3  2326							; This is the management of free memory in the system
      4  2326							; the interface to these functions
      5  2326							; a,x returns or provides the low hi bytes of the managed addresses
      6  2326							; This uses the programend, to memory end as the area to manage
      7  2326							;===================================================================
      8 U35c6					      Seg.u	TBData
      9 U35c6							;
     10 U35c6							;=====================================================
     11 U35c6							;Pointers for memory Management
     12 U35c6							;Allocated block are not chained but can be followed for all memory by the associated length
     13 U35c6							; Mem block format is
     14 U35c6							;	 0-1   pointer to next block for free blocks
     15 U35c6							;	 0-1   for allocated blocks
     16 U35c6							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     17 U35c6							;	   1   refrence counter ... lol only up to 256 but it is something
     18 U35c6							;	 2-3   length constant for exevy type of memory block
     19 U35c6							; Memory is recombined as it is released
     20 U35c6							; The memory manager is not interupted durring allocation
     21 U35c6							; or freeing of memory
     22 U35c6							;====================================================
     23 U35c6		       00 00	   MemFreeList ds	2	; list of free blocks of memory
     24 U35c8		       00 00	   MemR0      ds	2	; source for copy/move/Init
     25 U35ca		       00 00	   MemR1      ds	2	; Destination for copy/move
     26 U35cc							;=====================================================
     27  2326					      Seg	Code
     28  2326							;=====================================================
     29  2326				   MemInit
     30  2326		       a9 8d		      lda	#FreeMemStart&$FF
     31  2328		       8d 83 42 	      sta	ProgramStart
     32  232b		       8d 85 42 	      sta	ProgramEnd
     33  232e		       a9 42		      lda	#FreeMemStart>>8
     34  2330		       8d 84 42 	      sta	ProgramStart+1
     35  2333		       8d 86 42 	      sta	ProgramEnd+1
     36  2336
     37  2336		       20 40 23 	      jsr	GetSizes
     38  2339		       20 4b 23 	      jsr	MemFree
     39  233c		       20 63 23 	      jsr	MemUsed
     40  233f				   MemInitEnd
     41  233f		       60		      rts
     42  2340
     43  2340
     44  2340							;
     45  2340							;=====================================================
     46  2340							; This function might go away eventually, but was
     47  2340							; added to provide data for other pieces of code.
     48  2340							; It has some ties to the operating environment that
     49  2340							; will need to be customized for the target system.
     50  2340							;
     51  2340				   GetSizes
     52  2340							;
     53  2340							; Here is machine specific code to get the highest
     54  2340							; memory location that can be used by BASIC.
     55  2340							;
     56  2340				  -	      if	ProgramStart < $2000
     57  2340				  -	      lda	#$ff
     58  2340				  -	      sta	HighMem	;$13ff for KIM-1
     59  2340				  -	      sta	MemFreeList
     60  2340				  -	      lda	#$DE	;#$13
     61  2340				  -	      sta	HighMem+1
     62  2340				  -	      sta	MemFreeList+1
     63  2340					      else
     64  2340		       a9 ff		      lda	#$ff
     65  2342		       8d 87 42 	      sta	HighMem	;$CFFF otherwise
     66  2345		       a9 cf		      lda	#$cf
     67  2347		       8d 88 42 	      sta	HighMem+1
     68  234a					      endif
     69  234a		       60		      rts
     70  234b							;
     71  234b							; This computes the available memory remaining.
     72  234b							;
     73  234b				   MemFree
     74  234b		       38		      sec
     75  234c		       ad 87 42 	      lda	HighMem
     76  234f		       ed 85 42 	      sbc	ProgramEnd
     77  2352		       8d 8b 42 	      sta	FreeMem
     78  2355		       85 52		      sta	R0
     79  2357		       ad 88 42 	      lda	HighMem+1
     80  235a		       ed 86 42 	      sbc	ProgramEnd+1
     81  235d		       8d 8c 42 	      sta	FreeMem+1
     82  2360		       85 53		      sta	R0+1
     83  2362		       60		      rts
     84  2363							;
     85  2363							; This computes the size of the current user program.
     86  2363							;
     87  2363				   MemUsed
     88  2363		       38		      sec
     89  2364		       ad 85 42 	      lda	ProgramEnd
     90  2367		       ed 83 42 	      sbc	ProgramStart
     91  236a		       8d 89 42 	      sta	UsedMem
     92  236d		       85 52		      sta	R0
     93  236f		       ad 86 42 	      lda	ProgramEnd+1
     94  2372		       ed 84 42 	      sbc	ProgramStart+1
     95  2375		       8d 8a 42 	      sta	UsedMem+1
     96  2378		       85 53		      sta	R0+1
     97  237a							;
     98  237a		       60		      rts
     99  237b							;
    100  237b							;=====================================================
    101  237b							; Set a block of memory to a value
    102  237b		       8a	   iSetBlock  txa
    103  237c		       48		      pha
    104  237d		       98		      tya
    105  237e		       48		      pha
    106  237f		       20 3b 2c 	      jsr	popR0	; the address to write to
    107  2382		       a5 52		      lda	R0
    108  2384		       85 59		      sta	dpl
    109  2386		       a5 53		      lda	R0+1
    110  2388		       85 5a		      sta	dpl+1
    111  238a		       20 53 2c 	      jsr	popR1	; Number of bytes to write
    112  238d		       20 3b 2c 	      jsr	popR0	; Get the value to store into memory
    113  2390		       20 b0 29 	      jsr	getILByte
    114  2393		       85 58		      sta	R2	; store the data type into R2
    115  2395		       c9 a4		      cmp	#tInteger
    116  2397		       f0 08		      beq	memset	; skip this if we have an integer
    117  2399		       a5 52		      lda	R0	; Revers the order so they can be copied in correct order
    118  239b		       a6 53		      ldx	R0+1
    119  239d		       86 52		      stx	R0
    120  239f		       85 53		      sta	R0+1
    121  23a1
    122  23a1				   memset
    123  23a1		       a0 00		      ldy	#0	; Set for length of block to copy
    124  23a3		       a2 00		      ldx	#0	; set for number of block of 256 to copy
    125  23a5
    126  23a5		       a5 58	   iSetBlockLoop lda	R2	; Get Datatype
    127  23a7		       c9 a2		      cmp	#tByte
    128  23a9		       f0 09		      beq	iSetBlockB
    129  23ab
    130  23ab		       a5 52	   iSetBlockW lda	R0
    131  23ad		       91 59		      sta	(dpl),y
    132  23af		       20 c4 23 	      jsr	iSetBlockEnd
    133  23b2		       f0 09		      beq	iSetBlockComplete
    134  23b4
    135  23b4		       a5 53	   iSetBlockB lda	R0+1
    136  23b6		       91 59		      sta	(dpl),y
    137  23b8		       20 c4 23 	      jsr	iSetBlockEnd
    138  23bb		       d0 e8		      bne	iSetBlockLoop
    139  23bd
    140  23bd				   iSetBlockComplete
    141  23bd		       68		      pla
    142  23be		       a8		      tay
    143  23bf		       68		      pla
    144  23c0		       aa		      tax
    145  23c1		       4c b1 02 	      jmp	NextIL
    146  23c4							;
    147  23c4							; Check if we have reached the end of the initialization/Copy
    148  23c4							;
    149  23c4		       c8	   iSetBlockEnd iny
    150  23c5		       d0 03		      bne	iSetBlockEndChk
    151  23c7		       e8		      inx
    152  23c8		       e6 5a		      inc	dpl+1
    153  23ca				   iSetBlockEndChk
    154  23ca		       c4 54		      cpy	R1
    155  23cc		       d0 02		      bne	iSetBlockEndExit
    156  23ce		       e4 55		      cpx	R1+1
    157  23d0				   iSetBlockEndExit
    158  23d0		       60		      rts
    159  23d1							;
    160  23d1							;================================================================
    161  23d1							; Copy a block of memory from one location to another
    162  23d1							;
    163  23d1		       8a	   iCopyBlock txa
    164  23d2		       48		      pha
    165  23d3		       98		      tya
    166  23d4		       48		      pha
    167  23d5		       20 3b 2c 	      jsr	popR0	; get the source address
    168  23d8		       20 53 2c 	      jsr	popR1	; Destination address
    169  23db		       a5 54		      lda	R1
    170  23dd		       85 59		      sta	dpl
    171  23df		       a5 55		      lda	R1+1
    172  23e1		       85 5a		      sta	dpl+1
    173  23e3		       20 53 2c 	      jsr	popR1	; Number of bytes to copy
    174  23e6				   memcpy
    175  23e6		       a2 00		      ldx	#0
    176  23e8		       a0 00		      ldy	#0
    177  23ea				   iCopyBlockLoop
    178  23ea		       b1 52		      lda	(R0),y	;  Get the byte to copy
    179  23ec		       91 59		      sta	(dpl),y	;  Store the byte
    180  23ee		       c8		      iny
    181  23ef		       d0 05		      bne	iCopyChkEnd
    182  23f1		       e8		      inx
    183  23f2		       e6 53		      inc	R0+1
    184  23f4		       e6 5a		      inc	dpl+1
    185  23f6		       c4 54	   iCopyChkEnd cpy	R1
    186  23f8		       d0 f0		      bne	iCopyBlockLoop
    187  23fa		       e4 55		      cpx	R1+1
    188  23fc		       d0 ec		      bne	iCopyBlockLoop
    189  23fe				   iCopyBlockDone
    190  23fe		       68		      pla
    191  23ff		       a8		      tay
    192  2400		       68		      pla
    193  2401		       aa		      tax
    194  2402		       4c b1 02 	      jmp	NextIL
    195  2405							;
    196  2405							;=============================================================================
    197  2405							; Compare memory block location
    198  2405							; returns on the stack
    199  2405							; 0 - equals
    200  2405							; -1 - s1  <  s2
    201  2405							; 1   s1  >  s2
    202  2405		       8a	   iCmpBlock  txa
    203  2406		       48		      pha
    204  2407		       98		      tya
    205  2408		       48		      pha
    206  2409		       20 53 2c 	      jsr	popR1	; Get the Source 2 pointer
    207  240c		       a5 54		      lda	R1
    208  240e		       85 59		      sta	dpl	; store the secon source in dpl
    209  2410		       a5 55		      lda	R1+1
    210  2412		       85 5a		      sta	dpl+1
    211  2414		       20 3b 2c 	      jsr	popR0	; Get the Source 1 pointer
    212  2417		       20 53 2c 	      jsr	popR1	; Get the length of the compare to do
    213  241a		       a0 00		      ldy	#0
    214  241c		       a2 00		      ldx	#0
    215  241e		       4c 2b 24 	      jmp	iCmpCheckEnd
    216  2421
    217  2421		       b1 59	   iCmpLoop   lda	(dpl),y
    218  2423		       d1 52		      cmp	(R0),y
    219  2425		       d0 19		      bne	iCmpDone
    220  2427		       c8		      iny
    221  2428		       d0 01		      bne	iCmpCheckEnd
    222  242a		       e8		      inx
    223  242b				   iCmpCheckEnd
    224  242b		       c4 54		      cpy	R1
    225  242d		       d0 f2		      bne	iCmpLoop
    226  242f		       e4 55		      cpx	R1+1
    227  2431		       d0 ee		      bne	iCmpLoop
    228  2433		       a5 00		      lda	0
    229  2435		       85 53		      sta	R0+1
    230  2437		       85 52		      sta	R0
    231  2439				   iCmpReturn
    232  2439		       68		      pla
    233  243a		       a8		      tay
    234  243b		       68		      pla
    235  243c		       aa		      tax
    236  243d		       4c 16 07 	      jmp	pushR0nextIl
    237  2440
    238  2440				   iCmpDone
    239  2440		       90 0a		      bcc	iCmpGreater
    240  2442				   iCmpLess
    241  2442		       a9 00		      lda	#0
    242  2444		       85 53		      sta	R0+1
    243  2446		       a9 01		      lda	#1
    244  2448		       85 52		      sta	R0
    245  244a		       d0 ed		      bne	iCmpReturn
    246  244c				   iCmpGreater
    247  244c		       a9 ff		      lda	#-1
    248  244e		       85 52		      sta	R0
    249  2450		       85 53		      sta	R0+1
    250  2452		       d0 e5		      bne	iCmpReturn
    251  2454
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  2454					      include	"gosub.asm"
      1  2454					      seg	Code
      2  2454
      3  2454							; Gosub and return related functions
      4  2454							;==========================================================
      5  2454							; Push the current math stack frame onto the gosub stack
      6  2454				   iPushMathStack
      7  2454		       98		      tya
      8  2455		       48		      pha
      9  2456		       a4 4d		      ldy	GOSUBSTACKPTR
     10  2458		       a5 4a		      lda	MATHSTACKPTR
     11  245a		       91 4b		      sta	(GOSUBSTACK),y
     12  245c		       a9 00		      lda	#0
     13  245e		       c8		      iny
     14  245f		       91 4b		      sta	(GOSUBSTACK),y
     15  2461		       c8		      iny
     16  2462		       91 4b		      sta	(GOSUBSTACK),y
     17  2464		       c8		      iny
     18  2465		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  2467		       91 4b		      sta	(GOSUBSTACK),y
     20  2469		       c8		      iny
     21  246a		       84 4d		      sty	GOSUBSTACKPTR
     22  246c		       68		      pla
     23  246d		       a8		      tay
     24  246e		       4c b1 02 	      jmp	NextIL
     25  2471							;
     26  2471							;==========================================================
     27  2471							; Increment parameter count. Assume Stack frame is top of stack
     28  2471				   iIncParmCount
     29  2471		       98		      tya
     30  2472		       48		      pha
     31  2473
     32  2473		       a4 4d		      ldy	GOSUBSTACKPTR
     33  2475		       88		      dey
     34  2476		       88		      dey
     35  2477		       88		      dey
     36  2478		       b1 4b		      lda	(GOSUBSTACK),y
     37  247a		       18		      clc
     38  247b		       69 01		      adc	#1
     39  247d		       91 4b		      sta	(GOSUBSTACK),y
     40  247f
     41  247f		       68		      pla
     42  2480		       a8		      tay
     43  2481		       4c b1 02 	      jmp	NextIL
     44  2484							;
     45  2484							;==========================================================
     46  2484							;Restore the math stack frame
     47  2484		       20 8a 24    iPopMathStack jsr	PopMathStackNow
     48  2487		       4c b1 02 	      jmp	NextIL
     49  248a
     50  248a				   PopMathStackNow
     51  248a		       98		      tya
     52  248b		       48		      pha
     53  248c
     54  248c		       a4 4d		      ldy	GOSUBSTACKPTR
     55  248e		       88		      dey
     56  248f		       b1 4b		      lda	(GOSUBSTACK),y
     57  2491		       c9 05		      cmp	#GOSUB_STACK_FRAME
     58  2493		       d0 09		      bne	iPopMathStackNoFrame
     59  2495		       88		      dey
     60  2496		       88		      dey
     61  2497		       88		      dey
     62  2498		       b1 4b		      lda	(GOSUBSTACK),y
     63  249a		       85 4a		      sta	MATHSTACKPTR
     64  249c		       84 4d		      sty	GOSUBSTACKPTR
     65  249e
     66  249e				   iPopMathStackNoFrame
     67  249e
     68  249e		       68		      pla
     69  249f		       a8		      tay
     70  24a0		       60		      rts
     71  24a1
     72  24a1
     73  24a1							;==========================================================
     74  24a1							; Push the current math stack information onto the gosub stack
     75  24a1				   iSaveMathStack
     76  24a1		       98		      tya
     77  24a2		       48		      pha
     78  24a3
     79  24a3		       a4 4d		      ldy	GOSUBSTACKPTR
     80  24a5		       a5 4a		      lda	MATHSTACKPTR
     81  24a7		       91 4b		      sta	(GOSUBSTACK),y
     82  24a9		       a5 48		      lda	MATHSTACK
     83  24ab		       c8		      iny
     84  24ac
     85  24ac		       91 4b		      sta	(GOSUBSTACK),y
     86  24ae		       c8		      iny
     87  24af
     88  24af		       a5 49		      lda	MATHSTACK+1
     89  24b1		       91 4b		      sta	(GOSUBSTACK),y
     90  24b3		       c8		      iny
     91  24b4
     92  24b4		       a9 06		      lda	#GOSUB_STACK_SAVE
     93  24b6		       91 4b		      sta	(GOSUBSTACK),y
     94  24b8		       c8		      iny
     95  24b9
     96  24b9		       84 4d		      sty	GOSUBSTACKPTR
     97  24bb
     98  24bb		       68		      pla
     99  24bc		       a8		      tay
    100  24bd		       4c b1 02 	      jmp	NextIL
    101  24c0							;
    102  24c0							;==========================================================
    103  24c0							;Restore the math stack information from the gosub stack
    104  24c0				   iRestoreMathStack
    105  24c0		       98		      tya
    106  24c1		       48		      pha
    107  24c2
    108  24c2		       a5 4a		      lda	MATHSTACKPTR
    109  24c4		       85 58		      sta	R2	; save the current offset for whatever task to R2
    110  24c6
    111  24c6		       a4 4d		      ldy	GOSUBSTACKPTR
    112  24c8		       88		      dey
    113  24c9		       b1 4b		      lda	(GOSUBSTACK),y
    114  24cb		       c9 06		      cmp	#GOSUB_STACK_SAVE
    115  24cd		       d0 16		      bne	iPopMathStack_Err
    116  24cf		       88		      dey
    117  24d0		       b1 4b		      lda	(GOSUBSTACK),y
    118  24d2		       85 49		      sta	MATHSTACK+1
    119  24d4		       88		      dey
    120  24d5		       b1 4b		      lda	(GOSUBSTACK),y
    121  24d7		       85 48		      sta	MATHSTACK
    122  24d9		       88		      dey
    123  24da		       b1 4b		      lda	(GOSUBSTACK),y
    124  24dc		       85 4a		      sta	MATHSTACKPTR
    125  24de		       84 4d		      sty	GOSUBSTACKPTR
    126  24e0
    127  24e0		       68		      pla
    128  24e1		       a8		      tay
    129  24e2		       4c b1 02 	      jmp	NextIL
    130  24e5
    131  24e5				   iPopMathStack_Err
    132  24e5		       68		      pla
    133  24e6		       a8		      tay
    134  24e7		       a9 00		      lda	#0
    135  24e9		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    136  24eb		       4c 7d 06 	      jmp	iErr2
    137  24ee							;=========================================
    138  24ee							; For functions and tasks the variable address of # means
    139  24ee							; a passed parameter so #[0] is the first parameter etc
    140  24ee							; will try for a better way later
    141  24ee							;=====================================================
    142  24ee							; On entry il, branch to if function
    143  24ee							;	    il+1, value to be returned or not true or false
    144  24ee							;
    145  24ee							; Return from GOSUB  or function function
    146  24ee							; format   RSTR 0   --- return form gosub
    147  24ee							;	    RSTR 1   --- return from Function
    148  24ee							;
    149  24ee		       20 b0 29    iRSTR      jsr	getILByte	; get where to go if 0 = gosub/1=function call
    150  24f1		       8d 7f 42 	      sta	offset
    151  24f4		       20 93 2b 	      jsr	saveIL	; for later jump if needed add extra entry to	the return stack
    152  24f7
    153  24f7		       20 ec 2b 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    154  24fa		       85 54		      sta	R1	; keep the type of call returning from
    155  24fc		       b0 2b		      bcs	iRSTRErr	; stack underflow error possible
    156  24fe
    157  24fe		       20 b0 29 	      jsr	getILByte	; get if a value is being returned
    158  2501
    159  2501		       48		      pha		; save if a value was passed to be returned
    160  2502
    161  2502		       c9 00		      cmp	#0	; yes attemping to return a value
    162  2504		       f0 03		      beq	iRSTRPOP	; no value to return
    163  2506		       20 3b 2c 	      jsr	popR0	; Get the value from the stack save if needed
    164  2509
    165  2509				   iRSTRPOP
    166  2509		       20 8a 24 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    167  250c		       a5 54		      lda	R1	; called as a statement ?
    168  250e		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    169  2510		       f0 13		      beq	iRSTRExit
    170  2512
    171  2512		       68		      pla		; get back if value returned or not
    172  2513		       c9 01		      cmp	#1	; we have a value to return
    173  2515		       f0 05		      beq	iRSTRVALUE
    174  2517
    175  2517		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    176  2519		       4c 12 05 	      jmp	iSAVErr2	; jump to general error reporting function
    177  251c
    178  251c				   iRSTRVALUE
    179  251c		       20 a9 2b 	      jsr	pushR0	; return value back to top of stack
    180  251f		       20 9e 2b 	      jsr	restoreIL	; get the correct il
    181  2522		       4c d7 0b 	      jmp	tstBranch	; And called as a function
    182  2525
    183  2525				   iRSTRExit
    184  2525		       68		      pla		; throw away gosub/func flag
    185  2526		       4c b1 02 	      jmp	NextIL
    186  2529
    187  2529				   iRSTRNORETURNVALUE
    188  2529
    189  2529
    190  2529		       ad 0e 36    iRSTRErr   lda	taskPtr	; Check if this is task zero
    191  252c		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    192  252e		       a5 56		      lda	MQ
    193  2530		       d0 03		      bne	taskRet
    194  2532		       20 70 2e 	      jsr	pushFalse	; the result code by default is 0
    195  2535				   taskRet
    196  2535		       4c a9 27 	      jmp	iETask	; not task zero then do a task end instead
    197  2538				   taskZeroEnd
    198  2538		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    199  253a		       4c 12 05 	      jmp	iSAVErr2
    200  253d							;
    201  253d							;==========================================================================================
    202  253d							; Find the next gosub function parameter info	position on the stack
    203  253d							; Returns y = index and c set if found clear c otherwise
    204  253d		       a4 4d	   GosubFindParms ldy	GOSUBSTACKPTR	;Get the Pointer to the top of stack
    205  253f		       88		      dey		;Point to stack entry type
    206  2540
    207  2540							;Veryify the stack size and position for the call
    208  2540							;Loops here until it finds a GOSUB with value entry or gosub-rtn entry
    209  2540
    210  2540		       c0 00	   GosubFindLoop cpy	#0	;If we reach the top of the stack then no parametrs
    211  2542		       f0 2d		      beq	GosubNotFunc
    212  2544		       c0 10		      cpy	#GOSUBSTACKSIZE	;Tst if we are outside the stack size
    213  2546		       b0 29		      bcs	GosubNotFunc	;Not valid
    214  2548
    215  2548							;Look for the	 GOSUB_RTN_VALUE stack position
    216  2548		       b1 4b		      lda	(GOSUBSTACK),y	;Get the type of call - if it is not a fn call error
    217  254a		       c9 01		      cmp	#GOSUB_RTN	;if we find this then this function had no parameters
    218  254c		       f0 0f		      beq	GosubParmFnd	;We can pass parameters to a function that returns nothing
    219  254e
    220  254e		       c9 81		      cmp	#GOSUB_RTN_VALUE	;Parameters with the gosub call
    221  2550		       f0 0b		      beq	GosubParmFnd	;Skip any non Gosub related entries
    222  2552
    223  2552		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    224  2554		       f0 13		      beq	GosubParmSkip	;We have a stackframe good
    225  2556
    226  2556		       88		      dey
    227  2557		       88		      dey
    228  2558		       88		      dey
    229  2559		       88		      dey
    230  255a		       4c 40 25 	      jmp	GosubFindLoop
    231  255d
    232  255d		       c0 03	   GosubParmFnd cpy	#3	; Check if we are outside the stack
    233  255f		       90 10		      bcc	GosubNotFunc	; if y < 3 then error not found
    234  2561		       c0 10		      cpy	#GOSUBSTACKSIZE	; Largest value
    235  2563		       b0 0c		      bcs	GosubNotFunc	; no parameters passed
    236  2565
    237  2565		       88		      dey		; Point to hopefully Math Stack frame information
    238  2566		       88		      dey
    239  2567		       88		      dey
    240  2568		       88		      dey
    241  2569				   GosubParmSkip
    242  2569		       b1 4b		      lda	(GOSUBSTACK),y	;This should be a stack frame pointer
    243  256b		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    244  256d		       d0 02		      bne	GosubNotFunc	;No parameters passed but expected
    245  256f		       38		      sec
    246  2570		       60		      rts
    247  2571
    248  2571		       18	   GosubNotFunc clc
    249  2572		       60		      rts
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  2573					      include	"tasks.asm"
      1  2573							;=====================================================
      2  2573							; Tiny Basic IL task management
      3  2573							; Data required by task management
      4  2573							; currently each context is about 30 bytes and is swapped
      5  2573							; into and out of page zero on each task switch....
      6  2573							; LOL yes it is slow, but works for this iteration.
      7  2573							;
      8  2573
      9  2573					      Seg	Code
     10  2573							;=====================================================
     11  2573							; Sets the pointers to the math,IL and gosub stacks
     12  2573							; Creates the initial Context for each task slot
     13  2573				   taskSetStacks
     14  2573		       a9 0e		      lda	#mathStack&$FF
     15  2575		       85 48		      sta	MATHSTACK
     16  2577		       a9 37		      lda	#mathStack>>8
     17  2579		       85 49		      sta	MATHSTACK+1
     18  257b
     19  257b		       a9 9e		      lda	#ilStack&$ff
     20  257d		       85 45		      sta	ILSTACK
     21  257f		       a9 38		      lda	#ilStack>>8
     22  2581		       85 46		      sta	ILSTACK+1
     23  2583
     24  2583		       a9 86		      lda	#gosubStack&$FF
     25  2585		       85 4b		      sta	GOSUBSTACK
     26  2587		       a9 3c		      lda	#gosubStack>>8
     27  2589		       85 4c		      sta	GOSUBSTACK+1
     28  258b
     29  258b		       a9 06		      lda	#variableStack&$FF
     30  258d		       85 41		      sta	VARIABLES
     31  258f		       a9 3f		      lda	#variableStack>>8
     32  2591		       85 42		      sta	VARIABLES+1
     33  2593		       a2 0a		      ldx	#TASKCOUNT
     34  2595		       a0 00		      ldy	#0
     35  2597		       20 67 28 	      jsr	ContextSave	; Save the Task 0 context
     36  259a
     37  259a		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  259c		       b0 3a		      bcs	taskSetDone
     39  259e
     40  259e		       a5 4b		      lda	GOSUBSTACK
     41  25a0		       18		      clc
     42  25a1		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  25a3		       85 4b		      sta	GOSUBSTACK
     44  25a5		       a5 4c		      lda	GOSUBSTACK+1
     45  25a7		       69 00		      adc	#0
     46  25a9		       85 4c		      sta	GOSUBSTACK+1
     47  25ab
     48  25ab		       a5 45		      lda	ILSTACK	; must be less than 256
     49  25ad		       18		      clc
     50  25ae		       69 64		      adc	#ILSTACKSIZE*2
     51  25b0		       85 45		      sta	ILSTACK
     52  25b2		       a5 46		      lda	ILSTACK+1
     53  25b4		       69 00		      adc	#0
     54  25b6		       85 46		      sta	ILSTACK+1
     55  25b8
     56  25b8		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  25ba		       18		      clc
     58  25bb		       69 28		      adc	#MATHSTACKSIZE*2
     59  25bd		       85 48		      sta	MATHSTACK
     60  25bf		       a5 49		      lda	MATHSTACK+1
     61  25c1		       69 00		      adc	#0
     62  25c3		       85 49		      sta	MATHSTACK+1
     63  25c5
     64  25c5		       a5 41		      lda	VARIABLES	; must be less than 256
     65  25c7		       18		      clc
     66  25c8		       69 4a		      adc	#VARIABLESSIZE*2
     67  25ca		       85 41		      sta	VARIABLES
     68  25cc		       a5 42		      lda	VARIABLES+1
     69  25ce		       69 00		      adc	#0
     70  25d0		       85 42		      sta	VARIABLES+1
     71  25d2		       20 67 28 	      jsr	ContextSave
     72  25d5		       4c 9a 25 	      jmp	taskSetLoop
     73  25d8
     74  25d8				   taskSetDone
     75  25d8		       a0 00		      ldy	#0	; reload the main loop context
     76  25da		       20 76 28 	      jsr	ContextLoad
     77  25dd		       60		      rts
     78  25de							;
     79  25de							;============================================================
     80  25de							; Saves the io block to the context
     81  25de
     82  25de
     83  25de		       98	   SaveIOblock tya
     84  25df		       48		      pha
     85  25e0		       8a		      txa
     86  25e1		       48		      pha
     87  25e2
     88  25e2
     89  25e2
     90  25e2		       68		      pla
     91  25e3		       aa		      tax
     92  25e4		       68		      pla
     93  25e5		       a8		      tay
     94  25e6		       60		      rts
     95  25e7
     96  25e7							;
     97  25e7							;=====================================================
     98  25e7							; In some error cases the math stacks may be left pointing to the wrong stack
     99  25e7							; This function will reset those stack addresses but not the actual pointer
    100  25e7				   taskResetStacks
    101  25e7		       a0 00		      ldy	#0
    102  25e9		       20 76 28 	      jsr	ContextLoad
    103  25ec		       4c 73 25 	      jmp	taskSetStacks
    104  25ef							;
    105  25ef							;=====================================================
    106  25ef							; Clear all task entries and task stacks
    107  25ef		       98	   taskReset  tya		; Save Y
    108  25f0		       48		      pha
    109  25f1		       a9 01		      lda	#1
    110  25f3		       8d 0d 37 	      sta	taskCounter	; Set number of active tasks to 1
    111  25f6		       ac 0e 36 	      ldy	taskPtr	; Set the active task to 0 MAIN
    112  25f9		       c0 00		      cpy	#0	; check if we are the main context
    113  25fb		       f0 08		      beq	taskResetCont	; if we are just continue
    114  25fd
    115  25fd		       a0 00		      ldy	#0	; else we need to switch to the main context
    116  25ff		       8c 0e 36 	      sty	taskPtr
    117  2602		       20 76 28 	      jsr	ContextLoad	; load the System Task context
    118  2605				   taskResetCont
    119  2605		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    120  2607
    121  2607				   taskResetLoop
    122  2607		       a9 00		      lda	#TASKINACTIVE
    123  2609		       99 0f 36 	      sta	taskTable,y	; Ensure that the task is made inactive
    124  260c		       18		      clc
    125  260d		       98		      tya
    126  260e		       69 19		      adc	#CONTEXTLEN
    127  2610		       a8		      tay
    128  2611		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    129  2613		       90 f2		      bcc	taskResetLoop	; Go for more
    130  2615
    131  2615				   taskResetComplete
    132  2615
    133  2615		       68		      pla		; Restore y
    134  2616		       a8		      tay
    135  2617		       60		      rts
    136  2618
    137  2618							;
    138  2618							;======================================================
    139  2618							; iTaskSwitch	 switch to new task if not interrupt and
    140  2618							;		 count is exceded for task time slice gets here
    141  2618							;		 when time slice has reached zero
    142  2618							;
    143  2618		       98	   iTaskSwitch tya
    144  2619		       48		      pha
    145  261a
    146  261a		       ad 0b 37 	      lda	taskResetValue	; Always reset the counter value
    147  261d		       8d 09 37 	      sta	taskCurrentCycles	; Update the counter with the new value
    148  2620		       ce 0a 37 	      dec	taskCurrentCycles+1	; dec high order byte
    149  2623		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    150  2625
    151  2625		       ad 0c 37 	      lda	taskResetValue+1
    152  2628		       8d 0a 37 	      sta	taskCurrentCycles+1
    153  262b
    154  262b		       ad 56 19 	      lda	IRQPending	; Skip this if we are processing an irq
    155  262e		       0d 81 42 	      ora	taskIOPending	; If set then don't switch
    156  2631		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    157  2633
    158  2633		       ad 0d 37    iTaskMain  lda	taskCounter	; Number of tasks
    159  2636		       c9 01		      cmp	#1	; if there is only one task must be main
    160  2638		       d0 07		      bne	itasknext	; if it some other number continue to next
    161  263a
    162  263a		       ac 0e 36 	      ldy	taskPtr	; check if we have not just ended some other task
    163  263d		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    164  263f		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    165  2641							;
    166  2641							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    167  2641							;
    168  2641				   itasknext
    169  2641		       ac 0e 36 	      ldy	taskPtr
    170  2644		       20 67 28 	      jsr	ContextSave	; Save the current context, y points to next context
    171  2647				   itaskLoop
    172  2647		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    173  2649		       90 04		      bcc	iTaskNextChk
    174  264b
    175  264b		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    176  264d		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    177  264f
    178  264f				   iTaskNextChk
    179  264f		       b9 0f 36 	      lda	taskTable,y	; there is always at least one entry in table
    180  2652		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    181  2654		       18	   iTaskNext  clc
    182  2655		       98		      tya
    183  2656		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    184  2658		       a8		      tay
    185  2659		       4c 47 26 	      jmp	itaskLoop	; Check for busy entry
    186  265c
    187  265c		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    188  265e		       59 0f 36 	      eor	taskTable,y	; Check for anything waiting io
    189  2661		       d0 f1		      bne	iTaskNext
    190  2663		       20 76 28 	      jsr	ContextLoad	; load the next context
    191  2666		       8c 0e 36 	      sty	taskPtr	; update the task pointer
    192  2669
    193  2669				   iTaskSwitchDone
    194  2669		       68		      pla
    195  266a		       a8		      tay
    196  266b		       60		      rts
    197  266c							;
    198  266c							;================================================================
    199  266c							; Task Set task number to line number to start
    200  266c							; on entry stack contains, type of line description and  memvector or linenumber
    201  266c							; Task Table structure:
    202  266c							;    byte 0	-   Active inactive
    203  266c							;    byte 1-2	-   Basic code line pointer
    204  266c							;    byte 3	-   Offset on current line
    205  266c		       98	   iTaskSet   tya		;preserve Y
    206  266d		       48		      pha		; push a
    207  266e		       20 53 2c 	      jsr	popR1	; Get if compiled or line number expression
    208  2671		       20 3b 2c 	      jsr	popR0	; Get the line number to be saved
    209  2674
    210  2674
    211  2674
    212  2674		       ac 0e 36 	      ldy	taskPtr	; find out where we are
    213  2677		       20 67 28 	      jsr	ContextSave	; Save the current context
    214  267a
    215  267a							;Find the pointer to the line we need to start at
    216  267a		       a5 54		      lda	R1
    217  267c		       f0 0b		      beq	iTaskLineNum
    218  267e		       a5 52		      lda	R0
    219  2680		       85 4f		      sta	CURPTR
    220  2682		       a5 53		      lda	R0+1
    221  2684		       85 50		      sta	CURPTR+1
    222  2686		       4c 99 26 	      jmp	iTaskCont
    223  2689
    224  2689				   iTaskLineNum
    225  2689		       20 f5 29 	      jsr	findLine	; Get the offset of the line to start task at
    226  268c		       f0 0b		      beq	iTaskCont
    227  268e
    228  268e		       ac 0e 36 	      ldy	taskPtr	; Restore the original Context Error Exit
    229  2691		       20 76 28 	      jsr	ContextLoad
    230  2694
    231  2694		       68		      pla		; pop a - exit
    232  2695		       a8		      tay
    233  2696		       4c ea 0d 	      jmp	iSetIrqErr	; Bad line number provided
    234  2699
    235  2699				   iTaskCont
    236  2699		       20 39 28 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    237  269c		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    238  269e
    239  269e		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    240  26a0		       99 0f 36 	      sta	taskTable,y	; new task as active
    241  26a3
    242  26a3		       a5 4f		      lda	CURPTR
    243  26a5		       48		      pha		; push a
    244  26a6		       a5 50		      lda	CURPTR+1
    245  26a8		       48		      pha		; push a
    246  26a9
    247  26a9		       20 76 28 	      jsr	ContextLoad	; load the context of the new task
    248  26ac
    249  26ac		       68		      pla		; pop a
    250  26ad		       85 50		      sta	CURPTR+1
    251  26af		       68		      pla		; pop a
    252  26b0		       85 4f		      sta	CURPTR
    253  26b2		       a9 03		      lda	#3	; Offset to first instruction
    254  26b4		       85 51		      sta	CUROFF
    255  26b6
    256  26b6		       a9 00		      lda	#0
    257  26b8		       85 47		      sta	ILSTACKPTR
    258  26ba		       85 4a		      sta	MATHSTACKPTR
    259  26bc		       85 4d		      sta	GOSUBSTACKPTR
    260  26be		       a9 40		      lda	#GOSUBSTACKSIZE*4
    261  26c0		       85 4e		      sta	MESSAGEPTR
    262  26c2
    263  26c2		       20 6c 09 	      jsr	subVINIT	; Clear the variables
    264  26c5
    265  26c5		       a9 7e		      lda	#STMT&$FF
    266  26c7		       85 43		      sta	ILPC
    267  26c9		       a9 31		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    268  26cb		       85 44		      sta	ILPC+1
    269  26cd
    270  26cd		       98		      tya		; Save the new context offset to return to user
    271  26ce		       48		      pha		; push a
    272  26cf
    273  26cf		       20 67 28    itaskSetSave jsr	ContextSave	; save the updated context
    274  26d2		       ee 0d 37 	      inc	taskCounter	; Update the number of Tasks running
    275  26d5
    276  26d5		       ac 0e 36 	      ldy	taskPtr
    277  26d8		       20 76 28 	      jsr	ContextLoad	; restore the original context
    278  26db
    279  26db		       a9 00		      lda	#0	; Set the R0 upper to zero
    280  26dd		       85 53		      sta	R0+1
    281  26df		       68		      pla		; Get the task pid we stored				 ; pop a
    282  26e0		       85 52		      sta	R0	; Get the table entry value
    283  26e2
    284  26e2		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    285  26e3		       a8		      tay
    286  26e4
    287  26e4		       4c 16 07 	      jmp	pushR0nextIl	; Push R0 and continue
    288  26e7				   iTaskNoEmpty
    289  26e7		       ac 0e 36 	      ldy	taskPtr
    290  26ea		       20 76 28 	      jsr	ContextLoad
    291  26ed
    292  26ed		       68		      pla		; pop a    -- exit
    293  26ee		       a8		      tay
    294  26ef
    295  26ef		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    296  26f1		       a9 00		      lda	#0
    297  26f3		       4c 7d 06 	      jmp	iErr2
    298  26f6							;
    299  26f6							;===============================================================
    300  26f6							; Run the task whos PID is on the stack, preserve the stack
    301  26f6							;
    302  26f6				   iTaskEnable
    303  26f6		       98		      tya
    304  26f7		       48		      pha
    305  26f8		       20 53 2c 	      jsr	popR1
    306  26fb		       20 21 2c 	      jsr	pushR1
    307  26fe		       20 6d 29 	      jsr	ipc_getcontext	; get context pointer into mq
    308  2701		       a0 00		      ldy	#0
    309  2703		       b1 56		      lda	(MQ),y
    310  2705		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    311  2707		       09 80		      ora	#TASKACTIVE
    312  2709		       91 56		      sta	(MQ),y
    313  270b		       68		      pla
    314  270c		       a8		      tay
    315  270d		       4c b1 02 	      jmp	NextIL
    316  2710
    317  2710							;
    318  2710							;===============================================================
    319  2710							; Suspend the task whos PID  is on the stack, preserve the stack
    320  2710							;
    321  2710				   iTaskSuspend
    322  2710		       98		      tya
    323  2711		       48		      pha
    324  2712		       20 53 2c 	      jsr	popR1
    325  2715		       20 21 2c 	      jsr	pushR1
    326  2718		       20 6d 29 	      jsr	ipc_getcontext	; get context pointer into mq
    327  271b		       a0 00		      ldy	#0
    328  271d		       b1 56		      lda	(MQ),y
    329  271f		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    330  2721		       09 80		      ora	#TASKACTIVE
    331  2723		       68		      pla
    332  2724		       a8		      tay
    333  2725		       4c b1 02 	      jmp	NextIL
    334  2728
    335  2728							;================================================================
    336  2728							; Returns task Status
    337  2728				   iTaskStat
    338  2728		       98		      tya
    339  2729		       48		      pha
    340  272a		       20 3c 27 	      jsr	iTaskValid	; returns pointer to task entry
    341  272d		       b9 0f 36 	      lda	taskTable,y
    342  2730		       f0 05		      beq	iTaskStatExit
    343  2732		       68		      pla
    344  2733		       a8		      tay
    345  2734		       4c 7a 0d 	      jmp	iTruth
    346  2737				   iTaskStatExit
    347  2737		       68		      pla
    348  2738		       a8		      tay
    349  2739		       4c 83 0d 	      jmp	iFalse
    350  273c
    351  273c							;
    352  273c							;================================================================
    353  273c							; Validate the task number on top of the stack
    354  273c							; on exit y points to the requested task entry
    355  273c							;
    356  273c		       20 3b 2c    iTaskValid jsr	popR0	; get result of the multiply
    357  273f		       a5 53		      lda	R0+1
    358  2741		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    359  2743		       a5 52		      lda	R0
    360  2745		       c9 fa		      cmp	#TASKTABLELEN
    361  2747		       90 09		      bcc	iTaskIsValid
    362  2749
    363  2749		       68	   iTaskValidErr pla		;remove return address
    364  274a		       68		      pla
    365  274b		       a2 10		      ldx	#ERR_INVALID_PID
    366  274d		       a9 00		      lda	#0
    367  274f		       4c 7d 06 	      jmp	iErr2
    368  2752
    369  2752		       a8	   iTaskIsValid tay
    370  2753		       60		      rts
    371  2754							;
    372  2754							;================================================================
    373  2754							; Kill a running task, do nothing if already stopped
    374  2754		       20 3c 27    iTaskKill  jsr	iTaskValid
    375  2757		       a9 00		      lda	#0
    376  2759		       99 0f 36 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    377  275c							;
    378  275c							;================================================================
    379  275c							;Skip to next task
    380  275c				   iNTask
    381  275c		       a9 01		      lda	#1
    382  275e		       8d 09 37 	      sta	taskCurrentCycles
    383  2761		       8d 0a 37 	      sta	taskCurrentCycles+1
    384  2764		       4c b1 02 	      jmp	NextIL
    385  2767							;
    386  2767							;=======================================================
    387  2767							; Wait for a task to complete
    388  2767				   iWTASK
    389  2767		       20 b0 29 	      jsr	getILByte
    390  276a		       8d 7f 42 	      sta	offset
    391  276d							;
    392  276d		       20 93 2b 	      jsr	saveIL	;in case of failure
    393  2770
    394  2770		       20 3c 27 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    395  2773		       b9 0f 36 	      lda	taskTable,y
    396  2776		       d0 03		      bne	iWTASKWAIT
    397  2778				   iWTASKEXITED
    398  2778		       4c b1 02 	      jmp	NextIL
    399  277b				   iWTASKWAIT
    400  277b		       20 a9 2b 	      jsr	pushR0	; Push R0 back onto the stack
    401  277e		       a9 01		      lda	#1
    402  2780		       8d 09 37 	      sta	taskCurrentCycles	; Give up the cycles
    403  2783		       8d 0a 37 	      sta	taskCurrentCycles+1
    404  2786		       20 9e 2b 	      jsr	restoreIL
    405  2789		       4c d7 0b 	      jmp	tstBranch
    406  278c							;
    407  278c							;=======================================================
    408  278c							; Set task io lock
    409  278c		       ee 81 42    iStartIO   inc	taskIOPending
    410  278f		       4c b1 02 	      jmp	NextIL
    411  2792							;
    412  2792							;=======================================================
    413  2792							; Release the io lock
    414  2792		       ad 81 42    iEndIO     lda	taskIOPending
    415  2795		       f0 03		      beq	iEndIOExit
    416  2797		       ce 81 42 	      dec	taskIOPending
    417  279a		       4c b1 02    iEndIOExit jmp	NextIL
    418  279d							;
    419  279d							;===============================================================
    420  279d							; Return the task PID
    421  279d				   iTASKPID
    422  279d		       a9 00		      lda	#0
    423  279f		       85 53		      sta	R0+1
    424  27a1		       ad 0e 36 	      lda	taskPtr
    425  27a4		       85 52		      sta	R0
    426  27a6		       4c 16 07 	      jmp	pushR0nextIl
    427  27a9							;
    428  27a9							;================================================================
    429  27a9							; Terminate a task
    430  27a9		       ac 0e 36    iETask     ldy	taskPtr
    431  27ac		       c0 00		      cpy	#0
    432  27ae		       d0 03		      bne	iETaskCont
    433  27b0		       4c 02 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    434  27b3				   iETaskCont
    435  27b3		       a9 00		      lda	#TASKINACTIVE
    436  27b5		       99 0f 36 	      sta	taskTable,y	; mark entry as free
    437  27b8		       ce 0d 37 	      dec	taskCounter	; reduce the number of active tasks
    438  27bb		       a9 01		      lda	#1
    439  27bd		       8d 09 37 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    440  27c0		       8d 0a 37 	      sta	taskCurrentCycles+1
    441  27c3		       20 54 28 	      jsr	TaskSetExitCode
    442  27c6				   iETaskExit
    443  27c6		       4c b1 02 	      jmp	NextIL
    444  27c9							;================================================================
    445  27c9							; make the current tasks math stack equal another tasks stack
    446  27c9							; The task to get is stored on the math stack
    447  27c9
    448  27c9				   iTaskGetMathStack
    449  27c9		       20 74 2e 	      jsr	CopyStackR1	; Get the top of stack to R1
    450  27cc		       20 6d 29 	      jsr	ipc_getcontext	; MQ now has the context address
    451  27cf		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  27d1		       b1 56		      lda	(MQ),y
    453  27d3		       85 4a		      sta	MATHSTACKPTR
    454  27d5		       a0 08		      ldy	#MATHSTACKPOS
    455  27d7		       b1 56		      lda	(MQ),y
    456  27d9		       85 48		      sta	MATHSTACK
    457  27db		       c8		      iny
    458  27dc		       b1 56		      lda	(MQ),y
    459  27de		       85 49		      sta	MATHSTACK+1
    460  27e0		       4c b1 02 	      jmp	NextIL
    461  27e3							;==================================================================
    462  27e3							; Updates the tasks math stack pointer with contents of R2
    463  27e3							; PID is on top of the stack
    464  27e3				   iTaskPutMathPtr
    465  27e3		       20 74 2e 	      jsr	CopyStackR1	; Get the top of stack to R1
    466  27e6		       20 6d 29 	      jsr	ipc_getcontext	; MQ now has the context address
    467  27e9		       a5 58		      lda	R2	; R2 contains the number of parameters/offset
    468  27eb		       a0 0a		      ldy	#MATHSTACKPTRPOS	; Pointer to new tasks stack pointer
    469  27ed		       91 56		      sta	(MQ),y	; update it to point to the free space on stack
    470  27ef							;if parm count > 0 then we need to create a parameter block on the tasks gosubStack
    471  27ef		       c9 00		      cmp	#0	; if no parameters then
    472  27f1		       f0 26		      beq	iTaskPutMathPtrExit	; just get out of here
    473  27f3
    474  27f3		       a0 0b		      ldy	#GOSUBSTKPOS
    475  27f5		       b1 56		      lda	(MQ),y	; get the address of the new tasks gosub stack into R1
    476  27f7		       85 54		      sta	R1
    477  27f9		       c8		      iny
    478  27fa		       b1 56		      lda	(MQ),y
    479  27fc		       85 55		      sta	R1+1
    480  27fe
    481  27fe		       a9 00		      lda	#0	; Store the math stack offset into new gosub stack, always 0
    482  2800		       91 54		      sta	(R1),y
    483  2802
    484  2802		       c8		      iny
    485  2803		       18		      clc		; We need to turn stack ptr to actual parm count
    486  2804		       e9 01		      sbc	#1	; Stack pointer always point to next free byte
    487  2806		       0a		      asl
    488  2807		       91 54		      sta	(R1),y
    489  2809
    490  2809		       c8		      iny
    491  280a		       a9 ff		      lda	#$FF	; Dummy field, not used
    492  280c		       91 54		      sta	(R1),y
    493  280e		       c8		      iny
    494  280f		       a9 05		      lda	#GOSUB_STACK_FRAME	; Tell its a stck frame, ie identify param cnt etc
    495  2811		       91 54		      sta	(R1),y
    496  2813		       c8		      iny
    497  2814		       98		      tya
    498  2815		       a0 0d		      ldy	#GOSUBPTRPOS
    499  2817		       91 56		      sta	(MQ),y	; update the new tasks gosub stk pointer
    500  2819
    501  2819				   iTaskPutMathPtrExit
    502  2819		       4c b1 02 	      jmp	NextIL
    503  281c							;
    504  281c							;================================================================
    505  281c							; Set the time slice for each task
    506  281c				   iSLICE
    507  281c		       20 3b 2c 	      jsr	popR0
    508  281f		       a5 52		      lda	R0
    509  2821		       8d 0b 37 	      sta	taskResetValue
    510  2824		       a5 53		      lda	R0+1
    511  2826		       8d 0c 37 	      sta	taskResetValue+1
    512  2829		       d0 0b		      bne	iSliceSet
    513  282b		       ee 0c 37 	      inc	taskResetValue+1	; must be at least 1 high counter
    514  282e		       a9 01		      lda	#1
    515  2830		       8d 09 37 	      sta	taskCurrentCycles
    516  2833		       8d 0a 37 	      sta	taskCurrentCycles+1
    517  2836				   iSliceSet
    518  2836		       4c b1 02 	      jmp	NextIL
    519  2839							;================================================================
    520  2839							; Find an empty slot in the taskTable
    521  2839							; Return the index in y
    522  2839							; on exit   c set if an empty slot is found
    523  2839							;	     c clear if not found
    524  2839							;================================================================
    525  2839							;
    526  2839		       ad 0d 37    TaskEmpty  lda	taskCounter
    527  283c		       c9 0a		      cmp	#TASKCOUNT
    528  283e		       b0 10		      bcs	TaskNoSlot
    529  2840		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    530  2842				   TaskLoop
    531  2842		       b9 0f 36 	      lda	taskTable,y
    532  2845		       f0 0b		      beq	TaskEmptyFnd
    533  2847		       98		      tya
    534  2848		       18		      clc
    535  2849		       69 19		      adc	#CONTEXTLEN
    536  284b		       a8		      tay
    537  284c		       c0 fa		      cpy	#TASKTABLELEN
    538  284e		       90 f2		      bcc	TaskLoop	; Y is never zero
    539  2850				   TaskNoSlot
    540  2850		       18		      clc
    541  2851		       60		      rts
    542  2852				   TaskEmptyFnd
    543  2852		       38		      sec
    544  2853		       60		      rts
    545  2854							;====================================================
    546  2854							; Set the task exit code called from the return command
    547  2854							; on entry stack top hold exit value
    548  2854				   TaskSetExitCode
    549  2854		       98		      tya
    550  2855		       48		      pha
    551  2856		       20 3b 2c 	      jsr	popR0
    552  2859		       a0 48		      ldy	#TASKEXITCODE
    553  285b		       a5 52		      lda	R0
    554  285d		       91 41		      sta	(VARIABLES),y
    555  285f		       c8		      iny
    556  2860		       a5 53		      lda	R0+1
    557  2862		       91 41		      sta	(VARIABLES),y
    558  2864		       68		      pla
    559  2865		       98		      tya
    560  2866		       60		      rts
    561  2867
    562  2867							;
    563  2867							;=====================================================
    564  2867							; Save Context Store the context to the TASK Table
    565  2867							; on entry y contains the task table entry to save to
    566  2867							; on exit y points to next task table entry
    567  2867							;	   x contains the number of bytes copied
    568  2867		       a2 00	   ContextSave ldx	#0
    569  2869		       c8		      iny		;inc past the task flags
    570  286a		       b5 41	   ContextSvLoop lda	CONTEXT,x
    571  286c		       99 0f 36 	      sta	taskTable,y
    572  286f		       c8		      iny
    573  2870		       e8		      inx
    574  2871		       e0 18		      cpx	#[CONTEXTLEN-1]
    575  2873		       90 f5		      bcc	ContextSvLoop
    576  2875		       60		      rts
    577  2876							;
    578  2876							; Load Context transfer context from task table to the Current Context
    579  2876							; on entry y contains the task table entry to transfer
    580  2876							; on exit y points to the original task table entry
    581  2876							;	   x contains the number of bytes copied
    582  2876		       98	   ContextLoad tya
    583  2877		       48		      pha
    584  2878		       a2 00		      ldx	#0
    585  287a		       c8		      iny		;inc past the task flags
    586  287b		       b9 0f 36    ContextLDLoop lda	taskTable,y
    587  287e		       95 41		      sta	CONTEXT,x
    588  2880		       c8		      iny
    589  2881		       e8		      inx
    590  2882		       e0 18		      cpx	#[CONTEXTLEN-1]
    591  2884		       90 f5		      bcc	ContextLDLoop
    592  2886		       68		      pla
    593  2887		       a8		      tay
    594  2888		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  2889					      include	"ipc.asm"
      1  2889							;======================================================
      2  2889							; Inter process communications.
      3  2889							; Tasks may write/read integer messages among
      4  2889							; them selves.
      5  2889							; This uses each tasks gosub stack as a message queue
      6  2889							; Gosub calls start at the highest address and the
      7  2889							; msg queue starts at the highest address.
      8  2889							;
      9  2889							;======================================================
     10  2889							; ipcs   - Send msg to another task or many tasks
     11  2889							; on entry  math stack contains the  top PID
     12  2889							;				      2ND Message value
     13  2889							; on exit   math stack contain top True-good or False-failed
     14  2889							;
     15  2889							; it may not be sent if queue is full
     16  2889							;
     17  2889							; a = ipcs(<message-expression>,<task PID-expression>)
     18  2889							;
     19  2889				   iIPCS
     20  2889		       98		      tya
     21  288a		       48		      pha
     22  288b		       20 f2 28 	      jsr	ipc_enqueue
     23  288e		       b0 08		      bcs	iIPC_BAD
     24  2890		       20 66 2e 	      jsr	pushTrue
     25  2893		       68		      pla
     26  2894		       a8		      tay
     27  2895		       4c b1 02 	      jmp	NextIL
     28  2898				   iIPC_BAD
     29  2898		       68		      pla
     30  2899		       a8		      tay
     31  289a		       20 70 2e 	      jsr	pushFalse
     32  289d		       4c b1 02 	      jmp	NextIL
     33  28a0
     34  28a0							;======================================================
     35  28a0							; ipcr   - Recieve msg from task
     36  28a0							; on exit  the message value is returned from message queue
     37  28a0							;	    message -1	is reserved meaning no entry found
     38  28a0							; The provided variable contains the pid of the sending
     39  28a0							; task. This is optional. This always waits for a message
     40  28a0							; before returning.
     41  28a0							;
     42  28a0							; a = ipcr(<variable name>)
     43  28a0							;
     44  28a0				   iIPCR
     45  28a0		       98		      tya
     46  28a1		       48		      pha
     47  28a2		       20 34 29 	      jsr	ipc_dequeue
     48  28a5		       b0 05		      bcs	iIPCR_Q_Empty
     49  28a7		       68		      pla
     50  28a8		       a8		      tay
     51  28a9		       4c b1 02 	      jmp	NextIL
     52  28ac				   iIPCR_Q_Empty
     53  28ac		       68		      pla
     54  28ad		       a8		      tay
     55  28ae		       20 66 2e 	      jsr	pushTrue	; puts -1 on the stack
     56  28b1		       4c b1 02 	      jmp	NextIL
     57  28b4
     58  28b4							;=======================================================
     59  28b4							; ipcc   - Check if message available
     60  28b4							; on exit  Stack contains number of messages
     61  28b4							;
     62  28b4							; a = ipcc()
     63  28b4							;
     64  28b4				   iIPCC
     65  28b4		       98		      tya
     66  28b5		       48		      pha
     67  28b6		       20 df 28 	      jsr	ipc_queue_count
     68  28b9		       20 a9 2b 	      jsr	pushR0	; return the count
     69  28bc		       68		      pla
     70  28bd		       a8		      tay
     71  28be		       4c b1 02 	      jmp	NextIL
     72  28c1
     73  28c1							;=======================================================
     74  28c1							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  28c1				   iIPCIO
     76  28c1		       98		      tya
     77  28c2		       48		      pha
     78  28c3		       20 df 28 	      jsr	ipc_queue_count
     79  28c6		       a5 52		      lda	R0
     80  28c8		       d0 10		      bne	iIPCIO_No_Halt
     81  28ca		       a9 01		      lda	#1
     82  28cc		       8d 09 37 	      sta	taskCurrentCycles	; force a task switch
     83  28cf		       a9 01		      lda	#TASKWAITIPC
     84  28d1		       ac 0e 36 	      ldy	taskPtr
     85  28d4		       19 0f 36 	      ora	taskTable,y
     86  28d7		       99 0f 36 	      sta	taskTable,y
     87  28da
     88  28da				   iIPCIO_No_Halt
     89  28da		       68		      pla
     90  28db		       a8		      tay
     91  28dc		       4c b1 02 	      jmp	NextIL
     92  28df							;======================================================
     93  28df							;ipc_queue_count
     94  28df				   ipc_queue_count
     95  28df		       a5 4e		      lda	MESSAGEPTR
     96  28e1		       18		      clc
     97  28e2		       4a		      lsr		; divide by 4
     98  28e3		       4a		      lsr
     99  28e4		       85 52		      sta	R0	; store into R0
    100  28e6		       a9 10		      lda	#GOSUBSTACKSIZE
    101  28e8		       38		      sec
    102  28e9		       e5 52		      sbc	R0	; Get how many entries on queue
    103  28eb		       85 52		      sta	R0
    104  28ed		       a9 00		      lda	#0
    105  28ef		       85 53		      sta	R0+1
    106  28f1		       60		      rts
    107  28f2							;=======================================================
    108  28f2							; Support functions for messaging
    109  28f2							;
    110  28f2							; Enqueue message -> onto PID's MSG Q
    111  28f2							; on entry top of stack contains the PID
    112  28f2							;	    second contains the Message of the task
    113  28f2							; on exit contains c set if failed
    114  28f2							;		    c cleared if success
    115  28f2							;		    PID's MSG Q PTR points to the message
    116  28f2							;
    117  28f2				   ipc_enqueue
    118  28f2		       20 53 2c 	      jsr	popR1	; Get the pid
    119  28f5		       20 6d 29 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  28f8
    121  28f8		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  28fa		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  28fc		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  28fe		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  2900		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  2902
    127  2902
    128  2902							; Get the PID'S stack address into R0
    129  2902		       a0 0b		      ldy	#GOSUBSTKPOS
    130  2904		       b1 56		      lda	(MQ),y
    131  2906		       85 52		      sta	R0
    132  2908		       c8		      iny
    133  2909		       b1 56		      lda	(MQ),y
    134  290b		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  290d
    136  290d							; Set y to point to the msg q entry
    137  290d		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  290f		       b1 56		      lda	(MQ),y	; Get the index
    139  2911		       a8		      tay		; Set y to queue offset
    140  2912
    141  2912							; enqueue the message
    142  2912		       88		      dey		; First byte to save to
    143  2913		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  2915		       91 52		      sta	(R0),y	; Set the entry type
    145  2917
    146  2917		       88		      dey
    147  2918		       ad 0e 36 	      lda	taskPtr	; Store the PID into queue
    148  291b		       91 52		      sta	(R0),y
    149  291d		       20 53 2c 	      jsr	popR1	; Get the actual message value
    150  2920		       20 a1 29 	      jsr	ipc_pushR1	; Store Message value into queue
    151  2923
    152  2923		       98		      tya		; Save the new q ptr
    153  2924		       a0 0e		      ldy	#MSGPTRPOS
    154  2926		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  2928		       a0 00		      ldy	#0	; points to context root
    156  292a		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  292c		       51 56		      eor	(MQ),y	; Turn off the bit
    158  292e		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  2930		       18		      clc
    160  2931		       60		      rts
    161  2932				   ipc_enq_full
    162  2932		       38		      sec
    163  2933		       60		      rts
    164  2934							;=============================================================
    165  2934							; De-queue for message stack -> local tasks msg q
    166  2934							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  2934							;  message into
    168  2934							;  on exit   math stack contains value of message
    169  2934							;				  Variable if provided is pid
    170  2934				   ipc_dequeue
    171  2934		       20 6a 2c 	      jsr	popMQ	; Variable address to put PID into
    172  2937
    173  2937		       a4 4e		      ldy	MESSAGEPTR
    174  2939		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    175  293b		       b0 2e		      bcs	ipc_deq_empty
    176  293d		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  293f		       85 52		      sta	R0
    178  2941		       c8		      iny
    179  2942		       b1 4b		      lda	(GOSUBSTACK),y
    180  2944		       85 53		      sta	R0+1
    181  2946		       c8		      iny
    182  2947		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  2949		       85 54		      sta	R1
    184  294b		       c8		      iny
    185  294c		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  294e		       c8		      iny
    187  294f		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  2951
    189  2951		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  2953		       d0 16		      bne	ipc_deq_empty
    191  2955
    192  2955		       20 a9 2b 	      jsr	pushR0	; place value on stack
    193  2958
    194  2958		       a5 56		      lda	MQ
    195  295a		       05 57		      ora	MQ+1
    196  295c		       f0 0b		      beq	ipc_deq_done
    197  295e		       a5 54		      lda	R1
    198  2960		       a0 00		      ldy	#0
    199  2962		       91 56		      sta	(MQ),y
    200  2964		       c8		      iny
    201  2965		       a9 00		      lda	#0
    202  2967		       91 56		      sta	(MQ),y
    203  2969				   ipc_deq_done
    204  2969		       18		      clc
    205  296a		       60		      rts
    206  296b
    207  296b				   ipc_deq_empty
    208  296b		       38		      sec
    209  296c		       60		      rts
    210  296d
    211  296d							;=============================================
    212  296d							;  Get the context address into MQ from R1 with
    213  296d							;  context/index/pid
    214  296d				   ipc_getcontext
    215  296d		       18		      clc		; Get pointer to Task context
    216  296e		       a9 0f		      lda	#taskTable&$FF	; change ptr to address
    217  2970		       65 54		      adc	R1
    218  2972		       85 56		      sta	MQ
    219  2974		       a9 36		      lda	#taskTable>>8
    220  2976		       65 55		      adc	R1+1
    221  2978		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  297a		       60		      rts
    223  297b							;
    224  297b							;==============================================
    225  297b							; on entry R1 has a context value,
    226  297b							; on exit c is set if fails
    227  297b							;
    228  297b				   ipc_CONTEXTVALUES
      0  297b					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  297b		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  297f					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  297f		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  2983					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  2983		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    232  2985
    233  2985				   ipc_ValidateContext
    234  2985		       48		      pha
    235  2986		       8a		      txa
    236  2987		       48		      pha
    237  2988		       a5 55		      lda	R1+1
    238  298a		       d0 0e		      bne	ipc_Validate_Fail
    239  298c		       a2 00		      ldx	#0
    240  298e		       a5 54		      lda	R1
    241  2990				   ipc_ValidateLoop
    242  2990		       dd 7b 29 	      cmp	ipc_CONTEXTVALUES,x
    243  2993		       f0 09		      beq	ipc_Valid_Context
    244  2995		       e8		      inx
    245  2996		       e0 0a		      cpx	#TASKCOUNT
    246  2998		       90 f6		      bcc	ipc_ValidateLoop
    247  299a
    248  299a				   ipc_Validate_Fail
    249  299a		       68		      pla
    250  299b		       aa		      tax
    251  299c		       68		      pla
      0  299d					      rtn
      0  299d					      db	25
      1  299d		       19		      .byte.b	25
    253  299e
    254  299e				   ipc_Valid_Context
    255  299e		       18		      clc
    256  299f		       90 f9		      bcc	ipc_Validate_Fail
    257  29a1							;
    258  29a1							;==============================================
    259  29a1							;Push R1 onto the stack
    260  29a1							;on entry y = next entry
    261  29a1							;R0 points to the stack space
    262  29a1							;on exit y points to next free byte
    263  29a1				   ipc_pushR1
    264  29a1		       88		      dey
    265  29a2		       a5 55		      lda	R1+1	; PID first
    266  29a4		       91 52		      sta	(R0),y
    267  29a6		       88		      dey
    268  29a7		       a5 54		      lda	R1
    269  29a9		       91 52		      sta	(R0),y
    270  29ab		       60		      rts
    271  29ac
    272  29ac
    273  29ac
    274  29ac
    275  29ac
    276  29ac
    277  29ac
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  29ac					      include	"support.asm"
      1  29ac							;
      2  29ac							;=====================================================
      3  29ac							;=====================================================
      4  29ac							;=====================================================
      5  29ac							; This marks the start of support functions used by
      6  29ac							; the IL opcodes.  These are support functions, NOT
      7  29ac							; the IL code.
      8  29ac							;=====================================================
      9  29ac							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  29ac							;=====================================================
     11  29ac					      Seg	Code
     12  29ac							;=====================================================
     13  29ac							; This gets the next two bytes pointed to by ILPC and
     14  29ac							; returns them; X contains LSB, A contains MSB.  ILPC
     15  29ac							; is advanced by two, and Y contains 0 on return.
     16  29ac
     17  29ac							;
     18  29ac		       20 b0 29    getILWord  jsr	getILByte	;LSB
     19  29af		       aa		      tax
     20  29b0							;
     21  29b0							;=====================================================
     22  29b0							; This gets the next byte pointed to by ILPC and
     23  29b0							; returns it in A.  On return, X is unchanged but Y
     24  29b0							; contains 0.
     25  29b0							;
     26  29b0		       a0 00	   getILByte  ldy	#0
     27  29b2		       b1 43		      lda	(ILPC),y	;get byte
     28  29b4		       08		      php		;save status
     29  29b5		       e6 43		      inc	ILPC	;inc LSB
     30  29b7		       d0 02		      bne	getILb2	;branch if no overflow
     31  29b9		       e6 44		      inc	ILPC+1	;inc MSB
     32  29bb		       28	   getILb2    plp		;restore status
     33  29bc		       60		      rts
     34  29bd							;
     35  29bd							;=====================================================
     36  29bd							; Decrement ILPC by one.
     37  29bd							;
     38  29bd		       a5 43	   decIL      lda	ILPC
     39  29bf		       d0 02		      bne	decIL2
     40  29c1		       c6 44		      dec	ILPC+1
     41  29c3		       c6 43	   decIL2     dec	ILPC
     42  29c5		       60		      rts
     43  29c6							;
     44  29c6							;=====================================================
     45  29c6							; Push the ILPC onto the return stack.  Actually, this
     46  29c6							; pushes the address of ILPC+2 since that's the next
     47  29c6							; address to execute.
     48  29c6							;
     49  29c6		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  29c8		       c0 64		      cpy	#ILSTACKSIZE<<1
     51  29ca		       b0 15		      bcs	pushErr
     52  29cc		       a5 43		      lda	ILPC
     53  29ce		       18		      clc
     54  29cf		       69 02		      adc	#2
     55  29d1		       91 45		      sta	(ILSTACK),y
     56  29d3		       08		      php		;save C bit
     57  29d4		       c8		      iny
     58  29d5		       a5 44		      lda	ILPC+1
     59  29d7		       28		      plp		;restore C
     60  29d8		       69 00		      adc	#0
     61  29da		       91 45		      sta	(ILSTACK),y
     62  29dc		       c8		      iny
     63  29dd		       84 47		      sty	ILSTACKPTR
     64  29df		       18		      clc
     65  29e0		       60		      rts
     66  29e1				   pushErr
     67  29e1		       38		      sec
     68  29e2		       60		      rts
     69  29e3							;
     70  29e3							;=====================================================
     71  29e3							; Pull the top entry from return stack and put into
     72  29e3							; ILPC.
     73  29e3							;
     74  29e3		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  29e5		       f0 fa		      beq	pushErr
     76  29e7		       88		      dey
     77  29e8		       b1 45		      lda	(ILSTACK),y
     78  29ea		       85 44		      sta	ILPC+1
     79  29ec		       88		      dey
     80  29ed		       b1 45		      lda	(ILSTACK),y
     81  29ef		       85 43		      sta	ILPC
     82  29f1		       84 47		      sty	ILSTACKPTR
     83  29f3		       18		      clc
     84  29f4		       60		      rts
     85  29f5							;
     86  29f5							;=====================================================
     87  29f5							; This searches for a specific line number that is in
     88  29f5							; R0.	There are three possible return conditions:
     89  29f5							; Line numbers are now the third byte, the first byte is now
     90  29f5							; a pointer to the next line, of course no longer than 255 byte
     91  29f5							; per line.
     92  29f5							;
     93  29f5							; Exact match was found:
     94  29f5							;    * Z set
     95  29f5							;    * CURPTR points to two-byte line number for that
     96  29f5							;	line.
     97  29f5							;
     98  29f5							; Next highest line found:
     99  29f5							;    * Z cleared
    100  29f5							;    * C set
    101  29f5							;    * CURPTR points to two-byte line number for that
    102  29f5							;	line.
    103  29f5							;
    104  29f5							; End of program reached:
    105  29f5							;    * Z cleared
    106  29f5							;    * C cleared
    107  29f5							;    * CURPTR points to first free byte at end of
    108  29f5							;	program.  Ie, it has save value as PROGRAMEND.
    109  29f5							;
    110  29f5							; A, X, and Y are all undefined on return.
    111  29f5							;
    112  29f5
    113  29f5				   findLine
    114  29f5		       ad 83 42 	      lda	ProgramStart	;Start of program -> CURPTR
    115  29f8		       85 4f		      sta	CURPTR
    116  29fa		       ad 84 42 	      lda	ProgramStart+1
    117  29fd		       85 50		      sta	CURPTR+1
    118  29ff							;
    119  29ff							; At end of code?
    120  29ff							;
    121  29ff				   iXFER1
    122  29ff		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  2a01		       cd 85 42 	      cmp	ProgramEnd	; at end of program then stop run
    124  2a04		       d0 0b		      bne	xfer2	; not end
    125  2a06		       a5 50		      lda	CURPTR+1
    126  2a08		       cd 86 42 	      cmp	ProgramEnd+1
    127  2a0b		       d0 04		      bne	xfer2	;Not at end
    128  2a0d							;
    129  2a0d							; Line not found and the end of the program was
    130  2a0d							; reached.  Return Z and C both clear.
    131  2a0d							;
    132  2a0d		       a9 01		      lda	#1	;clear Z
    133  2a0f		       18		      clc		;clear C
    134  2a10		       60		      rts
    135  2a11							;
    136  2a11							; Check for an exact line number match
    137  2a11							;
    138  2a11		       a5 52	   xfer2      lda	R0
    139  2a13		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  2a15		       d1 4f		      cmp	(CURPTR),y
    141  2a17		       d0 08		      bne	xfernotit
    142  2a19		       c8		      iny
    143  2a1a		       a5 53		      lda	R0+1
    144  2a1c		       d1 4f		      cmp	(CURPTR),y
    145  2a1e		       d0 01		      bne	xfernotit	; not a matching line number
    146  2a20							;
    147  2a20							; This is exactly the line we want.
    148  2a20							;
    149  2a20		       60		      rts		;it matches exactly
    150  2a21							;
    151  2a21							; See if this line is greater than the one we're
    152  2a21							; searching for.
    153  2a21							;
    154  2a21		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  2a23		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  2a25		       c5 53		      cmp	R0+1
    157  2a27		       90 0b		      bcc	xfer3
    158  2a29		       d0 07		      bne	xfer4
    159  2a2b		       88		      dey
    160  2a2c		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  2a2e		       c5 52		      cmp	R0
    162  2a30		       90 02		      bcc	xfer3
    163  2a32							;
    164  2a32							; This line is greater than the one we want, so
    165  2a32							; return Z clear and C set.
    166  2a32							;
    167  2a32		       38	   xfer4      sec		;We found a line number greater
    168  2a33		       60		      rts		;both conditions set
    169  2a34							;
    170  2a34							; Not the line (or droid) we're looking for.  Move to
    171  2a34							; the next line.
    172  2a34							;
    173  2a34		       20 3a 2a    xfer3      jsr	FindNextLine
    174  2a37		       4c ff 29 	      jmp	iXFER1
    175  2a3a							;
    176  2a3a							;=====================================================
    177  2a3a							; This advances CURPTR to the next line.  If there
    178  2a3a							; are no more lines, this leaves CURPTR equal to
    179  2a3a							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  2a3a							; CURPTR is pointing to a valid line on entry.  This
    181  2a3a							; pointer points to the two-byte line number.
    182  2a3a							; Update this points to the 1 byte line length  ****************
    183  2a3a							;
    184  2a3a				   FindNextLine
    185  2a3a		       a0 03		      ldy	#3	;skip line number and length byte
    186  2a3c		       84 51		      sty	CUROFF	;this is the new offset
    187  2a3e		       a0 00		      ldy	#0
    188  2a40		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  2a42		       18		      clc
    190  2a43		       65 4f		      adc	CURPTR
    191  2a45		       85 4f		      sta	CURPTR
    192  2a47		       a5 50		      lda	CURPTR+1
    193  2a49		       69 00		      adc	#0
    194  2a4b		       85 50		      sta	CURPTR+1
    195  2a4d		       60	   FindNext4  rts
    196  2a4e							;
    197  2a4e							;=====================================================
    198  2a4e							; This compares CURPTR to PROGRAMEND and returns Z set
    199  2a4e							; if they are equal, Z clear if not.
    200  2a4e							;
    201  2a4e		       a5 4f	   AtEnd      lda	CURPTR
    202  2a50		       cd 85 42 	      cmp	ProgramEnd
    203  2a53		       d0 05		      bne	atendexit
    204  2a55		       a5 50		      lda	CURPTR+1
    205  2a57		       cd 86 42 	      cmp	ProgramEnd+1
    206  2a5a		       60	   atendexit  rts
    207  2a5b							;
    208  2a5b
    209  2a5b							;
    210  2a5b							;=====================================================
    211  2a5b							; Convert an ASCII string to a number.  On input,
    212  2a5b							; (CURPTR),Y points to the first digit.  This gets
    213  2a5b							; digit-by-digit until finding a non-number.  Returns
    214  2a5b							; Y pointing to the non-digit, and R0 contains the
    215  2a5b							; number.  This does NOT check for valid ranges, so
    216  2a5b							; a value like "123456789" will produce something,
    217  2a5b							; but not what you had expected.
    218  2a5b							;
    219  2a5b		       a9 00	   getDecimal lda	#0
    220  2a5d		       85 52		      sta	R0
    221  2a5f		       85 53		      sta	R0+1
    222  2a61		       85 59		      sta	dpl	;temporary negative flag
    223  2a63							;
    224  2a63							; See if it's negative...
    225  2a63							;
    226  2a63							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  2a63		       b1 4f		      lda	(CURPTR),y
    228  2a65		       c9 2d		      cmp	#'-
    229  2a67		       d0 02		      bne	getDecLoop
    230  2a69		       e6 59		      inc	dpl	;it's negative
    231  2a6b							;
    232  2a6b		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  2a6d		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  2a6f		       c9 30		      cmp	#'0
    235  2a71		       90 36		      bcc	getDdone
    236  2a73		       c9 3a		      cmp	#'9+1
    237  2a75		       b0 32		      bcs	getDdone
    238  2a77		       38		      sec
    239  2a78		       e9 30		      sbc	#'0	;convert to binary
    240  2a7a		       48		      pha
    241  2a7b							;
    242  2a7b							; Now multiply R0 by 10.  Remember that
    243  2a7b							; 2*N + 8*N = 10*N.
    244  2a7b							;
    245  2a7b		       06 52		      asl	R0
    246  2a7d		       26 53		      rol	R0+1	;*2
    247  2a7f		       a5 52		      lda	R0
    248  2a81		       85 54		      sta	R1
    249  2a83		       a5 53		      lda	R0+1
    250  2a85		       85 55		      sta	R1+1
    251  2a87		       06 52		      asl	R0
    252  2a89		       26 53		      rol	R0+1	;*4
    253  2a8b		       06 52		      asl	R0
    254  2a8d		       26 53		      rol	R0+1	;*8
    255  2a8f		       18		      clc		;now add the partial sums...
    256  2a90		       a5 52		      lda	R0	;...to get *10
    257  2a92		       65 54		      adc	R1
    258  2a94		       85 52		      sta	R0
    259  2a96		       a5 53		      lda	R0+1
    260  2a98		       65 55		      adc	R1+1
    261  2a9a		       85 53		      sta	R0+1
    262  2a9c							;
    263  2a9c							; Add in the new digit
    264  2a9c							;
    265  2a9c		       68		      pla
    266  2a9d		       18		      clc
    267  2a9e		       65 52		      adc	R0
    268  2aa0		       85 52		      sta	R0
    269  2aa2		       90 02		      bcc	getD2
    270  2aa4		       e6 53		      inc	R0+1
    271  2aa6							;
    272  2aa6							; Move to next character
    273  2aa6							;
    274  2aa6		       c8	   getD2      iny
    275  2aa7		       d0 c2		      bne	getDecLoop
    276  2aa9							;
    277  2aa9							; All done with digits, so now deal with it being
    278  2aa9							; negative.  If zero, then don't check for negative
    279  2aa9							; flag.  Ie, -0 is stored as 0.
    280  2aa9							;
    281  2aa9		       a5 52	   getDdone   lda	R0
    282  2aab		       05 53		      ora	R0+1
    283  2aad		       f0 16		      beq	getDone2	;zero
    284  2aaf		       a5 59		      lda	dpl
    285  2ab1		       f0 12		      beq	getDone2	;positive
    286  2ab3							;
    287  2ab3							; Invert all the bits, then add one.
    288  2ab3							;
    289  2ab3		       a5 52		      lda	R0
    290  2ab5		       49 ff		      eor	#$ff
    291  2ab7		       85 52		      sta	R0
    292  2ab9		       a5 53		      lda	R0+1
    293  2abb		       49 ff		      eor	#$ff
    294  2abd		       85 53		      sta	R0+1
    295  2abf							;
    296  2abf		       e6 52		      inc	R0
    297  2ac1		       d0 02		      bne	getDone2
    298  2ac3		       e6 53		      inc	R0+1
    299  2ac5				   getDone2
    300  2ac5							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  2ac5							;lda	  R0
    302  2ac5							;sta	  $0010
    303  2ac5							;lda	  R0+1
    304  2ac5							;sta	  $0011
    305  2ac5							;lda	  dpl
    306  2ac5							;sta	  $012
    307  2ac5
    308  2ac5		       60		      rts
    309  2ac6
    310  2ac6							;=====================================================
    311  2ac6							; Gets a line of input into LINBUF.
    312  2ac6							;
    313  2ac6							; On entry:
    314  2ac6							;    A contains the prompt character, or 0 if none.
    315  2ac6							;    X = 1 Background read
    316  2ac6							;    x = 0 Forground read with wait
    317  2ac6							;
    318  2ac6							; On exit:
    319  2ac6							;    CURPTR points to LINBUF
    320  2ac6							;    LINBUF contains the line with 0 at the end.
    321  2ac6							;    Y has offset to first non-space character
    322  2ac6							;    CURROFF has the same as Y.
    323  2ac6							;
    324  2ac6		       20 15 2b    GetLine    jsr	ReadPrompt
    325  2ac9		       e0 00		      cpx	#0
    326  2acb		       f0 14		      beq	GetLineRetry
    327  2acd		       ae 0e 36 	      ldx	taskPtr
    328  2ad0		       bd 0f 36 	      lda	taskTable,x
    329  2ad3		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  2ad5		       d0 3d		      bne	taskWaitingIO
    331  2ad7		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  2ad9		       9d 0f 36 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  2adc		       ce 14 2b 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  2adf		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  2ae1
    336  2ae1							;
    337  2ae1							; Now read a line and wait for the CR
    338  2ae1							;
    339  2ae1				   GetLineRetry
    340  2ae1		       a9 00		      lda	#0	;Wait for input to complete
    341  2ae3		       20 2d 2b 	      jsr	ReadLine
    342  2ae6
    343  2ae6							;
    344  2ae6							; Point to the line we just read
    345  2ae6							; Set the current pointer to point to the input line
    346  2ae6							;
    347  2ae6		       a0 00	   ReadComplete ldy	#0
    348  2ae8		       84 51		      sty	CUROFF
    349  2aea		       a2 ea		      ldx	#LINBUF&$ff
    350  2aec		       86 4f		      stx	CURPTR
    351  2aee		       a2 41		      ldx	#LINBUF>>8
    352  2af0		       86 50		      stx	CURPTR+1
    353  2af2							;
    354  2af2							; Output a CR/LF
    355  2af2							;
    356  2af2		       20 f4 2c 	      jsr	CRLF
    357  2af5							;
    358  2af5							; If a blank line, prompt again.
    359  2af5							;
    360  2af5		       20 eb 2c 	      jsr	SkipSpaces
    361  2af8		       b1 4f		      lda	(CURPTR),y
    362  2afa		       d0 10		      bne	GetLineDone	;We have data then exit
    363  2afc		       20 18 2b 	      jsr	ReadPromptRetry
    364  2aff		       ae 0e 36 	      ldx	taskPtr	;if this task is waiting for IO
    365  2b02		       bd 0f 36 	      lda	taskTable,x	;then get out, wait for line to
    366  2b05		       29 40		      and	#TASKWAITIO	;Complete again
    367  2b07		       d0 0b		      bne	taskWaitingIO
    368  2b09		       4c e1 2a 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  2b0c
    370  2b0c				   GetLineDone
    371  2b0c		       ae 0e 36 	      ldx	taskPtr
    372  2b0f		       a9 80		      lda	#TASKACTIVE
    373  2b11		       9d 0f 36 	      sta	taskTable,x	;IO is complete
    374  2b14
    375  2b14				   taskWaitingIO
    376  2b14		       60		      rts
    377  2b15
    378  2b15							;
    379  2b15							;=======================================================================
    380  2b15							; Display the prompt character
    381  2b15							; On entry
    382  2b15							;	    A contains the prompt character
    383  2b15							; On exit
    384  2b15							;	    The readbuffer index is reset to 0
    385  2b15							;
    386  2b15		       8d 71 42    ReadPrompt sta	promptChar
    387  2b18
    388  2b18							;
    389  2b18							; Prompt
    390  2b18							;
    391  2b18
    392  2b18		       ad 71 42    ReadPromptRetry lda	promptChar
    393  2b1b		       09 00		      ora	#0	;any prompt?
    394  2b1d		       f0 08		      beq	getlinenp
    395  2b1f		       20 e3 19 	      jsr	VOUTCH
    396  2b22		       a9 20		      lda	#$20
    397  2b24		       20 e3 19 	      jsr	VOUTCH	;Space after prompt
    398  2b27							;
    399  2b27		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  2b29		       8e 6e 42 	      stx	getlinx
    401  2b2c		       60		      rts
    402  2b2d							;
    403  2b2d							;===============================================================
    404  2b2d							; This fuction is the driver for the line input
    405  2b2d							; on call if a = 0 then it waits for all input
    406  2b2d							;	      a = 1 then nowait for input
    407  2b2d							; On exit
    408  2b2d							;		       c clear if not complete line
    409  2b2d							;		       c set if it was a complete line
    410  2b2d
    411  2b2d				   ReadLine
    412  2b2d		       8d 70 42 	      sta	inputNoWait
    413  2b30		       c9 00		      cmp	#0
    414  2b32		       f0 05		      beq	getline1
    415  2b34		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  2b37		       f0 2b		      beq	GetLineNoWait
    417  2b39		       20 e6 19    getline1   jsr	VGETCH
    418  2b3c					      if	CTMON65
    419  2b3c		       48		      pha
    420  2b3d		       20 e3 19 	      jsr	VOUTCH	;echo echo echo
    421  2b40		       68		      pla
    422  2b41					      endif
    423  2b41		       c9 0d		      cmp	#CR
    424  2b43		       f0 15		      beq	getlind	;end of line
    425  2b45		       c9 08		      cmp	#BS	;backspace?
    426  2b47		       f0 1d		      beq	getlinebs
    427  2b49		       ae 6e 42 	      ldx	getlinx
    428  2b4c		       9d ea 41 	      sta	LINBUF,x
    429  2b4f		       e8		      inx
    430  2b50		       8e 6e 42 	      stx	getlinx
    431  2b53		       ad 70 42 	      lda	inputNoWait
    432  2b56		       f0 e1		      beq	getline1
    433  2b58		       d0 0a		      bne	GetLineNoWait
    434  2b5a							;
    435  2b5a							; CR was hit
    436  2b5a							;
    437  2b5a		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  2b5c		       ae 6e 42 	      ldx	getlinx
    439  2b5f		       9d ea 41 	      sta	LINBUF,x
    440  2b62
    441  2b62		       38		      sec		; Carry set then cr received
    442  2b63		       60		      rts
    443  2b64
    444  2b64				   GetLineNoWait
    445  2b64		       18		      clc		; Carry clear no end of line
    446  2b65		       60		      rts
    447  2b66							;
    448  2b66							; Backspace was hit
    449  2b66							;
    450  2b66		       ae 6e 42    getlinebs  ldx	getlinx
    451  2b69		       f0 0e		      beq	getlineEOL	;at start of line
    452  2b6b		       ca		      dex
    453  2b6c		       8e 6e 42 	      stx	getlinx
    454  2b6f		       20 32 21    getlinepbs jsr	puts
      0  2b72					      db	27,"[K",0
      1  2b72		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  2b76		       4c 39 2b 	      jmp	getline1
    457  2b79		       a9 20	   getlineEOL lda	#SPACE
    458  2b7b		       20 e3 19 	      jsr	VOUTCH
    459  2b7e		       d0 ef		      bne	getlinepbs
    460  2b80							;
    461  2b80							;=====================================================
    462  2b80							; Count the length of the line currently in LINBUF
    463  2b80							; starting at offset Y.  Returns the length in X.  The
    464  2b80							; starting offset in Y should point past the ASCII
    465  2b80							; line number.  Also counts the trailing NULL and two
    466  2b80							; extra bytes for where the line number will be.
    467  2b80							; Update must now include leading length byte not the null at end ****************
    468  2b80							;
    469  2b80				   getLineLength
    470  2b80		       a2 00		      ldx	#0	;size
    471  2b82		       b9 ea 41    getLineL2  lda	LINBUF,y
    472  2b85		       f0 04		      beq	getLineL3
    473  2b87		       c8		      iny
    474  2b88		       e8		      inx
    475  2b89		       d0 f7		      bne	getLineL2
    476  2b8b		       e8	   getLineL3  inx		;count null at end
    477  2b8c		       e8		      inx		;line number LSB
    478  2b8d		       e8		      inx		;MSB
    479  2b8e		       e8		      inx		;change: count new leading line length
    480  2b8f		       8e 80 42 	      stx	lineLength
    481  2b92		       60		      rts
    482  2b93							;
    483  2b93							;=====================================================
    484  2b93							; Count the length of the line pointed to by CURPTR.
    485  2b93							; This also counts the line number and the terminating
    486  2b93							; null.  Ie, this string returns 8:
    487  2b93							;
    488  2b93							; <lineLow><lineHi>Hello<null>
    489  2b93							;
    490  2b93							; Another way of looking at it: add the return value
    491  2b93							; to the CURPTR and it'll point to the next line's
    492  2b93							; line number.  Returns the value in Y.
    493  2b93							; Update to ject get the leading byte length ********************
    494  2b93							;
    495  2b93							;getCURPTRLength
    496  2b93							;		ldy	CURPTR
    497  2b93							;		ldy	#3	;change: skip line number and leading length byte
    498  2b93							;getCLineL2	lda	(CURPTR),y
    499  2b93							;		beq	getCLineL3
    500  2b93							;		iny
    501  2b93							;		bne	getCLineL2
    502  2b93							;getCLineL3	iny		;count null at end
    503  2b93							;		rts
    504  2b93
    505  2b93							;
    506  2b93							;=====================================================
    507  2b93							; This saves ILPC.  This saves to a single save area,
    508  2b93							; so it can't be called more than once.
    509  2b93							;
    510  2b93		       a5 43	   saveIL     lda	ILPC
    511  2b95		       8d 7c 42 	      sta	tempIL
    512  2b98		       a5 44		      lda	ILPC+1
    513  2b9a		       8d 7d 42 	      sta	tempIL+1
    514  2b9d		       60		      rts
    515  2b9e							;
    516  2b9e							;=====================================================
    517  2b9e							; This restores ILPC.
    518  2b9e							;
    519  2b9e		       ad 7c 42    restoreIL  lda	tempIL
    520  2ba1		       85 43		      sta	ILPC
    521  2ba3		       ad 7d 42 	      lda	tempIL+1
    522  2ba6		       85 44		      sta	ILPC+1
    523  2ba8		       60		      rts
    524  2ba9							;
    525  2ba9							;=====================================================
    526  2ba9							; This pushes R0 onto the stack.
    527  2ba9							;
    528  2ba9		       8c 77 42    pushR0     sty	rtemp1
    529  2bac		       a4 4a		      ldy	MATHSTACKPTR
    530  2bae		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  2bb0		       b0 38		      bcs	pusherr
    532  2bb2		       a5 52		      lda	R0
    533  2bb4		       91 48		      sta	(MATHSTACK),y
    534  2bb6		       c8		      iny
    535  2bb7		       a5 53		      lda	R0+1
    536  2bb9		       91 48		      sta	(MATHSTACK),y
    537  2bbb		       c8		      iny
    538  2bbc		       84 4a		      sty	MATHSTACKPTR
    539  2bbe		       ac 77 42 	      ldy	rtemp1
    540  2bc1		       18		      clc
    541  2bc2		       60		      rts
    542  2bc3
    543  2bc3							;=====================================================
    544  2bc3							; This pushes curptr basic current line onto the call stack.
    545  2bc3							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  2bc3
    547  2bc3				   pushLN
    548  2bc3		       8d 78 42 	      STA	rtemp1+1	; Store type of push being done
    549  2bc6		       8c 77 42 	      sty	rtemp1
    550  2bc9		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  2bcb		       c5 4d		      cmp	GOSUBSTACKPTR
    552  2bcd		       90 1b		      bcc	pusherr	; No error
    553  2bcf		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  2bd1		       a2 00		      ldx	#0	; Start of bytes to copy
    555  2bd3				   pushLoop
    556  2bd3		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  2bd5		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  2bd7		       c8		      iny		; Next destination
    559  2bd8		       e8		      inx		; Next Source byte
    560  2bd9		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  2bdb		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  2bdd
    563  2bdd		       ad 78 42    pushDone   lda	rtemp1+1	; Type of stack entry
    564  2be0		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  2be2		       c8		      iny		; Next entry
    566  2be3
    567  2be3		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  2be5		       ac 77 42 	      ldy	rtemp1
    569  2be8		       18		      clc
    570  2be9		       60		      rts
    571  2bea				   pusherr
    572  2bea		       38		      sec
    573  2beb		       60		      rts
    574  2bec							;=====================================================
    575  2bec							; This pops Top Off gosub call Stack and
    576  2bec							; places it in CURPTR/CUROFF.
    577  2bec							; This checks if the type = 1 GOSUB
    578  2bec							; if not it removes what ever is on the stack
    579  2bec							; until it finds the next return. Allowing
    580  2bec							; a return from within a for/next
    581  2bec							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  2bec		       8c 77 42    popLN      sty	rtemp1
    583  2bef		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  2bf1		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  2bf3
    586  2bf3				   popContinue
    587  2bf3		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  2bf5		       90 22		      bcc	poperr	; Process an error
    589  2bf7
    590  2bf7		       88		      dey		; Position to read entry type
    591  2bf8		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  2bfa		       8d 78 42 	      sta	rtemp1+1	; Save to be returned
    593  2bfd		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  2bff		       f0 04		      beq	popLoop	; Restore the line
    595  2c01		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  2c03		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  2c05
    598  2c05				   popLoop
    599  2c05		       88		      dey
    600  2c06		       ca		      dex
    601  2c07		       b1 4b		      lda	(GOSUBSTACK),y
    602  2c09		       95 4f		      sta	CURPTR,x
    603  2c0b		       e0 00		      cpx	#0
    604  2c0d		       d0 f6		      bne	popLoop	; Loop until all moved
    605  2c0f
    606  2c0f
    607  2c0f		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  2c11		       ac 77 42 	      ldy	rtemp1
    609  2c14		       ad 78 42 	      lda	rtemp1+1	; get the type of return
    610  2c17		       18		      clc
    611  2c18		       60		      rts
    612  2c19
    613  2c19		       38	   poperr     sec
    614  2c1a		       60		      rts
    615  2c1b
    616  2c1b		       88	   popSkipEntry dey
    617  2c1c		       88		      dey
    618  2c1d		       88		      dey
    619  2c1e		       4c f3 2b 	      jmp	popContinue
    620  2c21
    621  2c21							;
    622  2c21							;=====================================================
    623  2c21							; This pushes R1 onto the stack
    624  2c21							;
    625  2c21		       8c 77 42    pushR1     sty	rtemp1
    626  2c24		       a4 4a		      ldy	MATHSTACKPTR
    627  2c26		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  2c28		       b0 ef		      bcs	poperr
    629  2c2a		       a5 54		      lda	R1
    630  2c2c		       91 48		      sta	(MATHSTACK),y
    631  2c2e		       c8		      iny
    632  2c2f		       a5 55		      lda	R1+1
    633  2c31		       91 48		      sta	(MATHSTACK),y
    634  2c33		       c8		      iny
    635  2c34		       84 4a		      sty	MATHSTACKPTR
    636  2c36		       ac 77 42 	      ldy	rtemp1
    637  2c39		       18		      clc
    638  2c3a		       60		      rts
    639  2c3b							;
    640  2c3b							;=====================================================
    641  2c3b							; This pops Top Of Stack and places it in R0.
    642  2c3b							;
    643  2c3b		       8c 77 42    popR0      sty	rtemp1
    644  2c3e		       a4 4a		      ldy	MATHSTACKPTR
    645  2c40		       f0 d7		      beq	poperr
    646  2c42		       88		      dey
    647  2c43		       b1 48		      lda	(MATHSTACK),y
    648  2c45		       85 53		      sta	R0+1
    649  2c47		       88		      dey
    650  2c48		       b1 48		      lda	(MATHSTACK),y
    651  2c4a		       85 52		      sta	R0
    652  2c4c		       84 4a		      sty	MATHSTACKPTR
    653  2c4e		       ac 77 42 	      ldy	rtemp1
    654  2c51		       18		      clc
    655  2c52		       60		      rts
    656  2c53
    657  2c53							;
    658  2c53							;=====================================================
    659  2c53							; This pops TOS and places it in R1.
    660  2c53							;
    661  2c53		       8c 77 42    popR1      sty	rtemp1
    662  2c56		       a4 4a		      ldy	MATHSTACKPTR
    663  2c58		       f0 bf		      beq	poperr
    664  2c5a		       88		      dey
    665  2c5b		       b1 48		      lda	(MATHSTACK),y
    666  2c5d		       85 55		      sta	R1+1
    667  2c5f		       88		      dey
    668  2c60		       b1 48		      lda	(MATHSTACK),y
    669  2c62		       85 54		      sta	R1
    670  2c64		       84 4a		      sty	MATHSTACKPTR
    671  2c66		       ac 77 42 	      ldy	rtemp1
    672  2c69		       60		      rts
    673  2c6a							;
    674  2c6a							;=====================================================
    675  2c6a							; This pops TOS and places it in MQ.
    676  2c6a							;
    677  2c6a		       8c 77 42    popMQ      sty	rtemp1
    678  2c6d		       a4 4a		      ldy	MATHSTACKPTR
    679  2c6f		       f0 a8		      beq	poperr
    680  2c71		       88		      dey
    681  2c72		       b1 48		      lda	(MATHSTACK),y
    682  2c74		       85 57		      sta	MQ+1
    683  2c76		       88		      dey
    684  2c77		       b1 48		      lda	(MATHSTACK),y
    685  2c79		       85 56		      sta	MQ
    686  2c7b		       84 4a		      sty	MATHSTACKPTR
    687  2c7d		       ac 77 42 	      ldy	rtemp1
    688  2c80		       60		      rts
    689  2c81							;
    690  2c81							;=====================================================
    691  2c81							; This assists with multiplication and division by
    692  2c81							; looking at R0 and R1 and saving a flag as to what
    693  2c81							; sign the result will be.  Math is always done on
    694  2c81							; positive numbers, so this converts negative numbers
    695  2c81							; into positives.  On exit, R0 and R1 are both
    696  2c81							; positive.  If the signs were different then 'signs'
    697  2c81							; will be non-zero.
    698  2c81							;
    699  2c81		       a9 00	   SaveSigns  lda	#0
    700  2c83		       8d 76 42 	      sta	sign	;assume positive
    701  2c86		       a5 53		      lda	R0+1	;MSB
    702  2c88		       10 13		      bpl	SaveSigns1
    703  2c8a		       ee 76 42 	      inc	sign	;it's negative
    704  2c8d		       49 ff		      eor	#$ff	;flip bits
    705  2c8f		       85 53		      sta	R0+1
    706  2c91		       a5 52		      lda	R0
    707  2c93		       49 ff		      eor	#$ff
    708  2c95		       85 52		      sta	R0
    709  2c97		       e6 52		      inc	R0
    710  2c99		       d0 02		      bne	SaveSigns1
    711  2c9b		       e6 53		      inc	R0+1
    712  2c9d		       a5 55	   SaveSigns1 lda	R1+1
    713  2c9f		       10 1a		      bpl	SaveSigns2
    714  2ca1		       48		      pha
    715  2ca2		       ad 76 42 	      lda	sign
    716  2ca5		       49 01		      eor	#1
    717  2ca7		       8d 76 42 	      sta	sign
    718  2caa		       68		      pla
    719  2cab		       49 ff		      eor	#$ff	;flip bits
    720  2cad		       85 55		      sta	R1+1
    721  2caf		       a5 54		      lda	R1
    722  2cb1		       49 ff		      eor	#$ff
    723  2cb3		       85 54		      sta	R1
    724  2cb5		       e6 54		      inc	R1
    725  2cb7		       d0 02		      bne	SaveSigns2
    726  2cb9		       e6 55		      inc	R1+1
    727  2cbb		       60	   SaveSigns2 rts
    728  2cbc							;
    729  2cbc							;=====================================================
    730  2cbc							; This looks at the value of 'signs' and will convert
    731  2cbc							; both R0 and R1 to negative if set.
    732  2cbc							;
    733  2cbc				   RestoreSigns
    734  2cbc		       ad 76 42 	      lda	sign
    735  2cbf		       f0 28		      beq	restoresigns2
    736  2cc1							;
    737  2cc1		       a5 52		      lda	R0
    738  2cc3		       d0 02		      bne	restoresigns3
    739  2cc5		       c6 53		      dec	R0+1
    740  2cc7				   restoresigns3
    741  2cc7		       c6 52		      dec	R0
    742  2cc9		       a5 52		      lda	R0
    743  2ccb		       49 ff		      eor	#$ff
    744  2ccd		       85 52		      sta	R0
    745  2ccf		       a5 53		      lda	R0+1
    746  2cd1		       49 ff		      eor	#$ff
    747  2cd3		       85 53		      sta	R0+1
    748  2cd5							;
    749  2cd5		       a5 54		      lda	R1
    750  2cd7		       d0 02		      bne	restoresigns4
    751  2cd9		       c6 55		      dec	R1+1
    752  2cdb				   restoresigns4
    753  2cdb		       c6 54		      dec	R1
    754  2cdd		       a5 54		      lda	R1
    755  2cdf		       49 ff		      eor	#$ff
    756  2ce1		       85 54		      sta	R1
    757  2ce3		       a5 55		      lda	R1+1
    758  2ce5		       49 ff		      eor	#$ff
    759  2ce7		       85 55		      sta	R1+1
    760  2ce9							;
    761  2ce9				   restoresigns2
    762  2ce9		       60		      rts
    763  2cea							;
    764  2cea							;=====================================================
    765  2cea							; Skip over spaces.  Returns Y with the offset to
    766  2cea							; either the last character in the line, or the first
    767  2cea							; non-space character.
    768  2cea							;
    769  2cea
    770  2cea		       c8	   skipsp2    iny
    771  2ceb		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  2ced		       f0 04		      beq	Skip3	;end of line
    773  2cef		       c9 20		      cmp	#SPACE
    774  2cf1		       f0 f7		      beq	skipsp2
    775  2cf3		       60	   Skip3      rts
    776  2cf4							;*********************************************************
    777  2cf4							; Output a CR/LF combination to the console.  Preserves
    778  2cf4							; all registers.
    779  2cf4							;
    780  2cf4		       48	   tbcrlf     pha
    781  2cf5		       a9 0d		      lda	#CR
    782  2cf7		       20 e3 19 	      jsr	VOUTCH
    783  2cfa		       a9 0a		      lda	#LF
    784  2cfc		       20 e3 19 	      jsr	VOUTCH
    785  2cff		       68		      pla
    786  2d00		       60		      rts
    787  2d01							;
    788  2d01							;=====================================================
    789  2d01							; Some logic to print the Line of basic code being executed
    790  2d01		       24 40	   idbgBasic  bit	ILTrace
    791  2d03		       50 75		      bvc	dbgBasicNone
    792  2d05		       98		      tya
    793  2d06		       48		      pha
    794  2d07		       20 89 2e 	      jsr	SetOutDebug
    795  2d0a
    796  2d0a		       a5 4f		      lda	CURPTR
    797  2d0c		       85 59		      sta	dpl
    798  2d0e		       a5 50		      lda	CURPTR+1
    799  2d10		       85 5a		      sta	dpl+1
    800  2d12
    801  2d12		       20 ca 21 	      jsr	PrintProgramLine
    802  2d15
    803  2d15		       a5 40		      lda	ILTrace
    804  2d17		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  2d19		       f0 5a		      beq	dbgBasicDone
    806  2d1b		       20 a0 2e 	      jsr	SetInDebug
    807  2d1e		       20 32 21 	      jsr	puts
      0  2d21					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  2d21		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  2d5e				   dbgBasicLoop
    810  2d5e		       20 e6 19 	      jsr	VGETCH
    811  2d61		       20 f4 2c 	      jsr	CRLF
    812  2d64		       20 c4 2e 	      jsr	SetInDebugEnd
    813  2d67
    814  2d67		       c9 73		      cmp	#'s	; Quit program
    815  2d69		       f0 12		      beq	dbgBasicStop
    816  2d6b
    817  2d6b		       c9 64		      cmp	#'d	; Display Variables
    818  2d6d		       d0 06		      bne	dbgBasicDone
    819  2d6f
    820  2d6f		       20 8d 21 	      jsr	PrintAllVars
    821  2d72		       18		      clc
    822  2d73		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  2d75
    824  2d75		       20 b7 2e    dbgBasicDone jsr	SetOutDebugEnd
    825  2d78		       68		      pla
    826  2d79		       a8		      tay
    827  2d7a		       4c b1 02    dbgBasicNone jmp	NextIL
    828  2d7d
    829  2d7d				   dbgBasicStop
    830  2d7d		       20 b7 2e 	      jsr	SetOutDebugEnd
    831  2d80		       68		      pla
    832  2d81		       a8		      tay
    833  2d82		       4c 02 06 	      jmp	iFIN
    834  2d85							;
    835  2d85							;=====================================================
    836  2d85							; This is some debug logic which displays the current
    837  2d85							; value of the ILPC and the line buffer.
    838  2d85							;
    839  2d85		       24 40	   dbgLine    bit	ILTrace
    840  2d87		       30 01		      bmi	dbgPrt
    841  2d89		       60		      rts
    842  2d8a				   dbgPrt
    843  2d8a		       20 89 2e 	      jsr	SetOutDebug
    844  2d8d		       20 32 21 	      jsr	puts
      0  2d90					      db	"ILPC:",0
      1  2d90		       49 4c 50 43*	      .byte.b	"ILPC:",0
    846  2d96		       a5 44		      lda	ILPC+1
    847  2d98		       20 15 21 	      jsr	OUTHEX
    848  2d9b		       a5 43		      lda	ILPC
    849  2d9d		       20 15 21 	      jsr	OUTHEX
    850  2da0		       a9 20		      lda	#SPACE
    851  2da2		       20 e3 19 	      jsr	VOUTCH
    852  2da5
    853  2da5		       a0 00		      ldy	#0
    854  2da7		       b1 43		      lda	(ILPC),y	;Get the il pcode value
    855  2da9					      if	IL_DEBUG_TEXT
    856  2da9		       20 f4 18 	      jsr	PrintILText
    857  2dac				  -	      else
    858  2dac				  -	      jsr	OUTHEX
    859  2dac					      endif
    860  2dac		       20 32 21 	      jsr	puts
      0  2daf					      db	" ILSP:",0
      1  2daf		       20 49 4c 53*	      .byte.b	" ILSP:",0
    862  2db6		       a5 47		      lda	ILSTACKPTR
    863  2db8		       20 15 21 	      jsr	OUTHEX
    864  2dbb		       a9 20		      lda	#SPACE
    865  2dbd		       20 e3 19 	      jsr	VOUTCH
    866  2dc0
    867  2dc0							; Display the CURPTR value and offset
    868  2dc0							;
    869  2dc0		       20 32 21 	      jsr	puts
      0  2dc3					      db	", CURPTR: ",0
      1  2dc3		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    871  2dce		       a5 50		      lda	CURPTR+1
    872  2dd0		       20 15 21 	      jsr	OUTHEX
    873  2dd3		       a5 4f		      lda	CURPTR
    874  2dd5		       20 15 21 	      jsr	OUTHEX
    875  2dd8		       a9 2b		      lda	#'+
    876  2dda		       20 e3 19 	      jsr	VOUTCH
    877  2ddd		       a5 51		      lda	CUROFF
    878  2ddf		       20 15 21 	      jsr	OUTHEX
    879  2de2							;
    880  2de2		       20 f4 2c 	      jsr	CRLF
    881  2de5		       20 b7 2e 	      jsr	SetOutDebugEnd
    882  2de8		       20 1b 2e 	      jsr	ILChkRange
    883  2deb		       b0 02		      bcs	dbgLineErr
    884  2ded		       18		      clc
    885  2dee		       60		      rts
    886  2def
    887  2def				   dbgLineErr
    888  2def		       20 89 2e 	      jsr	SetOutDebug
    889  2df2		       20 32 21 	      jsr	puts
      0  2df5					      db	"Outside Valid IL Address Range",CR,LF,0
      1  2df5		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    891  2e16		       20 b7 2e 	      jsr	SetOutDebugEnd
    892  2e19		       38		      sec
    893  2e1a		       60		      rts
    894  2e1b
    895  2e1b		       a5 44	   ILChkRange lda	ILPC+1
    896  2e1d		       c9 31		      cmp	#IL>>8
    897  2e1f		       90 18		      bcc	ILBadRange
    898  2e21		       d0 06		      bne	ILChkHigh
    899  2e23
    900  2e23		       a5 43		      lda	ILPC
    901  2e25		       c9 70		      cmp	#IL&$ff
    902  2e27		       90 10		      bcc	ILBadRange
    903  2e29
    904  2e29		       a5 44	   ILChkHigh  lda	ILPC+1
    905  2e2b		       c9 35		      cmp	#ILEND>>8
    906  2e2d		       90 08		      bcc	ILGoodRange
    907  2e2f		       d0 08		      bne	ILBadRange
    908  2e31
    909  2e31		       a5 43		      lda	ILPC
    910  2e33		       c9 bb		      cmp	#ILEND&$ff
    911  2e35		       b0 02		      bcs	ILBadRange
    912  2e37
    913  2e37		       18	   ILGoodRange clc
    914  2e38		       60		      rts
    915  2e39				   ILBadRange
    916  2e39		       38		      sec
    917  2e3a		       60		      rts
    918  2e3b
    919  2e3b
    920  2e3b							;=====================================================
    921  2e3b							; Set output vector to the console output function
    922  2e3b							;
    923  2e3b				   SetOutConsole
    924  2e3b		       48		      pha
    925  2e3c		       a9 0c		      lda	#OUTCH&$ff
    926  2e3e		       8d c0 35 	      sta	BOutVec
    927  2e41		       a9 f0		      lda	#OUTCH>>8
    928  2e43		       8d c1 35 	      sta	BOutVec+1
    929  2e46		       68		      pla
    930  2e47		       60		      rts
    931  2e48
    932  2e48				   SetInConsole
    933  2e48		       48		      pha
    934  2e49		       a9 09		      lda	#GETCH&$ff
    935  2e4b		       8d be 35 	      sta	BInVec
    936  2e4e		       a9 f0		      lda	#GETCH>>8
    937  2e50		       8d bf 35 	      sta	BInVec+1
    938  2e53		       68		      pla
    939  2e54		       60		      rts
    940  2e55
    941  2e55
    942  2e55
    943  2e55							;====================================================
    944  2e55							;Clear the terminal assume it is ansii or vt100
    945  2e55							;
    946  2e55				   iCLEARSCREEN
    947  2e55		       20 32 21 	      jsr	puts
      0  2e58					      db	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,0
      1  2e58		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,0
    949  2e63		       4c b1 02 	      jmp	NextIL
    950  2e66
    951  2e66							;====================================================
    952  2e66							; Push true and false onto math stack
    953  2e66				   pushTrue
    954  2e66		       a9 ff		      lda	#$ff
    955  2e68		       85 52	   pushTF     sta	R0
    956  2e6a		       85 53		      sta	R0+1
    957  2e6c		       20 a9 2b 	      jsr	pushR0
    958  2e6f		       60		      rts
    959  2e70		       a9 00	   pushFalse  lda	#0
    960  2e72		       f0 f4		      beq	pushTF
    961  2e74
    962  2e74							;======================================================
    963  2e74							; Copy stack top to R1
    964  2e74				   CopyStackR1
    965  2e74		       98		      tya
    966  2e75		       48		      pha
    967  2e76		       a4 4a		      ldy	MATHSTACKPTR
    968  2e78		       88		      dey
    969  2e79		       b1 48		      lda	(MATHSTACK),y
    970  2e7b		       85 55		      sta	R1+1
    971  2e7d		       88		      dey
    972  2e7e		       b1 48		      lda	(MATHSTACK),y
    973  2e80		       85 54		      sta	R1
    974  2e82		       68		      pla
    975  2e83		       a8		      tay
    976  2e84		       60		      rts
    977  2e85
    978  2e85
    979  2e85							;====================================================
    980  2e85							;Swap the out debug call for standard calls
    981  2e85		       00 00	   DebugIOSave ds	2
    982  2e87		       00 00	   DebugInSave ds	2
    983  2e89				   SetOutDebug
    984  2e89		       ad c0 35 	      lda	BOutVec
    985  2e8c		       8d 85 2e 	      sta	DebugIOSave
    986  2e8f		       ad c1 35 	      lda	BOutVec+1
    987  2e92		       8d 86 2e 	      sta	DebugIOSave+1
    988  2e95		       a9 1d		      lda	#OUTDEBUG&$ff	; Put the Debug output
    989  2e97		       8d c0 35 	      sta	BOutVec
    990  2e9a		       a9 2f		      lda	#OUTDEBUG>>8
    991  2e9c		       8d c1 35 	      sta	BOutVec+1
    992  2e9f		       60		      rts
    993  2ea0				   SetInDebug
    994  2ea0		       ad be 35 	      lda	BInVec
    995  2ea3		       8d 87 2e 	      sta	DebugInSave
    996  2ea6		       ad bf 35 	      lda	BInVec+1
    997  2ea9		       8d 88 2e 	      sta	DebugInSave+1
    998  2eac		       a9 21		      lda	#INDEBUG&$ff
    999  2eae		       8d be 35 	      sta	BInVec
   1000  2eb1		       a9 2f		      lda	#INDEBUG>>8
   1001  2eb3		       8d bf 35 	      sta	BInVec+1
   1002  2eb6		       60		      rts
   1003  2eb7				   SetOutDebugEnd
   1004  2eb7		       ad 85 2e 	      lda	DebugIOSave
   1005  2eba		       8d c0 35 	      sta	BOutVec
   1006  2ebd		       ad 86 2e 	      lda	DebugIOSave+1
   1007  2ec0		       8d c1 35 	      sta	BOutVec+1
   1008  2ec3		       60		      rts
   1009  2ec4				   SetInDebugEnd
   1010  2ec4		       ad 87 2e 	      lda	DebugInSave
   1011  2ec7		       8d be 35 	      sta	BInVec
   1012  2eca		       ad 88 2e 	      lda	DebugInSave+1
   1013  2ecd		       8d bf 35 	      sta	BInVec+1
   1014  2ed0		       60		      rts
   1015  2ed1							;
   1016  2ed1							;====================================================
   1017  2ed1							; Set the input and output terminal address
   1018  2ed1							; The math stack stack byte is the output io slot
   1019  2ed1							; The math stack  is the input io slot
   1020  2ed1
   1021  2ed1				   iSetTerminal
   1022  2ed1		       20 3b 2c 	      jsr	popR0	; Process the output io addresses
   1023  2ed4		       20 fe 2e 	      jsr	CalcSlot
   1024  2ed7		       a5 52		      lda	R0
   1025  2ed9		       09 01		      ora	#1
   1026  2edb		       8d 1e 2f 	      sta	TerminalOutputPort
   1027  2ede		       a5 53		      lda	R0+1
   1028  2ee0		       8d 1f 2f 	      sta	TerminalOutputPort+1
   1029  2ee3
   1030  2ee3		       20 3b 2c 	      jsr	popR0	; Process the input io address
   1031  2ee6		       20 fe 2e 	      jsr	CalcSlot
   1032  2ee9		       a5 52		      lda	R0
   1033  2eeb		       8d 22 2f 	      sta	TerminalStatusPort
   1034  2eee		       09 01		      ora	#1
   1035  2ef0		       8d 29 2f 	      sta	TerminalInputPort
   1036  2ef3		       a5 53		      lda	R0+1
   1037  2ef5		       8d 2a 2f 	      sta	TerminalInputPort+1
   1038  2ef8		       8d 23 2f 	      sta	TerminalStatusPort+1
   1039  2efb		       4c b1 02 	      jmp	NextIL
   1040  2efe
   1041  2efe							;===================================================
   1042  2efe							; Calculate the slot address the the slot number
   1043  2efe							; R0 contains the slot number 0-255
   1044  2efe
   1045  2efe				   CalcSlot
   1046  2efe		       8a		      txa
   1047  2eff		       48		      pha
   1048  2f00
   1049  2f00		       a2 04		      ldx	#4
   1050  2f02				   CalcSlotLoop
   1051  2f02		       18		      clc
   1052  2f03		       26 52		      rol	R0
   1053  2f05		       26 53		      rol	R0+1
   1054  2f07		       ca		      dex
   1055  2f08		       d0 f8		      bne	CalcSlotLoop
   1056  2f0a
   1057  2f0a		       a9 e0		      lda	#$E0
   1058  2f0c		       05 53		      ora	R0+1
   1059  2f0e		       85 53		      sta	R0+1
   1060  2f10		       68		      pla
   1061  2f11
   1062  2f11		       aa		      tax
   1063  2f12		       60		      rts
   1064  2f13							;
   1065  2f13							;====================================================
   1066  2f13							; Output to the Terminal/Debug console
   1067  2f13							;     x = high address byte
   1068  2f13							;     y = low address byte
   1069  2f13							;     a = Terminator for string
   1070  2f13				   TerminalWrite
   1071  2f13				   DebugWrite
   1072  2f13		       20 89 2e 	      jsr	SetOutDebug
   1073  2f16		       20 70 21 	      jsr	PrtStr
   1074  2f19		       20 b7 2e 	      jsr	SetOutDebugEnd
   1075  2f1c		       60		      rts
   1076  2f1d
   1077  2f1d				   TerminalIOblock
   1078  2f1d				   OUTDEBUG
   1079  2f1d		       8d		      .byte.b	$8D	; STA
   1080  2f1e				   TerminalOutputPort
   1081  2f1e		       21 e0	   DEBUGPORT  .word.w	$E021	; Dont check anything just output the byte
   1082  2f20		       60		      RTS
   1083  2f21
   1084  2f21				   TerminalRead
   1085  2f21				   INDEBUG
   1086  2f21		       ad		      .byte.b	$AD	; LDA
   1087  2f22				   TerminalStatusPort
   1088  2f22		       20 e0	   DEBUGPORTSTATUS .word.w	$E020
   1089  2f24
   1090  2f24		       29 01		      and	#$01
   1091  2f26		       f0 f9		      beq	INDEBUG
   1092  2f28
   1093  2f28		       ad		      .byte.b	$AD	; LDA
   1094  2f29				   TerminalInputPort
   1095  2f29		       21 e0	   DEBUGPORTIN .word.w	$E021
   1096  2f2b		       60		      rts
   1097  2f2c				   TerminalIOblockEnd
   1098  2f2c							;======================================================================
   1099  2f2c							;Copy Quoted string to buffer, terminate with 0 byte
   1100  2f2c							; R0  Source tring points to tString type
   1101  2f2c							; x is terminator
   1102  2f2c							; R1 points to destinition location
   1103  2f2c							; On exit R0 contains length of copy Plus Term and leading bytes
   1104  2f2c
   1105  2f2c				   qstrcpy
   1106  2f2c		       20 a9 2b 	      jsr	pushR0
   1107  2f2f		       20 7c 2f 	      jsr	IncR0	; point past the tString
   1108  2f32		       20 7c 2f 	      jsr	IncR0	; Point Past the opening "
   1109  2f35		       a2 22		      ldx	#'"	; copy Termination
   1110  2f37		       20 51 2f 	      jsr	pstrcpy
   1111  2f3a		       20 7c 2f 	      jsr	IncR0	; point to "
   1112  2f3d		       20 7c 2f 	      jsr	IncR0	; Point to next free byte
   1113  2f40		       20 53 2c 	      jsr	popR1
   1114  2f43		       38		      sec
   1115  2f44		       a5 52		      lda	R0
   1116  2f46		       e5 54		      sbc	R1
   1117  2f48		       85 52		      sta	R0
   1118  2f4a		       a5 53		      lda	R0+1
   1119  2f4c		       e5 55		      sbc	R1+1
   1120  2f4e		       85 53		      sta	R0+1
   1121  2f50		       60		      rts
   1122  2f51
   1123  2f51							;=========================================================================
   1124  2f51							;Copy string from R0 to R1, terminator in x
   1125  2f51							; On exit    R0 contains the length of the copy
   1126  2f51				   pstrcpy
   1127  2f51		       a0 00		      ldy	#0
   1128  2f53		       86 58		      stx	R2
   1129  2f55
   1130  2f55				   strcpyLoop
   1131  2f55		       b1 52		      lda	(R0),y
   1132  2f57		       c5 58		      cmp	R2
   1133  2f59		       f0 0a		      beq	strcpyDone
   1134  2f5b		       91 54		      sta	(R1),y
   1135  2f5d		       20 7c 2f 	      jsr	IncR0
   1136  2f60		       20 6a 2f 	      jsr	IncR1
   1137  2f63		       90 f0		      bcc	strcpyLoop
   1138  2f65				   strcpyDone
   1139  2f65		       a9 00		      lda	#0
   1140  2f67		       91 54		      sta	(R1),y
   1141  2f69
   1142  2f69		       60		      rts
   1143  2f6a
   1144  2f6a							;=========================================================================
   1145  2f6a							; on exit c is set on overflow
   1146  2f6a				   IncR1
   1147  2f6a		       48		      pha
   1148  2f6b		       18		      clc
   1149  2f6c		       a9 01		      lda	#1
   1150  2f6e		       65 54		      adc	R1
   1151  2f70		       85 54		      sta	R1
   1152  2f72		       90 06		      bcc	IncR1Done
   1153  2f74		       a9 00		      lda	#0
   1154  2f76		       65 55		      adc	R1+1
   1155  2f78		       85 55		      sta	R1+1
   1156  2f7a				   IncR1Done
   1157  2f7a		       68		      pla
   1158  2f7b		       60		      rts
   1159  2f7c							;=========================================================================
   1160  2f7c							; on exit c is set on overflow
   1161  2f7c				   IncR0
   1162  2f7c		       48		      pha
   1163  2f7d		       18		      clc
   1164  2f7e		       a9 01		      lda	#1
   1165  2f80		       65 52		      adc	R0
   1166  2f82		       85 52		      sta	R0
   1167  2f84		       90 06		      bcc	IncR0Done
   1168  2f86		       a9 00		      lda	#0
   1169  2f88		       65 53		      adc	R0+1
   1170  2f8a		       85 53		      sta	R0+1
   1171  2f8c				   IncR0Done
   1172  2f8c		       68		      pla
   1173  2f8d		       60		      rts
   1174  2f8e
   1175  2f8e
   1176  2f8e
   1177  2f8e
   1178  2f8e
   1179  2f8e
   1180  2f8e
   1181  2f8e
   1182  2f8e
   1183  2f8e
   1184  2f8e
   1185  2f8e
   1186  2f8e
   1187  2f8e
   1188  2f8e
   1189  2f8e
------- FILE mytb.asm
   2480  2f8e
   2481  2f8e					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  2f8e					      include	"storage.asm"
      1  2f8e							;
      2  2f8e							;=====================================================
      3  2f8e							;=====================================================
      4  2f8e							;=====================================================
      5  2f8e							; This file contains the functions for saving and
      6  2f8e							; restoring programs from some sort of mass storage
      7  2f8e							; device.  This particular version is for using the
      8  2f8e							; Corsham Tech SD Card System.
      9  2f8e							;=====================================================
     10  2f8e							;=====================================================
     11  2f8e							;=====================================================
     12  2f8e
     13 U35cc					      seg.u	TBData
     14 U35cc		       00	   diskBufLength ds	1
     15 U35cd		       00	   diskBufOffset ds	1
     16 U35ce		       00 00 00 00*DiskFileName ds	64
     17 U360e
     18  2f8e					      SEG	Code
     19  2f8e
     20  2f8e							;
     21  2f8e							;=====================================================
     22  2f8e							; Open a file for reading as a program.  The next
     23  2f8e							; thing on the line should be the filename.
     24  2f8e							;
     25  2f8e				   iOPENREAD
     26  2f8e					      if	XKIM || CTMON65
     27  2f8e		       20 a8 2f 	      jsr	setFileName	;Set the file name to open
     28  2f91		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  2f94		       90 07		      bcc	Ropenok	;branch if opened ok
     30  2f96							;
     31  2f96							; Open failed
     32  2f96							;
     33  2f96		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  2f98		       a9 00	   Rdfail2    lda	#0
     35  2f9a		       4c 7d 06 	      jmp	iErr2
     36  2f9d							;
     37  2f9d							; Clear counts and offsets so the next read will
     38  2f9d							; cause the file to be read.
     39  2f9d							;
     40  2f9d		       a9 00	   Ropenok    lda	#0
     41  2f9f		       8d cd 35 	      sta	diskBufOffset
     42  2fa2		       8d cc 35 	      sta	diskBufLength
     43  2fa5		       4c b1 02 	      jmp	NextIL
     44  2fa8					      endif
     45  2fa8
     46  2fa8							;===============================================================
     47  2fa8							; Set file name
     48  2fa8				   setFileName
     49  2fa8		       a4 51		      ldy	CUROFF
     50  2faa		       b1 4f		      lda	(CURPTR),y
     51  2fac		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  2fae		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  2fb0
     54  2fb0		       18		      clc
     55  2fb1		       98		      tya
     56  2fb2		       65 4f		      adc	CURPTR
     57  2fb4		       85 52		      sta	R0	;LSB
     58  2fb6		       a5 50		      lda	CURPTR+1
     59  2fb8		       69 00		      adc	#0
     60  2fba		       85 53		      sta	R0+1
     61  2fbc		       a9 ce		      lda	#DiskFileName&$ff
     62  2fbe		       85 54		      sta	R1
     63  2fc0		       a9 35		      lda	#DiskFileName>>8
     64  2fc2		       85 55		      sta	R1+1
     65  2fc4		       20 2c 2f 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  2fc7		       a5 52		      lda	R0
     67  2fc9		       18		      clc
     68  2fca		       65 51		      adc	CUROFF	; add the current offset
     69  2fcc		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  2fce				   ResetFileName
     71  2fce		       a0 ce		      ldy	#DiskFileName&$ff
     72  2fd0		       a2 35		      ldx	#DiskFileName>>8
     73  2fd2		       18		      clc
     74  2fd3		       60		      rts
     75  2fd4
     76  2fd4				   setFileNameNotFound
     77  2fd4		       68		      pla
     78  2fd5		       68		      pla		; remove the return address from the stack
     79  2fd6		       a9 00		      lda	#0
     80  2fd8		       a2 09		      ldx	#ERR_NO_FILENAME
     81  2fda		       4c 7d 06 	      jmp	iErr2
     82  2fdd
     83  2fdd							;
     84  2fdd							;==============================JUSTLOSTINTIME 08/02/2022========
     85  2fdd							;Remove a file from the disk
     86  2fdd				   iRMFILE
     87  2fdd					      if	XKIM || CTMON65
     88  2fdd		       20 a8 2f 	      jsr	setFileName
     89  2fe0		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  2fe3		       90 07		      bcc	wrmOk	;branch if removed ok
     91  2fe5		       a9 00		      lda	#0
     92  2fe7		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  2fe9		       4c 7d 06 	      jmp	iErr2
     94  2fec				   wrmOk
     95  2fec		       4c b1 02 	      jmp	NextIL
     96  2fef
     97  2fef					      endif
     98  2fef							;
     99  2fef							;=====================================================
    100  2fef				   iOPENWRITE
    101  2fef					      if	XKIM || CTMON65
    102  2fef		       20 a8 2f 	      jsr	setFileName
    103  2ff2		       20 b0 29 	      jsr	getILByte	;get the append or create byte
    104  2ff5		       c9 01		      cmp	#1	;create/truncate
    105  2ff7		       d0 06		      bne	iopencont
    106  2ff9		       20 ce 2f 	      jsr	ResetFileName	;point back to the file name
    107  2ffc		       20 45 f0 	      jsr	DiskRmFile	;by default files opened for write are append
    108  2fff
    109  2fff				   iopencont
    110  2fff		       20 ce 2f 	      jsr	ResetFileName	;point back to the file name
    111  3002		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    112  3005		       90 07		      bcc	Wopenok	;branch if opened ok
    113  3007							;
    114  3007							; Open failed
    115  3007							;
    116  3007		       a9 00	   Wdfail     lda	#0
    117  3009		       a2 08		      ldx	#ERR_WRITE_FAIL
    118  300b		       4c 7d 06 	      jmp	iErr2
    119  300e							;
    120  300e		       4c b1 02    Wopenok    jmp	NextIL
    121  3011					      endif
    122  3011							;
    123  3011							;=====================================================
    124  3011							; Gets a line of input from the disk file and puts it
    125  3011							; into LINBUF.
    126  3011							;
    127  3011							; On exit:
    128  3011							;    CURPTR points to LINBUF
    129  3011							;    LINBUF contains the line with 0 at the end.
    130  3011							;    Y has offset to first non-space character
    131  3011							;    CURROFF has the same as Y.
    132  3011							;
    133  3011				   iDGETLINE
    134  3011					      if	XKIM || CTMON65
    135  3011		       a2 ea		      ldx	#LINBUF&$ff
    136  3013		       86 4f		      stx	CURPTR
    137  3015		       a2 41		      ldx	#LINBUF>>8
    138  3017		       86 50		      stx	CURPTR+1
    139  3019							;
    140  3019		       a2 00		      ldx	#0	;offset
    141  301b		       8e 6e 42    iDgetLoop  stx	getlinx
    142  301e		       20 89 30 	      jsr	getNextFileByte
    143  3021		       b0 16		      bcs	iGetEOF
    144  3023		       c9 0d		      cmp	#CR
    145  3025		       f0 0d		      beq	iGetEOL
    146  3027		       c9 0a		      cmp	#LF
    147  3029		       f0 09		      beq	iGetEOL
    148  302b		       ae 6e 42 	      ldx	getlinx
    149  302e		       9d ea 41 	      sta	LINBUF,x
    150  3031		       e8		      inx
    151  3032		       d0 e7		      bne	iDgetLoop
    152  3034							;
    153  3034							; Handle end of line.	If the line has nothing, loop
    154  3034							; back and get another line.
    155  3034							;
    156  3034		       ae 6e 42    iGetEOL    ldx	getlinx	;blank line?
    157  3037		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    158  3039							;
    159  3039							; This can fall through when there is a line, or
    160  3039							; called directly when EOF is encountered.
    161  3039							;
    162  3039		       ae 6e 42    iGetEOF    ldx	getlinx
    163  303c		       a9 00		      lda	#0
    164  303e		       9d ea 41 	      sta	LINBUF,x
    165  3041		       a0 00		      ldy	#0
    166  3043		       20 eb 2c 	      jsr	SkipSpaces
    167  3046		       20 d5 1c 	      jsr	ParseInputLine
    168  3049		       a9 d2		      lda	#TOKENBUFFER&$ff
    169  304b		       85 4f		      sta	CURPTR
    170  304d		       a9 1b		      lda	#TOKENBUFFER>>8
    171  304f		       85 50		      sta	CURPTR+1
    172  3051		       a9 01		      lda	#1
    173  3053		       85 51		      sta	CUROFF
    174  3055		       4c b1 02 	      jmp	NextIL
    175  3058					      endif
    176  3058
    177  3058							;
    178  3058							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    179  3058							; DISK
    180  3058							;
    181  3058				   iDDIR
    182  3058					      if	XKIM || CTMON65
    183  3058		       20 30 f0 	      jsr	DiskDir
    184  305b							;
    185  305b							; Get/Display each entry
    186  305b							;
    187  305b		       a2 35	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    188  305d		       a0 ce		      ldy	#DiskFileName&$ff
    189  305f		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    190  3062		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    191  3064		       20 32 21 	      jsr	puts
      0  3067					      db	"   ",0
      1  3067		       20 20 20 00	      .byte.b	"   ",0
    193  306b							; Print the line to the console
    194  306b		       a2 35		      ldx	#DiskFileName>>8	;pointer to buffer
    195  306d		       a0 ce		      ldy	#DiskFileName&$ff
    196  306f		       a5 00		      lda	0
    197  3071		       20 70 21 	      jsr	PrtStr	;else print name
    198  3074		       20 18 f0 	      jsr	crlf
    199  3077
    200  3077		       4c 5b 30 	      jmp	DiskDirLoop	;do next entry
    201  307a
    202  307a		       4c b1 02    DiskDirEnd jmp	NextIL
    203  307d					      endif
    204  307d							;
    205  307d							;=====================================================
    206  307d							; Does a LIST to a Disk file.
    207  307d							;
    208  307d				   iDLIST
    209  307d					      if	XKIM || CTMON65
    210  307d		       20 b8 30 	      jsr	SetOutDisk
    211  3080		       4c 34 08 	      jmp	iLST2
    212  3083					      endif
    213  3083							;
    214  3083							;=====================================================
    215  3083							; Closes any pending disk file.  Okay to call if there
    216  3083							; is no open file.
    217  3083							;
    218  3083				   iDCLOSE
    219  3083					      if	XKIM || CTMON65
    220  3083		       20 42 f0 	      jsr	DiskClose
    221  3086		       4c b1 02 	      jmp	NextIL
    222  3089					      endif
    223  3089							;
    224  3089							;=====================================================
    225  3089							; This gets the next byte from an open disk file.  If
    226  3089							; there are no more bytes left, this returns C set.
    227  3089							; Else, C is clear and A contains the character.
    228  3089							;
    229  3089				   getNextFileByte
    230  3089					      if	XKIM || CTMON65
    231  3089		       ae cd 35 	      ldx	diskBufOffset
    232  308c		       ec cc 35 	      cpx	diskBufLength
    233  308f		       d0 14		      bne	hasdata	;branch if still data
    234  3091							;
    235  3091							; There is no data left in the buffer, so read a
    236  3091							; block from the SD system.
    237  3091							;
    238  3091		       a9 84		      lda	#BUFFER_SIZE
    239  3093		       a2 df		      ldx	#buffer>>8
    240  3095		       a0 0a		      ldy	#buffer&$ff
    241  3097		       20 3c f0 	      jsr	DiskRead
    242  309a		       b0 12		      bcs	getNextEof
    243  309c							;
    244  309c							; A contains the number of bytes actually read.
    245  309c							;
    246  309c		       8d cc 35 	      sta	diskBufLength	;save length
    247  309f		       c9 00		      cmp	#0	;shouldn't happen
    248  30a1		       f0 0b		      beq	getNextEof
    249  30a3							;
    250  30a3		       a2 00		      ldx	#0
    251  30a5		       bd 0a df    hasdata    lda	buffer,x
    252  30a8		       e8		      inx
    253  30a9		       8e cd 35 	      stx	diskBufOffset
    254  30ac		       18		      clc
    255  30ad		       60		      rts
    256  30ae							;
    257  30ae		       a9 00	   getNextEof lda	#0
    258  30b0		       8d cd 35 	      sta	diskBufOffset
    259  30b3		       8d cc 35 	      sta	diskBufLength
    260  30b6		       38		      sec
    261  30b7		       60		      rts
    262  30b8							;
    263  30b8							;=====================================================
    264  30b8							; Set output vector to the disk output function
    265  30b8							;
    266  30b8		       a9 c3	   SetOutDisk lda	#DOUT&$ff
    267  30ba		       8d c0 35 	      sta	BOutVec
    268  30bd		       a9 30		      lda	#DOUT/256
    269  30bf		       8d c1 35 	      sta	BOutVec+1
    270  30c2		       60		      rts
    271  30c3							;
    272  30c3							;=====================================================
    273  30c3							; input a contains charater to write to open file
    274  30c3							; output:
    275  30c3							;	    C flag clear if no error
    276  30c3							;
    277  30c3		       8e ce 35    DOUT       stx	DiskFileName	; Save the x value, fulename not used
    278  30c6		       8c cf 35 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    279  30c9		       8d 0a df 	      sta	buffer	; Store the byte to send into the buffer
    280  30cc		       a9 01		      lda	#1	; set number of bytes to send to 1
    281  30ce		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    282  30d0		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    283  30d2		       20 3f f0 	      jsr	DiskWrite	; Place the character to disk if a file is open
    284  30d5		       ae ce 35 	      ldx	DiskFileName	; Restore the x value that was saved
    285  30d8		       ac cf 35 	      ldy	DiskFileName+1	; Restore the y value saved
    286  30db		       60		      rts
    287  30dc							;=======================================================
    288  30dc							; output:
    289  30dc							;	  c flag is clear if no error, a contains bytes read
    290  30dc							;	  c flag set Reached eof, a undefined
    291  30dc							;
    292  30dc		       8e ce 35    DIN	      stx	DiskFileName	; Save the x value, filename not used just storage
    293  30df		       8c cf 35 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    294  30e2		       a9 01		      lda	#1	; set number of bytes to read to 1
    295  30e4		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    296  30e6		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    297  30e8		       20 3c f0 	      jsr	DiskRead
    298  30eb		       ad 0a df 	      lda	buffer	; Get the byte just read
    299  30ee		       ae ce 35 	      ldx	DiskFileName
    300  30f1		       ac cf 35 	      ldy	DiskFileName+1
    301  30f4		       60		      rts
    302  30f5
    303  30f5							;========================================================
    304  30f5							; Dstat / open/close/stat files
    305  30f5				   DSTAT
    306  30f5		       60		      rts
    307  30f6							;========================================================
    308  30f6					      endif
------- FILE mytb.asm
   2483  30f6					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  30f6					      include	"IL.inc"
      1  30f6
      2  30f6							;=====================================================
      3  30f6							; IL.inc
      4  30f6							; These are macros for IL instructions
      5  30f6							;
      6  30f6					      mac	dw
      7  30f6					      .word	{0}
      8  30f6					      endm
      9  30f6					      mac	db
     10  30f6					      .byte	{0}
     11  30f6					      endm
     12  30f6					      macro	xinit
     13  30f6					      db	0
     14  30f6					      endm		;reset the il to start clear all
     15  30f6							;
     16  30f6					      macro	done
     17  30f6					      db	1
     18  30f6					      endm		;print an error if not end of line
     19  30f6							;
     20  30f6					      macro	prs
     21  30f6					      db	2
     22  30f6					      endm		;print a quoted string
     23  30f6							;
     24  30f6					      macro	prn
     25  30f6					      db	3
     26  30f6					      endm		;print a number
     27  30f6							;
     28  30f6					      macro	spc
     29  30f6					      db	4
     30  30f6					      endm		;print space til new tabstop
     31  30f6							;
     32  30f6					      macro	nline
     33  30f6					      db	5
     34  30f6					      endm		;print a new line crlf
     35  30f6							;
     36  30f6							; My NXT is a bit different in that it takes one
     37  30f6							; parameter, which is an address.  If the BASIC
     38  30f6							; program is currently running then move to the
     39  30f6							; next line and continue execution.  However, if
     40  30f6							; in direct mode, jump to the specified IL label.
     41  30f6							;
     42  30f6					      macro	nxt
     43  30f6					      db	6
     44  30f6					      dw	{1}	; addr
     45  30f6					      endm		; addr
     46  30f6							;
     47  30f6					      macro	xfer
     48  30f6					      db	7
     49  30f6					      endm
     50  30f6							;
     51  30f6					      macro	sav
     52  30f6					      db	8
     53  30f6					      db	{1}
     54  30f6					      endm
     55  30f6							;
     56  30f6							;  Passed jump if function called, and true false value returned
     57  30f6					      macro	rstr
     58  30f6					      db	9
     59  30f6					      db	({1}-*)-1	;(addr-*)-1
     60  30f6					      db	{2}
     61  30f6					      endm
     62  30f6							;
     63  30f6					      macro	cmpr
     64  30f6					      db	10
     65  30f6					      endm
     66  30f6							;
     67  30f6					      macro	innum
     68  30f6					      db	11
     69  30f6					      endm
     70  30f6							;
     71  30f6					      macro	fin
     72  30f6					      db	12
     73  30f6					      endm
     74  30f6							;
     75  30f6							; ERR is followed by an error number.	The error
     76  30f6							; code is printed along with the line number.
     77  30f6							; Control is passed to the statement set with
     78  30f6							; the ERRGOTO statement.
     79  30f6							;
     80  30f6					      macro	errmsg
     81  30f6					      db	13
     82  30f6					      dw	{1}	;ecode
     83  30f6					      endm		;ecode
     84  30f6							;
     85  30f6					      macro	add
     86  30f6					      db	14
     87  30f6					      endm
     88  30f6							;
     89  30f6					      macro	sub
     90  30f6					      db	15
     91  30f6					      endm
     92  30f6							;
     93  30f6					      macro	neg
     94  30f6					      db	16
     95  30f6					      endm
     96  30f6							;
     97  30f6					      macro	mul
     98  30f6					      db	17
     99  30f6					      endm
    100  30f6							;
    101  30f6					      macro	div
    102  30f6					      db	18
    103  30f6					      endm
    104  30f6							;
    105  30f6					      macro	store
    106  30f6					      db	19
    107  30f6					      endm
    108  30f6							;
    109  30f6					      macro	ind
    110  30f6					      db	20
    111  30f6					      endm
    112  30f6							;
    113  30f6					      macro	lst
    114  30f6					      db	21
    115  30f6					      endm
    116  30f6							;
    117  30f6					      macro	init
    118  30f6					      db	22
    119  30f6					      endm
    120  30f6							;
    121  30f6					      macro	getline
    122  30f6					      db	23
    123  30f6					      endm
    124  30f6							;
    125  30f6					      macro	insert
    126  30f6					      db	24
    127  30f6					      endm
    128  30f6							;
    129  30f6					      macro	rtn
    130  30f6					      db	25
    131  30f6					      endm
    132  30f6							;
    133  30f6					      macro	exit
    134  30f6					      db	26
    135  30f6					      endm
    136  30f6							;
    137  30f6					      macro	lit
    138  30f6					      db	27
    139  30f6					      dw	{1}	;value
    140  30f6					      endm		; value LIT
    141  30f6							;
    142  30f6					      macro	call
    143  30f6					      db	28
    144  30f6					      dw	{1}	;addr
    145  30f6					      endm		;addr
    146  30f6							;
    147  30f6							; IJMP will set the IL PC to the specified value.
    148  30f6							;
    149  30f6					      macro	ijmp
    150  30f6					      db	29
    151  30f6					      dw	{1}	;addr
    152  30f6					      endm		;addr
    153  30f6							;
    154  30f6					      macro	vinit
    155  30f6					      db	30
    156  30f6					      endm
    157  30f6							;
    158  30f6							; ERRGOTO sets the point in the code where the IL
    159  30f6							; interpreter will go after any error.
    160  30f6							;
    161  30f6					      macro	errgoto
    162  30f6					      db	31
    163  30f6					      dw	{1}	;addr
    164  30f6					      endm		;addr
    165  30f6							;
    166  30f6					      macro	tst
    167  30f6					      db	32
    168  30f6					      db	({1}-*)-1	;(addr-*)-1
    169  30f6					      db	{2},0	;string,0
    170  30f6					      endm		;addr,string
    171  30f6							;
    172  30f6					      macro	tstv
    173  30f6					      db	33
    174  30f6					      db	({1}-*)-1	;(addr-*)-1
    175  30f6					      endm		;addr
    176  30f6							;
    177  30f6					      macro	tstl
    178  30f6					      db	34
    179  30f6					      db	({1}-*)-1	;(addr-*)-1
    180  30f6					      endm		;addr
    181  30f6							;
    182  30f6					      macro	tstn
    183  30f6					      db	35
    184  30f6					      db	({1}-*)-1	;(addr-*)-1
    185  30f6					      endm		;addr
    186  30f6							;
    187  30f6							; FREE returns the amount of free RAM on top of
    188  30f6							; the stack.  This is the amount of room the user
    189  30f6							; program has available.
    190  30f6							;
    191  30f6					      macro	free
    192  30f6					      db	36
    193  30f6					      endm
    194  30f6							;
    195  30f6							; RANDOM takes the top item off the stack and
    196  30f6							; replaces it with a random number that is
    197  30f6							; MOD the initial value.  Ie, if the TOS is
    198  30f6							; 42 then RANDOM returns a value from 0 to 41.
    199  30f6							;
    200  30f6					      macro	random
    201  30f6					      db	37
    202  30f6					      endm
    203  30f6							;
    204  30f6							; ABS will replace the top of stack with the
    205  30f6							; absolute value.
    206  30f6							;
    207  30f6					      macro	abs
    208  30f6					      db	38
    209  30f6					      endm
    210  30f6							;
    211  30f6							; OPENREAD opens a file for reading, as in getting
    212  30f6							; statements from it.
    213  30f6							;
    214  30f6					      macro	openread
    215  30f6					      db	39
    216  30f6					      endm
    217  30f6							;
    218  30f6							; OPENWRITE opens a file for writing, as in saving
    219  30f6							; the current program to it.
    220  30f6							;
    221  30f6					      macro	openwrite
    222  30f6					      db	40
    223  30f6					      db	{1}	; 0= append 1 = create/truncate
    224  30f6					      endm
    225  30f6							;
    226  30f6							; DCLOSE closes any open disk file.
    227  30f6							;
    228  30f6					      macro	dclose
    229  30f6					      db	41
    230  30f6					      endm
    231  30f6							;
    232  30f6							; DGETLINE gets one line from the disk file and puts it
    233  30f6							; into LINBUFF.
    234  30f6							;
    235  30f6					      macro	dgetline
    236  30f6					      db	42
    237  30f6					      endm
    238  30f6							;
    239  30f6							; DLIST saves the program to an open disk file.
    240  30f6							;
    241  30f6					      macro	dlist
    242  30f6					      db	43
    243  30f6					      endm
    244  30f6							; DDIR list the current directory
    245  30f6							;
    246  30f6					      macro	ddir
    247  30f6					      db	44
    248  30f6					      endm
    249  30f6
    250  30f6							; RMFILE remove a fle from disk
    251  30f6					      macro	rmfile
    252  30f6					      db	45
    253  30f6					      endm
    254  30f6
    255  30f6							; CLEARSCREEN clear the screen
    256  30f6					      macro	clearscreen
    257  30f6					      db	46
    258  30f6					      endm
    259  30f6							; POKEMEM Poke value into memory
    260  30f6					      macro	pokemem
    261  30f6					      db	47
    262  30f6					      endm
    263  30f6							; PEEKMEM peek at value in memory
    264  30f6					      macro	peekmem
    265  30f6					      db	48
    266  30f6					      endm
    267  30f6							; TSTLET Test if the statement is a let without the keyword let
    268  30f6					      macro	tstlet
    269  30f6					      db	49
    270  30f6					      db	({1}-*)-1	;(addr-*)-1
    271  30f6					      endm		;addr
    272  30f6							; TSTDONE if we reach the end of a statement
    273  30f6					      macro	tstdone
    274  30f6					      db	50
    275  30f6					      db	({1}-*)-1	;(addr-*)-1
    276  30f6					      endm		;addr
    277  30f6							; GETCHAR	get a character from the input line leave it in RO
    278  30f6					      macro	getchar
    279  30f6					      db	51
    280  30f6					      endm
    281  30f6							; PUTCHAR	Put a character to the terminal
    282  30f6					      macro	putchar
    283  30f6					      db	52
    284  30f6					      endm
    285  30f6							; Call		Call a machine function return a to stack
    286  30f6					      macro	callfunc
    287  30f6					      db	53
    288  30f6					      endm
    289  30f6
    290  30f6							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    291  30f6					      macro	ibranch
    292  30f6					      db	54
    293  30f6					      endm
    294  30f6
    295  30f6							; TSTSTR	 Tests for the open quote in a string
    296  30f6					      macro	tststr
    297  30f6					      db	55
    298  30f6					      db	({1}-*)-1	;(addr-*)-1
    299  30f6					      endm
    300  30f6							; SETIRQ	Sets the line number to run when an irq happens irq 550
    301  30f6					      macro	setirq
    302  30f6					      db	56
    303  30f6					      endm
    304  30f6
    305  30f6							; TSTIRQ	Test for irq pending,
    306  30f6							;		if so push the IRQ LINE NUMBER into RO, onto stack
    307  30f6					      macro	tstirq
    308  30f6					      db	57
    309  30f6					      db	({1}-*)-1	;(addr-*)-1
    310  30f6					      endm
    311  30f6
    312  30f6							; IRET    return from interupt service
    313  30f6					      macro	iret
    314  30f6					      db	58
    315  30f6					      endm
    316  30f6
    317  30f6							; INSTR   read a string from the input
    318  30f6					      macro	instr
    319  30f6					      db	59
    320  30f6					      endm
    321  30f6
    322  30f6							; MODULO Returns the remainder of the division
    323  30f6					      macro	modulo
    324  30f6					      db	60
    325  30f6					      endm
    326  30f6							; Set a task line
    327  30f6					      macro	taskcreate
    328  30f6					      db	61
    329  30f6					      endm
    330  30f6							; End a task
    331  30f6					      macro	etask
    332  30f6					      db	62
    333  30f6					      endm
    334  30f6							; Skip to next task
    335  30f6					      macro	ntask
    336  30f6					      db	63
    337  30f6					      endm
    338  30f6							; Subscript
    339  30f6					      macro	subscript
    340  30f6					      db	64
    341  30f6					      db	{1}
    342  30f6					      endm
    343  30f6							; KILL Task
    344  30f6					      macro	taskkill
    345  30f6					      db	65
    346  30f6					      endm
    347  30f6							; STAT Task
    348  30f6					      macro	taskstat
    349  30f6					      db	66
    350  30f6					      endm
    351  30f6							;  output value as hex
    352  30f6					      macro	hexprt
    353  30f6					      db	67
    354  30f6					      endm
    355  30f6							;  Read in background has completed
    356  30f6					      macro	readcomplete
    357  30f6					      db	68
    358  30f6					      endm
    359  30f6							;  ReadInput line
    360  30f6					      macro	readstart
    361  30f6					      db	69
    362  30f6					      endm
    363  30f6							; Startio request
    364  30f6					      macro	startio
    365  30f6					      db	70
    366  30f6					      endm
    367  30f6							; Endio
    368  30f6					      macro	endio
    369  30f6					      db	71
    370  30f6					      endm
    371  30f6							; Logical not
    372  30f6					      macro	lognot
    373  30f6					      db	72
    374  30f6					      endm
    375  30f6							; Logical OR
    376  30f6					      macro	logor
    377  30f6					      db	73
    378  30f6					      endm
    379  30f6							;Logical and
    380  30f6					      macro	logand
    381  30f6					      db	74
    382  30f6					      endm
    383  30f6							;Logical XOR
    384  30f6					      macro	logxor
    385  30f6					      db	75
    386  30f6					      endm
    387  30f6							;Wait for task to complete, or list of tasks
    388  30f6					      macro	wtask
    389  30f6					      db	76
    390  30f6					      db	({1}-*)-1	;(addr-*)-1
    391  30f6					      endm
    392  30f6							;Get the current task id
    393  30f6					      MACRO	taskpid
    394  30f6					      db	77
    395  30f6					      endm
    396  30f6							;Trace the basic execution
    397  30f6					      Macro	traceprogram
    398  30f6					      db	78
    399  30f6					      endm
    400  30f6							;Do a basic program Trace
    401  30f6					      Macro	debugbasic
    402  30f6					      db	79
    403  30f6					      endm
    404  30f6
    405  30f6							; Inter Process communications instructions
    406  30f6					      Macro	ipcsend
    407  30f6					      db	80
    408  30f6					      endm
    409  30f6					      Macro	ipcreceive
    410  30f6					      db	81
    411  30f6					      endm
    412  30f6					      Macro	ipccheck
    413  30f6					      db	82
    414  30f6					      endm
    415  30f6					      Macro	ipcio
    416  30f6					      db	83
    417  30f6					      endm
    418  30f6					      Macro	pushmathstack
    419  30f6					      db	84
    420  30f6					      endm
    421  30f6					      Macro	popmathstack
    422  30f6					      db	85
    423  30f6					      endm
    424  30f6					      Macro	savemathstack
    425  30f6					      db	86
    426  30f6					      endm
    427  30f6					      Macro	restoremathstack
    428  30f6					      db	87
    429  30f6					      endm
    430  30f6					      Macro	incparmcount
    431  30f6					      db	88
    432  30f6					      endm
    433  30f6					      Macro	taskgetmathstack
    434  30f6					      db	89
    435  30f6					      endm
    436  30f6					      Macro	taskenable
    437  30f6					      db	90
    438  30f6					      endm
    439  30f6					      Macro	tasksuspend
    440  30f6					      db	91
    441  30f6					      endm
    442  30f6					      Macro	taskputmathptr
    443  30f6					      db	92
    444  30f6					      endm
    445  30f6							; Test for an extension type of variable that allows access to a tasks variables
    446  30f6							; Using  PID!<Var name>
    447  30f6					      Macro	tstvt
    448  30f6					      db	93
    449  30f6					      db	({1}-*)-1	;(addr-*)-1
    450  30f6					      endm
    451  30f6
    452  30f6							; Provide access to R2 for the IL program
    453  30f6					      Macro	setr2
    454  30f6					      db	94
    455  30f6					      db	{1}	; R2 is only one byte
    456  30f6					      endm
    457  30f6
    458  30f6							;Move stack top to temp
    459  30f6					      Macro	stk2tmp
    460  30f6					      db	95
    461  30f6					      endm
    462  30f6
    463  30f6					      Macro	tmp2stk
    464  30f6					      db	96
    465  30f6					      endm
    466  30f6
    467  30f6					      Macro	tstbyte
    468  30f6					      db	97
    469  30f6					      db	({1}-*)-1	; (addr-*)-1 goto if match
    470  30f6					      dw	{2}	; address to check
    471  30f6					      db	{3}	; Value to compare
    472  30f6					      endm
    473  30f6
    474  30f6					      Macro	incvar
    475  30f6					      db	98
    476  30f6					      endm
    477  30f6					      Macro	decvar
    478  30f6					      db	99
    479  30f6					      endm
    480  30f6
    481  30f6					      Macro	slice
    482  30f6					      db	100
    483  30f6					      endm
    484  30f6
    485  30f6					      Macro	tstb
    486  30f6					      db	101
    487  30f6					      db	({1}-*)-1
    488  30f6					      db	{2}
    489  30f6					      endm
    490  30f6
    491  30f6					      Macro	tstw
    492  30f6					      db	102
    493  30f6					      db	({1}-*)-1
    494  30f6					      dw	{2}
    495  30f6					      endm
    496  30f6
    497  30f6					      Macro	ongoto
    498  30f6					      db	103
    499  30f6					      dw	{1}
    500  30f6					      dw	{2}
    501  30f6					      endm
    502  30f6
    503  30f6					      Macro	tstrelop
    504  30f6					      db	104
    505  30f6					      db	({1}-*)-1
    506  30f6					      endm
    507  30f6
    508  30f6					      Macro	repeatline
    509  30f6					      db	105
    510  30f6					      endm
    511  30f6
    512  30f6							; Check for a precompiled branch, will take branch if precompiled value present
    513  30f6					      Macro	tstbranch
    514  30f6					      db	106
    515  30f6					      db	({1}-*)-1
    516  30f6					      endm
    517  30f6
    518  30f6					      Macro	fastxfer
    519  30f6					      db	107
    520  30f6					      endm
    521  30f6
    522  30f6							; Set all io to to a terminal for input output
    523  30f6							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    524  30f6							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    525  30f6					      Macro	setterminal
    526  30f6					      db	108
    527  30f6					      endm
    528  30f6
    529  30f6							;Fetch a single byte from memory
    530  30f6					      Macro	indb
    531  30f6					      db	109
    532  30f6					      endm
    533  30f6
    534  30f6							; Set a block of memory to a fixed value, byte or word
    535  30f6							; Stack must contain destiniation address, length to set in bytes, value {byte of word} to initialize to
    536  30f6					      Macro	setblock
    537  30f6					      db	110
    538  30f6					      db	{1}	; the data type to initialize	tByte or tInteger
    539  30f6					      endm
    540  30f6
    541  30f6							; Copy a block of memory
    542  30f6							; Stack must contain source address, destination address, length in bytes
    543  30f6					      Macro	copyblock
    544  30f6					      db	111
    545  30f6					      endm
    546  30f6
    547  30f6							; Compare one block of memory to another
    548  30f6							; Stack contains Length, Source1 Source 2
    549  30f6							; Place on stack 0 equal, 1 s1>s2, -1 s1 < s2
    550  30f6					      Macro	cmpmem
    551  30f6					      db	112
    552  30f6					      endm
    553  30f6
    554  30f6							; Shift Left and Right
    555  30f6					      Macro	shift
    556  30f6					      db	113
    557  30f6					      db	{1}	; direction  0 = left 1 = right
    558  30f6					      endm
------- FILE mytb.asm
   2485  30f6							;
   2486  30f6				  -	      if	FIXED
   2487  30f6				  -	      org	$1000
   2488  30f6					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  30f6					      include	"basic.il"
      1  30f6					      seg	Code
      2  30f6							; on goto table
      3  30f6							; format :   first byte is value Base, subtracted from value found
      4  30f6							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  30f6				   BasicStmts
      0  30f6					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  30f6		       01 23		      .byte.b	kBeginKey,(kKeyCount+1)
      0  30f8					      dw	ekLet
      1  30f8		       83 31		      .word.w	ekLet
      0  30fa					      dw	ekInc
      1  30fa		       b5 31		      .word.w	ekInc
      0  30fc					      dw	ekDec
      1  30fc		       c2 31		      .word.w	ekDec
      0  30fe					      dw	ekIreturn
      1  30fe		       cf 31		      .word.w	ekIreturn
      0  3100					      dw	ekIf
      1  3100		       d4 31		      .word.w	ekIf
      0  3102					      dw	ekThen
      1  3102		       da 31		      .word.w	ekThen
      0  3104					      dw	ekGoto
      1  3104		       de 31		      .word.w	ekGoto
      0  3106					      dw	ekGosub
      1  3106		       62 35		      .word.w	ekGosub
      0  3108					      dw	ekReturn
      1  3108		       70 35		      .word.w	ekReturn
      0  310a					      dw	ekRem
      1  310a		       f2 31		      .word.w	ekRem
      0  310c					      dw	ekPrint	; should be entry for print
      1  310c		       08 32		      .word.w	ekPrint
      0  310e					      dw	ekTaske
      1  310e		       55 32		      .word.w	ekTaske
      0  3110					      dw	ekTaskn
      1  3110		       6b 32		      .word.w	ekTaskn
      0  3112					      dw	ekTaskw
      1  3112		       72 32		      .word.w	ekTaskw
      0  3114					      dw	ekPoke
      1  3114		       8d 32		      .word.w	ekPoke
      0  3116					      dw	ekPutch
      1  3116		       ef 32		      .word.w	ekPutch
      0  3118					      dw	ekCls
      1  3118		       fa 32		      .word.w	ekCls
      0  311a					      dw	ekInput
      1  311a		       01 33		      .word.w	ekInput
      0  311c					      dw	ekEnd
      1  311c		       2a 33		      .word.w	ekEnd
      0  311e					      dw	ekIrq
      1  311e		       2e 33		      .word.w	ekIrq
      0  3120					      dw	ekKill
      1  3120		       39 33		      .word.w	ekKill
      0  3122					      dw	ekList
      1  3122		       44 33		      .word.w	ekList
      0  3124					      dw	ekRun
      1  3124		       49 33		      .word.w	ekRun
      0  3126					      dw	ekNew
      1  3126		       52 33		      .word.w	ekNew
      0  3128					      dw	ekSlice
      1  3128		       56 33		      .word.w	ekSlice
      0  312a					      dw	ekTrace
      1  312a		       61 33		      .word.w	ekTrace
      0  312c					      dw	ekExit
      1  312c		       72 33		      .word.w	ekExit
      0  312e					      dw	ekSave
      1  312e		       73 33		      .word.w	ekSave
      0  3130					      dw	ekLoad
      1  3130		       7a 33		      .word.w	ekLoad
      0  3132					      dw	ekErase
      1  3132		       8a 33		      .word.w	ekErase
      0  3134					      dw	ekDir
      1  3134		       86 33		      .word.w	ekDir
      0  3136					      dw	ekSetTerm
      1  3136		       f8 31		      .word.w	ekSetTerm
      0  3138					      dw	ekSetMemB
      1  3138		       a4 32		      .word.w	ekSetMemB
      0  313a					      dw	ekSetMemW
      1  313a		       b0 32		      .word.w	ekSetMemW
      0  313c					      dw	ekCopyMem
      1  313c		       d2 32		      .word.w	ekCopyMem
     42  313e							;
     43  313e							; Logical operators
      0  313e				   BasicLogical db	kOr,3
      1  313e		       25 03		      .byte.b	kOr,3
      0  3140					      dw	ekOr
      1  3140		       b8 33		      .word.w	ekOr
      0  3142					      dw	ekXor
      1  3142		       bd 33		      .word.w	ekXor
      0  3144					      dw	ekAnd
      1  3144		       b3 33		      .word.w	ekAnd
     48  3146
      0  3146				   BasicShift db	kShr,2
      1  3146		       28 02		      .byte.b	kShr,2
      0  3148					      dw	ekShiftRight
      1  3148		       a8 33		      .word.w	ekShiftRight
      0  314a					      dw	ekShiftLeft
      1  314a		       a2 33		      .word.w	ekShiftLeft
     52  314c
     53  314c							;functions returning values
     54  314c
      0  314c				   BasicFuncs db	kBeginFunc,kFuncCount
      1  314c		       2a 11		      .byte.b	kBeginFunc,kFuncCount
      0  314e					      dw	ekTrue
      1  314e		       1d 34		      .word.w	ekTrue
      0  3150					      dw	ekFalse
      1  3150		       21 34		      .word.w	ekFalse
      0  3152					      dw	ekFree
      1  3152		       25 34		      .word.w	ekFree
      0  3154					      dw	ekGetch
      1  3154		       2d 34		      .word.w	ekGetch
      0  3156					      dw	ekPeek
      1  3156		       5b 34		      .word.w	ekPeek
      0  3158					      dw	ekTask
      1  3158		       66 34		      .word.w	ekTask
      0  315a					      dw	ekIpcc
      1  315a		       b2 34		      .word.w	ekIpcc
      0  315c					      dw	ekIpcs
      1  315c		       8d 34		      .word.w	ekIpcs
      0  315e					      dw	ekIpcr
      1  315e		       9e 34		      .word.w	ekIpcr
      0  3160					      dw	ekRnd
      1  3160		       bd 34		      .word.w	ekRnd
      0  3162					      dw	ekStat
      1  3162		       db 34		      .word.w	ekStat
      0  3164					      dw	ekAbs
      1  3164		       d0 34		      .word.w	ekAbs
      0  3166					      dw	ekCall
      1  3166		       e8 34		      .word.w	ekCall
      0  3168					      dw	ekGofn
      1  3168		       69 35		      .word.w	ekGofn
      0  316a					      dw	ekPid
      1  316a		       e6 34		      .word.w	ekPid
      0  316c					      dw	ekAddr
      1  316c		       35 34		      .word.w	ekAddr
      0  316e					      dw	ekCmpMem
      1  316e		       44 34		      .word.w	ekCmpMem
     73  3170							;====================================================
     74  3170							; file constants
     75  3170		       00 00	   OPEN_APPEND equ	0	; append to file
     76  3170		       00 01	   OPEN_CREATE equ	1	; truncate/create file
     77  3170
     78  3170							;=====================================================
     79  3170							; This is the IL of the BASIC (or whatever) language.
     80  3170							; Because of the way macros are implemented by as65,
     81  3170							; labels can't be on the same line as a macro
     82  3170							; invocation, so that's why labels are on separate
     83  3170							; lines.
     84  3170							;
     85  3170		       31 70	   IL	      equ	*
     86  3170
     87  3170							;THE IL CONTROL SECTION
     88  3170
     89  3170				   START
      0  3170					      INIT		;INITIALIZE
      0  3170					      db	22
      1  3170		       16		      .byte.b	22
      0  3171					      NLINE		;WRITE CRLF
      0  3171					      db	5
      1  3171		       05		      .byte.b	5
      0  3172					      ERRGOTO	CO	;where to go after an error
      0  3172					      db	31
      1  3172		       1f		      .byte.b	31
      0  3173					      dw	CO
      1  3173		       76 31		      .word.w	CO
      0  3175					      VINIT		;clear all variables
      0  3175					      db	30
      1  3175		       1e		      .byte.b	30
     94  3176							;
     95  3176							; This is where we jump to get a line of commands or
     96  3176							; a program from the user.
     97  3176							;
     98  3176				   CO
      0  3176					      GETLINE		;WRITE PROMPT AND GET LINE
      0  3176					      db	23
      1  3176		       17		      .byte.b	23
      0  3177					      TSTL	XEC	;TEST FOR LINE NUMBER, if none then execute the line
      0  3177					      db	34
      1  3177		       22		      .byte.b	34
      0  3178					      db	(XEC-*)-1
      1  3178		       04		      .byte.b	(XEC-*)-1
      0  3179					      INSERT		;INSERT IT (MAY BE DELETE)
      0  3179					      db	24
      1  3179		       18		      .byte.b	24
      0  317a					      IJMP	CO
      0  317a					      db	29
      1  317a		       1d		      .byte.b	29
      0  317b					      dw	CO
      1  317b		       76 31		      .word.w	CO
    103  317d				   XEC
      0  317d					      XINIT		;INITIALIZE
      0  317d					      db	0
      1  317d		       00		      .byte.b	0
    105  317e							;============================================================================
    106  317e							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
    107  317e							;
    108  317e				   STMT
      0  317e					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  317e					      db	57
      1  317e		       39		      .byte.b	57
      0  317f					      db	(notirq-*)-1
      1  317f		       00		      .byte.b	(notirq-*)-1
    110  3180							;==========================================================================================
    111  3180							; Process a let statement implied or explicit.
    112  3180							;
    113  3180				   notirq
      0  3180					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  3180					      db	79
      1  3180		       4f		      .byte.b	79
      0  3181					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  3181					      db	49
      1  3181		       31		      .byte.b	49
      0  3182					      db	(DoVector-*)-1
      1  3182		       2d		      .byte.b	(DoVector-*)-1
    116  3183				   ekLet
      0  3183					      TSTV	DoVector	; Test for variable
      0  3183					      db	33
      1  3183		       21		      .byte.b	33
      0  3184					      db	(DoVector-*)-1
      1  3184		       2b		      .byte.b	(DoVector-*)-1
      0  3185					      CALL	FactVarPtrNoTst	; get a pointer to the variable
      0  3185					      db	28
      1  3185		       1c		      .byte.b	28
      0  3186					      dw	FactVarPtrNoTst
      1  3186		       31 35		      .word.w	FactVarPtrNoTst
    119  3188
    120  3188				   LETINDEX_ALL
      0  3188					      TSTB	ERRMissingEquals,oEqual	; (This line originally omitted)
      0  3188					      db	101
      1  3188		       65		      .byte.b	101
      0  3189					      db	(ERRMissingEquals-*)-1
      1  3189		       20		      .byte.b	(ERRMissingEquals-*)-1
      0  318a					      db	oEqual
      1  318a		       f2		      .byte.b	oEqual
    122  318b				   LETBE
      0  318b					      TSTBYTE	LETAssignByte,R2,tByte	; Check for a byte conversion
      0  318b					      db	97
      1  318b		       61		      .byte.b	97
      0  318c					      db	(LETAssignByte-*)-1
      1  318c		       10		      .byte.b	(LETAssignByte-*)-1
      0  318d					      dw	R2
      1  318d		       58 00		      .word.w	R2
      0  318f					      db	tByte
      1  318f		       a2		      .byte.b	tByte
      0  3190					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  3190					      db	28
      1  3190		       1c		      .byte.b	28
      0  3191					      dw	EXPR
      1  3191		       92 33		      .word.w	EXPR
      0  3193					      DONE		; REPORT ERROR IF NOT NEXT
      0  3193					      db	1
      1  3193		       01		      .byte.b	1
      0  3194					      SETR2	tInteger	; Store an integer type
      0  3194					      db	94
      1  3194		       5e		      .byte.b	94
      0  3195					      db	tInteger
      1  3195		       a4		      .byte.b	tInteger
      0  3196					      STORE		; STORE RESULT at variable address
      0  3196					      db	19
      1  3196		       13		      .byte.b	19
      0  3197					      NXT	CO	; AND SEQUENCE TO NEXT
      0  3197					      db	6
      1  3197		       06		      .byte.b	6
      0  3198					      dw	CO
      1  3198		       76 31		      .word.w	CO
      0  319a					      IJMP	STMT	; Next statement
      0  319a					      db	29
      1  319a		       1d		      .byte.b	29
      0  319b					      dw	STMT
      1  319b		       7e 31		      .word.w	STMT
    130  319d
    131  319d				   LETAssignByte
      0  319d					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  319d					      db	28
      1  319d		       1c		      .byte.b	28
      0  319e					      dw	EXPR
      1  319e		       92 33		      .word.w	EXPR
      0  31a0					      DONE		; REPORT ERROR IF NOT NEXT
      0  31a0					      db	1
      1  31a0		       01		      .byte.b	1
      0  31a1					      SETR2	tByte	; Set to store a byte value
      0  31a1					      db	94
      1  31a1		       5e		      .byte.b	94
      0  31a2					      db	tByte
      1  31a2		       a2		      .byte.b	tByte
      0  31a3					      STORE		; STORE RESULT at variable address
      0  31a3					      db	19
      1  31a3		       13		      .byte.b	19
      0  31a4					      NXT	CO	; AND SEQUENCE TO NEXT
      0  31a4					      db	6
      1  31a4		       06		      .byte.b	6
      0  31a5					      dw	CO
      1  31a5		       76 31		      .word.w	CO
      0  31a7					      IJMP	STMT	; Next statement
      0  31a7					      db	29
      1  31a7		       1d		      .byte.b	29
      0  31a8					      dw	STMT
      1  31a8		       7e 31		      .word.w	STMT
    138  31aa
    139  31aa				   ERRMissingEquals
      0  31aa					      ERRMSG	ERR_MISSINGEQUALSIGN	; Missing asignment
      0  31aa					      db	13
      1  31aa		       0d		      .byte.b	13
      0  31ab					      dw	ERR_MISSINGEQUALSIGN
      1  31ab		       18 00		      .word.w	ERR_MISSINGEQUALSIGN
    141  31ad
    142  31ad				   ERRVEC2
      0  31ad					      IJMP	UNKNOWN
      0  31ad					      db	29
      1  31ad		       1d		      .byte.b	29
      0  31ae					      dw	UNKNOWN
      1  31ae		       8e 33		      .word.w	UNKNOWN
    144  31b0							;=============================================================
    145  31b0							;Branch on a valid statement start
    146  31b0				   DoVector
      0  31b0					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  31b0					      db	103
      1  31b0		       67		      .byte.b	103
      0  31b1					      dw	BasicStmts
      1  31b1		       f6 30		      .word.w	BasicStmts
      0  31b3					      dw	UNKNOWN
      1  31b3		       8e 33		      .word.w	UNKNOWN
    148  31b5							;This will never return here!
    149  31b5							;=============================================================
    150  31b5							; Inc or dec a variable
    151  31b5				   ekInc
      0  31b5					      TSTV	ERRVEC2	; Verify we have a variable
      0  31b5					      db	33
      1  31b5		       21		      .byte.b	33
      0  31b6					      db	(ERRVEC2-*)-1
      1  31b6		       f6		      .byte.b	(ERRVEC2-*)-1
      0  31b7					      CALL	FactVarPtrNoTst	; Get a pointer to the memory location to increment
      0  31b7					      db	28
      1  31b7		       1c		      .byte.b	28
      0  31b8					      dw	FactVarPtrNoTst
      1  31b8		       31 35		      .word.w	FactVarPtrNoTst
    154  31ba							;	  TSTB	     eDoInc,oBang		    ; Allow to inc or dec other tasks variables
    155  31ba							;	  IND					    ; we just got a pid
    156  31ba							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    157  31ba				   eDoInc
      0  31ba					      INCVAR		; Do the increment of the variable
      0  31ba					      db	98
      1  31ba		       62		      .byte.b	98
      0  31bb					      DONE		; Test for end of line or end of statement ":"
      0  31bb					      db	1
      1  31bb		       01		      .byte.b	1
      0  31bc					      NXT	CO	; Get the next statement, branch CO if end of program
      0  31bc					      db	6
      1  31bc		       06		      .byte.b	6
      0  31bd					      dw	CO
      1  31bd		       76 31		      .word.w	CO
      0  31bf					      IJMP	STMT	; Process the next statement
      0  31bf					      db	29
      1  31bf		       1d		      .byte.b	29
      0  31c0					      dw	STMT
      1  31c0		       7e 31		      .word.w	STMT
    162  31c2							;S1Dec:
    163  31c2							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    164  31c2				   ekDec
      0  31c2					      TSTV	ERRVEC2	; Must be followed by a variable
      0  31c2					      db	33
      1  31c2		       21		      .byte.b	33
      0  31c3					      db	(ERRVEC2-*)-1
      1  31c3		       e9		      .byte.b	(ERRVEC2-*)-1
      0  31c4					      CALL	FactVarPtrNoTst	; Get a pointer to the variable to update
      0  31c4					      db	28
      1  31c4		       1c		      .byte.b	28
      0  31c5					      dw	FactVarPtrNoTst
      1  31c5		       31 35		      .word.w	FactVarPtrNoTst
    167  31c7							;	  TSTB	     eDoDec,oBang		    ; Allow to inc or dec other tasks variables
    168  31c7							;	  IND					    ; we just got a pid
    169  31c7							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    170  31c7				   eDoDec
      0  31c7					      DECVAR		; Decrement the actual variable
      0  31c7					      db	99
      1  31c7		       63		      .byte.b	99
      0  31c8					      DONE		; Test if end of line or : statement
      0  31c8					      db	1
      1  31c8		       01		      .byte.b	1
      0  31c9					      NXT	CO	; If at end of program then got the console
      0  31c9					      db	6
      1  31c9		       06		      .byte.b	6
      0  31ca					      dw	CO
      1  31ca		       76 31		      .word.w	CO
      0  31cc					      IJMP	STMT	; Process the next statement of command line
      0  31cc					      db	29
      1  31cc		       1d		      .byte.b	29
      0  31cd					      dw	STMT
      1  31cd		       7e 31		      .word.w	STMT
    175  31cf							;=============================================================================================================================
    176  31cf							; iret or ireturn, Return from interupt process
    177  31cf							;
    178  31cf							;S1Iret:
    179  31cf							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    180  31cf							;S1Sa:
    181  31cf				   ekIreturn
      0  31cf					      DONE		; Must be only thing on the line
      0  31cf					      db	1
      1  31cf		       01		      .byte.b	1
      0  31d0					      IRET		; RESTORE LINE NUMBER OF CALL
      0  31d0					      db	58
      1  31d0		       3a		      .byte.b	58
      0  31d1					      IJMP	STMT
      0  31d1					      db	29
      1  31d1		       1d		      .byte.b	29
      0  31d2					      dw	STMT
      1  31d2		       7e 31		      .word.w	STMT
    185  31d4							;==============================================================================================================================
    186  31d4							;Process if statement, if true then process all statements until end of line reached
    187  31d4							;S1S1:
    188  31d4							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    189  31d4				   ekIf
      0  31d4					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  31d4					      db	28
      1  31d4		       1c		      .byte.b	28
      0  31d5					      dw	EXPR
      1  31d5		       92 33		      .word.w	EXPR
      0  31d7					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  31d7					      db	101
      1  31d7		       65		      .byte.b	101
      0  31d8					      db	(S1W-*)-1
      1  31d8		       01		      .byte.b	(S1W-*)-1
      0  31d9					      db	kThen
      1  31d9		       06		      .byte.b	kThen
    192  31da				   ekThen
    193  31da				   S1W
      0  31da					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  31da					      db	54
      1  31da		       36		      .byte.b	54
      0  31db					      IJMP	STMT
      0  31db					      db	29
      1  31db		       1d		      .byte.b	29
      0  31dc					      dw	STMT
      1  31dc		       7e 31		      .word.w	STMT
    196  31de							;===============================================================================================================================
    197  31de							; Test for GOTO
    198  31de							;S1Z:
    199  31de							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    200  31de							;
    201  31de				   ekGoto
      0  31de					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  31de					      db	106
      1  31de		       6a		      .byte.b	106
      0  31df					      db	(ekGotoCompiled-*)-1
      1  31df		       0e		      .byte.b	(ekGotoCompiled-*)-1
    203  31e0							; Else we have the address and just goto that address
      0  31e0					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  31e0					      db	101
      1  31e0		       65		      .byte.b	101
      0  31e1					      db	(ekGotoLine-*)-1
      1  31e1		       05		      .byte.b	(ekGotoLine-*)-1
      0  31e2					      db	oPeriod
      1  31e2		       e9		      .byte.b	oPeriod
      0  31e3					      REPEATLINE		; Repeat the same line again
      0  31e3					      db	105
      1  31e3		       69		      .byte.b	105
      0  31e4					      IJMP	STMT	; Go do the statement
      0  31e4					      db	29
      1  31e4		       1d		      .byte.b	29
      0  31e5					      dw	STMT
      1  31e5		       7e 31		      .word.w	STMT
    207  31e7
    208  31e7				   ekGotoLine
      0  31e7					      CALL	EXPR	; GET LABEL
      0  31e7					      db	28
      1  31e7		       1c		      .byte.b	28
      0  31e8					      dw	EXPR
      1  31e8		       92 33		      .word.w	EXPR
      0  31ea					      lit	0	; Place indicator for line num on stack
      0  31ea					      db	27
      1  31ea		       1b		      .byte.b	27
      0  31eb					      dw	0
      1  31eb		       00 00		      .word.w	0
      0  31ed					      FASTXFER
      0  31ed					      db	107
      1  31ed		       6b		      .byte.b	107
    212  31ee				   ekGotoCompiled
      0  31ee					      lit	1	; tell it that mempointer on the stack
      0  31ee					      db	27
      1  31ee		       1b		      .byte.b	27
      0  31ef					      dw	1
      1  31ef		       01 00		      .word.w	1
      0  31f1					      FASTXFER		; put top of stack into curptr
      0  31f1					      db	107
      1  31f1		       6b		      .byte.b	107
    215  31f2
    216  31f2
    217  31f2							;==================================================================================================================================
    218  31f2							; Process REM statement
    219  31f2							;
    220  31f2							;S2a:
    221  31f2							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    222  31f2				   ekRem
      0  31f2					      NXT	CO	; The rest of the line is ignored
      0  31f2					      db	6
      1  31f2		       06		      .byte.b	6
      0  31f3					      dw	CO
      1  31f3		       76 31		      .word.w	CO
      0  31f5					      IJMP	STMT	; Process the next statement
      0  31f5					      db	29
      1  31f5		       1d		      .byte.b	29
      0  31f6					      dw	STMT
      1  31f6		       7e 31		      .word.w	STMT
    225  31f8							;====================================================================================================================================
    226  31f8							; Set the Task input output slot each slot is 16 byte starting at e000
    227  31f8							; so 0,1,...
    228  31f8				   ekSetTerm
      0  31f8					      CALL	EXPR
      0  31f8					      db	28
      1  31f8		       1c		      .byte.b	28
      0  31f9					      dw	EXPR
      1  31f9		       92 33		      .word.w	EXPR
      0  31fb					      TSTB	ERRVEC,oComma
      0  31fb					      db	101
      1  31fb		       65		      .byte.b	101
      0  31fc					      db	(ERRVEC-*)-1
      1  31fc		       2f		      .byte.b	(ERRVEC-*)-1
      0  31fd					      db	oComma
      1  31fd		       e2		      .byte.b	oComma
      0  31fe					      CALL	EXPR
      0  31fe					      db	28
      1  31fe		       1c		      .byte.b	28
      0  31ff					      dw	EXPR
      1  31ff		       92 33		      .word.w	EXPR
      0  3201					      SETTERMINAL
      0  3201					      db	108
      1  3201		       6c		      .byte.b	108
      0  3202					      NXT	CO	;Next statement to execute
      0  3202					      db	6
      1  3202		       06		      .byte.b	6
      0  3203					      dw	CO
      1  3203		       76 31		      .word.w	CO
      0  3205					      IJMP	STMT
      0  3205					      db	29
      1  3205		       1d		      .byte.b	29
      0  3206					      dw	STMT
      1  3206		       7e 31		      .word.w	STMT
    235  3208							;==================================================================================================================================
    236  3208							; Print statement
    237  3208							;
    238  3208							;S3:
    239  3208							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    240  3208				   ekPrint
      0  3208					      STARTIO		; Lock task until io completes
      0  3208					      db	70
      1  3208		       46		      .byte.b	70
    242  3209				   S4
      0  3209					      TSTDONE	S4a	; Test if we just want crlf printed
      0  3209					      db	50
      1  3209		       32		      .byte.b	50
      0  320a					      db	(S4a-*)-1
      1  320a		       03		      .byte.b	(S4a-*)-1
      0  320b					      IJMP	S6
      0  320b					      db	29
      1  320b		       1d		      .byte.b	29
      0  320c					      dw	S6
      1  320c		       23 32		      .word.w	S6
    245  320e
    246  320e				   S4a
      0  320e					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  320e					      db	101
      1  320e		       65		      .byte.b	101
      0  320f					      db	(S7-*)-1
      1  320f		       1f		      .byte.b	(S7-*)-1
      0  3210					      db	tString
      1  3210		       a0		      .byte.b	tString
      0  3211					      PRS		; PRINT STRING
      0  3211					      db	2
      1  3211		       02		      .byte.b	2
    249  3212				   S5
      0  3212					      TSTB	S6A,oComma	; IS THERE MORE?
      0  3212					      db	101
      1  3212		       65		      .byte.b	101
      0  3213					      db	(S6A-*)-1
      1  3213		       07		      .byte.b	(S6A-*)-1
      0  3214					      db	oComma
      1  3214		       e2		      .byte.b	oComma
      0  3215					      SPC		; SPACE TO NEXT ZONE
      0  3215					      db	4
      1  3215		       04		      .byte.b	4
      0  3216					      TSTDONE	S4	; Not end of line jump back
      0  3216					      db	50
      1  3216		       32		      .byte.b	50
      0  3217					      db	(S4-*)-1
      1  3217		       f1		      .byte.b	(S4-*)-1
      0  3218					      IJMP	S6Z	; YES JUMP BACK
      0  3218					      db	29
      1  3218		       1d		      .byte.b	29
      0  3219					      dw	S6Z
      1  3219		       25 32		      .word.w	S6Z
    254  321b
    255  321b							;
    256  321b							; If a semicolon, don't do anything.
    257  321b							;
    258  321b				   S6A
      0  321b					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  321b					      db	101
      1  321b		       65		      .byte.b	101
      0  321c					      db	(S6-*)-1
      1  321c		       06		      .byte.b	(S6-*)-1
      0  321d					      db	oSemiColon
      1  321d		       e3		      .byte.b	oSemiColon
      0  321e					      TSTDONE	S4	; Jump Back if not end of line
      0  321e					      db	50
      1  321e		       32		      .byte.b	50
      0  321f					      db	(S4-*)-1
      1  321f		       e9		      .byte.b	(S4-*)-1
      0  3220					      IJMP	S6Z
      0  3220					      db	29
      1  3220		       1d		      .byte.b	29
      0  3221					      dw	S6Z
      1  3221		       25 32		      .word.w	S6Z
    262  3223
    263  3223				   S6
    264  3223
      0  3223					      DONE		; ERROR IF CR NOT NEXT
      0  3223					      db	1
      1  3223		       01		      .byte.b	1
      0  3224					      NLINE
      0  3224					      db	5
      1  3224		       05		      .byte.b	5
    267  3225				   S6Z
      0  3225					      ENDIO		; release task io completed
      0  3225					      db	71
      1  3225		       47		      .byte.b	71
      0  3226					      NXT	CO	; exit here if , or ; at end of print
      0  3226					      db	6
      1  3226		       06		      .byte.b	6
      0  3227					      dw	CO
      1  3227		       76 31		      .word.w	CO
      0  3229					      IJMP	STMT
      0  3229					      db	29
      1  3229		       1d		      .byte.b	29
      0  322a					      dw	STMT
      1  322a		       7e 31		      .word.w	STMT
    271  322c							;
    272  322c							; A jump for code too far away for relative branch
    273  322c							;
    274  322c				   ERRVEC
      0  322c					      IJMP	UNKNOWN
      0  322c					      db	29
      1  322c		       1d		      .byte.b	29
      0  322d					      dw	UNKNOWN
      1  322d		       8e 33		      .word.w	UNKNOWN
    276  322f							;
    277  322f							; Get here if there is an expression to print
    278  322f				   S7
      0  322f					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  322f					      db	101
      1  322f		       65		      .byte.b	101
      0  3230					      db	(S7AUnsigned-*)-1
      1  3230		       08		      .byte.b	(S7AUnsigned-*)-1
      0  3231					      db	oDollar
      1  3231		       e7		      .byte.b	oDollar
      0  3232					      CALL	EXPR
      0  3232					      db	28
      1  3232		       1c		      .byte.b	28
      0  3233					      dw	EXPR
      1  3233		       92 33		      .word.w	EXPR
      0  3235					      HEXPRT
      0  3235					      db	67
      1  3235		       43		      .byte.b	67
      0  3236					      IJMP	S5
      0  3236					      db	29
      1  3236		       1d		      .byte.b	29
      0  3237					      dw	S5
      1  3237		       12 32		      .word.w	S5
    283  3239
    284  3239				   S7AUnsigned
    285  3239
      0  3239					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  3239					      db	101
      1  3239		       65		      .byte.b	101
      0  323a					      db	(S7A-*)-1
      1  323a		       0a		      .byte.b	(S7A-*)-1
      0  323b					      db	oPercent
      1  323b		       ed		      .byte.b	oPercent
      0  323c					      CALL	EXPR
      0  323c					      db	28
      1  323c		       1c		      .byte.b	28
      0  323d					      dw	EXPR
      1  323d		       92 33		      .word.w	EXPR
      0  323f					      SETR2	tUint
      0  323f					      db	94
      1  323f		       5e		      .byte.b	94
      0  3240					      db	tUint
      1  3240		       a9		      .byte.b	tUint
      0  3241					      PRN
      0  3241					      db	3
      1  3241		       03		      .byte.b	3
      0  3242					      IJMP	S5
      0  3242					      db	29
      1  3242		       1d		      .byte.b	29
      0  3243					      dw	S5
      1  3243		       12 32		      .word.w	S5
    291  3245
    292  3245				   S7A
    293  3245
      0  3245					      CALL	EXPR
      0  3245					      db	28
      1  3245		       1c		      .byte.b	28
      0  3246					      dw	EXPR
      1  3246		       92 33		      .word.w	EXPR
      0  3248					      TSTB	S7B,oDollar	; Print the value as a single character
      0  3248					      db	101
      1  3248		       65		      .byte.b	101
      0  3249					      db	(S7B-*)-1
      1  3249		       05		      .byte.b	(S7B-*)-1
      0  324a					      db	oDollar
      1  324a		       e7		      .byte.b	oDollar
      0  324b					      PUTCHAR
      0  324b					      db	52
      1  324b		       34		      .byte.b	52
      0  324c					      IJMP	S5
      0  324c					      db	29
      1  324c		       1d		      .byte.b	29
      0  324d					      dw	S5
      1  324d		       12 32		      .word.w	S5
    298  324f
    299  324f				   S7B
      0  324f					      SETR2	tInteger	; Print the value as a signed number
      0  324f					      db	94
      1  324f		       5e		      .byte.b	94
      0  3250					      db	tInteger
      1  3250		       a4		      .byte.b	tInteger
      0  3251					      PRN		; PRINT IT
      0  3251					      db	3
      1  3251		       03		      .byte.b	3
      0  3252					      IJMP	S5	; IS THERE MORE?
      0  3252					      db	29
      1  3252		       1d		      .byte.b	29
      0  3253					      dw	S5
      1  3253		       12 32		      .word.w	S5
    303  3255							;
    304  3255							;===========================================================
    305  3255							; PROCESS ALL THE TASK STATEMENTS
    306  3255							;
    307  3255							;S8:
    308  3255							;	  TSTB	      S8G,kTaske		 ; End Task
    309  3255				   ekTaske
      0  3255					      TSTB	S8NoParm,oLeftBracket
      0  3255					      db	101
      1  3255		       65		      .byte.b	101
      0  3256					      db	(S8NoParm-*)-1
      1  3256		       0c		      .byte.b	(S8NoParm-*)-1
      0  3257					      db	oLeftBracket
      1  3257		       e0		      .byte.b	oLeftBracket
      0  3258					      CALL	EXPR
      0  3258					      db	28
      1  3258		       1c		      .byte.b	28
      0  3259					      dw	EXPR
      1  3259		       92 33		      .word.w	EXPR
      0  325b					      TSTB	UNKNOWNLnk,oRightBracket
      0  325b					      db	101
      1  325b		       65		      .byte.b	101
      0  325c					      db	(UNKNOWNLnk-*)-1
      1  325c		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  325d					      db	oRightBracket
      1  325d		       e1		      .byte.b	oRightBracket
      0  325e					      ETASK
      0  325e					      db	62
      1  325e		       3e		      .byte.b	62
      0  325f					      DONE
      0  325f					      db	1
      1  325f		       01		      .byte.b	1
      0  3260					      IJMP	STMT
      0  3260					      db	29
      1  3260		       1d		      .byte.b	29
      0  3261					      dw	STMT
      1  3261		       7e 31		      .word.w	STMT
    316  3263				   S8NoParm
      0  3263					      LIT	0
      0  3263					      db	27
      1  3263		       1b		      .byte.b	27
      0  3264					      dw	0
      1  3264		       00 00		      .word.w	0
      0  3266					      ETASK
      0  3266					      db	62
      1  3266		       3e		      .byte.b	62
      0  3267					      DONE		; Must be last thing on a line
      0  3267					      db	1
      1  3267		       01		      .byte.b	1
      0  3268					      IJMP	STMT
      0  3268					      db	29
      1  3268		       1d		      .byte.b	29
      0  3269					      dw	STMT
      1  3269		       7e 31		      .word.w	STMT
    321  326b							;
    322  326b							;===========================================================
    323  326b							; The task gives up the rest of the cycles
    324  326b							;S8G:
    325  326b							;	  TSTB	      S8a,kTaskn	 ;Next task
    326  326b				   ekTaskn
      0  326b					      NTASK
      0  326b					      db	63
      1  326b		       3f		      .byte.b	63
      0  326c					      NXT	CO	;Next statement to execute
      0  326c					      db	6
      1  326c		       06		      .byte.b	6
      0  326d					      dw	CO
      1  326d		       76 31		      .word.w	CO
      0  326f					      IJMP	STMT
      0  326f					      db	29
      1  326f		       1d		      .byte.b	29
      0  3270					      dw	STMT
      1  3270		       7e 31		      .word.w	STMT
    330  3272							;
    331  3272							;===========================================================
    332  3272							; Waits for a task or list of tasks to complete
    333  3272
    334  3272				   ekTaskw
      0  3272					      TSTB	UNKNOWNLnk,oLeftBracket
      0  3272					      db	101
      1  3272		       65		      .byte.b	101
      0  3273					      db	(UNKNOWNLnk-*)-1
      1  3273		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  3274					      db	oLeftBracket
      1  3274		       e0		      .byte.b	oLeftBracket
    336  3275				   S8TSK
      0  3275					      Call	EXPR	;Gets the PID of task to wait for
      0  3275					      db	28
      1  3275		       1c		      .byte.b	28
      0  3276					      dw	EXPR
      1  3276		       92 33		      .word.w	EXPR
    338  3278				   S8LOOP
      0  3278					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  3278					      db	76
      1  3278		       4c		      .byte.b	76
      0  3279					      db	(S8LOOP-*)-1
      1  3279		       fe		      .byte.b	(S8LOOP-*)-1
      0  327a					      TSTB	S8aa,oComma	;Checks for more tasks
      0  327a					      db	101
      1  327a		       65		      .byte.b	101
      0  327b					      db	(S8aa-*)-1
      1  327b		       04		      .byte.b	(S8aa-*)-1
      0  327c					      db	oComma
      1  327c		       e2		      .byte.b	oComma
      0  327d					      IJMP	S8TSK	;Go for the next task number
      0  327d					      db	29
      1  327d		       1d		      .byte.b	29
      0  327e					      dw	S8TSK
      1  327e		       75 32		      .word.w	S8TSK
    342  3280				   S8aa
      0  3280					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  3280					      db	101
      1  3280		       65		      .byte.b	101
      0  3281					      db	(UNKNOWNLnk-*)-1
      1  3281		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  3282					      db	oRightBracket
      1  3282		       e1		      .byte.b	oRightBracket
      0  3283					      DONE
      0  3283					      db	1
      1  3283		       01		      .byte.b	1
      0  3284					      NXT	CO
      0  3284					      db	6
      1  3284		       06		      .byte.b	6
      0  3285					      dw	CO
      1  3285		       76 31		      .word.w	CO
      0  3287					      IJMP	STMT	;Next Statement
      0  3287					      db	29
      1  3287		       1d		      .byte.b	29
      0  3288					      dw	STMT
      1  3288		       7e 31		      .word.w	STMT
    347  328a
    348  328a
    349  328a
    350  328a				   UNKNOWNLnk
      0  328a					      iJMP	UNKNOWN
      0  328a					      db	29
      1  328a		       1d		      .byte.b	29
      0  328b					      dw	UNKNOWN
      1  328b		       8e 33		      .word.w	UNKNOWN
    352  328d
    353  328d							;
    354  328d							;===========================================================
    355  328d							; Update a memory location with a value
    356  328d							;  Use @[offset] to write a word value to memory
    357  328d							;
    358  328d							;S8a1:
    359  328d							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    360  328d				   ekPoke
      0  328d					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  328d					      db	101
      1  328d		       65		      .byte.b	101
      0  328e					      db	(UNKNOWNV-*)-1
      1  328e		       9c		      .byte.b	(UNKNOWNV-*)-1
      0  328f					      db	oLeftBracket
      1  328f		       e0		      .byte.b	oLeftBracket
      0  3290					      CALL	EXPR	; Get address to write to
      0  3290					      db	28
      1  3290		       1c		      .byte.b	28
      0  3291					      dw	EXPR
      1  3291		       92 33		      .word.w	EXPR
      0  3293					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  3293					      db	101
      1  3293		       65		      .byte.b	101
      0  3294					      db	(UNKNOWNV-*)-1
      1  3294		       96		      .byte.b	(UNKNOWNV-*)-1
      0  3295					      db	oComma
      1  3295		       e2		      .byte.b	oComma
      0  3296					      CALL	EXPR	; Get the value to poke
      0  3296					      db	28
      1  3296		       1c		      .byte.b	28
      0  3297					      dw	EXPR
      1  3297		       92 33		      .word.w	EXPR
      0  3299					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3299					      db	101
      1  3299		       65		      .byte.b	101
      0  329a					      db	(UNKNOWNV-*)-1
      1  329a		       90		      .byte.b	(UNKNOWNV-*)-1
      0  329b					      db	oRightBracket
      1  329b		       e1		      .byte.b	oRightBracket
      0  329c					      POKEMEM
      0  329c					      db	47
      1  329c		       2f		      .byte.b	47
      0  329d					      DONE
      0  329d					      db	1
      1  329d		       01		      .byte.b	1
      0  329e					      NXT	CO	;AND SEQUENCE TO NEXT
      0  329e					      db	6
      1  329e		       06		      .byte.b	6
      0  329f					      dw	CO
      1  329f		       76 31		      .word.w	CO
      0  32a1					      IJMP	STMT
      0  32a1					      db	29
      1  32a1		       1d		      .byte.b	29
      0  32a2					      dw	STMT
      1  32a2		       7e 31		      .word.w	STMT
    370  32a4							;
    371  32a4							;================================================================
    372  32a4							; Set a block of memory to a value word or byte
    373  32a4							; SetMem(Value, Length, Destination)
    374  32a4				   ekSetMemB
      0  32a4					      CALL	ekSetMem
      0  32a4					      db	28
      1  32a4		       1c		      .byte.b	28
      0  32a5					      dw	ekSetMem
      1  32a5		       bc 32		      .word.w	ekSetMem
      0  32a7					      SETBLOCK	tByte	; set value as byte
      0  32a7					      db	110
      1  32a7		       6e		      .byte.b	110
      0  32a8					      db	tByte
      1  32a8		       a2		      .byte.b	tByte
      0  32a9					      DONE
      0  32a9					      db	1
      1  32a9		       01		      .byte.b	1
      0  32aa					      NXT	CO
      0  32aa					      db	6
      1  32aa		       06		      .byte.b	6
      0  32ab					      dw	CO
      1  32ab		       76 31		      .word.w	CO
      0  32ad					      IJMP	STMT
      0  32ad					      db	29
      1  32ad		       1d		      .byte.b	29
      0  32ae					      dw	STMT
      1  32ae		       7e 31		      .word.w	STMT
    380  32b0
    381  32b0				   ekSetMemW
      0  32b0					      CALL	ekSetMem
      0  32b0					      db	28
      1  32b0		       1c		      .byte.b	28
      0  32b1					      dw	ekSetMem
      1  32b1		       bc 32		      .word.w	ekSetMem
      0  32b3					      SETBLOCK	tInteger	; set value as byte
      0  32b3					      db	110
      1  32b3		       6e		      .byte.b	110
      0  32b4					      db	tInteger
      1  32b4		       a4		      .byte.b	tInteger
      0  32b5					      DONE
      0  32b5					      db	1
      1  32b5		       01		      .byte.b	1
      0  32b6					      NXT	CO
      0  32b6					      db	6
      1  32b6		       06		      .byte.b	6
      0  32b7					      dw	CO
      1  32b7		       76 31		      .word.w	CO
      0  32b9					      IJMP	STMT
      0  32b9					      db	29
      1  32b9		       1d		      .byte.b	29
      0  32ba					      dw	STMT
      1  32ba		       7e 31		      .word.w	STMT
    387  32bc
    388  32bc				   ekSetMem
      0  32bc					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  32bc					      db	101
      1  32bc		       65		      .byte.b	101
      0  32bd					      db	(UNKNOWNV-*)-1
      1  32bd		       6d		      .byte.b	(UNKNOWNV-*)-1
      0  32be					      db	oLeftBracket
      1  32be		       e0		      .byte.b	oLeftBracket
      0  32bf					      CALL	EXPR	; Value to set
      0  32bf					      db	28
      1  32bf		       1c		      .byte.b	28
      0  32c0					      dw	EXPR
      1  32c0		       92 33		      .word.w	EXPR
      0  32c2					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  32c2					      db	101
      1  32c2		       65		      .byte.b	101
      0  32c3					      db	(UNKNOWNV-*)-1
      1  32c3		       67		      .byte.b	(UNKNOWNV-*)-1
      0  32c4					      db	oComma
      1  32c4		       e2		      .byte.b	oComma
      0  32c5					      CALL	EXPR	; Get The Length
      0  32c5					      db	28
      1  32c5		       1c		      .byte.b	28
      0  32c6					      dw	EXPR
      1  32c6		       92 33		      .word.w	EXPR
      0  32c8					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  32c8					      db	101
      1  32c8		       65		      .byte.b	101
      0  32c9					      db	(UNKNOWNV-*)-1
      1  32c9		       61		      .byte.b	(UNKNOWNV-*)-1
      0  32ca					      db	oComma
      1  32ca		       e2		      .byte.b	oComma
      0  32cb					      CALL	EXPR	; GET the address to start at
      0  32cb					      db	28
      1  32cb		       1c		      .byte.b	28
      0  32cc					      dw	EXPR
      1  32cc		       92 33		      .word.w	EXPR
      0  32ce					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  32ce					      db	101
      1  32ce		       65		      .byte.b	101
      0  32cf					      db	(UNKNOWNV-*)-1
      1  32cf		       5b		      .byte.b	(UNKNOWNV-*)-1
      0  32d0					      db	oRightBracket
      1  32d0		       e1		      .byte.b	oRightBracket
      0  32d1					      RTN
      0  32d1					      db	25
      1  32d1		       19		      .byte.b	25
    397  32d2							;
    398  32d2							;================================================================
    399  32d2							; Copy a block of memory
    400  32d2							; CopyMem(Length, Destination, Source)
    401  32d2				   ekCopyMem
      0  32d2					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  32d2					      db	101
      1  32d2		       65		      .byte.b	101
      0  32d3					      db	(UNKNOWNV-*)-1
      1  32d3		       57		      .byte.b	(UNKNOWNV-*)-1
      0  32d4					      db	oLeftBracket
      1  32d4		       e0		      .byte.b	oLeftBracket
      0  32d5					      CALL	EXPR	; Length
      0  32d5					      db	28
      1  32d5		       1c		      .byte.b	28
      0  32d6					      dw	EXPR
      1  32d6		       92 33		      .word.w	EXPR
      0  32d8					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  32d8					      db	101
      1  32d8		       65		      .byte.b	101
      0  32d9					      db	(UNKNOWNV-*)-1
      1  32d9		       51		      .byte.b	(UNKNOWNV-*)-1
      0  32da					      db	oComma
      1  32da		       e2		      .byte.b	oComma
      0  32db					      CALL	EXPR	; Destination
      0  32db					      db	28
      1  32db		       1c		      .byte.b	28
      0  32dc					      dw	EXPR
      1  32dc		       92 33		      .word.w	EXPR
      0  32de					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  32de					      db	101
      1  32de		       65		      .byte.b	101
      0  32df					      db	(UNKNOWNV-*)-1
      1  32df		       4b		      .byte.b	(UNKNOWNV-*)-1
      0  32e0					      db	oComma
      1  32e0		       e2		      .byte.b	oComma
      0  32e1					      CALL	EXPR	; Source
      0  32e1					      db	28
      1  32e1		       1c		      .byte.b	28
      0  32e2					      dw	EXPR
      1  32e2		       92 33		      .word.w	EXPR
      0  32e4					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  32e4					      db	101
      1  32e4		       65		      .byte.b	101
      0  32e5					      db	(UNKNOWNV-*)-1
      1  32e5		       45		      .byte.b	(UNKNOWNV-*)-1
      0  32e6					      db	oRightBracket
      1  32e6		       e1		      .byte.b	oRightBracket
      0  32e7					      COPYBLOCK		; Copy the memory
      0  32e7					      db	111
      1  32e7		       6f		      .byte.b	111
      0  32e8					      DONE
      0  32e8					      db	1
      1  32e8		       01		      .byte.b	1
      0  32e9					      NXT	CO
      0  32e9					      db	6
      1  32e9		       06		      .byte.b	6
      0  32ea					      dw	CO
      1  32ea		       76 31		      .word.w	CO
      0  32ec					      IJMP	STMT
      0  32ec					      db	29
      1  32ec		       1d		      .byte.b	29
      0  32ed					      dw	STMT
      1  32ed		       7e 31		      .word.w	STMT
    413  32ef
    414  32ef							;================================================================
    415  32ef							; Write a single byte to the output device
    416  32ef							;
    417  32ef				   ekPutch
      0  32ef					      CALL	EXPR
      0  32ef					      db	28
      1  32ef		       1c		      .byte.b	28
      0  32f0					      dw	EXPR
      1  32f0		       92 33		      .word.w	EXPR
      0  32f2					      PUTCHAR
      0  32f2					      db	52
      1  32f2		       34		      .byte.b	52
      0  32f3					      DONE
      0  32f3					      db	1
      1  32f3		       01		      .byte.b	1
      0  32f4					      NXT	CO	;AND SEQUENCE TO NEXT
      0  32f4					      db	6
      1  32f4		       06		      .byte.b	6
      0  32f5					      dw	CO
      1  32f5		       76 31		      .word.w	CO
      0  32f7					      IJMP	STMT
      0  32f7					      db	29
      1  32f7		       1d		      .byte.b	29
      0  32f8					      dw	STMT
      1  32f8		       7e 31		      .word.w	STMT
    423  32fa							;================================================================
    424  32fa							; Clear the screen lines
    425  32fa							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    426  32fa							;
    427  32fa				   ekCls
      0  32fa					      CLEARSCREEN
      0  32fa					      db	46
      1  32fa		       2e		      .byte.b	46
      0  32fb					      NXT	CO	;AND SEQUENCE TO NEXT
      0  32fb					      db	6
      1  32fb		       06		      .byte.b	6
      0  32fc					      dw	CO
      1  32fc		       76 31		      .word.w	CO
      0  32fe					      IJMP	STMT
      0  32fe					      db	29
      1  32fe		       1d		      .byte.b	29
      0  32ff					      dw	STMT
      1  32ff		       7e 31		      .word.w	STMT
    431  3301							;==================================================================
    432  3301							; Get input from the terminal
    433  3301							;   Reads from the currently active input device
    434  3301							;
    435  3301				   ekInput
    436  3301				   S10
      0  3301					      TSTB	S10A,tString	;If there is a string print the prompt
      0  3301					      db	101
      1  3301		       65		      .byte.b	101
      0  3302					      db	(S10A-*)-1
      1  3302		       05		      .byte.b	(S10A-*)-1
      0  3303					      db	tString
      1  3303		       a0		      .byte.b	tString
      0  3304					      PRS
      0  3304					      db	2
      1  3304		       02		      .byte.b	2
      0  3305					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  3305					      db	101
      1  3305		       65		      .byte.b	101
      0  3306					      db	(S10Z-*)-1
      1  3306		       19		      .byte.b	(S10Z-*)-1
      0  3307					      db	oSemiColon
      1  3307		       e3		      .byte.b	oSemiColon
    440  3308				   S10A
      0  3308					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  3308					      db	33
      1  3308		       21		      .byte.b	33
      0  3309					      db	(UNKNOWN-*)-1
      1  3309		       84		      .byte.b	(UNKNOWN-*)-1
      0  330a					      CALL	FactVarPtrNoTst
      0  330a					      db	28
      1  330a		       1c		      .byte.b	28
      0  330b					      dw	FactVarPtrNoTst
      1  330b		       31 35		      .word.w	FactVarPtrNoTst
    443  330d							;	  TSTB	     S10ACONT,oBang	      ; Print from another task
    444  330d							;	  IND
    445  330d							;	  TSTVT      UNKNOWN
    446  330d
    447  330d				   S10ACONT
      0  330d					      TSTB	S10A1,oDollar
      0  330d					      db	101
      1  330d		       65		      .byte.b	101
      0  330e					      db	(S10A1-*)-1
      1  330e		       07		      .byte.b	(S10A1-*)-1
      0  330f					      db	oDollar
      1  330f		       e7		      .byte.b	oDollar
      0  3310					      INSTR		;Move character From tty to AESTK
      0  3310					      db	59
      1  3310		       3b		      .byte.b	59
      0  3311					      SETR2	tByte
      0  3311					      db	94
      1  3311		       5e		      .byte.b	94
      0  3312					      db	tByte
      1  3312		       a2		      .byte.b	tByte
      0  3313					      IJMP	S10A2
      0  3313					      db	29
      1  3313		       1d		      .byte.b	29
      0  3314					      dw	S10A2
      1  3314		       19 33		      .word.w	S10A2
    452  3316				   S10A1
      0  3316					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  3316					      db	11
      1  3316		       0b		      .byte.b	11
      0  3317					      SETR2	tInteger
      0  3317					      db	94
      1  3317		       5e		      .byte.b	94
      0  3318					      db	tInteger
      1  3318		       a4		      .byte.b	tInteger
    455  3319				   S10A2
      0  3319					      STORE		;STORE IT
      0  3319					      db	19
      1  3319		       13		      .byte.b	19
      0  331a					      TSTB	S11,oComma	;IS THERE MORE?
      0  331a					      db	101
      1  331a		       65		      .byte.b	101
      0  331b					      db	(S11-*)-1
      1  331b		       07		      .byte.b	(S11-*)-1
      0  331c					      db	oComma
      1  331c		       e2		      .byte.b	oComma
      0  331d					      IJMP	S10	;YES
      0  331d					      db	29
      1  331d		       1d		      .byte.b	29
      0  331e					      dw	S10
      1  331e		       01 33		      .word.w	S10
    459  3320				   S10Z
      0  3320					      iJMP	UNKNOWN
      0  3320					      db	29
      1  3320		       1d		      .byte.b	29
      0  3321					      dw	UNKNOWN
      1  3321		       8e 33		      .word.w	UNKNOWN
    461  3323				   S11
      0  3323					      DONE		;MUST BE CR
      0  3323					      db	1
      1  3323		       01		      .byte.b	1
      0  3324					      NXT	CO	;SEQUENCE TO NEXT
      0  3324					      db	6
      1  3324		       06		      .byte.b	6
      0  3325					      dw	CO
      1  3325		       76 31		      .word.w	CO
      0  3327					      IJMP	STMT
      0  3327					      db	29
      1  3327		       1d		      .byte.b	29
      0  3328					      dw	STMT
      1  3328		       7e 31		      .word.w	STMT
    465  332a							;=====================================================================
    466  332a							; End of program, return to command line process
    467  332a							; Main Task may also use taske or return to stopped
    468  332a							;
    469  332a				   ekEnd
      0  332a					      FIN
      0  332a					      db	12
      1  332a		       0c		      .byte.b	12
    471  332b				   UNKNOWNV
      0  332b					      IJMP	UNKNOWN
      0  332b					      db	29
      1  332b		       1d		      .byte.b	29
      0  332c					      dw	UNKNOWN
      1  332c		       8e 33		      .word.w	UNKNOWN
    473  332e							;====================================================================
    474  332e							; IRQ <IRQ-HANDLER-Line expression>
    475  332e							;   Specify a line number subroutine to call when an interupt is processed
    476  332e							;   These subroutines must use iret to return.
    477  332e							;
    478  332e				   ekIrq
      0  332e					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  332e					      db	28
      1  332e		       1c		      .byte.b	28
      0  332f					      dw	EXPR
      1  332f		       92 33		      .word.w	EXPR
      0  3331					      DONE		;must be CR
      0  3331					      db	1
      1  3331		       01		      .byte.b	1
      0  3332					      SETIRQ		;Set the line number now
      0  3332					      db	56
      1  3332		       38		      .byte.b	56
      0  3333					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  3333					      db	6
      1  3333		       06		      .byte.b	6
      0  3334					      dw	CO
      1  3334		       76 31		      .word.w	CO
      0  3336					      IJMP	STMT
      0  3336					      db	29
      1  3336		       1d		      .byte.b	29
      0  3337					      dw	STMT
      1  3337		       7e 31		      .word.w	STMT
    484  3339
    485  3339							;=========================================================================
    486  3339							; KILL PID-expression	 kill a running task
    487  3339							;  ignored of task has already stopped
    488  3339							;
    489  3339				   ekKill
      0  3339					      CALL	EXPR
      0  3339					      db	28
      1  3339		       1c		      .byte.b	28
      0  333a					      dw	EXPR
      1  333a		       92 33		      .word.w	EXPR
      0  333c					      DONE
      0  333c					      db	1
      1  333c		       01		      .byte.b	1
      0  333d					      TASKKILL
      0  333d					      db	65
      1  333d		       41		      .byte.b	65
      0  333e					      NXT	CO
      0  333e					      db	6
      1  333e		       06		      .byte.b	6
      0  333f					      dw	CO
      1  333f		       76 31		      .word.w	CO
      0  3341					      IJMP	STMT
      0  3341					      db	29
      1  3341		       1d		      .byte.b	29
      0  3342					      dw	STMT
      1  3342		       7e 31		      .word.w	STMT
    495  3344
    496  3344							;============================================================================
    497  3344							; List all program lines
    498  3344							;
    499  3344				   ekList
      0  3344					      DONE
      0  3344					      db	1
      1  3344		       01		      .byte.b	1
      0  3345					      LST
      0  3345					      db	21
      1  3345		       15		      .byte.b	21
      0  3346					      IJMP	CO
      0  3346					      db	29
      1  3346		       1d		      .byte.b	29
      0  3347					      dw	CO
      1  3347		       76 31		      .word.w	CO
    503  3349							;=======================================================================
    504  3349							;RUN begin to executed the program in memory
    505  3349							;
    506  3349				   ekRun
      0  3349					      DONE
      0  3349					      db	1
      1  3349		       01		      .byte.b	1
      0  334a					      VINIT		;clear variables compile the line numbers
      0  334a					      db	30
      1  334a		       1e		      .byte.b	30
      0  334b					      LIT	1	;GOTO line 1
      0  334b					      db	27
      1  334b		       1b		      .byte.b	27
      0  334c					      dw	1
      1  334c		       01 00		      .word.w	1
      0  334e					      XFER		;Bob's addition
      0  334e					      db	7
      1  334e		       07		      .byte.b	7
    511  334f							; EXIT
      0  334f					      IJMP	STMT	;and run!
      0  334f					      db	29
      1  334f		       1d		      .byte.b	29
      0  3350					      dw	STMT
      1  3350		       7e 31		      .word.w	STMT
    513  3352							;=========================================================================
    514  3352							;Clear the program memory, delete all proram lines
    515  3352							;
    516  3352				   ekNew
      0  3352					      DONE
      0  3352					      db	1
      1  3352		       01		      .byte.b	1
      0  3353					      IJMP	START
      0  3353					      db	29
      1  3353		       1d		      .byte.b	29
      0  3354					      dw	START
      1  3354		       70 31		      .word.w	START
    519  3356
    520  3356							;========================================================================
    521  3356							; Slice(slice legth expression)
    522  3356							;   set the length of time between task switches
    523  3356							;
    524  3356				   ekSlice
      0  3356					      CALL	EXPR
      0  3356					      db	28
      1  3356		       1c		      .byte.b	28
      0  3357					      dw	EXPR
      1  3357		       92 33		      .word.w	EXPR
      0  3359					      SLICE
      0  3359					      db	100
      1  3359		       64		      .byte.b	100
      0  335a					      DONE
      0  335a					      db	1
      1  335a		       01		      .byte.b	1
      0  335b					      NXT	CO
      0  335b					      db	6
      1  335b		       06		      .byte.b	6
      0  335c					      dw	CO
      1  335c		       76 31		      .word.w	CO
      0  335e					      IJMP	STMT
      0  335e					      db	29
      1  335e		       1d		      .byte.b	29
      0  335f					      dw	STMT
      1  335f		       7e 31		      .word.w	STMT
    530  3361							;==========================================================================
    531  3361							; Turn off and on the thrace functions
    532  3361							; a debug terminal needs to be available
    533  3361							; Trace( Trace flag expression)
    534  3361							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    535  3361							;	for individual lines of basic code. These can be combined
    536  3361				   ekTrace
      0  3361					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  3361					      db	101
      1  3361		       65		      .byte.b	101
      0  3362					      db	(UNKNOWN-*)-1
      1  3362		       2b		      .byte.b	(UNKNOWN-*)-1
      0  3363					      db	oLeftBracket
      1  3363		       e0		      .byte.b	oLeftBracket
      0  3364					      CALL	EXPR
      0  3364					      db	28
      1  3364		       1c		      .byte.b	28
      0  3365					      dw	EXPR
      1  3365		       92 33		      .word.w	EXPR
      0  3367					      TSTB	UNKNOWN,oRightBracket
      0  3367					      db	101
      1  3367		       65		      .byte.b	101
      0  3368					      db	(UNKNOWN-*)-1
      1  3368		       25		      .byte.b	(UNKNOWN-*)-1
      0  3369					      db	oRightBracket
      1  3369		       e1		      .byte.b	oRightBracket
      0  336a					      TRACEPROGRAM
      0  336a					      db	78
      1  336a		       4e		      .byte.b	78
      0  336b					      DONE
      0  336b					      db	1
      1  336b		       01		      .byte.b	1
      0  336c					      NXT	CO
      0  336c					      db	6
      1  336c		       06		      .byte.b	6
      0  336d					      dw	CO
      1  336d		       76 31		      .word.w	CO
      0  336f					      IJMP	STMT
      0  336f					      db	29
      1  336f		       1d		      .byte.b	29
      0  3370					      dw	STMT
      1  3370		       7e 31		      .word.w	STMT
    544  3372							;=====================================================================
    545  3372							; Exit basic to machine monitor
    546  3372							;
    547  3372				   ekExit
      0  3372					      EXIT
      0  3372					      db	26
      1  3372		       1a		      .byte.b	26
    549  3373
    550  3373							;=======================================================================
    551  3373							; Commands related to saving/restoring programs
    552  3373							; to/from mass storage.
    553  3373							;=======================================================================
    554  3373							; Save a program file
    555  3373							;
    556  3373					      if	(XKIM || CTMON65) && DISK_ACCESS
    557  3373
    558  3373				   ekSave
      0  3373					      OPENWRITE	OPEN_CREATE
      0  3373					      db	40
      1  3373		       28		      .byte.b	40
      0  3374					      db	OPEN_CREATE
      1  3374		       01		      .byte.b	OPEN_CREATE
      0  3375					      DLIST
      0  3375					      db	43
      1  3375		       2b		      .byte.b	43
      0  3376					      DCLOSE
      0  3376					      db	41
      1  3376		       29		      .byte.b	41
      0  3377					      IJMP	CO
      0  3377					      db	29
      1  3377		       1d		      .byte.b	29
      0  3378					      dw	CO
      1  3378		       76 31		      .word.w	CO
    563  337a							;=========================================================================
    564  337a							; Load a program file
    565  337a							;
    566  337a				   ekLoad
      0  337a					      OPENREAD
      0  337a					      db	39
      1  337a		       27		      .byte.b	39
    568  337b				   S17CLP
      0  337b					      DGETLINE		;get line from file
      0  337b					      db	42
      1  337b		       2a		      .byte.b	42
      0  337c					      TSTL	S17EOL	;no line num means EOL
      0  337c					      db	34
      1  337c		       22		      .byte.b	34
      0  337d					      db	(S17EOL-*)-1
      1  337d		       04		      .byte.b	(S17EOL-*)-1
      0  337e					      INSERT		;put it into the program
      0  337e					      db	24
      1  337e		       18		      .byte.b	24
      0  337f					      IJMP	S17CLP	;keep going
      0  337f					      db	29
      1  337f		       1d		      .byte.b	29
      0  3380					      dw	S17CLP
      1  3380		       7b 33		      .word.w	S17CLP
    573  3382				   S17EOL
      0  3382					      DCLOSE		;close disk file
      0  3382					      db	41
      1  3382		       29		      .byte.b	41
      0  3383					      IJMP	CO	;back to start
      0  3383					      db	29
      1  3383		       1d		      .byte.b	29
      0  3384					      dw	CO
      1  3384		       76 31		      .word.w	CO
    576  3386							;=========================================================================
    577  3386							; Display the directory content
    578  3386							;
    579  3386				   ekDir
      0  3386					      DDIR		;Display the directory content
      0  3386					      db	44
      1  3386		       2c		      .byte.b	44
      0  3387					      IJMP	CO
      0  3387					      db	29
      1  3387		       1d		      .byte.b	29
      0  3388					      dw	CO
      1  3388		       76 31		      .word.w	CO
    582  338a							;=========================================================================
    583  338a							; Erase a file from disk
    584  338a							;
    585  338a				   ekErase
      0  338a					      RMFILE		;Erase the file from the disk
      0  338a					      db	45
      1  338a		       2d		      .byte.b	45
      0  338b					      IJMP	CO
      0  338b					      db	29
      1  338b		       1d		      .byte.b	29
      0  338c					      dw	CO
      1  338c		       76 31		      .word.w	CO
    588  338e
    589  338e					      endif
    590  338e
    591  338e							;===========================================================================
    592  338e							; Else, unknown command.
    593  338e							;
    594  338e				   UNKNOWN
      0  338e					      ENDIO
      0  338e					      db	71
      1  338e		       47		      .byte.b	71
    596  338f
    597  338f				   NotKnownStatement
    598  338f
      0  338f					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  338f					      db	13
      1  338f		       0d		      .byte.b	13
      0  3390					      dw	ERR_SYNTAX
      1  3390		       05 00		      .word.w	ERR_SYNTAX
    600  3392
    601  3392							;=======================================================
    602  3392							; Process Expresions, precidence is represented by the
    603  3392							; various call levels
    604  3392							;
    605  3392				   EXPR
      0  3392					      TSTB	EXPRLOGS,kNot
      0  3392					      db	101
      1  3392		       65		      .byte.b	101
      0  3393					      db	(EXPRLOGS-*)-1
      1  3393		       06		      .byte.b	(EXPRLOGS-*)-1
      0  3394					      db	kNot
      1  3394		       24		      .byte.b	kNot
    607  3395				   ekNot
      0  3395					      Call	EXPR
      0  3395					      db	28
      1  3395		       1c		      .byte.b	28
      0  3396					      dw	EXPR
      1  3396		       92 33		      .word.w	EXPR
      0  3398					      LOGNOT
      0  3398					      db	72
      1  3398		       48		      .byte.b	72
      0  3399					      RTN
      0  3399					      db	25
      1  3399		       19		      .byte.b	25
    611  339a
    612  339a							;=========================================================
    613  339a							;Look for logical operators, but does get first part of expression
    614  339a				   EXPRLOGS
      0  339a					      Call	EXPRCMP
      0  339a					      db	28
      1  339a		       1c		      .byte.b	28
      0  339b					      dw	EXPRCMP
      1  339b		       c2 33		      .word.w	EXPRCMP
    616  339d							;=========================================================
    617  339d							;Look for shift left and shift right level
    618  339d				   EXPSHIFT
      0  339d					      OnGoto	BasicShift,EXPRLOGICAL
      0  339d					      db	103
      1  339d		       67		      .byte.b	103
      0  339e					      dw	BasicShift
      1  339e		       46 31		      .word.w	BasicShift
      0  33a0					      dw	EXPRLOGICAL
      1  33a0		       ae 33		      .word.w	EXPRLOGICAL
    620  33a2
    621  33a2				   ekShiftLeft
      0  33a2					      Call	EXPR
      0  33a2					      db	28
      1  33a2		       1c		      .byte.b	28
      0  33a3					      dw	EXPR
      1  33a3		       92 33		      .word.w	EXPR
      0  33a5					      SHIFT	0
      0  33a5					      db	113
      1  33a5		       71		      .byte.b	113
      0  33a6					      db	0
      1  33a6		       00		      .byte.b	0
      0  33a7					      RTN
      0  33a7					      db	25
      1  33a7		       19		      .byte.b	25
    625  33a8
    626  33a8				   ekShiftRight
      0  33a8					      Call	EXPR
      0  33a8					      db	28
      1  33a8		       1c		      .byte.b	28
      0  33a9					      dw	EXPR
      1  33a9		       92 33		      .word.w	EXPR
      0  33ab					      SHIFT	1
      0  33ab					      db	113
      1  33ab		       71		      .byte.b	113
      0  33ac					      db	1
      1  33ac		       01		      .byte.b	1
      0  33ad					      RTN
      0  33ad					      db	25
      1  33ad		       19		      .byte.b	25
    630  33ae
    631  33ae							;======================================================================
    632  33ae				   EXPRLOGICAL
      0  33ae					      OnGoto	BasicLogical,iLOGExit
      0  33ae					      db	103
      1  33ae		       67		      .byte.b	103
      0  33af					      dw	BasicLogical
      1  33af		       3e 31		      .word.w	BasicLogical
      0  33b1					      dw	iLOGExit
      1  33b1		       c1 33		      .word.w	iLOGExit
    634  33b3				   ekAnd
      0  33b3					      Call	EXPR
      0  33b3					      db	28
      1  33b3		       1c		      .byte.b	28
      0  33b4					      dw	EXPR
      1  33b4		       92 33		      .word.w	EXPR
      0  33b6					      LOGAND
      0  33b6					      db	74
      1  33b6		       4a		      .byte.b	74
      0  33b7					      RTN
      0  33b7					      db	25
      1  33b7		       19		      .byte.b	25
    638  33b8				   ekOr
      0  33b8					      Call	EXPR
      0  33b8					      db	28
      1  33b8		       1c		      .byte.b	28
      0  33b9					      dw	EXPR
      1  33b9		       92 33		      .word.w	EXPR
      0  33bb					      LOGOR
      0  33bb					      db	73
      1  33bb		       49		      .byte.b	73
      0  33bc					      RTN
      0  33bc					      db	25
      1  33bc		       19		      .byte.b	25
    642  33bd				   ekXor
      0  33bd					      Call	EXPR
      0  33bd					      db	28
      1  33bd		       1c		      .byte.b	28
      0  33be					      dw	EXPR
      1  33be		       92 33		      .word.w	EXPR
      0  33c0					      LOGXOR
      0  33c0					      db	75
      1  33c0		       4b		      .byte.b	75
    645  33c1				   iLOGExit
      0  33c1					      RTN
      0  33c1					      db	25
      1  33c1		       19		      .byte.b	25
    647  33c2							;========================================================================
    648  33c2							; Process relational operators
    649  33c2							;
    650  33c2				   EXPRCMP
      0  33c2					      Call	EXPR2	; get the left first expression
      0  33c2					      db	28
      1  33c2		       1c		      .byte.b	28
      0  33c3					      dw	EXPR2
      1  33c3		       cd 33		      .word.w	EXPR2
      0  33c5					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  33c5					      db	104
      1  33c5		       68		      .byte.b	104
      0  33c6					      db	(iRDone-*)-1
      1  33c6		       05		      .byte.b	(iRDone-*)-1
    653  33c7							;	  TSTB	     iR0,oEqual
    654  33c7							;	  LIT	     2		     ;=
    655  33c7							;	  IJMP	     iRFound
    656  33c7							;iR0:
    657  33c7							;	  TSTB	      iR1,oLessEqual
    658  33c7							;	  LIT	      3 	      ;<=
    659  33c7							;	  IJMP	     iRFound
    660  33c7							;iR1:
    661  33c7							;	  TSTB	     iR3,oNotEqual
    662  33c7							;	  LIT	     5		      ;<>
    663  33c7							;	      IJMP	  iRFound
    664  33c7							;iR3:
    665  33c7							;	  TSTB	     iR4,oLess
    666  33c7							;	  LIT	     1		     ;<
    667  33c7							;	      IJMP	  iRFound
    668  33c7							;iR4:
    669  33c7							;	  TST	     iR5,oGreaterEqual
    670  33c7							;	  LIT	     6		     ;>=
    671  33c7							;	      IJMP	  iRFound
    672  33c7							;iR5:
    673  33c7							;	  TSTB	     iRDone,oGreater
    674  33c7							;	  LIT	     4		     ;>
    675  33c7				   iRFound
      0  33c7					      Call	EXPR	; get the right side of the expression
      0  33c7					      db	28
      1  33c7		       1c		      .byte.b	28
      0  33c8					      dw	EXPR
      1  33c8		       92 33		      .word.w	EXPR
      0  33ca					      CMPR		; Push the value of the true false onto the stack
      0  33ca					      db	10
      1  33ca		       0a		      .byte.b	10
      0  33cb					      RTN
      0  33cb					      db	25
      1  33cb		       19		      .byte.b	25
    679  33cc
    680  33cc				   iRDone
      0  33cc					      RTN
      0  33cc					      db	25
      1  33cc		       19		      .byte.b	25
    682  33cd
    683  33cd				   EXPR2
      0  33cd					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  33cd					      db	101
      1  33cd		       65		      .byte.b	101
      0  33ce					      db	(E0-*)-1
      1  33ce		       08		      .byte.b	(E0-*)-1
      0  33cf					      db	oMinus
      1  33cf		       eb		      .byte.b	oMinus
      0  33d0					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  33d0					      db	28
      1  33d0		       1c		      .byte.b	28
      0  33d1					      dw	TERM
      1  33d1		       f3 33		      .word.w	TERM
      0  33d3					      NEG		; Make value negated
      0  33d3					      db	16
      1  33d3		       10		      .byte.b	16
      0  33d4					      IJMP	E1	; We have Left term process operators next
      0  33d4					      db	29
      1  33d4		       1d		      .byte.b	29
      0  33d5					      dw	E1
      1  33d5		       dd 33		      .word.w	E1
    688  33d7				   E0
      0  33d7					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  33d7					      db	101
      1  33d7		       65		      .byte.b	101
      0  33d8					      db	(E1A-*)-1
      1  33d8		       01		      .byte.b	(E1A-*)-1
      0  33d9					      db	oPlus
      1  33d9		       ea		      .byte.b	oPlus
    690  33da				   E1A
      0  33da					      CALL	TERM	; Get the left term if it was not negated
      0  33da					      db	28
      1  33da		       1c		      .byte.b	28
      0  33db					      dw	TERM
      1  33db		       f3 33		      .word.w	TERM
    692  33dd				   E1
      0  33dd					      TST	E2,oPlus	; Check if we are adding left term to something
      0  33dd					      db	32
      1  33dd		       20		      .byte.b	32
      0  33de					      db	(E2-*)-1
      1  33de		       09		      .byte.b	(E2-*)-1
      0  33df					      db	oPlus,0
      1  33df		       ea 00		      .byte.b	oPlus,0
      0  33e1					      CALL	TERM	; if adding then get the right side term
      0  33e1					      db	28
      1  33e1		       1c		      .byte.b	28
      0  33e2					      dw	TERM
      1  33e2		       f3 33		      .word.w	TERM
      0  33e4					      ADD		; Add it to left term
      0  33e4					      db	14
      1  33e4		       0e		      .byte.b	14
      0  33e5					      IJMP	E1	; look for next + or -
      0  33e5					      db	29
      1  33e5		       1d		      .byte.b	29
      0  33e6					      dw	E1
      1  33e6		       dd 33		      .word.w	E1
    697  33e8				   E2
      0  33e8					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  33e8					      db	101
      1  33e8		       65		      .byte.b	101
      0  33e9					      db	(E3-*)-1
      1  33e9		       08		      .byte.b	(E3-*)-1
      0  33ea					      db	oMinus
      1  33ea		       eb		      .byte.b	oMinus
      0  33eb					      CALL	TERM	; get right side to subtract Diffrence
      0  33eb					      db	28
      1  33eb		       1c		      .byte.b	28
      0  33ec					      dw	TERM
      1  33ec		       f3 33		      .word.w	TERM
      0  33ee					      SUB		; Subtract the value
      0  33ee					      db	15
      1  33ee		       0f		      .byte.b	15
      0  33ef					      IJMP	E1	; Look for next + or -
      0  33ef					      db	29
      1  33ef		       1d		      .byte.b	29
      0  33f0					      dw	E1
      1  33f0		       dd 33		      .word.w	E1
    702  33f2				   E3			; Finish processing the expression
      0  33f2					      RTN		; We are finished processing the Expression
      0  33f2					      db	25
      1  33f2		       19		      .byte.b	25
    704  33f3							;
    705  33f3							; Get one of the terms of an expression
    706  33f3							;
    707  33f3				   TERM
      0  33f3					      CALL	FACT	; Get a value
      0  33f3					      db	28
      1  33f3		       1c		      .byte.b	28
      0  33f4					      dw	FACT
      1  33f4		       18 34		      .word.w	FACT
    709  33f6				   T0			; Check for higher precidence operators
      0  33f6					      TSTB	T1,oMultiply	; Check for *
      0  33f6					      db	101
      1  33f6		       65		      .byte.b	101
      0  33f7					      db	(T1-*)-1
      1  33f7		       08		      .byte.b	(T1-*)-1
      0  33f8					      db	oMultiply
      1  33f8		       ee		      .byte.b	oMultiply
      0  33f9					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  33f9					      db	28
      1  33f9		       1c		      .byte.b	28
      0  33fa					      dw	FACT
      1  33fa		       18 34		      .word.w	FACT
      0  33fc					      MUL		; Multiply factors
      0  33fc					      db	17
      1  33fc		       11		      .byte.b	17
      0  33fd					      IJMP	T0	; Check for * or /
      0  33fd					      db	29
      1  33fd		       1d		      .byte.b	29
      0  33fe					      dw	T0
      1  33fe		       f6 33		      .word.w	T0
    714  3400				   T1
      0  3400					      TSTB	T2,oDivide	; Check for a division
      0  3400					      db	101
      1  3400		       65		      .byte.b	101
      0  3401					      db	(T2-*)-1
      1  3401		       08		      .byte.b	(T2-*)-1
      0  3402					      db	oDivide
      1  3402		       ec		      .byte.b	oDivide
      0  3403					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  3403					      db	28
      1  3403		       1c		      .byte.b	28
      0  3404					      dw	FACT
      1  3404		       18 34		      .word.w	FACT
      0  3406					      DIV		; do division
      0  3406					      db	18
      1  3406		       12		      .byte.b	18
      0  3407					      IJMP	T0	; check for more * or /
      0  3407					      db	29
      1  3407		       1d		      .byte.b	29
      0  3408					      dw	T0
      1  3408		       f6 33		      .word.w	T0
    719  340a				   T2
      0  340a					      TSTB	T3,oModulo	; Check for a division
      0  340a					      db	101
      1  340a		       65		      .byte.b	101
      0  340b					      db	(T3-*)-1
      1  340b		       08		      .byte.b	(T3-*)-1
      0  340c					      db	oModulo
      1  340c		       ed		      .byte.b	oModulo
      0  340d					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  340d					      db	28
      1  340d		       1c		      .byte.b	28
      0  340e					      dw	FACT
      1  340e		       18 34		      .word.w	FACT
      0  3410					      MODULO		; do division for remainder
      0  3410					      db	60
      1  3410		       3c		      .byte.b	60
      0  3411					      IJMP	T0	; check for more * or / or %
      0  3411					      db	29
      1  3411		       1d		      .byte.b	29
      0  3412					      dw	T0
      1  3412		       f6 33		      .word.w	T0
    724  3414				   T3			; Finish processing the Term
      0  3414					      RTN
      0  3414					      db	25
      1  3414		       19		      .byte.b	25
    726  3415
    727  3415				   UNKNOWNVEC
      0  3415					      IJMP	UNKNOWN
      0  3415					      db	29
      1  3415		       1d		      .byte.b	29
      0  3416					      dw	UNKNOWN
      1  3416		       8e 33		      .word.w	UNKNOWN
    729  3418
    730  3418							;=============================================================================================
    731  3418							; Factor an expression.  Always test for functions
    732  3418							; first or else they'll be confused for variables.
    733  3418							;
    734  3418				   FACT
      0  3418					      OnGoto	BasicFuncs,FactNumber
      0  3418					      db	103
      1  3418		       67		      .byte.b	103
      0  3419					      dw	BasicFuncs
      1  3419		       4c 31		      .word.w	BasicFuncs
      0  341b					      dw	FactNumber
      1  341b		       01 35		      .word.w	FactNumber
    736  341d
    737  341d							;FACTCONTINUE:
    738  341d							;	  TSTB	     F1AA,kTrue
    739  341d				   ekTrue
      0  341d					      LIT	-1
      0  341d					      db	27
      1  341d		       1b		      .byte.b	27
      0  341e					      dw	-1
      1  341e		       ff ff		      .word.w	-1
      0  3420					      RTN
      0  3420					      db	25
      1  3420		       19		      .byte.b	25
    742  3421							;F1AA:
    743  3421							;	  TSTB	     F1AB,kFalse
    744  3421				   ekFalse
      0  3421					      LIT	0
      0  3421					      db	27
      1  3421		       1b		      .byte.b	27
      0  3422					      dw	0
      1  3422		       00 00		      .word.w	0
      0  3424					      RTN
      0  3424					      db	25
      1  3424		       19		      .byte.b	25
    747  3425							;==================================================================================
    748  3425							; Returns the amount of free SPACE
    749  3425				   ekFree
      0  3425					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3425					      db	101
      1  3425		       65		      .byte.b	101
      0  3426					      db	(UNKNOWNVEC-*)-1
      1  3426		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  3427					      db	oLeftBracket
      1  3427		       e0		      .byte.b	oLeftBracket
      0  3428					      TSTB	UNKNOWNVEC,oRightBracket
      0  3428					      db	101
      1  3428		       65		      .byte.b	101
      0  3429					      db	(UNKNOWNVEC-*)-1
      1  3429		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  342a					      db	oRightBracket
      1  342a		       e1		      .byte.b	oRightBracket
      0  342b					      FREE
      0  342b					      db	36
      1  342b		       24		      .byte.b	36
      0  342c					      RTN
      0  342c					      db	25
      1  342c		       19		      .byte.b	25
    754  342d							;===================================================================================
    755  342d							; getch() read a character from the input device
    756  342d							;
    757  342d				   ekGetch
      0  342d					      TSTB	UNKNOWNVEC,oLeftBracket
      0  342d					      db	101
      1  342d		       65		      .byte.b	101
      0  342e					      db	(UNKNOWNVEC-*)-1
      1  342e		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  342f					      db	oLeftBracket
      1  342f		       e0		      .byte.b	oLeftBracket
      0  3430					      TSTB	UNKNOWNVEC,oRightBracket
      0  3430					      db	101
      1  3430		       65		      .byte.b	101
      0  3431					      db	(UNKNOWNVEC-*)-1
      1  3431		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  3432					      db	oRightBracket
      1  3432		       e1		      .byte.b	oRightBracket
      0  3433					      GETCHAR
      0  3433					      db	51
      1  3433		       33		      .byte.b	51
      0  3434					      RTN
      0  3434					      db	25
      1  3434		       19		      .byte.b	25
    762  3435							;
    763  3435							;====================================================================================
    764  3435							; addr(variable definition)
    765  3435							; Returns the address of a variable on top of the stack
    766  3435				   ekAddr
      0  3435					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3435					      db	101
      1  3435		       65		      .byte.b	101
      0  3436					      db	(UNKNOWNVEC-*)-1
      1  3436		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  3437					      db	oLeftBracket
      1  3437		       e0		      .byte.b	oLeftBracket
      0  3438					      TSTV	ExpectedVariable
      0  3438					      db	33
      1  3438		       21		      .byte.b	33
      0  3439					      db	(ExpectedVariable-*)-1
      1  3439		       07		      .byte.b	(ExpectedVariable-*)-1
      0  343a					      CALL	FactVarPtrNoTst
      0  343a					      db	28
      1  343a		       1c		      .byte.b	28
      0  343b					      dw	FactVarPtrNoTst
      1  343b		       31 35		      .word.w	FactVarPtrNoTst
      0  343d					      TSTB	UNKNOWNVEC,oRightBracket
      0  343d					      db	101
      1  343d		       65		      .byte.b	101
      0  343e					      db	(UNKNOWNVEC-*)-1
      1  343e		       d6		      .byte.b	(UNKNOWNVEC-*)-1
      0  343f					      db	oRightBracket
      1  343f		       e1		      .byte.b	oRightBracket
      0  3440					      RTN
      0  3440					      db	25
      1  3440		       19		      .byte.b	25
    772  3441
    773  3441				   ExpectedVariable
      0  3441					      ERRMSG	ERR_SYNTAX	;Expected Variable
      0  3441					      db	13
      1  3441		       0d		      .byte.b	13
      0  3442					      dw	ERR_SYNTAX
      1  3442		       05 00		      .word.w	ERR_SYNTAX
    775  3444							;
    776  3444							;================================================================
    777  3444							; Compare a block of memory
    778  3444							; CmpMem(Length, Source 1, Source 2)
    779  3444							; returns on the stack 0 equal, 1 s1>s2, -1 s1<s2
    780  3444				   ekCmpMem
      0  3444					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  3444					      db	101
      1  3444		       65		      .byte.b	101
      0  3445					      db	(UNKNOWNVEC-*)-1
      1  3445		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  3446					      db	oLeftBracket
      1  3446		       e0		      .byte.b	oLeftBracket
      0  3447					      CALL	EXPR	; Length
      0  3447					      db	28
      1  3447		       1c		      .byte.b	28
      0  3448					      dw	EXPR
      1  3448		       92 33		      .word.w	EXPR
      0  344a					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  344a					      db	101
      1  344a		       65		      .byte.b	101
      0  344b					      db	(UNKNOWNVEC-*)-1
      1  344b		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  344c					      db	oComma
      1  344c		       e2		      .byte.b	oComma
      0  344d					      CALL	EXPR	; Source 1
      0  344d					      db	28
      1  344d		       1c		      .byte.b	28
      0  344e					      dw	EXPR
      1  344e		       92 33		      .word.w	EXPR
      0  3450					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  3450					      db	101
      1  3450		       65		      .byte.b	101
      0  3451					      db	(UNKNOWNVEC-*)-1
      1  3451		       c3		      .byte.b	(UNKNOWNVEC-*)-1
      0  3452					      db	oComma
      1  3452		       e2		      .byte.b	oComma
      0  3453					      CALL	EXPR	; Source 2
      0  3453					      db	28
      1  3453		       1c		      .byte.b	28
      0  3454					      dw	EXPR
      1  3454		       92 33		      .word.w	EXPR
      0  3456					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  3456					      db	101
      1  3456		       65		      .byte.b	101
      0  3457					      db	(UNKNOWNVEC-*)-1
      1  3457		       bd		      .byte.b	(UNKNOWNVEC-*)-1
      0  3458					      db	oRightBracket
      1  3458		       e1		      .byte.b	oRightBracket
      0  3459					      CMPMEM		; Compare the memory
      0  3459					      db	112
      1  3459		       70		      .byte.b	112
      0  345a					      RTN
      0  345a					      db	25
      1  345a		       19		      .byte.b	25
    790  345b							;====================================================================================
    791  345b							; peek(mem address) return the value of a byte in memory
    792  345b							; @[offset] return a word value from offset -- see tstv
    793  345b							;
    794  345b							;F1A2:
    795  345b							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    796  345b				   ekPeek
      0  345b					      TSTB	UNKNOWNVEC,oLeftBracket
      0  345b					      db	101
      1  345b		       65		      .byte.b	101
      0  345c					      db	(UNKNOWNVEC-*)-1
      1  345c		       b8		      .byte.b	(UNKNOWNVEC-*)-1
      0  345d					      db	oLeftBracket
      1  345d		       e0		      .byte.b	oLeftBracket
      0  345e					      CALL	EXPR	;Get the address to write to
      0  345e					      db	28
      1  345e		       1c		      .byte.b	28
      0  345f					      dw	EXPR
      1  345f		       92 33		      .word.w	EXPR
      0  3461					      TSTB	UNKNOWNVEC,oRightBracket
      0  3461					      db	101
      1  3461		       65		      .byte.b	101
      0  3462					      db	(UNKNOWNVEC-*)-1
      1  3462		       b2		      .byte.b	(UNKNOWNVEC-*)-1
      0  3463					      db	oRightBracket
      1  3463		       e1		      .byte.b	oRightBracket
      0  3464					      PEEKMEM
      0  3464					      db	48
      1  3464		       30		      .byte.b	48
      0  3465					      RTN
      0  3465					      db	25
      1  3465		       19		      .byte.b	25
    802  3466							;=======================================================================================
    803  3466							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    804  3466							;
    805  3466							;F2AZ:
    806  3466							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    807  3466				   ekTask
      0  3466					      TSTBRANCH	ekTaskCompiled
      0  3466					      db	106
      1  3466		       6a		      .byte.b	106
      0  3467					      db	(ekTaskCompiled-*)-1
      1  3467		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  3468					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3468					      db	101
      1  3468		       65		      .byte.b	101
      0  3469					      db	(UNKNOWNVEC-*)-1
      1  3469		       ab		      .byte.b	(UNKNOWNVEC-*)-1
      0  346a					      db	oLeftBracket
      1  346a		       e0		      .byte.b	oLeftBracket
      0  346b					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  346b					      db	28
      1  346b		       1c		      .byte.b	28
      0  346c					      dw	EXPR
      1  346c		       92 33		      .word.w	EXPR
      0  346e					      lit	0
      0  346e					      db	27
      1  346e		       1b		      .byte.b	27
      0  346f					      dw	0
      1  346f		       00 00		      .word.w	0
      0  3471					      iJMP	ekTaskLinenum
      0  3471					      db	29
      1  3471		       1d		      .byte.b	29
      0  3472					      dw	ekTaskLinenum
      1  3472		       77 34		      .word.w	ekTaskLinenum
    813  3474
    814  3474				   ekTaskCompiled
      0  3474					      lit	1
      0  3474					      db	27
      1  3474		       1b		      .byte.b	27
      0  3475					      dw	1
      1  3475		       01 00		      .word.w	1
    816  3477
    817  3477				   ekTaskLinenum
      0  3477					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  3477					      db	61
      1  3477		       3d		      .byte.b	61
      0  3478					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  3478					      db	101
      1  3478		       65		      .byte.b	101
      0  3479					      db	(F2AZNoParms-*)-1
      1  3479		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  347a					      db	oComma
      1  347a		       e2		      .byte.b	oComma
      0  347b					      SAVEMATHSTACK		;Push The mathstack
      0  347b					      db	86
      1  347b		       56		      .byte.b	86
      0  347c					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  347c					      db	89
      1  347c		       59		      .byte.b	89
    822  347d
    823  347d				   F2AZLOOP
      0  347d					      CALL	EXPR
      0  347d					      db	28
      1  347d		       1c		      .byte.b	28
      0  347e					      dw	EXPR
      1  347e		       92 33		      .word.w	EXPR
      0  3480					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  3480					      db	101
      1  3480		       65		      .byte.b	101
      0  3481					      db	(F2AZEndParm-*)-1
      1  3481		       04		      .byte.b	(F2AZEndParm-*)-1
      0  3482					      db	oComma
      1  3482		       e2		      .byte.b	oComma
      0  3483					      IJMP	F2AZLOOP	;check for more
      0  3483					      db	29
      1  3483		       1d		      .byte.b	29
      0  3484					      dw	F2AZLOOP
      1  3484		       7d 34		      .word.w	F2AZLOOP
    827  3486
    828  3486				   F2AZEndParm
      0  3486					      RESTOREMATHSTACK		;Back to normal stack
      0  3486					      db	87
      1  3486		       57		      .byte.b	87
      0  3487					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  3487					      db	92
      1  3487		       5c		      .byte.b	92
    831  3488
    832  3488				   F2AZNoParms
      0  3488					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  3488					      db	101
      1  3488		       65		      .byte.b	101
      0  3489					      db	(UNKNOWNVEC-*)-1
      1  3489		       8b		      .byte.b	(UNKNOWNVEC-*)-1
      0  348a					      db	oRightBracket
      1  348a		       e1		      .byte.b	oRightBracket
    834  348b
      0  348b					      TASKENABLE		;Enable the task to execute
      0  348b					      db	90
      1  348b		       5a		      .byte.b	90
    836  348c
      0  348c					      RTN		;Returns the Task number
      0  348c					      db	25
      1  348c		       19		      .byte.b	25
    838  348d							;=========================================================================================
    839  348d							; Check for IPC interproccess instructions
    840  348d							;   IPCS  - Send a message
    841  348d							;
    842  348d							;F2AZ1:
    843  348d							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    844  348d				   ekIpcs
      0  348d					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  348d					      db	101
      1  348d		       65		      .byte.b	101
      0  348e					      db	(UNKNOWNVEC-*)-1
      1  348e		       86		      .byte.b	(UNKNOWNVEC-*)-1
      0  348f					      db	oLeftBracket
      1  348f		       e0		      .byte.b	oLeftBracket
      0  3490					      CALL	EXPR	;Get the message value
      0  3490					      db	28
      1  3490		       1c		      .byte.b	28
      0  3491					      dw	EXPR
      1  3491		       92 33		      .word.w	EXPR
      0  3493					      TSTB	UNKNOWNVEC,oComma
      0  3493					      db	101
      1  3493		       65		      .byte.b	101
      0  3494					      db	(UNKNOWNVEC-*)-1
      1  3494		       80		      .byte.b	(UNKNOWNVEC-*)-1
      0  3495					      db	oComma
      1  3495		       e2		      .byte.b	oComma
      0  3496					      CALL	EXPR	;Get pid of task to send to
      0  3496					      db	28
      1  3496		       1c		      .byte.b	28
      0  3497					      dw	EXPR
      1  3497		       92 33		      .word.w	EXPR
      0  3499					      TSTB	UNKNOWNVEC,oRightBracket
      0  3499					      db	101
      1  3499		       65		      .byte.b	101
      0  349a					      db	(UNKNOWNVEC-*)-1
      1  349a		       7a		      .byte.b	(UNKNOWNVEC-*)-1
      0  349b					      db	oRightBracket
      1  349b		       e1		      .byte.b	oRightBracket
      0  349c					      IPCSEND		;Send msg and clear pid msg pending
      0  349c					      db	80
      1  349c		       50		      .byte.b	80
      0  349d					      RTN
      0  349d					      db	25
      1  349d		       19		      .byte.b	25
    852  349e							;================================================================================
    853  349e							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    854  349e							;
    855  349e				   ekIpcr
      0  349e					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  349e					      db	101
      1  349e		       65		      .byte.b	101
      0  349f					      db	(UNKNOWNVEC-*)-1
      1  349f		       75		      .byte.b	(UNKNOWNVEC-*)-1
      0  34a0					      db	oLeftBracket
      1  34a0		       e0		      .byte.b	oLeftBracket
      0  34a1					      TSTB	F2AZa1,oRightBracket
      0  34a1					      db	101
      1  34a1		       65		      .byte.b	101
      0  34a2					      db	(F2AZa1-*)-1
      1  34a2		       07		      .byte.b	(F2AZa1-*)-1
      0  34a3					      db	oRightBracket
      1  34a3		       e1		      .byte.b	oRightBracket
      0  34a4					      LIT	0	;We dont want the pid returned to us
      0  34a4					      db	27
      1  34a4		       1b		      .byte.b	27
      0  34a5					      dw	0
      1  34a5		       00 00		      .word.w	0
      0  34a7					      IJMP	ekIpcrComplete
      0  34a7					      db	29
      1  34a7		       1d		      .byte.b	29
      0  34a8					      dw	ekIpcrComplete
      1  34a8		       af 34		      .word.w	ekIpcrComplete
    860  34aa				   F2AZa1
      0  34aa					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  34aa					      db	33
      1  34aa		       21		      .byte.b	33
      0  34ab					      db	(UNKNOWNVEC-*)-1
      1  34ab		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  34ac					      TSTB	UNKNOWNVEC,oRightBracket
      0  34ac					      db	101
      1  34ac		       65		      .byte.b	101
      0  34ad					      db	(UNKNOWNVEC-*)-1
      1  34ad		       67		      .byte.b	(UNKNOWNVEC-*)-1
      0  34ae					      db	oRightBracket
      1  34ae		       e1		      .byte.b	oRightBracket
    863  34af
    864  34af				   ekIpcrComplete
      0  34af					      IPCIO		;Set the io bit and exit task till message
      0  34af					      db	83
      1  34af		       53		      .byte.b	83
      0  34b0					      IPCRECEIVE		;Get the message
      0  34b0					      db	81
      1  34b0		       51		      .byte.b	81
      0  34b1					      RTN
      0  34b1					      db	25
      1  34b1		       19		      .byte.b	25
    868  34b2							;===============================================================================
    869  34b2							; IPCC ---- check if a message is available
    870  34b2				   ekIpcc
      0  34b2					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34b2					      db	101
      1  34b2		       65		      .byte.b	101
      0  34b3					      db	(UNKNOWNVEC-*)-1
      1  34b3		       61		      .byte.b	(UNKNOWNVEC-*)-1
      0  34b4					      db	oLeftBracket
      1  34b4		       e0		      .byte.b	oLeftBracket
      0  34b5					      TSTB	UNKNOWNVEC,oRightBracket
      0  34b5					      db	101
      1  34b5		       65		      .byte.b	101
      0  34b6					      db	(UNKNOWNVEC-*)-1
      1  34b6		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  34b7					      db	oRightBracket
      1  34b7		       e1		      .byte.b	oRightBracket
      0  34b8					      IPCCHECK
      0  34b8					      db	82
      1  34b8		       52		      .byte.b	82
      0  34b9					      RTN
      0  34b9					      db	25
      1  34b9		       19		      .byte.b	25
    875  34ba
    876  34ba				   UNKNOWNID
      0  34ba					      IJMP	UNKNOWN
      0  34ba					      db	29
      1  34ba		       1d		      .byte.b	29
      0  34bb					      dw	UNKNOWN
      1  34bb		       8e 33		      .word.w	UNKNOWN
    878  34bd							;============================================================
    879  34bd							; RND() is supposed to have an argument but if none
    880  34bd							; was provided, just assume a large value.
    881  34bd							;
    882  34bd				   ekRnd
      0  34bd					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34bd					      db	101
      1  34bd		       65		      .byte.b	101
      0  34be					      db	(UNKNOWNVEC-*)-1
      1  34be		       56		      .byte.b	(UNKNOWNVEC-*)-1
      0  34bf					      db	oLeftBracket
      1  34bf		       e0		      .byte.b	oLeftBracket
      0  34c0					      TSTB	F2A1,oRightBracket
      0  34c0					      db	101
      1  34c0		       65		      .byte.b	101
      0  34c1					      db	(F2A1-*)-1
      1  34c1		       06		      .byte.b	(F2A1-*)-1
      0  34c2					      db	oRightBracket
      1  34c2		       e1		      .byte.b	oRightBracket
      0  34c3					      LIT	32766
      0  34c3					      db	27
      1  34c3		       1b		      .byte.b	27
      0  34c4					      dw	32766
      1  34c4		       fe 7f		      .word.w	32766
      0  34c6					      RANDOM
      0  34c6					      db	37
      1  34c6		       25		      .byte.b	37
      0  34c7					      RTN
      0  34c7					      db	25
      1  34c7		       19		      .byte.b	25
    888  34c8
    889  34c8				   F2A1
      0  34c8					      CALL	EXPR	;GET RANGE
      0  34c8					      db	28
      1  34c8		       1c		      .byte.b	28
      0  34c9					      dw	EXPR
      1  34c9		       92 33		      .word.w	EXPR
      0  34cb					      TSTB	UNKNOWNVEC,oRightBracket
      0  34cb					      db	101
      1  34cb		       65		      .byte.b	101
      0  34cc					      db	(UNKNOWNVEC-*)-1
      1  34cc		       48		      .byte.b	(UNKNOWNVEC-*)-1
      0  34cd					      db	oRightBracket
      1  34cd		       e1		      .byte.b	oRightBracket
      0  34ce					      RANDOM
      0  34ce					      db	37
      1  34ce		       25		      .byte.b	37
      0  34cf					      RTN
      0  34cf					      db	25
      1  34cf		       19		      .byte.b	25
    894  34d0							;==========================================================
    895  34d0							;	Return absolute value of expresion
    896  34d0							;
    897  34d0				   ekAbs
      0  34d0					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34d0					      db	101
      1  34d0		       65		      .byte.b	101
      0  34d1					      db	(UNKNOWNVEC-*)-1
      1  34d1		       43		      .byte.b	(UNKNOWNVEC-*)-1
      0  34d2					      db	oLeftBracket
      1  34d2		       e0		      .byte.b	oLeftBracket
      0  34d3					      CALL	EXPR	;get value
      0  34d3					      db	28
      1  34d3		       1c		      .byte.b	28
      0  34d4					      dw	EXPR
      1  34d4		       92 33		      .word.w	EXPR
      0  34d6					      TSTB	UNKNOWNVEC,oRightBracket
      0  34d6					      db	101
      1  34d6		       65		      .byte.b	101
      0  34d7					      db	(UNKNOWNVEC-*)-1
      1  34d7		       3d		      .byte.b	(UNKNOWNVEC-*)-1
      0  34d8					      db	oRightBracket
      1  34d8		       e1		      .byte.b	oRightBracket
      0  34d9					      ABS
      0  34d9					      db	38
      1  34d9		       26		      .byte.b	38
      0  34da					      RTN
      0  34da					      db	25
      1  34da		       19		      .byte.b	25
    903  34db							;============================================================
    904  34db							;     Return the the status of a task, provide the PID
    905  34db							;
    906  34db				   ekStat
      0  34db					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34db					      db	101
      1  34db		       65		      .byte.b	101
      0  34dc					      db	(UNKNOWNVEC-*)-1
      1  34dc		       38		      .byte.b	(UNKNOWNVEC-*)-1
      0  34dd					      db	oLeftBracket
      1  34dd		       e0		      .byte.b	oLeftBracket
      0  34de					      Call	EXPR
      0  34de					      db	28
      1  34de		       1c		      .byte.b	28
      0  34df					      dw	EXPR
      1  34df		       92 33		      .word.w	EXPR
      0  34e1					      TSTB	UNKNOWNVEC,oRightBracket
      0  34e1					      db	101
      1  34e1		       65		      .byte.b	101
      0  34e2					      db	(UNKNOWNVEC-*)-1
      1  34e2		       32		      .byte.b	(UNKNOWNVEC-*)-1
      0  34e3					      db	oRightBracket
      1  34e3		       e1		      .byte.b	oRightBracket
      0  34e4					      TASKSTAT
      0  34e4					      db	66
      1  34e4		       42		      .byte.b	66
      0  34e5					      RTN
      0  34e5					      db	25
      1  34e5		       19		      .byte.b	25
    912  34e6							;==============================================================
    913  34e6							; Return the current tasks pid
    914  34e6							;
    915  34e6				   ekPid
      0  34e6					      TASKPID
      0  34e6					      db	77
      1  34e6		       4d		      .byte.b	77
      0  34e7					      RTN
      0  34e7					      db	25
      1  34e7		       19		      .byte.b	25
    918  34e8							;===========================================================================
    919  34e8							; Call a machine function, provide the address to call and optionally
    920  34e8							; the value to be passed in reg A
    921  34e8				   ekCall
      0  34e8					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34e8					      db	101
      1  34e8		       65		      .byte.b	101
      0  34e9					      db	(UNKNOWNVEC-*)-1
      1  34e9		       2b		      .byte.b	(UNKNOWNVEC-*)-1
      0  34ea					      db	oLeftBracket
      1  34ea		       e0		      .byte.b	oLeftBracket
      0  34eb					      CALL	EXPR
      0  34eb					      db	28
      1  34eb		       1c		      .byte.b	28
      0  34ec					      dw	EXPR
      1  34ec		       92 33		      .word.w	EXPR
      0  34ee					      TSTB	F2B2A,oComma
      0  34ee					      db	101
      1  34ee		       65		      .byte.b	101
      0  34ef					      db	(F2B2A-*)-1
      1  34ef		       09		      .byte.b	(F2B2A-*)-1
      0  34f0					      db	oComma
      1  34f0		       e2		      .byte.b	oComma
      0  34f1					      CALL	EXPR
      0  34f1					      db	28
      1  34f1		       1c		      .byte.b	28
      0  34f2					      dw	EXPR
      1  34f2		       92 33		      .word.w	EXPR
      0  34f4					      TSTB	UNKNOWNVEC,oRightBracket
      0  34f4					      db	101
      1  34f4		       65		      .byte.b	101
      0  34f5					      db	(UNKNOWNVEC-*)-1
      1  34f5		       1f		      .byte.b	(UNKNOWNVEC-*)-1
      0  34f6					      db	oRightBracket
      1  34f6		       e1		      .byte.b	oRightBracket
      0  34f7					      CALLFUNC
      0  34f7					      db	53
      1  34f7		       35		      .byte.b	53
      0  34f8					      RTN
      0  34f8					      db	25
      1  34f8		       19		      .byte.b	25
    929  34f9							; Run the gosub within this function
    930  34f9				   F2B2A
      0  34f9					      TSTB	UNKNOWNID,oRightBracket
      0  34f9					      db	101
      1  34f9		       65		      .byte.b	101
      0  34fa					      db	(UNKNOWNID-*)-1
      1  34fa		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  34fb					      db	oRightBracket
      1  34fb		       e1		      .byte.b	oRightBracket
      0  34fc					      LIT	0	; No parameter passed so just load zero to A
      0  34fc					      db	27
      1  34fc		       1b		      .byte.b	27
      0  34fd					      dw	0
      1  34fd		       00 00		      .word.w	0
      0  34ff					      CALLFUNC
      0  34ff					      db	53
      1  34ff		       35		      .byte.b	53
      0  3500					      RTN
      0  3500					      db	25
      1  3500		       19		      .byte.b	25
    935  3501
    936  3501
    937  3501							;=================================================================================
    938  3501							;Check for a number !
    939  3501							;
    940  3501				   FactNumber
      0  3501					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  3501					      db	35
      1  3501		       23		      .byte.b	35
      0  3502					      db	(FactVariable-*)-1
      1  3502		       0f		      .byte.b	(FactVariable-*)-1
      0  3503					      RTN
      0  3503					      db	25
      1  3503		       19		      .byte.b	25
    943  3504
    944  3504				   FactWithBracket
      0  3504					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  3504					      db	101
      1  3504		       65		      .byte.b	101
      0  3505					      db	(F2RTN-*)-1
      1  3505		       08		      .byte.b	(F2RTN-*)-1
      0  3506					      db	oLeftBracket
      1  3506		       e0		      .byte.b	oLeftBracket
      0  3507					      CALL	EXPR
      0  3507					      db	28
      1  3507		       1c		      .byte.b	28
      0  3508					      dw	EXPR
      1  3508		       92 33		      .word.w	EXPR
      0  350a					      TST	F2,oRightBracket
      0  350a					      db	32
      1  350a		       20		      .byte.b	32
      0  350b					      db	(F2-*)-1
      1  350b		       03		      .byte.b	(F2-*)-1
      0  350c					      db	oRightBracket,0
      1  350c		       e1 00		      .byte.b	oRightBracket,0
    948  350e				   F2RTN
      0  350e					      RTN
      0  350e					      db	25
      1  350e		       19		      .byte.b	25
    950  350f
    951  350f				   F2
      0  350f					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  350f					      db	13
      1  350f		       0d		      .byte.b	13
      0  3510					      dw	ERR_SYNTAX
      1  3510		       05 00		      .word.w	ERR_SYNTAX
    953  3512							;
    954  3512							;=============================================================================
    955  3512							; See if this is just a simple variable
    956  3512							;  Allow a subscript for any variable
    957  3512							;
    958  3512				   FactVariable
    959  3512
      0  3512					      SETR2	tInteger
      0  3512					      db	94
      1  3512		       5e		      .byte.b	94
      0  3513					      db	tInteger
      1  3513		       a4		      .byte.b	tInteger
      0  3514					      TSTV	FactWithBracket
      0  3514					      db	33
      1  3514		       21		      .byte.b	33
      0  3515					      db	(FactWithBracket-*)-1
      1  3515		       ee		      .byte.b	(FactWithBracket-*)-1
      0  3516					      TSTBYTE	FactFNParm,R2,GOSUB_RTN_VALUE
      0  3516					      db	97
      1  3516		       61		      .byte.b	97
      0  3517					      db	(FactFNParm-*)-1
      1  3517		       0a		      .byte.b	(FactFNParm-*)-1
      0  3518					      dw	R2
      1  3518		       58 00		      .word.w	R2
      0  351a					      db	GOSUB_RTN_VALUE
      1  351a		       81		      .byte.b	GOSUB_RTN_VALUE
      0  351b					      CALL	FactVarPTR
      0  351b					      db	28
      1  351b		       1c		      .byte.b	28
      0  351c					      dw	FactVarPTR
      1  351c		       31 35		      .word.w	FactVarPTR
      0  351e					      CALL	FactVariableValue
      0  351e					      db	28
      1  351e		       1c		      .byte.b	28
      0  351f					      dw	FactVariableValue
      1  351f		       5a 35		      .word.w	FactVariableValue
      0  3521					      RTN
      0  3521					      db	25
      1  3521		       19		      .byte.b	25
    966  3522
    967  3522				   FactFNParm
      0  3522					      TSTB	FactExpectedOpeningBracket,oLeftSQBracket
      0  3522					      db	101
      1  3522		       65		      .byte.b	101
      0  3523					      db	(FactExpectedOpeningBracket-*)-1
      1  3523		       3b		      .byte.b	(FactExpectedOpeningBracket-*)-1
      0  3524					      db	oLeftSQBracket
      1  3524		       e4		      .byte.b	oLeftSQBracket
      0  3525					      CALL	EXPR
      0  3525					      db	28
      1  3525		       1c		      .byte.b	28
      0  3526					      dw	EXPR
      1  3526		       92 33		      .word.w	EXPR
      0  3528					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  3528					      db	101
      1  3528		       65		      .byte.b	101
      0  3529					      db	(FactMissingRightBracket-*)-1
      1  3529		       32		      .byte.b	(FactMissingRightBracket-*)-1
      0  352a					      db	oRightSQBracket
      1  352a		       e5		      .byte.b	oRightSQBracket
      0  352b					      SUBSCRIPT	GOSUB_RTN_VALUE
      0  352b					      db	64
      1  352b		       40		      .byte.b	64
      0  352c					      db	GOSUB_RTN_VALUE
      1  352c		       81		      .byte.b	GOSUB_RTN_VALUE
      0  352d					      SETR2	tInteger
      0  352d					      db	94
      1  352d		       5e		      .byte.b	94
      0  352e					      db	tInteger
      1  352e		       a4		      .byte.b	tInteger
      0  352f					      IND
      0  352f					      db	20
      1  352f		       14		      .byte.b	20
      0  3530					      RTN
      0  3530					      db	25
      1  3530		       19		      .byte.b	25
    975  3531
    976  3531				   FactVarPTR
    977  3531				   FactVarPtrNoTst
      0  3531					      TSTB	F2CLocalTask,oBang
      0  3531					      db	101
      1  3531		       65		      .byte.b	101
      0  3532					      db	(F2CLocalTask-*)-1
      1  3532		       04		      .byte.b	(F2CLocalTask-*)-1
      0  3533					      db	oBang
      1  3533		       e8		      .byte.b	oBang
      0  3534					      IND		; we just got a pid
      0  3534					      db	20
      1  3534		       14		      .byte.b	20
      0  3535					      TSTVT	UNKNOWNID	; if it is not another variable then error, Call test var. task
      0  3535					      db	93
      1  3535		       5d		      .byte.b	93
      0  3536					      db	(UNKNOWNID-*)-1
      1  3536		       83		      .byte.b	(UNKNOWNID-*)-1
    981  3537
    982  3537				   F2CLocalTask
      0  3537					      SETR2	tInteger	; Sets the default type to integer
      0  3537					      db	94
      1  3537		       5e		      .byte.b	94
      0  3538					      db	tInteger
      1  3538		       a4		      .byte.b	tInteger
      0  3539					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  3539					      db	101
      1  3539		       65		      .byte.b	101
      0  353a					      db	(F2INTEGER-*)-1
      1  353a		       11		      .byte.b	(F2INTEGER-*)-1
      0  353b					      db	oDollar
      1  353b		       e7		      .byte.b	oDollar
      0  353c					      SETR2	tByte
      0  353c					      db	94
      1  353c		       5e		      .byte.b	94
      0  353d					      db	tByte
      1  353d		       a2		      .byte.b	tByte
      0  353e					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  353e					      db	101
      1  353e		       65		      .byte.b	101
      0  353f					      db	(F2PTRLOADED-*)-1
      1  353f		       19		      .byte.b	(F2PTRLOADED-*)-1
      0  3540					      db	oLeftSQBracket
      1  3540		       e4		      .byte.b	oLeftSQBracket
      0  3541					      CALL	EXPR
      0  3541					      db	28
      1  3541		       1c		      .byte.b	28
      0  3542					      dw	EXPR
      1  3542		       92 33		      .word.w	EXPR
      0  3544					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  3544					      db	101
      1  3544		       65		      .byte.b	101
      0  3545					      db	(FactMissingRightBracket-*)-1
      1  3545		       16		      .byte.b	(FactMissingRightBracket-*)-1
      0  3546					      db	oRightSQBracket
      1  3546		       e5		      .byte.b	oRightSQBracket
      0  3547					      SUBSCRIPT	tByte	; Byte type array
      0  3547					      db	64
      1  3547		       40		      .byte.b	64
      0  3548					      db	tByte
      1  3548		       a2		      .byte.b	tByte
      0  3549					      SETR2	tByte	; Set byte data type
      0  3549					      db	94
      1  3549		       5e		      .byte.b	94
      0  354a					      db	tByte
      1  354a		       a2		      .byte.b	tByte
      0  354b					      RTN
      0  354b					      db	25
      1  354b		       19		      .byte.b	25
    992  354c
    993  354c				   F2INTEGER
      0  354c					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  354c					      db	101
      1  354c		       65		      .byte.b	101
      0  354d					      db	(F2PTRLOADED-*)-1
      1  354d		       0b		      .byte.b	(F2PTRLOADED-*)-1
      0  354e					      db	oLeftSQBracket
      1  354e		       e4		      .byte.b	oLeftSQBracket
      0  354f					      CALL	EXPR
      0  354f					      db	28
      1  354f		       1c		      .byte.b	28
      0  3550					      dw	EXPR
      1  3550		       92 33		      .word.w	EXPR
      0  3552					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  3552					      db	101
      1  3552		       65		      .byte.b	101
      0  3553					      db	(FactMissingRightBracket-*)-1
      1  3553		       08		      .byte.b	(FactMissingRightBracket-*)-1
      0  3554					      db	oRightSQBracket
      1  3554		       e5		      .byte.b	oRightSQBracket
      0  3555					      SUBSCRIPT	tInteger	; Integer type array
      0  3555					      db	64
      1  3555		       40		      .byte.b	64
      0  3556					      db	tInteger
      1  3556		       a4		      .byte.b	tInteger
      0  3557					      SETR2	tInteger	; Set word datatype
      0  3557					      db	94
      1  3557		       5e		      .byte.b	94
      0  3558					      db	tInteger
      1  3558		       a4		      .byte.b	tInteger
    999  3559				   F2PTRLOADED
      0  3559					      RTN
      0  3559					      db	25
      1  3559		       19		      .byte.b	25
   1001  355a
   1002  355a				   FactVariableValue
      0  355a					      IND		; YES, GET THE VALUE as word
      0  355a					      db	20
      1  355a		       14		      .byte.b	20
      0  355b					      RTN
      0  355b					      db	25
      1  355b		       19		      .byte.b	25
   1005  355c
   1006  355c				   FactMissingRightBracket
      0  355c					      IJMP	ReturnExpectBracket
      0  355c					      db	29
      1  355c		       1d		      .byte.b	29
      0  355d					      dw	ReturnExpectBracket
      1  355d		       90 35		      .word.w	ReturnExpectBracket
   1008  355f				   FactExpectedOpeningBracket
      0  355f					      ERRMSG	ERR_EXPECTED_OPENING_BRACKET
      0  355f					      db	13
      1  355f		       0d		      .byte.b	13
      0  3560					      dw	ERR_EXPECTED_OPENING_BRACKET
      1  3560		       1a 00		      .word.w	ERR_EXPECTED_OPENING_BRACKET
   1010  3562							;===============================================================================================================================
   1011  3562							;========================= Gosub and function interface ========================================================================
   1012  3562							; Process gosub 1000(Parm1, ...) no return value
   1013  3562							;
   1014  3562				   ekGosub
      0  3562					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  3562					      db	28
      1  3562		       1c		      .byte.b	28
      0  3563					      dw	GOSUBSTATEMENT
      1  3563		       94 35		      .word.w	GOSUBSTATEMENT
      0  3565					      DONE		; ERROR IF CR NOT NEXT
      0  3565					      db	1
      1  3565		       01		      .byte.b	1
      0  3566					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  3566					      db	8
      1  3566		       08		      .byte.b	8
      0  3567					      db	GOSUB_RTN
      1  3567		       01		      .byte.b	GOSUB_RTN
      0  3568					      FASTXFER		; AND JUMP to sub rtn
      0  3568					      db	107
      1  3568		       6b		      .byte.b	107
   1019  3569							;
   1020  3569							; End of gosub processing
   1021  3569							;===========================================================================
   1022  3569							; Same as gosub but expects a return value
   1023  3569							;   FN 1000(parm1, ....)  Expects an integer to be returned
   1024  3569							;
   1025  3569				   ekGofn
      0  3569					      Call	GOSUBSTATEMENT
      0  3569					      db	28
      1  3569		       1c		      .byte.b	28
      0  356a					      dw	GOSUBSTATEMENT
      1  356a		       94 35		      .word.w	GOSUBSTATEMENT
      0  356c					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  356c					      db	8
      1  356c		       08		      .byte.b	8
      0  356d					      db	GOSUB_RTN_VALUE
      1  356d		       81		      .byte.b	GOSUB_RTN_VALUE
      0  356e					      FASTXFER
      0  356e					      db	107
      1  356e		       6b		      .byte.b	107
   1029  356f
   1030  356f				   GOFNRet
      0  356f					      RTN
      0  356f					      db	25
      1  356f		       19		      .byte.b	25
   1032  3570							;===============================================================================================================================
   1033  3570							; Return from a gosub
   1034  3570							;
   1035  3570				   ekReturn
      0  3570					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  3570					      db	101
      1  3570		       65		      .byte.b	101
      0  3571					      db	(S2NoReturnValue-*)-1
      1  3571		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  3572					      db	oLeftBracket
      1  3572		       e0		      .byte.b	oLeftBracket
      0  3573					      CALL	EXPR
      0  3573					      db	28
      1  3573		       1c		      .byte.b	28
      0  3574					      dw	EXPR
      1  3574		       92 33		      .word.w	EXPR
      0  3576					      TSTB	ReturnExpectBracket,oRightBracket	; Now a value is on the stack
      0  3576					      db	101
      1  3576		       65		      .byte.b	101
      0  3577					      db	(ReturnExpectBracket-*)-1
      1  3577		       18		      .byte.b	(ReturnExpectBracket-*)-1
      0  3578					      db	oRightBracket
      1  3578		       e1		      .byte.b	oRightBracket
      0  3579					      DONE
      0  3579					      db	1
      1  3579		       01		      .byte.b	1
      0  357a					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  357a					      db	9
      1  357a		       09		      .byte.b	9
      0  357b					      db	(S2RetFunc-*)-1
      1  357b		       11		      .byte.b	(S2RetFunc-*)-1
      0  357c					      db	1
      1  357c		       01		      .byte.b	1
      0  357d					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  357d					      db	6
      1  357d		       06		      .byte.b	6
      0  357e					      dw	CO
      1  357e		       76 31		      .word.w	CO
      0  3580					      IJMP	STMT	; Process the new statement
      0  3580					      db	29
      1  3580		       1d		      .byte.b	29
      0  3581					      dw	STMT
      1  3581		       7e 31		      .word.w	STMT
   1043  3583
   1044  3583				   S2NoReturnValue
      0  3583					      DONE
      0  3583					      db	1
      1  3583		       01		      .byte.b	1
      0  3584					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  3584					      db	9
      1  3584		       09		      .byte.b	9
      0  3585					      db	(S2RetFunc-*)-1
      1  3585		       07		      .byte.b	(S2RetFunc-*)-1
      0  3586					      db	0
      1  3586		       00		      .byte.b	0
      0  3587					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3587					      db	6
      1  3587		       06		      .byte.b	6
      0  3588					      dw	CO
      1  3588		       76 31		      .word.w	CO
      0  358a					      IJMP	STMT	; Process the new statement
      0  358a					      db	29
      1  358a		       1d		      .byte.b	29
      0  358b					      dw	STMT
      1  358b		       7e 31		      .word.w	STMT
   1049  358d
   1050  358d				   S2RetFunc
      0  358d					      IJMP	GOFNRet	; Back into the Function
      0  358d					      db	29
      1  358d		       1d		      .byte.b	29
      0  358e					      dw	GOFNRet
      1  358e		       6f 35		      .word.w	GOFNRet
   1052  3590
   1053  3590				   ReturnExpectBracket
      0  3590					      ENDIO
      0  3590					      db	71
      1  3590		       47		      .byte.b	71
      0  3591					      ERRMSG	ERR_CLOSINGBRACKET
      0  3591					      db	13
      1  3591		       0d		      .byte.b	13
      0  3592					      dw	ERR_CLOSINGBRACKET
      1  3592		       17 00		      .word.w	ERR_CLOSINGBRACKET
   1056  3594							;
   1057  3594							; End of return from gosub
   1058  3594							;=============================================================
   1059  3594							; Gosub can be both a Function and a Subroutine
   1060  3594				   GOSUBSTATEMENT
      0  3594					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  3594					      db	106
      1  3594		       6a		      .byte.b	106
      0  3595					      db	(GOSUBCOMPILED-*)-1
      1  3595		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  3596					      CALL	EXPR	; GET DESTINATION
      0  3596					      db	28
      1  3596		       1c		      .byte.b	28
      0  3597					      dw	EXPR
      1  3597		       92 33		      .word.w	EXPR
      0  3599					      CALL	GOSUBCONT
      0  3599					      db	28
      1  3599		       1c		      .byte.b	28
      0  359a					      dw	GOSUBCONT
      1  359a		       a7 35		      .word.w	GOSUBCONT
      0  359c					      lit	0	; mark as lookup on stack
      0  359c					      db	27
      1  359c		       1b		      .byte.b	27
      0  359d					      dw	0
      1  359d		       00 00		      .word.w	0
      0  359f					      RTN
      0  359f					      db	25
      1  359f		       19		      .byte.b	25
   1066  35a0
   1067  35a0				   GOSUBCOMPILED
      0  35a0					      CALL	GOSUBCONT
      0  35a0					      db	28
      1  35a0		       1c		      .byte.b	28
      0  35a1					      dw	GOSUBCONT
      1  35a1		       a7 35		      .word.w	GOSUBCONT
      0  35a3					      lit	1	;mark as compiled on stack
      0  35a3					      db	27
      1  35a3		       1b		      .byte.b	27
      0  35a4					      dw	1
      1  35a4		       01 00		      .word.w	1
      0  35a6					      RTN
      0  35a6					      db	25
      1  35a6		       19		      .byte.b	25
   1071  35a7
   1072  35a7				   GOSUBCONT
      0  35a7					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters If not bracket get out
      0  35a7					      db	101
      1  35a7		       65		      .byte.b	101
      0  35a8					      db	(GOSUBDONE-*)-1
      1  35a8		       11		      .byte.b	(GOSUBDONE-*)-1
      0  35a9					      db	oLeftBracket
      1  35a9		       e0		      .byte.b	oLeftBracket
      0  35aa					      STK2TMP		;Transfer stack top to temp, temp gets line to goto
      0  35aa					      db	95
      1  35aa		       5f		      .byte.b	95
      0  35ab					      PUSHMATHSTACK		;Record stack frame for return
      0  35ab					      db	84
      1  35ab		       54		      .byte.b	84
   1076  35ac				   GOSUBLOOP
      0  35ac					      CALL	EXPR	; Allows what ever fits onto stack
      0  35ac					      db	28
      1  35ac		       1c		      .byte.b	28
      0  35ad					      dw	EXPR
      1  35ad		       92 33		      .word.w	EXPR
      0  35af					      INCPARMCOUNT
      0  35af					      db	88
      1  35af		       58		      .byte.b	88
      0  35b0					      TSTB	GOSUBParmDONE,oComma
      0  35b0					      db	101
      1  35b0		       65		      .byte.b	101
      0  35b1					      db	(GOSUBParmDONE-*)-1
      1  35b1		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  35b2					      db	oComma
      1  35b2		       e2		      .byte.b	oComma
      0  35b3					      IJMP	GOSUBLOOP
      0  35b3					      db	29
      1  35b3		       1d		      .byte.b	29
      0  35b4					      dw	GOSUBLOOP
      1  35b4		       ac 35		      .word.w	GOSUBLOOP
   1081  35b6				   GOSUBParmDONE
      0  35b6					      TSTB	ReturnExpectBracket,oRightBracket
      0  35b6					      db	101
      1  35b6		       65		      .byte.b	101
      0  35b7					      db	(ReturnExpectBracket-*)-1
      1  35b7		       d8		      .byte.b	(ReturnExpectBracket-*)-1
      0  35b8					      db	oRightBracket
      1  35b8		       e1		      .byte.b	oRightBracket
      0  35b9					      TMP2STK		; Restore line to goto
      0  35b9					      db	96
      1  35b9		       60		      .byte.b	96
   1084  35ba				   GOSUBDONE
      0  35ba					      RTN
      0  35ba					      db	25
      1  35ba		       19		      .byte.b	25
   1086  35bb
   1087  35bb		       35 bb	   ILEND      equ	*
------- FILE mytb.asm
   2490  35bb		       35 bb	   PROGEND    equ	*
   2491  35bb
   2492  35bb
   2493  35bb							;=====================================================
   2494  35bb							; Define start of non page zero data
   2495 U360e					      seg.u	TBData
   2496 U360e
   2497 U360e							;=====================================================
   2498 U360e							; These are storage items not in page zero.
   2499 U360e							;==================================================================================================
   2500 U360e							; Task Management information
   2501 U360e							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2502 U360e							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2503 U360e							; Task switchs happen at the beginning of the next Basic command line
   2504 U360e							; It will not happen during an input or output operations
   2505 U360e							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2506 U360e							; Task Zero is always the root task, main line program
   2507 U360e							;
   2508 U360e							; Layout is repeated for each configured task
   2509 U360e							; Task Table Byte   use masks follow
   2510 U360e		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2511 U360e		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2512 U360e		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2513 U360e		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2514 U360e		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2515 U360e
   2516 U360e		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2517 U360f		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2518 U360f		       37 09	   TASKTABLEEND equ	*	; End of task table
   2519 U360f		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2520 U3709
   2521 U3709							;Task Cycle Counter and reset count
   2522 U3709		       00 00	   taskCurrentCycles ds	2
   2523 U370b		       00 00	   taskResetValue ds	2
   2524 U370d		       00	   taskCounter ds	1	; Count of active tasks
   2525 U370e
   2526 U370e							;
   2527 U370e							; Math stack and IL call and Gosub/For-next return stack definitions
   2528 U370e							;
   2529 U370e		       37 0e	   STACKSTART equ	*
   2530 U370e		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2531 U389e		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2532 U3c86		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2533 U3f06		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code,taskio block stdin,stdout,stdstat,iostatus
   2534 U3f06		       00 48	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2535 U3f06		       41 ea	   STACKEND   equ	*
   2536 U3f06		       0a dc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2537 U41ea							;
   2538 U41ea							;
   2539 U41ea		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2540 U426e		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2541 U426f		       00	   printtx    ds	1	;temp X for print funcs
   2542 U4270		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2543 U4271		       00	   promptChar ds	1	;the character to use for a prompt
   2544 U4272		       00	   diddigit   ds	1	;for leading zero suppression
   2545 U4273		       00	   putsy      ds	1
   2546 U4274		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2547 U4276		       00	   sign       ds	1	;0 = positive, else negative
   2548 U4277		       00 00	   rtemp1     ds	2	;Temp for x and y
   2549 U4279		       00 00	   random     ds	2
   2550 U427b		       00	   tempy      ds	1	;temp y storage
   2551 U427c
   2552 U427c
   2553 U427c							; Moved from page zero as one clock cycle diff gives more space on page zero
   2554 U427c		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2555 U427e		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2556 U427f		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2557 U4280		       00	   lineLength ds	1	;Length of current line
   2558 U4281
   2559 U4281		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2560 U4282		       00	   taskRDPending ds	1	; 1 = background read is pending
   2561 U4283
   2562 U4283				  -	      if	XKIM
   2563 U4283				  -buffer     ds	BUFFER_SIZE
   2564 U4283					      endif
   2565 U4283							;
   2566 U4283							; PROGRAMEND is the end of the user's BASIC program.
   2567 U4283							; More precisely, it is one byte past the end.  Or,
   2568 U4283							; it's where the next line added to the end will be
   2569 U4283							; placed.
   2570 U4283							;
   2571 U4283		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2572 U4285		       00 00	   ProgramEnd ds	2	; End of users basic program, Next free byte after end
   2573 U4287		       00 00	   HighMem    ds	2	; highest location
   2574 U4289		       00 00	   UsedMem    ds	2	; size of user program
   2575 U428b		       00 00	   FreeMem    ds	2	; amount of free memory
   2576 U428d							;
   2577 U428d							;=====================================================
   2578 U428d							; This is the start of the user's BASIC program space.
   2579 U428d							;
   2580 U428d							; PERSONAL GOAL: This should be no larger than $0DFF.
   2581 U428d							;		  0200-05FF = 1K
   2582 U428d							;		  0200-09FF = 2K
   2583 U428d							;		  0200-0DFF = 3K
   2584 U428d							;		  0200-11FF = 4K
   2585 U428d							;		  0200-13FF = 4.5K
   2586 U428d							;
   2587 U428d				  -	      if	FIXED
   2588 U428d				  -	      org	$2000
   2589 U428d					      endif
   2590 U428d
   2591 U428d		       42 8d	   FreeMemStart equ	*
   2592 U428d							;/*
   2593 U428d							;  if	  CTMON65 || XKIM
   2594 U428d							;	  SEG Code
   2595 U428d							;	  org	  AutoRun
   2596 U428d							;	  dw	  TBasicCold
   2597 U428d							;  endif
   2598 U428d							;*/
   2599 U428d					      end
