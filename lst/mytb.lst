------- FILE mytb.asm LEVEL 1 PASS 6
      1 U4247				   input      processor	6502
      2 U4247 ????						;=====================================================
      3 U4247 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U4247 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U4247 ????						; Free Time. Now abiut 6K Full OS features.
      6 U4247 ????						;
      7 U4247 ????						; While working on the Corsham Technologies KIM Clone
      8 U4247 ????						; project, I wanted to include a TINY BASIC since that
      9 U4247 ????						; was a highly desirable feature of early computers.
     10 U4247 ????						;
     11 U4247 ????						; Rather than negotiating copyright issues for
     12 U4247 ????						; existing BASICs, I decided to just write one from
     13 U4247 ????						; scratch.
     14 U4247 ????						;
     15 U4247 ????						; 10/07/2017
     16 U4247 ????						;
     17 U4247 ????						; This implements a stripped down Tiny BASIC
     18 U4247 ????						; interpreter using the Interpretive Language (IL)
     19 U4247 ????						; method as described in the first few issues of
     20 U4247 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U4247 ????						; to write various languages simply by changing the
     22 U4247 ????						; IL code rather than the interpreter itself.
     23 U4247 ????						;
     24 U4247 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U4247 ????						;		* Fixed major bug in findLine that
     26 U4247 ????						;		  caused corrupted lines, crashes, etc.
     27 U4247 ????						;		* If no parameter given to RND, assume
     28 U4247 ????						;		  32766.
     29 U4247 ????						;		* No more error 5 when a program
     30 U4247 ????						;		  reaches the end without an END.
     31 U4247 ????						;
     32 U4247 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U4247 ????						;		 * Unexpanded version to play with everything
     34 U4247 ????						;		 * Add some usefull system level functions
     35 U4247 ????						;		 * allow a larger number of tiny basic formats
     36 U4247 ????						;		 * Add byte at start of line holding length
     37 U4247 ????						;		   for faster execution of goto and gosub
     38 U4247 ????						;		 * Re-added gosub
     39 U4247 ????						;		 * allow ; or , at end if print stmt
     40 U4247 ????						;		   without CRLF being added.
     41 U4247 ????						;		 * Added extended function erase to
     42 U4247 ????						;		   use the extended ctmon65 rm file
     43 U4247 ????						;		 * Fix quoted text to not have to backtrack
     44 U4247 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U4247 ????						;		 * Add concurrency features
     46 U4247 ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U4247 ????						;
     48 U4247 ????						; www.corshamtech.com
     49 U4247 ????						; bob@corshamtech.com
     50 U4247 ????						; JustLostInTime@gmail.com
     51 U4247 ????						;
     52 U4247 ????						;=====================================================
     53 U4247 ????						;
     54 U4247 ????						; Create TRUE and FALSE values for conditionals.
     55 U4247 ????						;
     56 U4247 ????
     57 U4247 ????	       00 00	   FALSE      equ	0
     58 U4247 ????	       ff ff ff ff TRUE       equ	~FALSE
     59 U4247 ????						;
     60 U4247 ????						;---------------------------------------------------------
     61 U4247 ????						; One of these must be set to indicate which environment
     62 U4247 ????						; Tiny BASIC will be running in.  Here are the current
     63 U4247 ????						; environments:
     64 U4247 ????						;
     65 U4247 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     66 U4247 ????						; more K of RAM.
     67 U4247 ????						;
     68 U4247 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     69 U4247 ????						; which enhances, without replacing, the standard KIM
     70 U4247 ????						; monitor.  It gives access to routines to save/load files
     71 U4247 ????						; to a micro SD card.
     72 U4247 ????						;
     73 U4247 ????						; CTMON65 is a from-scratch monitor written for the
     74 U4247 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     75 U4247 ????						; easily be ported to other systems.  It has support for
     76 U4247 ????						; using a micro SD card for file storage/retrieval.
     77 U4247 ????						;
     78 U4247 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     79 U4247 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     80 U4247 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     81 U4247 ????	       ff ff ff ff IL_DEBUG_TEXT equ	TRUE	;Print out as text IL instructions
     82 U4247 ????						;
     83 U4247 ????						;   Need to define some macros for the dasm assembler
     84 U4247 ????						;
     85 U4247 ????				      MACRO	dw
     86 U4247 ????				      .word	{0}
     87 U4247 ????				      ENDM
     88 U4247 ????
     89 U4247 ????				      MACRO	db
     90 U4247 ????				      .byte	{0}
     91 U4247 ????				      ENDM
     92 U4247 ????
     93 U4247 ????						;
     94 U4247 ????						; If set, include disk functions.
     95 U4247 ????						;
     96 U4247 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     97 U4247 ????						;
     98 U4247 ????						; If ILTRACE is set then dump out the address of every
     99 U4247 ????						; IL opcode before executing it.
    100 U4247 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    101 U4247 ????						;
    102 U4247 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    103 U4247 ????						;
    104 U4247 ????						; If FIXED is set, put the IL code and the user
    105 U4247 ????						; program space at fixed locations in memory.	This is
    106 U4247 ????						; meant only for debugging.
    107 U4247 ????						;
    108 U4247 ????	       00 00	   FIXED      equ	FALSE
    109 U4247 ????
    110 U4247 ????	       00 0f	   terminalIOblockLen equ	[TerminalIOblockEnd - TerminalIOblock]
    111 U4247 ????
    112 U4247 ????						;
    113 U4247 ????						; Sets the arithmetic stack depth.  This is *TINY*
    114 U4247 ????						; BASIC, so keep this small!
    115 U4247 ????						;
    116 U4247 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    117 U4247 ????	       00 32	   ILSTACKSIZE equ	50	;number of entries in ilstack
    118 U4247 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    119 U4247 ????	       00 25	   VARIABLESSIZE equ	37	;26 variables + 1 for exit code + 10 entries (20bytes) for ioblock
    120 U4247 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    121 U4247 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    122 U4247 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    123 U4247 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    124 U4247 ????
    125 U4247 ????	       00 36	   taskSTDIN  equ	[[VARIABLESSIZE - 10]*2]	;io vector
    126 U4247 ????	       00 38	   taskSTDOUT equ	[[[VARIABLESSIZE - 10]*2]+2]	;io vector
    127 U4247 ????
    128 U4247 ????	       00 3f	   taskIOinPort equ	[[[VARIABLESSIZE - 10]*2]+4+5]	;Offset into the ioblock
    129 U4247 ????	       00 3b	   taskIOoutPort equ	[[[VARIABLESSIZE - 10]*2]+4+1]	;Offset into the ioblock
    130 U4247 ????	       00 46	   taskIOstatusPort equ	[[[VARIABLESSIZE - 10]*2]+4+12]	;Offset into the ioblock
    131 U4247 ????						;
    132 U4247 ????						; Gosub entry types
    133 U4247 ????
    134 U4247 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    135 U4247 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    136 U4247 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    137 U4247 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    138 U4247 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    139 U4247 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    140 U4247 ????						; 0 byte is the original stack offset, byte 1 is the paameter count
    141 U4247 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    142 U4247 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    143 U4247 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    144 U4247 ????						;
    145 U4247 ????						; Common ASCII constants
    146 U4247 ????						;
    147 U4247 ????	       00 07	   BEL	      equ	$07
    148 U4247 ????	       00 08	   BS	      equ	$08
    149 U4247 ????	       00 09	   TAB	      equ	$09
    150 U4247 ????	       00 0a	   LF	      equ	$0A
    151 U4247 ????	       00 0d	   CR	      equ	$0D
    152 U4247 ????	       00 22	   quote      equ	$22
    153 U4247 ????	       00 20	   SPACE      equ	$20
    154 U4247 ????	       00 2c	   COMMA      equ	',
    155 U4247 ????	       00 3b	   SEMICOLON  equ	';
    156 U4247 ????	       00 3a	   COLON      equ	':
    157 U4247 ????	       00 24	   DOLLAR     equ	'$
    158 U4247 ????						;
    159 U4247 ????						; These are error codes
    160 U4247 ????						;
    161 U4247 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    162 U4247 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    163 U4247 ????	       00 02	   ERR_UNDER  equ	2	;The Math stack underflow
    164 U4247 ????	       00 03	   ERR_OVER   equ	3	;The Math stack overflow
    165 U4247 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    166 U4247 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    167 U4247 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    168 U4247 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    169 U4247 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    170 U4247 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    171 U4247 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    172 U4247 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    173 U4247 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;the gosub Stack overflow
    174 U4247 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    175 U4247 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    176 U4247 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    177 U4247 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    178 U4247 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    179 U4247 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    180 U4247 ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    181 U4247 ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    182 U4247 ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    183 U4247 ????	       00 16	   ERR_EXPECTVAR equ	22	;Expected a variable name or definition
    184 U4247 ????	       00 17	   ERR_CLOSINGBRACKET equ	23	;Expected a closing bracket
    185 U4247 ????	       00 18	   ERR_MISSINGEQUALSIGN equ	24	;Expected an equal sign for assignment
    186 U4247 ????	       00 19	   ERR_FUNCTION_EXPECTED_PARAMETERS equ	25	;Function expected parameters
    187 U4247 ????	       00 1a	   ERR_EXPECTED_OPENING_BRACKET equ	26	;Expected opening bracket [ or (
    188 U4247 ????						;
    189 U4247 ????						;=====================================================
    190 U4247 ????						; Zero page storage.
    191 U4247 ????						;
    192 U00f6 ????				      SEG.U	ZEROPAGE
    193 U0040					      org	$0040
    194 U0040
    195 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    196 U0041
    197 U0041							; The context is used to locate a task switch
    198 U0041							; it copies from here till all task fields are saved/swapped
    199 U0041							; The max number of tasks is 256 / context length
    200 U0041							; All positions POS values are plus one task table incldues
    201 U0041							; a leading status byte .
    202 U0041							;
    203 U0041		       00 41	   CONTEXT    equ	*
    204 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    205 U0041
    206 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    207 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    208 U0043
    209 U0043		       00 00	   ILPC       ds	2	; IL program counter
    210 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    211 U0047		       00	   ILSTACKPTR ds	1
    212 U0048
    213 U0048
    214 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    215 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    216 U004a
    217 U004a
    218 U004a		       00	   MATHSTACKPTR ds	1
    219 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    220 U004b
    221 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    222 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT + 1	; Get the offset to the gosub/msg stack
    223 U004d
    224 U004d
    225 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    226 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    227 U004e
    228 U004e
    229 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    230 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    231 U004f							;
    232 U004f							; CURPTR is a pointer to curent BASIC line being
    233 U004f							; executed.  Always points to start of line, CUROFF
    234 U004f							; is the offset to the current character.
    235 U004f							; The order of these fields is important
    236 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    237 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    238 U0052							;
    239 U0052							;The order of these fields in important
    240 U0052
    241 U0052							;
    242 U0052							; R0, R1 and MQ are used for arithmetic operations and
    243 U0052							; general use.
    244 U0052							;
    245 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    246 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    247 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    248 U0056		       00 00	   MQ	      ds	2	;used for some math
    249 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    250 U0058		       00 59	   REGISTERSEND equ	*
    251 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    252 U0059
    253 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    254 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    255 U0059
    256 U0059		       00 00	   dpl	      ds	2	; Used as a pointer to call il instructions
    257 U005b							;
    258 U005b							; This is zero if in immediate mode, or non-zero
    259 U005b							; if currently running a program.  Any input from
    260 U005b							; the main loop clears this, and the XFER IL
    261 U005b							; statement will set it.
    262 U005b							;
    263 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    264 U005c							;
    265 U005c							; Used for line insertion/removal.
    266 U005c							;
    267 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    268 U005e
    269 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    270 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    271 U005e							;
    272 U005e		       00 00	   PrtFrom    ds	2	; FROM
    273 U0060
    274 U0060							;
    275 U0060							;=====================================================
    276 U0060							;
    277  3575 ????				      SEG	Code
    278  0200					      org	$0200
    279  0200							;
    280  0200							; Cold start is at $0200.  Warm start is at $0203.
    281  0200							;
    282  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    283  0203		       4c 82 02    warm       jmp	warm2	;Entry point for worm restart
    284  0206							;
    285  0206							; These are the user-supplied vectors to I/O routines.
    286  0206							; If you want, you can just patch these in the binary
    287  0206							; file, but it would be better to change the source
    288  0206							; code.
    289  0206							;
    290  0206				  -	      if	KIM
    291  0206				  -OUTCH      jmp	$1ea0	;output char in A
    292  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    293  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    294  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    295  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    296  0206					      endif
    297  0206				  -	      if	XKIM
    298  0206				  -	      include	"xkim.inc"
    299  0206				  -	      SEG	Code
    300  0206				  -OUTCH      jmp	$1ea0
    301  0206				  -GETCH      jmp	xkGETCH
    302  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    303  0206				  -OUTHEX     jmp	xkPRTBYT
    304  0206				  -MONITOR    jmp	extKIM
    305  0206				  -puts       equ	putsil
    306  0206				  -BUFFER_SIZE equ	132
    307  0206					      endif
    308  0206
    309  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0060					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    311 Udf8e
    312  0206					      SEG	Code
    313  0206							;
    314  0206		       f0 0c	   OUTCH      equ	cout
    315  0206		       f0 09	   GETCH      equ	cin
    316  0206		       2c a3	   CRLF       equ	tbcrlf
    317  0206		       20 fa	   OUTHEX     equ	HexToOut
    318  0206		       f0 03	   MONITOR    equ	WARM
    319  0206		       f0 0f	   ISCHAR     equ	cstatus
    320  0206		       21 17	   puts       equ	tbputs
    321  0206					      endif
    322  0206							;
    323  0206		       20 ea 2d    cold2      jsr	SetOutConsole
    324  0209		       20 f7 2d 	      jsr	SetInConsole
    325  020c		       20 17 21 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      0  0241					      db	CR,LF,0
      1  0241		       0d 0a 00 	      .byte.b	CR,LF,0
    329  0244							;
    330  0244		       20 0b 23 	      jsr	MemInit	;setup the free space available
    331  0247
    332  0247		       a9 01	   calcstack  lda	#1
    333  0249		       8d c7 36 	      sta	taskCounter	; Initialize number of tasks to 1
    334  024c		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    335  024e		       8d c9 35 	      sta	taskTable	; mark the main task as active
    336  0251		       20 4c 25 	      jsr	taskSetStacks	; setup all the task stacks/Variables, Init task io block
    337  0254		       a9 1c		      lda	#IL&$ff
    338  0256		       85 43		      sta	ILPC
    339  0258		       a9 31		      lda	#IL>>8
    340  025a		       85 44		      sta	ILPC+1
    341  025c							;
    342  025c							;		  lda	  ProgramStart		     ; user prog
    343  025c							;		  sta	  ProgramEnd
    344  025c							;		  lda	  ProgramStart+1
    345  025c							;		  sta	  ProgramEnd+1
    346  025c							;
    347  025c
    348  025c							;  Init time slices defaults
    349  025c		       a9 02		      lda	#TASKCYCLESHIGH
    350  025e		       8d c6 36 	      sta	taskResetValue+1
    351  0261		       a9 ff		      lda	#TASKCYCLESDEFAULT
    352  0263		       8d c5 36 	      sta	taskResetValue
    353  0266							;
    354  0266							; Initialize the pseudo-random number sequence...
    355  0266							;
    356  0266		       a9 5a		      lda	#$5a
    357  0268		       8d 31 42 	      sta	rtemp1
    358  026b		       a9 9d		      lda	#%10011101
    359  026d		       8d 33 42 	      sta	random
    360  0270		       a9 5b		      lda	#%01011011
    361  0272		       8d 34 42 	      sta	random+1
    362  0275							;
    363  0275							;   Insert a Basic irq handler for the basic Language
    364  0275		       a9 d5		      lda	#ServiceIrq&$ff
    365  0277		       8d 00 df 	      sta	IRQvec
    366  027a		       a9 19		      lda	#ServiceIrq>>8
    367  027c		       8d 01 df 	      sta	IRQvec+1
    368  027f		       4c 95 02 	      jmp	coldtwo
    369  0282
    370  0282							;
    371  0282							;
    372  0282							; This is the warm start entry point
    373  0282							;
    374  0282		       20 ea 2d    warm2      jsr	SetOutConsole
    375  0285		       20 f7 2d 	      jsr	SetInConsole
    376  0288		       20 a3 2c 	      jsr	CRLF
    377  028b		       ad 2e 42 	      lda	errGoto
    378  028e		       85 43		      sta	ILPC
    379  0290		       ad 2f 42 	      lda	errGoto+1
    380  0293		       85 44		      sta	ILPC+1
    381  0295							;
    382  0295							; And continue with both starts here
    383  0295							;
    384  0295				   coldtwo
    385  0295							;
    386  0295							; The ILTrace flag is now run-time settable.
    387  0295							;
    388  0295		       a9 00		      lda	#ILTRACE&$ff
    389  0297		       85 40		      sta	ILTrace
    390  0299							;
    391  0299
    392  0299		       a9 00		      lda	#0
    393  029b		       85 5b		      sta	RunMode
    394  029d		       8d a4 41 	      sta	LINBUF
    395  02a0
    396  02a0							; Clear everything from the stacks
    397  02a0
    398  02a0		       8d 3b 42 	      sta	taskIOPending	; No one waiting for io
    399  02a3		       8d 3c 42 	      sta	taskRDPending	; No one waiting for bg io
    400  02a6
    401  02a6		       20 c8 25 	      jsr	taskReset
    402  02a9							;
    403  02a9		       a9 a4		      lda	#LINBUF&$ff
    404  02ab		       85 4f		      sta	CURPTR
    405  02ad		       a9 41		      lda	#LINBUF>>8
    406  02af		       85 50		      sta	CURPTR+1	;fall through...
    407  02b1
    408  02b1							;=====================================================
    409  02b1							; This is the top of the IL interpreter.  This fetches
    410  02b1							; and executes the instruction currently pointed to
    411  02b1							; by ILPC and adjusts ILPC to point to the next
    412  02b1							; instruction to execute.
    413  02b1							;
    414  02b1				   NextIL
    415  02b1		       ba		      tsx		; Get the stack pointer value
    416  02b2		       e0 ff		      cpx	#$FF	; Should be empty
    417  02b4		       d0 29		      bne	ILbad	; Halt and catch fire now!
    418  02b6
    419  02b6		       ce c3 36 	      dec	taskCurrentCycles
    420  02b9		       d0 03		      bne	NextIlNow
    421  02bb		       20 f1 25 	      jsr	iTaskSwitch	;check for a task switch
    422  02be		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    423  02c0		       f0 03		      beq	NextIL2	;Skip if no bits set
    424  02c2
    425  02c2		       20 34 2d 	      jsr	dbgLine	;Print the IL trace information
    426  02c5
    427  02c5		       a4 51	   NextIL2    ldy	CUROFF
    428  02c7							;		  jsr	  SkipSpaces	       ; no longer needed as tokenizer takes care of this
    429  02c7							;		  sty	  CUROFF
    430  02c7							;Task IO Management
    431  02c7		       ad 3c 42 	      lda	taskRDPending	; if it is zero then Nothing pending
    432  02ca		       f0 08		      beq	NextILStr
    433  02cc		       20 dc 2a 	      jsr	ReadLine	; else Pending and poll keyboard
    434  02cf		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    435  02d1		       ce 3c 42 	      dec	taskRDPending	; Carry is set if CR has been recieved
    436  02d4							;
    437  02d4		       20 5f 29    NextILStr  jsr	getILByte
    438  02d7							;
    439  02d7							; When the handler is called, these are the conditions
    440  02d7							; of several important items:
    441  02d7							;
    442  02d7							;    (ILPC) will point to the byte AFTER the IL
    443  02d7							;    opcode being executed.
    444  02d7							;
    445  02d7							;    (CURPTR),CUROFF will point to the start of the
    446  02d7							;    next word in the input buffer.  Ie, the next word
    447  02d7							;    in the user program.
    448  02d7							;
    449  02d7		       18		      clc		; Clear carry before shift
    450  02d8		       0a		      asl		; valid for 0-127
    451  02d9		       b0 04		      bcs	ILbad	; Out of range
    452  02db		       aa		      tax		; Move value to x
      0  02dc					      db	$7c	; jmp (ILTBL,X) ; dasm does not support 65c02 inst
      1  02dc		       7c		      .byte.b	$7c
      0  02dd					      dw	ILTBL	; Actual IL table address
      1  02dd		       20 03		      .word.w	ILTBL
    455  02df
    456  02df							;		asl
    457  02df							;		cmp	#ILTBLend-ILTBL+2
    458  02df							;		bcc	ILgood
    459  02df							;
    460  02df							; This handles an illegal IL opcode.  This is serious
    461  02df							; and there's no way to recover.
    462  02df							;
    463  02df				   iBadOP
    464  02df		       20 17 21    ILbad      jsr	puts
      0  02e2					      db	CR,LF
      1  02e2		       0d 0a		      .byte.b	CR,LF
      0  02e4					      db	"Illegal IL "
      1  02e4		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02ef					      db	0
      1  02ef		       00		      .byte.b	0
    468  02f0							;
    469  02f0							; Well this is awkward, we need to back up the IL
    470  02f0							; by one since it no longer points to the current
    471  02f0							; opcode.
    472  02f0							;
    473  02f0		       20 6c 29 	      jsr	decIL
    474  02f3							;
    475  02f3		       a0 00		      ldy	#0
    476  02f5		       b1 43		      lda	(ILPC),y
    477  02f7		       20 fa 20 	      jsr	OUTHEX
    478  02fa		       20 17 21 	      jsr	puts
      0  02fd					      db	" at ",0
      1  02fd		       20 61 74 20*	      .byte.b	" at ",0
    480  0302		       a5 44		      lda	ILPC+1
    481  0304		       20 fa 20 	      jsr	OUTHEX
    482  0307		       a5 43		      lda	ILPC
    483  0309		       20 fa 20 	      jsr	OUTHEX
    484  030c		       20 a3 2c 	      jsr	CRLF
    485  030f		       4c 03 f0 	      jmp	MONITOR
    486  0312							;
    487  0312							; Just jump to the address (ILPC),y.  Have to do
    488  0312							; some goofy stuff.
    489  0312							;
    490  0312		       a8	   ILgood     tay		;move index into Y
    491  0313		       b9 20 03 	      lda	ILTBL,y
    492  0316		       85 59		      sta	dpl
    493  0318		       b9 21 03 	      lda	ILTBL+1,y
    494  031b		       85 5a		      sta	dpl+1
    495  031d		       6c 59 00 	      jmp	(dpl)	;go to handler
    496  0320							;
    497  0320							;=====================================================
    498  0320							; This is the IL jump table.  The IL opcode is
    499  0320							; mulitplied by two, then looked-up in this table.
    500  0320							; There is absolutely nothing special about the order
    501  0320							; of entries here... they all decode at exactly the
    502  0320							; same speed.	However the entry number must match the
    503  0320							; values in IL.inc.
    504  0320							;
    505  0320				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0320					      include	"ilvectortable.asm"
      1  0320					      seg	Code
      2  0320				   ILTBL1
      0  0320					      dw	iXINIT	;0
      1  0320		       58 04		      .word.w	iXINIT
      0  0322					      dw	iDONE	;1
      1  0322		       75 04		      .word.w	iDONE
      0  0324					      dw	iPRS	;2
      1  0324		       8c 04		      .word.w	iPRS
      0  0326					      dw	iPRN	;3
      1  0326		       94 04		      .word.w	iPRN
      0  0328					      dw	iSPC	;4
      1  0328		       9d 04		      .word.w	iSPC
      0  032a					      dw	iNLINE	;5
      1  032a		       3f 09		      .word.w	iNLINE
      0  032c					      dw	iNXT	;6
      1  032c		       a5 04		      .word.w	iNXT
      0  032e					      dw	iXFER	;7
      1  032e		       e7 04		      .word.w	iXFER
      0  0330					      dw	iSAV	;8
      1  0330		       05 05		      .word.w	iSAV
      0  0332					      dw	iRSTR	;9
      1  0332		       d3 24		      .word.w	iRSTR
      0  0334					      dw	iCMPR	;10
      1  0334		       4b 05		      .word.w	iCMPR
      0  0336					      dw	iINNUM	;11
      1  0336		       ca 05		      .word.w	iINNUM
      0  0338					      dw	iFIN	;12
      1  0338		       02 06		      .word.w	iFIN
      0  033a					      dw	iERR	;13
      1  033a		       16 06		      .word.w	iERR
      0  033c					      dw	iADD	;14
      1  033c		       98 06		      .word.w	iADD
      0  033e					      dw	iSUB	;15
      1  033e		       ae 06		      .word.w	iSUB
      0  0340					      dw	iNEG	;16
      1  0340		       c4 06		      .word.w	iNEG
      0  0342					      dw	iMUL	;17
      1  0342		       dc 06		      .word.w	iMUL
      0  0344					      dw	iDIV	;18
      1  0344		       1c 07		      .word.w	iDIV
      0  0346					      dw	iSTORE	;19
      1  0346		       72 07		      .word.w	iSTORE
      0  0348					      dw	iIND	;20
      1  0348		       90 07		      .word.w	iIND
      0  034a					      dw	iLST	;21
      1  034a		       35 08		      .word.w	iLST
      0  034c					      dw	iINIT	;22
      1  034c		       20 04		      .word.w	iINIT
      0  034e					      dw	iGETLINE	;23
      1  034e		       6b 08		      .word.w	iGETLINE
      0  0350					      dw	iINSRT	;24
      1  0350		       88 08		      .word.w	iINSRT
      0  0352					      dw	iRTN	;25
      1  0352		       39 09		      .word.w	iRTN
      0  0354					      dw	MONITOR	;26
      1  0354		       03 f0		      .word.w	MONITOR
      0  0356					      dw	iLIT	;27
      1  0356		       63 09		      .word.w	iLIT
      0  0358					      dw	iCALL	;28
      1  0358		       45 09		      .word.w	iCALL
      0  035a					      dw	iJMP	;29
      1  035a		       51 09		      .word.w	iJMP
      0  035c					      dw	iVINIT	;30
      1  035c		       88 09		      .word.w	iVINIT
      0  035e					      dw	iERRGOTO	;31
      1  035e		       91 09		      .word.w	iERRGOTO
      0  0360					      dw	iTST	;32
      1  0360		       9d 09		      .word.w	iTST
      0  0362					      dw	iTSTV	;33
      1  0362		       c2 0a		      .word.w	iTSTV
      0  0364					      dw	iTSTL	;34
      1  0364		       68 0b		      .word.w	iTSTL
      0  0366					      dw	iTSTN	;35
      1  0366		       83 0b		      .word.w	iTSTN
      0  0368					      dw	iFREE	;36
      1  0368		       3c 0c		      .word.w	iFREE
      0  036a					      dw	iRANDOM	;37
      1  036a		       42 0c		      .word.w	iRANDOM
      0  036c					      dw	iABS	;38
      1  036c		       13 0d		      .word.w	iABS
     42  036e							;
     43  036e							; Disk functions.  There must be pointers
     44  036e							; to functions even if no disk is supported.
     45  036e							; Makes things easier in IL.inc.
     46  036e							;
     47  036e					      if	DISK_ACCESS
      0  036e					      dw	iOPENREAD	;39
      1  036e		       3d 2f		      .word.w	iOPENREAD
      0  0370					      dw	iOPENWRITE	;40
      1  0370		       9e 2f		      .word.w	iOPENWRITE
      0  0372					      dw	iDCLOSE	;41
      1  0372		       2f 30		      .word.w	iDCLOSE
      0  0374					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0374		       bd 2f		      .word.w	iDGETLINE
      0  0376					      dw	iDLIST	;43 Did you remember your towel?
      1  0376		       29 30		      .word.w	iDLIST
      0  0378					      dw	iDDIR	;44
      1  0378		       04 30		      .word.w	iDDIR
      0  037a					      dw	iRMFILE	;45
      1  037a		       8c 2f		      .word.w	iRMFILE
     55  037c				  -	      else
     56  037c				  -	      dw	NextIL	;39
     57  037c				  -	      dw	NextIL	;40
     58  037c				  -	      dw	NextIL	;41
     59  037c				  -	      dw	NextIL	;42
     60  037c				  -	      dw	NextIL	;43
     61  037c				  -	      dw	NextIL	;44
     62  037c				  -	      dw	NextIL	;45
     63  037c					      endif
     64  037c							;
      0  037c					      dw	iCLEARSCREEN	;46
      1  037c		       04 2e		      .word.w	iCLEARSCREEN
      0  037e					      dw	iPOKEMEMORY	;47
      1  037e		       a0 0c		      .word.w	iPOKEMEMORY
      0  0380					      dw	iPEEKMEMORY	;48
      1  0380		       b5 0c		      .word.w	iPEEKMEMORY
      0  0382					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0382		       e4 09		      .word.w	iTSTLET
      0  0384					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0384		       69 0a		      .word.w	iTSTDONE
      0  0386					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0386		       e2 0c		      .word.w	iGETCHAR
      0  0388					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0388		       f6 0c		      .word.w	iPUTCHAR
      0  038a					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  038a		       cb 0c		      .word.w	iCallFunc
      0  038c					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  038c		       98 05		      .word.w	iBranch
      0  038e					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  038e		       c7 09		      .word.w	iTSTStr
      0  0390					      dw	iSetIrq	;56	   sets the irq handler
      1  0390		       ba 0d		      .word.w	iSetIrq
      0  0392					      dw	iTstIrq	;57	   test if irq is pending
      1  0392		       fa 0b		      .word.w	iTstIrq
      0  0394					      dw	iRET	;58	   return from interupt
      1  0394		       39 05		      .word.w	iRET
      0  0396					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0396		       e3 05		      .word.w	iINSTR
      0  0398					      dw	iMOD	;60	   returns remainder of division
      1  0398		       25 07		      .word.w	iMOD
      0  039a					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  039a		       45 26		      .word.w	iTaskSet
      0  039c					      dw	iETask	;62	   Terminates a task
      1  039c		       82 27		      .word.w	iETask
      0  039e					      dw	iNTask	;63	   goto next task
      1  039e		       35 27		      .word.w	iNTask
     83  03a0				   ILTBL2
      0  03a0					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a0		       af 07		      .word.w	iArray
      0  03a2					      dw	iTaskKill	;65	   kill a running task
      1  03a2		       2d 27		      .word.w	iTaskKill
      0  03a4					      dw	iTaskStat	;66	   return the state of a task PID
      1  03a4		       01 27		      .word.w	iTaskStat
      0  03a6					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03a6		       01 0d		      .word.w	iHexOut
      0  03a8					      dw	iReadComplete	;68	   Called after a background read completes
      1  03a8		       b4 05		      .word.w	iReadComplete
      0  03aa					      dw	iReadStart	;69	   Called to start a background read request
      1  03aa		       aa 05		      .word.w	iReadStart
      0  03ac					      dw	iStartIO	;70	   Lock task until io complete
      1  03ac		       65 27		      .word.w	iStartIO
      0  03ae					      dw	iEndIO	;71	   release task lock for io
      1  03ae		       6b 27		      .word.w	iEndIO
      0  03b0					      dw	iLogNot	;72	   Logical not
      1  03b0		       6c 0d		      .word.w	iLogNot
      0  03b2					      dw	iLogOr	;73	   Logical Or
      1  03b2		       42 0d		      .word.w	iLogOr
      0  03b4					      dw	iLogAnd	;74	   Logical And
      1  03b4		       2d 0d		      .word.w	iLogAnd
      0  03b6					      dw	iLogXor	;75	   Logical Xor
      1  03b6		       57 0d		      .word.w	iLogXor
      0  03b8					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03b8		       40 27		      .word.w	iWTASK
      0  03ba					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03ba		       76 27		      .word.w	iTASKPID
      0  03bc					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03bc		       f8 0d		      .word.w	iTRACEPROG
      0  03be					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03be		       b0 2c		      .word.w	idbgBasic
      0  03c0					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c0		       38 28		      .word.w	iIPCS
      0  03c2					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c2		       4f 28		      .word.w	iIPCR
      0  03c4					      dw	iIPCC	;82	   Check if any message available for task
      1  03c4		       63 28		      .word.w	iIPCC
      0  03c6					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03c6		       70 28		      .word.w	iIPCIO
      0  03c8					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03c8		       39 24		      .word.w	iPushMathStack
      0  03ca					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03ca		       69 24		      .word.w	iPopMathStack
      0  03cc					      dw	iSaveMathStack	;86	   Save all math info
      1  03cc		       86 24		      .word.w	iSaveMathStack
      0  03ce					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03ce		       a5 24		      .word.w	iRestoreMathStack
      0  03d0					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d0		       56 24		      .word.w	iIncParmCount
      0  03d2					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d2		       a2 27		      .word.w	iTaskGetMathStack
      0  03d4					      dw	iTaskEnable	;90	   enable a suspended task
      1  03d4		       cf 26		      .word.w	iTaskEnable
      0  03d6					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03d6		       e9 26		      .word.w	iTaskSuspend
      0  03d8					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03d8		       bc 27		      .word.w	iTaskPutMathPtr
      0  03da					      dw	iTSTVT	;93	   test for another tasks variable
      1  03da		       b9 0a		      .word.w	iTSTVT
      0  03dc					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03dc		       5b 09		      .word.w	iSetR2
      0  03de					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03de		       17 05		      .word.w	iStk2Tmp
      0  03e0					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e0		       28 05		      .word.w	iTmp2Stk
      0  03e2					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e2		       05 0a		      .word.w	iTSTBYTE
      0  03e4					      dw	iINCVAR	;98	   Increment variable
      1  03e4		       8b 0a		      .word.w	iINCVAR
      0  03e6					      dw	iDECVAR	;99	   Decrement variable
      1  03e6		       a3 0a		      .word.w	iDECVAR
      0  03e8					      dw	iSLICE	;100	   set the time slice for tasks
      1  03e8		       cb 27		      .word.w	iSLICE
      0  03ea					      dw	iTSTB	;101	   Test if byte equals
      1  03ea		       24 0a		      .word.w	iTSTB
      0  03ec					      dw	iTSTW	;102	   Test If word equals
      1  03ec		       3f 0a		      .word.w	iTSTW
      0  03ee					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03ee		       b7 1e		      .word.w	iOnGoto
      0  03f0					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03f0		       e8 1e		      .word.w	iTSTRELOP
      0  03f2					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03f2		       cb 04		      .word.w	iRepeatLine
      0  03f4					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch if is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03f4		       0f 1f		      .word.w	iTSTBRANCH
      0  03f6					      dw	iFastXfer	;107	   move top of stack to curptr
      1  03f6		       d2 04		      .word.w	iFastXfer
      0  03f8					      dw	iSetTerminal	;108	   Set the Io Terminal to be used by print and input statements
      1  03f8		       80 2e		      .word.w	iSetTerminal
      0  03fa					      dw	iINDB	;109	   fetch a single byte from memory indirect
      1  03fa		       9d 07		      .word.w	iINDB
      0  03fc					      dw	iSetBlock	;110	   Set a block or words or byte to a value 16 bit length
      1  03fc		       60 23		      .word.w	iSetBlock
      0  03fe					      dw	iCopyBlock	;111	   Copy a block or memory from one location to another 16 bit length
      1  03fe		       b6 23		      .word.w	iCopyBlock
      0  0400					      dw	iCmpBlock	;112	   Compare to parts of memory
      1  0400		       ea 23		      .word.w	iCmpBlock
      0  0402					      dw	iShift	;113	   Shift left 0 or right 1
      1  0402		       90 0d		      .word.w	iShift
    134  0404
      0  0404					      dw	iBadOP	;114	   Invalid IL op code
      1  0404		       df 02		      .word.w	iBadOP
      0  0406					      dw	iBadOP	;115	   Invalid IL op code
      1  0406		       df 02		      .word.w	iBadOP
      0  0408					      dw	iBadOP	;116	   Invalid IL op code
      1  0408		       df 02		      .word.w	iBadOP
      0  040a					      dw	iBadOP	;117	   Invalid IL op code
      1  040a		       df 02		      .word.w	iBadOP
      0  040c					      dw	iBadOP	;118	   Invalid IL op code
      1  040c		       df 02		      .word.w	iBadOP
      0  040e					      dw	iBadOP	;119	   Invalid IL op code
      1  040e		       df 02		      .word.w	iBadOP
      0  0410					      dw	iBadOP	;120	   Invalid IL op code
      1  0410		       df 02		      .word.w	iBadOP
      0  0412					      dw	iBadOP	;121	   Invalid IL op code
      1  0412		       df 02		      .word.w	iBadOP
      0  0414					      dw	iBadOP	;122	   Invalid IL op code
      1  0414		       df 02		      .word.w	iBadOP
      0  0416					      dw	iBadOP	;123	   Invalid IL op code
      1  0416		       df 02		      .word.w	iBadOP
      0  0418					      dw	iBadOP	;124	   Invalid IL op code
      1  0418		       df 02		      .word.w	iBadOP
      0  041a					      dw	iBadOP	;125	   Invalid IL op code
      1  041a		       df 02		      .word.w	iBadOP
      0  041c					      dw	iBadOP	;126	   Invalid IL op code
      1  041c		       df 02		      .word.w	iBadOP
      0  041e					      dw	iBadOP	;127	   Invalid IL op code
      1  041e		       df 02		      .word.w	iBadOP
    149  0420
    150  0420
    151  0420
    152  0420
------- FILE mytb.asm
    507  0420		       04 20	   ILTBLend   equ	*
    508  0420
    509  0420							;
    510  0420							;=====================================================
    511  0420							;=====================================================
    512  0420							;=====================================================
    513  0420							; This marks the start of the handlers for IL opcodes.
    514  0420							;=====================================================
    515  0420							;=====================================================
    516  0420							;=====================================================
    517  0420							;
    518  0420							;
    519  0420		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    520  0422		       85 47		      sta	ILSTACKPTR
    521  0424		       85 4a		      sta	MATHSTACKPTR
    522  0426		       85 4d		      sta	GOSUBSTACKPTR
    523  0428		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    524  042a		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    525  042c							;
    526  042c		       ad 3d 42 	      lda	ProgramStart	; user prog
    527  042f		       85 4f		      sta	CURPTR
    528  0431		       8d ca 35 	      sta	taskTable+1
    529  0434		       8d 3f 42 	      sta	ProgramEnd
    530  0437		       ad 3e 42 	      lda	ProgramStart+1
    531  043a		       85 50		      sta	CURPTR+1
    532  043c		       8d cb 35 	      sta	taskTable+2
    533  043f		       8d 40 42 	      sta	ProgramEnd+1
    534  0442		       a9 80		      lda	#TASKACTIVE
    535  0444		       8d c9 35 	      sta	taskTable	;Mark the first slot as active
    536  0447		       a9 01		      lda	#1
    537  0449		       8d c7 36 	      sta	taskCounter	;there is always one task / Main task
    538  044c		       ad c5 36 	      lda	taskResetValue
    539  044f		       8d c3 36 	      sta	taskCurrentCycles	; set up the task switch counts
    540  0452		       ad c6 36 	      lda	taskResetValue+1
    541  0455		       8d c4 36 	      sta	taskCurrentCycles+1
    542  0458							;
    543  0458							; fall into XINIT...
    544  0458							;
    545  0458							;=====================================================
    546  0458							; This initializes for the start of the next line of
    547  0458							; BASIC text.
    548  0458							;
    549  0458		       78	   iXINIT     sei		; ensure interupts are off
    550  0459		       20 c8 25 	      jsr	taskReset	; Clear the task table
    551  045c		       a9 00		      lda	#0	; Clear the irq flags
    552  045e		       8d 5a 19 	      sta	IRQPending	; reset the irq pending
    553  0461		       8d 59 19 	      sta	IRQStatus	; Make sure irqs are off
    554  0464
    555  0464		       4c b1 02    goodExit   jmp	NextIL
    556  0467							;
    557  0467							;=====================================================
    558  0467							; This check if the escape key has been entered
    559  0467							; then changes out of run mode. z Set if esc found
    560  0467				   BreakSet
    561  0467		       20 0f f0 	      jsr	ISCHAR
    562  046a		       f0 06		      beq	BreakNo
    563  046c		       20 ea 19 	      jsr	VGETCH
    564  046f		       c9 1b		      cmp	#$1B
    565  0471		       60		      rts
    566  0472				   BreakNo
    567  0472		       a9 01		      lda	#1
    568  0474		       60		      rts
    569  0475
    570  0475							;
    571  0475
    572  0475							;=====================================================
    573  0475							; Verify there is nothing else on this input line.
    574  0475							; If there is, generate an error.
    575  0475							;
    576  0475		       a4 51	   iDONE      ldy	CUROFF
    577  0477		       b1 4f		      lda	(CURPTR),y
    578  0479		       f0 0e		      beq	doneadv
    579  047b		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    580  047d		       d0 03		      bne	idoneErr
    581  047f							;		  sty	  CUROFF
    582  047f		       4c b1 02 	      jmp	NextIL	; continue on this line
    583  0482
    584  0482				   idoneErr
    585  0482		       a2 04		      ldx	#ERR_EXTRA_STUFF
    586  0484		       a9 00		      lda	#0
    587  0486		       4c 7d 06 	      jmp	iErr2
    588  0489							;
    589  0489							; Advance to the next line
    590  0489							;
    591  0489				   doneadv
    592  0489		       4c b1 02 	      jmp	NextIL
    593  048c							;
    594  048c							;=====================================================
    595  048c							; Print the string until a closing quote
    596  048c							;
    597  048c				   iPRS
    598  048c		       20 3a 21 	      jsr	PrtQuoted
    599  048f		       84 51		      sty	CUROFF
    600  0491		       4c b1 02 	      jmp	NextIL
    601  0494							;
    602  0494							;=====================================================
    603  0494							; Pop the top off the stack and print it as a signed
    604  0494							; decimal number.
    605  0494							;
    606  0494				   iPRN
    607  0494		       20 ea 2b 	      jsr	popR0
    608  0497		       20 46 20 	      jsr	PrintDecimal
    609  049a		       4c b1 02 	      jmp	NextIL
    610  049d							;
    611  049d							;=====================================================
    612  049d							; Space to next zone.	Currently the code does not
    613  049d							; keep track of which column the output is on, so
    614  049d							; just print a tab.
    615  049d							;
    616  049d				   iSPC
    617  049d		       a9 09		      lda	#TAB
    618  049f		       20 e7 19 	      jsr	VOUTCH
    619  04a2		       4c b1 02 	      jmp	NextIL
    620  04a5							;
    621  04a5							;=====================================================
    622  04a5							; If in immediate mode, jump to the address following
    623  04a5							; the NXT instruction.  Else move to the next line of
    624  04a5							; user code and continue.
    625  04a5							;
    626  04a5		       a5 5b	   iNXT       lda	RunMode
    627  04a7		       d0 03		      bne	iNxtRun	;in run mode
    628  04a9							;
    629  04a9							; Get address and jump to it.
    630  04a9							;
    631  04a9		       4c 51 09 	      jmp	iJMP
    632  04ac							;
    633  04ac				   iNxtRun
    634  04ac		       a4 51		      ldy	CUROFF
    635  04ae		       b1 4f		      lda	(CURPTR),y
    636  04b0		       c9 e6		      cmp	#oColon
    637  04b2		       d0 06		      bne	iNxtRunGo
    638  04b4		       c8		      iny
    639  04b5		       84 51		      sty	CUROFF
    640  04b7		       4c c5 04 	      jmp	iNxtRun2
    641  04ba
    642  04ba				   iNxtRunGo
    643  04ba		       20 e9 29 	      jsr	FindNextLine
    644  04bd		       20 fd 29 	      jsr	AtEnd
    645  04c0		       d0 03		      bne	iNxtRun2	;not at end
    646  04c2							;
    647  04c2							; At the end of the program.  Pretend an END statement
    648  04c2							; was found.
    649  04c2							;
    650  04c2		       4c 02 06    iFINv      jmp	iFIN
    651  04c5							;
    652  04c5		       20 5b 29    iNxtRun2   jsr	getILWord	;ignore next word
    653  04c8		       4c b1 02 	      jmp	NextIL
    654  04cb							;=====================================================
    655  04cb							;Repeat the same line against
    656  04cb		       a0 03	   iRepeatLine ldy	#3
    657  04cd		       84 51		      sty	CUROFF
    658  04cf		       4c b1 02 	      jmp	NextIL
    659  04d2							;
    660  04d2							;=====================================================
    661  04d2							; XFER takes the number on top of the stack and looks
    662  04d2							; for that line in the program, or the next line
    663  04d2							; higher.  Ie, if it's 1 but there is no line 1, then
    664  04d2							; find the next one after that.
    665  04d2							;
    666  04d2				   iFastXfer
    667  04d2		       20 02 2c 	      jsr	popR1	; get type of transfer
    668  04d5		       a5 54		      lda	R1
    669  04d7		       f0 0e		      beq	iXFER
    670  04d9
    671  04d9		       20 ea 2b 	      jsr	popR0	; get where to transfer
    672  04dc		       a5 52		      lda	R0
    673  04de		       85 4f		      sta	CURPTR
    674  04e0		       a5 53		      lda	R0+1
    675  04e2		       85 50		      sta	CURPTR+1
    676  04e4		       4c ed 04 	      jmp	iXFER2
    677  04e7
    678  04e7				   iXFER
    679  04e7		       20 ea 2b 	      jsr	popR0
    680  04ea		       20 a4 29 	      jsr	findLine
    681  04ed
    682  04ed				   iXFER2
    683  04ed		       20 fd 29 	      jsr	AtEnd	;at end of user program?
    684  04f0		       f0 d0		      beq	iFINv
    685  04f2
    686  04f2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    687  04f4		       84 51		      sty	CUROFF
    688  04f6
    689  04f6							;		  lda	  #$ff
    690  04f6							;		  sta	  RunMode
    691  04f6							;
    692  04f6							; Transfer IL to STMT.  I don't like having this
    693  04f6							; hard-coded; fix it.
    694  04f6							;
    695  04f6							;		  lda	  #STMT&$ff
    696  04f6							;		  sta	  ILPC
    697  04f6							;		  lda	  #STMT>>8
    698  04f6							;		  sta	  ILPC+1
    699  04f6							;		  jmp	  NextIL
    700  04f6							;
    701  04f6							; Run
    702  04f6							;
    703  04f6				   iXferok
    704  04f6		       a9 ff		      lda	#$ff
    705  04f8		       85 5b		      sta	RunMode	;we're running
    706  04fa							;
    707  04fa							; Need a more elegant way to do this
    708  04fa							;
    709  04fa		       a9 2a		      lda	#STMT&$ff
    710  04fc		       85 43		      sta	ILPC
    711  04fe		       a9 31		      lda	#STMT>>8
    712  0500		       85 44		      sta	ILPC+1
    713  0502		       4c b1 02 	      jmp	NextIL
    714  0505							;
    715  0505							;=====================================================
    716  0505							; Save the pointer to the next line to the call stack.
    717  0505							;
    718  0505		       20 5f 29    iSAV       jsr	getILByte	; load type of gosub
    719  0508		       20 72 2b 	      jsr	pushLN	; Type passed in A
    720  050b		       b0 03		      bcs	iSAVErr
    721  050d		       4c b1 02 	      jmp	NextIL
    722  0510
    723  0510		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    724  0512		       a9 00	   iSAVErr2   lda	#0
    725  0514		       4c 7d 06 	      jmp	iErr2
    726  0517							;====================================================
    727  0517							; Move stack top to and from temp area
    728  0517				   iStk2Tmp
    729  0517		       20 ea 2b 	      jsr	popR0
    730  051a		       a5 52		      lda	R0
    731  051c		       a0 48		      ldy	#TASKEXITCODE	; can also be used as temp
    732  051e		       91 41		      sta	(VARIABLES),y
    733  0520		       c8		      iny
    734  0521		       a5 53		      lda	R0+1
    735  0523		       91 41		      sta	(VARIABLES),y
    736  0525		       4c b1 02 	      jmp	NextIL
    737  0528
    738  0528		       a0 48	   iTmp2Stk   ldy	#TASKEXITCODE
    739  052a		       b1 41		      lda	(VARIABLES),y
    740  052c		       85 52		      sta	R0
    741  052e		       c8		      iny
    742  052f		       b1 41		      lda	(VARIABLES),y
    743  0531		       85 53		      sta	R0+1
    744  0533		       20 58 2b 	      jsr	pushR0
    745  0536		       4c b1 02 	      jmp	NextIL
    746  0539							;
    747  0539							;=====================================================
    748  0539							; Pop the next line from the call stack. IRQ return
    749  0539							;
    750  0539		       20 9b 2b    iRET       jsr	popLN
    751  053c		       b0 d2		      bcs	iSAVErr
    752  053e		       a0 03		      ldy	#3
    753  0540		       84 51		      sty	CUROFF
    754  0542		       a9 00		      lda	#0
    755  0544		       8d 5a 19 	      sta	IRQPending
    756  0547		       58		      cli
    757  0548		       4c b1 02 	      jmp	NextIL
    758  054b							;
    759  054b							;=====================================================
    760  054b							; Compare items on stack.  Okay, so on input there are
    761  054b							; three things on the stack
    762  054b							;
    763  054b							;    EXPR2 <- Top of stack
    764  054b							;    OP    <- relational operator, next on stack
    765  054b							;    EXPR1 <- last item on stack
    766  054b							;
    767  054b							; Comparison is: EXPR1 <operator> EXPR2
    768  054b							;
    769  054b							; Operator is one of...
    770  054b							;
    771  054b							;    2 is =
    772  054b							;    1 is <
    773  054b							;    3 is <=
    774  054b							;    5 is <>
    775  054b							;    4 is >
    776  054b							;    6 is >=
    777  054b							;
    778  054b							; Those are bit-mapped:
    779  054b							;
    780  054b							;    xxxxxGEL
    781  054b							;
    782  054b							;    G = Greater than
    783  054b							;    E = Equal
    784  054b							;    L = Less than
    785  054b							;
    786  054b							; If the comparison is false, do a NXT, ie, move to the
    787  054b							; next line and continue.  If true, continue executing
    788  054b							; on this line.
    789  054b							;
    790  054b		       00 01	   REL_LT     equ	%001
    791  054b		       00 02	   REL_EQUAL  equ	%010
    792  054b		       00 04	   REL_GT     equ	%100
    793  054b							;
    794  054b		       20 02 2c    iCMPR      jsr	popR1
    795  054e		       20 19 2c 	      jsr	popMQ	;operator in MQ
    796  0551		       20 ea 2b 	      jsr	popR0
    797  0554		       20 5d 05 	      jsr	iCMPRsub
    798  0557		       20 58 2b 	      jsr	pushR0
    799  055a		       4c b1 02 	      jmp	NextIL
    800  055d							;
    801  055d							; See if they are equal or not
    802  055d							;
    803  055d				   iCMPRsub		; Called by internal functions
    804  055d
    805  055d		       a5 52		      lda	R0
    806  055f		       c5 54		      cmp	R1
    807  0561		       d0 0a		      bne	iCMPRnoteq	;try not equal
    808  0563		       a5 53		      lda	R0+1
    809  0565		       c5 55		      cmp	R1+1
    810  0567		       d0 04		      bne	iCMPRnoteq
    811  0569							;
    812  0569							; Equal, set the flag in MQ+1
    813  0569							;
    814  0569		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    815  056b		       d0 14		      bne	iCMPcom	;Exit it is equal
    816  056d							;
    817  056d							; See if EXPR1 (R0) < EXPR2 (R1)
    818  056d							; See www.6502.org/tutorials/compare_beyond.html
    819  056d							;
    820  056d				   iCMPRnoteq
    821  056d		       a5 52		      lda	R0
    822  056f		       c5 54		      cmp	R1	; Sets the carry flag
    823  0571		       a5 53		      lda	R0+1
    824  0573		       e5 55		      sbc	R1+1
    825  0575
    826  0575		       50 02		      bvc	iCMPR_2	; branch if N eor V
    827  0577		       49 80		      eor	#$80
    828  0579
    829  0579		       30 04	   iCMPR_2    bmi	iCMPlt
    830  057b		       a9 04		      lda	#REL_GT
    831  057d		       d0 02		      bne	iCMPcom
    832  057f
    833  057f		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    834  0581
    835  0581				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    836  0581							;
    837  0581							; Now compare the end result with what the caller
    838  0581							; was looking for.
    839  0581							;
    840  0581		       25 56		      and	MQ
    841  0583		       f0 0c		      beq	iCMPno	; no match
    842  0585		       a9 ff		      lda	#$FF	; true is $ffff
    843  0587		       85 52		      sta	R0
    844  0589		       85 53		      sta	R0+1
    845  058b		       d0 0a		      bne	iCMPDone
    846  058d							;
    847  058d							; R0 > R1
    848  058d							;
    849  058d		       a9 04	   iCMPgt     lda	#REL_GT
    850  058f		       d0 f0		      bne	iCMPcom
    851  0591				   iCMPno
    852  0591		       a9 00		      lda	#0
    853  0593		       85 52		      sta	R0
    854  0595		       85 53		      sta	R0+1
    855  0597
    856  0597				   iCMPDone
    857  0597		       60		      rts
    858  0598
    859  0598							;
    860  0598							; if Not a match, so jump to the next line of code.
    861  0598							; Branches based upon value on top of the stack
    862  0598				   iBranch
    863  0598		       20 ea 2b 	      jsr	popR0
    864  059b		       a5 52		      lda	R0
    865  059d		       05 53		      ora	R0+1
    866  059f		       f0 03		      beq	iBranchFalse	; not true
    867  05a1		       4c b1 02 	      jmp	NextIL	; It is true if any value not zero
    868  05a4							;
    869  05a4				   iBranchFalse
    870  05a4		       20 e9 29 	      jsr	FindNextLine
    871  05a7		       4c ed 04 	      jmp	iXFER2
    872  05aa							;
    873  05aa							;=====================================================
    874  05aa							; Start a read of data in background
    875  05aa				   iReadStart
    876  05aa		       a9 3f		      lda	#'?	; Prompt with question mark
    877  05ac		       a6 01		      ldx	1	; Indicate to start read in background
    878  05ae		       20 75 2a 	      jsr	GetLine	; Call the getline to start read
    879  05b1		       4c b1 02 	      jmp	NextIL	; next instruction
    880  05b4							;
    881  05b4							;=====================================================
    882  05b4							; Complete the read and return the curptr, curoff pointing to data
    883  05b4				   iReadComplete
    884  05b4		       a9 01		      lda	#GOSUB_RTN
    885  05b6		       20 72 2b 	      jsr	pushLN
    886  05b9		       90 03		      bcc	iReadOk
    887  05bb		       4c 35 0c    iReadErr   jmp	ErrStkOver	; Check if there was an error
    888  05be				   iReadOk
    889  05be		       20 95 2a 	      jsr	ReadComplete
    890  05c1		       4c b1 02 	      jmp	NextIL
    891  05c4		       20 9b 2b 	      jsr	popLN
    892  05c7		       4c b1 02 	      jmp	NextIL
    893  05ca							;=====================================================
    894  05ca							; Get a line of text from the user, convert to a
    895  05ca							; number, leave on top of stack.
    896  05ca							;
    897  05ca				   iINNUM
    898  05ca		       a9 01		      lda	#GOSUB_RTN
    899  05cc		       20 72 2b 	      jsr	pushLN
    900  05cf		       b0 ea		      bcs	iReadErr	; Stack over flow error
    901  05d1							;
    902  05d1		       a9 3f		      lda	#'?
    903  05d3		       a2 00		      ldx	#0	;Wait for complete
    904  05d5		       20 75 2a 	      jsr	GetLine
    905  05d8		       20 0a 2a 	      jsr	getDecimal
    906  05db		       20 58 2b 	      jsr	pushR0	;put onto stack
    907  05de		       b0 db		      bcs	iReadErr	;StackOverflow error
    908  05e0							;
    909  05e0		       4c fc 05 	      jmp	ExitIn
    910  05e3							;
    911  05e3							;=====================================================
    912  05e3							; Get a line of text from the user, convert to a
    913  05e3							; character value , leave on top of stack. up to 2 characters
    914  05e3							;
    915  05e3				   iINSTR
    916  05e3		       a9 01		      lda	#GOSUB_RTN
    917  05e5		       20 72 2b 	      jsr	pushLN
    918  05e8		       b0 d1		      bcs	iReadErr	; Stack overflow error
    919  05ea		       a9 3f		      lda	#'?
    920  05ec		       a2 00		      ldx	#0	;wait for read complete
    921  05ee		       20 75 2a 	      jsr	GetLine
    922  05f1		       b1 4f		      lda	(CURPTR),y
    923  05f3		       85 52		      sta	R0
    924  05f5		       a9 00		      lda	#0
    925  05f7		       85 53		      sta	R0+1
    926  05f9		       20 58 2b 	      jsr	pushR0	;put onto stack
    927  05fc				   ExitIn
    928  05fc		       20 9b 2b 	      jsr	popLN
    929  05ff		       4c b1 02 	      jmp	NextIL
    930  0602							;
    931  0602							;
    932  0602							;=====================================================
    933  0602							; Stop the currently running program.	Actually very
    934  0602							; simple to do... clear the RunMode flag, then set the
    935  0602							; ILPC to the standard handler and continue running.
    936  0602							;
    937  0602		       a9 00	   iFIN       lda	#0
    938  0604		       85 5b		      sta	RunMode
    939  0606		       20 c8 25 	      jsr	taskReset
    940  0609							;
    941  0609		       ad 2e 42 	      lda	errGoto
    942  060c		       85 43		      sta	ILPC
    943  060e		       ad 2f 42 	      lda	errGoto+1
    944  0611		       85 44		      sta	ILPC+1
    945  0613		       4c b1 02 	      jmp	NextIL
    946  0616							;
    947  0616							;=====================================================
    948  0616							; Handle the ERR opcode.  Following the instruction is
    949  0616							; a 16 bit error number.  Print an error message, and
    950  0616							; if we're in run mode, print the line number.  Stop
    951  0616							; program execution and return to the initial state.
    952  0616							;
    953  0616		       ad 3b 42    iERR       lda	taskIOPending
    954  0619		       f0 03		      beq	iErrNext
    955  061b		       ce 3b 42 	      dec	taskIOPending
    956  061e
    957  061e		       20 5b 29    iErrNext   jsr	getILWord	;get err code
    958  0621		       20 27 06 	      jsr	DisplayError
    959  0624		       4c 80 06 	      jmp	iErrComplete
    960  0627							;
    961  0627							; Enter here with the error code in X (LSB) and A (MSB).
    962  0627							;
    963  0627				   DisplayError
    964  0627		       86 52		      stx	R0
    965  0629		       85 53		      sta	R0+1
    966  062b							;
    967  062b		       20 17 21 	      jsr	puts
      0  062e					      db	CR,LF,"Error ",0
      1  062e		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    969  0637		       20 46 20 	      jsr	PrintDecimal
    970  063a							;
    971  063a		       a5 5b		      lda	RunMode	;running?
    972  063c		       f0 3b		      beq	iERR3	;nope
    973  063e		       20 17 21 	      jsr	puts
      0  0641					      db	" at line ",0
      1  0641		       20 61 74 20*	      .byte.b	" at line ",0
    975  064b		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    976  064d				   iErr2a
    977  064d		       b1 4f		      lda	(CURPTR),y
    978  064f		       85 52		      sta	R0
    979  0651		       c8		      iny
    980  0652		       b1 4f		      lda	(CURPTR),y
    981  0654		       85 53		      sta	R0+1
    982  0656		       20 46 20 	      jsr	PrintDecimal
    983  0659		       20 17 21 	      jsr	puts
      0  065c					      db	":",0
      1  065c		       3a 00		      .byte.b	":",0
    985  065e		       a9 00		      lda	#0
    986  0660		       85 53		      sta	R0+1
    987  0662		       a5 51		      lda	CUROFF
    988  0664		       18		      clc
    989  0665		       e9 03		      sbc	#3
    990  0667		       85 52		      sta	R0
    991  0669		       20 46 20 	      jsr	PrintDecimal
    992  066c		       20 17 21 	      jsr	puts
      0  066f					      db	":",0
      1  066f		       3a 00		      .byte.b	":",0
    994  0671		       ad c8 35 	      lda	taskPtr
    995  0674		       85 52		      sta	R0
    996  0676		       20 fa 20 	      jsr	HexToOut
    997  0679							;
    998  0679				   iERR3
    999  0679		       20 a3 2c 	      jsr	CRLF
   1000  067c		       60		      rts
   1001  067d
   1002  067d				   iErr2
   1003  067d		       20 27 06 	      jsr	DisplayError
   1004  0680
   1005  0680				   iErrComplete
   1006  0680		       20 c0 25 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1007  0683		       a9 00		      lda	#0
   1008  0685		       85 5b		      sta	RunMode	; fall through...
   1009  0687							;
   1010  0687							;=====================================================
   1011  0687							; Reset the IL to be back at the idle loop.  Does not
   1012  0687							; clear variables so the user can see what state
   1013  0687							; the program is in.
   1014  0687							;
   1015  0687		       a9 00	   ResetIL    lda	#0
   1016  0689		       85 47		      sta	ILSTACKPTR
   1017  068b		       ad 2e 42 	      lda	errGoto
   1018  068e		       85 43		      sta	ILPC
   1019  0690		       ad 2f 42 	      lda	errGoto+1
   1020  0693		       85 44		      sta	ILPC+1
   1021  0695		       4c b1 02 	      jmp	NextIL
   1022  0698
   1023  0698							;
   1024  0698							;=====================================================
   1025  0698							; Pop two items off stack, add them, then place the
   1026  0698							; result back onto the stack.
   1027  0698							;
   1028  0698		       20 ea 2b    iADD       jsr	popR0
   1029  069b		       20 02 2c 	      jsr	popR1
   1030  069e				   iADDfast
   1031  069e		       18		      clc
   1032  069f		       a5 52		      lda	R0
   1033  06a1		       65 54		      adc	R1
   1034  06a3		       85 52		      sta	R0
   1035  06a5		       a5 53		      lda	R0+1
   1036  06a7		       65 55		      adc	R1+1
   1037  06a9		       85 53		      sta	R0+1
   1038  06ab		       4c 16 07 	      jmp	pushR0nextIl
   1039  06ae							;
   1040  06ae							;=====================================================
   1041  06ae							; Pop two items off the stack.  Subtract the top of
   1042  06ae							; stack from the lower entry.
   1043  06ae							;
   1044  06ae		       20 02 2c    iSUB       jsr	popR1
   1045  06b1		       20 ea 2b 	      jsr	popR0
   1046  06b4		       38		      sec
   1047  06b5		       a5 52		      lda	R0
   1048  06b7		       e5 54		      sbc	R1
   1049  06b9		       85 52		      sta	R0
   1050  06bb		       a5 53		      lda	R0+1
   1051  06bd		       e5 55		      sbc	R1+1
   1052  06bf		       85 53		      sta	R0+1
   1053  06c1		       4c 16 07 	      jmp	pushR0nextIl
   1054  06c4							;
   1055  06c4							;=====================================================
   1056  06c4							; Negate the top of stack.
   1057  06c4							;
   1058  06c4		       20 ea 2b    iNEG       jsr	popR0
   1059  06c7		       a5 52		      lda	R0
   1060  06c9		       49 ff		      eor	#$ff
   1061  06cb		       85 52		      sta	R0
   1062  06cd		       a5 53		      lda	R0+1
   1063  06cf		       49 ff		      eor	#$ff
   1064  06d1		       85 53		      sta	R0+1
   1065  06d3		       e6 52		      inc	R0
   1066  06d5		       d0 02		      bne	iNEG2
   1067  06d7		       e6 53		      inc	R0+1
   1068  06d9		       4c 16 07    iNEG2      jmp	pushR0nextIl
   1069  06dc							;
   1070  06dc							;=====================================================
   1071  06dc							; Multiply top two items on the stack, put the results
   1072  06dc							; on top.  This uses the algorithm documented on page
   1073  06dc							; 115 of "Microprocessor Programming for Computer
   1074  06dc							; Hobbyists" by Neill Graham.
   1075  06dc							;
   1076  06dc		       20 e2 06    iMUL       jsr	iMultiply
   1077  06df		       4c b1 02 	      jmp	NextIL
   1078  06e2
   1079  06e2				   iMultiply
   1080  06e2		       20 ea 2b 	      jsr	popR0	;AC
   1081  06e5		       20 02 2c 	      jsr	popR1	;OP
   1082  06e8							;
   1083  06e8		       a5 52		      lda	R0
   1084  06ea		       85 56		      sta	MQ
   1085  06ec		       a5 53		      lda	R0+1
   1086  06ee		       85 57		      sta	MQ+1
   1087  06f0		       a9 00		      lda	#0	;clear result
   1088  06f2		       85 52		      sta	R0
   1089  06f4		       85 53		      sta	R0+1
   1090  06f6							;
   1091  06f6		       a2 10		      ldx	#16	;number of bits in value
   1092  06f8		       06 52	   multloop   asl	R0
   1093  06fa		       26 53		      rol	R0+1
   1094  06fc		       06 56		      asl	MQ
   1095  06fe		       26 57		      rol	MQ+1
   1096  0700		       90 0d		      bcc	multno	;skip add if no carry
   1097  0702							;
   1098  0702							; Add R1 back into R0
   1099  0702							;
   1100  0702		       18		      clc
   1101  0703		       a5 52		      lda	R0
   1102  0705		       65 54		      adc	R1
   1103  0707		       85 52		      sta	R0
   1104  0709		       a5 53		      lda	R0+1
   1105  070b		       65 55		      adc	R1+1
   1106  070d		       85 53		      sta	R0+1
   1107  070f							;
   1108  070f		       ca	   multno     dex		;did all bits yet?
   1109  0710		       d0 e6		      bne	multloop
   1110  0712		       20 58 2b 	      jsr	pushR0	;OP
   1111  0715		       60		      rts
   1112  0716							;
   1113  0716				   pushR0nextIl
   1114  0716		       20 58 2b 	      jsr	pushR0	;OP
   1115  0719		       4c b1 02 	      jmp	NextIL
   1116  071c							;
   1117  071c							;=====================================================
   1118  071c							; Divide the top of stack into the next to top item.
   1119  071c							; Leave results on stack.  Taken from:
   1120  071c							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1121  071c							;
   1122  071c							; R0 = R0 / R1
   1123  071c							; Remainder is in MQ
   1124  071c							;
   1125  071c		       20 36 07    iDIV       jsr	iDoDiv
   1126  071f		       20 6b 2c 	      jsr	RestoreSigns
   1127  0722		       4c 16 07 	      jmp	pushR0nextIl
   1128  0725
   1129  0725		       20 36 07    iMOD       jsr	iDoDiv
   1130  0728		       20 6b 2c 	      jsr	RestoreSigns
   1131  072b		       a5 56		      lda	MQ
   1132  072d		       85 52		      sta	R0
   1133  072f		       a5 57		      lda	MQ+1
   1134  0731		       85 53		      sta	R0+1
   1135  0733		       4c 16 07 	      jmp	pushR0nextIl
   1136  0736
   1137  0736				   iDoDiv
   1138  0736		       20 02 2c 	      jsr	popR1
   1139  0739		       20 ea 2b 	      jsr	popR0
   1140  073c							;
   1141  073c							; Check for divide by zero
   1142  073c							;
   1143  073c
   1144  073c				   iDivNoPop
   1145  073c		       a5 54		      lda	R1
   1146  073e		       05 55		      ora	R1+1
   1147  0740		       f0 29		      beq	divby0
   1148  0742							;
   1149  0742		       20 30 2c 	      jsr	SaveSigns
   1150  0745		       a9 00		      lda	#0	;preset remainder to 0
   1151  0747		       85 56		      sta	MQ
   1152  0749		       85 57		      sta	MQ+1
   1153  074b		       a2 10		      ldx	#16	;repeat for each bit: ...
   1154  074d				   divloop
   1155  074d		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1156  074f		       26 53		      rol	R0+1
   1157  0751		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1158  0753		       26 57		      rol	MQ+1
   1159  0755		       a5 56		      lda	MQ
   1160  0757		       38		      sec
   1161  0758		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1162  075a		       a8		      tay		;lb result -> Y, for we may need it later
   1163  075b		       a5 57		      lda	MQ+1
   1164  075d		       e5 55		      sbc	R1+1
   1165  075f		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1166  0761
   1167  0761		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1168  0763		       84 56		      sty	MQ
   1169  0765		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1170  0767
   1171  0767		       ca	   skip       dex
   1172  0768		       d0 e3		      bne	divloop
   1173  076a		       60		      rts
   1174  076b							;
   1175  076b							; Indicate divide-by-zero error
   1176  076b							;
   1177  076b		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
   1178  076d		       a9 00		      lda	#0
   1179  076f		       4c 7d 06 	      jmp	iErr2
   1180  0772							;
   1181  0772							;=====================================================
   1182  0772							; This pops the top two items off the stack.  The top
   1183  0772							; item is a data value and the other is an ABSOLUTE address.
   1184  0772							; Save the value into that address.
   1185  0772							;
   1186  0772		       98	   iSTORE     tya
   1187  0773		       48		      pha
   1188  0774		       20 ea 2b 	      jsr	popR0	;data
   1189  0777		       20 02 2c 	      jsr	popR1	;Storage location
   1190  077a		       a0 01		      ldy	#1
   1191  077c		       a5 58		      lda	R2
   1192  077e		       c9 a2		      cmp	#tByte
   1193  0780		       f0 04		      beq	iStoreB
   1194  0782				   iStoreW
   1195  0782		       a5 53		      lda	R0+1
   1196  0784		       91 54		      sta	(R1),y
   1197  0786				   iStoreB
   1198  0786		       a5 52		      lda	R0
   1199  0788		       88		      dey
   1200  0789		       91 54		      sta	(R1),y
   1201  078b		       68		      pla
   1202  078c		       a8		      tay
   1203  078d		       4c b1 02 	      jmp	NextIL
   1204  0790							;
   1205  0790							;=====================================================
   1206  0790							; Replaces the top of stack with the Value
   1207  0790							; of the variable  whose absolute address it represents.
   1208  0790							;
   1209  0790
   1210  0790		       98	   iIND       tya
   1211  0791		       48		      pha
   1212  0792		       20 02 2c 	      jsr	popR1
   1213  0795		       a0 01		      ldy	#1
   1214  0797		       a5 58		      lda	R2
   1215  0799		       c9 a4		      cmp	#tInteger
   1216  079b		       f0 04		      beq	iINDW
   1217  079d				   iINDB
   1218  079d		       a9 00		      lda	#0
   1219  079f		       f0 02		      BEQ	iINDC
   1220  07a1				   iINDW
   1221  07a1		       b1 54		      lda	(R1),y
   1222  07a3				   iINDC
   1223  07a3		       85 53		      sta	R0+1
   1224  07a5		       88		      dey
   1225  07a6		       b1 54		      lda	(R1),y
   1226  07a8		       85 52		      sta	R0
   1227  07aa		       68		      pla
   1228  07ab		       a8		      tay
   1229  07ac		       4c 16 07 	      jmp	pushR0nextIl
   1230  07af
   1231  07af							;
   1232  07af							;=====================================================
   1233  07af							; Check which type of index to use byte or word and jmp to correct
   1234  07af							; function
   1235  07af		       98	   iArray     tya
   1236  07b0		       48		      pha
   1237  07b1
   1238  07b1		       20 ea 2b 	      jsr	popR0	; Get the array index
   1239  07b4		       20 02 2c 	      jsr	popR1	; Get the Variable address
   1240  07b7
   1241  07b7		       20 5f 29 	      jsr	getILByte	; Get type of number to process
   1242  07ba		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Are we testing a valid parameter
   1243  07bc		       f0 52		      beq	iArrayFNparm	; process a fn pramater index
   1244  07be
   1245  07be		       29 fe		      and	#$FE	; Turn off the unsigned bit
   1246  07c0		       c9 a2		      cmp	#tByte	; Test for a byte index
   1247  07c2		       f0 10		      beq	iArrayB	; yes so branch to process a byte
   1248  07c4							;=====================================================
   1249  07c4							; Process 32 bit index into memory
   1250  07c4		       c9 a6	   iArrayL    cmp	#tLong	; Are we working with 32 bit integers
   1251  07c6		       d0 06		      bne	iArrayW	; Process with sigle shift
   1252  07c8		       06 52		      asl	R0	; Do the multiply by 2
   1253  07ca		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1254  07cc		       b0 39		      bcs	iArrayError	; if the carry is set we have an error
   1255  07ce							;=====================================================
   1256  07ce							; Get the array index from top of stack get Current variable
   1257  07ce							; address from next on stack, add the offset
   1258  07ce							; push the result back onto the stack
   1259  07ce				   iArrayW		; pointers, arrays etc all use 16 bit unsigned integers
   1260  07ce		       06 52		      asl	R0	; Do the multiply by 2
   1261  07d0		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1262  07d2		       b0 33		      bcs	iArrayError	; if the carry is set we have an error
   1263  07d4
   1264  07d4							;=====================================================
   1265  07d4							; Get from Byte array not Integer array
   1266  07d4				   iArrayB
   1267  07d4		       18		      clc
   1268  07d5		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1269  07d7		       65 52		      adc	R0
   1270  07d9		       85 52		      sta	R0
   1271  07db		       a5 55		      lda	R1+1
   1272  07dd		       65 53		      adc	R0+1
   1273  07df		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1274  07e1		       a5 55		      lda	R1+1
   1275  07e3		       cd 40 42 	      cmp	ProgramEnd+1	; lets check if we are processing an @ buffer pointer to free memory
   1276  07e6		       d0 08		      bne	iArrayCheckVar
   1277  07e8				   iArrayExit
   1278  07e8		       20 58 2b 	      jsr	pushR0	; Push R0 assume it is correct
   1279  07eb
   1280  07eb		       68		      pla
   1281  07ec		       a8		      tay
   1282  07ed		       4c b1 02 	      jmp	NextIL
   1283  07f0							; Check for valis variable and valid index to use
   1284  07f0		       a5 41	   iArrayCheckVar lda	VARIABLES
   1285  07f2		       18		      clc
   1286  07f3		       69 33		      adc	#[25*2]+1	; the number of actual variable valid bytes
   1287  07f5		       85 56		      sta	MQ	; mq contains the last valid byte we can use
   1288  07f7		       a9 00		      lda	#0
   1289  07f9		       65 42		      adc	VARIABLES+1	; Memory past last word R0+1 > A then invalid
   1290  07fb		       c5 53		      cmp	R0+1
   1291  07fd		       90 08		      bcc	iArrayError
   1292  07ff		       a5 52		      lda	R0	; a > m invalid past last byte of variable area
   1293  0801		       c5 56		      cmp	MQ
   1294  0803		       f0 e3		      beq	iArrayExit	; If it is equal then it is valid
   1295  0805		       90 e1		      bcc	iArrayExit	; if it is less it is valid
   1296  0807
   1297  0807							; Get here if array index is out of range
   1298  0807		       68	   iArrayError pla
   1299  0808		       98		      tya
   1300  0809		       a9 00		      lda	#0
   1301  080b		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1302  080d		       4c 7d 06 	      jmp	iErr2
   1303  0810							;=====================================================
   1304  0810							; Verify function paramater index is valid
   1305  0810		       20 22 25    iArrayFNparm jsr	GosubFindParms	; Get a pointer to the current functions parameter list info
   1306  0813		       90 f2		      bcc	iArrayError	; There are no paramters for this call, should never be true
   1307  0815		       88		      dey
   1308  0816		       88		      dey		; Points to parameter count
   1309  0817		       a5 52		      lda	R0	; get parm to be accessed
   1310  0819		       d1 4b		      cmp	(GOSUBSTACK),y	; compare to max number allowed
   1311  081b		       b0 ea		      bcs	iArrayError	; the parameter index should be less than the count
   1312  081d		       c9 00		      cmp	#0
   1313  081f		       f0 c7		      beq	iArrayExit	; Skip the rest if index is zero
   1314  0821		       06 52		      asl	R0	; Do the multiply by 2
   1315  0823		       26 53		      rol	R0+1
   1316  0825
   1317  0825		       18		      clc
   1318  0826		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1319  0828		       65 52		      adc	R0
   1320  082a		       85 52		      sta	R0
   1321  082c		       a5 55		      lda	R1+1
   1322  082e		       65 53		      adc	R0+1
   1323  0830		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1324  0832		       4c e8 07 	      jmp	iArrayExit	; Get ot we are done
   1325  0835							;
   1326  0835							;=====================================================
   1327  0835							; List the current BASIC program in memory.  Uses R0,
   1328  0835							; tempIly, and dpl.
   1329  0835							;
   1330  0835		       20 ea 2d    iLST       jsr	SetOutConsole
   1331  0838		       ad 3d 42    iLST2      lda	ProgramStart
   1332  083b		       85 59		      sta	dpl
   1333  083d		       ad 3e 42 	      lda	ProgramStart+1
   1334  0840		       85 5a		      sta	dpl+1
   1335  0842							;
   1336  0842							; dpl/dph point to the current line.  See if we're at
   1337  0842							; the end of the program.
   1338  0842							;
   1339  0842		       a5 59	   iLSTloop   lda	dpl
   1340  0844		       cd 3f 42 	      cmp	ProgramEnd
   1341  0847		       d0 07		      bne	iLstNotEnd
   1342  0849		       a5 5a		      lda	dpl+1
   1343  084b		       cd 40 42 	      cmp	ProgramEnd+1
   1344  084e		       f0 15		      beq	iLstdone
   1345  0850							;
   1346  0850		       20 af 21    iLstNotEnd jsr	PrintProgramLine
   1347  0853							;		  ldy	  #1		  ;Change:  Skip first byte length
   1348  0853							;		  lda	  (dpl),y	  ;line number LSB
   1349  0853							;		  sta	  R0
   1350  0853							;		  iny
   1351  0853							;		  lda	  (dpl),y		 ;line number MSB
   1352  0853							;		  sta	  R0+1
   1353  0853							;		  iny
   1354  0853							;		  sty	  tempIlY
   1355  0853							;		  jsr	  PrintDecimal
   1356  0853							;		  lda	  #SPACE
   1357  0853							;		  jsr	  VOUTCH
   1358  0853							;		  ldy	  tempIlY
   1359  0853							;iLSTl2	  lda	  (dpl),y
   1360  0853							;		  beq	  iLST3 	  ;end of this line 0 value
   1361  0853							;		  sty	  tempIlY
   1362  0853							;		  jsr	  VOUTCH
   1363  0853							;		  ldy	  tempIlY
   1364  0853							;		  iny
   1365  0853							;		  bne	  iLSTl2	  ;do next char
   1366  0853							;
   1367  0853							; End of this line.  Print CR/LF, then move to the
   1368  0853							; next line.
   1369  0853							;
   1370  0853		       a0 00	   iLST3      ldy	#0	;Move to next line
   1371  0855		       b1 59		      lda	(dpl),y	;Current line length
   1372  0857		       18		      clc		;Clear the carry flag
   1373  0858							;		  tya
   1374  0858		       65 59		      adc	dpl	;Add the offset to the pointer
   1375  085a		       85 59		      sta	dpl	;Save the new value
   1376  085c		       a5 5a		      lda	dpl+1	;Next byte
   1377  085e		       69 00		      adc	#0	;ad in the carry if any
   1378  0860		       85 5a		      sta	dpl+1	;Save it
   1379  0862							;
   1380  0862							; Have to manually do CR/LF so it uses the vectored
   1381  0862							; output function.
   1382  0862							;
   1383  0862							;		  lda	  #CR
   1384  0862							;		  jsr	  VOUTCH
   1385  0862							;		  lda	  #LF
   1386  0862							;		  jsr	  VOUTCH
   1387  0862		       4c 42 08 	      jmp	iLSTloop	;do next line
   1388  0865							;
   1389  0865		       20 ea 2d    iLstdone   jsr	SetOutConsole
   1390  0868		       4c b1 02 	      jmp	NextIL
   1391  086b							;
   1392  086b							;=====================================================
   1393  086b							; Get a line of text into LINBUF.  Terminate with a
   1394  086b							; null byte.
   1395  086b							;
   1396  086b				   iGETLINE
   1397  086b		       a9 3e		      lda	#'>	;prompt character
   1398  086d		       a6 00		      ldx	0	;Wait for read to complete
   1399  086f		       20 75 2a 	      jsr	GetLine
   1400  0872							;
   1401  0872		       a9 00		      lda	#0
   1402  0874		       85 5b		      sta	RunMode
   1403  0876				   iGetParseLine
   1404  0876							; lda	   CUROFF
   1405  0876							; pha
   1406  0876		       20 c1 1c 	      jsr	ParseInputLine
   1407  0879							; pla
   1408  0879							;  sta     CUROFF
   1409  0879		       a9 be		      lda	#TOKENBUFFER&$FF
   1410  087b		       85 4f		      sta	CURPTR
   1411  087d		       a9 1b		      lda	#TOKENBUFFER>>8
   1412  087f		       85 50		      sta	CURPTR+1
   1413  0881		       a9 01		      lda	#1
   1414  0883		       85 51		      sta	CUROFF
   1415  0885		       4c b1 02 	      jmp	NextIL
   1416  0888							;
   1417  0888							;=====================================================
   1418  0888							; This is called when the input buffer contains a line
   1419  0888							; typed in by the user that starts with a line number.
   1420  0888							; Insert the line into the program or delete the line
   1421  0888							; if there is nothing after the line number,
   1422  0888							;
   1423  0888				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1424  0888		       ad bf 1b 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1425  088b		       85 52		      sta	R0	; place the number into R0
   1426  088d		       ad c0 1b 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1427  0890		       85 53		      STA	R0+1	; Place it into
   1428  0892							;
   1429  0892							; Now find the line OR the next higher line OR the
   1430  0892							; end of the program.
   1431  0892							;
   1432  0892		       20 a4 29 	      jsr	findLine	; Look for the line number in the current program
   1433  0895							; Returns Z and curptr point to the line if found
   1434  0895							; Returns C and curptr at next higher line if not found and there is a higher line
   1435  0895							; Returns ZC clear and curptr to end of program if higher than all other lines
   1436  0895							;
   1437  0895							; If the line exists, it needs to be removed.
   1438  0895							;
   1439  0895		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1440  0897							;
   1441  0897							; Get length of line to be removed, we fall thru to here if we find a matching line
   1442  0897							;
   1443  0897							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1444  0897		       a0 00		      ldy	#0
   1445  0899		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1446  089b		       a8		      tay
   1447  089c							;If it is equal we delete the line and replace it, get length
   1448  089c							;then adjust all program line after up or down depending on len of line
   1449  089c							;If next higher then just move everythimg down by length bytes
   1450  089c							;This call will return how many bytes in the line we found
   1451  089c		       8c 3a 42 	      sty	lineLength	;Save the length of the line we found
   1452  089f							;
   1453  089f							; Compute the new end of the program first.
   1454  089f							;
   1455  089f		       38		      sec		;Set the carry bit
   1456  08a0		       ad 3f 42 	      lda	ProgramEnd	;Get low byte of program end
   1457  08a3		       ed 3a 42 	      sbc	lineLength	;Subtract the length of the current line
   1458  08a6		       8d 3f 42 	      sta	ProgramEnd	;save it
   1459  08a9		       ad 40 42 	      lda	ProgramEnd+1
   1460  08ac		       e9 00		      sbc	#0	;Process the carry
   1461  08ae		       8d 40 42 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1462  08b1							;
   1463  08b1							; Copy CURPTR into R1 for working
   1464  08b1							;
   1465  08b1		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1466  08b3		       85 54		      sta	R1
   1467  08b5		       a5 50		      lda	CURPTR+1
   1468  08b7		       85 55		      sta	R1+1
   1469  08b9							;
   1470  08b9							; See if we're at the end.
   1471  08b9							;
   1472  08b9		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1473  08bb		       cd 3f 42 	      cmp	ProgramEnd
   1474  08be		       d0 07		      bne	InsDelLoop
   1475  08c0		       a5 55		      lda	R1+1
   1476  08c2		       cd 40 42 	      cmp	ProgramEnd+1
   1477  08c5		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1478  08c7							;
   1479  08c7							; Move one byte, move to next location.
   1480  08c7							;
   1481  08c7		       ac 3a 42    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1482  08ca		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1483  08cc		       b1 54		      lda	(R1),y
   1484  08ce		       a0 00		      ldy	#0
   1485  08d0		       91 54		      sta	(R1),y
   1486  08d2		       e6 54		      inc	R1
   1487  08d4		       d0 e3		      bne	InsDelChk
   1488  08d6		       e6 55		      inc	R1+1
   1489  08d8		       4c b9 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1490  08db							;
   1491  08db							; Deletion is done.
   1492  08db							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1493  08db							;
   1494  08db				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1495  08db		       ad be 1b 	      lda	TOKENBUFFER	; Get the length
   1496  08de		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1497  08e0							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1498  08e0		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1499  08e2							;
   1500  08e2							; CURPTR points to where the line will be inserted.
   1501  08e2							;
   1502  08e2							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1503  08e2		       ae be 1b 	      ldx	TOKENBUFFER
   1504  08e5		       8e 3a 42 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1505  08e8							;
   1506  08e8		       ad 3f 42 	      lda	ProgramEnd	;Load the start address for the copy
   1507  08eb							;At this point curptr still contains the location we will insert data
   1508  08eb		       85 5c		      sta	FROM
   1509  08ed		       ad 40 42 	      lda	ProgramEnd+1
   1510  08f0		       85 5d		      sta	FROM+1
   1511  08f2							;
   1512  08f2		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1513  08f4		       b1 5c		      lda	(FROM),y
   1514  08f6		       ac 3a 42 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1515  08f9		       91 5c		      sta	(FROM),y	;Save the new byte
   1516  08fb							;
   1517  08fb		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1518  08fd		       c5 4f		      cmp	CURPTR
   1519  08ff		       d0 06		      bne	mvUpMore
   1520  0901		       a5 5d		      lda	FROM+1
   1521  0903		       c5 50		      cmp	CURPTR+1
   1522  0905		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1523  0907							;
   1524  0907							; Not done yet
   1525  0907							;
   1526  0907		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1527  0909		       d0 02		      bne	mvUpMore2
   1528  090b		       c6 5d		      dec	FROM+1
   1529  090d		       c6 5c	   mvUpMore2  dec	FROM
   1530  090f		       4c f2 08 	      jmp	mvup1	;Loop until everything is moved
   1531  0912							;
   1532  0912							; All done with copy.
   1533  0912							;
   1534  0912				   mvUpDone
   1535  0912		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1536  0913		       ad 3a 42 	      lda	lineLength	;Number of bytes to copy from line buff
   1537  0916		       6d 3f 42 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1538  0919		       8d 3f 42 	      sta	ProgramEnd
   1539  091c		       ad 40 42 	      lda	ProgramEnd+1
   1540  091f		       69 00		      adc	#0
   1541  0921		       8d 40 42 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1542  0924							;
   1543  0924							;===================jlit use length before line newline
   1544  0924
   1545  0924		       a0 00		      ldy	#0	;Set offset of copy
   1546  0926							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1547  0926							;		  sta	  (CURPTR),y	  ;Store the length
   1548  0926							;		  iny
   1549  0926							;		  lda	  R0		  ;Store the line number next
   1550  0926							;		  sta	  (CURPTR),y
   1551  0926							;		  iny
   1552  0926							;		  lda	  R0+1
   1553  0926							;		  sta	  (CURPTR),y
   1554  0926							;		  iny
   1555  0926							;
   1556  0926							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1557  0926		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1558  0928				   mvUpLoop2
   1559  0928							;		  lda	  LINBUF,x	 ;get a byte
   1560  0928		       bd be 1b 	      lda	TOKENBUFFER,x	;get a byte
   1561  092b		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1562  092d
   1563  092d		       e8		      inx
   1564  092e		       ec be 1b 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1565  0931		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1566  0933		       c8		      iny
   1567  0934		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1568  0936							;
   1569  0936		       4c b1 02    mvUpFini   jmp	NextIL
   1570  0939							;
   1571  0939							;=====================================================
   1572  0939							; Pops the top value of the ILPC stack and stores it
   1573  0939							; in ILPC.  Ie, return from an IL subroutine.
   1574  0939							;
   1575  0939		       20 92 29    iRTN       jsr	popILPC
   1576  093c		       4c b1 02 	      jmp	NextIL
   1577  093f							;
   1578  093f							;=====================================================
   1579  093f							; NLINE print a newline
   1580  093f							;
   1581  093f		       20 a3 2c    iNLINE     jsr	CRLF	;user supplied sub
   1582  0942		       4c b1 02 	      jmp	NextIL
   1583  0945							;
   1584  0945							;=====================================================
   1585  0945							; This saves the current ILPC value on the stack, then
   1586  0945							; jumps to the address specified by the next two bytes.
   1587  0945							;
   1588  0945		       20 75 29    iCALL      jsr	pushILPC	;save ILPC
   1589  0948		       90 07		      bcc	iJMP
   1590  094a
   1591  094a							;If the push failed not enough stack space
   1592  094a		       a2 15	   ErrILStkOver ldx	#ERR_IL_STACK_OVER_FLOW	; Flag any error in line number
   1593  094c		       a9 00		      lda	#0	; stop the execution
   1594  094e		       4c 7d 06 	      jmp	iErr2
   1595  0951							;
   1596  0951							; Jmp to a specific location in the IL code.  The new
   1597  0951							; address immediately follows the opcode.
   1598  0951							;
   1599  0951		       20 5b 29    iJMP       jsr	getILWord
   1600  0954		       86 43		      stx	ILPC
   1601  0956		       85 44		      sta	ILPC+1
   1602  0958		       4c b1 02 	      jmp	NextIL
   1603  095b
   1604  095b
   1605  095b							;
   1606  095b							;=====================================================
   1607  095b							; Push the next two bytes onto the arithmetic stack.
   1608  095b							;
   1609  095b		       20 5f 29    iSetR2     jsr	getILByte
   1610  095e		       85 58		      sta	R2
   1611  0960		       4c b1 02 	      jmp	NextIL
   1612  0963							;
   1613  0963							;=====================================================
   1614  0963							; Push the next two bytes onto the arithmetic stack.
   1615  0963							;
   1616  0963		       20 5b 29    iLIT       jsr	getILWord
   1617  0966		       86 52		      stx	R0
   1618  0968		       85 53		      sta	R0+1
   1619  096a		       20 58 2b 	      jsr	pushR0
   1620  096d		       4c b1 02 	      jmp	NextIL
   1621  0970							;
   1622  0970							;=====================================================
   1623  0970							; Initialize all variables for a single task.	Ie, set to zero.
   1624  0970							; And internal stack pointers
   1625  0970							;
   1626  0970		       98	   subVINIT   tya
   1627  0971		       48		      pha
   1628  0972
   1629  0972		       a9 00		      lda	#0
   1630  0974		       a0 00		      ldy	#0
   1631  0976		       91 41	   Vinit2     sta	(VARIABLES),y
   1632  0978		       c8		      iny
   1633  0979		       c0 48		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1634  097b		       90 f9		      bcc	Vinit2
   1635  097d		       85 4a		      sta	MATHSTACKPTR	; Clear the math stack
   1636  097f		       85 4d		      sta	GOSUBSTACKPTR	; Clear the gosub stack
   1637  0981		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reset the message queue
   1638  0983		       85 4e		      STA	MESSAGEPTR
   1639  0985
   1640  0985		       68		      pla
   1641  0986		       a8		      tay
   1642  0987		       60		      rts
   1643  0988
   1644  0988				   iVINIT
   1645  0988		       20 70 09 	      jsr	subVINIT
   1646  098b		       20 51 1f 	      jsr	Compile	; compile line numbers to memory pointers
   1647  098e		       4c b1 02 	      jmp	NextIL
   1648  0991							;
   1649  0991							;=====================================================
   1650  0991							; Set the address of the error handler.  After any
   1651  0991							; error, set to the ILPC to the specified location.
   1652  0991							;
   1653  0991		       20 5b 29    iERRGOTO   jsr	getILWord
   1654  0994		       8e 2e 42 	      stx	errGoto
   1655  0997		       8d 2f 42 	      sta	errGoto+1
   1656  099a		       4c b1 02 	      jmp	NextIL
   1657  099d							;
   1658  099d							;=====================================================
   1659  099d							; TST is followed by an 8 bit signed offset, then a
   1660  099d							; null terminated string.  Compare the string against
   1661  099d							; the string starting at (CURPTR),CUROFF.  If the
   1662  099d							; strings match, continue executing the next IL
   1663  099d							; opcode.  Else, add the offset to ILPC.
   1664  099d							;
   1665  099d		       20 5f 29    iTST       jsr	getILByte	;Get the relative jump address
   1666  09a0		       8d 39 42 	      sta	offset	;save it to use if test faile
   1667  09a3		       20 42 2b 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1668  09a6
   1669  09a6		       a4 51		      ldy	CUROFF
   1670  09a8		       84 59		      sty	dpl	;save for later
   1671  09aa							;
   1672  09aa		       20 5f 29    iTSTloop   jsr	getILByte	;get next char
   1673  09ad		       f0 11		      beq	iTSTm	;match!
   1674  09af		       a4 59		      ldy	dpl
   1675  09b1		       d1 4f		      cmp	(CURPTR),y
   1676  09b3		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1677  09b5		       09 20		      ora	#$20	; lets allow lowercase as well
   1678  09b7		       d1 4f		      cmp	(CURPTR),y
   1679  09b9		       d0 23		      bne	iTSTfail	;mismatch
   1680  09bb		       c8	   iTSTUpper  iny
   1681  09bc		       84 59		      sty	dpl
   1682  09be		       d0 ea		      bne	iTSTloop
   1683  09c0							;
   1684  09c0							; It's a match!  Clean up a bit.
   1685  09c0							;
   1686  09c0		       a4 59	   iTSTm      ldy	dpl
   1687  09c2		       84 51		      sty	CUROFF
   1688  09c4		       4c b1 02 	      jmp	NextIL
   1689  09c7
   1690  09c7							; Test for a single quote string
   1691  09c7		       20 5f 29    iTSTStr    jsr	getILByte
   1692  09ca		       8d 39 42 	      sta	offset
   1693  09cd		       20 42 2b 	      jsr	saveIL
   1694  09d0		       a4 51		      ldy	CUROFF
   1695  09d2		       a9 22		      lda	#'"
   1696  09d4		       d1 4f		      cmp	(CURPTR),y
   1697  09d6		       d0 06		      bne	iTSTfail
   1698  09d8		       c8		      iny
   1699  09d9		       84 51		      sty	CUROFF
   1700  09db		       4c d4 02 	      jmp	NextILStr
   1701  09de							;
   1702  09de							; Not a match, reset ILPC and then move to the
   1703  09de							; offset.
   1704  09de							;
   1705  09de		       20 4d 2b    iTSTfail   jsr	restoreIL
   1706  09e1		       4c db 0b 	      jmp	tstBranch
   1707  09e4							;
   1708  09e4							;=================================================JLIT=
   1709  09e4							; Test if we have a let statement without the let keyword
   1710  09e4		       20 5f 29    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1711  09e7		       8d 39 42 	      sta	offset	; Save the jump offset for fails
   1712  09ea		       20 42 2b 	      jsr	saveIL	; save to restore when done if fail
   1713  09ed
   1714  09ed		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1715  09ef		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1716  09f1		       c9 01		      cmp	#kLet	; Is it a let keyword
   1717  09f3		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1718  09f5		       c9 80		      cmp	#tVa	; lets check for a variable
   1719  09f7		       90 e5		      bcc	iTSTfail	; Less than variable range
   1720  09f9		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1721  09fb		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1722  09fd		       b0 df		      bcs	iTSTfail	; return it failed
   1723  09ff
   1724  09ff				   iTSTLETGOOD
   1725  09ff		       c8		      iny
   1726  0a00		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1727  0a02				   iTSTGOODVAR
   1728  0a02		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1729  0a05
   1730  0a05							;=================================================JLIT=
   1731  0a05							; Test a byte at an indirect address
   1732  0a05							; fails if byte is not equal to the value at the address
   1733  0a05							; The tests an indirect byte and branches if true
   1734  0a05		       20 5f 29    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1735  0a08		       8d 39 42 	      sta	offset	; Save the jump offset for fails
   1736  0a0b		       20 42 2b 	      jsr	saveIL	; save to restore when done if fail
   1737  0a0e		       20 5b 29 	      jsr	getILWord	; Get a word into RO
   1738  0a11		       86 52		      stx	R0
   1739  0a13		       85 53		      sta	R0+1
   1740  0a15		       20 5f 29 	      jsr	getILByte	; Get byte into A
   1741  0a18		       a0 00		      ldy	#0
   1742  0a1a		       d1 52		      cmp	(R0),y
   1743  0a1c		       d0 03		      bne	iTSTByteNotEqual
   1744  0a1e		       4c de 09 	      jmp	iTSTfail
   1745  0a21
   1746  0a21				   iTSTByteNotEqual
   1747  0a21		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1748  0a24
   1749  0a24							;=================================================JLIT=
   1750  0a24							; Test a byte	branch if it fails
   1751  0a24		       20 5f 29    iTSTB      jsr	getILByte	; Get the relative offset byte
   1752  0a27		       8d 39 42 	      sta	offset	; Save the jump offset for fails
   1753  0a2a		       20 42 2b 	      jsr	saveIL	; save to restore when done if fail
   1754  0a2d		       20 5f 29 	      jsr	getILByte	; Get a byte into Acc
   1755  0a30		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1756  0a32		       d1 4f		      cmp	(CURPTR),y
   1757  0a34		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1758  0a36		       4c de 09 	      jmp	iTSTfail	; REcover and move on to next test
   1759  0a39
   1760  0a39				   iTSTBMatch
   1761  0a39		       c8		      iny
   1762  0a3a		       84 51		      sty	CUROFF	; Point to the next byte
   1763  0a3c		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1764  0a3f
   1765  0a3f							;=================================================JLIT=
   1766  0a3f							; Test a byte	branch if it fails
   1767  0a3f		       20 5f 29    iTSTW      jsr	getILByte	; Get the relative offset byte
   1768  0a42		       8d 39 42 	      sta	offset	; Save the jump offset for fails
   1769  0a45		       20 42 2b 	      jsr	saveIL	; save to restore when done if fail
   1770  0a48		       20 5b 29 	      jsr	getILWord	; Get a word into RO
   1771  0a4b		       86 52		      stx	R0
   1772  0a4d		       85 53		      sta	R0+1
   1773  0a4f		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1774  0a51		       8a		      txa
   1775  0a52		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1776  0a54		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1777  0a56		       4c de 09 	      jmp	iTSTfail	; REcover and move on to next test
   1778  0a59		       c8	   iTSTWM1    iny
   1779  0a5a		       a5 53		      lda	R0+1
   1780  0a5c		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1781  0a5e		       f0 03		      beq	iTSTWMatch
   1782  0a60		       4c de 09 	      jmp	iTSTfail
   1783  0a63
   1784  0a63				   iTSTWMatch
   1785  0a63		       c8		      iny
   1786  0a64		       84 51		      sty	CUROFF
   1787  0a66		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1788  0a69
   1789  0a69							;================================================jLIT=
   1790  0a69							;Test for end of line
   1791  0a69							;
   1792  0a69				   iTSTDONE
   1793  0a69		       20 5f 29 	      jsr	getILByte
   1794  0a6c		       8d 39 42 	      sta	offset
   1795  0a6f		       20 42 2b 	      jsr	saveIL
   1796  0a72		       a4 51		      ldy	CUROFF
   1797  0a74		       84 59		      sty	dpl
   1798  0a76		       b1 4f		      lda	(CURPTR),y
   1799  0a78		       f0 0b		      beq	iTSTDONEtrue
   1800  0a7a		       c9 e6		      cmp	#oColon
   1801  0a7c		       f0 07		      beq	iTSTDONEtrue
   1802  0a7e		       a4 59		      ldy	dpl
   1803  0a80		       84 51		      sty	CUROFF
   1804  0a82		       4c de 09 	      jmp	iTSTfail
   1805  0a85							;
   1806  0a85							; Advance to the next line
   1807  0a85							;
   1808  0a85				   iTSTDONEtrue
   1809  0a85		       4c b1 02 	      jmp	NextIL
   1810  0a88
   1811  0a88		       4c db 0b    tstBranchLink jmp	tstBranch
   1812  0a8b							;
   1813  0a8b							;=====================================================
   1814  0a8b							; Inc and dec a variable , faster than a = a + 1
   1815  0a8b				   iINCVAR
   1816  0a8b		       20 ea 2b 	      jsr	popR0
   1817  0a8e		       a0 00		      ldy	#0
   1818  0a90		       18		      clc
   1819  0a91		       a9 01		      lda	#1
   1820  0a93		       71 52		      adc	(R0),y
   1821  0a95		       91 52		      sta	(R0),y
   1822  0a97		       90 07		      bcc	iINCDONE
   1823  0a99		       c8		      iny
   1824  0a9a		       a9 00		      lda	#0
   1825  0a9c		       71 52		      adc	(R0),y
   1826  0a9e		       91 52		      sta	(R0),y
   1827  0aa0				   iINCDONE
   1828  0aa0		       4c b1 02 	      jmp	NextIL
   1829  0aa3
   1830  0aa3				   iDECVAR
   1831  0aa3		       20 ea 2b 	      jsr	popR0
   1832  0aa6		       a0 00		      ldy	#0
   1833  0aa8		       38		      sec
   1834  0aa9		       b1 52		      lda	(R0),y
   1835  0aab		       e9 01		      sbc	#1
   1836  0aad		       91 52		      sta	(R0),y
   1837  0aaf		       c8		      iny
   1838  0ab0		       b1 52		      lda	(R0),y
   1839  0ab2		       e9 00		      sbc	#0
   1840  0ab4		       91 52		      sta	(R0),y
   1841  0ab6		       4c b1 02 	      jmp	NextIL
   1842  0ab9
   1843  0ab9
   1844  0ab9							;
   1845  0ab9							;=====================================================
   1846  0ab9							; TSTV is followed by an 8 bit signed offset.	If the
   1847  0ab9							; value at (CURPTR),CUROFF appears to be a variable
   1848  0ab9							; name, move to the next IL statement.  Else, add the
   1849  0ab9							; offset to ILPC. Converted to use actual absolute memory addresses
   1850  0ab9							; TSTVT Looks for the task context
   1851  0ab9							;
   1852  0ab9		       20 02 2c    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1853  0abc		       a9 00		      lda	#0
   1854  0abe		       85 58		      sta	R2
   1855  0ac0		       f0 04		      beq	iTSTVV
   1856  0ac2
   1857  0ac2							; Test for simple variable
   1858  0ac2		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1859  0ac4		       85 58		      sta	R2
   1860  0ac6
   1861  0ac6		       20 5f 29    iTSTVV     jsr	getILByte	;offset
   1862  0ac9		       8d 39 42 	      sta	offset
   1863  0acc							;
   1864  0acc		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1865  0ace		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1866  0ad0		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1867  0ad2		       4c 88 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1868  0ad5							;
   1869  0ad5				   iTSTVnext
   1870  0ad5		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1871  0ad7		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1872  0ad9
   1873  0ad9		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1874  0adb		       f0 5b		      beq	iTSTVParm
   1875  0add
   1876  0add		       c9 9b		      cmp	#tVhat	; task exit code
   1877  0adf		       d0 04		      bne	iTSTV_A2Z
   1878  0ae1		       a9 48		      lda	#TASKEXITCODE
   1879  0ae3		       d0 0b		      bne	iTSTVContinue
   1880  0ae5
   1881  0ae5				   iTSTV_A2Z
   1882  0ae5
   1883  0ae5		       c9 80		      cmp	#tVa
   1884  0ae7		       90 9f		      bcc	tstBranchLink
   1885  0ae9		       c9 9a		      cmp	#tVz+1
   1886  0aeb		       b0 9b		      bcs	tstBranchLink
   1887  0aed
   1888  0aed
   1889  0aed							;
   1890  0aed							; The condition is true, so convert to an index, push
   1891  0aed							; it onto the stack and continue running.
   1892  0aed							;
   1893  0aed		       29 7f		      and	#%01111111	; Mask off the high bit
   1894  0aef		       0a		      asl		; multiply by two
   1895  0af0
   1896  0af0				   iTSTVContinue
   1897  0af0		       c8		      iny
   1898  0af1		       84 51		      sty	CUROFF	; it is a valid variable
   1899  0af3		       48		      pha		; save the last variable pointer value
   1900  0af4		       a5 58		      lda	R2
   1901  0af6		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1902  0af8
   1903  0af8		       20 34 29 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1904  0afb		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1905  0afd
   1906  0afd		       68		      pla		; We have an invalid pid for getting variable value
   1907  0afe		       a2 10		      ldx	#ERR_INVALID_PID
   1908  0b00		       a9 00		      lda	#0
   1909  0b02		       4c 7d 06 	      jmp	iErr2
   1910  0b05
   1911  0b05				   iTSTVGOODPID
   1912  0b05		       20 1c 29 	      jsr	ipc_getcontext	; Get the other tasks variables
   1913  0b08		       a0 01		      ldy	#VARIABLEPOS
   1914  0b0a		       b1 56		      lda	(MQ),y
   1915  0b0c		       85 52		      sta	R0
   1916  0b0e		       c8		      iny
   1917  0b0f		       b1 56		      lda	(MQ),y
   1918  0b11		       85 53		      sta	R0+1
   1919  0b13		       4c 1e 0b 	      jmp	iTSTVAddOffset
   1920  0b16
   1921  0b16				   iTSTVLocalValue
   1922  0b16		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1923  0b18		       85 52		      sta	R0
   1924  0b1a		       a5 42		      lda	VARIABLES+1
   1925  0b1c		       85 53		      sta	R0+1
   1926  0b1e
   1927  0b1e				   iTSTVAddOffset
   1928  0b1e		       68		      pla
   1929  0b1f		       85 54		      sta	R1
   1930  0b21		       a9 00		      lda	#0
   1931  0b23		       85 55		      sta	R1+1
   1932  0b25
   1933  0b25				   iTSTVcontinue
   1934  0b25
   1935  0b25		       4c 9e 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1936  0b28
   1937  0b28							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1938  0b28							; an array of integer values or byte.
   1939  0b28				   iTSTVat
   1940  0b28		       c8		      iny
   1941  0b29		       84 51		      sty	CUROFF	;it is a valid variable
   1942  0b2b		       ad 3f 42 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1943  0b2e		       85 52		      sta	R0
   1944  0b30		       ad 40 42 	      lda	ProgramEnd+1
   1945  0b33		       85 53		      sta	R0+1
   1946  0b35		       4c 16 07 	      jmp	pushR0nextIl	;place this onto the stack
   1947  0b38
   1948  0b38							; When we get parameters passed we can access them using the # variable with[]
   1949  0b38							; example #[0] #[1] etc, we dont check yet if there is too many
   1950  0b38		       c8	   iTSTVParm  iny
   1951  0b39		       84 51		      sty	CUROFF	;it is a valid variable
   1952  0b3b
   1953  0b3b							; upon return the y register  point to the gosub Parms entry value entry
   1954  0b3b		       20 22 25 	      jsr	GosubFindParms
   1955  0b3e		       90 21		      bcc	iTSTMissingParms
   1956  0b40
   1957  0b40		       88		      dey
   1958  0b41		       88		      dey
   1959  0b42		       88		      dey		;Point to the actual index of first parameter in math stack
   1960  0b43
   1961  0b43		       a5 48		      lda	MATHSTACK
   1962  0b45		       85 52		      sta	R0
   1963  0b47		       a5 49		      lda	MATHSTACK+1
   1964  0b49		       85 53		      sta	R0+1
   1965  0b4b		       b1 4b		      lda	(GOSUBSTACK),y	; Get the correct Offset to start of parameters
   1966  0b4d		       f0 0b		      beq	iTSTVindex0	; no math if no offset
   1967  0b4f		       18		      clc
   1968  0b50		       65 52		      adc	R0	; Point to the actual address that the variables start, not just top of stack
   1969  0b52		       85 52		      sta	R0
   1970  0b54		       a9 00		      lda	#0
   1971  0b56		       65 53		      adc	R0+1
   1972  0b58		       85 53		      sta	R0+1
   1973  0b5a				   iTSTVindex0
   1974  0b5a		       a9 81		      lda	#GOSUB_RTN_VALUE
   1975  0b5c		       85 58		      sta	R2	; Set the data type as a parameter to a function
   1976  0b5e		       4c 16 07 	      jmp	pushR0nextIl
   1977  0b61
   1978  0b61
   1979  0b61				   iTSTMissingParms
   1980  0b61		       a9 00		      lda	#0
   1981  0b63		       a2 19		      ldx	#ERR_FUNCTION_EXPECTED_PARAMETERS
   1982  0b65		       4c 7d 06 	      jmp	iErr2
   1983  0b68
   1984  0b68							;
   1985  0b68							;=====================================================
   1986  0b68							; TSTL seems basically the same as TSTN, but leave the
   1987  0b68							; value in R0 instead of pushing onto stack.
   1988  0b68							; This tests for a valid line number
   1989  0b68							;
   1990  0b68		       20 5f 29    iTSTL      jsr	getILByte
   1991  0b6b		       8d 39 42 	      sta	offset
   1992  0b6e							;
   1993  0b6e		       a4 51		      ldy	CUROFF
   1994  0b70		       b1 4f		      lda	(CURPTR),y
   1995  0b72		       c8		      iny
   1996  0b73		       11 4f		      ora	(CURPTR),y
   1997  0b75		       f0 06		      beq	iTSTLNotLineNo
   1998  0b77
   1999  0b77
   2000  0b77							; In Both cases we need to point to the first usefull byte to process.
   2001  0b77		       c8		      iny
   2002  0b78		       84 51		      sty	CUROFF
   2003  0b7a		       4c b1 02 	      jmp	NextIL
   2004  0b7d				   iTSTLNotLineNo
   2005  0b7d		       c8		      iny
   2006  0b7e		       84 51		      sty	CUROFF
   2007  0b80		       4c db 0b 	      jmp	tstBranch
   2008  0b83
   2009  0b83							;
   2010  0b83							;=====================================================
   2011  0b83							; TSTN checks for a number.  This is very simplistic;
   2012  0b83							; if the character is a digit, assume it's a number.
   2013  0b83							; Convert to a number and push it onto the stack.
   2014  0b83							;
   2015  0b83		       20 5f 29    iTSTN      jsr	getILByte
   2016  0b86		       8d 39 42 	      sta	offset
   2017  0b89							;
   2018  0b89		       a9 00		      lda	#0
   2019  0b8b		       85 59		      sta	dpl
   2020  0b8d		       a4 51		      ldy	CUROFF
   2021  0b8f				   chkType
   2022  0b8f		       b1 4f		      lda	(CURPTR),y
   2023  0b91		       c9 a2		      cmp	#tByte
   2024  0b93		       f0 0e		      beq	chkByte
   2025  0b95		       c9 a4		      cmp	#tInteger
   2026  0b97		       f0 16		      beq	chkInteger
   2027  0b99		       c9 eb		      cmp	#oMinus
   2028  0b9b		       d0 3e		      bne	tstBranch
   2029  0b9d		       e6 59		      inc	dpl
   2030  0b9f		       c8		      iny
   2031  0ba0		       4c 8f 0b 	      jmp	chkType
   2032  0ba3
   2033  0ba3				   chkByte
   2034  0ba3		       a9 00		      lda	#0
   2035  0ba5		       85 53		      sta	R0+1
   2036  0ba7		       c8		      iny
   2037  0ba8		       b1 4f		      lda	(CURPTR),y
   2038  0baa		       85 52		      sta	R0
   2039  0bac		       c8		      iny
   2040  0bad		       d0 0b		      bne	iTSTN_1
   2041  0baf
   2042  0baf				   chkInteger
   2043  0baf		       c8		      iny
   2044  0bb0		       b1 4f		      lda	(CURPTR),y
   2045  0bb2		       85 52		      sta	R0
   2046  0bb4		       c8		      iny
   2047  0bb5		       b1 4f		      lda	(CURPTR),y
   2048  0bb7		       85 53		      sta	R0+1
   2049  0bb9		       c8		      iny
   2050  0bba							;
   2051  0bba							; Check if it is negative and make it so
   2052  0bba							;
   2053  0bba				   iTSTN_1
   2054  0bba		       84 51		      sty	CUROFF
   2055  0bbc
   2056  0bbc		       a5 59		      lda	dpl
   2057  0bbe		       f0 18		      beq	iTSTN_2	;positive
   2058  0bc0							;
   2059  0bc0		       a5 52		      lda	R0
   2060  0bc2		       05 53		      ora	R0+1
   2061  0bc4		       f0 12		      beq	iTSTN_2	;zero
   2062  0bc6
   2063  0bc6							; Invert all the bits, then add one.
   2064  0bc6							;
   2065  0bc6		       a5 52		      lda	R0
   2066  0bc8		       49 ff		      eor	#$ff
   2067  0bca		       85 52		      sta	R0
   2068  0bcc		       a5 53		      lda	R0+1
   2069  0bce		       49 ff		      eor	#$ff
   2070  0bd0		       85 53		      sta	R0+1
   2071  0bd2							;
   2072  0bd2		       e6 52		      inc	R0
   2073  0bd4		       d0 02		      bne	iTSTN_2
   2074  0bd6		       e6 53		      inc	R0+1
   2075  0bd8				   iTSTN_2
   2076  0bd8		       4c 16 07 	      jmp	pushR0nextIl	;save onto stack
   2077  0bdb
   2078  0bdb							;
   2079  0bdb							; Common jump point for all TSTx instructions that
   2080  0bdb							; fail to meet the requirements.  This takes the
   2081  0bdb							; offset and adds/subtracts to/from ILPC.
   2082  0bdb							;
   2083  0bdb		       ad 39 42    tstBranch  lda	offset	;get signed offset
   2084  0bde		       10 0e		      bpl	tstPositive
   2085  0be0							;
   2086  0be0							; Do negative branch.	Do sign extension.
   2087  0be0							;
   2088  0be0		       18	   tstNegative clc
   2089  0be1		       65 43		      adc	ILPC
   2090  0be3		       85 43		      sta	ILPC
   2091  0be5							;		  bcc	  tstBothDone
   2092  0be5							;		  dec	  ILPC+1
   2093  0be5							;		  jmp	  NextIL
   2094  0be5
   2095  0be5		       a5 44		      lda	ILPC+1
   2096  0be7		       69 ff		      adc	#$ff
   2097  0be9		       85 44		      sta	ILPC+1
   2098  0beb		       4c b1 02 	      jmp	NextIL	;keep going
   2099  0bee							;
   2100  0bee		       18	   tstPositive clc
   2101  0bef		       65 43		      adc	ILPC
   2102  0bf1		       85 43		      sta	ILPC
   2103  0bf3		       90 02		      bcc	tstBothDone
   2104  0bf5		       e6 44		      inc	ILPC+1
   2105  0bf7				   tstBothDone
   2106  0bf7		       4c b1 02 	      jmp	NextIL
   2107  0bfa
   2108  0bfa							;
   2109  0bfa							;====================================================
   2110  0bfa							; Test for IRQ pending, and test if a break key pressed
   2111  0bfa							; Yes I know but this handles all sorts of irq/break issues
   2112  0bfa							;
   2113  0bfa		       20 5f 29    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2114  0bfd		       8d 39 42 	      sta	offset	; Store the not true jump address offset
   2115  0c00		       ad 5a 19    irqNo      lda	IRQPending	; Check if the pending value is set
   2116  0c03		       f0 20		      beq	tstBreak	; if no irq then check for an escape key pressed
   2117  0c05		       c9 01		      cmp	#1	; only do this if set to first time
   2118  0c07		       d0 1c		      bne	tstBreak	; We are in a irq service already
   2119  0c09				   iTSTProcessIRQ
   2120  0c09		       78		      sei		; disable the interupt until ireturn resets it
   2121  0c0a		       ee 5a 19 	      inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2122  0c0d		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2123  0c0f		       20 72 2b 	      jsr	pushLN	; Push the next line to be executed
   2124  0c12		       b0 21		      bcs	ErrStkOver	; Check if there was an error
   2125  0c14		       ad 5b 19 	      lda	IRQEntry	; Get the line number to branch to
   2126  0c17		       85 4f		      sta	CURPTR	; put line number into r0
   2127  0c19		       ad 5c 19 	      lda	IRQEntry+1
   2128  0c1c		       85 50		      sta	CURPTR+1
   2129  0c1e		       a9 03		      lda	#3	; Point to first byte of program text
   2130  0c20		       85 51		      sta	CUROFF
   2131  0c22		       4c b1 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2132  0c25
   2133  0c25				   tstBreak
   2134  0c25		       20 67 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2135  0c28		       d0 b1		      bne	tstBranch	; z not set of no break found
   2136  0c2a		       ad 3b 42 	      lda	taskIOPending
   2137  0c2d		       f0 03		      beq	tstBrkComplete
   2138  0c2f		       ce 3b 42 	      dec	taskIOPending
   2139  0c32		       4c 02 06    tstBrkComplete jmp	iFIN	; Exit out of run mode
   2140  0c35
   2141  0c35		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2142  0c37		       a9 00		      lda	#0	; stop the execution
   2143  0c39		       4c 7d 06 	      jmp	iErr2
   2144  0c3c							;
   2145  0c3c
   2146  0c3c							;=====================================================
   2147  0c3c							; This places the number of free bytes on top of the
   2148  0c3c							; stack.
   2149  0c3c							;
   2150  0c3c		       20 30 23    iFREE      jsr	MemFree
   2151  0c3f		       4c 16 07 	      jmp	pushR0nextIl
   2152  0c42							;
   2153  0c42							;=====================================================
   2154  0c42							; Generate a random number from 0-FFFF and then MOD
   2155  0c42							; it with the value on top of stack.  Leaves number on
   2156  0c42							; stack
   2157  0c42							;
   2158  0c42		       20 02 2c    iRANDOM    jsr	popR1	;mod value
   2159  0c45							;
   2160  0c45							; If the value is zero, just return a one.
   2161  0c45							;
   2162  0c45		       a5 54		      lda	R1
   2163  0c47		       05 55		      ora	R1+1
   2164  0c49		       f0 4a		      beq	irandom1
   2165  0c4b							;
   2166  0c4b		       ad 34 42 	      lda	random+1
   2167  0c4e		       8d 31 42 	      sta	rtemp1
   2168  0c51		       ad 33 42 	      lda	random
   2169  0c54		       0a		      asl
   2170  0c55		       2e 31 42 	      rol	rtemp1
   2171  0c58		       0a		      asl
   2172  0c59		       2e 31 42 	      rol	rtemp1
   2173  0c5c		       18		      clc
   2174  0c5d		       6d 33 42 	      adc	random
   2175  0c60
   2176  0c60		       48		      pha
   2177  0c61
   2178  0c61		       ad 31 42 	      lda	rtemp1
   2179  0c64		       6d 34 42 	      adc	random+1
   2180  0c67		       8d 34 42 	      sta	random+1
   2181  0c6a
   2182  0c6a		       68		      pla
   2183  0c6b
   2184  0c6b		       69 11		      adc	#$11
   2185  0c6d		       8d 33 42 	      sta	random
   2186  0c70		       ad 34 42 	      lda	random+1
   2187  0c73		       69 36		      adc	#$36
   2188  0c75		       8d 34 42 	      sta	random+1
   2189  0c78
   2190  0c78		       ad 33 42 	      lda	random
   2191  0c7b		       85 52		      sta	R0
   2192  0c7d		       ad 34 42 	      lda	random+1
   2193  0c80		       29 7f		      and	#$7f	;make positive
   2194  0c82		       85 53		      sta	R0+1
   2195  0c84							;
   2196  0c84							; R0 contains the number and R1 contains the max value.
   2197  0c84							;
   2198  0c84		       20 3c 07 	      jsr	iDivNoPop
   2199  0c87		       20 6b 2c 	      jsr	RestoreSigns
   2200  0c8a		       a5 56		      lda	MQ
   2201  0c8c		       85 52		      sta	R0
   2202  0c8e		       a5 57		      lda	MQ+1
   2203  0c90		       85 53		      sta	R0+1
   2204  0c92		       4c 16 07 	      jmp	pushR0nextIl
   2205  0c95				   irandom1
   2206  0c95		       a9 00		      lda	#0
   2207  0c97		       85 53		      sta	R0+1
   2208  0c99		       a9 01		      lda	#1
   2209  0c9b		       85 52		      sta	R0
   2210  0c9d		       4c 16 07 	      jmp	pushR0nextIl
   2211  0ca0
   2212  0ca0							; The following replaced by call to division/modulo
   2213  0ca0							;iRANDOM_2	lda	R0
   2214  0ca0							;		cmp	R1
   2215  0ca0							;		bne	iRANDOM_1
   2216  0ca0							;		lda	R0+1
   2217  0ca0							;		cmp	R1+1
   2218  0ca0							;		bne	iRANDOM_1	;need to subtract
   2219  0ca0							;
   2220  0ca0							; Subtract R1 from R0
   2221  0ca0							;
   2222  0ca0							;iRANDOM_sub	sec
   2223  0ca0							;		lda	R0
   2224  0ca0							;		sbc	R1
   2225  0ca0							;		sta	R0
   2226  0ca0							;		lda	R0+1
   2227  0ca0							;		sbc	R1+1
   2228  0ca0							;		sta	R0+1
   2229  0ca0							;		jmp	iRANDOM_2
   2230  0ca0							;
   2231  0ca0							; See if R1 > R0.  If so, branch to subtract.
   2232  0ca0							;
   2233  0ca0							;iRANDOM_1	lda	R0
   2234  0ca0							;		cmp	R1
   2235  0ca0							;		lda	R0+1
   2236  0ca0							;		sbc	R1+1
   2237  0ca0							;		bvc	iRANDOM_4
   2238  0ca0							;		eor	#$80
   2239  0ca0							;iRANDOM_4	bpl	iRANDOM_sub
   2240  0ca0							;
   2241  0ca0							; All done.  Almost.  Add one, then push the result.
   2242  0ca0							;
   2243  0ca0							;irandom1	inc	R0
   2244  0ca0							;		bne	iRANDOM_3
   2245  0ca0							;		inc	R0+1
   2246  0ca0							;iRANDOM_3
   2247  0ca0							;		  jsr	pushR0	;return value
   2248  0ca0							;		jmp	NextIL
   2249  0ca0							;
   2250  0ca0							; Poke a value into a memory location
   2251  0ca0		       8c 35 42    iPOKEMEMORY sty	tempy
   2252  0ca3		       20 ea 2b 	      jsr	popR0
   2253  0ca6		       20 02 2c 	      jsr	popR1
   2254  0ca9		       a0 00		      ldy	#0
   2255  0cab		       a5 52		      lda	R0
   2256  0cad		       91 54		      sta	(R1),y
   2257  0caf		       ac 35 42 	      ldy	tempy
   2258  0cb2		       4c b1 02 	      jmp	NextIL
   2259  0cb5							;
   2260  0cb5							; Get a value from a memory location
   2261  0cb5							;
   2262  0cb5		       8c 35 42    iPEEKMEMORY sty	tempy
   2263  0cb8		       20 ea 2b 	      jsr	popR0
   2264  0cbb		       a0 00		      ldy	#0
   2265  0cbd		       b1 52		      lda	(R0),y
   2266  0cbf		       ac 35 42 	      ldy	tempy
   2267  0cc2		       85 52		      sta	R0
   2268  0cc4		       a9 00		      lda	#0
   2269  0cc6		       85 53		      sta	R0+1
   2270  0cc8		       4c 16 07 	      jmp	pushR0nextIl
   2271  0ccb							;
   2272  0ccb							; Call to address return what ever is in a to the stack
   2273  0ccb							; func2 will load a value into a before the call
   2274  0ccb		       20 02 2c    iCallFunc  jsr	popR1
   2275  0cce		       a5 54		      lda	R1
   2276  0cd0		       20 dc 0c 	      jsr	iCallRtn
   2277  0cd3		       85 52		      sta	R0
   2278  0cd5		       a9 00		      lda	#0
   2279  0cd7		       85 53		      sta	R0+1
   2280  0cd9		       20 16 07 	      jsr	pushR0nextIl
   2281  0cdc				   iCallRtn
   2282  0cdc		       20 ea 2b 	      jsr	popR0
   2283  0cdf		       6c 52 00 	      jmp	(R0)
   2284  0ce2
   2285  0ce2
   2286  0ce2							;===========================================jlit======
   2287  0ce2							;Get a character from the terminal convert to value
   2288  0ce2							;leave the number on top of the stack
   2289  0ce2							;
   2290  0ce2				   iGETCHAR
   2291  0ce2		       20 ea 19 	      jsr	VGETCH
   2292  0ce5					      if	CTMON65
   2293  0ce5		       48		      pha
   2294  0ce6		       20 e7 19 	      jsr	VOUTCH	;echo echo echo
   2295  0ce9		       68		      pla
   2296  0cea					      endif
   2297  0cea		       85 52		      sta	R0
   2298  0cec		       a9 00		      lda	#0
   2299  0cee		       85 53		      sta	R0+1
   2300  0cf0		       20 58 2b 	      jsr	pushR0
   2301  0cf3							;
   2302  0cf3		       4c b1 02 	      jmp	NextIL
   2303  0cf6							;===========================================jusilostintim======
   2304  0cf6							;Put a character to the terminal convert to
   2305  0cf6							;
   2306  0cf6		       20 ea 2b    iPUTCHAR   jsr	popR0
   2307  0cf9		       a5 52		      lda	R0
   2308  0cfb		       20 e7 19 	      jsr	VOUTCH
   2309  0cfe		       4c b1 02 	      jmp	NextIL
   2310  0d01							;=====================================================
   2311  0d01							; Put the number on the stack out as hex, suppress leading 0
   2312  0d01				   iHexOut
   2313  0d01		       20 ea 2b 	      jsr	popR0
   2314  0d04		       a5 53		      lda	R0+1
   2315  0d06		       f0 03		      beq	iHexSecondByte
   2316  0d08		       20 fa 20 	      jsr	OUTHEX
   2317  0d0b				   iHexSecondByte
   2318  0d0b		       a5 52		      lda	R0
   2319  0d0d		       20 fa 20 	      jsr	OUTHEX
   2320  0d10		       4c b1 02 	      jmp	NextIL
   2321  0d13							;
   2322  0d13							;=====================================================
   2323  0d13							; Replace TOS with its absolute value.
   2324  0d13							;
   2325  0d13		       20 ea 2b    iABS       jsr	popR0
   2326  0d16		       a5 53		      lda	R0+1
   2327  0d18		       10 10		      bpl	iABS_1	;already positive
   2328  0d1a		       49 ff		      eor	#$ff
   2329  0d1c		       85 53		      sta	R0+1
   2330  0d1e		       a5 52		      lda	R0
   2331  0d20		       49 ff		      eor	#$ff
   2332  0d22		       85 52		      sta	R0
   2333  0d24		       e6 52		      inc	R0
   2334  0d26		       d0 02		      bne	iABS_1
   2335  0d28		       e6 53		      inc	R0+1
   2336  0d2a		       4c 16 07    iABS_1     jmp	pushR0nextIl
   2337  0d2d
   2338  0d2d							;
   2339  0d2d							;================================================================
   2340  0d2d							; The set of logical operators
   2341  0d2d				   iLogAnd
   2342  0d2d		       20 ea 2b 	      jsr	popR0
   2343  0d30		       20 02 2c 	      jsr	popR1
   2344  0d33		       a5 52		      lda	R0
   2345  0d35		       25 54		      and	R1
   2346  0d37		       85 52		      sta	R0
   2347  0d39		       a5 53		      lda	R0+1
   2348  0d3b		       25 55		      and	R1+1
   2349  0d3d		       85 53		      sta	R0+1
   2350  0d3f		       4c 16 07 	      jmp	pushR0nextIl
   2351  0d42				   iLogOr
   2352  0d42		       20 ea 2b 	      jsr	popR0
   2353  0d45		       20 02 2c 	      jsr	popR1
   2354  0d48		       a5 52		      lda	R0
   2355  0d4a		       05 54		      ora	R1
   2356  0d4c		       85 52		      sta	R0
   2357  0d4e		       a5 53		      lda	R0+1
   2358  0d50		       05 55		      ora	R1+1
   2359  0d52		       85 53		      sta	R0+1
   2360  0d54		       4c 16 07 	      jmp	pushR0nextIl
   2361  0d57				   iLogXor
   2362  0d57		       20 ea 2b 	      jsr	popR0
   2363  0d5a		       20 02 2c 	      jsr	popR1
   2364  0d5d		       a5 52		      lda	R0
   2365  0d5f		       45 54		      eor	R1
   2366  0d61		       85 52		      sta	R0
   2367  0d63		       a5 53		      lda	R0+1
   2368  0d65		       45 55		      eor	R1+1
   2369  0d67		       85 53		      sta	R0+1
   2370  0d69		       4c 16 07 	      jmp	pushR0nextIl
   2371  0d6c				   iLogNot
   2372  0d6c		       20 ea 2b 	      jsr	popR0
   2373  0d6f		       a5 52		      lda	R0
   2374  0d71		       49 ff		      eor	#$FF
   2375  0d73		       85 52		      sta	R0
   2376  0d75		       a5 53		      lda	R0+1
   2377  0d77		       49 ff		      eor	#$FF
   2378  0d79		       85 53		      sta	R0+1
   2379  0d7b		       4c 16 07 	      jmp	pushR0nextIl
   2380  0d7e
   2381  0d7e				   iTruth
   2382  0d7e		       a9 ff		      lda	#$FF
   2383  0d80		       85 52		      sta	R0
   2384  0d82		       85 53		      sta	R0+1
   2385  0d84		       4c 16 07 	      jmp	pushR0nextIl
   2386  0d87				   iFalse
   2387  0d87		       a9 00		      lda	#$00
   2388  0d89		       85 52		      sta	R0
   2389  0d8b		       85 53		      sta	R0+1
   2390  0d8d		       4c 16 07 	      jmp	pushR0nextIl
   2391  0d90							;===============================================================
   2392  0d90							;Shift instruction right 1, left 0
   2393  0d90							;
   2394  0d90		       8a	   iShift     txa
   2395  0d91		       48		      pha
   2396  0d92		       20 ea 2b 	      jsr	popR0	; number of places to shift 0 to 16 really
   2397  0d95		       20 02 2c 	      jsr	popR1	; value to shift
   2398  0d98		       a6 52		      ldx	R0	; get number of times to shift
   2399  0d9a		       20 5f 29 	      jsr	getILByte	; get direction to shift
   2400  0d9d		       c9 01		      cmp	#1	; Should we be doing left
   2401  0d9f		       f0 0a		      beq	iShiftRight
   2402  0da1							;
   2403  0da1							; Shift r1 left n bits
   2404  0da1				   iShiftLeft
   2405  0da1		       18	   iShiftLloop clc
   2406  0da2		       26 54		      rol	R1
   2407  0da4		       26 55		      rol	R1+1
   2408  0da6		       ca		      dex
   2409  0da7		       d0 f8		      bne	iShiftLloop
   2410  0da9		       f0 07		      beq	iShiftExit
   2411  0dab							;
   2412  0dab							; Shift R1 right n bits
   2413  0dab							;
   2414  0dab				   iShiftRight
   2415  0dab		       46 55	   iShiftRloop lsr	R1+1
   2416  0dad		       46 54		      lsr	R1
   2417  0daf		       ca		      dex
   2418  0db0		       d0 f9		      bne	iShiftRloop
   2419  0db2				   iShiftExit
   2420  0db2		       68		      pla
   2421  0db3		       aa		      tax
   2422  0db4		       20 d0 2b 	      jsr	pushR1
   2423  0db7		       4c b1 02 	      jmp	NextIL
   2424  0dba
   2425  0dba							;================================================================
   2426  0dba							;Set the IRQ service rtn line number
   2427  0dba							;
   2428  0dba		       78	   iSetIrq    sei		; disable the interupts
   2429  0dbb		       a9 00		      lda	#0	; Zero the Status flag
   2430  0dbd		       8d 59 19 	      sta	IRQStatus
   2431  0dc0		       20 ea 2b 	      jsr	popR0	; get the line number
   2432  0dc3		       a5 52		      lda	R0
   2433  0dc5		       05 53		      ora	R0+1
   2434  0dc7		       f0 22		      beq	iSetExt	; if it is zero disable all
   2435  0dc9		       a9 01		      lda	#GOSUB_RTN	; default push type
   2436  0dcb		       20 72 2b 	      jsr	pushLN	; Save the current line pointer
   2437  0dce		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2438  0dd0		       4c 35 0c 	      jmp	ErrStkOver	; Check if there was an error
   2439  0dd3				   iSetIrqOk
   2440  0dd3		       20 a4 29 	      jsr	findLine	; Find the IRQ func Line Pointer
   2441  0dd6		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2442  0dd8		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2443  0dda		       8d 5c 19 	      sta	IRQEntry+1
   2444  0ddd		       a5 4f		      lda	CURPTR
   2445  0ddf		       8d 5b 19 	      sta	IRQEntry
   2446  0de2		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2447  0de4		       8d 59 19 	      sta	IRQStatus
   2448  0de7		       20 9b 2b 	      jsr	popLN	; Restore the old line number
   2449  0dea		       58		      cli		; Enable the interupts
   2450  0deb		       4c b1 02    iSetExt    jmp	NextIL
   2451  0dee
   2452  0dee		       20 9b 2b    iSetIrqErr jsr	popLN
   2453  0df1		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2454  0df3		       a9 00		      lda	#0
   2455  0df5		       4c 7d 06 	      jmp	iErr2
   2456  0df8							;
   2457  0df8		       20 ea 2b    iTRACEPROG jsr	popR0
   2458  0dfb		       a5 52		      lda	R0
   2459  0dfd		       85 40		      sta	ILTrace
   2460  0dff		       4c b1 02 	      jmp	NextIL
   2461  0e02
   2462  0e02							;=====================================================
   2463  0e02							; Define start of non page zero data
   2464 U4247 ????				      seg.u	TBData
   2465 U3575					      org	PROGEND
   2466 U3575							;=================================================================
   2467 U3575							;
   2468 U3575					      if	IL_DEBUG_TEXT
------- FILE ILKeyText.inc LEVEL 2 PASS 6
      0 U3575					      include	"ILKeyText.inc"
      1  0e02					      seg	Code
      2  0e02					      if	IL_DEBUG_TEXT
      3  0e02				   ILTEXTTABLE
      0  0e02					      db	0,23,"iXINIT		   ",0
      1  0e02		       00 17 69 58*	      .byte.b	0,23,"iXINIT		   ",0
      0  0e19					      db	1,23,"iDONE		   ",0
      1  0e19		       01 17 69 44*	      .byte.b	1,23,"iDONE		   ",0
      0  0e30					      db	2,23,"iPRS		   ",0
      1  0e30		       02 17 69 50*	      .byte.b	2,23,"iPRS		   ",0
      0  0e47					      db	3,23,"iPRN		   ",0
      1  0e47		       03 17 69 50*	      .byte.b	3,23,"iPRN		   ",0
      0  0e5e					      db	4,23,"iSPC		   ",0
      1  0e5e		       04 17 69 53*	      .byte.b	4,23,"iSPC		   ",0
      0  0e75					      db	5,23,"iNLINE		   ",0
      1  0e75		       05 17 69 4e*	      .byte.b	5,23,"iNLINE		   ",0
      0  0e8c					      db	6,23,"iNXT		   ",0
      1  0e8c		       06 17 69 4e*	      .byte.b	6,23,"iNXT		   ",0
      0  0ea3					      db	7,23,"iXFER		   ",0
      1  0ea3		       07 17 69 58*	      .byte.b	7,23,"iXFER		   ",0
      0  0eba					      db	8,23,"iSAV		   ",0
      1  0eba		       08 17 69 53*	      .byte.b	8,23,"iSAV		   ",0
      0  0ed1					      db	9,23,"iRSTR		   ",0
      1  0ed1		       09 17 69 52*	      .byte.b	9,23,"iRSTR		   ",0
      0  0ee8					      db	10,23,"iCMPR		    ",0
      1  0ee8		       0a 17 69 43*	      .byte.b	10,23,"iCMPR		    ",0
      0  0eff					      db	11,23,"iINNUM		    ",0
      1  0eff		       0b 17 69 49*	      .byte.b	11,23,"iINNUM		    ",0
      0  0f16					      db	12,23,"iFIN		    ",0
      1  0f16		       0c 17 69 46*	      .byte.b	12,23,"iFIN		    ",0
      0  0f2d					      db	13,23,"iERR		    ",0
      1  0f2d		       0d 17 69 45*	      .byte.b	13,23,"iERR		    ",0
      0  0f44					      db	14,23,"iADD		    ",0
      1  0f44		       0e 17 69 41*	      .byte.b	14,23,"iADD		    ",0
      0  0f5b					      db	15,23,"iSUB		    ",0
      1  0f5b		       0f 17 69 53*	      .byte.b	15,23,"iSUB		    ",0
      0  0f72					      db	16,23,"iNEG		    ",0
      1  0f72		       10 17 69 4e*	      .byte.b	16,23,"iNEG		    ",0
      0  0f89					      db	17,23,"iMUL		    ",0
      1  0f89		       11 17 69 4d*	      .byte.b	17,23,"iMUL		    ",0
      0  0fa0					      db	18,23,"iDIV		    ",0
      1  0fa0		       12 17 69 44*	      .byte.b	18,23,"iDIV		    ",0
      0  0fb7					      db	19,23,"iSTORE		    ",0
      1  0fb7		       13 17 69 53*	      .byte.b	19,23,"iSTORE		    ",0
      0  0fce					      db	20,23,"iIND		    ",0
      1  0fce		       14 17 69 49*	      .byte.b	20,23,"iIND		    ",0
      0  0fe5					      db	21,23,"iLST		    ",0
      1  0fe5		       15 17 69 4c*	      .byte.b	21,23,"iLST		    ",0
      0  0ffc					      db	22,23,"iINIT		    ",0
      1  0ffc		       16 17 69 49*	      .byte.b	22,23,"iINIT		    ",0
      0  1013					      db	23,23,"iGETLINE	    ",0
      1  1013		       17 17 69 47*	      .byte.b	23,23,"iGETLINE	    ",0
      0  102a					      db	24,23,"iINSRT		    ",0
      1  102a		       18 17 69 49*	      .byte.b	24,23,"iINSRT		    ",0
      0  1041					      db	25,23,"iRTN		    ",0
      1  1041		       19 17 69 52*	      .byte.b	25,23,"iRTN		    ",0
      0  1058					      db	26,23,"MONITOR 	    ",0
      1  1058		       1a 17 4d 4f*	      .byte.b	26,23,"MONITOR 	    ",0
      0  106f					      db	27,23,"iLIT		    ",0
      1  106f		       1b 17 69 4c*	      .byte.b	27,23,"iLIT		    ",0
      0  1086					      db	28,23,"iCALL		    ",0
      1  1086		       1c 17 69 43*	      .byte.b	28,23,"iCALL		    ",0
      0  109d					      db	29,23,"iJMP		    ",0
      1  109d		       1d 17 69 4a*	      .byte.b	29,23,"iJMP		    ",0
      0  10b4					      db	30,23,"iVINIT		    ",0
      1  10b4		       1e 17 69 56*	      .byte.b	30,23,"iVINIT		    ",0
      0  10cb					      db	31,23,"iERRGOTO	    ",0
      1  10cb		       1f 17 69 45*	      .byte.b	31,23,"iERRGOTO	    ",0
      0  10e2					      db	32,23,"iTST		    ",0
      1  10e2		       20 17 69 54*	      .byte.b	32,23,"iTST		    ",0
      0  10f9					      db	33,23,"iTSTV		    ",0
      1  10f9		       21 17 69 54*	      .byte.b	33,23,"iTSTV		    ",0
      0  1110					      db	34,23,"iTSTL		    ",0
      1  1110		       22 17 69 54*	      .byte.b	34,23,"iTSTL		    ",0
      0  1127					      db	35,23,"iTSTN		    ",0
      1  1127		       23 17 69 54*	      .byte.b	35,23,"iTSTN		    ",0
      0  113e					      db	36,23,"iFREE		    ",0
      1  113e		       24 17 69 46*	      .byte.b	36,23,"iFREE		    ",0
      0  1155					      db	37,23,"iRANDOM 	    ",0
      1  1155		       25 17 69 52*	      .byte.b	37,23,"iRANDOM 	    ",0
      0  116c					      db	38,23,"iABS		    ",0
      1  116c		       26 17 69 41*	      .byte.b	38,23,"iABS		    ",0
      0  1183					      db	39,23,"iOPENREAD	    ",0
      1  1183		       27 17 69 4f*	      .byte.b	39,23,"iOPENREAD	    ",0
      0  119a					      db	40,23,"iOPENWRITE	    ",0
      1  119a		       28 17 69 4f*	      .byte.b	40,23,"iOPENWRITE	    ",0
      0  11b1					      db	41,23,"iDCLOSE 	    ",0
      1  11b1		       29 17 69 44*	      .byte.b	41,23,"iDCLOSE 	    ",0
      0  11c8					      db	42,23,"iDGETLINE	    ",0
      1  11c8		       2a 17 69 44*	      .byte.b	42,23,"iDGETLINE	    ",0
      0  11df					      db	43,23,"iDLIST		    ",0
      1  11df		       2b 17 69 44*	      .byte.b	43,23,"iDLIST		    ",0
      0  11f6					      db	44,23,"iDDIR		    ",0
      1  11f6		       2c 17 69 44*	      .byte.b	44,23,"iDDIR		    ",0
      0  120d					      db	45,23,"iRMFILE 	    ",0
      1  120d		       2d 17 69 52*	      .byte.b	45,23,"iRMFILE 	    ",0
      0  1224					      db	39,23,"NextIL		    ",0
      1  1224		       27 17 4e 65*	      .byte.b	39,23,"NextIL		    ",0
      0  123b					      db	40,23,"NextIL		    ",0
      1  123b		       28 17 4e 65*	      .byte.b	40,23,"NextIL		    ",0
      0  1252					      db	41,23,"NextIL		    ",0
      1  1252		       29 17 4e 65*	      .byte.b	41,23,"NextIL		    ",0
      0  1269					      db	42,23,"NextIL		    ",0
      1  1269		       2a 17 4e 65*	      .byte.b	42,23,"NextIL		    ",0
      0  1280					      db	43,23,"NextIL		    ",0
      1  1280		       2b 17 4e 65*	      .byte.b	43,23,"NextIL		    ",0
      0  1297					      db	44,23,"NextIL		    ",0
      1  1297		       2c 17 4e 65*	      .byte.b	44,23,"NextIL		    ",0
      0  12ae					      db	45,23,"NextIL		    ",0
      1  12ae		       2d 17 4e 65*	      .byte.b	45,23,"NextIL		    ",0
      0  12c5					      db	46,23,"iCLEARSCREEN	    ",0
      1  12c5		       2e 17 69 43*	      .byte.b	46,23,"iCLEARSCREEN	    ",0
      0  12dc					      db	47,23,"iPOKEMEMORY	    ",0
      1  12dc		       2f 17 69 50*	      .byte.b	47,23,"iPOKEMEMORY	    ",0
      0  12f3					      db	48,23,"iPEEKMEMORY	    ",0
      1  12f3		       30 17 69 50*	      .byte.b	48,23,"iPEEKMEMORY	    ",0
      0  130a					      db	49,23,"iTSTLET 	    ",0
      1  130a		       31 17 69 54*	      .byte.b	49,23,"iTSTLET 	    ",0
      0  1321					      db	50,23,"iTSTDONE	    ",0
      1  1321		       32 17 69 54*	      .byte.b	50,23,"iTSTDONE	    ",0
      0  1338					      db	51,23,"iGETCHAR	    ",0
      1  1338		       33 17 69 47*	      .byte.b	51,23,"iGETCHAR	    ",0
      0  134f					      db	52,23,"iPUTCHAR	    ",0
      1  134f		       34 17 69 50*	      .byte.b	52,23,"iPUTCHAR	    ",0
      0  1366					      db	53,23,"iCallFunc	    ",0
      1  1366		       35 17 69 43*	      .byte.b	53,23,"iCallFunc	    ",0
      0  137d					      db	54,23,"iBranch 	    ",0
      1  137d		       36 17 69 42*	      .byte.b	54,23,"iBranch 	    ",0
      0  1394					      db	55,23,"iTSTStr 	    ",0
      1  1394		       37 17 69 54*	      .byte.b	55,23,"iTSTStr 	    ",0
      0  13ab					      db	56,23,"iSetIrq 	    ",0
      1  13ab		       38 17 69 53*	      .byte.b	56,23,"iSetIrq 	    ",0
      0  13c2					      db	57,23,"iTstIrq 	    ",0
      1  13c2		       39 17 69 54*	      .byte.b	57,23,"iTstIrq 	    ",0
      0  13d9					      db	58,23,"iRET		    ",0
      1  13d9		       3a 17 69 52*	      .byte.b	58,23,"iRET		    ",0
      0  13f0					      db	59,23,"iINSTR		    ",0
      1  13f0		       3b 17 69 49*	      .byte.b	59,23,"iINSTR		    ",0
      0  1407					      db	60,23,"iMOD		    ",0
      1  1407		       3c 17 69 4d*	      .byte.b	60,23,"iMOD		    ",0
      0  141e					      db	61,23,"iTaskSet	    ",0
      1  141e		       3d 17 69 54*	      .byte.b	61,23,"iTaskSet	    ",0
      0  1435					      db	62,23,"iETask		    ",0
      1  1435		       3e 17 69 45*	      .byte.b	62,23,"iETask		    ",0
      0  144c					      db	63,23,"iNTask		    ",0
      1  144c		       3f 17 69 4e*	      .byte.b	63,23,"iNTask		    ",0
      0  1463					      db	64,23,"iArray		    ",0
      1  1463		       40 17 69 41*	      .byte.b	64,23,"iArray		    ",0
      0  147a					      db	65,23,"iTaskKill	    ",0
      1  147a		       41 17 69 54*	      .byte.b	65,23,"iTaskKill	    ",0
      0  1491					      db	66,23,"iTaskStat	    ",0
      1  1491		       42 17 69 54*	      .byte.b	66,23,"iTaskStat	    ",0
      0  14a8					      db	67,23,"iHexOut 	    ",0
      1  14a8		       43 17 69 48*	      .byte.b	67,23,"iHexOut 	    ",0
      0  14bf					      db	68,23,"iReadComplete	    ",0
      1  14bf		       44 17 69 52*	      .byte.b	68,23,"iReadComplete	    ",0
      0  14d6					      db	69,23,"iReadStart	    ",0
      1  14d6		       45 17 69 52*	      .byte.b	69,23,"iReadStart	    ",0
      0  14ed					      db	70,23,"iStartIO	    ",0
      1  14ed		       46 17 69 53*	      .byte.b	70,23,"iStartIO	    ",0
      0  1504					      db	71,23,"iEndIO		    ",0
      1  1504		       47 17 69 45*	      .byte.b	71,23,"iEndIO		    ",0
      0  151b					      db	72,23,"iLogNot 	    ",0
      1  151b		       48 17 69 4c*	      .byte.b	72,23,"iLogNot 	    ",0
      0  1532					      db	73,23,"iLogOr		    ",0
      1  1532		       49 17 69 4c*	      .byte.b	73,23,"iLogOr		    ",0
      0  1549					      db	74,23,"iLogAnd 	    ",0
      1  1549		       4a 17 69 4c*	      .byte.b	74,23,"iLogAnd 	    ",0
      0  1560					      db	75,23,"iLogXor 	    ",0
      1  1560		       4b 17 69 4c*	      .byte.b	75,23,"iLogXor 	    ",0
      0  1577					      db	76,23,"iWTASK		    ",0
      1  1577		       4c 17 69 57*	      .byte.b	76,23,"iWTASK		    ",0
      0  158e					      db	77,23,"iTASKPID	    ",0
      1  158e		       4d 17 69 54*	      .byte.b	77,23,"iTASKPID	    ",0
      0  15a5					      db	78,23,"iTRACEPROG	    ",0
      1  15a5		       4e 17 69 54*	      .byte.b	78,23,"iTRACEPROG	    ",0
      0  15bc					      db	79,23,"idbgBasic	    ",0
      1  15bc		       4f 17 69 64*	      .byte.b	79,23,"idbgBasic	    ",0
      0  15d3					      db	80,23,"iIPCS		    ",0
      1  15d3		       50 17 69 49*	      .byte.b	80,23,"iIPCS		    ",0
      0  15ea					      db	81,23,"iIPCR		    ",0
      1  15ea		       51 17 69 49*	      .byte.b	81,23,"iIPCR		    ",0
      0  1601					      db	82,23,"iIPCC		    ",0
      1  1601		       52 17 69 49*	      .byte.b	82,23,"iIPCC		    ",0
      0  1618					      db	83,23,"iIPCIO		    ",0
      1  1618		       53 17 69 49*	      .byte.b	83,23,"iIPCIO		    ",0
      0  162f					      db	84,23,"iPushMathStack	    ",0
      1  162f		       54 17 69 50*	      .byte.b	84,23,"iPushMathStack	    ",0
      0  1646					      db	85,23,"iPopMathStack	    ",0
      1  1646		       55 17 69 50*	      .byte.b	85,23,"iPopMathStack	    ",0
      0  165d					      db	86,23,"iSaveMathStack	    ",0
      1  165d		       56 17 69 53*	      .byte.b	86,23,"iSaveMathStack	    ",0
      0  1674					      db	87,23,"iRestoreMathStack   ",0
      1  1674		       57 17 69 52*	      .byte.b	87,23,"iRestoreMathStack   ",0
      0  168b					      db	88,23,"iIncParmCount	    ",0
      1  168b		       58 17 69 49*	      .byte.b	88,23,"iIncParmCount	    ",0
      0  16a2					      db	89,23,"iTaskGetMathStack   ",0
      1  16a2		       59 17 69 54*	      .byte.b	89,23,"iTaskGetMathStack   ",0
      0  16b9					      db	90,23,"iTaskEnable	    ",0
      1  16b9		       5a 17 69 54*	      .byte.b	90,23,"iTaskEnable	    ",0
      0  16d0					      db	91,23,"iTaskSuspend	    ",0
      1  16d0		       5b 17 69 54*	      .byte.b	91,23,"iTaskSuspend	    ",0
      0  16e7					      db	92,23,"iTaskPutMathPtr     ",0
      1  16e7		       5c 17 69 54*	      .byte.b	92,23,"iTaskPutMathPtr     ",0
      0  16fe					      db	93,23,"iTSTVT		    ",0
      1  16fe		       5d 17 69 54*	      .byte.b	93,23,"iTSTVT		    ",0
      0  1715					      db	94,23,"iSetR2		    ",0
      1  1715		       5e 17 69 53*	      .byte.b	94,23,"iSetR2		    ",0
      0  172c					      db	95,23,"iStk2Tmp	    ",0
      1  172c		       5f 17 69 53*	      .byte.b	95,23,"iStk2Tmp	    ",0
      0  1743					      db	96,23,"iTmp2Stk	    ",0
      1  1743		       60 17 69 54*	      .byte.b	96,23,"iTmp2Stk	    ",0
      0  175a					      db	97,23,"iTSTBYTE	    ",0
      1  175a		       61 17 69 54*	      .byte.b	97,23,"iTSTBYTE	    ",0
      0  1771					      db	98,23,"iINCVAR 	    ",0
      1  1771		       62 17 69 49*	      .byte.b	98,23,"iINCVAR 	    ",0
      0  1788					      db	99,23,"iDECVAR 	    ",0
      1  1788		       63 17 69 44*	      .byte.b	99,23,"iDECVAR 	    ",0
      0  179f					      db	100,23,"iSLICE 	     ",0
      1  179f		       64 17 69 53*	      .byte.b	100,23,"iSLICE 	     ",0
      0  17b6					      db	101,23,"iTSTB		     ",0
      1  17b6		       65 17 69 54*	      .byte.b	101,23,"iTSTB		     ",0
      0  17cd					      db	102,23,"iTSTW		     ",0
      1  17cd		       66 17 69 54*	      .byte.b	102,23,"iTSTW		     ",0
      0  17e4					      db	103,23,"iOnGoto	     ",0
      1  17e4		       67 17 69 4f*	      .byte.b	103,23,"iOnGoto	     ",0
      0  17fb					      db	104,23,"iTSTRELOP	     ",0
      1  17fb		       68 17 69 54*	      .byte.b	104,23,"iTSTRELOP	     ",0
      0  1812					      db	105,23,"iRepeatLine	     ",0
      1  1812		       69 17 69 52*	      .byte.b	105,23,"iRepeatLine	     ",0
      0  1829					      db	106,23,"iTSTBRANCH	     ",0
      1  1829		       6a 17 69 54*	      .byte.b	106,23,"iTSTBRANCH	     ",0
      0  1840					      db	107,23,"iFastXfer	     ",0
      1  1840		       6b 17 69 46*	      .byte.b	107,23,"iFastXfer	     ",0
      0  1857					      db	108,23,"iSetTerminal	     ",0
      1  1857		       6c 17 69 53*	      .byte.b	108,23,"iSetTerminal	     ",0
      0  186e					      db	109,23,"iINDB		     ",0
      1  186e		       6d 17 69 49*	      .byte.b	109,23,"iINDB		     ",0
      0  1885					      db	110,23,"iSetBlock	     ",0
      1  1885		       6e 17 69 53*	      .byte.b	110,23,"iSetBlock	     ",0
      0  189c					      db	111,23,"iCopyBlock	     ",0
      1  189c		       6f 17 69 43*	      .byte.b	111,23,"iCopyBlock	     ",0
      0  18b3					      db	112,23,"iCmpBlock	     ",0
      1  18b3		       70 17 69 43*	      .byte.b	112,23,"iCmpBlock	     ",0
      0  18ca					      db	113,23,"iShift 	     ",0
      1  18ca		       71 17 69 53*	      .byte.b	113,23,"iShift 	     ",0
      0  18e1					      db	$FF,23,"0		     ",0
      1  18e1		       ff 17 30 20*	      .byte.b	$FF,23,"0		     ",0
    126  18f8
    127  18f8							; Search for the il instruction and print the correct text for it
    128  18f8							; on entry a contains the ip instruction to print
    129  18f8
    130 U3575					      seg.u	TBData
    131 U3575		       00 00	   R0TempIL   ds	2
    132 U3577		       00	   ILSTA      ds	1
    133 U3578
    134  18f8					      Seg	Code
    135  18f8
    136  18f8		       8d 77 35    PrintILText sta	ILSTA
    137  18fb		       98		      tya
    138  18fc		       48		      pha
    139  18fd		       8a		      txa
    140  18fe		       48		      pha
    141  18ff		       a5 52		      lda	R0
    142  1901		       8d 75 35 	      sta	R0TempIL
    143  1904		       a5 53		      lda	R0+1
    144  1906		       8d 75 35 	      sta	R0TempIL
    145  1909		       a9 02		      lda	#ILTEXTTABLE&$FF
    146  190b		       85 52		      sta	R0
    147  190d		       a9 0e		      LDA	#ILTEXTTABLE>>8
    148  190f		       85 53		      sta	R0+1
    149  1911							;Loop Here for each entry
    150  1911		       a0 00	   PrintILLoop ldy	#0
    151  1913		       b1 52		      lda	(R0),y
    152  1915		       c9 ff		      cmp	#$FF
    153  1917		       f0 2a		      beq	PrintILNotFound
    154  1919		       cd 77 35 	      cmp	ILSTA
    155  191c		       f0 11		      beq	PrintILFound
    156  191e		       c8		      iny
    157  191f		       b1 52		      lda	(R0),y
    158  1921		       18		      clc
    159  1922		       65 52		      adc	R0
    160  1924		       85 52		      sta	R0
    161  1926		       a9 00		      lda	#0
    162  1928		       65 53		      adc	R0+1
    163  192a		       85 53		      sta	R0+1
    164  192c		       4c 11 19 	      jmp	PrintILLoop
    165  192f							; The text was discovered
    166  192f		       c8	   PrintILFound iny		; point to length of instruction
    167  1930		       c8		      iny		; Point to start of text
    168  1931		       98		      tya
    169  1932		       18		      clc
    170  1933		       65 52		      adc	R0
    171  1935		       a8		      tay		; Low order byte of address
    172  1936		       a9 00		      lda	#0
    173  1938		       65 53		      adc	R0+1
    174  193a		       aa		      tax		; High order byte of address
    175  193b		       a9 00		      lda	#0	; Termination byte of string
    176  193d		       20 55 21 	      jsr	PrtStr	; print the string
    177  1940		       4c 49 19 	      jmp	PrintILDone
    178  1943
    179  1943		       ad 77 35    PrintILNotFound lda	ILSTA
    180  1946		       20 fa 20 	      jsr	HexToOut
    181  1949
    182  1949		       ad 75 35    PrintILDone lda	R0TempIL
    183  194c		       85 52		      sta	R0
    184  194e		       ad 76 35 	      lda	R0TempIL+1
    185  1951		       85 52		      sta	R0
    186  1953		       68		      pla
    187  1954		       aa		      tax
    188  1955		       68		      pla
    189  1956		       a8		      tay
    190  1957		       60		      rts
    191  1958					      endif
------- FILE mytb.asm
   2470  1958					      endif
------- FILE io.asm LEVEL 2 PASS 6
      0  1958					      include	"io.asm"
      1  1958							; This is the io blocks and function for reading and writing
      2  1958							; to devices attached to this computer.
      3  1958							; This supports devices mapped at e000 thru efff in slot sizes of 16 byte
      4  1958							;
      5  1958							;=====================================================================
      6  1958							; Device configuration equates
      7  1958		       00 00	   ConsoleID  equ	0
      8  1958		       00 08	   SerialID   equ	[1<<3]
      9  1958		       00 10	   ClockID    equ	[2<<3]
     10  1958		       00 18	   TimerID    equ	[3<<3]
     11  1958		       00 20	   DiskID     equ	[4<<3]
     12  1958
     13  1958		       00 0a	   IO_MAX_DEVICES equ	10
     14  1958		       00 06	   IO_VECT_LEN equ	6
     15  1958
     16  1958		       00 01	   IO_DEVICE_CLOSED equ	1	; The device is not open
     17  1958		       00 02	   IO_DEVICE_INVALID equ	2	; The Device number provided is invalid
     18  1958
     19  1958							;========================================================================================
     20  1958							; Uninitialized data segment
     21 U3578					      seg.u	TBData
     22 U3578
     23 U3578		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
     24 U357a		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
     25 U357c		       00 00	   BStatVec   ds	2	; This is used by inteface to read write status/config information
      0 U357e				   BActiveDevice db	1	; the index of the current device block
      1 U357e		       01		      .byte.b	1
      0 U357f				   BActiveDriver db	1	; Index of the device drive block
      1 U357f		       01		      .byte.b	1
     28 U3580
     29 U3580							;============================================================================================
     30  1958					      Seg	Code
     31  1958							; IRQ BASIC Code Service RTN Support
      0  1958				   SaveIrqReg db	0	; Store current setting
      1  1958		       00		      .byte.b	0
      0  1959				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1  1959		       00		      .byte.b	0
      0  195a				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1  195a		       00		      .byte.b	0
      0  195b				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1  195b		       00 00		      .byte.b	0,0
     36  195d
     37  195d							;============================================================================================
     38  195d							; Define the device interface blocks
     39  195d				   DeviceDriverBlocks
     40  195d				   ConsoleDevice		; Block 0
      0  195d					      dw	ConsoleID	; device idenifier Console
      1  195d		       00 00		      .word.w	ConsoleID
      0  195f					      dw	cin	; read function vector
      1  195f		       09 f0		      .word.w	cin
      0  1961					      dw	cout	; write function vector
      1  1961		       0c f0		      .word.w	cout
      0  1963					      dw	cstatus	; Get current Status info/Write config
      1  1963		       0f f0		      .word.w	cstatus
     45  1965
     46  1965				   SerialDevice 		; Block 1
      0  1965					      dw	SerialID	; device idenifier Serial
      1  1965		       08 00		      .word.w	SerialID
      0  1967					      dw	SerialIn	; read function vector
      1  1967		       43 1a		      .word.w	SerialIn
      0  1969					      dw	SerialOut	; write function vector
      1  1969		       43 1a		      .word.w	SerialOut
      0  196b					      dw	SerialStatus	; Get current Status info/Write config
      1  196b		       43 1a		      .word.w	SerialStatus
     51  196d
     52  196d				   ClockDevice		; Block 2
      0  196d					      dw	ClockID	; Day/date Clock
      1  196d		       10 00		      .word.w	ClockID
      0  196f					      dw	ClockRead	; Read the date from clock
      1  196f		       43 1a		      .word.w	ClockRead
      0  1971					      dw	ClockWrite	; Set the date/time of clock
      1  1971		       43 1a		      .word.w	ClockWrite
      0  1973					      dw	#0	; No Status/Config Function
      1  1973		       00 00		      .word.w	#0
     57  1975
     58  1975				   TimerDevice		; Block 3
      0  1975					      dw	TimerID	; Timer/interrupt interface
      1  1975		       18 00		      .word.w	TimerID
      0  1977					      dw	TimerStart	; Start the timer
      1  1977		       43 1a		      .word.w	TimerStart
      0  1979					      dw	TimerStop	; Stop the timer
      1  1979		       43 1a		      .word.w	TimerStop
      0  197b					      dw	TimerStatus	; Config/read status
      1  197b		       43 1a		      .word.w	TimerStatus
     63  197d
      0  197d				   DiskDevice dw	DiskID	; Block 4
      1  197d		       20 00		      .word.w	DiskID
      0  197f					      dw	DIN	; Disk Input / read function
      1  197f		       88 30		      .word.w	DIN
      0  1981					      dw	DOUT	; Disk Output / write function
      1  1981		       6f 30		      .word.w	DOUT
      0  1983					      dw	DSTAT	; Disk Status/open/close etc information
      1  1983		       a1 30		      .word.w	DSTAT
     68  1985							;
     69  1985							;======================================================================
     70  1985							; Define the Device/Slot,driver control blocks
     71  1985							; entry format: ControlWord,DeviceDriver,PortAddress,StatusWord
     72  1985							; Fixed at 10 devices memory usage is getting pretty big!!!!!!
     73  1985							; Control word : bit 0 = active 1, Free 0
     74  1985
     75  1985				   DeviceIoBlocks
      0  1985					      dw	1, ConsoleID, $E000, 0	; Console device is 0 file
      1  1985		       01 00 00 00*	      .word.w	1, ConsoleID, $E000, 0
      0  198d					      dw	1, ClockID, $E010, 0	; Port for the day/time clock
      1  198d		       01 00 10 00*	      .word.w	1, ClockID, $E010, 0
      0  1995					      dw	1, TimerID, $E010, 0	; Timer interface
      1  1995		       01 00 18 00*	      .word.w	1, TimerID, $E010, 0
      0  199d					      dw	1, DiskID, $E010, 0	; Disk Driver interface
      1  199d		       01 00 20 00*	      .word.w	1, DiskID, $E010, 0
      0  19a5					      dw	1, SerialID, $E020, 0	; Second terminal(default Basic debug)
      1  19a5		       01 00 08 00*	      .word.w	1, SerialID, $E020, 0
      0  19ad					      dw	0, SerialID, $E030, 0	; Unused slot
      1  19ad		       00 00 08 00*	      .word.w	0, SerialID, $E030, 0
      0  19b5					      dw	0, SerialID, $E040, 0	; Unused slot
      1  19b5		       00 00 08 00*	      .word.w	0, SerialID, $E040, 0
      0  19bd					      dw	0, SerialID, $E050, 0	; Unused slot
      1  19bd		       00 00 08 00*	      .word.w	0, SerialID, $E050, 0
      0  19c5					      dw	0, SerialID, $E060, 0	; Unused slot
      1  19c5		       00 00 08 00*	      .word.w	0, SerialID, $E060, 0
      0  19cd					      dw	0, SerialID, $E070, 0	; Unused slot
      1  19cd		       00 00 08 00*	      .word.w	0, SerialID, $E070, 0
     86  19d5							;
     87  19d5							;======================================================================
     88  19d5							;
     89  19d5					      Seg	Code
     90  19d5							;======================================================================
     91  19d5							; This is the Basic IRQ handler, works with task manager
     92  19d5							;
     93  19d5		       48	   ServiceIrq pha
     94  19d6		       ad 59 19 	      lda	IRQStatus
     95  19d9		       f0 0a		      BEQ	RetIrq
     96  19db		       ad 5a 19 	      lda	IRQPending
     97  19de		       d0 05		      bne	RetIrq
     98  19e0		       a9 01		      lda	#1
     99  19e2		       8d 5a 19 	      sta	IRQPending
    100  19e5		       68	   RetIrq     pla
    101  19e6		       40		      rti
    102  19e7							;======================================================================
    103  19e7							; Jump to the output/input function in BOutVec/BInVec
    104  19e7							;
    105  19e7		       6c 7a 35    VOUTCH     jmp	(BOutVec)	; Primary block io vectors
    106  19ea		       6c 78 35    VGETCH     jmp	(BInVec)
    107  19ed		       6c 7c 35    VSTAT      jmp	(BStatVec)
    108  19f0							;
    109  19f0							;======================================================================
    110  19f0							; IO Service functions
    111  19f0							; Validate the device index and set x to offest in table
    112  19f0							; does not return to ioInterface if invalid, returns to original caller
    113  19f0							; should be called immediatly after entering the ioInterface call
    114  19f0				   ioValidateDevice
    115  19f0		       e0 0a		      cpx	#IO_MAX_DEVICES
    116  19f2		       90 04		      bcc	ioValidIndex
    117  19f4		       a2 02		      ldx	#IO_DEVICE_INVALID
    118  19f6		       b0 13		      bcs	ioInvalidDevice
    119  19f8				   ioValidIndex
    120  19f8		       8a		      txa
    121  19f9		       0a		      asl		; Multiply by 8
    122  19fa		       0a		      asl
    123  19fb		       0a		      asl
    124  19fc		       aa		      tax		; Point to actual offset in the table
    125  19fd		       ec 7e 35 	      cpx	BActiveDevice	; is it already active ?
    126  1a00		       f0 0d		      beq	ioValidDevice	; Shortcut if this is the active device already
    127  1a02		       a9 01		      lda	#1	; Active flag
    128  1a04		       3d 85 19 	      and	DeviceIoBlocks,x	; Check if the device is active
    129  1a07		       d0 06		      bne	ioValidDevice	; The device is active and valid index
    130  1a09		       a2 01		      ldx	#IO_DEVICE_CLOSED
    131  1a0b
    132  1a0b				   ioInvalidDevice
    133  1a0b		       68		      pla		; Remove return address of IO interface
    134  1a0c		       68		      pla
    135  1a0d		       38		      sec		; ensure that carry is set
    136  1a0e		       60		      rts
    137  1a0f
    138  1a0f				   ioValidDevice
    139  1a0f		       18		      clc
    140  1a10		       60		      rts
    141  1a11							;
    142  1a11							;===================================================================================
    143  1a11							; Set the io device jmp vectors
    144  1a11							; input x contains the vector to the active Device IO Block
    145  1a11							; output a, x undefined y unchanged
    146  1a11				   ioSetDeviceVectors
    147  1a11		       ec 7e 35 	      cpx	BActiveDevice	; Check if already set
    148  1a14		       f0 1b		      beq	ioSetDevExit	; if already set then do nothing
    149  1a16
    150  1a16		       8e 7e 35 	      stx	BActiveDevice	; set the active device vector
    151  1a19		       98		      tya
    152  1a1a		       48		      pha
    153  1a1b
    154  1a1b		       bc 87 19 	      ldy	DeviceIoBlocks+2,x	; Get the device driver index
    155  1a1e		       8c 7f 35 	      sty	BActiveDriver	; Pointer to active Device driver
    156  1a21		       a2 00		      ldx	#0	; Transfer the 6 pointers to the Vectors
    157  1a23				   ioSetDevLoop
    158  1a23		       b9 5f 19 	      lda	DeviceDriverBlocks+2,y
    159  1a26		       9d 78 35 	      sta	BInVec,x
    160  1a29		       e8		      inx
    161  1a2a		       c8		      iny
    162  1a2b		       e0 06		      cpx	#IO_VECT_LEN	; Transfer the vector length to copy
    163  1a2d		       d0 f4		      bne	ioSetDevLoop
    164  1a2f
    165  1a2f		       68		      pla
    166  1a30		       a8		      tay
    167  1a31				   ioSetDevExit
    168  1a31		       60		      rts
    169  1a32							;
    170  1a32							;======================================================================
    171  1a32							; Generic call interface for devices
    172  1a32							; input x = DeviceIoBlockIndex
    173  1a32							; Carry set if error, x contains the error code
    174  1a32							; all other parameters are dependant upon the actual device interface
    175  1a32							;
    176  1a32							; ioPutCH  a contains the character to send
    177  1a32		       20 f0 19    ioPutCH    jsr	ioValidateDevice
    178  1a35		       48		      pha
    179  1a36		       20 11 1a 	      jsr	ioSetDeviceVectors
    180  1a39		       68		      pla
    181  1a3a		       20 e7 19 	      jsr	VOUTCH
    182  1a3d		       18		      clc
    183  1a3e		       60		      rts
    184  1a3f
    185  1a3f							; io Getch returns the character read from device
    186  1a3f		       20 f0 19    ioGetCH    jsr	ioValidateDevice
    187  1a42
    188  1a42		       60		      rts
    189  1a43							;
    190  1a43							;======================================================================
    191  1a43							;TTY interface functions,
    192  1a43							;	a contains the character to send
    193  1a43							;	x contains the Device ID (equals index into io blocks)	of the io block to used
    194  1a43							;
    195  1a43				   SerialIn
    196  1a43
    197  1a43				   SerialOut
    198  1a43
    199  1a43				   SerialStatus
    200  1a43
    201  1a43							;
    202  1a43							;======================================================================
    203  1a43							; Date/Time clock interface
    204  1a43				   ClockRead
    205  1a43
    206  1a43				   ClockWrite
    207  1a43
    208  1a43							;
    209  1a43							;======================================================================
    210  1a43							;
    211  1a43				   TimerStart
    212  1a43
    213  1a43				   TimerStop
    214  1a43
    215  1a43				   TimerStatus
    216  1a43
    217  1a43
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  1a43					      include	"tokenizer.asm"
      1  1a43					      seg	Code
      2  1a43		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  1a43
      4  1a43							; Define the types of tokens found, and identifiers
      5  1a43		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  1a43		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  1a43		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  1a43		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  1a43
     10  1a43		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  1a43		       00 9c	   tVhash     equ	$9C	; Variable #
     12  1a43		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  1a43
     14  1a43							; Base variable type supported by This basic
     15  1a43							; Unsigned types always have the 0 bit set to 1
     16  1a43		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     17  1a43		       00 a2	   tByte      equ	$A2	; Signed Byte value
     18  1a43		       00 a4	   tInteger   equ	$A4	; all tokenized integers start with 251 as first byte 16 bit signed number
     19  1a43		       00 a6	   tLong      equ	$A6	; Signed 32 bit integer
     20  1a43
     21  1a43		       00 a1	   tArray     equ	$A1	; Identifies Array Type, the byte following defines the length of each element
     22  1a43							; Arrays of string are arrays of pointers 2 bytes each
     23  1a43		       00 a3	   tPointer   equ	$A3	; Pointer  unsigned 16 bit
     24  1a43		       00 a5	   tIndirect  equ	$A5	; Points to an address that points to the data 16 bits
     25  1a43		       00 a7	   tuByte     equ	$A7	; Unsigned byte value 8 bit unsigned value
     26  1a43		       00 a9	   tUint      equ	$A9	; unsigned integer type 16 bit
     27  1a43		       00 ab	   tUlong     equ	$AB	; Unsigned 32 bit integer
     28  1a43
     29  1a43		       3c 3e	   Operators  BYTE.b	"<>"
     30  1a45		       3c 3d		      BYTE.b	"<="
     31  1a47		       3e 3d		      BYTE.b	">="
     32  1a49		       3c 00		      BYTE.b	"<",0
     33  1a4b		       3d 00		      BYTE.b	"=",0
     34  1a4d		       3e 00		      BYTE.b	">",0
     35  1a4f		       2b 00		      BYTE.b	"+",0
     36  1a51		       2d 00		      BYTE.b	"-",0
     37  1a53		       2f 00		      BYTE.b	"/",0
     38  1a55		       25 00		      BYTE.b	"%",0
     39  1a57		       2a 00		      BYTE.b	"*",0
     40  1a59		       28 00		      BYTE.b	"(",0
     41  1a5b		       29 00		      BYTE.b	")",0
     42  1a5d		       2c 00		      BYTE.b	",",0
     43  1a5f		       3b 00		      BYTE.b	";",0
     44  1a61		       5b 00		      BYTE.b	"[",0
     45  1a63		       5d 00		      BYTE.b	"]",0
     46  1a65		       3a 00		      BYTE.b	":",0
     47  1a67		       24 00		      BYTE.b	"$",0
     48  1a69		       21 00		      BYTE.b	"!",0
     49  1a6b		       3f 00		      BYTE.b	"?",0
     50  1a6d		       2e 00		      BYTE.b	".",0
     51  1a6f		       00 00		      BYTE.b	0,0
     52  1a71
     53  1a71		       f5 f3 f6 f1*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oLess,oEqual,oGreater
     54  1a77		       ea eb ec ed*	      BYTE.b	oPlus, oMinus, oDivide, oModulo, oMultiply
     55  1a7c		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     56  1a82		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod
     57  1a87
     58  1a87		       00 0b	   oQuestion  equ	kPrint
     59  1a87							;    2 is =
     60  1a87							;    1 is <
     61  1a87							;    3 is <=
     62  1a87							;    5 is <>
     63  1a87							;    4 is >
     64  1a87							;    6 is >=
     65  1a87		       00 f1	   oLess      equ	$F1
     66  1a87		       00 f2	   oEqual     equ	$F2
     67  1a87		       00 f3	   oLessEqual equ	$F3
     68  1a87		       00 f4	   oGreater   equ	$F4
     69  1a87		       00 f5	   oNotEqual  equ	$F5
     70  1a87		       00 f6	   oGreaterEqual equ	$F6
     71  1a87
     72  1a87		       00 e0	   oLeftBracket equ	$E0
     73  1a87		       00 e1	   oRightBracket equ	$E1
     74  1a87		       00 e2	   oComma     equ	$E2
     75  1a87		       00 e3	   oSemiColon equ	$E3
     76  1a87		       00 e4	   oLeftSQBracket equ	$E4
     77  1a87		       00 e5	   oRightSQBracket equ	$E5
     78  1a87		       00 e6	   oColon     equ	$E6
     79  1a87		       00 e7	   oDollar    equ	$E7
     80  1a87		       00 e8	   oBang      equ	$E8
     81  1a87		       00 e9	   oPeriod    equ	$E9
     82  1a87
     83  1a87
     84  1a87		       00 ea	   oPlus      equ	$EA
     85  1a87		       00 eb	   oMinus     equ	$EB
     86  1a87		       00 ec	   oDivide    equ	$EC
     87  1a87		       00 ed	   oModulo    equ	$ED
     88  1a87		       00 ee	   oMultiply  equ	$EE
     89  1a87
     90  1a87		       00 ed	   oPercent   equ	oModulo
     91  1a87
     92  1a87		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
     93  1a87
     94  1a87		       00 ff	   tError     equ	$FF	; Error should never happen
     95  1a87							;============================================================================================
     96  1a87							; Keyword and seperator values
     97  1a87				   '
     98  1a87		       00 01	   kBeginKey  equ	kLet
     99  1a87							;
    100  1a87		       00 01	   kLet       equ	1
    101  1a87		       00 02	   kInc       equ	kLet+1
    102  1a87		       00 03	   kDec       equ	kInc+1
    103  1a87		       00 04	   kIreturn   equ	kDec+1
    104  1a87		       00 05	   kIf	      equ	kIreturn+1
    105  1a87		       00 06	   kThen      equ	kIf+1
    106  1a87		       00 07	   kGoto      equ	kThen+1
    107  1a87		       00 08	   kGosub     equ	kGoto+1
    108  1a87		       00 09	   kReturn    equ	kGosub+1
    109  1a87		       00 0a	   kRem       equ	kReturn+1
    110  1a87		       00 0b	   kPrint     equ	kRem+1
    111  1a87		       00 0c	   kTaske     equ	kPrint+1
    112  1a87		       00 0d	   kTaskn     equ	kTaske+1
    113  1a87		       00 0e	   kTaskw     equ	kTaskn+1
    114  1a87		       00 0f	   kPoke      equ	kTaskw+1
    115  1a87		       00 10	   kPutch     equ	kPoke+1
    116  1a87		       00 11	   kCls       equ	kPutch+1
    117  1a87		       00 12	   kInput     equ	kCls+1
    118  1a87		       00 13	   kEnd       equ	kInput+1
    119  1a87		       00 14	   kIrq       equ	kEnd+1
    120  1a87		       00 15	   kKill      equ	kIrq+1
    121  1a87		       00 16	   kList      equ	kKill+1
    122  1a87		       00 17	   kRun       equ	kList+1
    123  1a87		       00 18	   kNew       equ	kRun+1
    124  1a87		       00 19	   kSlice     equ	kNew+1
    125  1a87		       00 1a	   kTrace     equ	kSlice+1
    126  1a87		       00 1b	   kExit      equ	kTrace+1
    127  1a87		       00 1c	   kSave      equ	kExit+1
    128  1a87		       00 1d	   kLoad      equ	kSave+1
    129  1a87		       00 1e	   kErase     equ	kLoad+1
    130  1a87		       00 1f	   kDir       equ	kErase+1
    131  1a87		       00 20	   kSetTerm   equ	kDir+1
    132  1a87		       00 21	   kSetMemB   equ	kSetTerm+1
    133  1a87		       00 22	   kSetMemW   equ	kSetMemB+1
    134  1a87		       00 23	   kCopyMem   equ	kSetMemW+1
    135  1a87							;
    136  1a87							; End of actual key words
    137  1a87							;
    138  1a87		       00 22	   kKeyCount  equ	kCopyMem-kBeginKey
    139  1a87							;
    140  1a87							; Logical operators
    141  1a87							;
    142  1a87		       00 24	   kNot       equ	kCopyMem+1
    143  1a87		       00 25	   kOr	      equ	kNot+1
    144  1a87		       00 26	   kXor       equ	kOr+1
    145  1a87		       00 27	   kAnd       equ	kXor+1
    146  1a87							;
    147  1a87							; Shift operators
    148  1a87							;
    149  1a87		       00 28	   kShr       equ	kAnd+1
    150  1a87		       00 29	   kShl       equ	kShr+1
    151  1a87
    152  1a87							; numeric functions
    153  1a87							;
    154  1a87		       00 2a	   kBeginFunc equ	kTrue
    155  1a87							;
    156  1a87							; Truth operators
    157  1a87							;
    158  1a87		       00 2a	   kTrue      equ	kShl+1
    159  1a87		       00 2b	   kFalse     equ	kTrue+1
    160  1a87							; Functions
    161  1a87		       00 2c	   kFree      equ	kFalse+1
    162  1a87		       00 2d	   kGetch     equ	kFree+1
    163  1a87		       00 2e	   kPeek      equ	kGetch+1
    164  1a87		       00 2f	   kTask      equ	kPeek+1
    165  1a87		       00 30	   kIpcc      equ	kTask+1
    166  1a87		       00 31	   kIpcs      equ	kIpcc+1
    167  1a87		       00 32	   kIpcr      equ	kIpcs+1
    168  1a87		       00 33	   kRnd       equ	kIpcr+1
    169  1a87		       00 34	   kStat      equ	kRnd+1
    170  1a87		       00 35	   kAbs       equ	kStat+1
    171  1a87		       00 36	   kCall      equ	kAbs+1
    172  1a87		       00 37	   kGofn      equ	kCall+1
    173  1a87		       00 38	   kPid       equ	kGofn+1
    174  1a87		       00 39	   kAddr      equ	kPid+1
    175  1a87		       00 3a	   kCmpMem    equ	kAddr+1
    176  1a87							;
    177  1a87		       00 11	   kFuncCount equ	((kCmpMem - kBeginFunc) + 1)
    178  1a87
    179  1a87							;
    180  1a87							; Keyword table contains 54 keywords
    181  1a87				   KeyWordTable
      0  1a87					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  1a87		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  1a8b					      db	kInc,"inC"
      1  1a8b		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  1a8f					      db	kDec,"deC"
      1  1a8f		       03 64 65 43	      .byte.b	kDec,"deC"
      0  1a93					      db	kIreturn,"ireturN"
      1  1a93		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  1a9b					      db	kIf,"iF"
      1  1a9b		       05 69 46 	      .byte.b	kIf,"iF"
      0  1a9e					      db	kThen,"theN"
      1  1a9e		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  1aa3					      db	kGoto,"gotO"
      1  1aa3		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  1aa8					      db	kGosub,"gosuB"
      1  1aa8		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  1aae					      db	kReturn,"returN"
      1  1aae		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  1ab5					      db	kRem,"reM"
      1  1ab5		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  1ab9					      db	kPrint,"prinT"
      1  1ab9		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  1abf					      db	kTaske,"taskE"
      1  1abf		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  1ac5					      db	kTaskn,"taskN"
      1  1ac5		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  1acb					      db	kTaskw,"taskW"
      1  1acb		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  1ad1					      db	kPoke,"pokE"
      1  1ad1		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  1ad6					      db	kPutch,"putcH"
      1  1ad6		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  1adc					      db	kCls,"clS"
      1  1adc		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  1ae0					      db	kInput,"inpuT"
      1  1ae0		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  1ae6					      db	kEnd,"enD"
      1  1ae6		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  1aea					      db	kIrq,"irQ"
      1  1aea		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  1aee					      db	kKill,"kilL"
      1  1aee		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  1af3					      db	kList,"lisT"
      1  1af3		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  1af8					      db	kRun,"ruN"
      1  1af8		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  1afc					      db	kNew,"neW"
      1  1afc		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  1b00					      db	kSlice,"slicE"
      1  1b00		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  1b06					      db	kTrace,"tracE"
      1  1b06		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  1b0c					      db	kExit,"exiT"
      1  1b0c		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  1b11					      db	kSave,"savE"
      1  1b11		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  1b16					      db	kLoad,"loaD"
      1  1b16		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  1b1b					      db	kErase,"erasE"
      1  1b1b		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  1b21					      db	kDir,"diR"
      1  1b21		       1f 64 69 52	      .byte.b	kDir,"diR"
    213  1b25							;Short form for statements:
      0  1b25					      db	kIreturn,"ireT"
      1  1b25		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  1b2a					      db	kReturn,"reT"
      1  1b2a		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  1b2e					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  1b2e		       0b 70 52 	      .byte.b	kPrint,"pR"
      0  1b31					      db	kSetTerm, "setterM"
      1  1b31		       20 73 65 74*	      .byte.b	kSetTerm, "setterM"
      0  1b39					      db	kSetMemB, "setmemB"
      1  1b39		       21 73 65 74*	      .byte.b	kSetMemB, "setmemB"
      0  1b41					      db	kSetMemW, "setmemW"
      1  1b41		       22 73 65 74*	      .byte.b	kSetMemW, "setmemW"
      0  1b49					      db	kCopyMem, "copymeM"
      1  1b49		       23 63 6f 70*	      .byte.b	kCopyMem, "copymeM"
    221  1b51
    222  1b51							; Shift operators
      0  1b51					      db	kShr,"shR"
      1  1b51		       28 73 68 52	      .byte.b	kShr,"shR"
      0  1b55					      db	kShl,"shL"
      1  1b55		       29 73 68 4c	      .byte.b	kShl,"shL"
    225  1b59
    226  1b59							;Logical and truth operators
      0  1b59					      db	kNot,"noT"
      1  1b59		       24 6e 6f 54	      .byte.b	kNot,"noT"
      0  1b5d					      db	kOr,"oR"
      1  1b5d		       25 6f 52 	      .byte.b	kOr,"oR"
      0  1b60					      db	kXor,"xoR"
      1  1b60		       26 78 6f 52	      .byte.b	kXor,"xoR"
      0  1b64					      db	kAnd,"anD"
      1  1b64		       27 61 6e 44	      .byte.b	kAnd,"anD"
    231  1b68
    232  1b68							; Truth values
      0  1b68					      db	kTrue,"truE"
      1  1b68		       2a 74 72 75*	      .byte.b	kTrue,"truE"
      0  1b6d					      db	kFalse,"falsE"
      1  1b6d		       2b 66 61 6c*	      .byte.b	kFalse,"falsE"
    235  1b73
    236  1b73
    237  1b73
    238  1b73							;functions returning values
    239  1b73
      0  1b73					      db	kFree,"freE"
      1  1b73		       2c 66 72 65*	      .byte.b	kFree,"freE"
      0  1b78					      db	kGetch,"getcH"
      1  1b78		       2d 67 65 74*	      .byte.b	kGetch,"getcH"
      0  1b7e					      db	kPeek,"peeK"
      1  1b7e		       2e 70 65 65*	      .byte.b	kPeek,"peeK"
      0  1b83					      db	kTask,"tasK"
      1  1b83		       2f 74 61 73*	      .byte.b	kTask,"tasK"
      0  1b88					      db	kIpcc,"ipcC"
      1  1b88		       30 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  1b8d					      db	kIpcs,"ipcS"
      1  1b8d		       31 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  1b92					      db	kIpcr,"ipcR"
      1  1b92		       32 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  1b97					      db	kRnd,"rnD"
      1  1b97		       33 72 6e 44	      .byte.b	kRnd,"rnD"
      0  1b9b					      db	kStat,"staT"
      1  1b9b		       34 73 74 61*	      .byte.b	kStat,"staT"
      0  1ba0					      db	kAbs,"abS"
      1  1ba0		       35 61 62 53	      .byte.b	kAbs,"abS"
      0  1ba4					      db	kCall,"calL"
      1  1ba4		       36 63 61 6c*	      .byte.b	kCall,"calL"
      0  1ba9					      db	kGofn,"fN"
      1  1ba9		       37 66 4e 	      .byte.b	kGofn,"fN"
      0  1bac					      db	kPid,"piD"
      1  1bac		       38 70 69 44	      .byte.b	kPid,"piD"
      0  1bb0					      db	kAddr,"addR"
      1  1bb0		       39 61 64 64*	      .byte.b	kAddr,"addR"
      0  1bb5					      db	kCmpMem, "cmpmeM"
      1  1bb5		       3a 63 6d 70*	      .byte.b	kCmpMem, "cmpmeM"
      0  1bbc					      db	0,0
      1  1bbc		       00 00		      .byte.b	0,0
    256  1bbe
    257  1bbe		       1b be	   KeyWordTableEnd equ	*
    258  1bbe		       01 37	   KeyWordTableLength equ	* - KeyWordTable
    259  1bbe		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    260  1cbe		       00 00 00    printStorage ds	3
    261  1cc1							;==================================================================================================================
    262  1cc1							; Read accross the inputline and output to TOKENBUFFER
    263  1cc1							; Format   byte      Description
    264  1cc1							;	     0	      length of line 1-255
    265  1cc1							;	    0-1       Line Number
    266  1cc1							;	    Tokens and litteral values encoded into the line
    267  1cc1							;
    268  1cc1							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    269  1cc1							;  if fails then test for keywords
    270  1cc1							;  if fails then test for variables and arrays
    271  1cc1							;  if fails check for operators/seperators  + - < > = % / * () [] , ; : >> <<
    272  1cc1
    273  1cc1				   ParseInputLine
    274  1cc1				  -	      if	DEBUGPARSER
    275  1cc1				  -	      jsr	SetOutDebug
    276  1cc1				  -	      jsr	DebugClearBuffer
    277  1cc1					      endif
    278  1cc1		       a5 51		      lda	CUROFF
    279  1cc3		       48		      pha
    280  1cc4		       8a		      txa
    281  1cc5		       48		      pha
    282  1cc6		       98		      tya
    283  1cc7		       48		      pha
    284  1cc8		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    285  1cca		       20 0a 2a 	      jsr	getDecimal	; Check for a line number, none is ok too
    286  1ccd		       84 51		      sty	CUROFF
    287  1ccf		       20 8d 1e 	      jsr	R02TOKEN	; Move R0 to token buffer
    288  1cd2
    289  1cd2				   ParseInputLoop
    290  1cd2		       a4 51		      ldy	CUROFF
    291  1cd4		       20 9a 2c 	      jsr	SkipSpaces	; Skip any spaces
    292  1cd7		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    293  1cd9		       b9 a4 41 	      lda	LINBUF,y	; Check for end of line
    294  1cdc		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    295  1cde
    296  1cde				   ParseForNumber
    297  1cde		       20 e1 1d 	      jsr	ParseNumeric	; Check for a numeric value
    298  1ce1		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    299  1ce3
    300  1ce3				   ParseForString
    301  1ce3		       20 b7 1d 	      jsr	ParseString	; Check for a string
    302  1ce6		       90 ea		      bcc	ParseInputLoop	; It was a string
    303  1ce8
    304  1ce8				   ParseForOp
    305  1ce8		       20 1f 1e 	      jsr	ParseForOperator	; Check for operator or punctuation
    306  1ceb		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    307  1ced
    308  1ced				   ParseForKey
    309  1ced		       20 14 1d 	      jsr	ParseLookupKey	; Check for a keyword value
    310  1cf0		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    311  1cf2
    312  1cf2				   ParseForVar
    313  1cf2		       20 56 1e 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    314  1cf5		       90 db		      bcc	ParseInputLoop
    315  1cf7
    316  1cf7				   ParseKeepChar		; if it does not parse just keep it safe
    317  1cf7		       b9 a4 41 	      lda	LINBUF,y
    318  1cfa		       9d be 1b 	      sta	TOKENBUFFER,x
    319  1cfd		       e8		      inx
    320  1cfe		       c8		      iny
    321  1cff		       84 51		      sty	CUROFF
    322  1d01		       d0 cf		      bne	ParseInputLoop
    323  1d03
    324  1d03				   ParseComplete
    325  1d03		       a9 00		      lda	#0
    326  1d05		       9d be 1b 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    327  1d08		       e8		      inx
    328  1d09		       8e be 1b 	      stx	TOKENBUFFER	; Place size including null into buffer start
    329  1d0c
    330  1d0c		       68		      pla
    331  1d0d		       a8		      tay
    332  1d0e		       68		      pla
    333  1d0f		       aa		      tax
    334  1d10		       68		      pla
    335  1d11		       85 51		      sta	CUROFF
    336  1d13
    337  1d13				  -	      if	DEBUGPARSER
    338  1d13				  -
    339  1d13				  -	      jsr	printTokenBuffer
    340  1d13				  -			;jsr	  DebugPrintProgramLine
    341  1d13				  -	      jsr	SetOutDebugEnd
    342  1d13				  -
    343  1d13					      endif
    344  1d13		       60		      rts
    345  1d14
    346  1d14							;==================================================================================================================
    347  1d14							; Look at curptr, curpos and check for a valid KeyWord
    348  1d14							; A contains the index value. c is clear
    349  1d14							;		     not found c set  A undefined
    350  1d14							; X is prerserved
    351  1d14							;
    352  1d14				   ParseLookupKey
    353  1d14		       86 58		      stx	R2
    354  1d16		       a0 00		      ldy	#0
    355  1d18		       a9 87		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    356  1d1a		       85 54		      sta	R1
    357  1d1c		       a9 1a		      lda	#KeyWordTable>>8
    358  1d1e		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    359  1d20		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    360  1d22		       85 52		      sta	R0	; Save until next keyword
    361  1d24		       c8		      iny		; Point to first character of keyword
    362  1d25		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    363  1d27
    364  1d27				  -	      if	DEBUGPARSER
    365  1d27				  -			;    jsr DebugKeyword
    366  1d27					      endif
    367  1d27
    368  1d27				   ParseLookupLoop
    369  1d27		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    370  1d29		       29 df		      and	#%11011111	; Force Keyword to upper case
    371  1d2b		       dd a4 41 	      cmp	LINBUF,x	; Check the input buffer
    372  1d2e		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    373  1d30		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    374  1d32		       dd a4 41 	      cmp	LINBUF,x	; Compare value to upercase
    375  1d35		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    376  1d37
    377  1d37				   ParseNextLetter
    378  1d37		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    379  1d39		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    380  1d3b		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    381  1d3d		       e8		      inx		; Point to next char in the input buffer
    382  1d3e		       c8		      iny		; Point to the next character in the Keyword table
    383  1d3f		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    384  1d41		       dd a4 41 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    385  1d44		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    386  1d46		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    387  1d48
    388  1d48				   ParseKeyFound
    389  1d48		       a5 52		      lda	R0	; get the keyword index
    390  1d4a
    391  1d4a				   ParseKeyDone
    392  1d4a		       e8		      inx		; point past the last character
    393  1d4b		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    394  1d4d		       a6 58		      ldx	R2	; Restore the original x pointer
    395  1d4f		       9d be 1b 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    396  1d52		       e8		      inx		; Point to next position in the output buffer
    397  1d53		       86 58		      stx	R2	; Save next position in buffer
    398  1d55		       c9 0a		      cmp	#kRem	; remark statement
    399  1d57		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    400  1d59		       c9 07		      cmp	#kGoto
    401  1d5b		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    402  1d5d		       c9 08		      cmp	#kGosub
    403  1d5f		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    404  1d61		       c9 37		      cmp	#kGofn
    405  1d63		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    406  1d65		       c9 2f		      cmp	#kTask
    407  1d67		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    408  1d69
    409  1d69		       18		      clc		; C flag clear, we found it
    410  1d6a		       60		      rts
    411  1d6b
    412  1d6b							; Move forward to the next entry in table
    413  1d6b				   ParseNextEntry
    414  1d6b		       b1 54		      lda	(R1),y	; Get the next character in the token
    415  1d6d		       29 20		      and	#%00100000	; Is it the last character
    416  1d6f		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    417  1d71		       c8		      iny		; Point to next char in the entry
    418  1d72		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    419  1d74
    420  1d74				   ParseEndOfEntry
    421  1d74		       c8		      iny		; Point to the byte after the last character
    422  1d75		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    423  1d76		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    424  1d77		       65 54		      adc	R1
    425  1d79		       85 54		      sta	R1
    426  1d7b		       a5 55		      lda	R1+1
    427  1d7d		       69 00		      adc	#0
    428  1d7f		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    429  1d81		       a0 00		      ldy	#0	; Reset the index back to zero
    430  1d83		       b1 54		      lda	(R1),y	; get keyword value
    431  1d85		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    432  1d87		       85 52		      sta	R0	; save the next token value
    433  1d89		       c8		      iny		; Inc past token value
    434  1d8a
    435  1d8a				  -	      if	DEBUGPARSER
    436  1d8a				  -			;    jsr DebugKeyword
    437  1d8a					      endif
    438  1d8a		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    439  1d8c		       4c 27 1d 	      jmp	ParseLookupLoop	; branch back for next key word
    440  1d8f
    441  1d8f				   ParseNoneFound
    442  1d8f		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    443  1d91		       38		      sec		; c clear, not found
    444  1d92		       60		      rts
    445  1d93
    446  1d93							;===============================================================================
    447  1d93							; Move everything from current position until the end of line into the token buffer
    448  1d93							;
    449  1d93		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    450  1d95		       a6 58		      ldx	R2	; where to place in the buffer
    451  1d97				   ParseMoveLoop
    452  1d97		       b9 a4 41 	      lda	LINBUF,y	; get the next byte
    453  1d9a		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    454  1d9c		       9d be 1b 	      sta	TOKENBUFFER,x	; save the byte
    455  1d9f		       c8		      iny
    456  1da0		       e8		      inx
    457  1da1		       d0 f4		      bne	ParseMoveLoop
    458  1da3				   ParseMoveDone
    459  1da3		       84 51		      sty	CUROFF
    460  1da5		       18		      clc
    461  1da6		       60		      rts
    462  1da7							;================================================================================================
    463  1da7							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    464  1da7							; transfer to a memory address
    465  1da7				   ParseHandleBranches
    466  1da7		       a6 58		      ldx	R2
    467  1da9		       a9 00		      lda	#0
    468  1dab		       9d be 1b 	      sta	TOKENBUFFER,x
    469  1dae		       e8		      inx
    470  1daf		       9d be 1b 	      sta	TOKENBUFFER,x
    471  1db2		       e8		      inx
    472  1db3		       86 58		      stx	R2
    473  1db5		       18		      clc
    474  1db6		       60		      rts
    475  1db7
    476  1db7							;=========================================================================================================
    477  1db7							;ParseString Parse a quotes string
    478  1db7							; on input X = outbuf position
    479  1db7							; y = inbuf position
    480  1db7							; Copies string to output buffer, updates x and y
    481  1db7				   ParseString
    482  1db7		       a4 51		      ldy	CUROFF
    483  1db9		       a9 a0		      lda	#tString
    484  1dbb		       9d be 1b 	      sta	TOKENBUFFER,X
    485  1dbe		       b9 a4 41 	      lda	LINBUF,y
    486  1dc1		       c9 22		      cmp	#'"
    487  1dc3		       d0 1a		      bne	ParseStringInvalid
    488  1dc5		       e8		      inx
    489  1dc6		       9d be 1b 	      sta	TOKENBUFFER,x
    490  1dc9		       e8		      inx
    491  1dca		       c8		      iny
    492  1dcb
    493  1dcb				   ParseStringLoop
    494  1dcb		       b9 a4 41 	      lda	LINBUF,y
    495  1dce		       9d be 1b 	      sta	TOKENBUFFER,x
    496  1dd1		       c9 22		      cmp	#'"
    497  1dd3		       f0 04		      beq	ParseStringDone
    498  1dd5		       c8		      iny
    499  1dd6		       e8		      inx
    500  1dd7		       d0 f2		      bne	ParseStringLoop
    501  1dd9
    502  1dd9				   ParseStringDone
    503  1dd9		       e8		      inx
    504  1dda		       c8		      iny
    505  1ddb		       84 51		      sty	CUROFF
    506  1ddd		       18		      clc
    507  1dde		       60		      rts
    508  1ddf
    509  1ddf				   ParseStringInvalid
    510  1ddf		       38		      sec
    511  1de0		       60		      rts
    512  1de1
    513  1de1							;=========================================================================================================
    514  1de1							; Get numeric values and return value in RO and type in a
    515  1de1							;
    516  1de1				   ParseNumeric
    517  1de1		       a4 51		      ldy	CUROFF
    518  1de3		       b9 a4 41 	      lda	LINBUF,y
    519  1de6		       c9 30		      cmp	#'0
    520  1de8		       90 33		      bcc	ParseNumInvalid
    521  1dea		       c9 3a		      cmp	#'9+1
    522  1dec		       b0 2f		      bcs	ParseNumInvalid
    523  1dee		       86 58		      stx	R2
    524  1df0		       20 0a 2a 	      jsr	getDecimal
    525  1df3		       a6 58		      ldx	R2
    526  1df5		       84 51		      sty	CUROFF
    527  1df7		       a5 53		      lda	R0+1
    528  1df9		       f0 14		      beq	ParseByteValue
    529  1dfb
    530  1dfb				   ParseIntegerValue
    531  1dfb		       a9 a4		      lda	#tInteger
    532  1dfd		       9d be 1b 	      sta	TOKENBUFFER,x
    533  1e00		       e8		      inx
    534  1e01		       a5 52		      lda	R0
    535  1e03		       9d be 1b 	      sta	TOKENBUFFER,x
    536  1e06		       e8		      inx
    537  1e07		       a5 53		      lda	R0+1
    538  1e09		       9d be 1b 	      sta	TOKENBUFFER,X
    539  1e0c		       e8		      inx
    540  1e0d		       18		      clc
    541  1e0e		       60		      rts
    542  1e0f
    543  1e0f				   ParseByteValue
    544  1e0f		       a9 a2		      lda	#tByte
    545  1e11		       9d be 1b 	      sta	TOKENBUFFER,x
    546  1e14		       e8		      inx
    547  1e15		       a5 52		      lda	R0
    548  1e17		       9d be 1b 	      sta	TOKENBUFFER,x
    549  1e1a		       e8		      inx
    550  1e1b		       18		      clc
    551  1e1c		       60		      rts
    552  1e1d
    553  1e1d				   ParseNumInvalid		;Not a valid Numeric
    554  1e1d		       38		      sec
    555  1e1e		       60		      rts
    556  1e1f
    557  1e1f							;=========================================================================================================
    558  1e1f							;Parse for operators and seperators
    559  1e1f							; on exit the A has the oper code, c is clear
    560  1e1f							;		 not found then c is set
    561  1e1f							;	x is preserved
    562  1e1f							;
    563  1e1f				   ParseForOperator
    564  1e1f		       86 58		      stx	R2
    565  1e21		       a4 51		      ldy	CUROFF
    566  1e23		       a2 00		      ldx	#0
    567  1e25				  -	      if	DEBUGPARSER
    568  1e25				  -			;	jsr    DebugPrintOP
    569  1e25					      endif
    570  1e25
    571  1e25				   ParseOpLoop
    572  1e25		       bd 43 1a 	      lda	Operators,x	; First byte of operator
    573  1e28		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    574  1e2a
    575  1e2a		       d9 a4 41 	      cmp	LINBUF,y	; Check the first byte
    576  1e2d		       d0 1c		      bne	ParseOpNext
    577  1e2f
    578  1e2f		       c8		      iny
    579  1e30
    580  1e30		       bd 44 1a 	      lda	Operators+1,x
    581  1e33		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    582  1e35
    583  1e35		       d9 a4 41 	      cmp	LINBUF,y
    584  1e38		       d0 11		      bne	ParseOpNext
    585  1e3a
    586  1e3a				   ParseOpFound
    587  1e3a		       c8		      iny
    588  1e3b
    589  1e3b				   ParseOpFoundSingle
    590  1e3b		       84 51		      sty	CUROFF
    591  1e3d
    592  1e3d		       8a		      txa
    593  1e3e		       4a		      lsr
    594  1e3f		       aa		      tax
    595  1e40		       bd 71 1a 	      lda	OperValues,x
    596  1e43		       a6 58		      ldx	R2
    597  1e45		       9d be 1b 	      sta	TOKENBUFFER,x
    598  1e48		       e8		      inx
    599  1e49		       18		      clc
    600  1e4a		       60		      rts
    601  1e4b
    602  1e4b				   ParseOpNext
    603  1e4b		       e8		      inx
    604  1e4c		       e8		      inx
    605  1e4d
    606  1e4d				  -	      if	DEBUGPARSER
    607  1e4d				  -			;	 jsr	DebugPrintOP
    608  1e4d					      endif
    609  1e4d		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    610  1e4f		       4c 25 1e 	      jmp	ParseOpLoop
    611  1e52
    612  1e52				   ParseOpNotFound
    613  1e52		       a6 58		      ldx	R2
    614  1e54		       38		      sec
    615  1e55		       60		      rts
    616  1e56							;=========================================================================================================
    617  1e56				  -	      if	DEBUGPARSER
    618  1e56				  -			;Print the text of a keyword
    619  1e56				  -			;Input R1    = offset into table
    620  1e56				  -DebugKeyword
    621  1e56				  -	      tya
    622  1e56				  -	      pha
    623  1e56				  -	      ldy	#1
    624  1e56				  -DebugKeyLoop
    625  1e56				  -	      lda	(R1),y
    626  1e56				  -	      jsr	VOUTCH
    627  1e56				  -	      and	#%00100000
    628  1e56				  -	      beq	DebugKeyDone
    629  1e56				  -	      iny
    630  1e56				  -	      bne	DebugKeyLoop
    631  1e56				  -
    632  1e56				  -DebugKeyDone
    633  1e56				  -	      jsr	CRLF
    634  1e56				  -	      pla
    635  1e56				  -	      tay
    636  1e56				  -	      rts
    637  1e56				  -			;========================================
    638  1e56				  -DebugPrintOP
    639  1e56				  -	      pha
    640  1e56				  -	      lda	Operators,x
    641  1e56				  -	      jsr	VOUTCH
    642  1e56				  -	      lda	Operators+1,x
    643  1e56				  -	      beq	DbgPrtOpDone
    644  1e56				  -	      jsr	VOUTCH
    645  1e56				  -
    646  1e56				  -DbgPrtOpDone
    647  1e56				  -	      jsr	CRLF
    648  1e56				  -	      pla
    649  1e56				  -	      rts
    650  1e56				  -			;=======================================
    651  1e56				  -DebugClearBuffer
    652  1e56				  -	      txa
    653  1e56				  -	      pha
    654  1e56				  -	      ldx	#$FF
    655  1e56				  -	      lda	#0
    656  1e56				  -DebugClrLoop
    657  1e56				  -	      sta	TOKENBUFFER,x
    658  1e56				  -	      dex
    659  1e56				  -	      bne	DebugClrLoop
    660  1e56				  -	      sta	TOKENBUFFER,x
    661  1e56				  -	      pla
    662  1e56				  -	      tax
    663  1e56				  -	      rts
    664  1e56				  -
    665  1e56				  -			;=====================================================
    666  1e56				  -			; Print the parser buffer as hex values
    667  1e56				  -printTokenBuffer
    668  1e56				  -	      stx	printStorage
    669  1e56				  -	      sty	printStorage+1
    670  1e56				  -	      sta	printStorage+2
    671  1e56				  -
    672  1e56				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    673  1e56				  -	      inx		; we want to show the last zero byte
    674  1e56				  -	      ldy	#0
    675  1e56				  -
    676  1e56				  -printHexLoop
    677  1e56				  -	      lda	TOKENBUFFER,y	; get the character
    678  1e56				  -	      jsr	HexToOut	; print it
    679  1e56				  -	      lda	#$20
    680  1e56				  -	      jsr	VOUTCH
    681  1e56				  -	      iny
    682  1e56				  -	      dex
    683  1e56				  -	      cpx	#0
    684  1e56				  -	      bne	printHexLoop
    685  1e56				  -	      jsr	CRLF
    686  1e56				  -
    687  1e56				  -	      ldy	printStorage+1
    688  1e56				  -	      ldx	printStorage
    689  1e56				  -	      lda	printStorage+2
    690  1e56				  -printHexDone
    691  1e56				  -	      clc
    692  1e56				  -	      rts
    693  1e56					      endif
    694  1e56
    695  1e56
    696  1e56							;=========================================================================================================
    697  1e56							; Parse for variables A-Z @, ^  x!x x[op]
    698  1e56				   ParseForVariable
    699  1e56		       a4 51		      ldy	CUROFF
    700  1e58		       b9 a4 41 	      lda	LINBUF,y
    701  1e5b		       c9 5e		      cmp	#'^	; is it an exit code
    702  1e5d		       d0 04		      bne	ParseVarMem
    703  1e5f		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    704  1e61		       d0 1f		      bne	ParseVarSpecial
    705  1e63
    706  1e63				   ParseVarMem
    707  1e63		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    708  1e65		       d0 04		      bne	ParseVarStack
    709  1e67		       a9 9d		      lda	#tVat
    710  1e69		       d0 17		      bne	ParseVarSpecial
    711  1e6b
    712  1e6b				   ParseVarStack
    713  1e6b		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    714  1e6d		       d0 04		      bne	ParseVarLetters
    715  1e6f		       a9 9c		      lda	#tVhash
    716  1e71		       d0 0f		      bne	ParseVarSpecial
    717  1e73
    718  1e73				   ParseVarLetters
    719  1e73		       29 df		      and	#%11011111	; Force upper case
    720  1e75		       c9 41		      cmp	#'A
    721  1e77		       90 12		      bcc	ParseVarInvalid
    722  1e79		       c9 5b		      cmp	#'Z+1
    723  1e7b		       b0 0e		      bcs	ParseVarInvalid
    724  1e7d							;
    725  1e7d							; The condition is true, so convert to an index, push
    726  1e7d							; it onto the stack and continue running.
    727  1e7d							;
    728  1e7d		       38		      sec
    729  1e7e		       e9 41		      sbc	#'A	;index is zero based
    730  1e80		       09 80		      ora	#$80
    731  1e82
    732  1e82				   ParseVarSpecial
    733  1e82		       9d be 1b 	      sta	TOKENBUFFER,x
    734  1e85		       e8		      inx
    735  1e86		       c8		      iny
    736  1e87		       84 51		      sty	CUROFF
    737  1e89		       18		      clc
    738  1e8a		       60		      rts
    739  1e8b
    740  1e8b				   ParseVarInvalid
    741  1e8b		       38		      sec
    742  1e8c		       60		      rts
    743  1e8d
    744  1e8d
    745  1e8d							;=========================================================================================================
    746  1e8d							; Transfer R0 to the TOKENBUFFER
    747  1e8d							;
    748  1e8d				   R02TOKEN
    749  1e8d		       a5 52		      lda	R0
    750  1e8f		       9d be 1b 	      sta	TOKENBUFFER,x
    751  1e92		       e8		      inx
    752  1e93		       a5 53		      lda	R0+1
    753  1e95		       9d be 1b 	      sta	TOKENBUFFER,x
    754  1e98		       e8		      inx
    755  1e99		       18		      clc
    756  1e9a		       60		      rts
    757  1e9b							;=========================================================================
    758  1e9b							; Transfer word in Token Buffer to R0
    759  1e9b				   TOKEN2R0
    760  1e9b		       b9 be 1b 	      lda	TOKENBUFFER,y
    761  1e9e		       85 52		      sta	R0
    762  1ea0		       c8		      iny
    763  1ea1		       ca		      dex
    764  1ea2		       b9 be 1b 	      lda	TOKENBUFFER,y
    765  1ea5		       c8		      iny
    766  1ea6		       ca		      dex
    767  1ea7		       85 53		      sta	R0+1
    768  1ea9		       60		      rts
    769  1eaa							;==========================================================================
    770  1eaa							; Transfer	Display Buffer position to R0
    771  1eaa							;
    772  1eaa				   DPL2R0
    773  1eaa		       b1 59		      lda	(dpl),y
    774  1eac		       85 52		      sta	R0
    775  1eae		       c8		      iny
    776  1eaf		       ca		      dex
    777  1eb0		       b1 59		      lda	(dpl),y
    778  1eb2		       c8		      iny
    779  1eb3		       ca		      dex
    780  1eb4		       85 53		      sta	R0+1
    781  1eb6		       60		      rts
    782  1eb7
    783  1eb7
    784  1eb7							;=========================================================================
    785  1eb7							; Read an IL byte lookit up in the table, of words
    786  1eb7							; set the next ilpc to point to that address
    787  1eb7							; if not found then do ussual filter stuff
    788  1eb7							; ongoto ilvectortable, not found address
    789  1eb7		       20 5b 29    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    790  1eba		       86 52		      stx	R0
    791  1ebc		       85 53		      sta	R0+1
    792  1ebe
    793  1ebe		       a4 51		      ldy	CUROFF
    794  1ec0		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    795  1ec2		       a0 00		      ldy	#0
    796  1ec4		       38		      sec
    797  1ec5		       f1 52		      sbc	(R0),y	; Subract the base value
    798  1ec7		       c8		      iny
    799  1ec8		       d1 52		      cmp	(R0),y	; Check if we are in range
    800  1eca		       b0 12		      bcs	iOnGotoInvalid
    801  1ecc		       e6 51		      inc	CUROFF	; Save the offset
    802  1ece
    803  1ece		       0a		      asl
    804  1ecf		       a8		      tay		; Turn into vector
    805  1ed0		       c8		      iny		; Inc must include the table base and entry count
    806  1ed1		       c8		      iny
    807  1ed2
    808  1ed2		       b1 52		      lda	(R0),y
    809  1ed4		       85 43		      sta	ILPC
    810  1ed6		       c8		      iny
    811  1ed7		       b1 52		      lda	(R0),y
    812  1ed9		       85 44		      sta	ILPC+1
    813  1edb		       4c b1 02 	      jmp	NextIL
    814  1ede
    815  1ede				   iOnGotoInvalid
    816  1ede		       20 5b 29 	      jsr	getILWord
    817  1ee1		       86 43		      stx	ILPC
    818  1ee3		       85 44		      sta	ILPC+1
    819  1ee5		       4c b1 02 	      jmp	NextIL
    820  1ee8							;
    821  1ee8							;==========================================================================================
    822  1ee8							; Test the token for relop and push the value onto the stack if true
    823  1ee8							;
    824  1ee8				   iTSTRELOP
    825  1ee8		       20 5f 29 	      jsr	getILByte
    826  1eeb		       8d 39 42 	      sta	offset
    827  1eee
    828  1eee		       a4 51		      ldy	CUROFF
    829  1ef0		       b1 4f		      lda	(CURPTR),y
    830  1ef2		       48		      pha
    831  1ef3		       29 f0		      and	#$F0
    832  1ef5		       c9 f0		      cmp	#$F0
    833  1ef7		       d0 12		      bne	iTSTRELOPNOT
    834  1ef9		       68		      pla
    835  1efa		       29 0f		      and	#$0F	; get the actual value
    836  1efc		       85 52		      sta	R0	; save it for later
    837  1efe		       a9 00		      lda	#0
    838  1f00		       85 53		      sta	R0+1
    839  1f02		       20 58 2b 	      jsr	pushR0
    840  1f05		       c8		      iny
    841  1f06		       84 51		      sty	CUROFF	; save the y pointer
    842  1f08		       4c b1 02 	      jmp	NextIL
    843  1f0b
    844  1f0b				   iTSTRELOPNOT
    845  1f0b		       68		      pla
    846  1f0c		       4c db 0b 	      jmp	tstBranch
    847  1f0f
    848  1f0f							;
    849  1f0f							;===================================================================================================
    850  1f0f							; Test the token and following info for precompiled address information
    851  1f0f							; skip it if zero, transfer and skip next integer value if not zero
    852  1f0f							; used by both gosub, goto and gofN
    853  1f0f							;
    854  1f0f				   iTSTBRANCH
    855  1f0f		       20 5f 29 	      jsr	getILByte	; Get jump address if vector is valid
    856  1f12		       8d 39 42 	      sta	offset	; Mark offset for later if vector found
    857  1f15		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    858  1f17		       88		      dey		; point back to the type of branch
    859  1f18		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    860  1f1a		       48		      pha		; Save till needed
    861  1f1b		       c8		      iny		; back to memory vectors
    862  1f1c				   ITSTBRANCHCont
    863  1f1c		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    864  1f1e		       85 52		      sta	R0	; R0 will contain mem pointer of present
    865  1f20		       c8		      iny		; Point to next byte of mem vector
    866  1f21		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    867  1f23		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    868  1f25		       c8		      iny		; Point to the byte past memory vector
    869  1f26		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    870  1f28
    871  1f28		       05 52		      ora	R0	; Get the second byte of the mem
    872  1f2a		       f0 21		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    873  1f2c		       68		      pla
    874  1f2d		       c9 2f		      cmp	#kTask	; Task defied with Task() so bypass the first bracket
    875  1f2f		       d0 07		      bne	iTSTBRANCHCont
    876  1f31		       b1 4f		      lda	(CURPTR),y
    877  1f33		       c9 e0		      cmp	#oLeftBracket
    878  1f35		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    879  1f37		       c8		      iny		; Increment past the bracket
    880  1f38				   iTSTBRANCHCont
    881  1f38		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    882  1f3a		       c9 a2		      cmp	#tByte	; A byte value is valid
    883  1f3c		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    884  1f3e		       c9 a4		      cmp	#tInteger	; An integer value is valid
    885  1f40		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    886  1f42		       c8		      iny		; skip type indicator for
    887  1f43				   ITSTBRANCHBYTE
    888  1f43		       c8		      iny		; skip first byte of value line number
    889  1f44		       c8		      iny		; Skip second byte of line number
    890  1f45
    891  1f45				   iTSTBRANCHVALID
    892  1f45		       84 51		      sty	CUROFF
    893  1f47		       20 58 2b 	      jsr	pushR0	; place transfer address on top of stack
    894  1f4a		       4c db 0b 	      jmp	tstBranch
    895  1f4d
    896  1f4d				   iTSTBRANCHNoCompile
    897  1f4d		       68		      pla
    898  1f4e				   iTSTBRANCHErr
    899  1f4e		       4c b1 02 	      jmp	NextIL
    900  1f51
    901  1f51
    902  1f51
    903  1f51
    904  1f51
    905  1f51
    906  1f51
    907  1f51
    908  1f51
    909  1f51
------- FILE mytb.asm
------- FILE compile.asm LEVEL 2 PASS 6
      0  1f51					      include	"compile.asm"
      1  1f51					      Seg	Code
      2  1f51							;
      3  1f51							;=====================================================================
      4  1f51							; Scan the loaded program just before running and insert memory locations of each
      5  1f51							; line number branched to. goto gosub, gofn
      6  1f51							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value}
      7  1f51				   Compile
      8  1f51		       a9 00		      lda	#0
      9  1f53		       85 52		      sta	R0	; keep track of how many errors we find
     10  1f55		       a5 5b		      lda	RunMode
     11  1f57		       48		      pha
     12  1f58		       e6 5b		      inc	RunMode	; force run mode for error reporting
     13  1f5a		       a5 4f		      lda	CURPTR
     14  1f5c		       48		      pha
     15  1f5d		       a5 50		      lda	CURPTR+1
     16  1f5f		       48		      pha
     17  1f60		       a5 51		      lda	CUROFF
     18  1f62		       48		      pha
     19  1f63		       ad 3d 42 	      lda	ProgramStart
     20  1f66		       85 59		      sta	dpl
     21  1f68		       ad 3e 42 	      lda	ProgramStart+1
     22  1f6b		       85 5a		      sta	dpl+1
     23  1f6d
     24  1f6d				   CompileLineStart
     25  1f6d		       a5 59		      lda	dpl
     26  1f6f		       cd 3f 42 	      cmp	ProgramEnd
     27  1f72		       d0 07		      bne	CompileContinue
     28  1f74		       a5 5a		      lda	dpl+1
     29  1f76		       cd 40 42 	      cmp	ProgramEnd+1
     30  1f79		       f0 3f		      beq	CompileComplete
     31  1f7b
     32  1f7b				   CompileContinue
     33  1f7b		       a0 03		      ldy	#3	; first real character in the line
     34  1f7d
     35  1f7d				   CompileLoop
     36  1f7d		       b1 59		      lda	(dpl),y	; get the byte
     37  1f7f		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     38  1f81		       c8		      iny		; Pass this byte
     39  1f82		       c9 07		      cmp	#kGoto
     40  1f84		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     41  1f86		       c9 08		      cmp	#kGosub
     42  1f88		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     43  1f8a		       c9 37		      cmp	#kGofn
     44  1f8c		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  1f8e		       c9 2f		      cmp	#kTask
     46  1f90		       f0 4c		      beq	CompileField
     47  1f92		       c9 0a		      cmp	#kRem
     48  1f94		       f0 12		      beq	CompileRem	; Skip until end of line
     49  1f96		       c9 a0		      cmp	#tString
     50  1f98		       f0 2f		      beq	CompileString
     51  1f9a		       c9 a4		      cmp	#tInteger
     52  1f9c		       f0 06		      beq	CompileInteger
     53  1f9e		       c9 a2		      cmp	#tByte
     54  1fa0		       f0 03		      beq	CompileByte
     55  1fa2		       d0 d9		      bne	CompileLoop	; Next character
     56  1fa4
     57  1fa4				   CompileInteger
     58  1fa4		       c8		      iny
     59  1fa5				   CompileByte
     60  1fa5		       c8		      iny
     61  1fa6		       d0 d5		      bne	CompileLoop
     62  1fa8				   CompileRem
     63  1fa8				   CompileEndOfLine
     64  1fa8		       a0 00		      ldy	#0
     65  1faa		       b1 59		      lda	(dpl),y
     66  1fac		       18		      clc
     67  1fad		       65 59		      adc	dpl
     68  1faf		       85 59		      sta	dpl
     69  1fb1		       a9 00		      lda	#0
     70  1fb3		       65 5a		      adc	dpl+1
     71  1fb5		       85 5a		      sta	dpl+1
     72  1fb7
     73  1fb7		       4c 6d 1f 	      jmp	CompileLineStart
     74  1fba
     75  1fba				   CompileComplete
     76  1fba		       68		      pla
     77  1fbb		       85 51		      sta	CUROFF
     78  1fbd		       68		      pla
     79  1fbe		       85 50		      sta	CURPTR+1
     80  1fc0		       68		      pla
     81  1fc1		       85 4f		      sta	CURPTR
     82  1fc3		       68		      pla
     83  1fc4		       85 5b		      sta	RunMode
     84  1fc6		       a5 52		      lda	R0	; returning the number of errors
     85  1fc8		       60		      rts
     86  1fc9
     87  1fc9
     88  1fc9				   CompileString
     89  1fc9		       c8		      iny		; point past first "
     90  1fca				   CompileStringLoop
     91  1fca		       b1 59		      lda	(dpl),y
     92  1fcc		       f0 0d		      beq	CompileStrDone2	; end of line
     93  1fce		       c9 22		      cmp	#'"	; end of string
     94  1fd0		       f0 08		      beq	CompileStrDone
     95  1fd2		       c9 5c		      cmp	#'\	; escape character
     96  1fd4		       d0 01		      bne	CompileStrNext
     97  1fd6		       c8		      iny		; skip the escape character
     98  1fd7				   CompileStrNext
     99  1fd7		       c8		      iny		; Next character
    100  1fd8		       d0 f0		      bne	CompileStringLoop	; test for end
    101  1fda				   CompileStrDone
    102  1fda		       c8		      iny
    103  1fdb				   CompileStrDone2
    104  1fdb		       4c 7d 1f 	      Jmp	CompileLoop
    105  1fde							;
    106  1fde							;===============================================================
    107  1fde							; on entry y points to storage location y+2 points to line number
    108  1fde							; on exit y points to line number type
    109  1fde
    110  1fde		       85 52	   CompileField sta	R0
    111  1fe0		       98		      tya		; save the y pointer to store the memory value
    112  1fe1		       48		      pha
    113  1fe2		       c8		      iny		; Skip over the memory vector
    114  1fe3		       c8		      iny
    115  1fe4		       a5 52		      lda	R0
    116  1fe6		       c9 2f		      cmp	#kTask	; for a task it is the next byte after a bracket
    117  1fe8		       d0 07		      bne	CompNoBracket
    118  1fea
    119  1fea		       b1 59		      lda	(dpl),y	; Lets make sure it is a )
    120  1fec		       c9 e0		      cmp	#oLeftBracket
    121  1fee		       d0 01		      bne	CompNoBracket	; in case of error
    122  1ff0		       c8		      iny		; skip the bracket
    123  1ff1
    124  1ff1				   CompNoBracket
    125  1ff1		       a9 00		      lda	#0	; In case the value is a byte
    126  1ff3		       85 53		      sta	R0+1
    127  1ff5
    128  1ff5		       b1 59		      lda	(dpl),Y	; get the type of the next byte t something or other
    129  1ff7		       c9 a2		      cmp	#tByte
    130  1ff9		       f0 15		      beq	CompByteLoad
    131  1ffb		       c9 a4		      cmp	#tInteger
    132  1ffd		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    133  1fff		       68		      pla
    134  2000		       4c 7d 1f 	      jmp	CompileLoop	; Ignore the saved stack
    135  2003				   CompIntLoad
    136  2003		       c8		      iny
    137  2004		       b1 59		      lda	(dpl),y
    138  2006		       85 52		      sta	R0
    139  2008		       c8		      iny
    140  2009		       b1 59		      lda	(dpl),y
    141  200b		       85 53		      sta	R0+1
    142  200d		       4c 15 20 	      jmp	CompFindLine
    143  2010				   CompByteLoad
    144  2010		       c8		      iny
    145  2011		       b1 59		      lda	(dpl),y
    146  2013		       85 52		      sta	R0
    147  2015				   CompFindLine
    148  2015		       20 a4 29 	      jsr	findLine
    149  2018		       f0 1d		      beq	CompFoundLine
    150  201a		       e6 52		      inc	R0	; number of errors
    151  201c
    152  201c		       a5 59		      lda	dpl
    153  201e		       85 4f		      sta	CURPTR
    154  2020		       a5 5a		      lda	dpl+1
    155  2022		       85 50		      sta	CURPTR+1
    156  2024		       84 51		      sty	CUROFF
    157  2026
    158  2026		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    159  2028		       a9 00		      lda	#0
    160  202a
    161  202a		       20 27 06 	      jsr	DisplayError
    162  202d		       20 af 21 	      jsr	PrintProgramLine
    163  2030
    164  2030		       68		      pla
    165  2031		       a8		      tay
    166  2032		       c8		      iny
    167  2033		       c8		      iny
    168  2034		       4c 7d 1f 	      jmp	CompileLoop
    169  2037
    170  2037				   CompFoundLine
    171  2037		       68		      pla
    172  2038		       a8		      tay
    173  2039		       a5 4f		      lda	CURPTR
    174  203b		       91 59		      sta	(dpl),y
    175  203d		       c8		      iny
    176  203e		       a5 50		      lda	CURPTR+1
    177  2040		       91 59		      sta	(dpl),y
    178  2042		       c8		      iny
    179  2043		       4c 7d 1f 	      jmp	CompileLoop
    180  2046
    181  2046
    182  2046
    183  2046
    184  2046
    185  2046
    186  2046
    187  2046
    188  2046
    189  2046
    190  2046
    191  2046
    192  2046
    193  2046
    194  2046
    195  2046
    196  2046
    197  2046
    198  2046
    199  2046
    200  2046
    201  2046
    202  2046
    203  2046
    204  2046
    205  2046
    206  2046
    207  2046
    208  2046
    209  2046
    210  2046
    211  2046
    212  2046
    213  2046
    214  2046
    215  2046
    216  2046
    217  2046
    218  2046
    219  2046
    220  2046
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  2046					      include	"print.asm"
      1  2046					      Seg	Code
      2  2046							;---------------------------
      3  2046							; Print 24-bit decimal number or  16bit unsigned
      4  2046							; ---------------------------
      5  2046							; On entry, R0=number to print
      6  2046							;	     Defaults to pad=0 , y=21 default
      7  2046							;	     R2 = 1 unsigned 16 bit
      8  2046							;	     R2 = 0 Signed   16 bit
      9  2046
     10  2046							; On entry at PrintDecPadded:
     11  2046							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  2046
     13  2046							; On exit,  A,X,Y,num,pad corrupted
     14  2046							; Size      129 bytes, Table 24 bytes	--- total 153
     15  2046							; -----------------------------------------------------------------
     16  2046
     17  2046				   PrintDecimal
     18  2046		       8a		      TXA
     19  2047		       48		      pha
     20  2048		       98		      tya
     21  2049		       48		      pha
     22  204a		       a9 00		      lda	#0
     23  204c		       8d e1 20 	      sta	pad
     24  204f		       a0 15		      LDY	#21	; Offset to powers of ten
     25  2051		       4c 57 20 	      JMP	PrintDo
     26  2054
     27  2054				   PrintDecPadded
     28  2054		       8e e1 20 	      stx	pad
     29  2057
     30  2057				   PrintDo
     31  2057		       a9 00		      lda	#0
     32  2059		       85 54		      sta	R1
     33  205b
     34  205b		       a5 58		      lda	R2
     35  205d		       c9 a9		      cmp	#tUint
     36  205f		       f0 29		      beq	PrintPos
     37  2061
     38  2061		       a5 53		      lda	R0+1	;MSB has sign
     39  2063		       10 25		      bpl	PrintPos	;it's a positive number;
     40  2065
     41  2065
     42  2065							; Negative numbers need more work.  Invert all the bits,
     43  2065							; then add one.
     44  2065
     45  2065		       a9 2d		      lda	#'-
     46  2067		       20 e7 19 	      jsr	VOUTCH	;print the negative sign
     47  206a
     48  206a		       a9 ff		      lda	#$FF
     49  206c		       85 54		      sta	R1
     50  206e		       a5 52		      lda	R0	;invert bits
     51  2070		       49 ff		      eor	#$ff
     52  2072		       85 52		      sta	R0
     53  2074		       a5 53		      lda	R0+1
     54  2076		       49 ff		      eor	#$ff
     55  2078		       85 53		      sta	R0+1
     56  207a		       a5 54		      lda	R1
     57  207c		       49 ff		      eor	#$ff
     58  207e		       85 54		      sta	R1
     59  2080		       e6 52		      inc	R0	;add one
     60  2082		       d0 06		      bne	PrintPos
     61  2084		       e6 53		      inc	R0+1
     62  2086		       d0 02		      bne	PrintPos
     63  2088		       e6 54		      inc	R1
     64  208a				   PrintPos
     65  208a
     66  208a				   PrDec24Lp1
     67  208a		       a2 ff		      LDX	#$FF
     68  208c		       38		      SEC		; Start with digit=-1
     69  208d				   PrDec24Lp2
     70  208d		       a5 52		      LDA	R0+0
     71  208f		       f9 e2 20 	      SBC	PrDec24Tens+0,Y
     72  2092		       85 52		      STA	R0+0	; Subtract current tens
     73  2094		       a5 53		      LDA	R0+1
     74  2096		       f9 e3 20 	      SBC	PrDec24Tens+1,Y
     75  2099		       85 53		      STA	R0+1
     76  209b		       a5 54		      LDA	R0+2
     77  209d		       f9 e4 20 	      SBC	PrDec24Tens+2,Y
     78  20a0		       85 54		      STA	R0+2
     79  20a2		       e8		      INX
     80  20a3		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     81  20a5		       a5 52		      LDA	R0+0
     82  20a7		       79 e2 20 	      ADC	PrDec24Tens+0,Y
     83  20aa		       85 52		      STA	R0+0	; Add current tens back in
     84  20ac		       a5 53		      LDA	R0+1
     85  20ae		       79 e3 20 	      ADC	PrDec24Tens+1,Y
     86  20b1		       85 53		      STA	R0+1
     87  20b3		       a5 54		      LDA	R0+2
     88  20b5		       79 e4 20 	      ADC	PrDec24Tens+2,Y
     89  20b8		       85 54		      STA	R0+2
     90  20ba		       8a		      TXA
     91  20bb		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     92  20bd		       ad e1 20 	      LDA	pad
     93  20c0		       d0 09		      BNE	PrDec24Print
     94  20c2		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     95  20c4				   PrDec24Digit
     96  20c4		       a2 30		      LDX	#'0
     97  20c6		       8e e1 20 	      STX	pad	; No more zero padding
     98  20c9		       09 30		      ORA	#'0	; Print this digit
     99  20cb				   PrDec24Print
    100  20cb		       20 e7 19 	      JSR	VOUTCH
    101  20ce				   PrDec24Next
    102  20ce		       88		      DEY
    103  20cf		       88		      DEY
    104  20d0		       88		      DEY
    105  20d1		       f0 07		      beq	PrDec24LastDigit
    106  20d3		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    107  20d5		       68		      pla
    108  20d6		       a8		      tay
    109  20d7		       68		      pla
    110  20d8		       aa		      tax
    111  20d9		       60		      RTS
    112  20da				   PrDec24LastDigit
    113  20da		       a2 30		      LDX	#'0
    114  20dc		       8e e1 20 	      STX	pad	; No more zero padding
    115  20df		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    116  20e1
      0  20e1				   pad	      db	0
      1  20e1		       00		      .byte.b	0
    118  20e2
    119  20e2				   PrDec24Tens
      0  20e2					      dw	1
      1  20e2		       01 00		      .word.w	1
      0  20e4					      db	(1 / 65536)
      1  20e4		       00		      .byte.b	(1 / 65536)
      0  20e5					      dw	10
      1  20e5		       0a 00		      .word.w	10
      0  20e7					      db	(10 / 65536)
      1  20e7		       00		      .byte.b	(10 / 65536)
      0  20e8					      dw	100
      1  20e8		       64 00		      .word.w	100
      0  20ea					      db	(100 / 65536)
      1  20ea		       00		      .byte.b	(100 / 65536)
      0  20eb					      dw	1000
      1  20eb		       e8 03		      .word.w	1000
      0  20ed					      db	(1000 / 65536)
      1  20ed		       00		      .byte.b	(1000 / 65536)
      0  20ee					      dw	10000
      1  20ee		       10 27		      .word.w	10000
      0  20f0					      db	(10000 / 65536)
      1  20f0		       00		      .byte.b	(10000 / 65536)
      0  20f1					      dw	100000
      1  20f1		       a0 86		      .word.w	100000
      0  20f3					      db	(100000 / 65536)
      1  20f3		       01		      .byte.b	(100000 / 65536)
      0  20f4					      dw	1000000
      1  20f4		       40 42		      .word.w	1000000
      0  20f6					      db	(1000000 / 65536)
      1  20f6		       0f		      .byte.b	(1000000 / 65536)
      0  20f7					      dw	10000000
      1  20f7		       80 96		      .word.w	10000000
      0  20f9					      db	(10000000 / 65536)
      1  20f9		       98		      .byte.b	(10000000 / 65536)
    136  20fa							;=====================================================
    137  20fa							; Print character in A as two hex digits to the Console
    138  20fa
    139  20fa		       48	   HexToOut   pha		;save return value
    140  20fb		       48		      pha
    141  20fc		       4a		      lsr		;a  ;move top nibble to bottom
    142  20fd		       4a		      lsr		;a
    143  20fe		       4a		      lsr		;a
    144  20ff		       4a		      lsr		;a
    145  2100		       20 09 21 	      jsr	hexta	;output nibble
    146  2103		       68		      pla
    147  2104		       20 09 21 	      jsr	hexta
    148  2107		       68		      pla		;restore
    149  2108		       60		      rts
    150  2109							;
    151  2109		       29 0f	   hexta      and	#%0001111
    152  210b		       c9 0a		      cmp	#$0a
    153  210d		       18		      clc
    154  210e		       30 02		      bmi	hexta1
    155  2110		       69 07		      adc	#7
    156  2112		       69 30	   hexta1     adc	#'0	;then fall into...
    157  2114		       4c e7 19 	      jmp	VOUTCH
    158  2117							;
    159  2117							;=====================================================
    160  2117							; Print the string that immediately follows the JSR to
    161  2117							; this function.  Stops when a null byte is found,
    162  2117							; then returns to the instruction immediately
    163  2117							; following the null.
    164  2117							;
    165  2117							; Thanks to Ross Archer for this code.
    166  2117							; http://www.6502.org/source/io/primm.htm
    167  2117							;
    168  2117
    169  2117		       68	   tbputs     pla		;Get the low part of "return" address
    170  2118							;(data start address)
    171  2118		       85 5e		      sta	PrtFrom
    172  211a		       68		      pla
    173  211b		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    174  211d							;(data start address)
    175  211d							;Note: actually we're pointing one short
    176  211d		       a0 01	   PSINB      ldy	#1
    177  211f		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    178  2121		       e6 5e		      inc	PrtFrom	;update the pointer
    179  2123		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    180  2125		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    181  2127		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    182  2129							;   Accumulator
    183  2129		       f0 06		      beq	PSIX1	;don't print the final NULL
    184  212b		       20 e7 19 	      jsr	VOUTCH	;write it out
    185  212e		       4c 1d 21 	      jmp	PSINB	;back around
    186  2131		       e6 5e	   PSIX1      inc	PrtFrom
    187  2133		       d0 02		      bne	PSIX2
    188  2135		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    189  2137		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    190  213a
    191  213a							;+
    192  213a							;====================================================
    193  213a		       42 35	   PrtTerm    equ	tempy
    194  213a
    195  213a							; on exit Print Y has the offset to use
    196  213a							; input y =	 addr low
    197  213a							;	 x =	 addr high
    198  213a							;	 a =	 termination string
    199  213a
    200  213a
    201  213a				   PrtQuoted		; Print a quoted string from the current program space
    202  213a		       a9 22		      lda	#'"
    203  213c		       a4 51		      ldy	CUROFF
    204  213e		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    205  2140		       d0 03		      bne	PrtNoInc
    206  2142		       c8		      iny
    207  2143		       84 51		      sty	CUROFF
    208  2145				   PrtNoInc
    209  2145		       8d 35 42 	      sta	PrtTerm
    210  2148
    211  2148				   PrtPrgString 		; Print a terminated string from the static program space
    212  2148		       a4 51		      ldy	CUROFF
    213  214a		       a5 4f		      lda	CURPTR
    214  214c		       85 5e		      sta	PrtFrom
    215  214e		       a5 50		      lda	CURPTR+1
    216  2150		       85 5f		      sta	PrtFrom+1
    217  2152		       4c 5e 21 	      jmp	PrtLoop
    218  2155
    219  2155							; Print a string pointed to by x= h, y=l terminated by value in  accumulator
    220  2155							; Return y as the length
    221  2155
    222  2155		       86 5f	   PrtStr     stx	PrtFrom+1
    223  2157		       84 5e		      sty	PrtFrom
    224  2159		       8d 35 42 	      sta	PrtTerm
    225  215c		       a0 00		      ldy	#0
    226  215e							;
    227  215e							; On entry here ptrfrom and prtterm point to area to print
    228  215e							;
    229  215e		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    230  2160		       cd 35 42 	      cmp	PrtTerm
    231  2163		       f0 0b		      beq	PrtEnd
    232  2165		       c9 00		      cmp	#0	; always end if 0 is found
    233  2167		       f0 07		      beq	PrtEnd
    234  2169		       20 e7 19 	      jsr	VOUTCH
    235  216c		       c8		      iny
    236  216d		       4c 5e 21 	      jmp	PrtLoop
    237  2170		       c8	   PrtEnd     iny		;return byte after the write
    238  2171		       60		      rts
    239  2172
    240  2172							;
    241  2172							;=======================================================
    242  2172							; Print all Variables
    243  2172				   PrintAllVars
    244  2172		       a0 00		      ldy	#0
    245  2174		       a9 41		      lda	#'A
    246  2176				   PrintAllVarsLoop
    247  2176		       48		      pha
    248  2177		       b1 41		      lda	(VARIABLES),y
    249  2179		       85 52		      sta	R0
    250  217b		       c8		      iny
    251  217c		       b1 41		      lda	(VARIABLES),y
    252  217e		       85 53		      sta	R0+1
    253  2180
    254  2180		       68		      pla		;get the current letter
    255  2181		       48		      pha
    256  2182		       20 e7 19 	      jsr	VOUTCH
    257  2185		       20 17 21 	      jsr	puts
      0  2188					      db	"=",0
      1  2188		       3d 00		      .byte.b	"=",0
    259  218a		       68		      pla
    260  218b		       aa		      tax
    261  218c		       e8		      inx
    262  218d		       8a		      txa
    263  218e		       48		      pha		;
    264  218f
    265  218f		       98		      tya
    266  2190		       48		      pha
    267  2191		       20 46 20 	      jsr	PrintDecimal
    268  2194		       20 17 21 	      jsr	puts
      0  2197					      db	" ",0
      1  2197		       20 00		      .byte.b	" ",0
    270  2199		       68		      pla
    271  219a		       a8		      tay
    272  219b		       c8		      iny
    273  219c		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    274  219e		       90 d6		      bcc	PrintAllVarsLoop
    275  21a0		       20 a3 2c 	      jsr	CRLF
    276  21a3
    277  21a3		       68		      pla
    278  21a4		       60		      rts
    279  21a5							;==========================================================================================================
    280  21a5							;Debug   Print a Program Line from compile buffer
    281  21a5							;
    282  21a5				   DebugPrintProgramLine
    283  21a5		       48		      pha
    284  21a6		       a9 be		      lda	#TOKENBUFFER&$FF
    285  21a8		       85 59		      sta	dpl
    286  21aa		       a9 1b		      lda	#TOKENBUFFER>>8
    287  21ac		       85 5a		      sta	dpl+1
    288  21ae		       68		      pla
    289  21af
    290  21af							; Decode and print a line of program text
    291  21af							; on entry	 dpl points to line of code to print
    292  21af							; on exit	 no change in reg or dpl
    293  21af							;
    294  21af				   PrintProgramLine
    295  21af
    296  21af		       8e be 1c 	      stx	printStorage
    297  21b2		       8c bf 1c 	      sty	printStorage+1
    298  21b5		       48		      pha
    299  21b6
    300  21b6		       a0 01		      ldy	#1	; index into the token buffer
    301  21b8		       84 58		      sty	R2	; print unsigned decimal
    302  21ba		       a0 00		      ldy	#0
    303  21bc		       b1 59		      lda	(dpl),y	; get number of bytes
    304  21be		       aa		      tax		; place pointer into x
    305  21bf		       c8		      iny
    306  21c0		       ca		      dex		; Deduct the length byte
    307  21c1		       20 aa 1e 	      jsr	DPL2R0	; Print the line number
    308  21c4		       20 46 20 	      jsr	PrintDecimal
    309  21c7		       a9 20		      lda	#$20
    310  21c9		       20 e7 19 	      jsr	VOUTCH
    311  21cc
    312  21cc				   PrintProgLoop
    313  21cc		       b1 59		      lda	(dpl),y	; Get a character
    314  21ce		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    315  21d0		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    316  21d2		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    317  21d4
    318  21d4				   PrintProgVars
    319  21d4		       b1 59		      lda	(dpl),y
    320  21d6		       29 e0		      and	#$E0	; Check for operators and punctuation
    321  21d8		       c9 e0		      cmp	#$E0
    322  21da		       f0 6b		      beq	PrintProgOperatorVect
    323  21dc
    324  21dc		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    325  21de		       c9 9e		      cmp	#$9D+1
    326  21e0		       90 62		      bcc	PrintProgVariableVec
    327  21e2		       29 a0		      and	#$A0	; Check for a valid datatype
    328  21e4		       c9 a0		      cmp	#$A0
    329  21e6		       f0 06		      beq	PrintDataType	; if not just print the character
    330  21e8		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    331  21ea		       ca		      dex		; Ok we are processing it
    332  21eb		       c8		      iny
    333  21ec		       d0 25		      bne	PrintContinue	; Print and do the next character
    334  21ee
    335  21ee				   PrintDataType
    336  21ee		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    337  21f0		       c9 a0		      cmp	#tString
    338  21f2		       f0 31		      beq	PrintStringVariable
    339  21f4
    340  21f4				   PrintProgNumber
    341  21f4		       c8		      iny		; we have a numerical integer value
    342  21f5		       ca		      dex
    343  21f6		       48		      pha
    344  21f7		       a9 00		      lda	#0
    345  21f9		       85 53		      sta	R0+1
    346  21fb		       85 58		      sta	R2	; Set to print signed number
    347  21fd		       b1 59		      lda	(dpl),y
    348  21ff		       85 52		      sta	R0
    349  2201		       68		      pla
    350  2202		       c9 a4		      cmp	#tInteger
    351  2204		       d0 06		      bne	PrintProgNumDone
    352  2206		       c8		      iny
    353  2207		       ca		      dex
    354  2208		       b1 59		      lda	(dpl),y
    355  220a		       85 53		      sta	R0+1
    356  220c
    357  220c				   PrintProgNumDone
    358  220c		       c8		      iny
    359  220d		       ca		      dex
    360  220e		       20 46 20 	      jsr	PrintDecimal
    361  2211
    362  2211				   PrintProgNext
    363  2211		       a9 20		      lda	#$20
    364  2213				   PrintContinue
    365  2213		       20 e7 19 	      jsr	VOUTCH
    366  2216				   PrintProgSkipSpace
    367  2216		       e0 00		      cpx	#0
    368  2218		       d0 b2		      bne	PrintProgLoop
    369  221a				   PrintProgramComplete
    370  221a		       20 a3 2c 	      jsr	CRLF
    371  221d
    372  221d		       ae be 1c 	      ldx	printStorage
    373  2220		       ac bf 1c 	      ldy	printStorage+1
    374  2223		       68		      pla
    375  2224
    376  2224		       60		      rts
    377  2225							;=================================================================================================================
    378  2225							; Print a string variable including the quotes
    379  2225							; On Input	 y is offset into buffer
    380  2225							; On Exit	 y is updated to new offset
    381  2225
    382  2225				   PrintStringVariable
    383  2225		       c8		      iny
    384  2226		       a9 22		      lda	#'"
    385  2228		       20 e7 19 	      jsr	VOUTCH
    386  222b		       c8		      iny
    387  222c		       a5 59		      lda	dpl
    388  222e		       85 5e		      sta	PrtFrom
    389  2230		       a5 5a		      lda	dpl+1
    390  2232		       85 5f		      sta	PrtFrom+1
    391  2234		       a9 22		      lda	#'"
    392  2236		       8d 35 42 	      sta	PrtTerm
    393  2239		       20 5e 21 	      jsr	PrtLoop
    394  223c		       a9 22		      lda	#'"
    395  223e		       20 e7 19 	      jsr	VOUTCH
    396  2241		       4c 11 22 	      jmp	PrintProgNext
    397  2244
    398  2244				   PrintProgVariableVec
    399  2244		       4c e4 22 	      jmp	PrintProgVariable
    400  2247
    401  2247				   PrintProgOperatorVect
    402  2247		       4c bb 22 	      jmp	PrintProgOperator
    403  224a							;===============================================================================================================
    404  224a							; On entry dpl points to the buffer we are printing from
    405  224a							;	    y	current offset into the dpl buffer
    406  224a							; all registers preserved
    407  224a							;
    408  224a				   PrintKeyword
    409  224a
    410  224a		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    411  224c		       85 52		      sta	R0	; The value we are looking for
    412  224e		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    413  2250		       f0 0c		      beq	PrintKeyBranch
    414  2252		       c9 08		      cmp	#kGosub
    415  2254		       f0 08		      beq	PrintKeyBranch
    416  2256		       c9 2f		      cmp	#kTask
    417  2258		       f0 04		      beq	PrintKeyBranch
    418  225a		       c9 37		      cmp	#kGofn
    419  225c		       d0 04		      bne	PrintKeySkipped
    420  225e				   PrintKeyBranch
    421  225e		       c8		      iny		; Skip the compiled memory address
    422  225f		       c8		      iny
    423  2260		       ca		      dex		; Change number of bytes to print
    424  2261		       ca		      dex		; Remove the bytes to print
    425  2262
    426  2262				   PrintKeySkipped
    427  2262		       c8		      iny		; Inc y to point to the next char to be printed
    428  2263		       ca		      dex		; Reduce number of bytes to print
    429  2264		       98		      tya		; Save y and x for the return
    430  2265		       48		      pha
    431  2266		       8a		      txa
    432  2267		       48		      pha
    433  2268
    434  2268		       a9 87		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    435  226a		       85 54		      sta	R1
    436  226c		       a9 1a		      lda	#KeyWordTable>>8
    437  226e		       85 55		      sta	R1+1
    438  2270
    439  2270
    440  2270				   PrintKeyLoop
    441  2270		       a0 00		      ldy	#0	; Index into the keyword entry
    442  2272		       b1 54		      lda	(R1),y	; Get token value for this entry
    443  2274		       c8		      iny		; Point to first byte of key
    444  2275		       c5 52		      cmp	R0	; Compare to the token we are looking for
    445  2277		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    446  2279
    447  2279				   PrintKeyNext
    448  2279		       b1 54		      lda	(R1),y	; Get key letter
    449  227b		       c8		      iny		; Point to next byte always
    450  227c		       29 20		      and	#%00100000	; Check for last character in key work
    451  227e		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    452  2280
    453  2280		       98		      tya		; Trabsfer y to a for the addition
    454  2281		       18		      clc		; Table > 256 bytes
    455  2282		       65 54		      adc	R1
    456  2284		       85 54		      sta	R1
    457  2286		       a9 00		      lda	#0
    458  2288		       65 55		      adc	R1+1
    459  228a		       85 55		      sta	R1+1
    460  228c		       4c 70 22 	      jmp	PrintKeyLoop
    461  228f
    462  228f				   PrintKeyFound
    463  228f		       b1 54		      lda	(R1),y	; letter from key table
    464  2291		       48		      pha		; Save it for later check
    465  2292		       09 20		      ora	#%00100000	; Force it to lower case
    466  2294		       20 e7 19 	      jsr	VOUTCH	; Print it out
    467  2297		       c8		      iny		; Point to next character
    468  2298		       68		      pla		; Restore the value
    469  2299		       29 20		      and	#%00100000	; Check if it was last char in keyword
    470  229b		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    471  229d
    472  229d		       68		      pla		; Restore the x and y values
    473  229e		       aa		      tax
    474  229f		       68		      pla
    475  22a0		       a8		      tay
    476  22a1
    477  22a1				   PrintChkRem
    478  22a1		       a9 0a		      lda	#kRem
    479  22a3		       c5 52		      cmp	R0
    480  22a5		       d0 11		      bne	PrintKeyDone
    481  22a7				   PrintKeyRem
    482  22a7		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    483  22a9		       85 5e		      sta	PrtFrom
    484  22ab		       a5 5a		      lda	dpl+1
    485  22ad		       85 5f		      sta	PrtFrom+1
    486  22af		       a9 00		      lda	#0
    487  22b1		       8d 35 42 	      sta	PrtTerm
    488  22b4		       20 5e 21 	      jsr	PrtLoop
    489  22b7		       88		      dey		; point back to the terminating null value
    490  22b8				   PrintKeyDone
    491  22b8		       4c 11 22 	      jmp	PrintProgNext
    492  22bb							;==================================================================================================================
    493  22bb							;Print Variable, number or operator
    494  22bb				   PrintProgOperator
    495  22bb		       b1 59		      lda	(dpl),y
    496  22bd		       c8		      iny
    497  22be		       ca		      dex
    498  22bf		       8e c0 1c 	      stx	printStorage+2
    499  22c2		       a2 00		      ldx	#0
    500  22c4				   PrintOprLoop
    501  22c4		       dd 71 1a 	      cmp	OperValues,x
    502  22c7		       f0 03		      beq	PrintOprFound
    503  22c9		       e8		      inx
    504  22ca		       d0 f8		      bne	PrintOprLoop
    505  22cc				   PrintOprFound
    506  22cc		       8a		      txa
    507  22cd		       0a		      asl
    508  22ce		       aa		      tax
    509  22cf		       bd 43 1a 	      lda	Operators,x
    510  22d2		       20 e7 19 	      jsr	VOUTCH
    511  22d5		       e8		      inx
    512  22d6		       bd 43 1a 	      lda	Operators,x
    513  22d9		       f0 03		      beq	PrintOprDone
    514  22db		       20 e7 19 	      jsr	VOUTCH
    515  22de				   PrintOprDone
    516  22de		       ae c0 1c 	      ldx	printStorage+2
    517  22e1		       4c 11 22 	      jmp	PrintProgNext
    518  22e4
    519  22e4							;=================================================================================================================
    520  22e4							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    521  22e4							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    522  22e4							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    523  22e4							;tVhat 	    equ     155 		   ; Variable ^
    524  22e4							;tVhash	    equ     156 		   ; Variable #
    525  22e4							;tVat		    equ     157 		   ; Variable @ = 0
    526  22e4				   PrintProgVariable
    527  22e4		       b1 59		      lda	(dpl),y
    528  22e6		       c8		      iny
    529  22e7		       ca		      dex
    530  22e8		       c9 9b		      cmp	#tVhat
    531  22ea		       d0 04		      bne	PrintProgChkHash
    532  22ec		       a9 5e		      lda	#'^
    533  22ee		       d0 15		      bne	PrintTheVar
    534  22f0				   PrintProgChkHash
    535  22f0		       c9 9c		      cmp	#tVhash
    536  22f2		       d0 04		      bne	PrintProgChkAt
    537  22f4		       a9 23		      lda	#'#
    538  22f6		       d0 0d		      bne	PrintTheVar
    539  22f8				   PrintProgChkAt
    540  22f8		       c9 9d		      cmp	#tVat
    541  22fa		       d0 04		      bne	PrintProgVarLetter
    542  22fc		       a9 40		      lda	#'@
    543  22fe		       d0 05		      bne	PrintTheVar
    544  2300				   PrintProgVarLetter
    545  2300		       29 7f		      and	#%01111111
    546  2302		       18		      clc
    547  2303		       69 41		      adc	#'A
    548  2305				   PrintTheVar
    549  2305		       20 e7 19 	      jsr	VOUTCH
    550  2308		       4c 11 22 	      jmp	PrintProgNext
    551  230b
    552  230b
    553  230b							;==================================================================================================
    554  230b							; Size of print functions
    555  230b		       02 c5	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  230b					      include	"mem.asm"
      1  230b							;===================================================================
      2  230b							;This file contains the memory allocation and free functions
      3  230b							;in herant in this is the management of free memory in the system
      4  230b							; the interface to these functions
      5  230b							; a,x returns or provides the low hi bytes of the managed addresses
      6  230b							; This uses the programend, to memory end as the area to manage
      7  230b							;===================================================================
      8 U3580					      Seg.u	TBData
      9 U3580							;
     10 U3580							;=====================================================
     11 U3580							;Pointers for memory Management
     12 U3580							;Allocated block are not chained but can be followed for all memory by the associated length
     13 U3580							; Mem block format is
     14 U3580							;	 0-1   pointer to next block for free blocks
     15 U3580							;	 0-1   for allocated blocks
     16 U3580							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     17 U3580							;	   1   refrence counter ... lol only up to 256 but it is something
     18 U3580							;	 2-3   length constant for exevy type of memory block
     19 U3580							; Memory is recombined as it is released
     20 U3580							; The memory manager is not interupted durring allocation
     21 U3580							; or freeing of memory
     22 U3580							;====================================================
     23 U3580		       00 00	   MemFreeList ds	2	; list of free blocks of memory
     24 U3582		       00 00	   MemR0      ds	2	; source for copy/move/Init
     25 U3584		       00 00	   MemR1      ds	2	; Destination for copy/move
     26 U3586							;=====================================================
     27  230b					      Seg	Code
     28  230b							;=====================================================
     29  230b				   MemInit
     30  230b		       a9 47		      lda	#FreeMemStart&$FF
     31  230d		       8d 3d 42 	      sta	ProgramStart
     32  2310		       8d 3f 42 	      sta	ProgramEnd
     33  2313		       a9 42		      lda	#FreeMemStart>>8
     34  2315		       8d 3e 42 	      sta	ProgramStart+1
     35  2318		       8d 40 42 	      sta	ProgramEnd+1
     36  231b
     37  231b		       20 25 23 	      jsr	GetSizes
     38  231e		       20 30 23 	      jsr	MemFree
     39  2321		       20 48 23 	      jsr	MemUsed
     40  2324				   MemInitEnd
     41  2324		       60		      rts
     42  2325
     43  2325
     44  2325							;
     45  2325							;=====================================================
     46  2325							; This function might go away eventually, but was
     47  2325							; added to provide data for other pieces of code.
     48  2325							; It has some ties to the operating environment that
     49  2325							; will need to be customized for the target system.
     50  2325							;
     51  2325				   GetSizes
     52  2325							;
     53  2325							; Here is machine specific code to get the highest
     54  2325							; memory location that can be used by BASIC.
     55  2325							;
     56  2325				  -	      if	ProgramStart < $2000
     57  2325				  -	      lda	#$ff
     58  2325				  -	      sta	HighMem	;$13ff for KIM-1
     59  2325				  -	      sta	MemFreeList
     60  2325				  -	      lda	#$DE	;#$13
     61  2325				  -	      sta	HighMem+1
     62  2325				  -	      sta	MemFreeList+1
     63  2325					      else
     64  2325		       a9 ff		      lda	#$ff
     65  2327		       8d 41 42 	      sta	HighMem	;$CFFF otherwise
     66  232a		       a9 cf		      lda	#$cf
     67  232c		       8d 42 42 	      sta	HighMem+1
     68  232f					      endif
     69  232f		       60		      rts
     70  2330							;
     71  2330							; This computes the available memory remaining.
     72  2330							;
     73  2330				   MemFree
     74  2330		       38		      sec
     75  2331		       ad 41 42 	      lda	HighMem
     76  2334		       ed 3f 42 	      sbc	ProgramEnd
     77  2337		       8d 45 42 	      sta	FreeMem
     78  233a		       85 52		      sta	R0
     79  233c		       ad 42 42 	      lda	HighMem+1
     80  233f		       ed 40 42 	      sbc	ProgramEnd+1
     81  2342		       8d 46 42 	      sta	FreeMem+1
     82  2345		       85 53		      sta	R0+1
     83  2347		       60		      rts
     84  2348							;
     85  2348							; This computes the size of the current user program.
     86  2348							;
     87  2348				   MemUsed
     88  2348		       38		      sec
     89  2349		       ad 3f 42 	      lda	ProgramEnd
     90  234c		       ed 3d 42 	      sbc	ProgramStart
     91  234f		       8d 43 42 	      sta	UsedMem
     92  2352		       85 52		      sta	R0
     93  2354		       ad 40 42 	      lda	ProgramEnd+1
     94  2357		       ed 3e 42 	      sbc	ProgramStart+1
     95  235a		       8d 44 42 	      sta	UsedMem+1
     96  235d		       85 53		      sta	R0+1
     97  235f							;
     98  235f		       60		      rts
     99  2360							;
    100  2360							;=====================================================
    101  2360							; Set a block of memory to a value
    102  2360		       8a	   iSetBlock  txa
    103  2361		       48		      pha
    104  2362		       98		      tya
    105  2363		       48		      pha
    106  2364		       20 ea 2b 	      jsr	popR0	; the address to write to
    107  2367		       a5 52		      lda	R0
    108  2369		       85 59		      sta	dpl
    109  236b		       a5 53		      lda	R0+1
    110  236d		       85 5a		      sta	dpl+1
    111  236f		       20 02 2c 	      jsr	popR1	; Number of bytes to write
    112  2372		       20 ea 2b 	      jsr	popR0	; Get the value to store into memory
    113  2375		       20 5f 29 	      jsr	getILByte
    114  2378		       85 58		      sta	R2	; store the data type into R2
    115  237a		       c9 a4		      cmp	#tInteger
    116  237c		       f0 08		      beq	memset	; skip this if we have an integer
    117  237e		       a5 52		      lda	R0	; Revers the order so they can be copied in correct order
    118  2380		       a6 53		      ldx	R0+1
    119  2382		       86 52		      stx	R0
    120  2384		       85 53		      sta	R0+1
    121  2386
    122  2386				   memset
    123  2386		       a0 00		      ldy	#0	; Set for length of block to copy
    124  2388		       a2 00		      ldx	#0	; set for number of block of 256 to copy
    125  238a
    126  238a		       a5 58	   iSetBlockLoop lda	R2	; Get Datatype
    127  238c		       c9 a2		      cmp	#tByte
    128  238e		       f0 09		      beq	iSetBlockB
    129  2390
    130  2390		       a5 52	   iSetBlockW lda	R0
    131  2392		       91 59		      sta	(dpl),y
    132  2394		       20 a9 23 	      jsr	iSetBlockEnd
    133  2397		       f0 09		      beq	iSetBlockComplete
    134  2399
    135  2399		       a5 53	   iSetBlockB lda	R0+1
    136  239b		       91 59		      sta	(dpl),y
    137  239d		       20 a9 23 	      jsr	iSetBlockEnd
    138  23a0		       d0 e8		      bne	iSetBlockLoop
    139  23a2
    140  23a2				   iSetBlockComplete
    141  23a2		       68		      pla
    142  23a3		       a8		      tay
    143  23a4		       68		      pla
    144  23a5		       aa		      tax
    145  23a6		       4c b1 02 	      jmp	NextIL
    146  23a9							;
    147  23a9							; Check if we have reached the end of the initialization/Copy
    148  23a9							;
    149  23a9		       c8	   iSetBlockEnd iny
    150  23aa		       d0 03		      bne	iSetBlockEndChk
    151  23ac		       e8		      inx
    152  23ad		       e6 5a		      inc	dpl+1
    153  23af				   iSetBlockEndChk
    154  23af		       c4 54		      cpy	R1
    155  23b1		       d0 02		      bne	iSetBlockEndExit
    156  23b3		       e4 55		      cpx	R1+1
    157  23b5				   iSetBlockEndExit
    158  23b5		       60		      rts
    159  23b6							;
    160  23b6							;================================================================
    161  23b6							; Copy a block of memory from one location to another
    162  23b6							;
    163  23b6		       8a	   iCopyBlock txa
    164  23b7		       48		      pha
    165  23b8		       98		      tya
    166  23b9		       48		      pha
    167  23ba		       20 ea 2b 	      jsr	popR0	; get the source address
    168  23bd		       20 02 2c 	      jsr	popR1	; Destination address
    169  23c0		       a5 54		      lda	R1
    170  23c2		       85 59		      sta	dpl
    171  23c4		       a5 55		      lda	R1+1
    172  23c6		       85 5a		      sta	dpl+1
    173  23c8		       20 02 2c 	      jsr	popR1	; Number of bytes to copy
    174  23cb				   memcpy
    175  23cb		       a2 00		      ldx	#0
    176  23cd		       a0 00		      ldy	#0
    177  23cf				   iCopyBlockLoop
    178  23cf		       b1 52		      lda	(R0),y	;  Get the byte to copy
    179  23d1		       91 59		      sta	(dpl),y	;  Store the byte
    180  23d3		       c8		      iny
    181  23d4		       d0 05		      bne	iCopyChkEnd
    182  23d6		       e8		      inx
    183  23d7		       e6 53		      inc	R0+1
    184  23d9		       e6 5a		      inc	dpl+1
    185  23db		       c4 54	   iCopyChkEnd cpy	R1
    186  23dd		       d0 f0		      bne	iCopyBlockLoop
    187  23df		       e4 55		      cpx	R1+1
    188  23e1		       d0 ec		      bne	iCopyBlockLoop
    189  23e3				   iCopyBlockDone
    190  23e3		       68		      pla
    191  23e4		       a8		      tay
    192  23e5		       68		      pla
    193  23e6		       aa		      tax
    194  23e7		       4c b1 02 	      jmp	NextIL
    195  23ea							;
    196  23ea							;=============================================================================
    197  23ea							; Compare memory block location
    198  23ea							; returns on the stack
    199  23ea							; 0 - equals
    200  23ea							; -1 - s1  <  s2
    201  23ea							; 1   s1  >  s2
    202  23ea		       8a	   iCmpBlock  txa
    203  23eb		       48		      pha
    204  23ec		       98		      tya
    205  23ed		       48		      pha
    206  23ee		       20 02 2c 	      jsr	popR1	; Get the Source 2 pointer
    207  23f1		       a5 54		      lda	R1
    208  23f3		       85 59		      sta	dpl	; store the secon source in dpl
    209  23f5		       a5 55		      lda	R1+1
    210  23f7		       85 5a		      sta	dpl+1
    211  23f9		       20 ea 2b 	      jsr	popR0	; Get the Source 1 pointer
    212  23fc		       20 02 2c 	      jsr	popR1	; Get the length of the compare to do
    213  23ff		       a0 00		      ldy	#0
    214  2401		       a2 00		      ldx	#0
    215  2403		       4c 10 24 	      jmp	iCmpCheckEnd
    216  2406
    217  2406		       b1 59	   iCmpLoop   lda	(dpl),y
    218  2408		       d1 52		      cmp	(R0),y
    219  240a		       d0 19		      bne	iCmpDone
    220  240c		       c8		      iny
    221  240d		       d0 01		      bne	iCmpCheckEnd
    222  240f		       e8		      inx
    223  2410				   iCmpCheckEnd
    224  2410		       c4 54		      cpy	R1
    225  2412		       d0 f2		      bne	iCmpLoop
    226  2414		       e4 55		      cpx	R1+1
    227  2416		       d0 ee		      bne	iCmpLoop
    228  2418		       a5 00		      lda	0
    229  241a		       85 53		      sta	R0+1
    230  241c		       85 52		      sta	R0
    231  241e				   iCmpReturn
    232  241e		       68		      pla
    233  241f		       a8		      tay
    234  2420		       68		      pla
    235  2421		       aa		      tax
    236  2422		       4c 16 07 	      jmp	pushR0nextIl
    237  2425
    238  2425				   iCmpDone
    239  2425		       90 0a		      bcc	iCmpGreater
    240  2427				   iCmpLess
    241  2427		       a9 00		      lda	#0
    242  2429		       85 53		      sta	R0+1
    243  242b		       a9 01		      lda	#1
    244  242d		       85 52		      sta	R0
    245  242f		       d0 ed		      bne	iCmpReturn
    246  2431				   iCmpGreater
    247  2431		       a9 ff		      lda	#-1
    248  2433		       85 52		      sta	R0
    249  2435		       85 53		      sta	R0+1
    250  2437		       d0 e5		      bne	iCmpReturn
    251  2439
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  2439					      include	"gosub.asm"
      1  2439					      seg	Code
      2  2439
      3  2439							; Gosub and return related functions
      4  2439							;==========================================================
      5  2439							; Push the current math stack frame onto the gosub stack
      6  2439				   iPushMathStack
      7  2439		       98		      tya
      8  243a		       48		      pha
      9  243b		       a4 4d		      ldy	GOSUBSTACKPTR
     10  243d		       a5 4a		      lda	MATHSTACKPTR
     11  243f		       91 4b		      sta	(GOSUBSTACK),y
     12  2441		       a9 00		      lda	#0
     13  2443		       c8		      iny
     14  2444		       91 4b		      sta	(GOSUBSTACK),y
     15  2446		       c8		      iny
     16  2447		       91 4b		      sta	(GOSUBSTACK),y
     17  2449		       c8		      iny
     18  244a		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  244c		       91 4b		      sta	(GOSUBSTACK),y
     20  244e		       c8		      iny
     21  244f		       84 4d		      sty	GOSUBSTACKPTR
     22  2451		       68		      pla
     23  2452		       a8		      tay
     24  2453		       4c b1 02 	      jmp	NextIL
     25  2456							;
     26  2456							;==========================================================
     27  2456							; Increment parameter count. Assume Stack frame is top of stack
     28  2456				   iIncParmCount
     29  2456		       98		      tya
     30  2457		       48		      pha
     31  2458
     32  2458		       a4 4d		      ldy	GOSUBSTACKPTR
     33  245a		       88		      dey
     34  245b		       88		      dey
     35  245c		       88		      dey
     36  245d		       b1 4b		      lda	(GOSUBSTACK),y
     37  245f		       18		      clc
     38  2460		       69 01		      adc	#1
     39  2462		       91 4b		      sta	(GOSUBSTACK),y
     40  2464
     41  2464		       68		      pla
     42  2465		       a8		      tay
     43  2466		       4c b1 02 	      jmp	NextIL
     44  2469							;
     45  2469							;==========================================================
     46  2469							;Restore the math stack frame
     47  2469		       20 6f 24    iPopMathStack jsr	PopMathStackNow
     48  246c		       4c b1 02 	      jmp	NextIL
     49  246f
     50  246f				   PopMathStackNow
     51  246f		       98		      tya
     52  2470		       48		      pha
     53  2471
     54  2471		       a4 4d		      ldy	GOSUBSTACKPTR
     55  2473		       88		      dey
     56  2474		       b1 4b		      lda	(GOSUBSTACK),y
     57  2476		       c9 05		      cmp	#GOSUB_STACK_FRAME
     58  2478		       d0 09		      bne	iPopMathStackNoFrame
     59  247a		       88		      dey
     60  247b		       88		      dey
     61  247c		       88		      dey
     62  247d		       b1 4b		      lda	(GOSUBSTACK),y
     63  247f		       85 4a		      sta	MATHSTACKPTR
     64  2481		       84 4d		      sty	GOSUBSTACKPTR
     65  2483
     66  2483				   iPopMathStackNoFrame
     67  2483
     68  2483		       68		      pla
     69  2484		       a8		      tay
     70  2485		       60		      rts
     71  2486
     72  2486
     73  2486							;==========================================================
     74  2486							; Push the current math stack information onto the gosub stack
     75  2486				   iSaveMathStack
     76  2486		       98		      tya
     77  2487		       48		      pha
     78  2488
     79  2488		       a4 4d		      ldy	GOSUBSTACKPTR
     80  248a		       a5 4a		      lda	MATHSTACKPTR
     81  248c		       91 4b		      sta	(GOSUBSTACK),y
     82  248e		       a5 48		      lda	MATHSTACK
     83  2490		       c8		      iny
     84  2491
     85  2491		       91 4b		      sta	(GOSUBSTACK),y
     86  2493		       c8		      iny
     87  2494
     88  2494		       a5 49		      lda	MATHSTACK+1
     89  2496		       91 4b		      sta	(GOSUBSTACK),y
     90  2498		       c8		      iny
     91  2499
     92  2499		       a9 06		      lda	#GOSUB_STACK_SAVE
     93  249b		       91 4b		      sta	(GOSUBSTACK),y
     94  249d		       c8		      iny
     95  249e
     96  249e		       84 4d		      sty	GOSUBSTACKPTR
     97  24a0
     98  24a0		       68		      pla
     99  24a1		       a8		      tay
    100  24a2		       4c b1 02 	      jmp	NextIL
    101  24a5							;
    102  24a5							;==========================================================
    103  24a5							;Restore the math stack information from the gosub stack
    104  24a5				   iRestoreMathStack
    105  24a5		       98		      tya
    106  24a6		       48		      pha
    107  24a7
    108  24a7		       a5 4a		      lda	MATHSTACKPTR
    109  24a9		       85 58		      sta	R2	; save the current offset for whatever task to R2
    110  24ab
    111  24ab		       a4 4d		      ldy	GOSUBSTACKPTR
    112  24ad		       88		      dey
    113  24ae		       b1 4b		      lda	(GOSUBSTACK),y
    114  24b0		       c9 06		      cmp	#GOSUB_STACK_SAVE
    115  24b2		       d0 16		      bne	iPopMathStack_Err
    116  24b4		       88		      dey
    117  24b5		       b1 4b		      lda	(GOSUBSTACK),y
    118  24b7		       85 49		      sta	MATHSTACK+1
    119  24b9		       88		      dey
    120  24ba		       b1 4b		      lda	(GOSUBSTACK),y
    121  24bc		       85 48		      sta	MATHSTACK
    122  24be		       88		      dey
    123  24bf		       b1 4b		      lda	(GOSUBSTACK),y
    124  24c1		       85 4a		      sta	MATHSTACKPTR
    125  24c3		       84 4d		      sty	GOSUBSTACKPTR
    126  24c5
    127  24c5		       68		      pla
    128  24c6		       a8		      tay
    129  24c7		       4c b1 02 	      jmp	NextIL
    130  24ca
    131  24ca				   iPopMathStack_Err
    132  24ca		       68		      pla
    133  24cb		       a8		      tay
    134  24cc		       a9 00		      lda	#0
    135  24ce		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    136  24d0		       4c 7d 06 	      jmp	iErr2
    137  24d3							;=========================================
    138  24d3							; For functions and tasks the variable address of # means
    139  24d3							; a passed parameter so #[0] is the first parameter etc
    140  24d3							; will try for a better way later
    141  24d3							;=====================================================
    142  24d3							; On entry il, branch to if function
    143  24d3							;	    il+1, value to be returned or not true or false
    144  24d3							;
    145  24d3							; Return from GOSUB  or function function
    146  24d3							; format   RSTR 0   --- return form gosub
    147  24d3							;	    RSTR 1   --- return from Function
    148  24d3							;
    149  24d3		       20 5f 29    iRSTR      jsr	getILByte	; get where to go if 0 = gosub/1=function call
    150  24d6		       8d 39 42 	      sta	offset
    151  24d9		       20 42 2b 	      jsr	saveIL	; for later jump if needed add extra entry to	the return stack
    152  24dc
    153  24dc		       20 9b 2b 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    154  24df		       85 54		      sta	R1	; keep the type of call returning from
    155  24e1		       b0 2b		      bcs	iRSTRErr	; stack underflow error possible
    156  24e3
    157  24e3		       20 5f 29 	      jsr	getILByte	; get if a value is being returned
    158  24e6
    159  24e6		       48		      pha		; save if a value was passed to be returned
    160  24e7
    161  24e7		       c9 00		      cmp	#0	; yes attemping to return a value
    162  24e9		       f0 03		      beq	iRSTRPOP	; no value to return
    163  24eb		       20 ea 2b 	      jsr	popR0	; Get the value from the stack save if needed
    164  24ee
    165  24ee				   iRSTRPOP
    166  24ee		       20 6f 24 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    167  24f1		       a5 54		      lda	R1	; called as a statement ?
    168  24f3		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    169  24f5		       f0 13		      beq	iRSTRExit
    170  24f7
    171  24f7		       68		      pla		; get back if value returned or not
    172  24f8		       c9 01		      cmp	#1	; we have a value to return
    173  24fa		       f0 05		      beq	iRSTRVALUE
    174  24fc
    175  24fc		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    176  24fe		       4c 12 05 	      jmp	iSAVErr2	; jump to general error reporting function
    177  2501
    178  2501				   iRSTRVALUE
    179  2501		       20 58 2b 	      jsr	pushR0	; return value back to top of stack
    180  2504		       20 4d 2b 	      jsr	restoreIL	; get the correct il
    181  2507		       4c db 0b 	      jmp	tstBranch	; And called as a function
    182  250a
    183  250a				   iRSTRExit
    184  250a		       68		      pla		; throw away gosub/func flag
    185  250b		       4c b1 02 	      jmp	NextIL
    186  250e
    187  250e				   iRSTRNORETURNVALUE
    188  250e
    189  250e
    190  250e		       ad c8 35    iRSTRErr   lda	taskPtr	; Check if this is task zero
    191  2511		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    192  2513		       a5 56		      lda	MQ
    193  2515		       d0 03		      bne	taskRet
    194  2517		       20 1f 2e 	      jsr	pushFalse	; the result code by default is 0
    195  251a				   taskRet
    196  251a		       4c 82 27 	      jmp	iETask	; not task zero then do a task end instead
    197  251d				   taskZeroEnd
    198  251d		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    199  251f		       4c 12 05 	      jmp	iSAVErr2
    200  2522							;
    201  2522							;==========================================================================================
    202  2522							; Find the next gosub function parameter info	position on the stack
    203  2522							; Returns y = index and c set if found clera c otherwise
    204  2522		       a4 4d	   GosubFindParms ldy	GOSUBSTACKPTR	;Get the Pointer to the top of stack
    205  2524		       88		      dey		;Point to stack entry type
    206  2525
    207  2525							;Veryify the stack size and position for the call
    208  2525							;Loops here until it finds a GOSUB with value entry or gosub-rtn entry
    209  2525
    210  2525		       c0 00	   GosubFindLoop cpy	#0	;If we reach the top of the stack then no parametrs
    211  2527		       f0 21		      beq	GosubNotFunc
    212  2529		       c0 10		      cpy	#GOSUBSTACKSIZE	;Tst if we are outside the stack size
    213  252b		       b0 1d		      bcs	GosubNotFunc	;Not valid
    214  252d
    215  252d							;Look for the	 GOSUG_RTN_VALUE stack position
    216  252d		       b1 4b		      lda	(GOSUBSTACK),y	;Get the type of call - if it is not a fn call error
    217  252f		       c9 01		      cmp	#GOSUB_RTN	;if we find this then this function had no parameters
    218  2531		       f0 17		      beq	GosubNotFunc
    219  2533
    220  2533		       c9 81		      cmp	#GOSUB_RTN_VALUE
    221  2535		       f0 07		      beq	GosubParmFnd	;Skip any non Gosub related entries
    222  2537		       88		      dey
    223  2538		       88		      dey
    224  2539		       88		      dey
    225  253a		       88		      dey
    226  253b		       4c 25 25 	      jmp	GosubFindLoop
    227  253e
    228  253e		       88	   GosubParmFnd dey		;Point to hopefully Math Stack frame information
    229  253f		       88		      dey
    230  2540		       88		      dey
    231  2541		       88		      dey
    232  2542
    233  2542		       b1 4b		      lda	(GOSUBSTACK),y	;This should be a stack frame pointer
    234  2544		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    235  2546		       d0 02		      bne	GosubNotFunc	;No parameters passed but expected
    236  2548		       38		      sec
    237  2549		       60		      rts
    238  254a
    239  254a		       18	   GosubNotFunc clc
    240  254b		       60		      rts
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  254c					      include	"tasks.asm"
      1  254c							;=====================================================
      2  254c							; Tiny Basic IL task management
      3  254c							; Data required by task management
      4  254c							; currently each context is about 30 bytes and is swapped
      5  254c							; into and out of page zero on each task switch....
      6  254c							; LOL yes it is slow, but works for this iteration.
      7  254c							;
      8  254c
      9  254c					      Seg	Code
     10  254c							;=====================================================
     11  254c							; Sets the pointers to the math,IL and gosub stacks
     12  254c							; Creates the initial Context for each task slot
     13  254c				   taskSetStacks
     14  254c		       a9 c8		      lda	#mathStack&$FF
     15  254e		       85 48		      sta	MATHSTACK
     16  2550		       a9 36		      lda	#mathStack>>8
     17  2552		       85 49		      sta	MATHSTACK+1
     18  2554
     19  2554		       a9 58		      lda	#ilStack&$ff
     20  2556		       85 45		      sta	ILSTACK
     21  2558		       a9 38		      lda	#ilStack>>8
     22  255a		       85 46		      sta	ILSTACK+1
     23  255c
     24  255c		       a9 40		      lda	#gosubStack&$FF
     25  255e		       85 4b		      sta	GOSUBSTACK
     26  2560		       a9 3c		      lda	#gosubStack>>8
     27  2562		       85 4c		      sta	GOSUBSTACK+1
     28  2564
     29  2564		       a9 c0		      lda	#variableStack&$FF
     30  2566		       85 41		      sta	VARIABLES
     31  2568		       a9 3e		      lda	#variableStack>>8
     32  256a		       85 42		      sta	VARIABLES+1
     33  256c		       a2 0a		      ldx	#TASKCOUNT
     34  256e		       a0 00		      ldy	#0
     35  2570		       20 16 28 	      jsr	ContextSave	; Save the Task 0 context
     36  2573
     37  2573		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  2575		       b0 3a		      bcs	taskSetDone
     39  2577
     40  2577		       a5 4b		      lda	GOSUBSTACK
     41  2579		       18		      clc
     42  257a		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  257c		       85 4b		      sta	GOSUBSTACK
     44  257e		       a5 4c		      lda	GOSUBSTACK+1
     45  2580		       69 00		      adc	#0
     46  2582		       85 4c		      sta	GOSUBSTACK+1
     47  2584
     48  2584		       a5 45		      lda	ILSTACK	; must be less than 256
     49  2586		       18		      clc
     50  2587		       69 64		      adc	#ILSTACKSIZE*2
     51  2589		       85 45		      sta	ILSTACK
     52  258b		       a5 46		      lda	ILSTACK+1
     53  258d		       69 00		      adc	#0
     54  258f		       85 46		      sta	ILSTACK+1
     55  2591
     56  2591		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  2593		       18		      clc
     58  2594		       69 28		      adc	#MATHSTACKSIZE*2
     59  2596		       85 48		      sta	MATHSTACK
     60  2598		       a5 49		      lda	MATHSTACK+1
     61  259a		       69 00		      adc	#0
     62  259c		       85 49		      sta	MATHSTACK+1
     63  259e
     64  259e		       a5 41		      lda	VARIABLES	; must be less than 256
     65  25a0		       18		      clc
     66  25a1		       69 4a		      adc	#VARIABLESSIZE*2
     67  25a3		       85 41		      sta	VARIABLES
     68  25a5		       a5 42		      lda	VARIABLES+1
     69  25a7		       69 00		      adc	#0
     70  25a9		       85 42		      sta	VARIABLES+1
     71  25ab		       20 16 28 	      jsr	ContextSave
     72  25ae		       4c 73 25 	      jmp	taskSetLoop
     73  25b1
     74  25b1				   taskSetDone
     75  25b1		       a0 00		      ldy	#0	; reload the main loop context
     76  25b3		       20 25 28 	      jsr	ContextLoad
     77  25b6		       60		      rts
     78  25b7							;
     79  25b7							;============================================================
     80  25b7							; Saves the io block to the context
     81  25b7
     82  25b7
     83  25b7		       98	   SaveIOblock tya
     84  25b8		       48		      pha
     85  25b9		       8a		      txa
     86  25ba		       48		      pha
     87  25bb
     88  25bb
     89  25bb
     90  25bb		       68		      pla
     91  25bc		       aa		      tax
     92  25bd		       68		      pla
     93  25be		       a8		      tay
     94  25bf		       60		      rts
     95  25c0
     96  25c0							;
     97  25c0							;=====================================================
     98  25c0							; In some error cases the math stacks may be left pointing to the wrong stack
     99  25c0							; This function will reset those stack addresses but not the actual pointer
    100  25c0				   taskResetStacks
    101  25c0		       a0 00		      ldy	#0
    102  25c2		       20 25 28 	      jsr	ContextLoad
    103  25c5		       4c 4c 25 	      jmp	taskSetStacks
    104  25c8							;
    105  25c8							;=====================================================
    106  25c8							; Clear all task entries and task stacks
    107  25c8		       98	   taskReset  tya		; Save Y
    108  25c9		       48		      pha
    109  25ca		       a9 01		      lda	#1
    110  25cc		       8d c7 36 	      sta	taskCounter	; Set number of active tasks to 1
    111  25cf		       ac c8 35 	      ldy	taskPtr	; Set the active task to 0 MAIN
    112  25d2		       c0 00		      cpy	#0	; check if we are the main context
    113  25d4		       f0 08		      beq	taskResetCont	; if we are just continue
    114  25d6
    115  25d6		       a0 00		      ldy	#0	; else we need to switch to the main context
    116  25d8		       8c c8 35 	      sty	taskPtr
    117  25db		       20 25 28 	      jsr	ContextLoad	; load the System Task context
    118  25de				   taskResetCont
    119  25de		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    120  25e0
    121  25e0				   taskResetLoop
    122  25e0		       a9 00		      lda	#TASKINACTIVE
    123  25e2		       99 c9 35 	      sta	taskTable,y	; Ensure that the task is made inactive
    124  25e5		       18		      clc
    125  25e6		       98		      tya
    126  25e7		       69 19		      adc	#CONTEXTLEN
    127  25e9		       a8		      tay
    128  25ea		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    129  25ec		       90 f2		      bcc	taskResetLoop	; Go for more
    130  25ee
    131  25ee				   taskResetComplete
    132  25ee
    133  25ee		       68		      pla		; Restore y
    134  25ef		       a8		      tay
    135  25f0		       60		      rts
    136  25f1
    137  25f1							;
    138  25f1							;======================================================
    139  25f1							; iTaskSwitch	 switch to new task if not interrupt and
    140  25f1							;		 count is exceded for task time slice gets here
    141  25f1							;		 when time slice has reached zero
    142  25f1							;
    143  25f1		       98	   iTaskSwitch tya
    144  25f2		       48		      pha
    145  25f3
    146  25f3		       ad c5 36 	      lda	taskResetValue	; Always reset the counter value
    147  25f6		       8d c3 36 	      sta	taskCurrentCycles	; Update the counter with the new value
    148  25f9		       ce c4 36 	      dec	taskCurrentCycles+1	; dec high order byte
    149  25fc		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    150  25fe
    151  25fe		       ad c6 36 	      lda	taskResetValue+1
    152  2601		       8d c4 36 	      sta	taskCurrentCycles+1
    153  2604
    154  2604		       ad 5a 19 	      lda	IRQPending	; Skip this if we are processing an irq
    155  2607		       0d 3b 42 	      ora	taskIOPending	; If set then don't switch
    156  260a		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    157  260c
    158  260c		       ad c7 36    iTaskMain  lda	taskCounter	; Number of tasks
    159  260f		       c9 01		      cmp	#1	; if there is only one task must be main
    160  2611		       d0 07		      bne	itasknext	; if it some other number continue to next
    161  2613
    162  2613		       ac c8 35 	      ldy	taskPtr	; check if we have not just ended some other task
    163  2616		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    164  2618		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    165  261a							;
    166  261a							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    167  261a							;
    168  261a				   itasknext
    169  261a		       ac c8 35 	      ldy	taskPtr
    170  261d		       20 16 28 	      jsr	ContextSave	; Save the current context, y points to next context
    171  2620				   itaskLoop
    172  2620		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    173  2622		       90 04		      bcc	iTaskNextChk
    174  2624
    175  2624		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    176  2626		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    177  2628
    178  2628				   iTaskNextChk
    179  2628		       b9 c9 35 	      lda	taskTable,y	; there is always at least one entry in table
    180  262b		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    181  262d		       18	   iTaskNext  clc
    182  262e		       98		      tya
    183  262f		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    184  2631		       a8		      tay
    185  2632		       4c 20 26 	      jmp	itaskLoop	; Check for busy entry
    186  2635
    187  2635		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    188  2637		       59 c9 35 	      eor	taskTable,y	; Check for anything waiting io
    189  263a		       d0 f1		      bne	iTaskNext
    190  263c		       20 25 28 	      jsr	ContextLoad	; load the next context
    191  263f		       8c c8 35 	      sty	taskPtr	; update the task pointer
    192  2642
    193  2642				   iTaskSwitchDone
    194  2642		       68		      pla
    195  2643		       a8		      tay
    196  2644		       60		      rts
    197  2645							;
    198  2645							;================================================================
    199  2645							; Task Set task number to line number to start
    200  2645							; on entry stack contains, type of line description and  memvector or linenumber
    201  2645							; Task Table structure:
    202  2645							;    byte 0	-   Active inactive
    203  2645							;    byte 1-2	-   Basic code line pointer
    204  2645							;    byte 3	-   Offset on current line
    205  2645		       98	   iTaskSet   tya		;preserve Y
    206  2646		       48		      pha		; push a
    207  2647		       20 02 2c 	      jsr	popR1	; Get if compiled or line number expression
    208  264a		       20 ea 2b 	      jsr	popR0	; Get the line number to be saved
    209  264d
    210  264d
    211  264d
    212  264d		       ac c8 35 	      ldy	taskPtr	; find out where we are
    213  2650		       20 16 28 	      jsr	ContextSave	; Save the current context
    214  2653
    215  2653							;Find the pointer to the line we need to start at
    216  2653		       a5 54		      lda	R1
    217  2655		       f0 0b		      beq	iTaskLineNum
    218  2657		       a5 52		      lda	R0
    219  2659		       85 4f		      sta	CURPTR
    220  265b		       a5 53		      lda	R0+1
    221  265d		       85 50		      sta	CURPTR+1
    222  265f		       4c 72 26 	      jmp	iTaskCont
    223  2662
    224  2662				   iTaskLineNum
    225  2662		       20 a4 29 	      jsr	findLine	; Get the offset of the line to start task at
    226  2665		       f0 0b		      beq	iTaskCont
    227  2667
    228  2667		       ac c8 35 	      ldy	taskPtr	; Restore the original Context Error Exit
    229  266a		       20 25 28 	      jsr	ContextLoad
    230  266d
    231  266d		       68		      pla		; pop a - exit
    232  266e		       a8		      tay
    233  266f		       4c ee 0d 	      jmp	iSetIrqErr	; Bad line number provided
    234  2672
    235  2672				   iTaskCont
    236  2672		       20 e8 27 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    237  2675		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    238  2677
    239  2677		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    240  2679		       99 c9 35 	      sta	taskTable,y	; new task as active
    241  267c
    242  267c		       a5 4f		      lda	CURPTR
    243  267e		       48		      pha		; push a
    244  267f		       a5 50		      lda	CURPTR+1
    245  2681		       48		      pha		; push a
    246  2682
    247  2682		       20 25 28 	      jsr	ContextLoad	; load the context of the new task
    248  2685
    249  2685		       68		      pla		; pop a
    250  2686		       85 50		      sta	CURPTR+1
    251  2688		       68		      pla		; pop a
    252  2689		       85 4f		      sta	CURPTR
    253  268b		       a9 03		      lda	#3	; Offset to first instruction
    254  268d		       85 51		      sta	CUROFF
    255  268f
    256  268f		       a9 00		      lda	#0
    257  2691		       85 47		      sta	ILSTACKPTR
    258  2693		       85 4a		      sta	MATHSTACKPTR
    259  2695		       85 4d		      sta	GOSUBSTACKPTR
    260  2697		       a9 40		      lda	#GOSUBSTACKSIZE*4
    261  2699		       85 4e		      sta	MESSAGEPTR
    262  269b
    263  269b		       20 70 09 	      jsr	subVINIT	; Clear the variables
    264  269e
    265  269e		       a9 2a		      lda	#STMT&$FF
    266  26a0		       85 43		      sta	ILPC
    267  26a2		       a9 31		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    268  26a4		       85 44		      sta	ILPC+1
    269  26a6
    270  26a6		       98		      tya		; Save the new context offset to return to user
    271  26a7		       48		      pha		; push a
    272  26a8
    273  26a8		       20 16 28    itaskSetSave jsr	ContextSave	; save the updated context
    274  26ab		       ee c7 36 	      inc	taskCounter	; Update the number of Tasks running
    275  26ae
    276  26ae		       ac c8 35 	      ldy	taskPtr
    277  26b1		       20 25 28 	      jsr	ContextLoad	; restore the original context
    278  26b4
    279  26b4		       a9 00		      lda	#0	; Set the R0 upper to zero
    280  26b6		       85 53		      sta	R0+1
    281  26b8		       68		      pla		; Get the task pid we stored				 ; pop a
    282  26b9		       85 52		      sta	R0	; Get the table entry value
    283  26bb
    284  26bb		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    285  26bc		       a8		      tay
    286  26bd
    287  26bd		       4c 16 07 	      jmp	pushR0nextIl	; Push R0 and continue
    288  26c0				   iTaskNoEmpty
    289  26c0		       ac c8 35 	      ldy	taskPtr
    290  26c3		       20 25 28 	      jsr	ContextLoad
    291  26c6
    292  26c6		       68		      pla		; pop a    -- exit
    293  26c7		       a8		      tay
    294  26c8
    295  26c8		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    296  26ca		       a9 00		      lda	#0
    297  26cc		       4c 7d 06 	      jmp	iErr2
    298  26cf							;
    299  26cf							;===============================================================
    300  26cf							; Run the task whos PID is on the stack, preserve the stack
    301  26cf							;
    302  26cf				   iTaskEnable
    303  26cf		       98		      tya
    304  26d0		       48		      pha
    305  26d1		       20 02 2c 	      jsr	popR1
    306  26d4		       20 d0 2b 	      jsr	pushR1
    307  26d7		       20 1c 29 	      jsr	ipc_getcontext	; get context pointer into mq
    308  26da		       a0 00		      ldy	#0
    309  26dc		       b1 56		      lda	(MQ),y
    310  26de		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    311  26e0		       09 80		      ora	#TASKACTIVE
    312  26e2		       91 56		      sta	(MQ),y
    313  26e4		       68		      pla
    314  26e5		       a8		      tay
    315  26e6		       4c b1 02 	      jmp	NextIL
    316  26e9
    317  26e9							;
    318  26e9							;===============================================================
    319  26e9							; Suspend the task whos PID  is on the stack, preserve the stack
    320  26e9							;
    321  26e9				   iTaskSuspend
    322  26e9		       98		      tya
    323  26ea		       48		      pha
    324  26eb		       20 02 2c 	      jsr	popR1
    325  26ee		       20 d0 2b 	      jsr	pushR1
    326  26f1		       20 1c 29 	      jsr	ipc_getcontext	; get context pointer into mq
    327  26f4		       a0 00		      ldy	#0
    328  26f6		       b1 56		      lda	(MQ),y
    329  26f8		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    330  26fa		       09 80		      ora	#TASKACTIVE
    331  26fc		       68		      pla
    332  26fd		       a8		      tay
    333  26fe		       4c b1 02 	      jmp	NextIL
    334  2701
    335  2701							;================================================================
    336  2701							; Returns task Status
    337  2701				   iTaskStat
    338  2701		       98		      tya
    339  2702		       48		      pha
    340  2703		       20 15 27 	      jsr	iTaskValid	; returns pointer to task entry
    341  2706		       b9 c9 35 	      lda	taskTable,y
    342  2709		       f0 05		      beq	iTaskStatExit
    343  270b		       68		      pla
    344  270c		       a8		      tay
    345  270d		       4c 7e 0d 	      jmp	iTruth
    346  2710				   iTaskStatExit
    347  2710		       68		      pla
    348  2711		       a8		      tay
    349  2712		       4c 87 0d 	      jmp	iFalse
    350  2715
    351  2715							;
    352  2715							;================================================================
    353  2715							; Validate the task number on top of the stack
    354  2715							; on exit y points to the requested task entry
    355  2715							;
    356  2715		       20 ea 2b    iTaskValid jsr	popR0	; get result of the multiply
    357  2718		       a5 53		      lda	R0+1
    358  271a		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    359  271c		       a5 52		      lda	R0
    360  271e		       c9 fa		      cmp	#TASKTABLELEN
    361  2720		       90 09		      bcc	iTaskIsValid
    362  2722
    363  2722		       68	   iTaskValidErr pla		;remove return address
    364  2723		       68		      pla
    365  2724		       a2 10		      ldx	#ERR_INVALID_PID
    366  2726		       a9 00		      lda	#0
    367  2728		       4c 7d 06 	      jmp	iErr2
    368  272b
    369  272b		       a8	   iTaskIsValid tay
    370  272c		       60		      rts
    371  272d							;
    372  272d							;================================================================
    373  272d							; Kill a running task, do nothing if already stopped
    374  272d		       20 15 27    iTaskKill  jsr	iTaskValid
    375  2730		       a9 00		      lda	#0
    376  2732		       99 c9 35 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    377  2735							;
    378  2735							;================================================================
    379  2735							;Skip to next task
    380  2735				   iNTask
    381  2735		       a9 01		      lda	#1
    382  2737		       8d c3 36 	      sta	taskCurrentCycles
    383  273a		       8d c4 36 	      sta	taskCurrentCycles+1
    384  273d		       4c b1 02 	      jmp	NextIL
    385  2740							;
    386  2740							;=======================================================
    387  2740							; Wait for a task to complete
    388  2740				   iWTASK
    389  2740		       20 5f 29 	      jsr	getILByte
    390  2743		       8d 39 42 	      sta	offset
    391  2746							;
    392  2746		       20 42 2b 	      jsr	saveIL	;in case of failure
    393  2749
    394  2749		       20 15 27 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    395  274c		       b9 c9 35 	      lda	taskTable,y
    396  274f		       d0 03		      bne	iWTASKWAIT
    397  2751				   iWTASKEXITED
    398  2751		       4c b1 02 	      jmp	NextIL
    399  2754				   iWTASKWAIT
    400  2754		       20 58 2b 	      jsr	pushR0	; Push R0 back onto the stack
    401  2757		       a9 01		      lda	#1
    402  2759		       8d c3 36 	      sta	taskCurrentCycles	; Give up the cycles
    403  275c		       8d c4 36 	      sta	taskCurrentCycles+1
    404  275f		       20 4d 2b 	      jsr	restoreIL
    405  2762		       4c db 0b 	      jmp	tstBranch
    406  2765							;
    407  2765							;=======================================================
    408  2765							; Set task io lock
    409  2765		       ee 3b 42    iStartIO   inc	taskIOPending
    410  2768		       4c b1 02 	      jmp	NextIL
    411  276b							;
    412  276b							;=======================================================
    413  276b							; Release the io lock
    414  276b		       ad 3b 42    iEndIO     lda	taskIOPending
    415  276e		       f0 03		      beq	iEndIOExit
    416  2770		       ce 3b 42 	      dec	taskIOPending
    417  2773		       4c b1 02    iEndIOExit jmp	NextIL
    418  2776							;
    419  2776							;===============================================================
    420  2776							; Return the task PID
    421  2776				   iTASKPID
    422  2776		       a9 00		      lda	#0
    423  2778		       85 53		      sta	R0+1
    424  277a		       ad c8 35 	      lda	taskPtr
    425  277d		       85 52		      sta	R0
    426  277f		       4c 16 07 	      jmp	pushR0nextIl
    427  2782							;
    428  2782							;================================================================
    429  2782							; Terminate a task
    430  2782		       ac c8 35    iETask     ldy	taskPtr
    431  2785		       c0 00		      cpy	#0
    432  2787		       d0 03		      bne	iETaskCont
    433  2789		       4c 02 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    434  278c				   iETaskCont
    435  278c		       a9 00		      lda	#TASKINACTIVE
    436  278e		       99 c9 35 	      sta	taskTable,y	; mark entry as free
    437  2791		       ce c7 36 	      dec	taskCounter	; reduce the number of active tasks
    438  2794		       a9 01		      lda	#1
    439  2796		       8d c3 36 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    440  2799		       8d c4 36 	      sta	taskCurrentCycles+1
    441  279c		       20 03 28 	      jsr	TaskSetExitCode
    442  279f				   iETaskExit
    443  279f		       4c b1 02 	      jmp	NextIL
    444  27a2							;================================================================
    445  27a2							; make the current tasks math stack equal another tasks stack
    446  27a2							; The task to get is stored on the math stack
    447  27a2
    448  27a2				   iTaskGetMathStack
    449  27a2		       20 23 2e 	      jsr	CopyStackR1	; Get the top of stack to R1
    450  27a5		       20 1c 29 	      jsr	ipc_getcontext	; MQ now has the context address
    451  27a8		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  27aa		       b1 56		      lda	(MQ),y
    453  27ac		       85 4a		      sta	MATHSTACKPTR
    454  27ae		       a0 08		      ldy	#MATHSTACKPOS
    455  27b0		       b1 56		      lda	(MQ),y
    456  27b2		       85 48		      sta	MATHSTACK
    457  27b4		       c8		      iny
    458  27b5		       b1 56		      lda	(MQ),y
    459  27b7		       85 49		      sta	MATHSTACK+1
    460  27b9		       4c b1 02 	      jmp	NextIL
    461  27bc							;==================================================================
    462  27bc							; Updates the tasks math stack pointer with contents of R2
    463  27bc							; PID is on top of the stack
    464  27bc				   iTaskPutMathPtr
    465  27bc		       20 23 2e 	      jsr	CopyStackR1	; Get the top of stack to R1
    466  27bf		       20 1c 29 	      jsr	ipc_getcontext	; MQ now has the context address
    467  27c2		       a5 58		      lda	R2
    468  27c4		       a0 0a		      ldy	#MATHSTACKPTRPOS
    469  27c6		       91 56		      sta	(MQ),y
    470  27c8		       4c b1 02 	      jmp	NextIL
    471  27cb							;
    472  27cb							;================================================================
    473  27cb							; Set the time slice for each task
    474  27cb				   iSLICE
    475  27cb		       20 ea 2b 	      jsr	popR0
    476  27ce		       a5 52		      lda	R0
    477  27d0		       8d c5 36 	      sta	taskResetValue
    478  27d3		       a5 53		      lda	R0+1
    479  27d5		       8d c6 36 	      sta	taskResetValue+1
    480  27d8		       d0 0b		      bne	iSliceSet
    481  27da		       ee c6 36 	      inc	taskResetValue+1	; must be at least 1 high counter
    482  27dd		       a9 01		      lda	#1
    483  27df		       8d c3 36 	      sta	taskCurrentCycles
    484  27e2		       8d c4 36 	      sta	taskCurrentCycles+1
    485  27e5				   iSliceSet
    486  27e5		       4c b1 02 	      jmp	NextIL
    487  27e8							;================================================================
    488  27e8							; Find an empty slot in the taskTable
    489  27e8							; Return the index in y
    490  27e8							; on exit   c set if an empty slot is found
    491  27e8							;	     c clear if not found
    492  27e8							;================================================================
    493  27e8							;
    494  27e8		       ad c7 36    TaskEmpty  lda	taskCounter
    495  27eb		       c9 0a		      cmp	#TASKCOUNT
    496  27ed		       b0 10		      bcs	TaskNoSlot
    497  27ef		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    498  27f1				   TaskLoop
    499  27f1		       b9 c9 35 	      lda	taskTable,y
    500  27f4		       f0 0b		      beq	TaskEmptyFnd
    501  27f6		       98		      tya
    502  27f7		       18		      clc
    503  27f8		       69 19		      adc	#CONTEXTLEN
    504  27fa		       a8		      tay
    505  27fb		       c0 fa		      cpy	#TASKTABLELEN
    506  27fd		       90 f2		      bcc	TaskLoop	; Y is never zero
    507  27ff				   TaskNoSlot
    508  27ff		       18		      clc
    509  2800		       60		      rts
    510  2801				   TaskEmptyFnd
    511  2801		       38		      sec
    512  2802		       60		      rts
    513  2803							;====================================================
    514  2803							; Set the task exit code called from the return command
    515  2803							; on entry stack top hold exit value
    516  2803				   TaskSetExitCode
    517  2803		       98		      tya
    518  2804		       48		      pha
    519  2805		       20 ea 2b 	      jsr	popR0
    520  2808		       a0 48		      ldy	#TASKEXITCODE
    521  280a		       a5 52		      lda	R0
    522  280c		       91 41		      sta	(VARIABLES),y
    523  280e		       c8		      iny
    524  280f		       a5 53		      lda	R0+1
    525  2811		       91 41		      sta	(VARIABLES),y
    526  2813		       68		      pla
    527  2814		       98		      tya
    528  2815		       60		      rts
    529  2816
    530  2816							;
    531  2816							;=====================================================
    532  2816							; Save Context Store the context to the TASK Table
    533  2816							; on entry y contains the task table entry to save to
    534  2816							; on exit y points to next task table entry
    535  2816							;	   x contains the number of bytes copied
    536  2816		       a2 00	   ContextSave ldx	#0
    537  2818		       c8		      iny		;inc past the task flags
    538  2819		       b5 41	   ContextSvLoop lda	CONTEXT,x
    539  281b		       99 c9 35 	      sta	taskTable,y
    540  281e		       c8		      iny
    541  281f		       e8		      inx
    542  2820		       e0 18		      cpx	#[CONTEXTLEN-1]
    543  2822		       90 f5		      bcc	ContextSvLoop
    544  2824		       60		      rts
    545  2825							;
    546  2825							; Load Context transfer context from task table to the Current Context
    547  2825							; on entry y contains the task table entry to transfer
    548  2825							; on exit y points to the original task table entry
    549  2825							;	   x contains the number of bytes copied
    550  2825		       98	   ContextLoad tya
    551  2826		       48		      pha
    552  2827		       a2 00		      ldx	#0
    553  2829		       c8		      iny		;inc past the task flags
    554  282a		       b9 c9 35    ContextLDLoop lda	taskTable,y
    555  282d		       95 41		      sta	CONTEXT,x
    556  282f		       c8		      iny
    557  2830		       e8		      inx
    558  2831		       e0 18		      cpx	#[CONTEXTLEN-1]
    559  2833		       90 f5		      bcc	ContextLDLoop
    560  2835		       68		      pla
    561  2836		       a8		      tay
    562  2837		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  2838					      include	"ipc.asm"
      1  2838							;======================================================
      2  2838							; Inter process communications.
      3  2838							; Tasks may write/read integer messages among
      4  2838							; them selves.
      5  2838							; This uses each tasks gosub stack as a message queue
      6  2838							; Gosub calls start at the highest address and the
      7  2838							; msg queue starts at the highest address.
      8  2838							;
      9  2838							;======================================================
     10  2838							; ipcs   - Send msg to another task or many tasks
     11  2838							; on entry  math stack contains the  top PID
     12  2838							;				      2ND Message value
     13  2838							; on exit   math stack contain top True-good or False-failed
     14  2838							;
     15  2838							; it may not be sent if queue is full
     16  2838							;
     17  2838							; a = ipcs(<message-expression>,<task PID-expression>)
     18  2838							;
     19  2838				   iIPCS
     20  2838		       98		      tya
     21  2839		       48		      pha
     22  283a		       20 a1 28 	      jsr	ipc_enqueue
     23  283d		       b0 08		      bcs	iIPC_BAD
     24  283f		       20 15 2e 	      jsr	pushTrue
     25  2842		       68		      pla
     26  2843		       a8		      tay
     27  2844		       4c b1 02 	      jmp	NextIL
     28  2847				   iIPC_BAD
     29  2847		       68		      pla
     30  2848		       a8		      tay
     31  2849		       20 1f 2e 	      jsr	pushFalse
     32  284c		       4c b1 02 	      jmp	NextIL
     33  284f
     34  284f							;======================================================
     35  284f							; ipcr   - Recieve msg from task
     36  284f							; on exit  the message value is returned from message queue
     37  284f							;	    message -1	is reserved meaning no entry found
     38  284f							; The provided variable contains the pid of the sending
     39  284f							; task. This is optional. This always waits for a message
     40  284f							; before returning.
     41  284f							;
     42  284f							; a = ipcr(<variable name>)
     43  284f							;
     44  284f				   iIPCR
     45  284f		       98		      tya
     46  2850		       48		      pha
     47  2851		       20 e3 28 	      jsr	ipc_dequeue
     48  2854		       b0 05		      bcs	iIPCR_Q_Empty
     49  2856		       68		      pla
     50  2857		       a8		      tay
     51  2858		       4c b1 02 	      jmp	NextIL
     52  285b				   iIPCR_Q_Empty
     53  285b		       68		      pla
     54  285c		       a8		      tay
     55  285d		       20 15 2e 	      jsr	pushTrue	; puts -1 on the stack
     56  2860		       4c b1 02 	      jmp	NextIL
     57  2863
     58  2863							;=======================================================
     59  2863							; ipcc   - Check if message available
     60  2863							; on exit  Stack contains number of messages
     61  2863							;
     62  2863							; a = ipcc()
     63  2863							;
     64  2863				   iIPCC
     65  2863		       98		      tya
     66  2864		       48		      pha
     67  2865		       20 8e 28 	      jsr	ipc_queue_count
     68  2868		       20 58 2b 	      jsr	pushR0	; return the count
     69  286b		       68		      pla
     70  286c		       a8		      tay
     71  286d		       4c b1 02 	      jmp	NextIL
     72  2870
     73  2870							;=======================================================
     74  2870							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  2870				   iIPCIO
     76  2870		       98		      tya
     77  2871		       48		      pha
     78  2872		       20 8e 28 	      jsr	ipc_queue_count
     79  2875		       a5 52		      lda	R0
     80  2877		       d0 10		      bne	iIPCIO_No_Halt
     81  2879		       a9 01		      lda	#1
     82  287b		       8d c3 36 	      sta	taskCurrentCycles	; force a task switch
     83  287e		       a9 01		      lda	#TASKWAITIPC
     84  2880		       ac c8 35 	      ldy	taskPtr
     85  2883		       19 c9 35 	      ora	taskTable,y
     86  2886		       99 c9 35 	      sta	taskTable,y
     87  2889
     88  2889				   iIPCIO_No_Halt
     89  2889		       68		      pla
     90  288a		       a8		      tay
     91  288b		       4c b1 02 	      jmp	NextIL
     92  288e							;======================================================
     93  288e							;ipc_queue_count
     94  288e				   ipc_queue_count
     95  288e		       a5 4e		      lda	MESSAGEPTR
     96  2890		       18		      clc
     97  2891		       4a		      lsr		; divide by 4
     98  2892		       4a		      lsr
     99  2893		       85 52		      sta	R0	; store into R0
    100  2895		       a9 10		      lda	#GOSUBSTACKSIZE
    101  2897		       38		      sec
    102  2898		       e5 52		      sbc	R0	; Get how many entries on queue
    103  289a		       85 52		      sta	R0
    104  289c		       a9 00		      lda	#0
    105  289e		       85 53		      sta	R0+1
    106  28a0		       60		      rts
    107  28a1							;=======================================================
    108  28a1							; Support functions for messaging
    109  28a1							;
    110  28a1							; Enqueue message -> onto PID's MSG Q
    111  28a1							; on entry top of stack contains the PID
    112  28a1							;	    second contains the Message of the task
    113  28a1							; on exit contains c set if failed
    114  28a1							;		    c cleared if success
    115  28a1							;		    PID's MSG Q PTR points to the message
    116  28a1							;
    117  28a1				   ipc_enqueue
    118  28a1		       20 02 2c 	      jsr	popR1	; Get the pid
    119  28a4		       20 1c 29 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  28a7
    121  28a7		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  28a9		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  28ab		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  28ad		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  28af		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  28b1
    127  28b1
    128  28b1							; Get the PID'S stack address into R0
    129  28b1		       a0 0b		      ldy	#GOSUBSTKPOS
    130  28b3		       b1 56		      lda	(MQ),y
    131  28b5		       85 52		      sta	R0
    132  28b7		       c8		      iny
    133  28b8		       b1 56		      lda	(MQ),y
    134  28ba		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  28bc
    136  28bc							; Set y to point to the msg q entry
    137  28bc		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  28be		       b1 56		      lda	(MQ),y	; Get the index
    139  28c0		       a8		      tay		; Set y to queue offset
    140  28c1
    141  28c1							; enqueue the message
    142  28c1		       88		      dey		; First byte to save to
    143  28c2		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  28c4		       91 52		      sta	(R0),y	; Set the entry type
    145  28c6
    146  28c6		       88		      dey
    147  28c7		       ad c8 35 	      lda	taskPtr	; Store the PID into queue
    148  28ca		       91 52		      sta	(R0),y
    149  28cc		       20 02 2c 	      jsr	popR1	; Get the actual message value
    150  28cf		       20 50 29 	      jsr	ipc_pushR1	; Store Message value into queue
    151  28d2
    152  28d2		       98		      tya		; Save the new q ptr
    153  28d3		       a0 0e		      ldy	#MSGPTRPOS
    154  28d5		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  28d7		       a0 00		      ldy	#0	; points to context root
    156  28d9		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  28db		       51 56		      eor	(MQ),y	; Turn off the bit
    158  28dd		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  28df		       18		      clc
    160  28e0		       60		      rts
    161  28e1				   ipc_enq_full
    162  28e1		       38		      sec
    163  28e2		       60		      rts
    164  28e3							;=============================================================
    165  28e3							; De-queue for message stack -> local tasks msg q
    166  28e3							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  28e3							;  message into
    168  28e3							;  on exit   math stack contains value of message
    169  28e3							;				  Variable if provided is pid
    170  28e3				   ipc_dequeue
    171  28e3		       20 19 2c 	      jsr	popMQ	; Variable address to put PID into
    172  28e6
    173  28e6		       a4 4e		      ldy	MESSAGEPTR
    174  28e8		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    175  28ea		       b0 2e		      bcs	ipc_deq_empty
    176  28ec		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  28ee		       85 52		      sta	R0
    178  28f0		       c8		      iny
    179  28f1		       b1 4b		      lda	(GOSUBSTACK),y
    180  28f3		       85 53		      sta	R0+1
    181  28f5		       c8		      iny
    182  28f6		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  28f8		       85 54		      sta	R1
    184  28fa		       c8		      iny
    185  28fb		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  28fd		       c8		      iny
    187  28fe		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  2900
    189  2900		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  2902		       d0 16		      bne	ipc_deq_empty
    191  2904
    192  2904		       20 58 2b 	      jsr	pushR0	; place value on stack
    193  2907
    194  2907		       a5 56		      lda	MQ
    195  2909		       05 57		      ora	MQ+1
    196  290b		       f0 0b		      beq	ipc_deq_done
    197  290d		       a5 54		      lda	R1
    198  290f		       a0 00		      ldy	#0
    199  2911		       91 56		      sta	(MQ),y
    200  2913		       c8		      iny
    201  2914		       a9 00		      lda	#0
    202  2916		       91 56		      sta	(MQ),y
    203  2918				   ipc_deq_done
    204  2918		       18		      clc
    205  2919		       60		      rts
    206  291a
    207  291a				   ipc_deq_empty
    208  291a		       38		      sec
    209  291b		       60		      rts
    210  291c
    211  291c							;=============================================
    212  291c							;  Get the context address into MQ from R1 with
    213  291c							;  context/index/pid
    214  291c				   ipc_getcontext
    215  291c		       18		      clc		; Get pointer to Task context
    216  291d		       a9 c9		      lda	#taskTable&$FF	; change ptr to address
    217  291f		       65 54		      adc	R1
    218  2921		       85 56		      sta	MQ
    219  2923		       a9 35		      lda	#taskTable>>8
    220  2925		       65 55		      adc	R1+1
    221  2927		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  2929		       60		      rts
    223  292a							;
    224  292a							;==============================================
    225  292a							; on entry R1 has a context value,
    226  292a							; on exit c is set if fails
    227  292a							;
    228  292a				   ipc_CONTEXTVALUES
      0  292a					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  292a		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  292e					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  292e		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  2932					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  2932		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    232  2934
    233  2934				   ipc_ValidateContext
    234  2934		       48		      pha
    235  2935		       8a		      txa
    236  2936		       48		      pha
    237  2937		       a5 55		      lda	R1+1
    238  2939		       d0 0e		      bne	ipc_Validate_Fail
    239  293b		       a2 00		      ldx	#0
    240  293d		       a5 54		      lda	R1
    241  293f				   ipc_ValidateLoop
    242  293f		       dd 2a 29 	      cmp	ipc_CONTEXTVALUES,x
    243  2942		       f0 09		      beq	ipc_Valid_Context
    244  2944		       e8		      inx
    245  2945		       e0 0a		      cpx	#TASKCOUNT
    246  2947		       90 f6		      bcc	ipc_ValidateLoop
    247  2949
    248  2949				   ipc_Validate_Fail
    249  2949		       68		      pla
    250  294a		       aa		      tax
    251  294b		       68		      pla
      0  294c					      rtn
      0  294c					      db	25
      1  294c		       19		      .byte.b	25
    253  294d
    254  294d				   ipc_Valid_Context
    255  294d		       18		      clc
    256  294e		       90 f9		      bcc	ipc_Validate_Fail
    257  2950							;
    258  2950							;==============================================
    259  2950							;Push R1 onto the stack
    260  2950							;on entry y = next entry
    261  2950							;R0 points to the stack space
    262  2950							;on exit y points to next free byte
    263  2950				   ipc_pushR1
    264  2950		       88		      dey
    265  2951		       a5 55		      lda	R1+1	; PID first
    266  2953		       91 52		      sta	(R0),y
    267  2955		       88		      dey
    268  2956		       a5 54		      lda	R1
    269  2958		       91 52		      sta	(R0),y
    270  295a		       60		      rts
    271  295b
    272  295b
    273  295b
    274  295b
    275  295b
    276  295b
    277  295b
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  295b					      include	"support.asm"
      1  295b							;
      2  295b							;=====================================================
      3  295b							;=====================================================
      4  295b							;=====================================================
      5  295b							; This marks the start of support functions used by
      6  295b							; the IL opcodes.  These are support functions, NOT
      7  295b							; the IL code.
      8  295b							;=====================================================
      9  295b							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  295b							;=====================================================
     11  295b					      Seg	Code
     12  295b							;=====================================================
     13  295b							; This gets the next two bytes pointed to by ILPC and
     14  295b							; returns them; X contains LSB, A contains MSB.  ILPC
     15  295b							; is advanced by two, and Y contains 0 on return.
     16  295b
     17  295b							;
     18  295b		       20 5f 29    getILWord  jsr	getILByte	;LSB
     19  295e		       aa		      tax
     20  295f							;
     21  295f							;=====================================================
     22  295f							; This gets the next byte pointed to by ILPC and
     23  295f							; returns it in A.  On return, X is unchanged but Y
     24  295f							; contains 0.
     25  295f							;
     26  295f		       a0 00	   getILByte  ldy	#0
     27  2961		       b1 43		      lda	(ILPC),y	;get byte
     28  2963		       08		      php		;save status
     29  2964		       e6 43		      inc	ILPC	;inc LSB
     30  2966		       d0 02		      bne	getILb2	;branch if no overflow
     31  2968		       e6 44		      inc	ILPC+1	;inc MSB
     32  296a		       28	   getILb2    plp		;restore status
     33  296b		       60		      rts
     34  296c							;
     35  296c							;=====================================================
     36  296c							; Decrement ILPC by one.
     37  296c							;
     38  296c		       a5 43	   decIL      lda	ILPC
     39  296e		       d0 02		      bne	decIL2
     40  2970		       c6 44		      dec	ILPC+1
     41  2972		       c6 43	   decIL2     dec	ILPC
     42  2974		       60		      rts
     43  2975							;
     44  2975							;=====================================================
     45  2975							; Push the ILPC onto the return stack.  Actually, this
     46  2975							; pushes the address of ILPC+2 since that's the next
     47  2975							; address to execute.
     48  2975							;
     49  2975		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  2977		       c0 64		      cpy	#ILSTACKSIZE<<1
     51  2979		       b0 15		      bcs	pushErr
     52  297b		       a5 43		      lda	ILPC
     53  297d		       18		      clc
     54  297e		       69 02		      adc	#2
     55  2980		       91 45		      sta	(ILSTACK),y
     56  2982		       08		      php		;save C bit
     57  2983		       c8		      iny
     58  2984		       a5 44		      lda	ILPC+1
     59  2986		       28		      plp		;restore C
     60  2987		       69 00		      adc	#0
     61  2989		       91 45		      sta	(ILSTACK),y
     62  298b		       c8		      iny
     63  298c		       84 47		      sty	ILSTACKPTR
     64  298e		       18		      clc
     65  298f		       60		      rts
     66  2990				   pushErr
     67  2990		       38		      sec
     68  2991		       60		      rts
     69  2992							;
     70  2992							;=====================================================
     71  2992							; Pull the top entry from return stack and put into
     72  2992							; ILPC.
     73  2992							;
     74  2992		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  2994		       f0 fa		      beq	pushErr
     76  2996		       88		      dey
     77  2997		       b1 45		      lda	(ILSTACK),y
     78  2999		       85 44		      sta	ILPC+1
     79  299b		       88		      dey
     80  299c		       b1 45		      lda	(ILSTACK),y
     81  299e		       85 43		      sta	ILPC
     82  29a0		       84 47		      sty	ILSTACKPTR
     83  29a2		       18		      clc
     84  29a3		       60		      rts
     85  29a4							;
     86  29a4							;=====================================================
     87  29a4							; This searches for a specific line number that is in
     88  29a4							; R0.	There are three possible return conditions:
     89  29a4							; Line numbers are now the third byte, the first byte is now
     90  29a4							; a pointer to the next line, of course no longer than 255 byte
     91  29a4							; per line.
     92  29a4							;
     93  29a4							; Exact match was found:
     94  29a4							;    * Z set
     95  29a4							;    * CURPTR points to two-byte line number for that
     96  29a4							;	line.
     97  29a4							;
     98  29a4							; Next highest line found:
     99  29a4							;    * Z cleared
    100  29a4							;    * C set
    101  29a4							;    * CURPTR points to two-byte line number for that
    102  29a4							;	line.
    103  29a4							;
    104  29a4							; End of program reached:
    105  29a4							;    * Z cleared
    106  29a4							;    * C cleared
    107  29a4							;    * CURPTR points to first free byte at end of
    108  29a4							;	program.  Ie, it has save value as PROGRAMEND.
    109  29a4							;
    110  29a4							; A, X, and Y are all undefined on return.
    111  29a4							;
    112  29a4
    113  29a4				   findLine
    114  29a4		       ad 3d 42 	      lda	ProgramStart	;Start of program -> CURPTR
    115  29a7		       85 4f		      sta	CURPTR
    116  29a9		       ad 3e 42 	      lda	ProgramStart+1
    117  29ac		       85 50		      sta	CURPTR+1
    118  29ae							;
    119  29ae							; At end of code?
    120  29ae							;
    121  29ae				   iXFER1
    122  29ae		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  29b0		       cd 3f 42 	      cmp	ProgramEnd	; at end of program then stop run
    124  29b3		       d0 0b		      bne	xfer2	; not end
    125  29b5		       a5 50		      lda	CURPTR+1
    126  29b7		       cd 40 42 	      cmp	ProgramEnd+1
    127  29ba		       d0 04		      bne	xfer2	;Not at end
    128  29bc							;
    129  29bc							; Line not found and the end of the program was
    130  29bc							; reached.  Return Z and C both clear.
    131  29bc							;
    132  29bc		       a9 01		      lda	#1	;clear Z
    133  29be		       18		      clc		;clear C
    134  29bf		       60		      rts
    135  29c0							;
    136  29c0							; Check for an exact line number match
    137  29c0							;
    138  29c0		       a5 52	   xfer2      lda	R0
    139  29c2		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  29c4		       d1 4f		      cmp	(CURPTR),y
    141  29c6		       d0 08		      bne	xfernotit
    142  29c8		       c8		      iny
    143  29c9		       a5 53		      lda	R0+1
    144  29cb		       d1 4f		      cmp	(CURPTR),y
    145  29cd		       d0 01		      bne	xfernotit	; not a matching line number
    146  29cf							;
    147  29cf							; This is exactly the line we want.
    148  29cf							;
    149  29cf		       60		      rts		;it matches exactly
    150  29d0							;
    151  29d0							; See if this line is greater than the one we're
    152  29d0							; searching for.
    153  29d0							;
    154  29d0		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  29d2		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  29d4		       c5 53		      cmp	R0+1
    157  29d6		       90 0b		      bcc	xfer3
    158  29d8		       d0 07		      bne	xfer4
    159  29da		       88		      dey
    160  29db		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  29dd		       c5 52		      cmp	R0
    162  29df		       90 02		      bcc	xfer3
    163  29e1							;
    164  29e1							; This line is greater than the one we want, so
    165  29e1							; return Z clear and C set.
    166  29e1							;
    167  29e1		       38	   xfer4      sec		;We found a line number greater
    168  29e2		       60		      rts		;both conditions set
    169  29e3							;
    170  29e3							; Not the line (or droid) we're looking for.  Move to
    171  29e3							; the next line.
    172  29e3							;
    173  29e3		       20 e9 29    xfer3      jsr	FindNextLine
    174  29e6		       4c ae 29 	      jmp	iXFER1
    175  29e9							;
    176  29e9							;=====================================================
    177  29e9							; This advances CURPTR to the next line.  If there
    178  29e9							; are no more lines, this leaves CURPTR equal to
    179  29e9							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  29e9							; CURPTR is pointing to a valid line on entry.  This
    181  29e9							; pointer points to the two-byte line number.
    182  29e9							; Update this points to the 1 byte line length  ****************
    183  29e9							;
    184  29e9				   FindNextLine
    185  29e9		       a0 03		      ldy	#3	;skip line number and length byte
    186  29eb		       84 51		      sty	CUROFF	;this is the new offset
    187  29ed		       a0 00		      ldy	#0
    188  29ef		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  29f1		       18		      clc
    190  29f2		       65 4f		      adc	CURPTR
    191  29f4		       85 4f		      sta	CURPTR
    192  29f6		       a5 50		      lda	CURPTR+1
    193  29f8		       69 00		      adc	#0
    194  29fa		       85 50		      sta	CURPTR+1
    195  29fc		       60	   FindNext4  rts
    196  29fd							;
    197  29fd							;=====================================================
    198  29fd							; This compares CURPTR to PROGRAMEND and returns Z set
    199  29fd							; if they are equal, Z clear if not.
    200  29fd							;
    201  29fd		       a5 4f	   AtEnd      lda	CURPTR
    202  29ff		       cd 3f 42 	      cmp	ProgramEnd
    203  2a02		       d0 05		      bne	atendexit
    204  2a04		       a5 50		      lda	CURPTR+1
    205  2a06		       cd 40 42 	      cmp	ProgramEnd+1
    206  2a09		       60	   atendexit  rts
    207  2a0a							;
    208  2a0a
    209  2a0a							;
    210  2a0a							;=====================================================
    211  2a0a							; Convert an ASCII string to a number.  On input,
    212  2a0a							; (CURPTR),Y points to the first digit.  This gets
    213  2a0a							; digit-by-digit until finding a non-number.  Returns
    214  2a0a							; Y pointing to the non-digit, and R0 contains the
    215  2a0a							; number.  This does NOT check for valid ranges, so
    216  2a0a							; a value like "123456789" will produce something,
    217  2a0a							; but not what you had expected.
    218  2a0a							;
    219  2a0a		       a9 00	   getDecimal lda	#0
    220  2a0c		       85 52		      sta	R0
    221  2a0e		       85 53		      sta	R0+1
    222  2a10		       85 59		      sta	dpl	;temporary negative flag
    223  2a12							;
    224  2a12							; See if it's negative...
    225  2a12							;
    226  2a12							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  2a12		       b1 4f		      lda	(CURPTR),y
    228  2a14		       c9 2d		      cmp	#'-
    229  2a16		       d0 02		      bne	getDecLoop
    230  2a18		       e6 59		      inc	dpl	;it's negative
    231  2a1a							;
    232  2a1a		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  2a1c		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  2a1e		       c9 30		      cmp	#'0
    235  2a20		       90 36		      bcc	getDdone
    236  2a22		       c9 3a		      cmp	#'9+1
    237  2a24		       b0 32		      bcs	getDdone
    238  2a26		       38		      sec
    239  2a27		       e9 30		      sbc	#'0	;convert to binary
    240  2a29		       48		      pha
    241  2a2a							;
    242  2a2a							; Now multiply R0 by 10.  Remember that
    243  2a2a							; 2*N + 8*N = 10*N.
    244  2a2a							;
    245  2a2a		       06 52		      asl	R0
    246  2a2c		       26 53		      rol	R0+1	;*2
    247  2a2e		       a5 52		      lda	R0
    248  2a30		       85 54		      sta	R1
    249  2a32		       a5 53		      lda	R0+1
    250  2a34		       85 55		      sta	R1+1
    251  2a36		       06 52		      asl	R0
    252  2a38		       26 53		      rol	R0+1	;*4
    253  2a3a		       06 52		      asl	R0
    254  2a3c		       26 53		      rol	R0+1	;*8
    255  2a3e		       18		      clc		;now add the partial sums...
    256  2a3f		       a5 52		      lda	R0	;...to get *10
    257  2a41		       65 54		      adc	R1
    258  2a43		       85 52		      sta	R0
    259  2a45		       a5 53		      lda	R0+1
    260  2a47		       65 55		      adc	R1+1
    261  2a49		       85 53		      sta	R0+1
    262  2a4b							;
    263  2a4b							; Add in the new digit
    264  2a4b							;
    265  2a4b		       68		      pla
    266  2a4c		       18		      clc
    267  2a4d		       65 52		      adc	R0
    268  2a4f		       85 52		      sta	R0
    269  2a51		       90 02		      bcc	getD2
    270  2a53		       e6 53		      inc	R0+1
    271  2a55							;
    272  2a55							; Move to next character
    273  2a55							;
    274  2a55		       c8	   getD2      iny
    275  2a56		       d0 c2		      bne	getDecLoop
    276  2a58							;
    277  2a58							; All done with digits, so now deal with it being
    278  2a58							; negative.  If zero, then don't check for negative
    279  2a58							; flag.  Ie, -0 is stored as 0.
    280  2a58							;
    281  2a58		       a5 52	   getDdone   lda	R0
    282  2a5a		       05 53		      ora	R0+1
    283  2a5c		       f0 16		      beq	getDone2	;zero
    284  2a5e		       a5 59		      lda	dpl
    285  2a60		       f0 12		      beq	getDone2	;positive
    286  2a62							;
    287  2a62							; Invert all the bits, then add one.
    288  2a62							;
    289  2a62		       a5 52		      lda	R0
    290  2a64		       49 ff		      eor	#$ff
    291  2a66		       85 52		      sta	R0
    292  2a68		       a5 53		      lda	R0+1
    293  2a6a		       49 ff		      eor	#$ff
    294  2a6c		       85 53		      sta	R0+1
    295  2a6e							;
    296  2a6e		       e6 52		      inc	R0
    297  2a70		       d0 02		      bne	getDone2
    298  2a72		       e6 53		      inc	R0+1
    299  2a74				   getDone2
    300  2a74							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  2a74							;lda	  R0
    302  2a74							;sta	  $0010
    303  2a74							;lda	  R0+1
    304  2a74							;sta	  $0011
    305  2a74							;lda	  dpl
    306  2a74							;sta	  $012
    307  2a74
    308  2a74		       60		      rts
    309  2a75
    310  2a75							;=====================================================
    311  2a75							; Gets a line of input into LINBUF.
    312  2a75							;
    313  2a75							; On entry:
    314  2a75							;    A contains the prompt character, or 0 if none.
    315  2a75							;    X = 1 Background read
    316  2a75							;    x = 0 Forground read with wait
    317  2a75							;
    318  2a75							; On exit:
    319  2a75							;    CURPTR points to LINBUF
    320  2a75							;    LINBUF contains the line with 0 at the end.
    321  2a75							;    Y has offset to first non-space character
    322  2a75							;    CURROFF has the same as Y.
    323  2a75							;
    324  2a75		       20 c4 2a    GetLine    jsr	ReadPrompt
    325  2a78		       e0 00		      cpx	#0
    326  2a7a		       f0 14		      beq	GetLineRetry
    327  2a7c		       ae c8 35 	      ldx	taskPtr
    328  2a7f		       bd c9 35 	      lda	taskTable,x
    329  2a82		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  2a84		       d0 3d		      bne	taskWaitingIO
    331  2a86		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  2a88		       9d c9 35 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  2a8b		       ce c3 2a 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  2a8e		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  2a90
    336  2a90							;
    337  2a90							; Now read a line and wait for the CR
    338  2a90							;
    339  2a90				   GetLineRetry
    340  2a90		       a9 00		      lda	#0	;Wait for input to complete
    341  2a92		       20 dc 2a 	      jsr	ReadLine
    342  2a95
    343  2a95							;
    344  2a95							; Point to the line we just read
    345  2a95							; Set the current pointer to point to the input line
    346  2a95							;
    347  2a95		       a0 00	   ReadComplete ldy	#0
    348  2a97		       84 51		      sty	CUROFF
    349  2a99		       a2 a4		      ldx	#LINBUF&$ff
    350  2a9b		       86 4f		      stx	CURPTR
    351  2a9d		       a2 41		      ldx	#LINBUF>>8
    352  2a9f		       86 50		      stx	CURPTR+1
    353  2aa1							;
    354  2aa1							; Output a CR/LF
    355  2aa1							;
    356  2aa1		       20 a3 2c 	      jsr	CRLF
    357  2aa4							;
    358  2aa4							; If a blank line, prompt again.
    359  2aa4							;
    360  2aa4		       20 9a 2c 	      jsr	SkipSpaces
    361  2aa7		       b1 4f		      lda	(CURPTR),y
    362  2aa9		       d0 10		      bne	GetLineDone	;We have data then exit
    363  2aab		       20 c7 2a 	      jsr	ReadPromptRetry
    364  2aae		       ae c8 35 	      ldx	taskPtr	;if this task is waiting for IO
    365  2ab1		       bd c9 35 	      lda	taskTable,x	;then get out, wait for line to
    366  2ab4		       29 40		      and	#TASKWAITIO	;Complete again
    367  2ab6		       d0 0b		      bne	taskWaitingIO
    368  2ab8		       4c 90 2a 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  2abb
    370  2abb				   GetLineDone
    371  2abb		       ae c8 35 	      ldx	taskPtr
    372  2abe		       a9 80		      lda	#TASKACTIVE
    373  2ac0		       9d c9 35 	      sta	taskTable,x	;IO is complete
    374  2ac3
    375  2ac3				   taskWaitingIO
    376  2ac3		       60		      rts
    377  2ac4
    378  2ac4							;
    379  2ac4							;=======================================================================
    380  2ac4							; Display the prompt character
    381  2ac4							; On entry
    382  2ac4							;	    A contains the prompt character
    383  2ac4							; On exit
    384  2ac4							;	    The readbuffer index is reset to 0
    385  2ac4							;
    386  2ac4		       8d 2b 42    ReadPrompt sta	promptChar
    387  2ac7
    388  2ac7							;
    389  2ac7							; Prompt
    390  2ac7							;
    391  2ac7
    392  2ac7		       ad 2b 42    ReadPromptRetry lda	promptChar
    393  2aca		       09 00		      ora	#0	;any prompt?
    394  2acc		       f0 08		      beq	getlinenp
    395  2ace		       20 e7 19 	      jsr	VOUTCH
    396  2ad1		       a9 20		      lda	#$20
    397  2ad3		       20 e7 19 	      jsr	VOUTCH	;Space after prompt
    398  2ad6							;
    399  2ad6		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  2ad8		       8e 28 42 	      stx	getlinx
    401  2adb		       60		      rts
    402  2adc							;
    403  2adc							;===============================================================
    404  2adc							; This fuction is the driver for the line input
    405  2adc							; on call if a = 0 then it waits for all input
    406  2adc							;	      a = 1 then nowait for input
    407  2adc							; On exit
    408  2adc							;		       c clear if not complete line
    409  2adc							;		       c set if it was a complete line
    410  2adc
    411  2adc				   ReadLine
    412  2adc		       8d 2a 42 	      sta	inputNoWait
    413  2adf		       c9 00		      cmp	#0
    414  2ae1		       f0 05		      beq	getline1
    415  2ae3		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  2ae6		       f0 2b		      beq	GetLineNoWait
    417  2ae8		       20 ea 19    getline1   jsr	VGETCH
    418  2aeb					      if	CTMON65
    419  2aeb		       48		      pha
    420  2aec		       20 e7 19 	      jsr	VOUTCH	;echo echo echo
    421  2aef		       68		      pla
    422  2af0					      endif
    423  2af0		       c9 0d		      cmp	#CR
    424  2af2		       f0 15		      beq	getlind	;end of line
    425  2af4		       c9 08		      cmp	#BS	;backspace?
    426  2af6		       f0 1d		      beq	getlinebs
    427  2af8		       ae 28 42 	      ldx	getlinx
    428  2afb		       9d a4 41 	      sta	LINBUF,x
    429  2afe		       e8		      inx
    430  2aff		       8e 28 42 	      stx	getlinx
    431  2b02		       ad 2a 42 	      lda	inputNoWait
    432  2b05		       f0 e1		      beq	getline1
    433  2b07		       d0 0a		      bne	GetLineNoWait
    434  2b09							;
    435  2b09							; CR was hit
    436  2b09							;
    437  2b09		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  2b0b		       ae 28 42 	      ldx	getlinx
    439  2b0e		       9d a4 41 	      sta	LINBUF,x
    440  2b11
    441  2b11		       38		      sec		; Carry set then cr received
    442  2b12		       60		      rts
    443  2b13
    444  2b13				   GetLineNoWait
    445  2b13		       18		      clc		; Carry clear no end of line
    446  2b14		       60		      rts
    447  2b15							;
    448  2b15							; Backspace was hit
    449  2b15							;
    450  2b15		       ae 28 42    getlinebs  ldx	getlinx
    451  2b18		       f0 0e		      beq	getlineEOL	;at start of line
    452  2b1a		       ca		      dex
    453  2b1b		       8e 28 42 	      stx	getlinx
    454  2b1e		       20 17 21    getlinepbs jsr	puts
      0  2b21					      db	27,"[K",0
      1  2b21		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  2b25		       4c e8 2a 	      jmp	getline1
    457  2b28		       a9 20	   getlineEOL lda	#SPACE
    458  2b2a		       20 e7 19 	      jsr	VOUTCH
    459  2b2d		       d0 ef		      bne	getlinepbs
    460  2b2f							;
    461  2b2f							;=====================================================
    462  2b2f							; Count the length of the line currently in LINBUF
    463  2b2f							; starting at offset Y.  Returns the length in X.  The
    464  2b2f							; starting offset in Y should point past the ASCII
    465  2b2f							; line number.  Also counts the trailing NULL and two
    466  2b2f							; extra bytes for where the line number will be.
    467  2b2f							; Update must now include leading length byte not the null at end ****************
    468  2b2f							;
    469  2b2f				   getLineLength
    470  2b2f		       a2 00		      ldx	#0	;size
    471  2b31		       b9 a4 41    getLineL2  lda	LINBUF,y
    472  2b34		       f0 04		      beq	getLineL3
    473  2b36		       c8		      iny
    474  2b37		       e8		      inx
    475  2b38		       d0 f7		      bne	getLineL2
    476  2b3a		       e8	   getLineL3  inx		;count null at end
    477  2b3b		       e8		      inx		;line number LSB
    478  2b3c		       e8		      inx		;MSB
    479  2b3d		       e8		      inx		;change: count new leading line length
    480  2b3e		       8e 3a 42 	      stx	lineLength
    481  2b41		       60		      rts
    482  2b42							;
    483  2b42							;=====================================================
    484  2b42							; Count the length of the line pointed to by CURPTR.
    485  2b42							; This also counts the line number and the terminating
    486  2b42							; null.  Ie, this string returns 8:
    487  2b42							;
    488  2b42							; <lineLow><lineHi>Hello<null>
    489  2b42							;
    490  2b42							; Another way of looking at it: add the return value
    491  2b42							; to the CURPTR and it'll point to the next line's
    492  2b42							; line number.  Returns the value in Y.
    493  2b42							; Update to ject get the leading byte length ********************
    494  2b42							;
    495  2b42							;getCURPTRLength
    496  2b42							;		ldy	CURPTR
    497  2b42							;		ldy	#3	;change: skip line number and leading length byte
    498  2b42							;getCLineL2	lda	(CURPTR),y
    499  2b42							;		beq	getCLineL3
    500  2b42							;		iny
    501  2b42							;		bne	getCLineL2
    502  2b42							;getCLineL3	iny		;count null at end
    503  2b42							;		rts
    504  2b42
    505  2b42							;
    506  2b42							;=====================================================
    507  2b42							; This saves ILPC.  This saves to a single save area,
    508  2b42							; so it can't be called more than once.
    509  2b42							;
    510  2b42		       a5 43	   saveIL     lda	ILPC
    511  2b44		       8d 36 42 	      sta	tempIL
    512  2b47		       a5 44		      lda	ILPC+1
    513  2b49		       8d 37 42 	      sta	tempIL+1
    514  2b4c		       60		      rts
    515  2b4d							;
    516  2b4d							;=====================================================
    517  2b4d							; This restores ILPC.
    518  2b4d							;
    519  2b4d		       ad 36 42    restoreIL  lda	tempIL
    520  2b50		       85 43		      sta	ILPC
    521  2b52		       ad 37 42 	      lda	tempIL+1
    522  2b55		       85 44		      sta	ILPC+1
    523  2b57		       60		      rts
    524  2b58							;
    525  2b58							;=====================================================
    526  2b58							; This pushes R0 onto the stack.
    527  2b58							;
    528  2b58		       8c 31 42    pushR0     sty	rtemp1
    529  2b5b		       a4 4a		      ldy	MATHSTACKPTR
    530  2b5d		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  2b5f		       b0 38		      bcs	pusherr
    532  2b61		       a5 52		      lda	R0
    533  2b63		       91 48		      sta	(MATHSTACK),y
    534  2b65		       c8		      iny
    535  2b66		       a5 53		      lda	R0+1
    536  2b68		       91 48		      sta	(MATHSTACK),y
    537  2b6a		       c8		      iny
    538  2b6b		       84 4a		      sty	MATHSTACKPTR
    539  2b6d		       ac 31 42 	      ldy	rtemp1
    540  2b70		       18		      clc
    541  2b71		       60		      rts
    542  2b72
    543  2b72							;=====================================================
    544  2b72							; This pushes curptr basic current line onto the call stack.
    545  2b72							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  2b72
    547  2b72				   pushLN
    548  2b72		       8d 32 42 	      STA	rtemp1+1	; Store type of push being done
    549  2b75		       8c 31 42 	      sty	rtemp1
    550  2b78		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  2b7a		       c5 4d		      cmp	GOSUBSTACKPTR
    552  2b7c		       90 1b		      bcc	pusherr	; No error
    553  2b7e		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  2b80		       a2 00		      ldx	#0	; Start of bytes to copy
    555  2b82				   pushLoop
    556  2b82		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  2b84		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  2b86		       c8		      iny		; Next destination
    559  2b87		       e8		      inx		; Next Source byte
    560  2b88		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  2b8a		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  2b8c
    563  2b8c		       ad 32 42    pushDone   lda	rtemp1+1	; Type of stack entry
    564  2b8f		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  2b91		       c8		      iny		; Next entry
    566  2b92
    567  2b92		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  2b94		       ac 31 42 	      ldy	rtemp1
    569  2b97		       18		      clc
    570  2b98		       60		      rts
    571  2b99				   pusherr
    572  2b99		       38		      sec
    573  2b9a		       60		      rts
    574  2b9b							;=====================================================
    575  2b9b							; This pops Top Off gosub call Stack and
    576  2b9b							; places it in CURPTR/CUROFF.
    577  2b9b							; This checks if the type = 1 GOSUB
    578  2b9b							; if not it removes what ever is on the stack
    579  2b9b							; until it finds the next return. Allowing
    580  2b9b							; a return from within a for/next
    581  2b9b							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  2b9b		       8c 31 42    popLN      sty	rtemp1
    583  2b9e		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  2ba0		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  2ba2
    586  2ba2				   popContinue
    587  2ba2		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  2ba4		       90 22		      bcc	poperr	; Process an error
    589  2ba6
    590  2ba6		       88		      dey		; Position to read entry type
    591  2ba7		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  2ba9		       8d 32 42 	      sta	rtemp1+1	; Save to be returned
    593  2bac		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  2bae		       f0 04		      beq	popLoop	; Restore the line
    595  2bb0		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  2bb2		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  2bb4
    598  2bb4				   popLoop
    599  2bb4		       88		      dey
    600  2bb5		       ca		      dex
    601  2bb6		       b1 4b		      lda	(GOSUBSTACK),y
    602  2bb8		       95 4f		      sta	CURPTR,x
    603  2bba		       e0 00		      cpx	#0
    604  2bbc		       d0 f6		      bne	popLoop	; Loop until all moved
    605  2bbe
    606  2bbe
    607  2bbe		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  2bc0		       ac 31 42 	      ldy	rtemp1
    609  2bc3		       ad 32 42 	      lda	rtemp1+1	; get the type of return
    610  2bc6		       18		      clc
    611  2bc7		       60		      rts
    612  2bc8
    613  2bc8		       38	   poperr     sec
    614  2bc9		       60		      rts
    615  2bca
    616  2bca		       88	   popSkipEntry dey
    617  2bcb		       88		      dey
    618  2bcc		       88		      dey
    619  2bcd		       4c a2 2b 	      jmp	popContinue
    620  2bd0
    621  2bd0							;
    622  2bd0							;=====================================================
    623  2bd0							; This pushes R1 onto the stack
    624  2bd0							;
    625  2bd0		       8c 31 42    pushR1     sty	rtemp1
    626  2bd3		       a4 4a		      ldy	MATHSTACKPTR
    627  2bd5		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  2bd7		       b0 ef		      bcs	poperr
    629  2bd9		       a5 54		      lda	R1
    630  2bdb		       91 48		      sta	(MATHSTACK),y
    631  2bdd		       c8		      iny
    632  2bde		       a5 55		      lda	R1+1
    633  2be0		       91 48		      sta	(MATHSTACK),y
    634  2be2		       c8		      iny
    635  2be3		       84 4a		      sty	MATHSTACKPTR
    636  2be5		       ac 31 42 	      ldy	rtemp1
    637  2be8		       18		      clc
    638  2be9		       60		      rts
    639  2bea							;
    640  2bea							;=====================================================
    641  2bea							; This pops Top Of Stack and places it in R0.
    642  2bea							;
    643  2bea		       8c 31 42    popR0      sty	rtemp1
    644  2bed		       a4 4a		      ldy	MATHSTACKPTR
    645  2bef		       f0 d7		      beq	poperr
    646  2bf1		       88		      dey
    647  2bf2		       b1 48		      lda	(MATHSTACK),y
    648  2bf4		       85 53		      sta	R0+1
    649  2bf6		       88		      dey
    650  2bf7		       b1 48		      lda	(MATHSTACK),y
    651  2bf9		       85 52		      sta	R0
    652  2bfb		       84 4a		      sty	MATHSTACKPTR
    653  2bfd		       ac 31 42 	      ldy	rtemp1
    654  2c00		       18		      clc
    655  2c01		       60		      rts
    656  2c02
    657  2c02							;
    658  2c02							;=====================================================
    659  2c02							; This pops TOS and places it in R1.
    660  2c02							;
    661  2c02		       8c 31 42    popR1      sty	rtemp1
    662  2c05		       a4 4a		      ldy	MATHSTACKPTR
    663  2c07		       f0 bf		      beq	poperr
    664  2c09		       88		      dey
    665  2c0a		       b1 48		      lda	(MATHSTACK),y
    666  2c0c		       85 55		      sta	R1+1
    667  2c0e		       88		      dey
    668  2c0f		       b1 48		      lda	(MATHSTACK),y
    669  2c11		       85 54		      sta	R1
    670  2c13		       84 4a		      sty	MATHSTACKPTR
    671  2c15		       ac 31 42 	      ldy	rtemp1
    672  2c18		       60		      rts
    673  2c19							;
    674  2c19							;=====================================================
    675  2c19							; This pops TOS and places it in MQ.
    676  2c19							;
    677  2c19		       8c 31 42    popMQ      sty	rtemp1
    678  2c1c		       a4 4a		      ldy	MATHSTACKPTR
    679  2c1e		       f0 a8		      beq	poperr
    680  2c20		       88		      dey
    681  2c21		       b1 48		      lda	(MATHSTACK),y
    682  2c23		       85 57		      sta	MQ+1
    683  2c25		       88		      dey
    684  2c26		       b1 48		      lda	(MATHSTACK),y
    685  2c28		       85 56		      sta	MQ
    686  2c2a		       84 4a		      sty	MATHSTACKPTR
    687  2c2c		       ac 31 42 	      ldy	rtemp1
    688  2c2f		       60		      rts
    689  2c30							;
    690  2c30							;=====================================================
    691  2c30							; This assists with multiplication and division by
    692  2c30							; looking at R0 and R1 and saving a flag as to what
    693  2c30							; sign the result will be.  Math is always done on
    694  2c30							; positive numbers, so this converts negative numbers
    695  2c30							; into positives.  On exit, R0 and R1 are both
    696  2c30							; positive.  If the signs were different then 'signs'
    697  2c30							; will be non-zero.
    698  2c30							;
    699  2c30		       a9 00	   SaveSigns  lda	#0
    700  2c32		       8d 30 42 	      sta	sign	;assume positive
    701  2c35		       a5 53		      lda	R0+1	;MSB
    702  2c37		       10 13		      bpl	SaveSigns1
    703  2c39		       ee 30 42 	      inc	sign	;it's negative
    704  2c3c		       49 ff		      eor	#$ff	;flip bits
    705  2c3e		       85 53		      sta	R0+1
    706  2c40		       a5 52		      lda	R0
    707  2c42		       49 ff		      eor	#$ff
    708  2c44		       85 52		      sta	R0
    709  2c46		       e6 52		      inc	R0
    710  2c48		       d0 02		      bne	SaveSigns1
    711  2c4a		       e6 53		      inc	R0+1
    712  2c4c		       a5 55	   SaveSigns1 lda	R1+1
    713  2c4e		       10 1a		      bpl	SaveSigns2
    714  2c50		       48		      pha
    715  2c51		       ad 30 42 	      lda	sign
    716  2c54		       49 01		      eor	#1
    717  2c56		       8d 30 42 	      sta	sign
    718  2c59		       68		      pla
    719  2c5a		       49 ff		      eor	#$ff	;flip bits
    720  2c5c		       85 55		      sta	R1+1
    721  2c5e		       a5 54		      lda	R1
    722  2c60		       49 ff		      eor	#$ff
    723  2c62		       85 54		      sta	R1
    724  2c64		       e6 54		      inc	R1
    725  2c66		       d0 02		      bne	SaveSigns2
    726  2c68		       e6 55		      inc	R1+1
    727  2c6a		       60	   SaveSigns2 rts
    728  2c6b							;
    729  2c6b							;=====================================================
    730  2c6b							; This looks at the value of 'signs' and will convert
    731  2c6b							; both R0 and R1 to negative if set.
    732  2c6b							;
    733  2c6b				   RestoreSigns
    734  2c6b		       ad 30 42 	      lda	sign
    735  2c6e		       f0 28		      beq	restoresigns2
    736  2c70							;
    737  2c70		       a5 52		      lda	R0
    738  2c72		       d0 02		      bne	restoresigns3
    739  2c74		       c6 53		      dec	R0+1
    740  2c76				   restoresigns3
    741  2c76		       c6 52		      dec	R0
    742  2c78		       a5 52		      lda	R0
    743  2c7a		       49 ff		      eor	#$ff
    744  2c7c		       85 52		      sta	R0
    745  2c7e		       a5 53		      lda	R0+1
    746  2c80		       49 ff		      eor	#$ff
    747  2c82		       85 53		      sta	R0+1
    748  2c84							;
    749  2c84		       a5 54		      lda	R1
    750  2c86		       d0 02		      bne	restoresigns4
    751  2c88		       c6 55		      dec	R1+1
    752  2c8a				   restoresigns4
    753  2c8a		       c6 54		      dec	R1
    754  2c8c		       a5 54		      lda	R1
    755  2c8e		       49 ff		      eor	#$ff
    756  2c90		       85 54		      sta	R1
    757  2c92		       a5 55		      lda	R1+1
    758  2c94		       49 ff		      eor	#$ff
    759  2c96		       85 55		      sta	R1+1
    760  2c98							;
    761  2c98				   restoresigns2
    762  2c98		       60		      rts
    763  2c99							;
    764  2c99							;=====================================================
    765  2c99							; Skip over spaces.  Returns Y with the offset to
    766  2c99							; either the last character in the line, or the first
    767  2c99							; non-space character.
    768  2c99							;
    769  2c99
    770  2c99		       c8	   skipsp2    iny
    771  2c9a		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  2c9c		       f0 04		      beq	Skip3	;end of line
    773  2c9e		       c9 20		      cmp	#SPACE
    774  2ca0		       f0 f7		      beq	skipsp2
    775  2ca2		       60	   Skip3      rts
    776  2ca3							;*********************************************************
    777  2ca3							; Output a CR/LF combination to the console.  Preserves
    778  2ca3							; all registers.
    779  2ca3							;
    780  2ca3		       48	   tbcrlf     pha
    781  2ca4		       a9 0d		      lda	#CR
    782  2ca6		       20 e7 19 	      jsr	VOUTCH
    783  2ca9		       a9 0a		      lda	#LF
    784  2cab		       20 e7 19 	      jsr	VOUTCH
    785  2cae		       68		      pla
    786  2caf		       60		      rts
    787  2cb0							;
    788  2cb0							;=====================================================
    789  2cb0							; Some logic to print the Line of basic code being executed
    790  2cb0		       24 40	   idbgBasic  bit	ILTrace
    791  2cb2		       50 75		      bvc	dbgBasicNone
    792  2cb4		       98		      tya
    793  2cb5		       48		      pha
    794  2cb6		       20 38 2e 	      jsr	SetOutDebug
    795  2cb9
    796  2cb9		       a5 4f		      lda	CURPTR
    797  2cbb		       85 59		      sta	dpl
    798  2cbd		       a5 50		      lda	CURPTR+1
    799  2cbf		       85 5a		      sta	dpl+1
    800  2cc1
    801  2cc1		       20 af 21 	      jsr	PrintProgramLine
    802  2cc4
    803  2cc4		       a5 40		      lda	ILTrace
    804  2cc6		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  2cc8		       f0 5a		      beq	dbgBasicDone
    806  2cca		       20 4f 2e 	      jsr	SetInDebug
    807  2ccd		       20 17 21 	      jsr	puts
      0  2cd0					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  2cd0		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  2d0d				   dbgBasicLoop
    810  2d0d		       20 ea 19 	      jsr	VGETCH
    811  2d10		       20 a3 2c 	      jsr	CRLF
    812  2d13		       20 73 2e 	      jsr	SetInDebugEnd
    813  2d16
    814  2d16		       c9 73		      cmp	#'s	; Quit program
    815  2d18		       f0 12		      beq	dbgBasicStop
    816  2d1a
    817  2d1a		       c9 64		      cmp	#'d	; Display Variables
    818  2d1c		       d0 06		      bne	dbgBasicDone
    819  2d1e
    820  2d1e		       20 72 21 	      jsr	PrintAllVars
    821  2d21		       18		      clc
    822  2d22		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  2d24
    824  2d24		       20 66 2e    dbgBasicDone jsr	SetOutDebugEnd
    825  2d27		       68		      pla
    826  2d28		       a8		      tay
    827  2d29		       4c b1 02    dbgBasicNone jmp	NextIL
    828  2d2c
    829  2d2c				   dbgBasicStop
    830  2d2c		       20 66 2e 	      jsr	SetOutDebugEnd
    831  2d2f		       68		      pla
    832  2d30		       a8		      tay
    833  2d31		       4c 02 06 	      jmp	iFIN
    834  2d34							;
    835  2d34							;=====================================================
    836  2d34							; This is some debug logic which displays the current
    837  2d34							; value of the ILPC and the line buffer.
    838  2d34							;
    839  2d34		       24 40	   dbgLine    bit	ILTrace
    840  2d36		       30 01		      bmi	dbgPrt
    841  2d38		       60		      rts
    842  2d39				   dbgPrt
    843  2d39		       20 38 2e 	      jsr	SetOutDebug
    844  2d3c		       20 17 21 	      jsr	puts
      0  2d3f					      db	"ILPC:",0
      1  2d3f		       49 4c 50 43*	      .byte.b	"ILPC:",0
    846  2d45		       a5 44		      lda	ILPC+1
    847  2d47		       20 fa 20 	      jsr	OUTHEX
    848  2d4a		       a5 43		      lda	ILPC
    849  2d4c		       20 fa 20 	      jsr	OUTHEX
    850  2d4f		       a9 20		      lda	#SPACE
    851  2d51		       20 e7 19 	      jsr	VOUTCH
    852  2d54
    853  2d54		       a0 00		      ldy	#0
    854  2d56		       b1 43		      lda	(ILPC),y	;Get the il pcode value
    855  2d58					      if	IL_DEBUG_TEXT
    856  2d58		       20 f8 18 	      jsr	PrintILText
    857  2d5b				  -	      else
    858  2d5b				  -	      jsr	OUTHEX
    859  2d5b					      endif
    860  2d5b		       20 17 21 	      jsr	puts
      0  2d5e					      db	" ILSP:",0
      1  2d5e		       20 49 4c 53*	      .byte.b	" ILSP:",0
    862  2d65		       a5 47		      lda	ILSTACKPTR
    863  2d67		       20 fa 20 	      jsr	OUTHEX
    864  2d6a		       a9 20		      lda	#SPACE
    865  2d6c		       20 e7 19 	      jsr	VOUTCH
    866  2d6f
    867  2d6f							; Display the CURPTR value and offset
    868  2d6f							;
    869  2d6f		       20 17 21 	      jsr	puts
      0  2d72					      db	", CURPTR: ",0
      1  2d72		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    871  2d7d		       a5 50		      lda	CURPTR+1
    872  2d7f		       20 fa 20 	      jsr	OUTHEX
    873  2d82		       a5 4f		      lda	CURPTR
    874  2d84		       20 fa 20 	      jsr	OUTHEX
    875  2d87		       a9 2b		      lda	#'+
    876  2d89		       20 e7 19 	      jsr	VOUTCH
    877  2d8c		       a5 51		      lda	CUROFF
    878  2d8e		       20 fa 20 	      jsr	OUTHEX
    879  2d91							;
    880  2d91		       20 a3 2c 	      jsr	CRLF
    881  2d94		       20 66 2e 	      jsr	SetOutDebugEnd
    882  2d97		       20 ca 2d 	      jsr	ILChkRange
    883  2d9a		       b0 02		      bcs	dbgLineErr
    884  2d9c		       18		      clc
    885  2d9d		       60		      rts
    886  2d9e
    887  2d9e				   dbgLineErr
    888  2d9e		       20 38 2e 	      jsr	SetOutDebug
    889  2da1		       20 17 21 	      jsr	puts
      0  2da4					      db	"Outside Valid IL Address Range",CR,LF,0
      1  2da4		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    891  2dc5		       20 66 2e 	      jsr	SetOutDebugEnd
    892  2dc8		       38		      sec
    893  2dc9		       60		      rts
    894  2dca
    895  2dca		       a5 44	   ILChkRange lda	ILPC+1
    896  2dcc		       c9 31		      cmp	#IL>>8
    897  2dce		       90 18		      bcc	ILBadRange
    898  2dd0		       d0 06		      bne	ILChkHigh
    899  2dd2
    900  2dd2		       a5 43		      lda	ILPC
    901  2dd4		       c9 1c		      cmp	#IL&$ff
    902  2dd6		       90 10		      bcc	ILBadRange
    903  2dd8
    904  2dd8		       a5 44	   ILChkHigh  lda	ILPC+1
    905  2dda		       c9 35		      cmp	#ILEND>>8
    906  2ddc		       90 08		      bcc	ILGoodRange
    907  2dde		       d0 08		      bne	ILBadRange
    908  2de0
    909  2de0		       a5 43		      lda	ILPC
    910  2de2		       c9 75		      cmp	#ILEND&$ff
    911  2de4		       b0 02		      bcs	ILBadRange
    912  2de6
    913  2de6		       18	   ILGoodRange clc
    914  2de7		       60		      rts
    915  2de8				   ILBadRange
    916  2de8		       38		      sec
    917  2de9		       60		      rts
    918  2dea
    919  2dea
    920  2dea							;=====================================================
    921  2dea							; Set output vector to the console output function
    922  2dea							;
    923  2dea				   SetOutConsole
    924  2dea		       48		      pha
    925  2deb		       a9 0c		      lda	#OUTCH&$ff
    926  2ded		       8d 7a 35 	      sta	BOutVec
    927  2df0		       a9 f0		      lda	#OUTCH>>8
    928  2df2		       8d 7b 35 	      sta	BOutVec+1
    929  2df5		       68		      pla
    930  2df6		       60		      rts
    931  2df7
    932  2df7				   SetInConsole
    933  2df7		       48		      pha
    934  2df8		       a9 09		      lda	#GETCH&$ff
    935  2dfa		       8d 78 35 	      sta	BInVec
    936  2dfd		       a9 f0		      lda	#GETCH>>8
    937  2dff		       8d 79 35 	      sta	BInVec+1
    938  2e02		       68		      pla
    939  2e03		       60		      rts
    940  2e04
    941  2e04
    942  2e04
    943  2e04							;====================================================
    944  2e04							;Clear the terminal assume it is ansii or vt100
    945  2e04							;
    946  2e04				   iCLEARSCREEN
    947  2e04		       20 17 21 	      jsr	puts
      0  2e07					      db	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,0
      1  2e07		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,0
    949  2e12		       4c b1 02 	      jmp	NextIL
    950  2e15
    951  2e15							;====================================================
    952  2e15							; Push true and false onto math stack
    953  2e15				   pushTrue
    954  2e15		       a9 ff		      lda	#$ff
    955  2e17		       85 52	   pushTF     sta	R0
    956  2e19		       85 53		      sta	R0+1
    957  2e1b		       20 58 2b 	      jsr	pushR0
    958  2e1e		       60		      rts
    959  2e1f		       a9 00	   pushFalse  lda	#0
    960  2e21		       f0 f4		      beq	pushTF
    961  2e23
    962  2e23							;======================================================
    963  2e23							; Copy stack top to R1
    964  2e23				   CopyStackR1
    965  2e23		       98		      tya
    966  2e24		       48		      pha
    967  2e25		       a4 4a		      ldy	MATHSTACKPTR
    968  2e27		       88		      dey
    969  2e28		       b1 48		      lda	(MATHSTACK),y
    970  2e2a		       85 55		      sta	R1+1
    971  2e2c		       88		      dey
    972  2e2d		       b1 48		      lda	(MATHSTACK),y
    973  2e2f		       85 54		      sta	R1
    974  2e31		       68		      pla
    975  2e32		       a8		      tay
    976  2e33		       60		      rts
    977  2e34
    978  2e34
    979  2e34							;====================================================
    980  2e34							;Swap the out debug call for standard calls
    981  2e34		       00 00	   DebugIOSave ds	2
    982  2e36		       00 00	   DebugInSave ds	2
    983  2e38				   SetOutDebug
    984  2e38		       ad 7a 35 	      lda	BOutVec
    985  2e3b		       8d 34 2e 	      sta	DebugIOSave
    986  2e3e		       ad 7b 35 	      lda	BOutVec+1
    987  2e41		       8d 35 2e 	      sta	DebugIOSave+1
    988  2e44		       a9 cc		      lda	#OUTDEBUG&$ff	; Put the Debug output
    989  2e46		       8d 7a 35 	      sta	BOutVec
    990  2e49		       a9 2e		      lda	#OUTDEBUG>>8
    991  2e4b		       8d 7b 35 	      sta	BOutVec+1
    992  2e4e		       60		      rts
    993  2e4f				   SetInDebug
    994  2e4f		       ad 78 35 	      lda	BInVec
    995  2e52		       8d 36 2e 	      sta	DebugInSave
    996  2e55		       ad 79 35 	      lda	BInVec+1
    997  2e58		       8d 37 2e 	      sta	DebugInSave+1
    998  2e5b		       a9 d0		      lda	#INDEBUG&$ff
    999  2e5d		       8d 78 35 	      sta	BInVec
   1000  2e60		       a9 2e		      lda	#INDEBUG>>8
   1001  2e62		       8d 79 35 	      sta	BInVec+1
   1002  2e65		       60		      rts
   1003  2e66				   SetOutDebugEnd
   1004  2e66		       ad 34 2e 	      lda	DebugIOSave
   1005  2e69		       8d 7a 35 	      sta	BOutVec
   1006  2e6c		       ad 35 2e 	      lda	DebugIOSave+1
   1007  2e6f		       8d 7b 35 	      sta	BOutVec+1
   1008  2e72		       60		      rts
   1009  2e73				   SetInDebugEnd
   1010  2e73		       ad 36 2e 	      lda	DebugInSave
   1011  2e76		       8d 78 35 	      sta	BInVec
   1012  2e79		       ad 37 2e 	      lda	DebugInSave+1
   1013  2e7c		       8d 79 35 	      sta	BInVec+1
   1014  2e7f		       60		      rts
   1015  2e80							;
   1016  2e80							;====================================================
   1017  2e80							; Set the input and output terminal address
   1018  2e80							; The math stack stack byte is the output io slot
   1019  2e80							; The math stack  is the input io slot
   1020  2e80
   1021  2e80				   iSetTerminal
   1022  2e80		       20 ea 2b 	      jsr	popR0	; Process the output io addresses
   1023  2e83		       20 ad 2e 	      jsr	CalcSlot
   1024  2e86		       a5 52		      lda	R0
   1025  2e88		       09 01		      ora	#1
   1026  2e8a		       8d cd 2e 	      sta	TerminalOutputPort
   1027  2e8d		       a5 53		      lda	R0+1
   1028  2e8f		       8d ce 2e 	      sta	TerminalOutputPort+1
   1029  2e92
   1030  2e92		       20 ea 2b 	      jsr	popR0	; Process the input io address
   1031  2e95		       20 ad 2e 	      jsr	CalcSlot
   1032  2e98		       a5 52		      lda	R0
   1033  2e9a		       8d d1 2e 	      sta	TerminalStatusPort
   1034  2e9d		       09 01		      ora	#1
   1035  2e9f		       8d d8 2e 	      sta	TerminalInputPort
   1036  2ea2		       a5 53		      lda	R0+1
   1037  2ea4		       8d d9 2e 	      sta	TerminalInputPort+1
   1038  2ea7		       8d d2 2e 	      sta	TerminalStatusPort+1
   1039  2eaa		       4c b1 02 	      jmp	NextIL
   1040  2ead
   1041  2ead							;===================================================
   1042  2ead							; Calculate the slot address the the slot number
   1043  2ead							; R0 contains the slot number 0-255
   1044  2ead
   1045  2ead				   CalcSlot
   1046  2ead		       8a		      txa
   1047  2eae		       48		      pha
   1048  2eaf
   1049  2eaf		       a2 04		      ldx	#4
   1050  2eb1				   CalcSlotLoop
   1051  2eb1		       18		      clc
   1052  2eb2		       26 52		      rol	R0
   1053  2eb4		       26 53		      rol	R0+1
   1054  2eb6		       ca		      dex
   1055  2eb7		       d0 f8		      bne	CalcSlotLoop
   1056  2eb9
   1057  2eb9		       a9 e0		      lda	#$E0
   1058  2ebb		       05 53		      ora	R0+1
   1059  2ebd		       85 53		      sta	R0+1
   1060  2ebf		       68		      pla
   1061  2ec0
   1062  2ec0		       aa		      tax
   1063  2ec1		       60		      rts
   1064  2ec2							;
   1065  2ec2							;====================================================
   1066  2ec2							; Output to the Terminal/Debug console
   1067  2ec2							;     x = high address byte
   1068  2ec2							;     y = low address byte
   1069  2ec2							;     a = Terminator for string
   1070  2ec2				   TerminalWrite
   1071  2ec2				   DebugWrite
   1072  2ec2		       20 38 2e 	      jsr	SetOutDebug
   1073  2ec5		       20 55 21 	      jsr	PrtStr
   1074  2ec8		       20 66 2e 	      jsr	SetOutDebugEnd
   1075  2ecb		       60		      rts
   1076  2ecc
   1077  2ecc				   TerminalIOblock
   1078  2ecc				   OUTDEBUG
   1079  2ecc		       8d		      .byte.b	$8D	; STA
   1080  2ecd				   TerminalOutputPort
   1081  2ecd		       21 e0	   DEBUGPORT  .word.w	$E021	; Dont check anything just output the byte
   1082  2ecf		       60		      RTS
   1083  2ed0
   1084  2ed0				   TerminalRead
   1085  2ed0				   INDEBUG
   1086  2ed0		       ad		      .byte.b	$AD	; LDA
   1087  2ed1				   TerminalStatusPort
   1088  2ed1		       20 e0	   DEBUGPORTSTATUS .word.w	$E020
   1089  2ed3
   1090  2ed3		       29 01		      and	#$01
   1091  2ed5		       f0 f9		      beq	INDEBUG
   1092  2ed7
   1093  2ed7		       ad		      .byte.b	$AD	; LDA
   1094  2ed8				   TerminalInputPort
   1095  2ed8		       21 e0	   DEBUGPORTIN .word.w	$E021
   1096  2eda		       60		      rts
   1097  2edb				   TerminalIOblockEnd
   1098  2edb							;======================================================================
   1099  2edb							;Copy Quoted string to buffer, terminate with 0 byte
   1100  2edb							; R0  Source tring points to tString type
   1101  2edb							; x is terminator
   1102  2edb							; R1 points to destinition location
   1103  2edb							; On exit R0 contains length of copy Plus Term and leading bytes
   1104  2edb
   1105  2edb				   qstrcpy
   1106  2edb		       20 58 2b 	      jsr	pushR0
   1107  2ede		       20 2b 2f 	      jsr	IncR0	; point past the tString
   1108  2ee1		       20 2b 2f 	      jsr	IncR0	; Point Past the opening "
   1109  2ee4		       a2 22		      ldx	#'"	; copy Termination
   1110  2ee6		       20 00 2f 	      jsr	pstrcpy
   1111  2ee9		       20 2b 2f 	      jsr	IncR0	; point to "
   1112  2eec		       20 2b 2f 	      jsr	IncR0	; Point to next free byte
   1113  2eef		       20 02 2c 	      jsr	popR1
   1114  2ef2		       38		      sec
   1115  2ef3		       a5 52		      lda	R0
   1116  2ef5		       e5 54		      sbc	R1
   1117  2ef7		       85 52		      sta	R0
   1118  2ef9		       a5 53		      lda	R0+1
   1119  2efb		       e5 55		      sbc	R1+1
   1120  2efd		       85 53		      sta	R0+1
   1121  2eff		       60		      rts
   1122  2f00
   1123  2f00							;=========================================================================
   1124  2f00							;Copy string from R0 to R1, terminator in x
   1125  2f00							; On exit    R0 contains the length of the copy
   1126  2f00				   pstrcpy
   1127  2f00		       a0 00		      ldy	#0
   1128  2f02		       86 58		      stx	R2
   1129  2f04
   1130  2f04				   strcpyLoop
   1131  2f04		       b1 52		      lda	(R0),y
   1132  2f06		       c5 58		      cmp	R2
   1133  2f08		       f0 0a		      beq	strcpyDone
   1134  2f0a		       91 54		      sta	(R1),y
   1135  2f0c		       20 2b 2f 	      jsr	IncR0
   1136  2f0f		       20 19 2f 	      jsr	IncR1
   1137  2f12		       90 f0		      bcc	strcpyLoop
   1138  2f14				   strcpyDone
   1139  2f14		       a9 00		      lda	#0
   1140  2f16		       91 54		      sta	(R1),y
   1141  2f18
   1142  2f18		       60		      rts
   1143  2f19
   1144  2f19							;=========================================================================
   1145  2f19							; on exit c is set on overflow
   1146  2f19				   IncR1
   1147  2f19		       48		      pha
   1148  2f1a		       18		      clc
   1149  2f1b		       a9 01		      lda	#1
   1150  2f1d		       65 54		      adc	R1
   1151  2f1f		       85 54		      sta	R1
   1152  2f21		       90 06		      bcc	IncR1Done
   1153  2f23		       a9 00		      lda	#0
   1154  2f25		       65 55		      adc	R1+1
   1155  2f27		       85 55		      sta	R1+1
   1156  2f29				   IncR1Done
   1157  2f29		       68		      pla
   1158  2f2a		       60		      rts
   1159  2f2b							;=========================================================================
   1160  2f2b							; on exit c is set on overflow
   1161  2f2b				   IncR0
   1162  2f2b		       48		      pha
   1163  2f2c		       18		      clc
   1164  2f2d		       a9 01		      lda	#1
   1165  2f2f		       65 52		      adc	R0
   1166  2f31		       85 52		      sta	R0
   1167  2f33		       90 06		      bcc	IncR0Done
   1168  2f35		       a9 00		      lda	#0
   1169  2f37		       65 53		      adc	R0+1
   1170  2f39		       85 53		      sta	R0+1
   1171  2f3b				   IncR0Done
   1172  2f3b		       68		      pla
   1173  2f3c		       60		      rts
   1174  2f3d
   1175  2f3d
   1176  2f3d
   1177  2f3d
   1178  2f3d
   1179  2f3d
   1180  2f3d
   1181  2f3d
   1182  2f3d
   1183  2f3d
   1184  2f3d
   1185  2f3d
   1186  2f3d
   1187  2f3d
   1188  2f3d
   1189  2f3d
------- FILE mytb.asm
   2480  2f3d
   2481  2f3d					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  2f3d					      include	"storage.asm"
      1  2f3d							;
      2  2f3d							;=====================================================
      3  2f3d							;=====================================================
      4  2f3d							;=====================================================
      5  2f3d							; This file contains the functions for saving and
      6  2f3d							; restoring programs from some sort of mass storage
      7  2f3d							; device.  This particular version is for using the
      8  2f3d							; Corsham Tech SD Card System.
      9  2f3d							;=====================================================
     10  2f3d							;=====================================================
     11  2f3d							;=====================================================
     12  2f3d
     13 U3586					      seg.u	TBData
     14 U3586		       00	   diskBufLength ds	1
     15 U3587		       00	   diskBufOffset ds	1
     16 U3588		       00 00 00 00*DiskFileName ds	64
     17 U35c8
     18  2f3d					      SEG	Code
     19  2f3d
     20  2f3d							;
     21  2f3d							;=====================================================
     22  2f3d							; Open a file for reading as a program.  The next
     23  2f3d							; thing on the line should be the filename.
     24  2f3d							;
     25  2f3d				   iOPENREAD
     26  2f3d					      if	XKIM || CTMON65
     27  2f3d		       20 57 2f 	      jsr	setFileName	;Set the file name to open
     28  2f40		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  2f43		       90 07		      bcc	Ropenok	;branch if opened ok
     30  2f45							;
     31  2f45							; Open failed
     32  2f45							;
     33  2f45		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  2f47		       a9 00	   Rdfail2    lda	#0
     35  2f49		       4c 7d 06 	      jmp	iErr2
     36  2f4c							;
     37  2f4c							; Clear counts and offsets so the next read will
     38  2f4c							; cause the file to be read.
     39  2f4c							;
     40  2f4c		       a9 00	   Ropenok    lda	#0
     41  2f4e		       8d 87 35 	      sta	diskBufOffset
     42  2f51		       8d 86 35 	      sta	diskBufLength
     43  2f54		       4c b1 02 	      jmp	NextIL
     44  2f57					      endif
     45  2f57
     46  2f57							;===============================================================
     47  2f57							; Set file name
     48  2f57				   setFileName
     49  2f57		       a4 51		      ldy	CUROFF
     50  2f59		       b1 4f		      lda	(CURPTR),y
     51  2f5b		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  2f5d		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  2f5f
     54  2f5f		       18		      clc
     55  2f60		       98		      tya
     56  2f61		       65 4f		      adc	CURPTR
     57  2f63		       85 52		      sta	R0	;LSB
     58  2f65		       a5 50		      lda	CURPTR+1
     59  2f67		       69 00		      adc	#0
     60  2f69		       85 53		      sta	R0+1
     61  2f6b		       a9 88		      lda	#DiskFileName&$ff
     62  2f6d		       85 54		      sta	R1
     63  2f6f		       a9 35		      lda	#DiskFileName>>8
     64  2f71		       85 55		      sta	R1+1
     65  2f73		       20 db 2e 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  2f76		       a5 52		      lda	R0
     67  2f78		       18		      clc
     68  2f79		       65 51		      adc	CUROFF	; add the current offset
     69  2f7b		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  2f7d				   ResetFileName
     71  2f7d		       a0 88		      ldy	#DiskFileName&$ff
     72  2f7f		       a2 35		      ldx	#DiskFileName>>8
     73  2f81		       18		      clc
     74  2f82		       60		      rts
     75  2f83
     76  2f83				   setFileNameNotFound
     77  2f83		       68		      pla
     78  2f84		       68		      pla		; remove the return address from the stack
     79  2f85		       a9 00		      lda	#0
     80  2f87		       a2 09		      ldx	#ERR_NO_FILENAME
     81  2f89		       4c 7d 06 	      jmp	iErr2
     82  2f8c
     83  2f8c							;
     84  2f8c							;==============================JUSTLOSTINTIME 08/02/2022========
     85  2f8c							;Remove a file from the disk
     86  2f8c				   iRMFILE
     87  2f8c					      if	XKIM || CTMON65
     88  2f8c		       20 57 2f 	      jsr	setFileName
     89  2f8f		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  2f92		       90 07		      bcc	wrmOk	;branch if removed ok
     91  2f94		       a9 00		      lda	#0
     92  2f96		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  2f98		       4c 7d 06 	      jmp	iErr2
     94  2f9b				   wrmOk
     95  2f9b		       4c b1 02 	      jmp	NextIL
     96  2f9e
     97  2f9e					      endif
     98  2f9e							;
     99  2f9e							;=====================================================
    100  2f9e				   iOPENWRITE
    101  2f9e					      if	XKIM || CTMON65
    102  2f9e		       20 57 2f 	      jsr	setFileName
    103  2fa1		       20 5f 29 	      jsr	getILByte	;get the append or create byte
    104  2fa4		       c9 01		      cmp	#1	;create/truncate
    105  2fa6		       d0 06		      bne	iopencont
    106  2fa8		       20 45 f0 	      jsr	DiskRmFile	;by default files opened for write are append
    107  2fab		       20 7d 2f 	      jsr	ResetFileName	;point back to the file name
    108  2fae				   iopencont
    109  2fae
    110  2fae		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    111  2fb1		       90 07		      bcc	Wopenok	;branch if opened ok
    112  2fb3							;
    113  2fb3							; Open failed
    114  2fb3							;
    115  2fb3		       a9 00	   Wdfail     lda	#0
    116  2fb5		       a2 08		      ldx	#ERR_WRITE_FAIL
    117  2fb7		       4c 7d 06 	      jmp	iErr2
    118  2fba							;
    119  2fba		       4c b1 02    Wopenok    jmp	NextIL
    120  2fbd					      endif
    121  2fbd							;
    122  2fbd							;=====================================================
    123  2fbd							; Gets a line of input from the disk file and puts it
    124  2fbd							; into LINBUF.
    125  2fbd							;
    126  2fbd							; On exit:
    127  2fbd							;    CURPTR points to LINBUF
    128  2fbd							;    LINBUF contains the line with 0 at the end.
    129  2fbd							;    Y has offset to first non-space character
    130  2fbd							;    CURROFF has the same as Y.
    131  2fbd							;
    132  2fbd				   iDGETLINE
    133  2fbd					      if	XKIM || CTMON65
    134  2fbd		       a2 a4		      ldx	#LINBUF&$ff
    135  2fbf		       86 4f		      stx	CURPTR
    136  2fc1		       a2 41		      ldx	#LINBUF>>8
    137  2fc3		       86 50		      stx	CURPTR+1
    138  2fc5							;
    139  2fc5		       a2 00		      ldx	#0	;offset
    140  2fc7		       8e 28 42    iDgetLoop  stx	getlinx
    141  2fca		       20 35 30 	      jsr	getNextFileByte
    142  2fcd		       b0 16		      bcs	iGetEOF
    143  2fcf		       c9 0d		      cmp	#CR
    144  2fd1		       f0 0d		      beq	iGetEOL
    145  2fd3		       c9 0a		      cmp	#LF
    146  2fd5		       f0 09		      beq	iGetEOL
    147  2fd7		       ae 28 42 	      ldx	getlinx
    148  2fda		       9d a4 41 	      sta	LINBUF,x
    149  2fdd		       e8		      inx
    150  2fde		       d0 e7		      bne	iDgetLoop
    151  2fe0							;
    152  2fe0							; Handle end of line.	If the line has nothing, loop
    153  2fe0							; back and get another line.
    154  2fe0							;
    155  2fe0		       ae 28 42    iGetEOL    ldx	getlinx	;blank line?
    156  2fe3		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    157  2fe5							;
    158  2fe5							; This can fall through when there is a line, or
    159  2fe5							; called directly when EOF is encountered.
    160  2fe5							;
    161  2fe5		       ae 28 42    iGetEOF    ldx	getlinx
    162  2fe8		       a9 00		      lda	#0
    163  2fea		       9d a4 41 	      sta	LINBUF,x
    164  2fed		       a0 00		      ldy	#0
    165  2fef		       20 9a 2c 	      jsr	SkipSpaces
    166  2ff2		       20 c1 1c 	      jsr	ParseInputLine
    167  2ff5		       a9 be		      lda	#TOKENBUFFER&$ff
    168  2ff7		       85 4f		      sta	CURPTR
    169  2ff9		       a9 1b		      lda	#TOKENBUFFER>>8
    170  2ffb		       85 50		      sta	CURPTR+1
    171  2ffd		       a9 01		      lda	#1
    172  2fff		       85 51		      sta	CUROFF
    173  3001		       4c b1 02 	      jmp	NextIL
    174  3004					      endif
    175  3004
    176  3004							;
    177  3004							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    178  3004							; DISK
    179  3004							;
    180  3004				   iDDIR
    181  3004					      if	XKIM || CTMON65
    182  3004		       20 30 f0 	      jsr	DiskDir
    183  3007							;
    184  3007							; Get/Display each entry
    185  3007							;
    186  3007		       a2 35	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    187  3009		       a0 88		      ldy	#DiskFileName&$ff
    188  300b		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    189  300e		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    190  3010		       20 17 21 	      jsr	puts
      0  3013					      db	"   ",0
      1  3013		       20 20 20 00	      .byte.b	"   ",0
    192  3017							; Print the line to the console
    193  3017		       a2 35		      ldx	#DiskFileName>>8	;pointer to buffer
    194  3019		       a0 88		      ldy	#DiskFileName&$ff
    195  301b		       a5 00		      lda	0
    196  301d		       20 55 21 	      jsr	PrtStr	;else print name
    197  3020		       20 18 f0 	      jsr	crlf
    198  3023
    199  3023		       4c 07 30 	      jmp	DiskDirLoop	;do next entry
    200  3026
    201  3026		       4c b1 02    DiskDirEnd jmp	NextIL
    202  3029					      endif
    203  3029							;
    204  3029							;=====================================================
    205  3029							; Does a LIST to a Disk file.
    206  3029							;
    207  3029				   iDLIST
    208  3029					      if	XKIM || CTMON65
    209  3029		       20 64 30 	      jsr	SetOutDisk
    210  302c		       4c 38 08 	      jmp	iLST2
    211  302f					      endif
    212  302f							;
    213  302f							;=====================================================
    214  302f							; Closes any pending disk file.  Okay to call if there
    215  302f							; is no open file.
    216  302f							;
    217  302f				   iDCLOSE
    218  302f					      if	XKIM || CTMON65
    219  302f		       20 42 f0 	      jsr	DiskClose
    220  3032		       4c b1 02 	      jmp	NextIL
    221  3035					      endif
    222  3035							;
    223  3035							;=====================================================
    224  3035							; This gets the next byte from an open disk file.  If
    225  3035							; there are no more bytes left, this returns C set.
    226  3035							; Else, C is clear and A contains the character.
    227  3035							;
    228  3035				   getNextFileByte
    229  3035					      if	XKIM || CTMON65
    230  3035		       ae 87 35 	      ldx	diskBufOffset
    231  3038		       ec 86 35 	      cpx	diskBufLength
    232  303b		       d0 14		      bne	hasdata	;branch if still data
    233  303d							;
    234  303d							; There is no data left in the buffer, so read a
    235  303d							; block from the SD system.
    236  303d							;
    237  303d		       a9 84		      lda	#BUFFER_SIZE
    238  303f		       a2 df		      ldx	#buffer>>8
    239  3041		       a0 0a		      ldy	#buffer&$ff
    240  3043		       20 3c f0 	      jsr	DiskRead
    241  3046		       b0 12		      bcs	getNextEof
    242  3048							;
    243  3048							; A contains the number of bytes actually read.
    244  3048							;
    245  3048		       8d 86 35 	      sta	diskBufLength	;save length
    246  304b		       c9 00		      cmp	#0	;shouldn't happen
    247  304d		       f0 0b		      beq	getNextEof
    248  304f							;
    249  304f		       a2 00		      ldx	#0
    250  3051		       bd 0a df    hasdata    lda	buffer,x
    251  3054		       e8		      inx
    252  3055		       8e 87 35 	      stx	diskBufOffset
    253  3058		       18		      clc
    254  3059		       60		      rts
    255  305a							;
    256  305a		       a9 00	   getNextEof lda	#0
    257  305c		       8d 87 35 	      sta	diskBufOffset
    258  305f		       8d 86 35 	      sta	diskBufLength
    259  3062		       38		      sec
    260  3063		       60		      rts
    261  3064							;
    262  3064							;=====================================================
    263  3064							; Set output vector to the disk output function
    264  3064							;
    265  3064		       a9 6f	   SetOutDisk lda	#DOUT&$ff
    266  3066		       8d 7a 35 	      sta	BOutVec
    267  3069		       a9 30		      lda	#DOUT/256
    268  306b		       8d 7b 35 	      sta	BOutVec+1
    269  306e		       60		      rts
    270  306f							;
    271  306f							;=====================================================
    272  306f							; input a contains charater to write to open file
    273  306f							; output:
    274  306f							;	    C flag clear if no error
    275  306f							;
    276  306f		       8e 88 35    DOUT       stx	DiskFileName	; Save the x value, fulename not used
    277  3072		       8c 89 35 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    278  3075		       8d 0a df 	      sta	buffer	; Store the byte to send into the buffer
    279  3078		       a9 01		      lda	#1	; set number of bytes to send to 1
    280  307a		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    281  307c		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    282  307e		       20 3f f0 	      jsr	DiskWrite	; Place the character to disk if a file is open
    283  3081		       ae 88 35 	      ldx	DiskFileName	; Restore the x value that was saved
    284  3084		       ac 89 35 	      ldy	DiskFileName+1	; Restore the y value saved
    285  3087		       60		      rts
    286  3088							;=======================================================
    287  3088							; output:
    288  3088							;	  c flag is clear if no error, a contains bytes read
    289  3088							;	  c flag set Reached eof, a undefined
    290  3088							;
    291  3088		       8e 88 35    DIN	      stx	DiskFileName	; Save the x value, filename not used just storage
    292  308b		       8c 89 35 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    293  308e		       a9 01		      lda	#1	; set number of bytes to read to 1
    294  3090		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    295  3092		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    296  3094		       20 3c f0 	      jsr	DiskRead
    297  3097		       ad 0a df 	      lda	buffer	; Get the byte just read
    298  309a		       ae 88 35 	      ldx	DiskFileName
    299  309d		       ac 89 35 	      ldy	DiskFileName+1
    300  30a0		       60		      rts
    301  30a1
    302  30a1							;========================================================
    303  30a1							; Dstat / open/close/stat files
    304  30a1				   DSTAT
    305  30a1		       60		      rts
    306  30a2							;========================================================
    307  30a2					      endif
------- FILE mytb.asm
   2483  30a2					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  30a2					      include	"IL.inc"
      1  30a2
      2  30a2							;=====================================================
      3  30a2							; IL.inc
      4  30a2							; These are macros for IL instructions
      5  30a2							;
      6  30a2					      mac	dw
      7  30a2					      .word	{0}
      8  30a2					      endm
      9  30a2					      mac	db
     10  30a2					      .byte	{0}
     11  30a2					      endm
     12  30a2					      macro	xinit
     13  30a2					      db	0
     14  30a2					      endm		;reset the il to start clear all
     15  30a2							;
     16  30a2					      macro	done
     17  30a2					      db	1
     18  30a2					      endm		;print an error if not end of line
     19  30a2							;
     20  30a2					      macro	prs
     21  30a2					      db	2
     22  30a2					      endm		;print a quoted string
     23  30a2							;
     24  30a2					      macro	prn
     25  30a2					      db	3
     26  30a2					      endm		;print a number
     27  30a2							;
     28  30a2					      macro	spc
     29  30a2					      db	4
     30  30a2					      endm		;print space til new tabstop
     31  30a2							;
     32  30a2					      macro	nline
     33  30a2					      db	5
     34  30a2					      endm		;print a new line crlf
     35  30a2							;
     36  30a2							; My NXT is a bit different in that it takes one
     37  30a2							; parameter, which is an address.  If the BASIC
     38  30a2							; program is currently running then move to the
     39  30a2							; next line and continue execution.  However, if
     40  30a2							; in direct mode, jump to the specified IL label.
     41  30a2							;
     42  30a2					      macro	nxt
     43  30a2					      db	6
     44  30a2					      dw	{1}	; addr
     45  30a2					      endm		; addr
     46  30a2							;
     47  30a2					      macro	xfer
     48  30a2					      db	7
     49  30a2					      endm
     50  30a2							;
     51  30a2					      macro	sav
     52  30a2					      db	8
     53  30a2					      db	{1}
     54  30a2					      endm
     55  30a2							;
     56  30a2							;  Passed jump if function called, and true false value returned
     57  30a2					      macro	rstr
     58  30a2					      db	9
     59  30a2					      db	({1}-*)-1	;(addr-*)-1
     60  30a2					      db	{2}
     61  30a2					      endm
     62  30a2							;
     63  30a2					      macro	cmpr
     64  30a2					      db	10
     65  30a2					      endm
     66  30a2							;
     67  30a2					      macro	innum
     68  30a2					      db	11
     69  30a2					      endm
     70  30a2							;
     71  30a2					      macro	fin
     72  30a2					      db	12
     73  30a2					      endm
     74  30a2							;
     75  30a2							; ERR is followed by an error number.	The error
     76  30a2							; code is printed along with the line number.
     77  30a2							; Control is passed to the statement set with
     78  30a2							; the ERRGOTO statement.
     79  30a2							;
     80  30a2					      macro	errmsg
     81  30a2					      db	13
     82  30a2					      dw	{1}	;ecode
     83  30a2					      endm		;ecode
     84  30a2							;
     85  30a2					      macro	add
     86  30a2					      db	14
     87  30a2					      endm
     88  30a2							;
     89  30a2					      macro	sub
     90  30a2					      db	15
     91  30a2					      endm
     92  30a2							;
     93  30a2					      macro	neg
     94  30a2					      db	16
     95  30a2					      endm
     96  30a2							;
     97  30a2					      macro	mul
     98  30a2					      db	17
     99  30a2					      endm
    100  30a2							;
    101  30a2					      macro	div
    102  30a2					      db	18
    103  30a2					      endm
    104  30a2							;
    105  30a2					      macro	store
    106  30a2					      db	19
    107  30a2					      endm
    108  30a2							;
    109  30a2					      macro	ind
    110  30a2					      db	20
    111  30a2					      endm
    112  30a2							;
    113  30a2					      macro	lst
    114  30a2					      db	21
    115  30a2					      endm
    116  30a2							;
    117  30a2					      macro	init
    118  30a2					      db	22
    119  30a2					      endm
    120  30a2							;
    121  30a2					      macro	getline
    122  30a2					      db	23
    123  30a2					      endm
    124  30a2							;
    125  30a2					      macro	insert
    126  30a2					      db	24
    127  30a2					      endm
    128  30a2							;
    129  30a2					      macro	rtn
    130  30a2					      db	25
    131  30a2					      endm
    132  30a2							;
    133  30a2					      macro	exit
    134  30a2					      db	26
    135  30a2					      endm
    136  30a2							;
    137  30a2					      macro	lit
    138  30a2					      db	27
    139  30a2					      dw	{1}	;value
    140  30a2					      endm		; value LIT
    141  30a2							;
    142  30a2					      macro	call
    143  30a2					      db	28
    144  30a2					      dw	{1}	;addr
    145  30a2					      endm		;addr
    146  30a2							;
    147  30a2							; IJMP will set the IL PC to the specified value.
    148  30a2							;
    149  30a2					      macro	ijmp
    150  30a2					      db	29
    151  30a2					      dw	{1}	;addr
    152  30a2					      endm		;addr
    153  30a2							;
    154  30a2					      macro	vinit
    155  30a2					      db	30
    156  30a2					      endm
    157  30a2							;
    158  30a2							; ERRGOTO sets the point in the code where the IL
    159  30a2							; interpreter will go after any error.
    160  30a2							;
    161  30a2					      macro	errgoto
    162  30a2					      db	31
    163  30a2					      dw	{1}	;addr
    164  30a2					      endm		;addr
    165  30a2							;
    166  30a2					      macro	tst
    167  30a2					      db	32
    168  30a2					      db	({1}-*)-1	;(addr-*)-1
    169  30a2					      db	{2},0	;string,0
    170  30a2					      endm		;addr,string
    171  30a2							;
    172  30a2					      macro	tstv
    173  30a2					      db	33
    174  30a2					      db	({1}-*)-1	;(addr-*)-1
    175  30a2					      endm		;addr
    176  30a2							;
    177  30a2					      macro	tstl
    178  30a2					      db	34
    179  30a2					      db	({1}-*)-1	;(addr-*)-1
    180  30a2					      endm		;addr
    181  30a2							;
    182  30a2					      macro	tstn
    183  30a2					      db	35
    184  30a2					      db	({1}-*)-1	;(addr-*)-1
    185  30a2					      endm		;addr
    186  30a2							;
    187  30a2							; FREE returns the amount of free RAM on top of
    188  30a2							; the stack.  This is the amount of room the user
    189  30a2							; program has available.
    190  30a2							;
    191  30a2					      macro	free
    192  30a2					      db	36
    193  30a2					      endm
    194  30a2							;
    195  30a2							; RANDOM takes the top item off the stack and
    196  30a2							; replaces it with a random number that is
    197  30a2							; MOD the initial value.  Ie, if the TOS is
    198  30a2							; 42 then RANDOM returns a value from 0 to 41.
    199  30a2							;
    200  30a2					      macro	random
    201  30a2					      db	37
    202  30a2					      endm
    203  30a2							;
    204  30a2							; ABS will replace the top of stack with the
    205  30a2							; absolute value.
    206  30a2							;
    207  30a2					      macro	abs
    208  30a2					      db	38
    209  30a2					      endm
    210  30a2							;
    211  30a2							; OPENREAD opens a file for reading, as in getting
    212  30a2							; statements from it.
    213  30a2							;
    214  30a2					      macro	openread
    215  30a2					      db	39
    216  30a2					      endm
    217  30a2							;
    218  30a2							; OPENWRITE opens a file for writing, as in saving
    219  30a2							; the current program to it.
    220  30a2							;
    221  30a2					      macro	openwrite
    222  30a2					      db	40
    223  30a2					      db	{1}	; 0= append 1 = create/truncate
    224  30a2					      endm
    225  30a2							;
    226  30a2							; DCLOSE closes any open disk file.
    227  30a2							;
    228  30a2					      macro	dclose
    229  30a2					      db	41
    230  30a2					      endm
    231  30a2							;
    232  30a2							; DGETLINE gets one line from the disk file and puts it
    233  30a2							; into LINBUFF.
    234  30a2							;
    235  30a2					      macro	dgetline
    236  30a2					      db	42
    237  30a2					      endm
    238  30a2							;
    239  30a2							; DLIST saves the program to an open disk file.
    240  30a2							;
    241  30a2					      macro	dlist
    242  30a2					      db	43
    243  30a2					      endm
    244  30a2							; DDIR list the current directory
    245  30a2							;
    246  30a2					      macro	ddir
    247  30a2					      db	44
    248  30a2					      endm
    249  30a2
    250  30a2							; RMFILE remove a fle from disk
    251  30a2					      macro	rmfile
    252  30a2					      db	45
    253  30a2					      endm
    254  30a2
    255  30a2							; CLEARSCREEN clear the screen
    256  30a2					      macro	clearscreen
    257  30a2					      db	46
    258  30a2					      endm
    259  30a2							; POKEMEM Poke value into memory
    260  30a2					      macro	pokemem
    261  30a2					      db	47
    262  30a2					      endm
    263  30a2							; PEEKMEM peek at value in memory
    264  30a2					      macro	peekmem
    265  30a2					      db	48
    266  30a2					      endm
    267  30a2							; TSTLET Test if the statement is a let without the keyword let
    268  30a2					      macro	tstlet
    269  30a2					      db	49
    270  30a2					      db	({1}-*)-1	;(addr-*)-1
    271  30a2					      endm		;addr
    272  30a2							; TSTDONE if we reach the end of a statement
    273  30a2					      macro	tstdone
    274  30a2					      db	50
    275  30a2					      db	({1}-*)-1	;(addr-*)-1
    276  30a2					      endm		;addr
    277  30a2							; GETCHAR	get a character from the input line leave it in RO
    278  30a2					      macro	getchar
    279  30a2					      db	51
    280  30a2					      endm
    281  30a2							; PUTCHAR	Put a character to the terminal
    282  30a2					      macro	putchar
    283  30a2					      db	52
    284  30a2					      endm
    285  30a2							; Call		Call a machine function return a to stack
    286  30a2					      macro	callfunc
    287  30a2					      db	53
    288  30a2					      endm
    289  30a2
    290  30a2							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    291  30a2					      macro	ibranch
    292  30a2					      db	54
    293  30a2					      endm
    294  30a2
    295  30a2							; TSTSTR	 Tests for the open quote in a string
    296  30a2					      macro	tststr
    297  30a2					      db	55
    298  30a2					      db	({1}-*)-1	;(addr-*)-1
    299  30a2					      endm
    300  30a2							; SETIRQ	Sets the line number to run when an irq happens irq 550
    301  30a2					      macro	setirq
    302  30a2					      db	56
    303  30a2					      endm
    304  30a2
    305  30a2							; TSTIRQ	Test for irq pending,
    306  30a2							;		if so push the IRQ LINE NUMBER into RO, onto stack
    307  30a2					      macro	tstirq
    308  30a2					      db	57
    309  30a2					      db	({1}-*)-1	;(addr-*)-1
    310  30a2					      endm
    311  30a2
    312  30a2							; IRET    return from interupt service
    313  30a2					      macro	iret
    314  30a2					      db	58
    315  30a2					      endm
    316  30a2
    317  30a2							; INSTR   read a string from the input
    318  30a2					      macro	instr
    319  30a2					      db	59
    320  30a2					      endm
    321  30a2
    322  30a2							; MODULO Returns the remainder of the division
    323  30a2					      macro	modulo
    324  30a2					      db	60
    325  30a2					      endm
    326  30a2							; Set a task line
    327  30a2					      macro	taskcreate
    328  30a2					      db	61
    329  30a2					      endm
    330  30a2							; End a task
    331  30a2					      macro	etask
    332  30a2					      db	62
    333  30a2					      endm
    334  30a2							; Skip to next task
    335  30a2					      macro	ntask
    336  30a2					      db	63
    337  30a2					      endm
    338  30a2							; Subscript
    339  30a2					      macro	subscript
    340  30a2					      db	64
    341  30a2					      db	{1}
    342  30a2					      endm
    343  30a2							; KILL Task
    344  30a2					      macro	taskkill
    345  30a2					      db	65
    346  30a2					      endm
    347  30a2							; STAT Task
    348  30a2					      macro	taskstat
    349  30a2					      db	66
    350  30a2					      endm
    351  30a2							;  output value as hex
    352  30a2					      macro	hexprt
    353  30a2					      db	67
    354  30a2					      endm
    355  30a2							;  Read in background has completed
    356  30a2					      macro	readcomplete
    357  30a2					      db	68
    358  30a2					      endm
    359  30a2							;  ReadInput line
    360  30a2					      macro	readstart
    361  30a2					      db	69
    362  30a2					      endm
    363  30a2							; Startio request
    364  30a2					      macro	startio
    365  30a2					      db	70
    366  30a2					      endm
    367  30a2							; Endio
    368  30a2					      macro	endio
    369  30a2					      db	71
    370  30a2					      endm
    371  30a2							; Logical not
    372  30a2					      macro	lognot
    373  30a2					      db	72
    374  30a2					      endm
    375  30a2							; Logical OR
    376  30a2					      macro	logor
    377  30a2					      db	73
    378  30a2					      endm
    379  30a2							;Logical and
    380  30a2					      macro	logand
    381  30a2					      db	74
    382  30a2					      endm
    383  30a2							;Logical XOR
    384  30a2					      macro	logxor
    385  30a2					      db	75
    386  30a2					      endm
    387  30a2							;Wait for task to complete, or list of tasks
    388  30a2					      macro	wtask
    389  30a2					      db	76
    390  30a2					      db	({1}-*)-1	;(addr-*)-1
    391  30a2					      endm
    392  30a2							;Get the current task id
    393  30a2					      MACRO	taskpid
    394  30a2					      db	77
    395  30a2					      endm
    396  30a2							;Trace the basic execution
    397  30a2					      Macro	traceprogram
    398  30a2					      db	78
    399  30a2					      endm
    400  30a2							;Do a basic program Trace
    401  30a2					      Macro	debugbasic
    402  30a2					      db	79
    403  30a2					      endm
    404  30a2
    405  30a2							; Inter Process communications instructions
    406  30a2					      Macro	ipcsend
    407  30a2					      db	80
    408  30a2					      endm
    409  30a2					      Macro	ipcreceive
    410  30a2					      db	81
    411  30a2					      endm
    412  30a2					      Macro	ipccheck
    413  30a2					      db	82
    414  30a2					      endm
    415  30a2					      Macro	ipcio
    416  30a2					      db	83
    417  30a2					      endm
    418  30a2					      Macro	pushmathstack
    419  30a2					      db	84
    420  30a2					      endm
    421  30a2					      Macro	popmathstack
    422  30a2					      db	85
    423  30a2					      endm
    424  30a2					      Macro	savemathstack
    425  30a2					      db	86
    426  30a2					      endm
    427  30a2					      Macro	restoremathstack
    428  30a2					      db	87
    429  30a2					      endm
    430  30a2					      Macro	incparmcount
    431  30a2					      db	88
    432  30a2					      endm
    433  30a2					      Macro	taskgetmathstack
    434  30a2					      db	89
    435  30a2					      endm
    436  30a2					      Macro	taskenable
    437  30a2					      db	90
    438  30a2					      endm
    439  30a2					      Macro	tasksuspend
    440  30a2					      db	91
    441  30a2					      endm
    442  30a2					      Macro	taskputmathptr
    443  30a2					      db	92
    444  30a2					      endm
    445  30a2							; Test for an extension type of variable that allows access to a tasks variables
    446  30a2							; Using  PID!<Var name>
    447  30a2					      Macro	tstvt
    448  30a2					      db	93
    449  30a2					      db	({1}-*)-1	;(addr-*)-1
    450  30a2					      endm
    451  30a2
    452  30a2							; Provide access to R2 for the IL program
    453  30a2					      Macro	setr2
    454  30a2					      db	94
    455  30a2					      db	{1}	; R2 is only one byte
    456  30a2					      endm
    457  30a2
    458  30a2							;Move stack top to temp
    459  30a2					      Macro	stk2tmp
    460  30a2					      db	95
    461  30a2					      endm
    462  30a2
    463  30a2					      Macro	tmp2stk
    464  30a2					      db	96
    465  30a2					      endm
    466  30a2
    467  30a2					      Macro	tstbyte
    468  30a2					      db	97
    469  30a2					      db	({1}-*)-1	; (addr-*)-1 goto if match
    470  30a2					      dw	{2}	; address to check
    471  30a2					      db	{3}	; Value to compare
    472  30a2					      endm
    473  30a2
    474  30a2					      Macro	incvar
    475  30a2					      db	98
    476  30a2					      endm
    477  30a2					      Macro	decvar
    478  30a2					      db	99
    479  30a2					      endm
    480  30a2
    481  30a2					      Macro	slice
    482  30a2					      db	100
    483  30a2					      endm
    484  30a2
    485  30a2					      Macro	tstb
    486  30a2					      db	101
    487  30a2					      db	({1}-*)-1
    488  30a2					      db	{2}
    489  30a2					      endm
    490  30a2
    491  30a2					      Macro	tstw
    492  30a2					      db	102
    493  30a2					      db	({1}-*)-1
    494  30a2					      dw	{2}
    495  30a2					      endm
    496  30a2
    497  30a2					      Macro	ongoto
    498  30a2					      db	103
    499  30a2					      dw	{1}
    500  30a2					      dw	{2}
    501  30a2					      endm
    502  30a2
    503  30a2					      Macro	tstrelop
    504  30a2					      db	104
    505  30a2					      db	({1}-*)-1
    506  30a2					      endm
    507  30a2
    508  30a2					      Macro	repeatline
    509  30a2					      db	105
    510  30a2					      endm
    511  30a2
    512  30a2							; Check for a precompiled branch, will take branch if precompiled value present
    513  30a2					      Macro	tstbranch
    514  30a2					      db	106
    515  30a2					      db	({1}-*)-1
    516  30a2					      endm
    517  30a2
    518  30a2					      Macro	fastxfer
    519  30a2					      db	107
    520  30a2					      endm
    521  30a2
    522  30a2							; Set all io to to a terminal for input output
    523  30a2							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    524  30a2							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    525  30a2					      Macro	setterminal
    526  30a2					      db	108
    527  30a2					      endm
    528  30a2
    529  30a2							;Fetch a single byte from memory
    530  30a2					      Macro	indb
    531  30a2					      db	109
    532  30a2					      endm
    533  30a2
    534  30a2							; Set a block of memory to a fixed value, byte or word
    535  30a2							; Stack must contain destiniation address, length to set in bytes, value {byte of word} to initialize to
    536  30a2					      Macro	setblock
    537  30a2					      db	110
    538  30a2					      db	{1}	; the data type to initialize	tByte or tInteger
    539  30a2					      endm
    540  30a2
    541  30a2							; Copy a block of memory
    542  30a2							; Stack must contain source address, destination address, length in bytes
    543  30a2					      Macro	copyblock
    544  30a2					      db	111
    545  30a2					      endm
    546  30a2
    547  30a2							; Compare one block of memory to another
    548  30a2							; Stack contains Length, Source1 Source 2
    549  30a2							; Place on stack 0 equal, 1 s1>s2, -1 s1 < s2
    550  30a2					      Macro	cmpmem
    551  30a2					      db	112
    552  30a2					      endm
    553  30a2
    554  30a2							; Shift Left and Right
    555  30a2					      Macro	shift
    556  30a2					      db	113
    557  30a2					      db	{1}	; direction  0 = left 1 = right
    558  30a2					      endm
------- FILE mytb.asm
   2485  30a2							;
   2486  30a2				  -	      if	FIXED
   2487  30a2				  -	      org	$1000
   2488  30a2					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  30a2					      include	"basic.il"
      1  30a2					      seg	Code
      2  30a2							; on goto table
      3  30a2							; format :   first byte is value Base, subtracted from value found
      4  30a2							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  30a2				   BasicStmts
      0  30a2					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  30a2		       01 23		      .byte.b	kBeginKey,(kKeyCount+1)
      0  30a4					      dw	ekLet
      1  30a4		       2f 31		      .word.w	ekLet
      0  30a6					      dw	ekInc
      1  30a6		       61 31		      .word.w	ekInc
      0  30a8					      dw	ekDec
      1  30a8		       6e 31		      .word.w	ekDec
      0  30aa					      dw	ekIreturn
      1  30aa		       7b 31		      .word.w	ekIreturn
      0  30ac					      dw	ekIf
      1  30ac		       80 31		      .word.w	ekIf
      0  30ae					      dw	ekThen
      1  30ae		       86 31		      .word.w	ekThen
      0  30b0					      dw	ekGoto
      1  30b0		       8a 31		      .word.w	ekGoto
      0  30b2					      dw	ekGosub
      1  30b2		       1c 35		      .word.w	ekGosub
      0  30b4					      dw	ekReturn
      1  30b4		       2a 35		      .word.w	ekReturn
      0  30b6					      dw	ekRem
      1  30b6		       9e 31		      .word.w	ekRem
      0  30b8					      dw	ekPrint	; should be entry for print
      1  30b8		       b4 31		      .word.w	ekPrint
      0  30ba					      dw	ekTaske
      1  30ba		       01 32		      .word.w	ekTaske
      0  30bc					      dw	ekTaskn
      1  30bc		       17 32		      .word.w	ekTaskn
      0  30be					      dw	ekTaskw
      1  30be		       1e 32		      .word.w	ekTaskw
      0  30c0					      dw	ekPoke
      1  30c0		       39 32		      .word.w	ekPoke
      0  30c2					      dw	ekPutch
      1  30c2		       9b 32		      .word.w	ekPutch
      0  30c4					      dw	ekCls
      1  30c4		       a6 32		      .word.w	ekCls
      0  30c6					      dw	ekInput
      1  30c6		       ad 32		      .word.w	ekInput
      0  30c8					      dw	ekEnd
      1  30c8		       d6 32		      .word.w	ekEnd
      0  30ca					      dw	ekIrq
      1  30ca		       da 32		      .word.w	ekIrq
      0  30cc					      dw	ekKill
      1  30cc		       e5 32		      .word.w	ekKill
      0  30ce					      dw	ekList
      1  30ce		       f0 32		      .word.w	ekList
      0  30d0					      dw	ekRun
      1  30d0		       f5 32		      .word.w	ekRun
      0  30d2					      dw	ekNew
      1  30d2		       fe 32		      .word.w	ekNew
      0  30d4					      dw	ekSlice
      1  30d4		       02 33		      .word.w	ekSlice
      0  30d6					      dw	ekTrace
      1  30d6		       0d 33		      .word.w	ekTrace
      0  30d8					      dw	ekExit
      1  30d8		       1e 33		      .word.w	ekExit
      0  30da					      dw	ekSave
      1  30da		       1f 33		      .word.w	ekSave
      0  30dc					      dw	ekLoad
      1  30dc		       26 33		      .word.w	ekLoad
      0  30de					      dw	ekErase
      1  30de		       36 33		      .word.w	ekErase
      0  30e0					      dw	ekDir
      1  30e0		       32 33		      .word.w	ekDir
      0  30e2					      dw	ekSetTerm
      1  30e2		       a4 31		      .word.w	ekSetTerm
      0  30e4					      dw	ekSetMemB
      1  30e4		       50 32		      .word.w	ekSetMemB
      0  30e6					      dw	ekSetMemW
      1  30e6		       5c 32		      .word.w	ekSetMemW
      0  30e8					      dw	ekCopyMem
      1  30e8		       7e 32		      .word.w	ekCopyMem
     42  30ea							;
     43  30ea							; Logical operators
      0  30ea				   BasicLogical db	kOr,3
      1  30ea		       25 03		      .byte.b	kOr,3
      0  30ec					      dw	ekOr
      1  30ec		       72 33		      .word.w	ekOr
      0  30ee					      dw	ekXor
      1  30ee		       77 33		      .word.w	ekXor
      0  30f0					      dw	ekAnd
      1  30f0		       6d 33		      .word.w	ekAnd
     48  30f2
      0  30f2				   BasicShift db	kShr,2
      1  30f2		       28 02		      .byte.b	kShr,2
      0  30f4					      dw	ekShiftRight
      1  30f4		       62 33		      .word.w	ekShiftRight
      0  30f6					      dw	ekShiftLeft
      1  30f6		       5c 33		      .word.w	ekShiftLeft
     52  30f8
     53  30f8							;functions returning values
     54  30f8
      0  30f8				   BasicFuncs db	kBeginFunc,kFuncCount
      1  30f8		       2a 11		      .byte.b	kBeginFunc,kFuncCount
      0  30fa					      dw	ekTrue
      1  30fa		       d7 33		      .word.w	ekTrue
      0  30fc					      dw	ekFalse
      1  30fc		       db 33		      .word.w	ekFalse
      0  30fe					      dw	ekFree
      1  30fe		       df 33		      .word.w	ekFree
      0  3100					      dw	ekGetch
      1  3100		       e7 33		      .word.w	ekGetch
      0  3102					      dw	ekPeek
      1  3102		       15 34		      .word.w	ekPeek
      0  3104					      dw	ekTask
      1  3104		       20 34		      .word.w	ekTask
      0  3106					      dw	ekIpcc
      1  3106		       6c 34		      .word.w	ekIpcc
      0  3108					      dw	ekIpcs
      1  3108		       47 34		      .word.w	ekIpcs
      0  310a					      dw	ekIpcr
      1  310a		       58 34		      .word.w	ekIpcr
      0  310c					      dw	ekRnd
      1  310c		       77 34		      .word.w	ekRnd
      0  310e					      dw	ekStat
      1  310e		       95 34		      .word.w	ekStat
      0  3110					      dw	ekAbs
      1  3110		       8a 34		      .word.w	ekAbs
      0  3112					      dw	ekCall
      1  3112		       a2 34		      .word.w	ekCall
      0  3114					      dw	ekGofn
      1  3114		       23 35		      .word.w	ekGofn
      0  3116					      dw	ekPid
      1  3116		       a0 34		      .word.w	ekPid
      0  3118					      dw	ekAddr
      1  3118		       ef 33		      .word.w	ekAddr
      0  311a					      dw	ekCmpMem
      1  311a		       fe 33		      .word.w	ekCmpMem
     73  311c							;====================================================
     74  311c							; file constants
     75  311c		       00 00	   OPEN_APPEND equ	0	; append to file
     76  311c		       00 01	   OPEN_CREATE equ	1	; truncate/create file
     77  311c
     78  311c							;=====================================================
     79  311c							; This is the IL of the BASIC (or whatever) language.
     80  311c							; Because of the way macros are implemented by as65,
     81  311c							; labels can't be on the same line as a macro
     82  311c							; invocation, so that's why labels are on separate
     83  311c							; lines.
     84  311c							;
     85  311c		       31 1c	   IL	      equ	*
     86  311c
     87  311c							;THE IL CONTROL SECTION
     88  311c
     89  311c				   START
      0  311c					      INIT		;INITIALIZE
      0  311c					      db	22
      1  311c		       16		      .byte.b	22
      0  311d					      NLINE		;WRITE CRLF
      0  311d					      db	5
      1  311d		       05		      .byte.b	5
      0  311e					      ERRGOTO	CO	;where to go after an error
      0  311e					      db	31
      1  311e		       1f		      .byte.b	31
      0  311f					      dw	CO
      1  311f		       22 31		      .word.w	CO
      0  3121					      VINIT		;clear all variables
      0  3121					      db	30
      1  3121		       1e		      .byte.b	30
     94  3122							;
     95  3122							; This is where we jump to get a line of commands or
     96  3122							; a program from the user.
     97  3122							;
     98  3122				   CO
      0  3122					      GETLINE		;WRITE PROMPT AND GET LINE
      0  3122					      db	23
      1  3122		       17		      .byte.b	23
      0  3123					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  3123					      db	34
      1  3123		       22		      .byte.b	34
      0  3124					      db	(XEC-*)-1
      1  3124		       04		      .byte.b	(XEC-*)-1
      0  3125					      INSERT		;INSERT IT (MAY BE DELETE)
      0  3125					      db	24
      1  3125		       18		      .byte.b	24
      0  3126					      IJMP	CO
      0  3126					      db	29
      1  3126		       1d		      .byte.b	29
      0  3127					      dw	CO
      1  3127		       22 31		      .word.w	CO
    103  3129				   XEC
      0  3129					      XINIT		;INITIALIZE
      0  3129					      db	0
      1  3129		       00		      .byte.b	0
    105  312a							;============================================================================
    106  312a							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
    107  312a							;
    108  312a				   STMT
      0  312a					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  312a					      db	57
      1  312a		       39		      .byte.b	57
      0  312b					      db	(notirq-*)-1
      1  312b		       01		      .byte.b	(notirq-*)-1
      0  312c					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  312c					      db	79
      1  312c		       4f		      .byte.b	79
    111  312d
    112  312d							;==========================================================================================
    113  312d							; Process a let statement implied or explicit.
    114  312d							;
    115  312d				   notirq
      0  312d					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  312d					      db	49
      1  312d		       31		      .byte.b	49
      0  312e					      db	(DoVector-*)-1
      1  312e		       2d		      .byte.b	(DoVector-*)-1
    117  312f				   ekLet
      0  312f					      TSTV	DoVector	; Test for variable
      0  312f					      db	33
      1  312f		       21		      .byte.b	33
      0  3130					      db	(DoVector-*)-1
      1  3130		       2b		      .byte.b	(DoVector-*)-1
      0  3131					      CALL	FactVarPtrNoTst	; get a pointer to the variable
      0  3131					      db	28
      1  3131		       1c		      .byte.b	28
      0  3132					      dw	FactVarPtrNoTst
      1  3132		       eb 34		      .word.w	FactVarPtrNoTst
    120  3134
    121  3134				   LETINDEX_ALL
      0  3134					      TSTB	ERRMissingEquals,oEqual	; (This line originally omitted)
      0  3134					      db	101
      1  3134		       65		      .byte.b	101
      0  3135					      db	(ERRMissingEquals-*)-1
      1  3135		       20		      .byte.b	(ERRMissingEquals-*)-1
      0  3136					      db	oEqual
      1  3136		       f2		      .byte.b	oEqual
    123  3137				   LETBE
      0  3137					      TSTBYTE	LETAssignByte,R2,tByte	; Check for a byte conversion
      0  3137					      db	97
      1  3137		       61		      .byte.b	97
      0  3138					      db	(LETAssignByte-*)-1
      1  3138		       10		      .byte.b	(LETAssignByte-*)-1
      0  3139					      dw	R2
      1  3139		       58 00		      .word.w	R2
      0  313b					      db	tByte
      1  313b		       a2		      .byte.b	tByte
      0  313c					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  313c					      db	28
      1  313c		       1c		      .byte.b	28
      0  313d					      dw	EXPR
      1  313d		       3e 33		      .word.w	EXPR
      0  313f					      DONE		; REPORT ERROR IF NOT NEXT
      0  313f					      db	1
      1  313f		       01		      .byte.b	1
      0  3140					      SETR2	tInteger	; Store an integer type
      0  3140					      db	94
      1  3140		       5e		      .byte.b	94
      0  3141					      db	tInteger
      1  3141		       a4		      .byte.b	tInteger
      0  3142					      STORE		; STORE RESULT at variable address
      0  3142					      db	19
      1  3142		       13		      .byte.b	19
      0  3143					      NXT	CO	; AND SEQUENCE TO NEXT
      0  3143					      db	6
      1  3143		       06		      .byte.b	6
      0  3144					      dw	CO
      1  3144		       22 31		      .word.w	CO
      0  3146					      IJMP	STMT	; Next statement
      0  3146					      db	29
      1  3146		       1d		      .byte.b	29
      0  3147					      dw	STMT
      1  3147		       2a 31		      .word.w	STMT
    131  3149
    132  3149				   LETAssignByte
      0  3149					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  3149					      db	28
      1  3149		       1c		      .byte.b	28
      0  314a					      dw	EXPR
      1  314a		       3e 33		      .word.w	EXPR
      0  314c					      DONE		; REPORT ERROR IF NOT NEXT
      0  314c					      db	1
      1  314c		       01		      .byte.b	1
      0  314d					      SETR2	tByte	; Set to store a byte value
      0  314d					      db	94
      1  314d		       5e		      .byte.b	94
      0  314e					      db	tByte
      1  314e		       a2		      .byte.b	tByte
      0  314f					      STORE		; STORE RESULT at variable address
      0  314f					      db	19
      1  314f		       13		      .byte.b	19
      0  3150					      NXT	CO	; AND SEQUENCE TO NEXT
      0  3150					      db	6
      1  3150		       06		      .byte.b	6
      0  3151					      dw	CO
      1  3151		       22 31		      .word.w	CO
      0  3153					      IJMP	STMT	; Next statement
      0  3153					      db	29
      1  3153		       1d		      .byte.b	29
      0  3154					      dw	STMT
      1  3154		       2a 31		      .word.w	STMT
    139  3156
    140  3156				   ERRMissingEquals
      0  3156					      ERRMSG	ERR_MISSINGEQUALSIGN	; Missing asignment
      0  3156					      db	13
      1  3156		       0d		      .byte.b	13
      0  3157					      dw	ERR_MISSINGEQUALSIGN
      1  3157		       18 00		      .word.w	ERR_MISSINGEQUALSIGN
    142  3159
    143  3159				   ERRVEC2
      0  3159					      IJMP	UNKNOWN
      0  3159					      db	29
      1  3159		       1d		      .byte.b	29
      0  315a					      dw	UNKNOWN
      1  315a		       3a 33		      .word.w	UNKNOWN
    145  315c							;=============================================================
    146  315c							;Branch on a valid statement start
    147  315c				   DoVector
      0  315c					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  315c					      db	103
      1  315c		       67		      .byte.b	103
      0  315d					      dw	BasicStmts
      1  315d		       a2 30		      .word.w	BasicStmts
      0  315f					      dw	UNKNOWN
      1  315f		       3a 33		      .word.w	UNKNOWN
    149  3161							;This will never return here!
    150  3161							;=============================================================
    151  3161							; Inc or dec a variable
    152  3161				   ekInc
      0  3161					      TSTV	ERRVEC2	; Verify we have a variable
      0  3161					      db	33
      1  3161		       21		      .byte.b	33
      0  3162					      db	(ERRVEC2-*)-1
      1  3162		       f6		      .byte.b	(ERRVEC2-*)-1
      0  3163					      CALL	FactVarPtrNoTst	; Get a pointer to the memory location to increment
      0  3163					      db	28
      1  3163		       1c		      .byte.b	28
      0  3164					      dw	FactVarPtrNoTst
      1  3164		       eb 34		      .word.w	FactVarPtrNoTst
    155  3166							;	  TSTB	     eDoInc,oBang		    ; Allow to inc or dec other tasks variables
    156  3166							;	  IND					    ; we just got a pid
    157  3166							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    158  3166				   eDoInc
      0  3166					      INCVAR		; Do the increment of the variable
      0  3166					      db	98
      1  3166		       62		      .byte.b	98
      0  3167					      DONE		; Test for end of line or end of statement ":"
      0  3167					      db	1
      1  3167		       01		      .byte.b	1
      0  3168					      NXT	CO	; Get the next statement, branch CO if end of program
      0  3168					      db	6
      1  3168		       06		      .byte.b	6
      0  3169					      dw	CO
      1  3169		       22 31		      .word.w	CO
      0  316b					      IJMP	STMT	; Process the next statement
      0  316b					      db	29
      1  316b		       1d		      .byte.b	29
      0  316c					      dw	STMT
      1  316c		       2a 31		      .word.w	STMT
    163  316e							;S1Dec:
    164  316e							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    165  316e				   ekDec
      0  316e					      TSTV	ERRVEC2	; Must be followed by a variable
      0  316e					      db	33
      1  316e		       21		      .byte.b	33
      0  316f					      db	(ERRVEC2-*)-1
      1  316f		       e9		      .byte.b	(ERRVEC2-*)-1
      0  3170					      CALL	FactVarPtrNoTst	; Get a pointer to the variable to update
      0  3170					      db	28
      1  3170		       1c		      .byte.b	28
      0  3171					      dw	FactVarPtrNoTst
      1  3171		       eb 34		      .word.w	FactVarPtrNoTst
    168  3173							;	  TSTB	     eDoDec,oBang		    ; Allow to inc or dec other tasks variables
    169  3173							;	  IND					    ; we just got a pid
    170  3173							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    171  3173				   eDoDec
      0  3173					      DECVAR		; Decrement the actual variable
      0  3173					      db	99
      1  3173		       63		      .byte.b	99
      0  3174					      DONE		; Test if end of line or : statement
      0  3174					      db	1
      1  3174		       01		      .byte.b	1
      0  3175					      NXT	CO	; If at end of program then got the console
      0  3175					      db	6
      1  3175		       06		      .byte.b	6
      0  3176					      dw	CO
      1  3176		       22 31		      .word.w	CO
      0  3178					      IJMP	STMT	; Process the next statement of command line
      0  3178					      db	29
      1  3178		       1d		      .byte.b	29
      0  3179					      dw	STMT
      1  3179		       2a 31		      .word.w	STMT
    176  317b							;=============================================================================================================================
    177  317b							; iret or ireturn, Return from interupt process
    178  317b							;
    179  317b							;S1Iret:
    180  317b							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    181  317b							;S1Sa:
    182  317b				   ekIreturn
      0  317b					      DONE		; Must be only thing on the line
      0  317b					      db	1
      1  317b		       01		      .byte.b	1
      0  317c					      IRET		; RESTORE LINE NUMBER OF CALL
      0  317c					      db	58
      1  317c		       3a		      .byte.b	58
      0  317d					      IJMP	STMT
      0  317d					      db	29
      1  317d		       1d		      .byte.b	29
      0  317e					      dw	STMT
      1  317e		       2a 31		      .word.w	STMT
    186  3180							;==============================================================================================================================
    187  3180							;Process if statement, if true then process all statements until end of line reached
    188  3180							;S1S1:
    189  3180							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    190  3180				   ekIf
      0  3180					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  3180					      db	28
      1  3180		       1c		      .byte.b	28
      0  3181					      dw	EXPR
      1  3181		       3e 33		      .word.w	EXPR
      0  3183					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  3183					      db	101
      1  3183		       65		      .byte.b	101
      0  3184					      db	(S1W-*)-1
      1  3184		       01		      .byte.b	(S1W-*)-1
      0  3185					      db	kThen
      1  3185		       06		      .byte.b	kThen
    193  3186				   ekThen
    194  3186				   S1W
      0  3186					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  3186					      db	54
      1  3186		       36		      .byte.b	54
      0  3187					      IJMP	STMT
      0  3187					      db	29
      1  3187		       1d		      .byte.b	29
      0  3188					      dw	STMT
      1  3188		       2a 31		      .word.w	STMT
    197  318a							;===============================================================================================================================
    198  318a							; Test for GOTO
    199  318a							;S1Z:
    200  318a							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    201  318a							;
    202  318a				   ekGoto
      0  318a					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  318a					      db	106
      1  318a		       6a		      .byte.b	106
      0  318b					      db	(ekGotoCompiled-*)-1
      1  318b		       0e		      .byte.b	(ekGotoCompiled-*)-1
    204  318c							; Else we have the address ad just goto that address
      0  318c					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  318c					      db	101
      1  318c		       65		      .byte.b	101
      0  318d					      db	(ekGotoLine-*)-1
      1  318d		       05		      .byte.b	(ekGotoLine-*)-1
      0  318e					      db	oPeriod
      1  318e		       e9		      .byte.b	oPeriod
      0  318f					      REPEATLINE		; Repeat the same line again
      0  318f					      db	105
      1  318f		       69		      .byte.b	105
      0  3190					      IJMP	STMT	; Go do the statement
      0  3190					      db	29
      1  3190		       1d		      .byte.b	29
      0  3191					      dw	STMT
      1  3191		       2a 31		      .word.w	STMT
    208  3193
    209  3193				   ekGotoLine
      0  3193					      CALL	EXPR	; GET LABEL
      0  3193					      db	28
      1  3193		       1c		      .byte.b	28
      0  3194					      dw	EXPR
      1  3194		       3e 33		      .word.w	EXPR
      0  3196					      lit	0	; Place indicator for line num on stack
      0  3196					      db	27
      1  3196		       1b		      .byte.b	27
      0  3197					      dw	0
      1  3197		       00 00		      .word.w	0
      0  3199					      FASTXFER
      0  3199					      db	107
      1  3199		       6b		      .byte.b	107
    213  319a				   ekGotoCompiled
      0  319a					      lit	1	; tell it that mempointer on the stack
      0  319a					      db	27
      1  319a		       1b		      .byte.b	27
      0  319b					      dw	1
      1  319b		       01 00		      .word.w	1
      0  319d					      FASTXFER		; put top of stack into curptr
      0  319d					      db	107
      1  319d		       6b		      .byte.b	107
    216  319e
    217  319e
    218  319e							;==================================================================================================================================
    219  319e							; Process REM statement
    220  319e							;
    221  319e							;S2a:
    222  319e							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    223  319e				   ekRem
      0  319e					      NXT	CO	; The rest of the line is ignored
      0  319e					      db	6
      1  319e		       06		      .byte.b	6
      0  319f					      dw	CO
      1  319f		       22 31		      .word.w	CO
      0  31a1					      IJMP	STMT	; Process the next statement
      0  31a1					      db	29
      1  31a1		       1d		      .byte.b	29
      0  31a2					      dw	STMT
      1  31a2		       2a 31		      .word.w	STMT
    226  31a4							;====================================================================================================================================
    227  31a4							; Set the Task input output slot each slot is 16 byte starting at e000
    228  31a4							; so 0,1,...
    229  31a4				   ekSetTerm
      0  31a4					      CALL	EXPR
      0  31a4					      db	28
      1  31a4		       1c		      .byte.b	28
      0  31a5					      dw	EXPR
      1  31a5		       3e 33		      .word.w	EXPR
      0  31a7					      TSTB	ERRVEC,oComma
      0  31a7					      db	101
      1  31a7		       65		      .byte.b	101
      0  31a8					      db	(ERRVEC-*)-1
      1  31a8		       2f		      .byte.b	(ERRVEC-*)-1
      0  31a9					      db	oComma
      1  31a9		       e2		      .byte.b	oComma
      0  31aa					      CALL	EXPR
      0  31aa					      db	28
      1  31aa		       1c		      .byte.b	28
      0  31ab					      dw	EXPR
      1  31ab		       3e 33		      .word.w	EXPR
      0  31ad					      SETTERMINAL
      0  31ad					      db	108
      1  31ad		       6c		      .byte.b	108
      0  31ae					      NXT	CO	;Next statement to execute
      0  31ae					      db	6
      1  31ae		       06		      .byte.b	6
      0  31af					      dw	CO
      1  31af		       22 31		      .word.w	CO
      0  31b1					      IJMP	STMT
      0  31b1					      db	29
      1  31b1		       1d		      .byte.b	29
      0  31b2					      dw	STMT
      1  31b2		       2a 31		      .word.w	STMT
    236  31b4							;==================================================================================================================================
    237  31b4							; Print statement
    238  31b4							;
    239  31b4							;S3:
    240  31b4							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    241  31b4				   ekPrint
      0  31b4					      STARTIO		; Lock task until io completes
      0  31b4					      db	70
      1  31b4		       46		      .byte.b	70
    243  31b5				   S4
      0  31b5					      TSTDONE	S4a	; Test if we just want crlf printed
      0  31b5					      db	50
      1  31b5		       32		      .byte.b	50
      0  31b6					      db	(S4a-*)-1
      1  31b6		       03		      .byte.b	(S4a-*)-1
      0  31b7					      IJMP	S6
      0  31b7					      db	29
      1  31b7		       1d		      .byte.b	29
      0  31b8					      dw	S6
      1  31b8		       cf 31		      .word.w	S6
    246  31ba
    247  31ba				   S4a
      0  31ba					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  31ba					      db	101
      1  31ba		       65		      .byte.b	101
      0  31bb					      db	(S7-*)-1
      1  31bb		       1f		      .byte.b	(S7-*)-1
      0  31bc					      db	tString
      1  31bc		       a0		      .byte.b	tString
      0  31bd					      PRS		; PRINT STRING
      0  31bd					      db	2
      1  31bd		       02		      .byte.b	2
    250  31be				   S5
      0  31be					      TSTB	S6A,oComma	; IS THERE MORE?
      0  31be					      db	101
      1  31be		       65		      .byte.b	101
      0  31bf					      db	(S6A-*)-1
      1  31bf		       07		      .byte.b	(S6A-*)-1
      0  31c0					      db	oComma
      1  31c0		       e2		      .byte.b	oComma
      0  31c1					      SPC		; SPACE TO NEXT ZONE
      0  31c1					      db	4
      1  31c1		       04		      .byte.b	4
      0  31c2					      TSTDONE	S4	; Not end of line jump back
      0  31c2					      db	50
      1  31c2		       32		      .byte.b	50
      0  31c3					      db	(S4-*)-1
      1  31c3		       f1		      .byte.b	(S4-*)-1
      0  31c4					      IJMP	S6Z	; YES JUMP BACK
      0  31c4					      db	29
      1  31c4		       1d		      .byte.b	29
      0  31c5					      dw	S6Z
      1  31c5		       d1 31		      .word.w	S6Z
    255  31c7
    256  31c7							;
    257  31c7							; If a semicolon, don't do anything.
    258  31c7							;
    259  31c7				   S6A
      0  31c7					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  31c7					      db	101
      1  31c7		       65		      .byte.b	101
      0  31c8					      db	(S6-*)-1
      1  31c8		       06		      .byte.b	(S6-*)-1
      0  31c9					      db	oSemiColon
      1  31c9		       e3		      .byte.b	oSemiColon
      0  31ca					      TSTDONE	S4	; Jump Back if not end of line
      0  31ca					      db	50
      1  31ca		       32		      .byte.b	50
      0  31cb					      db	(S4-*)-1
      1  31cb		       e9		      .byte.b	(S4-*)-1
      0  31cc					      IJMP	S6Z
      0  31cc					      db	29
      1  31cc		       1d		      .byte.b	29
      0  31cd					      dw	S6Z
      1  31cd		       d1 31		      .word.w	S6Z
    263  31cf
    264  31cf				   S6
    265  31cf
      0  31cf					      DONE		; ERROR IF CR NOT NEXT
      0  31cf					      db	1
      1  31cf		       01		      .byte.b	1
      0  31d0					      NLINE
      0  31d0					      db	5
      1  31d0		       05		      .byte.b	5
    268  31d1				   S6Z
      0  31d1					      ENDIO		; release task io completed
      0  31d1					      db	71
      1  31d1		       47		      .byte.b	71
      0  31d2					      NXT	CO	; exit here if , or ; at end of print
      0  31d2					      db	6
      1  31d2		       06		      .byte.b	6
      0  31d3					      dw	CO
      1  31d3		       22 31		      .word.w	CO
      0  31d5					      IJMP	STMT
      0  31d5					      db	29
      1  31d5		       1d		      .byte.b	29
      0  31d6					      dw	STMT
      1  31d6		       2a 31		      .word.w	STMT
    272  31d8							;
    273  31d8							; A jump for code too far away for relative branch
    274  31d8							;
    275  31d8				   ERRVEC
      0  31d8					      IJMP	UNKNOWN
      0  31d8					      db	29
      1  31d8		       1d		      .byte.b	29
      0  31d9					      dw	UNKNOWN
      1  31d9		       3a 33		      .word.w	UNKNOWN
    277  31db							;
    278  31db							; Get here if there is an expression to print
    279  31db				   S7
      0  31db					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  31db					      db	101
      1  31db		       65		      .byte.b	101
      0  31dc					      db	(S7AUnsigned-*)-1
      1  31dc		       08		      .byte.b	(S7AUnsigned-*)-1
      0  31dd					      db	oDollar
      1  31dd		       e7		      .byte.b	oDollar
      0  31de					      CALL	EXPR
      0  31de					      db	28
      1  31de		       1c		      .byte.b	28
      0  31df					      dw	EXPR
      1  31df		       3e 33		      .word.w	EXPR
      0  31e1					      HEXPRT
      0  31e1					      db	67
      1  31e1		       43		      .byte.b	67
      0  31e2					      IJMP	S5
      0  31e2					      db	29
      1  31e2		       1d		      .byte.b	29
      0  31e3					      dw	S5
      1  31e3		       be 31		      .word.w	S5
    284  31e5
    285  31e5				   S7AUnsigned
    286  31e5
      0  31e5					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  31e5					      db	101
      1  31e5		       65		      .byte.b	101
      0  31e6					      db	(S7A-*)-1
      1  31e6		       0a		      .byte.b	(S7A-*)-1
      0  31e7					      db	oPercent
      1  31e7		       ed		      .byte.b	oPercent
      0  31e8					      CALL	EXPR
      0  31e8					      db	28
      1  31e8		       1c		      .byte.b	28
      0  31e9					      dw	EXPR
      1  31e9		       3e 33		      .word.w	EXPR
      0  31eb					      SETR2	tUint
      0  31eb					      db	94
      1  31eb		       5e		      .byte.b	94
      0  31ec					      db	tUint
      1  31ec		       a9		      .byte.b	tUint
      0  31ed					      PRN
      0  31ed					      db	3
      1  31ed		       03		      .byte.b	3
      0  31ee					      IJMP	S5
      0  31ee					      db	29
      1  31ee		       1d		      .byte.b	29
      0  31ef					      dw	S5
      1  31ef		       be 31		      .word.w	S5
    292  31f1
    293  31f1				   S7A
    294  31f1
      0  31f1					      CALL	EXPR
      0  31f1					      db	28
      1  31f1		       1c		      .byte.b	28
      0  31f2					      dw	EXPR
      1  31f2		       3e 33		      .word.w	EXPR
      0  31f4					      TSTB	S7B,oDollar	; Print the value as a single character
      0  31f4					      db	101
      1  31f4		       65		      .byte.b	101
      0  31f5					      db	(S7B-*)-1
      1  31f5		       05		      .byte.b	(S7B-*)-1
      0  31f6					      db	oDollar
      1  31f6		       e7		      .byte.b	oDollar
      0  31f7					      PUTCHAR
      0  31f7					      db	52
      1  31f7		       34		      .byte.b	52
      0  31f8					      IJMP	S5
      0  31f8					      db	29
      1  31f8		       1d		      .byte.b	29
      0  31f9					      dw	S5
      1  31f9		       be 31		      .word.w	S5
    299  31fb
    300  31fb				   S7B
      0  31fb					      SETR2	tInteger	; Print the value as a signed number
      0  31fb					      db	94
      1  31fb		       5e		      .byte.b	94
      0  31fc					      db	tInteger
      1  31fc		       a4		      .byte.b	tInteger
      0  31fd					      PRN		; PRINT IT
      0  31fd					      db	3
      1  31fd		       03		      .byte.b	3
      0  31fe					      IJMP	S5	; IS THERE MORE?
      0  31fe					      db	29
      1  31fe		       1d		      .byte.b	29
      0  31ff					      dw	S5
      1  31ff		       be 31		      .word.w	S5
    304  3201							;
    305  3201							;===========================================================
    306  3201							; PROCESS ALL THE TASK STATEMENTS
    307  3201							;
    308  3201							;S8:
    309  3201							;	  TSTB	      S8G,kTaske		 ; End Task
    310  3201				   ekTaske
      0  3201					      TSTB	S8NoParm,oLeftBracket
      0  3201					      db	101
      1  3201		       65		      .byte.b	101
      0  3202					      db	(S8NoParm-*)-1
      1  3202		       0c		      .byte.b	(S8NoParm-*)-1
      0  3203					      db	oLeftBracket
      1  3203		       e0		      .byte.b	oLeftBracket
      0  3204					      CALL	EXPR
      0  3204					      db	28
      1  3204		       1c		      .byte.b	28
      0  3205					      dw	EXPR
      1  3205		       3e 33		      .word.w	EXPR
      0  3207					      TSTB	UNKNOWNLnk,oRightBracket
      0  3207					      db	101
      1  3207		       65		      .byte.b	101
      0  3208					      db	(UNKNOWNLnk-*)-1
      1  3208		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  3209					      db	oRightBracket
      1  3209		       e1		      .byte.b	oRightBracket
      0  320a					      ETASK
      0  320a					      db	62
      1  320a		       3e		      .byte.b	62
      0  320b					      DONE
      0  320b					      db	1
      1  320b		       01		      .byte.b	1
      0  320c					      IJMP	STMT
      0  320c					      db	29
      1  320c		       1d		      .byte.b	29
      0  320d					      dw	STMT
      1  320d		       2a 31		      .word.w	STMT
    317  320f				   S8NoParm
      0  320f					      LIT	0
      0  320f					      db	27
      1  320f		       1b		      .byte.b	27
      0  3210					      dw	0
      1  3210		       00 00		      .word.w	0
      0  3212					      ETASK
      0  3212					      db	62
      1  3212		       3e		      .byte.b	62
      0  3213					      DONE		; Must be last thing on a line
      0  3213					      db	1
      1  3213		       01		      .byte.b	1
      0  3214					      IJMP	STMT
      0  3214					      db	29
      1  3214		       1d		      .byte.b	29
      0  3215					      dw	STMT
      1  3215		       2a 31		      .word.w	STMT
    322  3217							;
    323  3217							;===========================================================
    324  3217							; The task gives up the rest of the cycles
    325  3217							;S8G:
    326  3217							;	  TSTB	      S8a,kTaskn	 ;Next task
    327  3217				   ekTaskn
      0  3217					      NTASK
      0  3217					      db	63
      1  3217		       3f		      .byte.b	63
      0  3218					      NXT	CO	;Next statement to execute
      0  3218					      db	6
      1  3218		       06		      .byte.b	6
      0  3219					      dw	CO
      1  3219		       22 31		      .word.w	CO
      0  321b					      IJMP	STMT
      0  321b					      db	29
      1  321b		       1d		      .byte.b	29
      0  321c					      dw	STMT
      1  321c		       2a 31		      .word.w	STMT
    331  321e							;
    332  321e							;===========================================================
    333  321e							; Waits for a task or list of tasks to complete
    334  321e
    335  321e				   ekTaskw
      0  321e					      TSTB	UNKNOWNLnk,oLeftBracket
      0  321e					      db	101
      1  321e		       65		      .byte.b	101
      0  321f					      db	(UNKNOWNLnk-*)-1
      1  321f		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  3220					      db	oLeftBracket
      1  3220		       e0		      .byte.b	oLeftBracket
    337  3221				   S8TSK
      0  3221					      Call	EXPR	;Gets the PID of task to wait for
      0  3221					      db	28
      1  3221		       1c		      .byte.b	28
      0  3222					      dw	EXPR
      1  3222		       3e 33		      .word.w	EXPR
    339  3224				   S8LOOP
      0  3224					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  3224					      db	76
      1  3224		       4c		      .byte.b	76
      0  3225					      db	(S8LOOP-*)-1
      1  3225		       fe		      .byte.b	(S8LOOP-*)-1
      0  3226					      TSTB	S8aa,oComma	;Checks for more tasks
      0  3226					      db	101
      1  3226		       65		      .byte.b	101
      0  3227					      db	(S8aa-*)-1
      1  3227		       04		      .byte.b	(S8aa-*)-1
      0  3228					      db	oComma
      1  3228		       e2		      .byte.b	oComma
      0  3229					      IJMP	S8TSK	;Go for the next task number
      0  3229					      db	29
      1  3229		       1d		      .byte.b	29
      0  322a					      dw	S8TSK
      1  322a		       21 32		      .word.w	S8TSK
    343  322c				   S8aa
      0  322c					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  322c					      db	101
      1  322c		       65		      .byte.b	101
      0  322d					      db	(UNKNOWNLnk-*)-1
      1  322d		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  322e					      db	oRightBracket
      1  322e		       e1		      .byte.b	oRightBracket
      0  322f					      DONE
      0  322f					      db	1
      1  322f		       01		      .byte.b	1
      0  3230					      NXT	CO
      0  3230					      db	6
      1  3230		       06		      .byte.b	6
      0  3231					      dw	CO
      1  3231		       22 31		      .word.w	CO
      0  3233					      IJMP	STMT	;Next Statement
      0  3233					      db	29
      1  3233		       1d		      .byte.b	29
      0  3234					      dw	STMT
      1  3234		       2a 31		      .word.w	STMT
    348  3236
    349  3236
    350  3236
    351  3236				   UNKNOWNLnk
      0  3236					      iJMP	UNKNOWN
      0  3236					      db	29
      1  3236		       1d		      .byte.b	29
      0  3237					      dw	UNKNOWN
      1  3237		       3a 33		      .word.w	UNKNOWN
    353  3239
    354  3239							;
    355  3239							;===========================================================
    356  3239							; Update a memory location with a value
    357  3239							;  Use @[offset] to write a word value to memory
    358  3239							;
    359  3239							;S8a1:
    360  3239							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    361  3239				   ekPoke
      0  3239					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3239					      db	101
      1  3239		       65		      .byte.b	101
      0  323a					      db	(UNKNOWNV-*)-1
      1  323a		       9c		      .byte.b	(UNKNOWNV-*)-1
      0  323b					      db	oLeftBracket
      1  323b		       e0		      .byte.b	oLeftBracket
      0  323c					      CALL	EXPR	; Get address to write to
      0  323c					      db	28
      1  323c		       1c		      .byte.b	28
      0  323d					      dw	EXPR
      1  323d		       3e 33		      .word.w	EXPR
      0  323f					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  323f					      db	101
      1  323f		       65		      .byte.b	101
      0  3240					      db	(UNKNOWNV-*)-1
      1  3240		       96		      .byte.b	(UNKNOWNV-*)-1
      0  3241					      db	oComma
      1  3241		       e2		      .byte.b	oComma
      0  3242					      CALL	EXPR	; Get the value to poke
      0  3242					      db	28
      1  3242		       1c		      .byte.b	28
      0  3243					      dw	EXPR
      1  3243		       3e 33		      .word.w	EXPR
      0  3245					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3245					      db	101
      1  3245		       65		      .byte.b	101
      0  3246					      db	(UNKNOWNV-*)-1
      1  3246		       90		      .byte.b	(UNKNOWNV-*)-1
      0  3247					      db	oRightBracket
      1  3247		       e1		      .byte.b	oRightBracket
      0  3248					      POKEMEM
      0  3248					      db	47
      1  3248		       2f		      .byte.b	47
      0  3249					      DONE
      0  3249					      db	1
      1  3249		       01		      .byte.b	1
      0  324a					      NXT	CO	;AND SEQUENCE TO NEXT
      0  324a					      db	6
      1  324a		       06		      .byte.b	6
      0  324b					      dw	CO
      1  324b		       22 31		      .word.w	CO
      0  324d					      IJMP	STMT
      0  324d					      db	29
      1  324d		       1d		      .byte.b	29
      0  324e					      dw	STMT
      1  324e		       2a 31		      .word.w	STMT
    371  3250							;
    372  3250							;================================================================
    373  3250							; Set a block of memory to a value word or byte
    374  3250							; SetMem(Value, Length, Destination)
    375  3250				   ekSetMemB
      0  3250					      CALL	ekSetMem
      0  3250					      db	28
      1  3250		       1c		      .byte.b	28
      0  3251					      dw	ekSetMem
      1  3251		       68 32		      .word.w	ekSetMem
      0  3253					      SETBLOCK	tByte	; set value as byte
      0  3253					      db	110
      1  3253		       6e		      .byte.b	110
      0  3254					      db	tByte
      1  3254		       a2		      .byte.b	tByte
      0  3255					      DONE
      0  3255					      db	1
      1  3255		       01		      .byte.b	1
      0  3256					      NXT	CO
      0  3256					      db	6
      1  3256		       06		      .byte.b	6
      0  3257					      dw	CO
      1  3257		       22 31		      .word.w	CO
      0  3259					      IJMP	STMT
      0  3259					      db	29
      1  3259		       1d		      .byte.b	29
      0  325a					      dw	STMT
      1  325a		       2a 31		      .word.w	STMT
    381  325c
    382  325c				   ekSetMemW
      0  325c					      CALL	ekSetMem
      0  325c					      db	28
      1  325c		       1c		      .byte.b	28
      0  325d					      dw	ekSetMem
      1  325d		       68 32		      .word.w	ekSetMem
      0  325f					      SETBLOCK	tInteger	; set value as byte
      0  325f					      db	110
      1  325f		       6e		      .byte.b	110
      0  3260					      db	tInteger
      1  3260		       a4		      .byte.b	tInteger
      0  3261					      DONE
      0  3261					      db	1
      1  3261		       01		      .byte.b	1
      0  3262					      NXT	CO
      0  3262					      db	6
      1  3262		       06		      .byte.b	6
      0  3263					      dw	CO
      1  3263		       22 31		      .word.w	CO
      0  3265					      IJMP	STMT
      0  3265					      db	29
      1  3265		       1d		      .byte.b	29
      0  3266					      dw	STMT
      1  3266		       2a 31		      .word.w	STMT
    388  3268
    389  3268				   ekSetMem
      0  3268					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3268					      db	101
      1  3268		       65		      .byte.b	101
      0  3269					      db	(UNKNOWNV-*)-1
      1  3269		       6d		      .byte.b	(UNKNOWNV-*)-1
      0  326a					      db	oLeftBracket
      1  326a		       e0		      .byte.b	oLeftBracket
      0  326b					      CALL	EXPR	; Value to set
      0  326b					      db	28
      1  326b		       1c		      .byte.b	28
      0  326c					      dw	EXPR
      1  326c		       3e 33		      .word.w	EXPR
      0  326e					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  326e					      db	101
      1  326e		       65		      .byte.b	101
      0  326f					      db	(UNKNOWNV-*)-1
      1  326f		       67		      .byte.b	(UNKNOWNV-*)-1
      0  3270					      db	oComma
      1  3270		       e2		      .byte.b	oComma
      0  3271					      CALL	EXPR	; Get The Length
      0  3271					      db	28
      1  3271		       1c		      .byte.b	28
      0  3272					      dw	EXPR
      1  3272		       3e 33		      .word.w	EXPR
      0  3274					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3274					      db	101
      1  3274		       65		      .byte.b	101
      0  3275					      db	(UNKNOWNV-*)-1
      1  3275		       61		      .byte.b	(UNKNOWNV-*)-1
      0  3276					      db	oComma
      1  3276		       e2		      .byte.b	oComma
      0  3277					      CALL	EXPR	; GET the address to start at
      0  3277					      db	28
      1  3277		       1c		      .byte.b	28
      0  3278					      dw	EXPR
      1  3278		       3e 33		      .word.w	EXPR
      0  327a					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  327a					      db	101
      1  327a		       65		      .byte.b	101
      0  327b					      db	(UNKNOWNV-*)-1
      1  327b		       5b		      .byte.b	(UNKNOWNV-*)-1
      0  327c					      db	oRightBracket
      1  327c		       e1		      .byte.b	oRightBracket
      0  327d					      RTN
      0  327d					      db	25
      1  327d		       19		      .byte.b	25
    398  327e							;
    399  327e							;================================================================
    400  327e							; Copy a block of memory
    401  327e							; CopyMem(Length, Destination, Source)
    402  327e				   ekCopyMem
      0  327e					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  327e					      db	101
      1  327e		       65		      .byte.b	101
      0  327f					      db	(UNKNOWNV-*)-1
      1  327f		       57		      .byte.b	(UNKNOWNV-*)-1
      0  3280					      db	oLeftBracket
      1  3280		       e0		      .byte.b	oLeftBracket
      0  3281					      CALL	EXPR	; Length
      0  3281					      db	28
      1  3281		       1c		      .byte.b	28
      0  3282					      dw	EXPR
      1  3282		       3e 33		      .word.w	EXPR
      0  3284					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3284					      db	101
      1  3284		       65		      .byte.b	101
      0  3285					      db	(UNKNOWNV-*)-1
      1  3285		       51		      .byte.b	(UNKNOWNV-*)-1
      0  3286					      db	oComma
      1  3286		       e2		      .byte.b	oComma
      0  3287					      CALL	EXPR	; Destination
      0  3287					      db	28
      1  3287		       1c		      .byte.b	28
      0  3288					      dw	EXPR
      1  3288		       3e 33		      .word.w	EXPR
      0  328a					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  328a					      db	101
      1  328a		       65		      .byte.b	101
      0  328b					      db	(UNKNOWNV-*)-1
      1  328b		       4b		      .byte.b	(UNKNOWNV-*)-1
      0  328c					      db	oComma
      1  328c		       e2		      .byte.b	oComma
      0  328d					      CALL	EXPR	; Source
      0  328d					      db	28
      1  328d		       1c		      .byte.b	28
      0  328e					      dw	EXPR
      1  328e		       3e 33		      .word.w	EXPR
      0  3290					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3290					      db	101
      1  3290		       65		      .byte.b	101
      0  3291					      db	(UNKNOWNV-*)-1
      1  3291		       45		      .byte.b	(UNKNOWNV-*)-1
      0  3292					      db	oRightBracket
      1  3292		       e1		      .byte.b	oRightBracket
      0  3293					      COPYBLOCK		; Copy the memory
      0  3293					      db	111
      1  3293		       6f		      .byte.b	111
      0  3294					      DONE
      0  3294					      db	1
      1  3294		       01		      .byte.b	1
      0  3295					      NXT	CO
      0  3295					      db	6
      1  3295		       06		      .byte.b	6
      0  3296					      dw	CO
      1  3296		       22 31		      .word.w	CO
      0  3298					      IJMP	STMT
      0  3298					      db	29
      1  3298		       1d		      .byte.b	29
      0  3299					      dw	STMT
      1  3299		       2a 31		      .word.w	STMT
    414  329b
    415  329b							;================================================================
    416  329b							; Write a single byte to the output device
    417  329b							;
    418  329b				   ekPutch
      0  329b					      CALL	EXPR
      0  329b					      db	28
      1  329b		       1c		      .byte.b	28
      0  329c					      dw	EXPR
      1  329c		       3e 33		      .word.w	EXPR
      0  329e					      PUTCHAR
      0  329e					      db	52
      1  329e		       34		      .byte.b	52
      0  329f					      DONE
      0  329f					      db	1
      1  329f		       01		      .byte.b	1
      0  32a0					      NXT	CO	;AND SEQUENCE TO NEXT
      0  32a0					      db	6
      1  32a0		       06		      .byte.b	6
      0  32a1					      dw	CO
      1  32a1		       22 31		      .word.w	CO
      0  32a3					      IJMP	STMT
      0  32a3					      db	29
      1  32a3		       1d		      .byte.b	29
      0  32a4					      dw	STMT
      1  32a4		       2a 31		      .word.w	STMT
    424  32a6							;================================================================
    425  32a6							; Clear the screen lines
    426  32a6							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    427  32a6							;
    428  32a6				   ekCls
      0  32a6					      CLEARSCREEN
      0  32a6					      db	46
      1  32a6		       2e		      .byte.b	46
      0  32a7					      NXT	CO	;AND SEQUENCE TO NEXT
      0  32a7					      db	6
      1  32a7		       06		      .byte.b	6
      0  32a8					      dw	CO
      1  32a8		       22 31		      .word.w	CO
      0  32aa					      IJMP	STMT
      0  32aa					      db	29
      1  32aa		       1d		      .byte.b	29
      0  32ab					      dw	STMT
      1  32ab		       2a 31		      .word.w	STMT
    432  32ad							;==================================================================
    433  32ad							; Get input from the terminal
    434  32ad							;   Reads from the currently active input device
    435  32ad							;
    436  32ad				   ekInput
    437  32ad				   S10
      0  32ad					      TSTB	S10A,tString	;If there is a string print the prompt
      0  32ad					      db	101
      1  32ad		       65		      .byte.b	101
      0  32ae					      db	(S10A-*)-1
      1  32ae		       05		      .byte.b	(S10A-*)-1
      0  32af					      db	tString
      1  32af		       a0		      .byte.b	tString
      0  32b0					      PRS
      0  32b0					      db	2
      1  32b0		       02		      .byte.b	2
      0  32b1					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  32b1					      db	101
      1  32b1		       65		      .byte.b	101
      0  32b2					      db	(S10Z-*)-1
      1  32b2		       19		      .byte.b	(S10Z-*)-1
      0  32b3					      db	oSemiColon
      1  32b3		       e3		      .byte.b	oSemiColon
    441  32b4				   S10A
      0  32b4					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  32b4					      db	33
      1  32b4		       21		      .byte.b	33
      0  32b5					      db	(UNKNOWN-*)-1
      1  32b5		       84		      .byte.b	(UNKNOWN-*)-1
      0  32b6					      CALL	FactVarPtrNoTst
      0  32b6					      db	28
      1  32b6		       1c		      .byte.b	28
      0  32b7					      dw	FactVarPtrNoTst
      1  32b7		       eb 34		      .word.w	FactVarPtrNoTst
    444  32b9							;	  TSTB	     S10ACONT,oBang	      ; Print from another task
    445  32b9							;	  IND
    446  32b9							;	  TSTVT      UNKNOWN
    447  32b9
    448  32b9				   S10ACONT
      0  32b9					      TSTB	S10A1,oDollar
      0  32b9					      db	101
      1  32b9		       65		      .byte.b	101
      0  32ba					      db	(S10A1-*)-1
      1  32ba		       07		      .byte.b	(S10A1-*)-1
      0  32bb					      db	oDollar
      1  32bb		       e7		      .byte.b	oDollar
      0  32bc					      INSTR		;Move character From tty to AESTK
      0  32bc					      db	59
      1  32bc		       3b		      .byte.b	59
      0  32bd					      SETR2	tByte
      0  32bd					      db	94
      1  32bd		       5e		      .byte.b	94
      0  32be					      db	tByte
      1  32be		       a2		      .byte.b	tByte
      0  32bf					      IJMP	S10A2
      0  32bf					      db	29
      1  32bf		       1d		      .byte.b	29
      0  32c0					      dw	S10A2
      1  32c0		       c5 32		      .word.w	S10A2
    453  32c2				   S10A1
      0  32c2					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  32c2					      db	11
      1  32c2		       0b		      .byte.b	11
      0  32c3					      SETR2	tInteger
      0  32c3					      db	94
      1  32c3		       5e		      .byte.b	94
      0  32c4					      db	tInteger
      1  32c4		       a4		      .byte.b	tInteger
    456  32c5				   S10A2
      0  32c5					      STORE		;STORE IT
      0  32c5					      db	19
      1  32c5		       13		      .byte.b	19
      0  32c6					      TSTB	S11,oComma	;IS THERE MORE?
      0  32c6					      db	101
      1  32c6		       65		      .byte.b	101
      0  32c7					      db	(S11-*)-1
      1  32c7		       07		      .byte.b	(S11-*)-1
      0  32c8					      db	oComma
      1  32c8		       e2		      .byte.b	oComma
      0  32c9					      IJMP	S10	;YES
      0  32c9					      db	29
      1  32c9		       1d		      .byte.b	29
      0  32ca					      dw	S10
      1  32ca		       ad 32		      .word.w	S10
    460  32cc				   S10Z
      0  32cc					      iJMP	UNKNOWN
      0  32cc					      db	29
      1  32cc		       1d		      .byte.b	29
      0  32cd					      dw	UNKNOWN
      1  32cd		       3a 33		      .word.w	UNKNOWN
    462  32cf				   S11
      0  32cf					      DONE		;MUST BE CR
      0  32cf					      db	1
      1  32cf		       01		      .byte.b	1
      0  32d0					      NXT	CO	;SEQUENCE TO NEXT
      0  32d0					      db	6
      1  32d0		       06		      .byte.b	6
      0  32d1					      dw	CO
      1  32d1		       22 31		      .word.w	CO
      0  32d3					      IJMP	STMT
      0  32d3					      db	29
      1  32d3		       1d		      .byte.b	29
      0  32d4					      dw	STMT
      1  32d4		       2a 31		      .word.w	STMT
    466  32d6							;=====================================================================
    467  32d6							; End of program, return to command line process
    468  32d6							; Main Task may also use taske or return to stopped
    469  32d6							;
    470  32d6				   ekEnd
      0  32d6					      FIN
      0  32d6					      db	12
      1  32d6		       0c		      .byte.b	12
    472  32d7				   UNKNOWNV
      0  32d7					      IJMP	UNKNOWN
      0  32d7					      db	29
      1  32d7		       1d		      .byte.b	29
      0  32d8					      dw	UNKNOWN
      1  32d8		       3a 33		      .word.w	UNKNOWN
    474  32da							;====================================================================
    475  32da							; IRQ <IRQ-HANDLER-Line expression>
    476  32da							;   Specify a line number subroutine to call when an interupt is processed
    477  32da							;   These subroutines must use iret to return.
    478  32da							;
    479  32da				   ekIrq
      0  32da					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  32da					      db	28
      1  32da		       1c		      .byte.b	28
      0  32db					      dw	EXPR
      1  32db		       3e 33		      .word.w	EXPR
      0  32dd					      DONE		;must be CR
      0  32dd					      db	1
      1  32dd		       01		      .byte.b	1
      0  32de					      SETIRQ		;Set the line number now
      0  32de					      db	56
      1  32de		       38		      .byte.b	56
      0  32df					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  32df					      db	6
      1  32df		       06		      .byte.b	6
      0  32e0					      dw	CO
      1  32e0		       22 31		      .word.w	CO
      0  32e2					      IJMP	STMT
      0  32e2					      db	29
      1  32e2		       1d		      .byte.b	29
      0  32e3					      dw	STMT
      1  32e3		       2a 31		      .word.w	STMT
    485  32e5
    486  32e5							;=========================================================================
    487  32e5							; KILL PID-expression	 kill a running task
    488  32e5							;  ignored of task has already stopped
    489  32e5							;
    490  32e5				   ekKill
      0  32e5					      CALL	EXPR
      0  32e5					      db	28
      1  32e5		       1c		      .byte.b	28
      0  32e6					      dw	EXPR
      1  32e6		       3e 33		      .word.w	EXPR
      0  32e8					      DONE
      0  32e8					      db	1
      1  32e8		       01		      .byte.b	1
      0  32e9					      TASKKILL
      0  32e9					      db	65
      1  32e9		       41		      .byte.b	65
      0  32ea					      NXT	CO
      0  32ea					      db	6
      1  32ea		       06		      .byte.b	6
      0  32eb					      dw	CO
      1  32eb		       22 31		      .word.w	CO
      0  32ed					      IJMP	STMT
      0  32ed					      db	29
      1  32ed		       1d		      .byte.b	29
      0  32ee					      dw	STMT
      1  32ee		       2a 31		      .word.w	STMT
    496  32f0
    497  32f0							;============================================================================
    498  32f0							; List all program lines
    499  32f0							;
    500  32f0				   ekList
      0  32f0					      DONE
      0  32f0					      db	1
      1  32f0		       01		      .byte.b	1
      0  32f1					      LST
      0  32f1					      db	21
      1  32f1		       15		      .byte.b	21
      0  32f2					      IJMP	CO
      0  32f2					      db	29
      1  32f2		       1d		      .byte.b	29
      0  32f3					      dw	CO
      1  32f3		       22 31		      .word.w	CO
    504  32f5							;=======================================================================
    505  32f5							;RUN begin to executed the program in memory
    506  32f5							;
    507  32f5				   ekRun
      0  32f5					      DONE
      0  32f5					      db	1
      1  32f5		       01		      .byte.b	1
      0  32f6					      VINIT		;clear variables compile the line numbers
      0  32f6					      db	30
      1  32f6		       1e		      .byte.b	30
      0  32f7					      LIT	1	;GOTO line 1
      0  32f7					      db	27
      1  32f7		       1b		      .byte.b	27
      0  32f8					      dw	1
      1  32f8		       01 00		      .word.w	1
      0  32fa					      XFER		;Bob's addition
      0  32fa					      db	7
      1  32fa		       07		      .byte.b	7
    512  32fb							; EXIT
      0  32fb					      IJMP	STMT	;and run!
      0  32fb					      db	29
      1  32fb		       1d		      .byte.b	29
      0  32fc					      dw	STMT
      1  32fc		       2a 31		      .word.w	STMT
    514  32fe							;=========================================================================
    515  32fe							;Clear the program memory, delete all proram lines
    516  32fe							;
    517  32fe				   ekNew
      0  32fe					      DONE
      0  32fe					      db	1
      1  32fe		       01		      .byte.b	1
      0  32ff					      IJMP	START
      0  32ff					      db	29
      1  32ff		       1d		      .byte.b	29
      0  3300					      dw	START
      1  3300		       1c 31		      .word.w	START
    520  3302
    521  3302							;========================================================================
    522  3302							; Slice(slice legth expression)
    523  3302							;   set the length of time between task switches
    524  3302							;
    525  3302				   ekSlice
      0  3302					      CALL	EXPR
      0  3302					      db	28
      1  3302		       1c		      .byte.b	28
      0  3303					      dw	EXPR
      1  3303		       3e 33		      .word.w	EXPR
      0  3305					      SLICE
      0  3305					      db	100
      1  3305		       64		      .byte.b	100
      0  3306					      DONE
      0  3306					      db	1
      1  3306		       01		      .byte.b	1
      0  3307					      NXT	CO
      0  3307					      db	6
      1  3307		       06		      .byte.b	6
      0  3308					      dw	CO
      1  3308		       22 31		      .word.w	CO
      0  330a					      IJMP	STMT
      0  330a					      db	29
      1  330a		       1d		      .byte.b	29
      0  330b					      dw	STMT
      1  330b		       2a 31		      .word.w	STMT
    531  330d							;==========================================================================
    532  330d							; Turn off and on the thrace functions
    533  330d							; a debug terminal needs to be available
    534  330d							; Trace( Trace flag expression)
    535  330d							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    536  330d							;	for individual lines of basic code. These can be combined
    537  330d				   ekTrace
      0  330d					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  330d					      db	101
      1  330d		       65		      .byte.b	101
      0  330e					      db	(UNKNOWN-*)-1
      1  330e		       2b		      .byte.b	(UNKNOWN-*)-1
      0  330f					      db	oLeftBracket
      1  330f		       e0		      .byte.b	oLeftBracket
      0  3310					      CALL	EXPR
      0  3310					      db	28
      1  3310		       1c		      .byte.b	28
      0  3311					      dw	EXPR
      1  3311		       3e 33		      .word.w	EXPR
      0  3313					      TSTB	UNKNOWN,oRightBracket
      0  3313					      db	101
      1  3313		       65		      .byte.b	101
      0  3314					      db	(UNKNOWN-*)-1
      1  3314		       25		      .byte.b	(UNKNOWN-*)-1
      0  3315					      db	oRightBracket
      1  3315		       e1		      .byte.b	oRightBracket
      0  3316					      TRACEPROGRAM
      0  3316					      db	78
      1  3316		       4e		      .byte.b	78
      0  3317					      DONE
      0  3317					      db	1
      1  3317		       01		      .byte.b	1
      0  3318					      NXT	CO
      0  3318					      db	6
      1  3318		       06		      .byte.b	6
      0  3319					      dw	CO
      1  3319		       22 31		      .word.w	CO
      0  331b					      IJMP	STMT
      0  331b					      db	29
      1  331b		       1d		      .byte.b	29
      0  331c					      dw	STMT
      1  331c		       2a 31		      .word.w	STMT
    545  331e							;=====================================================================
    546  331e							; Exit basic to machine monitor
    547  331e							;
    548  331e				   ekExit
      0  331e					      EXIT
      0  331e					      db	26
      1  331e		       1a		      .byte.b	26
    550  331f
    551  331f							;=======================================================================
    552  331f							; Commands related to saving/restoring programs
    553  331f							; to/from mass storage.
    554  331f							;=======================================================================
    555  331f							; Save a program file
    556  331f							;
    557  331f					      if	(XKIM || CTMON65) && DISK_ACCESS
    558  331f
    559  331f				   ekSave
      0  331f					      OPENWRITE	OPEN_CREATE
      0  331f					      db	40
      1  331f		       28		      .byte.b	40
      0  3320					      db	OPEN_CREATE
      1  3320		       01		      .byte.b	OPEN_CREATE
      0  3321					      DLIST
      0  3321					      db	43
      1  3321		       2b		      .byte.b	43
      0  3322					      DCLOSE
      0  3322					      db	41
      1  3322		       29		      .byte.b	41
      0  3323					      IJMP	CO
      0  3323					      db	29
      1  3323		       1d		      .byte.b	29
      0  3324					      dw	CO
      1  3324		       22 31		      .word.w	CO
    564  3326							;=========================================================================
    565  3326							; Load a program file
    566  3326							;
    567  3326				   ekLoad
      0  3326					      OPENREAD
      0  3326					      db	39
      1  3326		       27		      .byte.b	39
    569  3327				   S17CLP
      0  3327					      DGETLINE		;get line from file
      0  3327					      db	42
      1  3327		       2a		      .byte.b	42
      0  3328					      TSTL	S17EOL	;no line num means EOL
      0  3328					      db	34
      1  3328		       22		      .byte.b	34
      0  3329					      db	(S17EOL-*)-1
      1  3329		       04		      .byte.b	(S17EOL-*)-1
      0  332a					      INSERT		;put it into the program
      0  332a					      db	24
      1  332a		       18		      .byte.b	24
      0  332b					      IJMP	S17CLP	;keep going
      0  332b					      db	29
      1  332b		       1d		      .byte.b	29
      0  332c					      dw	S17CLP
      1  332c		       27 33		      .word.w	S17CLP
    574  332e				   S17EOL
      0  332e					      DCLOSE		;close disk file
      0  332e					      db	41
      1  332e		       29		      .byte.b	41
      0  332f					      IJMP	CO	;back to start
      0  332f					      db	29
      1  332f		       1d		      .byte.b	29
      0  3330					      dw	CO
      1  3330		       22 31		      .word.w	CO
    577  3332							;=========================================================================
    578  3332							; Display the directory content
    579  3332							;
    580  3332				   ekDir
      0  3332					      DDIR		;Display the directory content
      0  3332					      db	44
      1  3332		       2c		      .byte.b	44
      0  3333					      IJMP	CO
      0  3333					      db	29
      1  3333		       1d		      .byte.b	29
      0  3334					      dw	CO
      1  3334		       22 31		      .word.w	CO
    583  3336							;=========================================================================
    584  3336							; Erase a file from disk
    585  3336							;
    586  3336				   ekErase
      0  3336					      RMFILE		;Erase the file from the disk
      0  3336					      db	45
      1  3336		       2d		      .byte.b	45
      0  3337					      IJMP	CO
      0  3337					      db	29
      1  3337		       1d		      .byte.b	29
      0  3338					      dw	CO
      1  3338		       22 31		      .word.w	CO
    589  333a
    590  333a					      endif
    591  333a
    592  333a							;===========================================================================
    593  333a							; Else, unknown command.
    594  333a							;
    595  333a				   UNKNOWN
      0  333a					      ENDIO
      0  333a					      db	71
      1  333a		       47		      .byte.b	71
    597  333b
    598  333b				   NotKnownStatement
    599  333b
      0  333b					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  333b					      db	13
      1  333b		       0d		      .byte.b	13
      0  333c					      dw	ERR_SYNTAX
      1  333c		       05 00		      .word.w	ERR_SYNTAX
    601  333e
    602  333e							;=======================================================
    603  333e							; Process Expresions, precidence is represented by the
    604  333e							; various call levels
    605  333e							;
      0  333e				   EXPR       TSTB	EXPRNEXT,oLeftBracket
      0  333e					      db	101
      1  333e		       65		      .byte.b	101
      0  333f					      db	(EXPRNEXT-*)-1
      1  333f		       0c		      .byte.b	(EXPRNEXT-*)-1
      0  3340					      db	oLeftBracket
      1  3340		       e0		      .byte.b	oLeftBracket
      0  3341					      Call	EXPR
      0  3341					      db	28
      1  3341		       1c		      .byte.b	28
      0  3342					      dw	EXPR
      1  3342		       3e 33		      .word.w	EXPR
      0  3344					      TSTB	ExpectBrace,oRightBracket
      0  3344					      db	101
      1  3344		       65		      .byte.b	101
      0  3345					      db	(ExpectBrace-*)-1
      1  3345		       02		      .byte.b	(ExpectBrace-*)-1
      0  3346					      db	oRightBracket
      1  3346		       e1		      .byte.b	oRightBracket
      0  3347					      RTN
      0  3347					      db	25
      1  3347		       19		      .byte.b	25
    610  3348
    611  3348				   ExpectBrace
      0  3348					      ENDIO
      0  3348					      db	71
      1  3348		       47		      .byte.b	71
      0  3349					      ERRMSG	ERR_CLOSINGBRACKET
      0  3349					      db	13
      1  3349		       0d		      .byte.b	13
      0  334a					      dw	ERR_CLOSINGBRACKET
      1  334a		       17 00		      .word.w	ERR_CLOSINGBRACKET
    614  334c
    615  334c				   EXPRNEXT
      0  334c					      TSTB	EXPRLOGS,kNot
      0  334c					      db	101
      1  334c		       65		      .byte.b	101
      0  334d					      db	(EXPRLOGS-*)-1
      1  334d		       06		      .byte.b	(EXPRLOGS-*)-1
      0  334e					      db	kNot
      1  334e		       24		      .byte.b	kNot
    617  334f				   ekNot
      0  334f					      Call	EXPR
      0  334f					      db	28
      1  334f		       1c		      .byte.b	28
      0  3350					      dw	EXPR
      1  3350		       3e 33		      .word.w	EXPR
      0  3352					      LOGNOT
      0  3352					      db	72
      1  3352		       48		      .byte.b	72
      0  3353					      RTN
      0  3353					      db	25
      1  3353		       19		      .byte.b	25
    621  3354
    622  3354
    623  3354							;=========================================================
    624  3354							;Look for logical operators, but does get first part of expression
    625  3354				   EXPRLOGS
      0  3354					      Call	EXPRCMP
      0  3354					      db	28
      1  3354		       1c		      .byte.b	28
      0  3355					      dw	EXPRCMP
      1  3355		       7c 33		      .word.w	EXPRCMP
    627  3357							;=========================================================
    628  3357							;Look for shift left and shift right level
    629  3357				   EXPSHIFT
      0  3357					      OnGoto	BasicShift,EXPRLOGICAL
      0  3357					      db	103
      1  3357		       67		      .byte.b	103
      0  3358					      dw	BasicShift
      1  3358		       f2 30		      .word.w	BasicShift
      0  335a					      dw	EXPRLOGICAL
      1  335a		       68 33		      .word.w	EXPRLOGICAL
    631  335c
    632  335c				   ekShiftLeft
      0  335c					      Call	EXPR
      0  335c					      db	28
      1  335c		       1c		      .byte.b	28
      0  335d					      dw	EXPR
      1  335d		       3e 33		      .word.w	EXPR
      0  335f					      SHIFT	0
      0  335f					      db	113
      1  335f		       71		      .byte.b	113
      0  3360					      db	0
      1  3360		       00		      .byte.b	0
      0  3361					      RTN
      0  3361					      db	25
      1  3361		       19		      .byte.b	25
    636  3362
    637  3362				   ekShiftRight
      0  3362					      Call	EXPR
      0  3362					      db	28
      1  3362		       1c		      .byte.b	28
      0  3363					      dw	EXPR
      1  3363		       3e 33		      .word.w	EXPR
      0  3365					      SHIFT	1
      0  3365					      db	113
      1  3365		       71		      .byte.b	113
      0  3366					      db	1
      1  3366		       01		      .byte.b	1
      0  3367					      RTN
      0  3367					      db	25
      1  3367		       19		      .byte.b	25
    641  3368
    642  3368							;======================================================================
    643  3368				   EXPRLOGICAL
      0  3368					      OnGoto	BasicLogical,iLOGExit
      0  3368					      db	103
      1  3368		       67		      .byte.b	103
      0  3369					      dw	BasicLogical
      1  3369		       ea 30		      .word.w	BasicLogical
      0  336b					      dw	iLOGExit
      1  336b		       7b 33		      .word.w	iLOGExit
    645  336d				   ekAnd
      0  336d					      Call	EXPR
      0  336d					      db	28
      1  336d		       1c		      .byte.b	28
      0  336e					      dw	EXPR
      1  336e		       3e 33		      .word.w	EXPR
      0  3370					      LOGAND
      0  3370					      db	74
      1  3370		       4a		      .byte.b	74
      0  3371					      RTN
      0  3371					      db	25
      1  3371		       19		      .byte.b	25
    649  3372				   ekOr
      0  3372					      Call	EXPR
      0  3372					      db	28
      1  3372		       1c		      .byte.b	28
      0  3373					      dw	EXPR
      1  3373		       3e 33		      .word.w	EXPR
      0  3375					      LOGOR
      0  3375					      db	73
      1  3375		       49		      .byte.b	73
      0  3376					      RTN
      0  3376					      db	25
      1  3376		       19		      .byte.b	25
    653  3377				   ekXor
      0  3377					      Call	EXPR
      0  3377					      db	28
      1  3377		       1c		      .byte.b	28
      0  3378					      dw	EXPR
      1  3378		       3e 33		      .word.w	EXPR
      0  337a					      LOGXOR
      0  337a					      db	75
      1  337a		       4b		      .byte.b	75
    656  337b				   iLOGExit
      0  337b					      RTN
      0  337b					      db	25
      1  337b		       19		      .byte.b	25
    658  337c							;========================================================================
    659  337c							; Process relational operators
    660  337c							;
    661  337c				   EXPRCMP
      0  337c					      Call	EXPR2	; get the left first expression
      0  337c					      db	28
      1  337c		       1c		      .byte.b	28
      0  337d					      dw	EXPR2
      1  337d		       87 33		      .word.w	EXPR2
      0  337f					      TSTRELOP	iRDone	; Exit level if no rel ops found
      0  337f					      db	104
      1  337f		       68		      .byte.b	104
      0  3380					      db	(iRDone-*)-1
      1  3380		       05		      .byte.b	(iRDone-*)-1
    664  3381							;	  TSTB	     iR0,oEqual
    665  3381							;	  LIT	     2		     ;=
    666  3381							;	  IJMP	     iRFound
    667  3381							;iR0:
    668  3381							;	  TSTB	      iR1,oLessEqual
    669  3381							;	  LIT	      3 	      ;<=
    670  3381							;	  IJMP	     iRFound
    671  3381							;iR1:
    672  3381							;	  TSTB	     iR3,oNotEqual
    673  3381							;	  LIT	     5		      ;<>
    674  3381							;	      IJMP	  iRFound
    675  3381							;iR3:
    676  3381							;	  TSTB	     iR4,oLess
    677  3381							;	  LIT	     1		     ;<
    678  3381							;	      IJMP	  iRFound
    679  3381							;iR4:
    680  3381							;	  TST	     iR5,oGreaterEqual
    681  3381							;	  LIT	     6		     ;>=
    682  3381							;	      IJMP	  iRFound
    683  3381							;iR5:
    684  3381							;	  TSTB	     iRDone,oGreater
    685  3381							;	  LIT	     4		     ;>
    686  3381				   iRFound
      0  3381					      Call	EXPR	; get the right side of the expression
      0  3381					      db	28
      1  3381		       1c		      .byte.b	28
      0  3382					      dw	EXPR
      1  3382		       3e 33		      .word.w	EXPR
      0  3384					      CMPR		; Push the value of the true false onto the stack
      0  3384					      db	10
      1  3384		       0a		      .byte.b	10
      0  3385					      RTN
      0  3385					      db	25
      1  3385		       19		      .byte.b	25
    690  3386
    691  3386				   iRDone
      0  3386					      RTN
      0  3386					      db	25
      1  3386		       19		      .byte.b	25
    693  3387
    694  3387				   EXPR2
      0  3387					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  3387					      db	101
      1  3387		       65		      .byte.b	101
      0  3388					      db	(E0-*)-1
      1  3388		       08		      .byte.b	(E0-*)-1
      0  3389					      db	oMinus
      1  3389		       eb		      .byte.b	oMinus
      0  338a					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  338a					      db	28
      1  338a		       1c		      .byte.b	28
      0  338b					      dw	TERM
      1  338b		       ad 33		      .word.w	TERM
      0  338d					      NEG		; Make value negated
      0  338d					      db	16
      1  338d		       10		      .byte.b	16
      0  338e					      IJMP	E1	; We have Left term process operators next
      0  338e					      db	29
      1  338e		       1d		      .byte.b	29
      0  338f					      dw	E1
      1  338f		       97 33		      .word.w	E1
    699  3391				   E0
      0  3391					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  3391					      db	101
      1  3391		       65		      .byte.b	101
      0  3392					      db	(E1A-*)-1
      1  3392		       01		      .byte.b	(E1A-*)-1
      0  3393					      db	oPlus
      1  3393		       ea		      .byte.b	oPlus
    701  3394				   E1A
      0  3394					      CALL	TERM	; Get the left term if it was not negated
      0  3394					      db	28
      1  3394		       1c		      .byte.b	28
      0  3395					      dw	TERM
      1  3395		       ad 33		      .word.w	TERM
    703  3397				   E1
      0  3397					      TST	E2,oPlus	; Check if we are adding left term to something
      0  3397					      db	32
      1  3397		       20		      .byte.b	32
      0  3398					      db	(E2-*)-1
      1  3398		       09		      .byte.b	(E2-*)-1
      0  3399					      db	oPlus,0
      1  3399		       ea 00		      .byte.b	oPlus,0
      0  339b					      CALL	TERM	; if adding then get the right side term
      0  339b					      db	28
      1  339b		       1c		      .byte.b	28
      0  339c					      dw	TERM
      1  339c		       ad 33		      .word.w	TERM
      0  339e					      ADD		; Add it to left term
      0  339e					      db	14
      1  339e		       0e		      .byte.b	14
      0  339f					      IJMP	E1	; look for next + or -
      0  339f					      db	29
      1  339f		       1d		      .byte.b	29
      0  33a0					      dw	E1
      1  33a0		       97 33		      .word.w	E1
    708  33a2				   E2
      0  33a2					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  33a2					      db	101
      1  33a2		       65		      .byte.b	101
      0  33a3					      db	(E3-*)-1
      1  33a3		       08		      .byte.b	(E3-*)-1
      0  33a4					      db	oMinus
      1  33a4		       eb		      .byte.b	oMinus
      0  33a5					      CALL	TERM	; get right side to subtract Diffrence
      0  33a5					      db	28
      1  33a5		       1c		      .byte.b	28
      0  33a6					      dw	TERM
      1  33a6		       ad 33		      .word.w	TERM
      0  33a8					      SUB		; Subtract the value
      0  33a8					      db	15
      1  33a8		       0f		      .byte.b	15
      0  33a9					      IJMP	E1	; Look for next + or -
      0  33a9					      db	29
      1  33a9		       1d		      .byte.b	29
      0  33aa					      dw	E1
      1  33aa		       97 33		      .word.w	E1
    713  33ac				   E3			; Finish processing the expression
      0  33ac					      RTN		; We are finished processing the Expression
      0  33ac					      db	25
      1  33ac		       19		      .byte.b	25
    715  33ad							;
    716  33ad							; Get one of the terms of an expression
    717  33ad							;
    718  33ad				   TERM
      0  33ad					      CALL	FACT	; Get a value
      0  33ad					      db	28
      1  33ad		       1c		      .byte.b	28
      0  33ae					      dw	FACT
      1  33ae		       d2 33		      .word.w	FACT
    720  33b0				   T0			; Check for higher precidence operators
      0  33b0					      TSTB	T1,oMultiply	; Check for *
      0  33b0					      db	101
      1  33b0		       65		      .byte.b	101
      0  33b1					      db	(T1-*)-1
      1  33b1		       08		      .byte.b	(T1-*)-1
      0  33b2					      db	oMultiply
      1  33b2		       ee		      .byte.b	oMultiply
      0  33b3					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  33b3					      db	28
      1  33b3		       1c		      .byte.b	28
      0  33b4					      dw	FACT
      1  33b4		       d2 33		      .word.w	FACT
      0  33b6					      MUL		; Multiply factors
      0  33b6					      db	17
      1  33b6		       11		      .byte.b	17
      0  33b7					      IJMP	T0	; Check for * or /
      0  33b7					      db	29
      1  33b7		       1d		      .byte.b	29
      0  33b8					      dw	T0
      1  33b8		       b0 33		      .word.w	T0
    725  33ba				   T1
      0  33ba					      TSTB	T2,oDivide	; Check for a division
      0  33ba					      db	101
      1  33ba		       65		      .byte.b	101
      0  33bb					      db	(T2-*)-1
      1  33bb		       08		      .byte.b	(T2-*)-1
      0  33bc					      db	oDivide
      1  33bc		       ec		      .byte.b	oDivide
      0  33bd					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  33bd					      db	28
      1  33bd		       1c		      .byte.b	28
      0  33be					      dw	FACT
      1  33be		       d2 33		      .word.w	FACT
      0  33c0					      DIV		; do division
      0  33c0					      db	18
      1  33c0		       12		      .byte.b	18
      0  33c1					      IJMP	T0	; check for more * or /
      0  33c1					      db	29
      1  33c1		       1d		      .byte.b	29
      0  33c2					      dw	T0
      1  33c2		       b0 33		      .word.w	T0
    730  33c4				   T2
      0  33c4					      TSTB	T3,oModulo	; Check for a division
      0  33c4					      db	101
      1  33c4		       65		      .byte.b	101
      0  33c5					      db	(T3-*)-1
      1  33c5		       08		      .byte.b	(T3-*)-1
      0  33c6					      db	oModulo
      1  33c6		       ed		      .byte.b	oModulo
      0  33c7					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  33c7					      db	28
      1  33c7		       1c		      .byte.b	28
      0  33c8					      dw	FACT
      1  33c8		       d2 33		      .word.w	FACT
      0  33ca					      MODULO		; do division for remainder
      0  33ca					      db	60
      1  33ca		       3c		      .byte.b	60
      0  33cb					      IJMP	T0	; check for more * or / or %
      0  33cb					      db	29
      1  33cb		       1d		      .byte.b	29
      0  33cc					      dw	T0
      1  33cc		       b0 33		      .word.w	T0
    735  33ce				   T3			; Finish processing the Term
      0  33ce					      RTN
      0  33ce					      db	25
      1  33ce		       19		      .byte.b	25
    737  33cf
    738  33cf				   UNKNOWNVEC
      0  33cf					      IJMP	UNKNOWN
      0  33cf					      db	29
      1  33cf		       1d		      .byte.b	29
      0  33d0					      dw	UNKNOWN
      1  33d0		       3a 33		      .word.w	UNKNOWN
    740  33d2
    741  33d2							;=============================================================================================
    742  33d2							; Factor an expression.  Always test for functions
    743  33d2							; first or else they'll be confused for variables.
    744  33d2							;
    745  33d2				   FACT
      0  33d2					      OnGoto	BasicFuncs,FactNumber
      0  33d2					      db	103
      1  33d2		       67		      .byte.b	103
      0  33d3					      dw	BasicFuncs
      1  33d3		       f8 30		      .word.w	BasicFuncs
      0  33d5					      dw	FactNumber
      1  33d5		       bb 34		      .word.w	FactNumber
    747  33d7
    748  33d7							;FACTCONTINUE:
    749  33d7							;	  TSTB	     F1AA,kTrue
    750  33d7				   ekTrue
      0  33d7					      LIT	-1
      0  33d7					      db	27
      1  33d7		       1b		      .byte.b	27
      0  33d8					      dw	-1
      1  33d8		       ff ff		      .word.w	-1
      0  33da					      RTN
      0  33da					      db	25
      1  33da		       19		      .byte.b	25
    753  33db							;F1AA:
    754  33db							;	  TSTB	     F1AB,kFalse
    755  33db				   ekFalse
      0  33db					      LIT	0
      0  33db					      db	27
      1  33db		       1b		      .byte.b	27
      0  33dc					      dw	0
      1  33dc		       00 00		      .word.w	0
      0  33de					      RTN
      0  33de					      db	25
      1  33de		       19		      .byte.b	25
    758  33df							;==================================================================================
    759  33df							; Returns the amount of free SPACE
    760  33df				   ekFree
      0  33df					      TSTB	UNKNOWNVEC,oLeftBracket
      0  33df					      db	101
      1  33df		       65		      .byte.b	101
      0  33e0					      db	(UNKNOWNVEC-*)-1
      1  33e0		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  33e1					      db	oLeftBracket
      1  33e1		       e0		      .byte.b	oLeftBracket
      0  33e2					      TSTB	UNKNOWNVEC,oRightBracket
      0  33e2					      db	101
      1  33e2		       65		      .byte.b	101
      0  33e3					      db	(UNKNOWNVEC-*)-1
      1  33e3		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  33e4					      db	oRightBracket
      1  33e4		       e1		      .byte.b	oRightBracket
      0  33e5					      FREE
      0  33e5					      db	36
      1  33e5		       24		      .byte.b	36
      0  33e6					      RTN
      0  33e6					      db	25
      1  33e6		       19		      .byte.b	25
    765  33e7							;===================================================================================
    766  33e7							; getch() read a character from the input device
    767  33e7							;
    768  33e7				   ekGetch
      0  33e7					      TSTB	UNKNOWNVEC,oLeftBracket
      0  33e7					      db	101
      1  33e7		       65		      .byte.b	101
      0  33e8					      db	(UNKNOWNVEC-*)-1
      1  33e8		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  33e9					      db	oLeftBracket
      1  33e9		       e0		      .byte.b	oLeftBracket
      0  33ea					      TSTB	UNKNOWNVEC,oRightBracket
      0  33ea					      db	101
      1  33ea		       65		      .byte.b	101
      0  33eb					      db	(UNKNOWNVEC-*)-1
      1  33eb		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  33ec					      db	oRightBracket
      1  33ec		       e1		      .byte.b	oRightBracket
      0  33ed					      GETCHAR
      0  33ed					      db	51
      1  33ed		       33		      .byte.b	51
      0  33ee					      RTN
      0  33ee					      db	25
      1  33ee		       19		      .byte.b	25
    773  33ef							;
    774  33ef							;====================================================================================
    775  33ef							; addr(variable definition)
    776  33ef							; Returns the address of a variable on top of the stack
    777  33ef				   ekAddr
      0  33ef					      TSTB	UNKNOWNVEC,oLeftBracket
      0  33ef					      db	101
      1  33ef		       65		      .byte.b	101
      0  33f0					      db	(UNKNOWNVEC-*)-1
      1  33f0		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  33f1					      db	oLeftBracket
      1  33f1		       e0		      .byte.b	oLeftBracket
      0  33f2					      TSTV	ExpectedVariable
      0  33f2					      db	33
      1  33f2		       21		      .byte.b	33
      0  33f3					      db	(ExpectedVariable-*)-1
      1  33f3		       07		      .byte.b	(ExpectedVariable-*)-1
      0  33f4					      CALL	FactVarPtrNoTst
      0  33f4					      db	28
      1  33f4		       1c		      .byte.b	28
      0  33f5					      dw	FactVarPtrNoTst
      1  33f5		       eb 34		      .word.w	FactVarPtrNoTst
      0  33f7					      TSTB	UNKNOWNVEC,oRightBracket
      0  33f7					      db	101
      1  33f7		       65		      .byte.b	101
      0  33f8					      db	(UNKNOWNVEC-*)-1
      1  33f8		       d6		      .byte.b	(UNKNOWNVEC-*)-1
      0  33f9					      db	oRightBracket
      1  33f9		       e1		      .byte.b	oRightBracket
      0  33fa					      RTN
      0  33fa					      db	25
      1  33fa		       19		      .byte.b	25
    783  33fb
    784  33fb				   ExpectedVariable
      0  33fb					      ERRMSG	ERR_SYNTAX	;Expected Variable
      0  33fb					      db	13
      1  33fb		       0d		      .byte.b	13
      0  33fc					      dw	ERR_SYNTAX
      1  33fc		       05 00		      .word.w	ERR_SYNTAX
    786  33fe							;
    787  33fe							;================================================================
    788  33fe							; Compare a block of memory
    789  33fe							; CmpMem(Length, Source 1, Source 2)
    790  33fe							; returns on the stack 0 equal, 1 s1>s2, -1 s1<s2
    791  33fe				   ekCmpMem
      0  33fe					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  33fe					      db	101
      1  33fe		       65		      .byte.b	101
      0  33ff					      db	(UNKNOWNVEC-*)-1
      1  33ff		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  3400					      db	oLeftBracket
      1  3400		       e0		      .byte.b	oLeftBracket
      0  3401					      CALL	EXPR	; Length
      0  3401					      db	28
      1  3401		       1c		      .byte.b	28
      0  3402					      dw	EXPR
      1  3402		       3e 33		      .word.w	EXPR
      0  3404					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  3404					      db	101
      1  3404		       65		      .byte.b	101
      0  3405					      db	(UNKNOWNVEC-*)-1
      1  3405		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  3406					      db	oComma
      1  3406		       e2		      .byte.b	oComma
      0  3407					      CALL	EXPR	; Source 1
      0  3407					      db	28
      1  3407		       1c		      .byte.b	28
      0  3408					      dw	EXPR
      1  3408		       3e 33		      .word.w	EXPR
      0  340a					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  340a					      db	101
      1  340a		       65		      .byte.b	101
      0  340b					      db	(UNKNOWNVEC-*)-1
      1  340b		       c3		      .byte.b	(UNKNOWNVEC-*)-1
      0  340c					      db	oComma
      1  340c		       e2		      .byte.b	oComma
      0  340d					      CALL	EXPR	; Source 2
      0  340d					      db	28
      1  340d		       1c		      .byte.b	28
      0  340e					      dw	EXPR
      1  340e		       3e 33		      .word.w	EXPR
      0  3410					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  3410					      db	101
      1  3410		       65		      .byte.b	101
      0  3411					      db	(UNKNOWNVEC-*)-1
      1  3411		       bd		      .byte.b	(UNKNOWNVEC-*)-1
      0  3412					      db	oRightBracket
      1  3412		       e1		      .byte.b	oRightBracket
      0  3413					      CMPMEM		; Compare the memory
      0  3413					      db	112
      1  3413		       70		      .byte.b	112
      0  3414					      RTN
      0  3414					      db	25
      1  3414		       19		      .byte.b	25
    801  3415							;====================================================================================
    802  3415							; peek(mem address) return the value of a byte in memory
    803  3415							; @[offset] return a word value from offset -- see tstv
    804  3415							;
    805  3415							;F1A2:
    806  3415							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    807  3415				   ekPeek
      0  3415					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3415					      db	101
      1  3415		       65		      .byte.b	101
      0  3416					      db	(UNKNOWNVEC-*)-1
      1  3416		       b8		      .byte.b	(UNKNOWNVEC-*)-1
      0  3417					      db	oLeftBracket
      1  3417		       e0		      .byte.b	oLeftBracket
      0  3418					      CALL	EXPR	;Get the address to write to
      0  3418					      db	28
      1  3418		       1c		      .byte.b	28
      0  3419					      dw	EXPR
      1  3419		       3e 33		      .word.w	EXPR
      0  341b					      TSTB	UNKNOWNVEC,oRightBracket
      0  341b					      db	101
      1  341b		       65		      .byte.b	101
      0  341c					      db	(UNKNOWNVEC-*)-1
      1  341c		       b2		      .byte.b	(UNKNOWNVEC-*)-1
      0  341d					      db	oRightBracket
      1  341d		       e1		      .byte.b	oRightBracket
      0  341e					      PEEKMEM
      0  341e					      db	48
      1  341e		       30		      .byte.b	48
      0  341f					      RTN
      0  341f					      db	25
      1  341f		       19		      .byte.b	25
    813  3420							;=======================================================================================
    814  3420							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    815  3420							;
    816  3420							;F2AZ:
    817  3420							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    818  3420				   ekTask
      0  3420					      TSTBRANCH	ekTaskCompiled
      0  3420					      db	106
      1  3420		       6a		      .byte.b	106
      0  3421					      db	(ekTaskCompiled-*)-1
      1  3421		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  3422					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3422					      db	101
      1  3422		       65		      .byte.b	101
      0  3423					      db	(UNKNOWNVEC-*)-1
      1  3423		       ab		      .byte.b	(UNKNOWNVEC-*)-1
      0  3424					      db	oLeftBracket
      1  3424		       e0		      .byte.b	oLeftBracket
      0  3425					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  3425					      db	28
      1  3425		       1c		      .byte.b	28
      0  3426					      dw	EXPR
      1  3426		       3e 33		      .word.w	EXPR
      0  3428					      lit	0
      0  3428					      db	27
      1  3428		       1b		      .byte.b	27
      0  3429					      dw	0
      1  3429		       00 00		      .word.w	0
      0  342b					      iJMP	ekTaskLinenum
      0  342b					      db	29
      1  342b		       1d		      .byte.b	29
      0  342c					      dw	ekTaskLinenum
      1  342c		       31 34		      .word.w	ekTaskLinenum
    824  342e
    825  342e				   ekTaskCompiled
      0  342e					      lit	1
      0  342e					      db	27
      1  342e		       1b		      .byte.b	27
      0  342f					      dw	1
      1  342f		       01 00		      .word.w	1
    827  3431
    828  3431				   ekTaskLinenum
      0  3431					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  3431					      db	61
      1  3431		       3d		      .byte.b	61
      0  3432					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  3432					      db	101
      1  3432		       65		      .byte.b	101
      0  3433					      db	(F2AZNoParms-*)-1
      1  3433		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  3434					      db	oComma
      1  3434		       e2		      .byte.b	oComma
      0  3435					      SAVEMATHSTACK		;Push The mathstack
      0  3435					      db	86
      1  3435		       56		      .byte.b	86
      0  3436					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  3436					      db	89
      1  3436		       59		      .byte.b	89
    833  3437				   F2AZLOOP
      0  3437					      CALL	EXPR	;do the expression leave answer on tasks stack
      0  3437					      db	28
      1  3437		       1c		      .byte.b	28
      0  3438					      dw	EXPR
      1  3438		       3e 33		      .word.w	EXPR
      0  343a					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  343a					      db	101
      1  343a		       65		      .byte.b	101
      0  343b					      db	(F2AZEndParm-*)-1
      1  343b		       04		      .byte.b	(F2AZEndParm-*)-1
      0  343c					      db	oComma
      1  343c		       e2		      .byte.b	oComma
      0  343d					      IJMP	F2AZLOOP	;check for more
      0  343d					      db	29
      1  343d		       1d		      .byte.b	29
      0  343e					      dw	F2AZLOOP
      1  343e		       37 34		      .word.w	F2AZLOOP
    837  3440
    838  3440				   F2AZEndParm
      0  3440					      RESTOREMATHSTACK		;Back to normal stack
      0  3440					      db	87
      1  3440		       57		      .byte.b	87
      0  3441					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  3441					      db	92
      1  3441		       5c		      .byte.b	92
    841  3442
    842  3442				   F2AZNoParms
      0  3442					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  3442					      db	101
      1  3442		       65		      .byte.b	101
      0  3443					      db	(UNKNOWNVEC-*)-1
      1  3443		       8b		      .byte.b	(UNKNOWNVEC-*)-1
      0  3444					      db	oRightBracket
      1  3444		       e1		      .byte.b	oRightBracket
    844  3445
      0  3445					      TASKENABLE		;Enable the task to execute
      0  3445					      db	90
      1  3445		       5a		      .byte.b	90
    846  3446
      0  3446					      RTN		;Returns the Task number
      0  3446					      db	25
      1  3446		       19		      .byte.b	25
    848  3447							;=========================================================================================
    849  3447							; Check for IPC interproccess instructions
    850  3447							;   IPCS  - Send a message
    851  3447							;
    852  3447							;F2AZ1:
    853  3447							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    854  3447				   ekIpcs
      0  3447					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  3447					      db	101
      1  3447		       65		      .byte.b	101
      0  3448					      db	(UNKNOWNVEC-*)-1
      1  3448		       86		      .byte.b	(UNKNOWNVEC-*)-1
      0  3449					      db	oLeftBracket
      1  3449		       e0		      .byte.b	oLeftBracket
      0  344a					      CALL	EXPR	;Get the message value
      0  344a					      db	28
      1  344a		       1c		      .byte.b	28
      0  344b					      dw	EXPR
      1  344b		       3e 33		      .word.w	EXPR
      0  344d					      TSTB	UNKNOWNVEC,oComma
      0  344d					      db	101
      1  344d		       65		      .byte.b	101
      0  344e					      db	(UNKNOWNVEC-*)-1
      1  344e		       80		      .byte.b	(UNKNOWNVEC-*)-1
      0  344f					      db	oComma
      1  344f		       e2		      .byte.b	oComma
      0  3450					      CALL	EXPR	;Get pid of task to send to
      0  3450					      db	28
      1  3450		       1c		      .byte.b	28
      0  3451					      dw	EXPR
      1  3451		       3e 33		      .word.w	EXPR
      0  3453					      TSTB	UNKNOWNVEC,oRightBracket
      0  3453					      db	101
      1  3453		       65		      .byte.b	101
      0  3454					      db	(UNKNOWNVEC-*)-1
      1  3454		       7a		      .byte.b	(UNKNOWNVEC-*)-1
      0  3455					      db	oRightBracket
      1  3455		       e1		      .byte.b	oRightBracket
      0  3456					      IPCSEND		;Send msg and clear pid msg pending
      0  3456					      db	80
      1  3456		       50		      .byte.b	80
      0  3457					      RTN
      0  3457					      db	25
      1  3457		       19		      .byte.b	25
    862  3458							;================================================================================
    863  3458							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    864  3458							;
    865  3458				   ekIpcr
      0  3458					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  3458					      db	101
      1  3458		       65		      .byte.b	101
      0  3459					      db	(UNKNOWNVEC-*)-1
      1  3459		       75		      .byte.b	(UNKNOWNVEC-*)-1
      0  345a					      db	oLeftBracket
      1  345a		       e0		      .byte.b	oLeftBracket
      0  345b					      TSTB	F2AZa1,oRightBracket
      0  345b					      db	101
      1  345b		       65		      .byte.b	101
      0  345c					      db	(F2AZa1-*)-1
      1  345c		       07		      .byte.b	(F2AZa1-*)-1
      0  345d					      db	oRightBracket
      1  345d		       e1		      .byte.b	oRightBracket
      0  345e					      LIT	0	;We dont want the pid returned to us
      0  345e					      db	27
      1  345e		       1b		      .byte.b	27
      0  345f					      dw	0
      1  345f		       00 00		      .word.w	0
      0  3461					      IJMP	ekIpcrComplete
      0  3461					      db	29
      1  3461		       1d		      .byte.b	29
      0  3462					      dw	ekIpcrComplete
      1  3462		       69 34		      .word.w	ekIpcrComplete
    870  3464				   F2AZa1
      0  3464					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  3464					      db	33
      1  3464		       21		      .byte.b	33
      0  3465					      db	(UNKNOWNVEC-*)-1
      1  3465		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  3466					      TSTB	UNKNOWNVEC,oRightBracket
      0  3466					      db	101
      1  3466		       65		      .byte.b	101
      0  3467					      db	(UNKNOWNVEC-*)-1
      1  3467		       67		      .byte.b	(UNKNOWNVEC-*)-1
      0  3468					      db	oRightBracket
      1  3468		       e1		      .byte.b	oRightBracket
    873  3469
    874  3469				   ekIpcrComplete
      0  3469					      IPCIO		;Set the io bit and exit task till message
      0  3469					      db	83
      1  3469		       53		      .byte.b	83
      0  346a					      IPCRECEIVE		;Get the message
      0  346a					      db	81
      1  346a		       51		      .byte.b	81
      0  346b					      RTN
      0  346b					      db	25
      1  346b		       19		      .byte.b	25
    878  346c							;===============================================================================
    879  346c							; IPCC ---- check if a message is available
    880  346c				   ekIpcc
      0  346c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  346c					      db	101
      1  346c		       65		      .byte.b	101
      0  346d					      db	(UNKNOWNVEC-*)-1
      1  346d		       61		      .byte.b	(UNKNOWNVEC-*)-1
      0  346e					      db	oLeftBracket
      1  346e		       e0		      .byte.b	oLeftBracket
      0  346f					      TSTB	UNKNOWNVEC,oRightBracket
      0  346f					      db	101
      1  346f		       65		      .byte.b	101
      0  3470					      db	(UNKNOWNVEC-*)-1
      1  3470		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  3471					      db	oRightBracket
      1  3471		       e1		      .byte.b	oRightBracket
      0  3472					      IPCCHECK
      0  3472					      db	82
      1  3472		       52		      .byte.b	82
      0  3473					      RTN
      0  3473					      db	25
      1  3473		       19		      .byte.b	25
    885  3474
    886  3474				   UNKNOWNID
      0  3474					      IJMP	UNKNOWN
      0  3474					      db	29
      1  3474		       1d		      .byte.b	29
      0  3475					      dw	UNKNOWN
      1  3475		       3a 33		      .word.w	UNKNOWN
    888  3477							;============================================================
    889  3477							; RND() is supposed to have an argument but if none
    890  3477							; was provided, just assume a large value.
    891  3477							;
    892  3477				   ekRnd
      0  3477					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3477					      db	101
      1  3477		       65		      .byte.b	101
      0  3478					      db	(UNKNOWNVEC-*)-1
      1  3478		       56		      .byte.b	(UNKNOWNVEC-*)-1
      0  3479					      db	oLeftBracket
      1  3479		       e0		      .byte.b	oLeftBracket
      0  347a					      TSTB	F2A1,oRightBracket
      0  347a					      db	101
      1  347a		       65		      .byte.b	101
      0  347b					      db	(F2A1-*)-1
      1  347b		       06		      .byte.b	(F2A1-*)-1
      0  347c					      db	oRightBracket
      1  347c		       e1		      .byte.b	oRightBracket
      0  347d					      LIT	32766
      0  347d					      db	27
      1  347d		       1b		      .byte.b	27
      0  347e					      dw	32766
      1  347e		       fe 7f		      .word.w	32766
      0  3480					      RANDOM
      0  3480					      db	37
      1  3480		       25		      .byte.b	37
      0  3481					      RTN
      0  3481					      db	25
      1  3481		       19		      .byte.b	25
    898  3482
    899  3482				   F2A1
      0  3482					      CALL	EXPR	;GET RANGE
      0  3482					      db	28
      1  3482		       1c		      .byte.b	28
      0  3483					      dw	EXPR
      1  3483		       3e 33		      .word.w	EXPR
      0  3485					      TSTB	UNKNOWNVEC,oRightBracket
      0  3485					      db	101
      1  3485		       65		      .byte.b	101
      0  3486					      db	(UNKNOWNVEC-*)-1
      1  3486		       48		      .byte.b	(UNKNOWNVEC-*)-1
      0  3487					      db	oRightBracket
      1  3487		       e1		      .byte.b	oRightBracket
      0  3488					      RANDOM
      0  3488					      db	37
      1  3488		       25		      .byte.b	37
      0  3489					      RTN
      0  3489					      db	25
      1  3489		       19		      .byte.b	25
    904  348a							;==========================================================
    905  348a							;	Return absolute value of expresion
    906  348a							;
    907  348a				   ekAbs
      0  348a					      TSTB	UNKNOWNVEC,oLeftBracket
      0  348a					      db	101
      1  348a		       65		      .byte.b	101
      0  348b					      db	(UNKNOWNVEC-*)-1
      1  348b		       43		      .byte.b	(UNKNOWNVEC-*)-1
      0  348c					      db	oLeftBracket
      1  348c		       e0		      .byte.b	oLeftBracket
      0  348d					      CALL	EXPR	;get value
      0  348d					      db	28
      1  348d		       1c		      .byte.b	28
      0  348e					      dw	EXPR
      1  348e		       3e 33		      .word.w	EXPR
      0  3490					      TSTB	UNKNOWNVEC,oRightBracket
      0  3490					      db	101
      1  3490		       65		      .byte.b	101
      0  3491					      db	(UNKNOWNVEC-*)-1
      1  3491		       3d		      .byte.b	(UNKNOWNVEC-*)-1
      0  3492					      db	oRightBracket
      1  3492		       e1		      .byte.b	oRightBracket
      0  3493					      ABS
      0  3493					      db	38
      1  3493		       26		      .byte.b	38
      0  3494					      RTN
      0  3494					      db	25
      1  3494		       19		      .byte.b	25
    913  3495							;============================================================
    914  3495							;     Return the the status of a task, provide the PID
    915  3495							;
    916  3495				   ekStat
      0  3495					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3495					      db	101
      1  3495		       65		      .byte.b	101
      0  3496					      db	(UNKNOWNVEC-*)-1
      1  3496		       38		      .byte.b	(UNKNOWNVEC-*)-1
      0  3497					      db	oLeftBracket
      1  3497		       e0		      .byte.b	oLeftBracket
      0  3498					      Call	EXPR
      0  3498					      db	28
      1  3498		       1c		      .byte.b	28
      0  3499					      dw	EXPR
      1  3499		       3e 33		      .word.w	EXPR
      0  349b					      TSTB	UNKNOWNVEC,oRightBracket
      0  349b					      db	101
      1  349b		       65		      .byte.b	101
      0  349c					      db	(UNKNOWNVEC-*)-1
      1  349c		       32		      .byte.b	(UNKNOWNVEC-*)-1
      0  349d					      db	oRightBracket
      1  349d		       e1		      .byte.b	oRightBracket
      0  349e					      TASKSTAT
      0  349e					      db	66
      1  349e		       42		      .byte.b	66
      0  349f					      RTN
      0  349f					      db	25
      1  349f		       19		      .byte.b	25
    922  34a0							;==============================================================
    923  34a0							; Return the current tasks pid
    924  34a0							;
    925  34a0				   ekPid
      0  34a0					      TASKPID
      0  34a0					      db	77
      1  34a0		       4d		      .byte.b	77
      0  34a1					      RTN
      0  34a1					      db	25
      1  34a1		       19		      .byte.b	25
    928  34a2							;===========================================================================
    929  34a2							; Call a machine function, provide the address to call and optionally
    930  34a2							; the value to be passed in reg A
    931  34a2				   ekCall
      0  34a2					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34a2					      db	101
      1  34a2		       65		      .byte.b	101
      0  34a3					      db	(UNKNOWNVEC-*)-1
      1  34a3		       2b		      .byte.b	(UNKNOWNVEC-*)-1
      0  34a4					      db	oLeftBracket
      1  34a4		       e0		      .byte.b	oLeftBracket
      0  34a5					      CALL	EXPR
      0  34a5					      db	28
      1  34a5		       1c		      .byte.b	28
      0  34a6					      dw	EXPR
      1  34a6		       3e 33		      .word.w	EXPR
      0  34a8					      TSTB	F2B2A,oComma
      0  34a8					      db	101
      1  34a8		       65		      .byte.b	101
      0  34a9					      db	(F2B2A-*)-1
      1  34a9		       09		      .byte.b	(F2B2A-*)-1
      0  34aa					      db	oComma
      1  34aa		       e2		      .byte.b	oComma
      0  34ab					      CALL	EXPR
      0  34ab					      db	28
      1  34ab		       1c		      .byte.b	28
      0  34ac					      dw	EXPR
      1  34ac		       3e 33		      .word.w	EXPR
      0  34ae					      TSTB	UNKNOWNVEC,oRightBracket
      0  34ae					      db	101
      1  34ae		       65		      .byte.b	101
      0  34af					      db	(UNKNOWNVEC-*)-1
      1  34af		       1f		      .byte.b	(UNKNOWNVEC-*)-1
      0  34b0					      db	oRightBracket
      1  34b0		       e1		      .byte.b	oRightBracket
      0  34b1					      CALLFUNC
      0  34b1					      db	53
      1  34b1		       35		      .byte.b	53
      0  34b2					      RTN
      0  34b2					      db	25
      1  34b2		       19		      .byte.b	25
    939  34b3							; Run the gosub within this function
    940  34b3				   F2B2A
      0  34b3					      TSTB	UNKNOWNID,oRightBracket
      0  34b3					      db	101
      1  34b3		       65		      .byte.b	101
      0  34b4					      db	(UNKNOWNID-*)-1
      1  34b4		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  34b5					      db	oRightBracket
      1  34b5		       e1		      .byte.b	oRightBracket
      0  34b6					      LIT	0	; No parameter passed so just load zero to A
      0  34b6					      db	27
      1  34b6		       1b		      .byte.b	27
      0  34b7					      dw	0
      1  34b7		       00 00		      .word.w	0
      0  34b9					      CALLFUNC
      0  34b9					      db	53
      1  34b9		       35		      .byte.b	53
      0  34ba					      RTN
      0  34ba					      db	25
      1  34ba		       19		      .byte.b	25
    945  34bb
    946  34bb
    947  34bb							;=================================================================================
    948  34bb							;Check for a number !
    949  34bb							;
    950  34bb				   FactNumber
      0  34bb					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  34bb					      db	35
      1  34bb		       23		      .byte.b	35
      0  34bc					      db	(FactVariable-*)-1
      1  34bc		       0f		      .byte.b	(FactVariable-*)-1
      0  34bd					      RTN
      0  34bd					      db	25
      1  34bd		       19		      .byte.b	25
    953  34be
    954  34be				   FactWithBracket
      0  34be					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  34be					      db	101
      1  34be		       65		      .byte.b	101
      0  34bf					      db	(F2RTN-*)-1
      1  34bf		       08		      .byte.b	(F2RTN-*)-1
      0  34c0					      db	oLeftBracket
      1  34c0		       e0		      .byte.b	oLeftBracket
      0  34c1					      CALL	EXPR
      0  34c1					      db	28
      1  34c1		       1c		      .byte.b	28
      0  34c2					      dw	EXPR
      1  34c2		       3e 33		      .word.w	EXPR
      0  34c4					      TST	F2,oRightBracket
      0  34c4					      db	32
      1  34c4		       20		      .byte.b	32
      0  34c5					      db	(F2-*)-1
      1  34c5		       03		      .byte.b	(F2-*)-1
      0  34c6					      db	oRightBracket,0
      1  34c6		       e1 00		      .byte.b	oRightBracket,0
    958  34c8				   F2RTN
      0  34c8					      RTN
      0  34c8					      db	25
      1  34c8		       19		      .byte.b	25
    960  34c9
    961  34c9				   F2
      0  34c9					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  34c9					      db	13
      1  34c9		       0d		      .byte.b	13
      0  34ca					      dw	ERR_SYNTAX
      1  34ca		       05 00		      .word.w	ERR_SYNTAX
    963  34cc							;
    964  34cc							;=============================================================================
    965  34cc							; See if this is just a simple variable
    966  34cc							;  Allow a subscript for any variable
    967  34cc							;
    968  34cc				   FactVariable
    969  34cc
      0  34cc					      SETR2	tInteger
      0  34cc					      db	94
      1  34cc		       5e		      .byte.b	94
      0  34cd					      db	tInteger
      1  34cd		       a4		      .byte.b	tInteger
      0  34ce					      TSTV	FactWithBracket
      0  34ce					      db	33
      1  34ce		       21		      .byte.b	33
      0  34cf					      db	(FactWithBracket-*)-1
      1  34cf		       ee		      .byte.b	(FactWithBracket-*)-1
      0  34d0					      TSTBYTE	FactFNParm,R2,GOSUB_RTN_VALUE
      0  34d0					      db	97
      1  34d0		       61		      .byte.b	97
      0  34d1					      db	(FactFNParm-*)-1
      1  34d1		       0a		      .byte.b	(FactFNParm-*)-1
      0  34d2					      dw	R2
      1  34d2		       58 00		      .word.w	R2
      0  34d4					      db	GOSUB_RTN_VALUE
      1  34d4		       81		      .byte.b	GOSUB_RTN_VALUE
      0  34d5					      CALL	FactVarPTR
      0  34d5					      db	28
      1  34d5		       1c		      .byte.b	28
      0  34d6					      dw	FactVarPTR
      1  34d6		       eb 34		      .word.w	FactVarPTR
      0  34d8					      CALL	FactVariableValue
      0  34d8					      db	28
      1  34d8		       1c		      .byte.b	28
      0  34d9					      dw	FactVariableValue
      1  34d9		       14 35		      .word.w	FactVariableValue
      0  34db					      RTN
      0  34db					      db	25
      1  34db		       19		      .byte.b	25
    976  34dc
    977  34dc				   FactFNParm
      0  34dc					      TSTB	FactExpectedOpeningBracket,oLeftSQBracket
      0  34dc					      db	101
      1  34dc		       65		      .byte.b	101
      0  34dd					      db	(FactExpectedOpeningBracket-*)-1
      1  34dd		       3b		      .byte.b	(FactExpectedOpeningBracket-*)-1
      0  34de					      db	oLeftSQBracket
      1  34de		       e4		      .byte.b	oLeftSQBracket
      0  34df					      CALL	EXPR
      0  34df					      db	28
      1  34df		       1c		      .byte.b	28
      0  34e0					      dw	EXPR
      1  34e0		       3e 33		      .word.w	EXPR
      0  34e2					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  34e2					      db	101
      1  34e2		       65		      .byte.b	101
      0  34e3					      db	(FactMissingRightBracket-*)-1
      1  34e3		       32		      .byte.b	(FactMissingRightBracket-*)-1
      0  34e4					      db	oRightSQBracket
      1  34e4		       e5		      .byte.b	oRightSQBracket
      0  34e5					      SUBSCRIPT	GOSUB_RTN_VALUE
      0  34e5					      db	64
      1  34e5		       40		      .byte.b	64
      0  34e6					      db	GOSUB_RTN_VALUE
      1  34e6		       81		      .byte.b	GOSUB_RTN_VALUE
      0  34e7					      SETR2	tInteger
      0  34e7					      db	94
      1  34e7		       5e		      .byte.b	94
      0  34e8					      db	tInteger
      1  34e8		       a4		      .byte.b	tInteger
      0  34e9					      IND
      0  34e9					      db	20
      1  34e9		       14		      .byte.b	20
      0  34ea					      RTN
      0  34ea					      db	25
      1  34ea		       19		      .byte.b	25
    985  34eb
    986  34eb				   FactVarPTR
    987  34eb				   FactVarPtrNoTst
      0  34eb					      TSTB	F2CLocalTask,oBang
      0  34eb					      db	101
      1  34eb		       65		      .byte.b	101
      0  34ec					      db	(F2CLocalTask-*)-1
      1  34ec		       04		      .byte.b	(F2CLocalTask-*)-1
      0  34ed					      db	oBang
      1  34ed		       e8		      .byte.b	oBang
      0  34ee					      IND		; we just got a pid
      0  34ee					      db	20
      1  34ee		       14		      .byte.b	20
      0  34ef					      TSTVT	UNKNOWNID	; if it is not another variabe then error, Call test var. task
      0  34ef					      db	93
      1  34ef		       5d		      .byte.b	93
      0  34f0					      db	(UNKNOWNID-*)-1
      1  34f0		       83		      .byte.b	(UNKNOWNID-*)-1
    991  34f1
    992  34f1				   F2CLocalTask
      0  34f1					      SETR2	tInteger	; Sets the default type to integer
      0  34f1					      db	94
      1  34f1		       5e		      .byte.b	94
      0  34f2					      db	tInteger
      1  34f2		       a4		      .byte.b	tInteger
      0  34f3					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  34f3					      db	101
      1  34f3		       65		      .byte.b	101
      0  34f4					      db	(F2INTEGER-*)-1
      1  34f4		       11		      .byte.b	(F2INTEGER-*)-1
      0  34f5					      db	oDollar
      1  34f5		       e7		      .byte.b	oDollar
      0  34f6					      SETR2	tByte
      0  34f6					      db	94
      1  34f6		       5e		      .byte.b	94
      0  34f7					      db	tByte
      1  34f7		       a2		      .byte.b	tByte
      0  34f8					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  34f8					      db	101
      1  34f8		       65		      .byte.b	101
      0  34f9					      db	(F2PTRLOADED-*)-1
      1  34f9		       19		      .byte.b	(F2PTRLOADED-*)-1
      0  34fa					      db	oLeftSQBracket
      1  34fa		       e4		      .byte.b	oLeftSQBracket
      0  34fb					      CALL	EXPR
      0  34fb					      db	28
      1  34fb		       1c		      .byte.b	28
      0  34fc					      dw	EXPR
      1  34fc		       3e 33		      .word.w	EXPR
      0  34fe					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  34fe					      db	101
      1  34fe		       65		      .byte.b	101
      0  34ff					      db	(FactMissingRightBracket-*)-1
      1  34ff		       16		      .byte.b	(FactMissingRightBracket-*)-1
      0  3500					      db	oRightSQBracket
      1  3500		       e5		      .byte.b	oRightSQBracket
      0  3501					      SUBSCRIPT	tByte	; Byte type array
      0  3501					      db	64
      1  3501		       40		      .byte.b	64
      0  3502					      db	tByte
      1  3502		       a2		      .byte.b	tByte
      0  3503					      SETR2	tByte	; Set byte data type
      0  3503					      db	94
      1  3503		       5e		      .byte.b	94
      0  3504					      db	tByte
      1  3504		       a2		      .byte.b	tByte
      0  3505					      RTN
      0  3505					      db	25
      1  3505		       19		      .byte.b	25
   1002  3506
   1003  3506				   F2INTEGER
      0  3506					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  3506					      db	101
      1  3506		       65		      .byte.b	101
      0  3507					      db	(F2PTRLOADED-*)-1
      1  3507		       0b		      .byte.b	(F2PTRLOADED-*)-1
      0  3508					      db	oLeftSQBracket
      1  3508		       e4		      .byte.b	oLeftSQBracket
      0  3509					      CALL	EXPR
      0  3509					      db	28
      1  3509		       1c		      .byte.b	28
      0  350a					      dw	EXPR
      1  350a		       3e 33		      .word.w	EXPR
      0  350c					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  350c					      db	101
      1  350c		       65		      .byte.b	101
      0  350d					      db	(FactMissingRightBracket-*)-1
      1  350d		       08		      .byte.b	(FactMissingRightBracket-*)-1
      0  350e					      db	oRightSQBracket
      1  350e		       e5		      .byte.b	oRightSQBracket
      0  350f					      SUBSCRIPT	tInteger	; Integer type array
      0  350f					      db	64
      1  350f		       40		      .byte.b	64
      0  3510					      db	tInteger
      1  3510		       a4		      .byte.b	tInteger
      0  3511					      SETR2	tInteger	; Set word datatype
      0  3511					      db	94
      1  3511		       5e		      .byte.b	94
      0  3512					      db	tInteger
      1  3512		       a4		      .byte.b	tInteger
   1009  3513				   F2PTRLOADED
      0  3513					      RTN
      0  3513					      db	25
      1  3513		       19		      .byte.b	25
   1011  3514
   1012  3514				   FactVariableValue
      0  3514					      IND		; YES, GET THE VALUE as word
      0  3514					      db	20
      1  3514		       14		      .byte.b	20
      0  3515					      RTN
      0  3515					      db	25
      1  3515		       19		      .byte.b	25
   1015  3516
   1016  3516				   FactMissingRightBracket
      0  3516					      IJMP	ReturnExpectBracket
      0  3516					      db	29
      1  3516		       1d		      .byte.b	29
      0  3517					      dw	ReturnExpectBracket
      1  3517		       4a 35		      .word.w	ReturnExpectBracket
   1018  3519				   FactExpectedOpeningBracket
      0  3519					      ERRMSG	ERR_EXPECTED_OPENING_BRACKET
      0  3519					      db	13
      1  3519		       0d		      .byte.b	13
      0  351a					      dw	ERR_EXPECTED_OPENING_BRACKET
      1  351a		       1a 00		      .word.w	ERR_EXPECTED_OPENING_BRACKET
   1020  351c							;===============================================================================================================================
   1021  351c							;========================= Gosub and function interface ========================================================================
   1022  351c							; Process gosub no return value
   1023  351c							;
   1024  351c				   ekGosub
      0  351c					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  351c					      db	28
      1  351c		       1c		      .byte.b	28
      0  351d					      dw	GOSUBSTATEMENT
      1  351d		       4e 35		      .word.w	GOSUBSTATEMENT
      0  351f					      DONE		; ERROR IF CR NOT NEXT
      0  351f					      db	1
      1  351f		       01		      .byte.b	1
      0  3520					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  3520					      db	8
      1  3520		       08		      .byte.b	8
      0  3521					      db	GOSUB_RTN
      1  3521		       01		      .byte.b	GOSUB_RTN
      0  3522					      FASTXFER		; AND JUMP to sub rtn
      0  3522					      db	107
      1  3522		       6b		      .byte.b	107
   1029  3523							;
   1030  3523							; End of gosub processing
   1031  3523							;===========================================================================
   1032  3523							; Same as gosub but expects a return value
   1033  3523							;   FN 1000(parm1, ....)  Expects an integer to be returned
   1034  3523							;
   1035  3523				   ekGofn
      0  3523					      Call	GOSUBSTATEMENT
      0  3523					      db	28
      1  3523		       1c		      .byte.b	28
      0  3524					      dw	GOSUBSTATEMENT
      1  3524		       4e 35		      .word.w	GOSUBSTATEMENT
      0  3526					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  3526					      db	8
      1  3526		       08		      .byte.b	8
      0  3527					      db	GOSUB_RTN_VALUE
      1  3527		       81		      .byte.b	GOSUB_RTN_VALUE
      0  3528					      FASTXFER
      0  3528					      db	107
      1  3528		       6b		      .byte.b	107
   1039  3529
   1040  3529				   GOFNRet
      0  3529					      RTN
      0  3529					      db	25
      1  3529		       19		      .byte.b	25
   1042  352a							;===============================================================================================================================
   1043  352a							; Return from a gosub
   1044  352a							;
   1045  352a				   ekReturn
      0  352a					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  352a					      db	101
      1  352a		       65		      .byte.b	101
      0  352b					      db	(S2NoReturnValue-*)-1
      1  352b		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  352c					      db	oLeftBracket
      1  352c		       e0		      .byte.b	oLeftBracket
      0  352d					      CALL	EXPR
      0  352d					      db	28
      1  352d		       1c		      .byte.b	28
      0  352e					      dw	EXPR
      1  352e		       3e 33		      .word.w	EXPR
      0  3530					      TSTB	ReturnExpectBracket,oRightBracket	; Now a value is on the stack
      0  3530					      db	101
      1  3530		       65		      .byte.b	101
      0  3531					      db	(ReturnExpectBracket-*)-1
      1  3531		       18		      .byte.b	(ReturnExpectBracket-*)-1
      0  3532					      db	oRightBracket
      1  3532		       e1		      .byte.b	oRightBracket
      0  3533					      DONE
      0  3533					      db	1
      1  3533		       01		      .byte.b	1
      0  3534					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  3534					      db	9
      1  3534		       09		      .byte.b	9
      0  3535					      db	(S2RetFunc-*)-1
      1  3535		       11		      .byte.b	(S2RetFunc-*)-1
      0  3536					      db	1
      1  3536		       01		      .byte.b	1
      0  3537					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3537					      db	6
      1  3537		       06		      .byte.b	6
      0  3538					      dw	CO
      1  3538		       22 31		      .word.w	CO
      0  353a					      IJMP	STMT	; Process the new statement
      0  353a					      db	29
      1  353a		       1d		      .byte.b	29
      0  353b					      dw	STMT
      1  353b		       2a 31		      .word.w	STMT
   1053  353d
   1054  353d				   S2NoReturnValue
      0  353d					      DONE
      0  353d					      db	1
      1  353d		       01		      .byte.b	1
      0  353e					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  353e					      db	9
      1  353e		       09		      .byte.b	9
      0  353f					      db	(S2RetFunc-*)-1
      1  353f		       07		      .byte.b	(S2RetFunc-*)-1
      0  3540					      db	0
      1  3540		       00		      .byte.b	0
      0  3541					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3541					      db	6
      1  3541		       06		      .byte.b	6
      0  3542					      dw	CO
      1  3542		       22 31		      .word.w	CO
      0  3544					      IJMP	STMT	; Process the new statement
      0  3544					      db	29
      1  3544		       1d		      .byte.b	29
      0  3545					      dw	STMT
      1  3545		       2a 31		      .word.w	STMT
   1059  3547
   1060  3547				   S2RetFunc
      0  3547					      IJMP	GOFNRet	; Back into the Function
      0  3547					      db	29
      1  3547		       1d		      .byte.b	29
      0  3548					      dw	GOFNRet
      1  3548		       29 35		      .word.w	GOFNRet
   1062  354a
   1063  354a				   ReturnExpectBracket
      0  354a					      ENDIO
      0  354a					      db	71
      1  354a		       47		      .byte.b	71
      0  354b					      ERRMSG	ERR_CLOSINGBRACKET
      0  354b					      db	13
      1  354b		       0d		      .byte.b	13
      0  354c					      dw	ERR_CLOSINGBRACKET
      1  354c		       17 00		      .word.w	ERR_CLOSINGBRACKET
   1066  354e							;
   1067  354e							; End of return from gosub
   1068  354e							;=============================================================
   1069  354e							; Gosub can be both a Function and a Subroutine
   1070  354e				   GOSUBSTATEMENT
      0  354e					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  354e					      db	106
      1  354e		       6a		      .byte.b	106
      0  354f					      db	(GOSUBCOMPILED-*)-1
      1  354f		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  3550					      CALL	EXPR	; GET DESTINATION
      0  3550					      db	28
      1  3550		       1c		      .byte.b	28
      0  3551					      dw	EXPR
      1  3551		       3e 33		      .word.w	EXPR
      0  3553					      CALL	GOSUBCONT
      0  3553					      db	28
      1  3553		       1c		      .byte.b	28
      0  3554					      dw	GOSUBCONT
      1  3554		       61 35		      .word.w	GOSUBCONT
      0  3556					      lit	0	; mark as lookup on stack
      0  3556					      db	27
      1  3556		       1b		      .byte.b	27
      0  3557					      dw	0
      1  3557		       00 00		      .word.w	0
      0  3559					      RTN
      0  3559					      db	25
      1  3559		       19		      .byte.b	25
   1076  355a
   1077  355a				   GOSUBCOMPILED
      0  355a					      CALL	GOSUBCONT
      0  355a					      db	28
      1  355a		       1c		      .byte.b	28
      0  355b					      dw	GOSUBCONT
      1  355b		       61 35		      .word.w	GOSUBCONT
      0  355d					      lit	1	;mark as compiled on stack
      0  355d					      db	27
      1  355d		       1b		      .byte.b	27
      0  355e					      dw	1
      1  355e		       01 00		      .word.w	1
      0  3560					      RTN
      0  3560					      db	25
      1  3560		       19		      .byte.b	25
   1081  3561
   1082  3561				   GOSUBCONT
      0  3561					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters
      0  3561					      db	101
      1  3561		       65		      .byte.b	101
      0  3562					      db	(GOSUBDONE-*)-1
      1  3562		       11		      .byte.b	(GOSUBDONE-*)-1
      0  3563					      db	oLeftBracket
      1  3563		       e0		      .byte.b	oLeftBracket
      0  3564					      STK2TMP		;Transfer stack top to temp
      0  3564					      db	95
      1  3564		       5f		      .byte.b	95
      0  3565					      PUSHMATHSTACK		;Record stack frame for return
      0  3565					      db	84
      1  3565		       54		      .byte.b	84
   1086  3566				   GOSUBLOOP
      0  3566					      CALL	EXPR	; Allows what ever fits onto stack
      0  3566					      db	28
      1  3566		       1c		      .byte.b	28
      0  3567					      dw	EXPR
      1  3567		       3e 33		      .word.w	EXPR
      0  3569					      INCPARMCOUNT
      0  3569					      db	88
      1  3569		       58		      .byte.b	88
      0  356a					      TSTB	GOSUBParmDONE,oComma
      0  356a					      db	101
      1  356a		       65		      .byte.b	101
      0  356b					      db	(GOSUBParmDONE-*)-1
      1  356b		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  356c					      db	oComma
      1  356c		       e2		      .byte.b	oComma
      0  356d					      IJMP	GOSUBLOOP
      0  356d					      db	29
      1  356d		       1d		      .byte.b	29
      0  356e					      dw	GOSUBLOOP
      1  356e		       66 35		      .word.w	GOSUBLOOP
   1091  3570				   GOSUBParmDONE
      0  3570					      TSTB	ReturnExpectBracket,oRightBracket
      0  3570					      db	101
      1  3570		       65		      .byte.b	101
      0  3571					      db	(ReturnExpectBracket-*)-1
      1  3571		       d8		      .byte.b	(ReturnExpectBracket-*)-1
      0  3572					      db	oRightBracket
      1  3572		       e1		      .byte.b	oRightBracket
      0  3573					      TMP2STK		; Restore line to goto
      0  3573					      db	96
      1  3573		       60		      .byte.b	96
   1094  3574				   GOSUBDONE
      0  3574					      RTN
      0  3574					      db	25
      1  3574		       19		      .byte.b	25
   1096  3575
   1097  3575		       35 75	   ILEND      equ	*
------- FILE mytb.asm
   2490  3575		       35 75	   PROGEND    equ	*
   2491  3575
   2492  3575
   2493  3575							;=====================================================
   2494  3575							; Define start of non page zero data
   2495 U35c8					      seg.u	TBData
   2496 U35c8
   2497 U35c8							;=====================================================
   2498 U35c8							; These are storage items not in page zero.
   2499 U35c8							;==================================================================================================
   2500 U35c8							; Task Management information
   2501 U35c8							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2502 U35c8							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2503 U35c8							; Task switchs happen at the beginning of the next Basic command line
   2504 U35c8							; It will not happen during an input or output operations
   2505 U35c8							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2506 U35c8							; Task Zero is always the root task, main line program
   2507 U35c8							;
   2508 U35c8							; Layout is repeated for each configured task
   2509 U35c8							; Task Table Byte   use masks follow
   2510 U35c8		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2511 U35c8		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2512 U35c8		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2513 U35c8		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2514 U35c8		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2515 U35c8
   2516 U35c8		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2517 U35c9		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2518 U35c9		       36 c3	   TASKTABLEEND equ	*	; End of task table
   2519 U35c9		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2520 U36c3
   2521 U36c3							;Task Cycle Counter and reset count
   2522 U36c3		       00 00	   taskCurrentCycles ds	2
   2523 U36c5		       00 00	   taskResetValue ds	2
   2524 U36c7		       00	   taskCounter ds	1	; Count of active tasks
   2525 U36c8
   2526 U36c8							;
   2527 U36c8							; Math stack and IL call and Gosub/For-next return stack definitions
   2528 U36c8							;
   2529 U36c8		       36 c8	   STACKSTART equ	*
   2530 U36c8		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2531 U3858		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2532 U3c40		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2533 U3ec0		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code,taskio block stdin,stdout,stdstat,iostatus
   2534 U3ec0		       00 48	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2535 U3ec0		       41 a4	   STACKEND   equ	*
   2536 U3ec0		       0a dc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2537 U41a4							;
   2538 U41a4							;
   2539 U41a4		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2540 U4228		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2541 U4229		       00	   printtx    ds	1	;temp X for print funcs
   2542 U422a		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2543 U422b		       00	   promptChar ds	1	;the character to use for a prompt
   2544 U422c		       00	   diddigit   ds	1	;for leading zero suppression
   2545 U422d		       00	   putsy      ds	1
   2546 U422e		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2547 U4230		       00	   sign       ds	1	;0 = positive, else negative
   2548 U4231		       00 00	   rtemp1     ds	2	;Temp for x and y
   2549 U4233		       00 00	   random     ds	2
   2550 U4235		       00	   tempy      ds	1	;temp y storage
   2551 U4236
   2552 U4236
   2553 U4236							; Moved from page zero as one clock cycle diff gives more space on page zero
   2554 U4236		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2555 U4238		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2556 U4239		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2557 U423a		       00	   lineLength ds	1	;Length of current line
   2558 U423b
   2559 U423b		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2560 U423c		       00	   taskRDPending ds	1	; 1 = background read is pending
   2561 U423d
   2562 U423d				  -	      if	XKIM
   2563 U423d				  -buffer     ds	BUFFER_SIZE
   2564 U423d					      endif
   2565 U423d							;
   2566 U423d							; PROGRAMEND is the end of the user's BASIC program.
   2567 U423d							; More precisely, it is one byte past the end.  Or,
   2568 U423d							; it's where the next line added to the end will be
   2569 U423d							; placed.
   2570 U423d							;
   2571 U423d		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2572 U423f		       00 00	   ProgramEnd ds	2	; End of users basic program, Next free byte after end
   2573 U4241		       00 00	   HighMem    ds	2	; highest location
   2574 U4243		       00 00	   UsedMem    ds	2	; size of user program
   2575 U4245		       00 00	   FreeMem    ds	2	; amount of free memory
   2576 U4247							;
   2577 U4247							;=====================================================
   2578 U4247							; This is the start of the user's BASIC program space.
   2579 U4247							;
   2580 U4247							; PERSONAL GOAL: This should be no larger than $0DFF.
   2581 U4247							;		  0200-05FF = 1K
   2582 U4247							;		  0200-09FF = 2K
   2583 U4247							;		  0200-0DFF = 3K
   2584 U4247							;		  0200-11FF = 4K
   2585 U4247							;		  0200-13FF = 4.5K
   2586 U4247							;
   2587 U4247				  -	      if	FIXED
   2588 U4247				  -	      org	$2000
   2589 U4247					      endif
   2590 U4247
   2591 U4247		       42 47	   FreeMemStart equ	*
   2592 U4247							;/*
   2593 U4247							;  if	  CTMON65 || XKIM
   2594 U4247							;	  SEG Code
   2595 U4247							;	  org	  AutoRun
   2596 U4247							;	  dw	  TBasicCold
   2597 U4247							;  endif
   2598 U4247							;*/
   2599 U4247					      end
