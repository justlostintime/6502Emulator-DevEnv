------- FILE mytb.asm LEVEL 1 PASS 6
      1 U4341				   input      processor	6502
      2 U4341 ????						;=====================================================
      3 U4341 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U4341 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U4341 ????						; Free Time. Now abiut 6K Full OS features.
      6 U4341 ????						;
      7 U4341 ????						; While working on the Corsham Technologies KIM Clone
      8 U4341 ????						; project, I wanted to include a TINY BASIC since that
      9 U4341 ????						; was a highly desirable feature of early computers.
     10 U4341 ????						;
     11 U4341 ????						; Rather than negotiating copyright issues for
     12 U4341 ????						; existing BASICs, I decided to just write one from
     13 U4341 ????						; scratch.
     14 U4341 ????						;
     15 U4341 ????						; 10/07/2017
     16 U4341 ????						;
     17 U4341 ????						; This implements a stripped down Tiny BASIC
     18 U4341 ????						; interpreter using the Interpretive Language (IL)
     19 U4341 ????						; method as described in the first few issues of
     20 U4341 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U4341 ????						; to write various languages simply by changing the
     22 U4341 ????						; IL code rather than the interpreter itself.
     23 U4341 ????						;
     24 U4341 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U4341 ????						;		* Fixed major bug in findLine that
     26 U4341 ????						;		  caused corrupted lines, crashes, etc.
     27 U4341 ????						;		* If no parameter given to RND, assume
     28 U4341 ????						;		  32766.
     29 U4341 ????						;		* No more error 5 when a program
     30 U4341 ????						;		  reaches the end without an END.
     31 U4341 ????						;
     32 U4341 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U4341 ????						;		 * Unexpanded version to play with everything
     34 U4341 ????						;		 * Add some usefull system level functions
     35 U4341 ????						;		 * allow a larger number of tiny basic formats
     36 U4341 ????						;		 * Add byte at start of line holding length
     37 U4341 ????						;		   for faster execution of goto and gosub
     38 U4341 ????						;		 * Re-added gosub
     39 U4341 ????						;		 * allow ; or , at end if print stmt
     40 U4341 ????						;		   without CRLF being added.
     41 U4341 ????						;		 * Added extended function erase to
     42 U4341 ????						;		   use the extended ctmon65 rm file
     43 U4341 ????						;		 * Fix quoted text to not have to backtrack
     44 U4341 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U4341 ????						;		 * Add concurrency features
     46 U4341 ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U4341 ????						;
     48 U4341 ????						; 10/31/2023 v0.5 Justlostintime@gmail.com
     49 U4341 ????						;		 * Inline in il some var load value instead of calling
     50 U4341 ????						;
     51 U4341 ????						; www.corshamtech.com
     52 U4341 ????						; bob@corshamtech.com
     53 U4341 ????						; JustLostInTime@gmail.com
     54 U4341 ????						;
     55 U4341 ????						;=====================================================
     56 U4341 ????						;
     57 U4341 ????						; Create TRUE and FALSE values for conditionals.
     58 U4341 ????						;
     59 U4341 ????
     60 U4341 ????	       00 00	   FALSE      equ	0
     61 U4341 ????	       ff ff ff ff TRUE       equ	~FALSE
     62 U4341 ????						;
     63 U4341 ????						;---------------------------------------------------------
     64 U4341 ????						; One of these must be set to indicate which environment
     65 U4341 ????						; Tiny BASIC will be running in.  Here are the current
     66 U4341 ????						; environments:
     67 U4341 ????						;
     68 U4341 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     69 U4341 ????						; more K of RAM.
     70 U4341 ????						;
     71 U4341 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     72 U4341 ????						; which enhances, without replacing, the standard KIM
     73 U4341 ????						; monitor.  It gives access to routines to save/load files
     74 U4341 ????						; to a micro SD card.
     75 U4341 ????						;
     76 U4341 ????						; CTMON65 is a from-scratch monitor written for the
     77 U4341 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     78 U4341 ????						; easily be ported to other systems.  It has support for
     79 U4341 ????						; using a micro SD card for file storage/retrieval.
     80 U4341 ????						;
     81 U4341 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     82 U4341 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     83 U4341 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     84 U4341 ????	       ff ff ff ff IL_DEBUG_TEXT equ	TRUE	;Print out as text IL instructions
     85 U4341 ????						;
     86 U4341 ????						;   Need to define some macros for the dasm assembler
     87 U4341 ????						;
     88 U4341 ????				      MACRO	dw
     89 U4341 ????				      .word	{0}
     90 U4341 ????				      ENDM
     91 U4341 ????
     92 U4341 ????				      MACRO	db
     93 U4341 ????				      .byte	{0}
     94 U4341 ????				      ENDM
     95 U4341 ????
     96 U4341 ????						;
     97 U4341 ????						; If set, include disk functions.
     98 U4341 ????						;
     99 U4341 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
    100 U4341 ????						;
    101 U4341 ????						; If ILTRACE is set then dump out the address of every
    102 U4341 ????						; IL opcode before executing it.
    103 U4341 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    104 U4341 ????						;
    105 U4341 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    106 U4341 ????						;
    107 U4341 ????						; If FIXED is set, put the IL code and the user
    108 U4341 ????						; program space at fixed locations in memory.	This is
    109 U4341 ????						; meant only for debugging.
    110 U4341 ????						;
    111 U4341 ????	       00 00	   FIXED      equ	FALSE
    112 U4341 ????
    113 U4341 ????	       00 0f	   terminalIOblockLen equ	[TerminalIOblockEnd - TerminalIOblock]
    114 U4341 ????
    115 U4341 ????						;
    116 U4341 ????						; Sets the arithmetic stack depth.  This is *TINY*
    117 U4341 ????						; BASIC, so keep this small!
    118 U4341 ????						;
    119 U4341 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    120 U4341 ????	       00 32	   ILSTACKSIZE equ	50	;number of entries in ilstack
    121 U4341 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    122 U4341 ????	       00 25	   VARIABLESSIZE equ	37	;26 variables + 1 for exit code + 10 entries (20bytes) for ioblock
    123 U4341 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    124 U4341 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    125 U4341 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    126 U4341 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    127 U4341 ????
    128 U4341 ????	       00 36	   taskSTDIN  equ	[[VARIABLESSIZE - 10]*2]	;io vector
    129 U4341 ????	       00 38	   taskSTDOUT equ	[[[VARIABLESSIZE - 10]*2]+2]	;io vector
    130 U4341 ????
    131 U4341 ????	       00 3f	   taskIOinPort equ	[[[VARIABLESSIZE - 10]*2]+4+5]	;Offset into the ioblock
    132 U4341 ????	       00 3b	   taskIOoutPort equ	[[[VARIABLESSIZE - 10]*2]+4+1]	;Offset into the ioblock
    133 U4341 ????	       00 46	   taskIOstatusPort equ	[[[VARIABLESSIZE - 10]*2]+4+12]	;Offset into the ioblock
    134 U4341 ????						;
    135 U4341 ????						; Gosub entry types
    136 U4341 ????
    137 U4341 ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    138 U4341 ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    139 U4341 ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    140 U4341 ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    141 U4341 ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    142 U4341 ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    143 U4341 ????						; 0 byte is the original stack offset, byte 1 is the parameter count
    144 U4341 ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    145 U4341 ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    146 U4341 ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    147 U4341 ????						;
    148 U4341 ????						; Common ASCII constants
    149 U4341 ????						;
    150 U4341 ????	       00 07	   BEL	      equ	$07
    151 U4341 ????	       00 08	   BS	      equ	$08
    152 U4341 ????	       00 09	   TAB	      equ	$09
    153 U4341 ????	       00 0a	   LF	      equ	$0A
    154 U4341 ????	       00 0d	   CR	      equ	$0D
    155 U4341 ????	       00 22	   quote      equ	$22
    156 U4341 ????	       00 20	   SPACE      equ	$20
    157 U4341 ????	       00 2c	   COMMA      equ	',
    158 U4341 ????	       00 3b	   SEMICOLON  equ	';
    159 U4341 ????	       00 3a	   COLON      equ	':
    160 U4341 ????	       00 24	   DOLLAR     equ	'$
    161 U4341 ????						;
    162 U4341 ????						; These are error codes
    163 U4341 ????						;
    164 U4341 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    165 U4341 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    166 U4341 ????	       00 02	   ERR_UNDER  equ	2	;The Math stack underflow
    167 U4341 ????	       00 03	   ERR_OVER   equ	3	;The Math stack overflow
    168 U4341 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    169 U4341 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    170 U4341 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    171 U4341 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    172 U4341 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    173 U4341 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    174 U4341 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    175 U4341 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    176 U4341 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;the gosub Stack overflow
    177 U4341 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    178 U4341 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    179 U4341 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    180 U4341 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    181 U4341 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    182 U4341 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    183 U4341 ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    184 U4341 ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    185 U4341 ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    186 U4341 ????	       00 16	   ERR_EXPECTVAR equ	22	;Expected a variable name or definition
    187 U4341 ????	       00 17	   ERR_CLOSINGBRACKET equ	23	;Expected a closing bracket
    188 U4341 ????	       00 18	   ERR_MISSINGEQUALSIGN equ	24	;Expected an equal sign for assignment
    189 U4341 ????	       00 19	   ERR_FUNCTION_EXPECTED_PARAMETERS equ	25	;Function expected parameters
    190 U4341 ????	       00 1a	   ERR_EXPECTED_OPENING_BRACKET equ	26	;Expected opening bracket [ or (
    191 U4341 ????						;
    192 U4341 ????						;=====================================================
    193 U4341 ????						; Zero page storage.
    194 U4341 ????						;
    195 U00f6 ????				      SEG.U	ZEROPAGE
    196 U0040					      org	$0040
    197 U0040
    198 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    199 U0041
    200 U0041							; The context is used to locate a task switch
    201 U0041							; it copies from here till all task fields are saved/swapped
    202 U0041							; The max number of tasks is 256 / context length
    203 U0041							; All positions POS values are plus one task table incldues
    204 U0041							; a leading status byte .
    205 U0041							;
    206 U0041		       00 41	   CONTEXT    equ	*
    207 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    208 U0041
    209 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    210 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    211 U0043
    212 U0043		       00 00	   ILPC       ds	2	; IL program counter
    213 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    214 U0047		       00	   ILSTACKPTR ds	1
    215 U0048
    216 U0048
    217 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    218 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    219 U004a
    220 U004a
    221 U004a		       00	   MATHSTACKPTR ds	1
    222 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    223 U004b
    224 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    225 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT + 1	; Get the offset to the gosub/msg stack
    226 U004d
    227 U004d
    228 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    229 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    230 U004e
    231 U004e
    232 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    233 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    234 U004f							;
    235 U004f							; CURPTR is a pointer to curent BASIC line being
    236 U004f							; executed.  Always points to start of line, CUROFF
    237 U004f							; is the offset to the current character.
    238 U004f							; The order of these fields is important
    239 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    240 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    241 U0052							;
    242 U0052							;The order of these fields in important
    243 U0052
    244 U0052							;
    245 U0052							; R0, R1 and MQ are used for arithmetic operations and
    246 U0052							; general use.
    247 U0052							;
    248 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    249 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    250 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    251 U0056		       00 00	   MQ	      ds	2	;used for some math
    252 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    253 U0058		       00 59	   REGISTERSEND equ	*
    254 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    255 U0059
    256 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    257 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    258 U0059
    259 U0059		       00 00	   dpl	      ds	2	; Used as a pointer to call il instructions
    260 U005b							;
    261 U005b							; This is zero if in immediate mode, or non-zero
    262 U005b							; if currently running a program.  Any input from
    263 U005b							; the main loop clears this, and the XFER IL
    264 U005b							; statement will set it.
    265 U005b							;
    266 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    267 U005c							;
    268 U005c							; Used for line insertion/removal.
    269 U005c							;
    270 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    271 U005e
    272 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    273 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    274 U005e							;
    275 U005e		       00 00	   PrtFrom    ds	2	; FROM
    276 U0060
    277 U0060							;
    278 U0060							;=====================================================
    279 U0060							;
    280  366b ????				      SEG	Code
    281  0200					      org	$0200
    282  0200							;
    283  0200							; Cold start is at $0200.  Warm start is at $0203.
    284  0200							;
    285  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    286  0203		       4c 82 02    warm       jmp	warm2	;Entry point for worm restart
    287  0206							;
    288  0206							; These are the user-supplied vectors to I/O routines.
    289  0206							; If you want, you can just patch these in the binary
    290  0206							; file, but it would be better to change the source
    291  0206							; code.
    292  0206							;
    293  0206				  -	      if	KIM
    294  0206				  -OUTCH      jmp	$1ea0	;output char in A
    295  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    296  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    297  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    298  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    299  0206					      endif
    300  0206				  -	      if	XKIM
    301  0206				  -	      include	"xkim.inc"
    302  0206				  -	      SEG	Code
    303  0206				  -OUTCH      jmp	$1ea0
    304  0206				  -GETCH      jmp	xkGETCH
    305  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    306  0206				  -OUTHEX     jmp	xkPRTBYT
    307  0206				  -MONITOR    jmp	extKIM
    308  0206				  -puts       equ	putsil
    309  0206				  -BUFFER_SIZE equ	132
    310  0206					      endif
    311  0206
    312  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0060					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    314 Udf8e
    315  0206					      SEG	Code
    316  0206							;
    317  0206		       f0 0c	   OUTCH      equ	cout
    318  0206		       f0 09	   GETCH      equ	cin
    319  0206		       2d 7d	   CRLF       equ	tbcrlf
    320  0206		       21 9e	   OUTHEX     equ	HexToOut
    321  0206		       f0 03	   MONITOR    equ	WARM
    322  0206		       f0 0f	   ISCHAR     equ	cstatus
    323  0206		       21 bb	   puts       equ	tbputs
    324  0206					      endif
    325  0206							;
    326  0206		       20 c4 2e    cold2      jsr	SetOutConsole
    327  0209		       20 d1 2e 	      jsr	SetInConsole
    328  020c		       20 bb 21 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.20  IRQs/Tasks/Tokens"
      0  0241					      db	CR,LF,0
      1  0241		       0d 0a 00 	      .byte.b	CR,LF,0
    332  0244							;
    333  0244		       20 af 23 	      jsr	MemInit	;setup the free space available
    334  0247
    335  0247		       a9 01	   calcstack  lda	#1
    336  0249		       8d bd 37 	      sta	taskCounter	; Initialize number of tasks to 1
    337  024c		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    338  024e		       8d bf 36 	      sta	taskTable	; mark the main task as active
    339  0251		       20 fc 25 	      jsr	taskSetStacks	; setup all the task stacks/Variables, Init task io block
    340  0254		       a9 01		      lda	#IL&$ff
    341  0256		       85 43		      sta	ILPC
    342  0258		       a9 32		      lda	#IL>>8
    343  025a		       85 44		      sta	ILPC+1
    344  025c							;
    345  025c							;		  lda	  ProgramStart		     ; user prog
    346  025c							;		  sta	  ProgramEnd
    347  025c							;		  lda	  ProgramStart+1
    348  025c							;		  sta	  ProgramEnd+1
    349  025c							;
    350  025c
    351  025c							;  Init time slices defaults
    352  025c		       a9 02		      lda	#TASKCYCLESHIGH
    353  025e		       8d bc 37 	      sta	taskResetValue+1
    354  0261		       a9 ff		      lda	#TASKCYCLESDEFAULT
    355  0263		       8d bb 37 	      sta	taskResetValue
    356  0266							;
    357  0266							; Initialize the pseudo-random number sequence...
    358  0266							;
    359  0266		       a9 5a		      lda	#$5a
    360  0268		       8d 27 43 	      sta	rtemp1
    361  026b		       a9 9d		      lda	#%10011101
    362  026d		       8d 29 43 	      sta	random
    363  0270		       a9 5b		      lda	#%01011011
    364  0272		       8d 2a 43 	      sta	random+1
    365  0275							;
    366  0275							;   Insert a Basic irq handler for the basic Language
    367  0275		       a9 41		      lda	#ServiceIrq&$ff
    368  0277		       8d 00 df 	      sta	IRQvec
    369  027a		       a9 1a		      lda	#ServiceIrq>>8
    370  027c		       8d 01 df 	      sta	IRQvec+1
    371  027f		       4c 95 02 	      jmp	coldtwo
    372  0282
    373  0282							;
    374  0282							;
    375  0282							; This is the warm start entry point
    376  0282							;
    377  0282		       20 c4 2e    warm2      jsr	SetOutConsole
    378  0285		       20 d1 2e 	      jsr	SetInConsole
    379  0288		       20 7d 2d 	      jsr	CRLF
    380  028b		       ad 24 43 	      lda	errGoto
    381  028e		       85 43		      sta	ILPC
    382  0290		       ad 25 43 	      lda	errGoto+1
    383  0293		       85 44		      sta	ILPC+1
    384  0295							;
    385  0295							; And continue with both starts here
    386  0295							;
    387  0295				   coldtwo
    388  0295							;
    389  0295							; The ILTrace flag is now run-time settable.
    390  0295							;
    391  0295		       a9 00		      lda	#ILTRACE&$ff
    392  0297		       85 40		      sta	ILTrace
    393  0299							;
    394  0299
    395  0299		       a9 00		      lda	#0
    396  029b		       85 5b		      sta	RunMode
    397  029d		       8d 9a 42 	      sta	LINBUF
    398  02a0
    399  02a0							; Clear everything from the stacks
    400  02a0
    401  02a0		       8d 31 43 	      sta	taskIOPending	; No one waiting for io
    402  02a3		       8d 32 43 	      sta	taskRDPending	; No one waiting for bg io
    403  02a6
    404  02a6		       20 78 26 	      jsr	taskReset
    405  02a9							;
    406  02a9		       a9 9a		      lda	#LINBUF&$ff
    407  02ab		       85 4f		      sta	CURPTR
    408  02ad		       a9 42		      lda	#LINBUF>>8
    409  02af		       85 50		      sta	CURPTR+1	;fall through...
    410  02b1
    411  02b1							;=====================================================
    412  02b1							; This is the top of the IL interpreter.  This fetches
    413  02b1							; and executes the instruction currently pointed to
    414  02b1							; by ILPC and adjusts ILPC to point to the next
    415  02b1							; instruction to execute.
    416  02b1							;
    417  02b1				   NextIL
    418  02b1		       ba		      tsx		; Get the stack pointer value
    419  02b2		       e0 ff		      cpx	#$FF	; Should be empty
    420  02b4		       d0 29		      bne	ILbad	; Halt and catch fire now!
    421  02b6
    422  02b6		       ce b9 37 	      dec	taskCurrentCycles
    423  02b9		       d0 03		      bne	NextIlNow
    424  02bb		       20 a1 26 	      jsr	iTaskSwitch	;check for a task switch
    425  02be		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    426  02c0		       f0 03		      beq	NextIL2	;Skip if no bits set
    427  02c2
    428  02c2		       20 0e 2e 	      jsr	dbgLine	;Print the IL trace information
    429  02c5
    430  02c5		       a4 51	   NextIL2    ldy	CUROFF
    431  02c7							;		  jsr	  SkipSpaces	       ; no longer needed as tokenizer takes care of this
    432  02c7							;		  sty	  CUROFF
    433  02c7							;Task IO Management
    434  02c7		       ad 32 43 	      lda	taskRDPending	; if it is zero then Nothing pending
    435  02ca		       f0 08		      beq	NextILStr
    436  02cc		       20 b6 2b 	      jsr	ReadLine	; else Pending and poll keyboard
    437  02cf		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    438  02d1		       ce 32 43 	      dec	taskRDPending	; Carry is set if CR has been recieved
    439  02d4							;
    440  02d4		       20 39 2a    NextILStr  jsr	getILByte
    441  02d7							;
    442  02d7							; When the handler is called, these are the conditions
    443  02d7							; of several important items:
    444  02d7							;
    445  02d7							;    (ILPC) will point to the byte AFTER the IL
    446  02d7							;    opcode being executed.
    447  02d7							;
    448  02d7							;    (CURPTR),CUROFF will point to the start of the
    449  02d7							;    next word in the input buffer.  Ie, the next word
    450  02d7							;    in the user program.
    451  02d7							;
    452  02d7		       18		      clc		; Clear carry before shift
    453  02d8		       0a		      asl		; valid for 0-127
    454  02d9		       b0 04		      bcs	ILbad	; Out of range
    455  02db		       aa		      tax		; Move value to x
      0  02dc					      db	$7c	; jmp (ILTBL,X) ; dasm does not support 65c02 inst
      1  02dc		       7c		      .byte.b	$7c
      0  02dd					      dw	ILTBL	; Actual IL table address
      1  02dd		       20 03		      .word.w	ILTBL
    458  02df
    459  02df							;		asl
    460  02df							;		cmp	#ILTBLend-ILTBL+2
    461  02df							;		bcc	ILgood
    462  02df							;
    463  02df							; This handles an illegal IL opcode.  This is serious
    464  02df							; and there's no way to recover.
    465  02df							;
    466  02df				   iBadOP
    467  02df		       20 bb 21    ILbad      jsr	puts
      0  02e2					      db	CR,LF
      1  02e2		       0d 0a		      .byte.b	CR,LF
      0  02e4					      db	"Illegal IL "
      1  02e4		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02ef					      db	0
      1  02ef		       00		      .byte.b	0
    471  02f0							;
    472  02f0							; Well this is awkward, we need to back up the IL
    473  02f0							; by one since it no longer points to the current
    474  02f0							; opcode.
    475  02f0							;
    476  02f0		       20 46 2a 	      jsr	decIL
    477  02f3							;
    478  02f3		       a0 00		      ldy	#0
    479  02f5		       b1 43		      lda	(ILPC),y
    480  02f7		       20 9e 21 	      jsr	OUTHEX
    481  02fa		       20 bb 21 	      jsr	puts
      0  02fd					      db	" at ",0
      1  02fd		       20 61 74 20*	      .byte.b	" at ",0
    483  0302		       a5 44		      lda	ILPC+1
    484  0304		       20 9e 21 	      jsr	OUTHEX
    485  0307		       a5 43		      lda	ILPC
    486  0309		       20 9e 21 	      jsr	OUTHEX
    487  030c		       20 7d 2d 	      jsr	CRLF
    488  030f		       4c 03 f0 	      jmp	MONITOR
    489  0312							;
    490  0312							; Just jump to the address (ILPC),y.  Have to do
    491  0312							; some goofy stuff.
    492  0312							;
    493  0312		       a8	   ILgood     tay		;move index into Y
    494  0313		       b9 20 03 	      lda	ILTBL,y
    495  0316		       85 59		      sta	dpl
    496  0318		       b9 21 03 	      lda	ILTBL+1,y
    497  031b		       85 5a		      sta	dpl+1
    498  031d		       6c 59 00 	      jmp	(dpl)	;go to handler
    499  0320							;
    500  0320							;=====================================================
    501  0320							; This is the IL jump table.  The IL opcode is
    502  0320							; mulitplied by two, then looked-up in this table.
    503  0320							; There is absolutely nothing special about the order
    504  0320							; of entries here... they all decode at exactly the
    505  0320							; same speed.	However the entry number must match the
    506  0320							; values in IL.inc.
    507  0320							;
    508  0320				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0320					      include	"ilvectortable.asm"
      1  0320					      seg	Code
      2  0320				   ILTBL1
      0  0320					      dw	iXINIT	;0
      1  0320		       58 04		      .word.w	iXINIT
      0  0322					      dw	iDONE	;1
      1  0322		       75 04		      .word.w	iDONE
      0  0324					      dw	iPRS	;2
      1  0324		       8c 04		      .word.w	iPRS
      0  0326					      dw	iPRN	;3
      1  0326		       94 04		      .word.w	iPRN
      0  0328					      dw	iSPC	;4
      1  0328		       9d 04		      .word.w	iSPC
      0  032a					      dw	iNLINE	;5
      1  032a		       44 09		      .word.w	iNLINE
      0  032c					      dw	iNXT	;6
      1  032c		       a5 04		      .word.w	iNXT
      0  032e					      dw	iXFER	;7
      1  032e		       e7 04		      .word.w	iXFER
      0  0330					      dw	iSAV	;8
      1  0330		       05 05		      .word.w	iSAV
      0  0332					      dw	iRSTR	;9
      1  0332		       77 25		      .word.w	iRSTR
      0  0334					      dw	iCMPR	;10
      1  0334		       4b 05		      .word.w	iCMPR
      0  0336					      dw	iINNUM	;11
      1  0336		       ca 05		      .word.w	iINNUM
      0  0338					      dw	iFIN	;12
      1  0338		       02 06		      .word.w	iFIN
      0  033a					      dw	iERR	;13
      1  033a		       16 06		      .word.w	iERR
      0  033c					      dw	iADD	;14
      1  033c		       9f 06		      .word.w	iADD
      0  033e					      dw	iSUB	;15
      1  033e		       b5 06		      .word.w	iSUB
      0  0340					      dw	iNEG	;16
      1  0340		       cb 06		      .word.w	iNEG
      0  0342					      dw	iMUL	;17
      1  0342		       e3 06		      .word.w	iMUL
      0  0344					      dw	iDIV	;18
      1  0344		       23 07		      .word.w	iDIV
      0  0346					      dw	iSTORE	;19
      1  0346		       7b 07		      .word.w	iSTORE
      0  0348					      dw	iIND	;20
      1  0348		       99 07		      .word.w	iIND
      0  034a					      dw	iLST	;21
      1  034a		       3a 08		      .word.w	iLST
      0  034c					      dw	iINIT	;22
      1  034c		       20 04		      .word.w	iINIT
      0  034e					      dw	iGETLINE	;23
      1  034e		       70 08		      .word.w	iGETLINE
      0  0350					      dw	iINSRT	;24
      1  0350		       8d 08		      .word.w	iINSRT
      0  0352					      dw	iRTN	;25
      1  0352		       3e 09		      .word.w	iRTN
      0  0354					      dw	MONITOR	;26
      1  0354		       03 f0		      .word.w	MONITOR
      0  0356					      dw	iLIT	;27
      1  0356		       68 09		      .word.w	iLIT
      0  0358					      dw	iCALL	;28
      1  0358		       4a 09		      .word.w	iCALL
      0  035a					      dw	iJMP	;29
      1  035a		       56 09		      .word.w	iJMP
      0  035c					      dw	iVINIT	;30
      1  035c		       8d 09		      .word.w	iVINIT
      0  035e					      dw	iERRGOTO	;31
      1  035e		       96 09		      .word.w	iERRGOTO
      0  0360					      dw	iTST	;32
      1  0360		       a2 09		      .word.w	iTST
      0  0362					      dw	iTSTV	;33
      1  0362		       c7 0a		      .word.w	iTSTV
      0  0364					      dw	iTSTL	;34
      1  0364		       6d 0b		      .word.w	iTSTL
      0  0366					      dw	iTSTN	;35
      1  0366		       88 0b		      .word.w	iTSTN
      0  0368					      dw	iFREE	;36
      1  0368		       41 0c		      .word.w	iFREE
      0  036a					      dw	iRANDOM	;37
      1  036a		       47 0c		      .word.w	iRANDOM
      0  036c					      dw	iABS	;38
      1  036c		       18 0d		      .word.w	iABS
     42  036e							;
     43  036e							; Disk functions.  There must be pointers
     44  036e							; to functions even if no disk is supported.
     45  036e							; Makes things easier in IL.inc.
     46  036e							;
     47  036e					      if	DISK_ACCESS
      0  036e					      dw	iOPENREAD	;39
      1  036e		       1d 30		      .word.w	iOPENREAD
      0  0370					      dw	iOPENWRITE	;40
      1  0370		       7e 30		      .word.w	iOPENWRITE
      0  0372					      dw	iDCLOSE	;41
      1  0372		       12 31		      .word.w	iDCLOSE
      0  0374					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0374		       a0 30		      .word.w	iDGETLINE
      0  0376					      dw	iDLIST	;43 Did you remember your towel?
      1  0376		       0c 31		      .word.w	iDLIST
      0  0378					      dw	iDDIR	;44
      1  0378		       e7 30		      .word.w	iDDIR
      0  037a					      dw	iRMFILE	;45
      1  037a		       6c 30		      .word.w	iRMFILE
     55  037c				  -	      else
     56  037c				  -	      dw	NextIL	;39
     57  037c				  -	      dw	NextIL	;40
     58  037c				  -	      dw	NextIL	;41
     59  037c				  -	      dw	NextIL	;42
     60  037c				  -	      dw	NextIL	;43
     61  037c				  -	      dw	NextIL	;44
     62  037c				  -	      dw	NextIL	;45
     63  037c					      endif
     64  037c							;
      0  037c					      dw	iCLEARSCREEN	;46
      1  037c		       de 2e		      .word.w	iCLEARSCREEN
      0  037e					      dw	iPOKEMEMORY	;47
      1  037e		       a5 0c		      .word.w	iPOKEMEMORY
      0  0380					      dw	iPEEKMEMORY	;48
      1  0380		       ba 0c		      .word.w	iPEEKMEMORY
      0  0382					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0382		       e9 09		      .word.w	iTSTLET
      0  0384					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0384		       6e 0a		      .word.w	iTSTDONE
      0  0386					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0386		       e7 0c		      .word.w	iGETCHAR
      0  0388					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0388		       fb 0c		      .word.w	iPUTCHAR
      0  038a					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  038a		       d0 0c		      .word.w	iCallFunc
      0  038c					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  038c		       98 05		      .word.w	iBranch
      0  038e					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  038e		       cc 09		      .word.w	iTSTStr
      0  0390					      dw	iSetIrq	;56	   sets the irq handler
      1  0390		       bf 0d		      .word.w	iSetIrq
      0  0392					      dw	iTstIrq	;57	   test if irq is pending
      1  0392		       ff 0b		      .word.w	iTstIrq
      0  0394					      dw	iRET	;58	   return from interupt
      1  0394		       39 05		      .word.w	iRET
      0  0396					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0396		       e3 05		      .word.w	iINSTR
      0  0398					      dw	iMOD	;60	   returns remainder of division
      1  0398		       2c 07		      .word.w	iMOD
      0  039a					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  039a		       f5 26		      .word.w	iTaskSet
      0  039c					      dw	iETask	;62	   Terminates a task
      1  039c		       32 28		      .word.w	iETask
      0  039e					      dw	iNTask	;63	   goto next task
      1  039e		       e5 27		      .word.w	iNTask
     83  03a0				   ILTBL2
      0  03a0					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a0		       b8 07		      .word.w	iArray
      0  03a2					      dw	iTaskKill	;65	   kill a running task
      1  03a2		       dd 27		      .word.w	iTaskKill
      0  03a4					      dw	iTaskStat	;66	   return the state of a task PID
      1  03a4		       b1 27		      .word.w	iTaskStat
      0  03a6					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03a6		       06 0d		      .word.w	iHexOut
      0  03a8					      dw	iReadComplete	;68	   Called after a background read completes
      1  03a8		       b4 05		      .word.w	iReadComplete
      0  03aa					      dw	iReadStart	;69	   Called to start a background read request
      1  03aa		       aa 05		      .word.w	iReadStart
      0  03ac					      dw	iStartIO	;70	   Lock task until io complete
      1  03ac		       15 28		      .word.w	iStartIO
      0  03ae					      dw	iEndIO	;71	   release task lock for io
      1  03ae		       1b 28		      .word.w	iEndIO
      0  03b0					      dw	iLogNot	;72	   Logical not
      1  03b0		       71 0d		      .word.w	iLogNot
      0  03b2					      dw	iLogOr	;73	   Logical Or
      1  03b2		       47 0d		      .word.w	iLogOr
      0  03b4					      dw	iLogAnd	;74	   Logical And
      1  03b4		       32 0d		      .word.w	iLogAnd
      0  03b6					      dw	iLogXor	;75	   Logical Xor
      1  03b6		       5c 0d		      .word.w	iLogXor
      0  03b8					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03b8		       f0 27		      .word.w	iWTASK
      0  03ba					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03ba		       26 28		      .word.w	iTASKPID
      0  03bc					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03bc		       fd 0d		      .word.w	iTRACEPROG
      0  03be					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03be		       8a 2d		      .word.w	idbgBasic
      0  03c0					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c0		       12 29		      .word.w	iIPCS
      0  03c2					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c2		       29 29		      .word.w	iIPCR
      0  03c4					      dw	iIPCC	;82	   Check if any message available for task
      1  03c4		       3d 29		      .word.w	iIPCC
      0  03c6					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03c6		       4a 29		      .word.w	iIPCIO
      0  03c8					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03c8		       dd 24		      .word.w	iPushMathStack
      0  03ca					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03ca		       0d 25		      .word.w	iPopMathStack
      0  03cc					      dw	iSaveMathStack	;86	   Save all math info
      1  03cc		       2a 25		      .word.w	iSaveMathStack
      0  03ce					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03ce		       49 25		      .word.w	iRestoreMathStack
      0  03d0					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d0		       fa 24		      .word.w	iIncParmCount
      0  03d2					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d2		       52 28		      .word.w	iTaskGetMathStack
      0  03d4					      dw	iTaskEnable	;90	   enable a suspended task
      1  03d4		       7f 27		      .word.w	iTaskEnable
      0  03d6					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03d6		       99 27		      .word.w	iTaskSuspend
      0  03d8					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03d8		       6c 28		      .word.w	iTaskPutMathPtr
      0  03da					      dw	iTSTVT	;93	   test for another tasks variable
      1  03da		       be 0a		      .word.w	iTSTVT
      0  03dc					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03dc		       60 09		      .word.w	iSetR2
      0  03de					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03de		       17 05		      .word.w	iStk2Tmp
      0  03e0					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e0		       28 05		      .word.w	iTmp2Stk
      0  03e2					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e2		       0a 0a		      .word.w	iTSTBYTE
      0  03e4					      dw	iINCVAR	;98	   Increment variable
      1  03e4		       90 0a		      .word.w	iINCVAR
      0  03e6					      dw	iDECVAR	;99	   Decrement variable
      1  03e6		       a8 0a		      .word.w	iDECVAR
      0  03e8					      dw	iSLICE	;100	   set the time slice for tasks
      1  03e8		       a5 28		      .word.w	iSLICE
      0  03ea					      dw	iTSTB	;101	   Test if byte equals
      1  03ea		       29 0a		      .word.w	iTSTB
      0  03ec					      dw	iTSTW	;102	   Test If word equals
      1  03ec		       44 0a		      .word.w	iTSTW
      0  03ee					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03ee		       54 1f		      .word.w	iOnGoto
      0  03f0					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03f0		       85 1f		      .word.w	iTSTRELOP
      0  03f2					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03f2		       cb 04		      .word.w	iRepeatLine
      0  03f4					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch if is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03f4		       ac 1f		      .word.w	iTSTBRANCH
      0  03f6					      dw	iFastXfer	;107	   move top of stack to curptr
      1  03f6		       d2 04		      .word.w	iFastXfer
      0  03f8					      dw	iSetTerminal	;108	   Set the Io Terminal to be used by print and input statements
      1  03f8		       60 2f		      .word.w	iSetTerminal
      0  03fa					      dw	iINDB	;109	   fetch a single byte from memory indirect
      1  03fa		       a6 07		      .word.w	iINDB
      0  03fc					      dw	iSetBlock	;110	   Set a block or words or byte to a value 16 bit length
      1  03fc		       04 24		      .word.w	iSetBlock
      0  03fe					      dw	iCopyBlock	;111	   Copy a block or memory from one location to another 16 bit length
      1  03fe		       5a 24		      .word.w	iCopyBlock
      0  0400					      dw	iCmpBlock	;112	   Compare to parts of memory
      1  0400		       8e 24		      .word.w	iCmpBlock
      0  0402					      dw	iShift	;113	   Shift left 0 or right 1
      1  0402		       95 0d		      .word.w	iShift
      0  0404					      dw	iTimer	;114	   Start/Stop/Set timer and enable disable system irq
      1  0404		       74 19		      .word.w	iTimer
    135  0406
      0  0406					      dw	iBadOP	;115	   Invalid IL op code
      1  0406		       df 02		      .word.w	iBadOP
      0  0408					      dw	iBadOP	;116	   Invalid IL op code
      1  0408		       df 02		      .word.w	iBadOP
      0  040a					      dw	iBadOP	;117	   Invalid IL op code
      1  040a		       df 02		      .word.w	iBadOP
      0  040c					      dw	iBadOP	;118	   Invalid IL op code
      1  040c		       df 02		      .word.w	iBadOP
      0  040e					      dw	iBadOP	;119	   Invalid IL op code
      1  040e		       df 02		      .word.w	iBadOP
      0  0410					      dw	iBadOP	;120	   Invalid IL op code
      1  0410		       df 02		      .word.w	iBadOP
      0  0412					      dw	iBadOP	;121	   Invalid IL op code
      1  0412		       df 02		      .word.w	iBadOP
      0  0414					      dw	iBadOP	;122	   Invalid IL op code
      1  0414		       df 02		      .word.w	iBadOP
      0  0416					      dw	iBadOP	;123	   Invalid IL op code
      1  0416		       df 02		      .word.w	iBadOP
      0  0418					      dw	iBadOP	;124	   Invalid IL op code
      1  0418		       df 02		      .word.w	iBadOP
      0  041a					      dw	iBadOP	;125	   Invalid IL op code
      1  041a		       df 02		      .word.w	iBadOP
      0  041c					      dw	iBadOP	;126	   Invalid IL op code
      1  041c		       df 02		      .word.w	iBadOP
      0  041e					      dw	iBadOP	;127	   Invalid IL op code
      1  041e		       df 02		      .word.w	iBadOP
    149  0420
    150  0420
    151  0420
    152  0420
------- FILE mytb.asm
    510  0420		       04 20	   ILTBLend   equ	*
    511  0420
    512  0420							;
    513  0420							;=====================================================
    514  0420							;=====================================================
    515  0420							;=====================================================
    516  0420							; This marks the start of the handlers for IL opcodes.
    517  0420							;=====================================================
    518  0420							;=====================================================
    519  0420							;=====================================================
    520  0420							;
    521  0420							;
    522  0420		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    523  0422		       85 47		      sta	ILSTACKPTR
    524  0424		       85 4a		      sta	MATHSTACKPTR
    525  0426		       85 4d		      sta	GOSUBSTACKPTR
    526  0428		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    527  042a		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    528  042c							;
    529  042c		       ad 37 43 	      lda	ProgramStart	; user prog
    530  042f		       85 4f		      sta	CURPTR
    531  0431		       8d c0 36 	      sta	taskTable+1
    532  0434		       8d 39 43 	      sta	ProgramEnd
    533  0437		       ad 38 43 	      lda	ProgramStart+1
    534  043a		       85 50		      sta	CURPTR+1
    535  043c		       8d c1 36 	      sta	taskTable+2
    536  043f		       8d 3a 43 	      sta	ProgramEnd+1
    537  0442		       a9 80		      lda	#TASKACTIVE
    538  0444		       8d bf 36 	      sta	taskTable	;Mark the first slot as active
    539  0447		       a9 01		      lda	#1
    540  0449		       8d bd 37 	      sta	taskCounter	;there is always one task / Main task
    541  044c		       ad bb 37 	      lda	taskResetValue
    542  044f		       8d b9 37 	      sta	taskCurrentCycles	; set up the task switch counts
    543  0452		       ad bc 37 	      lda	taskResetValue+1
    544  0455		       8d ba 37 	      sta	taskCurrentCycles+1
    545  0458							;
    546  0458							; fall into XINIT...
    547  0458							;
    548  0458							;=====================================================
    549  0458							; This initializes for the start of the next line of
    550  0458							; BASIC text.
    551  0458							;
    552  0458		       78	   iXINIT     sei		; ensure interupts are off
    553  0459		       20 78 26 	      jsr	taskReset	; Clear the task table
    554  045c		       a9 00		      lda	#0	; Clear the irq flags
    555  045e		       8d c6 19 	      sta	IRQPending	; reset the irq pending
    556  0461		       8d c5 19 	      sta	IRQStatus	; Make sure irqs are off
    557  0464
    558  0464		       4c b1 02    goodExit   jmp	NextIL
    559  0467							;
    560  0467							;=====================================================
    561  0467							; This check if the escape key has been entered
    562  0467							; then changes out of run mode. z Set if esc found
    563  0467				   BreakSet
    564  0467		       20 0f f0 	      jsr	ISCHAR
    565  046a		       f0 06		      beq	BreakNo
    566  046c		       20 66 1a 	      jsr	VGETCH
    567  046f		       c9 1b		      cmp	#$1B
    568  0471		       60		      rts
    569  0472				   BreakNo
    570  0472		       a9 01		      lda	#1
    571  0474		       60		      rts
    572  0475
    573  0475							;
    574  0475
    575  0475							;=====================================================
    576  0475							; Verify there is nothing else on this input line.
    577  0475							; If there is, generate an error.
    578  0475							;
    579  0475		       a4 51	   iDONE      ldy	CUROFF
    580  0477		       b1 4f		      lda	(CURPTR),y
    581  0479		       f0 0e		      beq	doneadv
    582  047b		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    583  047d		       d0 03		      bne	idoneErr
    584  047f							;		  sty	  CUROFF
    585  047f		       4c b1 02 	      jmp	NextIL	; continue on this line
    586  0482
    587  0482				   idoneErr
    588  0482		       a2 04		      ldx	#ERR_EXTRA_STUFF
    589  0484		       a9 00		      lda	#0
    590  0486		       4c 7d 06 	      jmp	iErr2
    591  0489							;
    592  0489							; Advance to the next line
    593  0489							;
    594  0489				   doneadv
    595  0489		       4c b1 02 	      jmp	NextIL
    596  048c							;
    597  048c							;=====================================================
    598  048c							; Print the string until a closing quote
    599  048c							;
    600  048c				   iPRS
    601  048c		       20 de 21 	      jsr	PrtQuoted
    602  048f		       84 51		      sty	CUROFF
    603  0491		       4c b1 02 	      jmp	NextIL
    604  0494							;
    605  0494							;=====================================================
    606  0494							; Pop the top off the stack and print it as a signed
    607  0494							; decimal number.
    608  0494							;
    609  0494				   iPRN
    610  0494		       20 c4 2c 	      jsr	popR0
    611  0497		       20 ea 20 	      jsr	PrintDecimal
    612  049a		       4c b1 02 	      jmp	NextIL
    613  049d							;
    614  049d							;=====================================================
    615  049d							; Space to next zone.	Currently the code does not
    616  049d							; keep track of which column the output is on, so
    617  049d							; just print a tab.
    618  049d							;
    619  049d				   iSPC
    620  049d		       a9 09		      lda	#TAB
    621  049f		       20 63 1a 	      jsr	VOUTCH
    622  04a2		       4c b1 02 	      jmp	NextIL
    623  04a5							;
    624  04a5							;=====================================================
    625  04a5							; If in immediate mode, jump to the address following
    626  04a5							; the NXT instruction.  Else move to the next line of
    627  04a5							; user code and continue.
    628  04a5							;
    629  04a5		       a5 5b	   iNXT       lda	RunMode
    630  04a7		       d0 03		      bne	iNxtRun	;in run mode
    631  04a9							;
    632  04a9							; Get address and jump to it.
    633  04a9							;
    634  04a9		       4c 56 09 	      jmp	iJMP
    635  04ac							;
    636  04ac				   iNxtRun
    637  04ac		       a4 51		      ldy	CUROFF
    638  04ae		       b1 4f		      lda	(CURPTR),y
    639  04b0		       c9 e6		      cmp	#oColon
    640  04b2		       d0 06		      bne	iNxtRunGo
    641  04b4		       c8		      iny
    642  04b5		       84 51		      sty	CUROFF
    643  04b7		       4c c5 04 	      jmp	iNxtRun2
    644  04ba
    645  04ba				   iNxtRunGo
    646  04ba		       20 c3 2a 	      jsr	FindNextLine
    647  04bd		       20 d7 2a 	      jsr	AtEnd
    648  04c0		       d0 03		      bne	iNxtRun2	;not at end
    649  04c2							;
    650  04c2							; At the end of the program.  Pretend an END statement
    651  04c2							; was found.
    652  04c2							;
    653  04c2		       4c 02 06    iFINv      jmp	iFIN
    654  04c5							;
    655  04c5		       20 35 2a    iNxtRun2   jsr	getILWord	;ignore next word
    656  04c8		       4c b1 02 	      jmp	NextIL
    657  04cb							;=====================================================
    658  04cb							;Repeat the same line against
    659  04cb		       a0 03	   iRepeatLine ldy	#3
    660  04cd		       84 51		      sty	CUROFF
    661  04cf		       4c b1 02 	      jmp	NextIL
    662  04d2							;
    663  04d2							;=====================================================
    664  04d2							; XFER takes the number on top of the stack and looks
    665  04d2							; for that line in the program, or the next line
    666  04d2							; higher.  Ie, if it's 1 but there is no line 1, then
    667  04d2							; find the next one after that.
    668  04d2							;
    669  04d2				   iFastXfer
    670  04d2		       20 dc 2c 	      jsr	popR1	; get type of transfer
    671  04d5		       a5 54		      lda	R1
    672  04d7		       f0 0e		      beq	iXFER
    673  04d9
    674  04d9		       20 c4 2c 	      jsr	popR0	; get where to transfer
    675  04dc				   FastFastXfer
    676  04dc		       a5 52		      lda	R0
    677  04de		       85 4f		      sta	CURPTR
    678  04e0		       a5 53		      lda	R0+1
    679  04e2		       85 50		      sta	CURPTR+1
    680  04e4		       4c ed 04 	      jmp	iXFER2
    681  04e7
    682  04e7				   iXFER
    683  04e7		       20 c4 2c 	      jsr	popR0
    684  04ea		       20 7e 2a 	      jsr	findLine
    685  04ed
    686  04ed				   iXFER2
    687  04ed		       20 d7 2a 	      jsr	AtEnd	;at end of user program?
    688  04f0		       f0 d0		      beq	iFINv
    689  04f2
    690  04f2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    691  04f4		       84 51		      sty	CUROFF
    692  04f6
    693  04f6							;		  lda	  #$ff
    694  04f6							;		  sta	  RunMode
    695  04f6							;
    696  04f6							; Transfer IL to STMT.  I don't like having this
    697  04f6							; hard-coded; fix it.
    698  04f6							;
    699  04f6							;		  lda	  #STMT&$ff
    700  04f6							;		  sta	  ILPC
    701  04f6							;		  lda	  #STMT>>8
    702  04f6							;		  sta	  ILPC+1
    703  04f6							;		  jmp	  NextIL
    704  04f6							;
    705  04f6							; Run
    706  04f6							;
    707  04f6				   iXferok
    708  04f6		       a9 ff		      lda	#$ff
    709  04f8		       85 5b		      sta	RunMode	;we're running
    710  04fa							;
    711  04fa							; Need a more elegant way to do this
    712  04fa							;
    713  04fa		       a9 0f		      lda	#STMT&$ff
    714  04fc		       85 43		      sta	ILPC
    715  04fe		       a9 32		      lda	#STMT>>8
    716  0500		       85 44		      sta	ILPC+1
    717  0502		       4c b1 02 	      jmp	NextIL
    718  0505							;
    719  0505							;=====================================================
    720  0505							; Save the pointer to the next line to the call stack.
    721  0505							;
    722  0505		       20 39 2a    iSAV       jsr	getILByte	; load type of gosub
    723  0508		       20 4c 2c 	      jsr	pushLN	; Type passed in A
    724  050b		       b0 03		      bcs	iSAVErr
    725  050d		       4c b1 02 	      jmp	NextIL
    726  0510
    727  0510		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    728  0512		       a9 00	   iSAVErr2   lda	#0
    729  0514		       4c 7d 06 	      jmp	iErr2
    730  0517							;====================================================
    731  0517							; Move stack top to and from temp area
    732  0517				   iStk2Tmp
    733  0517		       20 c4 2c 	      jsr	popR0
    734  051a		       a5 52		      lda	R0
    735  051c		       a0 48		      ldy	#TASKEXITCODE	; can also be used as temp
    736  051e		       91 41		      sta	(VARIABLES),y
    737  0520		       c8		      iny
    738  0521		       a5 53		      lda	R0+1
    739  0523		       91 41		      sta	(VARIABLES),y
    740  0525		       4c b1 02 	      jmp	NextIL
    741  0528
    742  0528		       a0 48	   iTmp2Stk   ldy	#TASKEXITCODE
    743  052a		       b1 41		      lda	(VARIABLES),y
    744  052c		       85 52		      sta	R0
    745  052e		       c8		      iny
    746  052f		       b1 41		      lda	(VARIABLES),y
    747  0531		       85 53		      sta	R0+1
    748  0533		       20 32 2c 	      jsr	pushR0
    749  0536		       4c b1 02 	      jmp	NextIL
    750  0539							;
    751  0539							;=====================================================
    752  0539							; Pop the next line from the call stack. IRQ return
    753  0539							;
    754  0539		       20 75 2c    iRET       jsr	popLN
    755  053c		       b0 d2		      bcs	iSAVErr
    756  053e		       a0 03		      ldy	#3
    757  0540		       84 51		      sty	CUROFF
    758  0542		       a9 00		      lda	#0
    759  0544		       8d c6 19 	      sta	IRQPending
    760  0547		       58		      cli
    761  0548		       4c b1 02 	      jmp	NextIL
    762  054b							;
    763  054b							;=====================================================
    764  054b							; Compare items on stack.  Okay, so on input there are
    765  054b							; three things on the stack
    766  054b							;
    767  054b							;    EXPR2 <- Top of stack
    768  054b							;    OP    <- relational operator, next on stack
    769  054b							;    EXPR1 <- last item on stack
    770  054b							;
    771  054b							; Comparison is: EXPR1 <operator> EXPR2
    772  054b							;
    773  054b							; Operator is one of...
    774  054b							;
    775  054b							;    2 is =
    776  054b							;    1 is <
    777  054b							;    3 is <=
    778  054b							;    5 is <>
    779  054b							;    4 is >
    780  054b							;    6 is >=
    781  054b							;
    782  054b							; Those are bit-mapped:
    783  054b							;
    784  054b							;    xxxxxGEL
    785  054b							;
    786  054b							;    G = Greater than
    787  054b							;    E = Equal
    788  054b							;    L = Less than
    789  054b							;
    790  054b							; If the comparison is false, do a NXT, ie, move to the
    791  054b							; next line and continue.  If true, continue executing
    792  054b							; on this line.
    793  054b							;
    794  054b		       00 01	   REL_LT     equ	%001
    795  054b		       00 02	   REL_EQUAL  equ	%010
    796  054b		       00 04	   REL_GT     equ	%100
    797  054b							;
    798  054b		       20 dc 2c    iCMPR      jsr	popR1
    799  054e		       20 f3 2c 	      jsr	popMQ	;operator in MQ
    800  0551		       20 c4 2c 	      jsr	popR0
    801  0554		       20 5d 05 	      jsr	iCMPRsub
    802  0557		       20 32 2c 	      jsr	pushR0
    803  055a		       4c b1 02 	      jmp	NextIL
    804  055d							;
    805  055d							; See if they are equal or not
    806  055d							;
    807  055d				   iCMPRsub		; Called by internal functions
    808  055d
    809  055d		       a5 52		      lda	R0
    810  055f		       c5 54		      cmp	R1
    811  0561		       d0 0a		      bne	iCMPRnoteq	;try not equal
    812  0563		       a5 53		      lda	R0+1
    813  0565		       c5 55		      cmp	R1+1
    814  0567		       d0 04		      bne	iCMPRnoteq
    815  0569							;
    816  0569							; Equal, set the flag in MQ+1
    817  0569							;
    818  0569		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    819  056b		       d0 14		      bne	iCMPcom	;Exit it is equal
    820  056d							;
    821  056d							; See if EXPR1 (R0) < EXPR2 (R1)
    822  056d							; See www.6502.org/tutorials/compare_beyond.html
    823  056d							;
    824  056d				   iCMPRnoteq
    825  056d		       a5 52		      lda	R0
    826  056f		       c5 54		      cmp	R1	; Sets the carry flag
    827  0571		       a5 53		      lda	R0+1
    828  0573		       e5 55		      sbc	R1+1
    829  0575
    830  0575		       50 02		      bvc	iCMPR_2	; branch if N eor V
    831  0577		       49 80		      eor	#$80
    832  0579
    833  0579		       30 04	   iCMPR_2    bmi	iCMPlt
    834  057b		       a9 04		      lda	#REL_GT
    835  057d		       d0 02		      bne	iCMPcom
    836  057f
    837  057f		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    838  0581
    839  0581				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    840  0581							;
    841  0581							; Now compare the end result with what the caller
    842  0581							; was looking for.
    843  0581							;
    844  0581		       25 56		      and	MQ
    845  0583		       f0 0c		      beq	iCMPno	; no match
    846  0585		       a9 ff		      lda	#$FF	; true is $ffff
    847  0587		       85 52		      sta	R0
    848  0589		       85 53		      sta	R0+1
    849  058b		       d0 0a		      bne	iCMPDone
    850  058d							;
    851  058d							; R0 > R1
    852  058d							;
    853  058d		       a9 04	   iCMPgt     lda	#REL_GT
    854  058f		       d0 f0		      bne	iCMPcom
    855  0591				   iCMPno
    856  0591		       a9 00		      lda	#0
    857  0593		       85 52		      sta	R0
    858  0595		       85 53		      sta	R0+1
    859  0597
    860  0597				   iCMPDone
    861  0597		       60		      rts
    862  0598
    863  0598							;
    864  0598							; if Not a match, so jump to the next line of code.
    865  0598							; Branches based upon value on top of the stack
    866  0598				   iBranch
    867  0598		       20 c4 2c 	      jsr	popR0
    868  059b		       a5 52		      lda	R0
    869  059d		       05 53		      ora	R0+1
    870  059f		       f0 03		      beq	iBranchFalse	; not true
    871  05a1		       4c b1 02 	      jmp	NextIL	; It is true if any value not zero
    872  05a4							;
    873  05a4				   iBranchFalse
    874  05a4		       20 c3 2a 	      jsr	FindNextLine
    875  05a7		       4c ed 04 	      jmp	iXFER2
    876  05aa							;
    877  05aa							;=====================================================
    878  05aa							; Start a read of data in background
    879  05aa				   iReadStart
    880  05aa		       a9 3f		      lda	#'?	; Prompt with question mark
    881  05ac		       a6 01		      ldx	1	; Indicate to start read in background
    882  05ae		       20 4f 2b 	      jsr	GetLine	; Call the getline to start read
    883  05b1		       4c b1 02 	      jmp	NextIL	; next instruction
    884  05b4							;
    885  05b4							;=====================================================
    886  05b4							; Complete the read and return the curptr, curoff pointing to data
    887  05b4				   iReadComplete
    888  05b4		       a9 01		      lda	#GOSUB_RTN
    889  05b6		       20 4c 2c 	      jsr	pushLN
    890  05b9		       90 03		      bcc	iReadOk
    891  05bb		       4c 3a 0c    iReadErr   jmp	ErrStkOver	; Check if there was an error
    892  05be				   iReadOk
    893  05be		       20 6f 2b 	      jsr	ReadComplete
    894  05c1		       4c b1 02 	      jmp	NextIL
    895  05c4		       20 75 2c 	      jsr	popLN
    896  05c7		       4c b1 02 	      jmp	NextIL
    897  05ca							;=====================================================
    898  05ca							; Get a line of text from the user, convert to a
    899  05ca							; number, leave on top of stack.
    900  05ca							;
    901  05ca				   iINNUM
    902  05ca		       a9 01		      lda	#GOSUB_RTN
    903  05cc		       20 4c 2c 	      jsr	pushLN
    904  05cf		       b0 ea		      bcs	iReadErr	; Stack over flow error
    905  05d1							;
    906  05d1		       a9 3f		      lda	#'?
    907  05d3		       a2 00		      ldx	#0	;Wait for complete
    908  05d5		       20 4f 2b 	      jsr	GetLine
    909  05d8		       20 e4 2a 	      jsr	getDecimal
    910  05db		       20 32 2c 	      jsr	pushR0	;put onto stack
    911  05de		       b0 db		      bcs	iReadErr	;StackOverflow error
    912  05e0							;
    913  05e0		       4c fc 05 	      jmp	ExitIn
    914  05e3							;
    915  05e3							;=====================================================
    916  05e3							; Get a line of text from the user, convert to a
    917  05e3							; character value , leave on top of stack. up to 2 characters
    918  05e3							;
    919  05e3				   iINSTR
    920  05e3		       a9 01		      lda	#GOSUB_RTN
    921  05e5		       20 4c 2c 	      jsr	pushLN
    922  05e8		       b0 d1		      bcs	iReadErr	; Stack overflow error
    923  05ea		       a9 3f		      lda	#'?
    924  05ec		       a2 00		      ldx	#0	;wait for read complete
    925  05ee		       20 4f 2b 	      jsr	GetLine
    926  05f1		       b1 4f		      lda	(CURPTR),y
    927  05f3		       85 52		      sta	R0
    928  05f5		       a9 00		      lda	#0
    929  05f7		       85 53		      sta	R0+1
    930  05f9		       20 32 2c 	      jsr	pushR0	;put onto stack
    931  05fc				   ExitIn
    932  05fc		       20 75 2c 	      jsr	popLN
    933  05ff		       4c b1 02 	      jmp	NextIL
    934  0602							;
    935  0602							;
    936  0602							;=====================================================
    937  0602							; Stop the currently running program.	Actually very
    938  0602							; simple to do... clear the RunMode flag, then set the
    939  0602							; ILPC to the standard handler and continue running.
    940  0602							;
    941  0602		       a9 00	   iFIN       lda	#0
    942  0604		       85 5b		      sta	RunMode
    943  0606		       20 78 26 	      jsr	taskReset
    944  0609							;
    945  0609		       ad 24 43 	      lda	errGoto
    946  060c		       85 43		      sta	ILPC
    947  060e		       ad 25 43 	      lda	errGoto+1
    948  0611		       85 44		      sta	ILPC+1
    949  0613		       4c b1 02 	      jmp	NextIL
    950  0616							;
    951  0616							;=====================================================
    952  0616							; Handle the ERR opcode.  Following the instruction is
    953  0616							; a 16 bit error number.  Print an error message, and
    954  0616							; if we're in run mode, print the line number.  Stop
    955  0616							; program execution and return to the initial state.
    956  0616							;
    957  0616		       ad 31 43    iERR       lda	taskIOPending
    958  0619		       f0 03		      beq	iErrNext
    959  061b		       ce 31 43 	      dec	taskIOPending
    960  061e
    961  061e		       20 35 2a    iErrNext   jsr	getILWord	;get err code
    962  0621		       20 27 06 	      jsr	DisplayError
    963  0624		       4c 80 06 	      jmp	iErrComplete
    964  0627							;
    965  0627							; Enter here with the error code in X (LSB) and A (MSB).
    966  0627							;
    967  0627				   DisplayError
    968  0627		       86 52		      stx	R0
    969  0629		       85 53		      sta	R0+1
    970  062b							;
    971  062b		       20 bb 21 	      jsr	puts
      0  062e					      db	CR,LF,"Error ",0
      1  062e		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    973  0637		       20 ea 20 	      jsr	PrintDecimal
    974  063a							;
    975  063a		       a5 5b		      lda	RunMode	;running?
    976  063c		       f0 3b		      beq	iERR3	;nope
    977  063e		       20 bb 21 	      jsr	puts
      0  0641					      db	" at line ",0
      1  0641		       20 61 74 20*	      .byte.b	" at line ",0
    979  064b		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    980  064d				   iErr2a
    981  064d		       b1 4f		      lda	(CURPTR),y
    982  064f		       85 52		      sta	R0
    983  0651		       c8		      iny
    984  0652		       b1 4f		      lda	(CURPTR),y
    985  0654		       85 53		      sta	R0+1
    986  0656		       20 ea 20 	      jsr	PrintDecimal
    987  0659		       20 bb 21 	      jsr	puts
      0  065c					      db	":",0
      1  065c		       3a 00		      .byte.b	":",0
    989  065e		       a9 00		      lda	#0
    990  0660		       85 53		      sta	R0+1
    991  0662		       a5 51		      lda	CUROFF
    992  0664		       18		      clc
    993  0665		       e9 03		      sbc	#3
    994  0667		       85 52		      sta	R0
    995  0669		       20 ea 20 	      jsr	PrintDecimal
    996  066c		       20 bb 21 	      jsr	puts
      0  066f					      db	":",0
      1  066f		       3a 00		      .byte.b	":",0
    998  0671		       ad be 36 	      lda	taskPtr
    999  0674		       85 52		      sta	R0
   1000  0676		       20 9e 21 	      jsr	HexToOut
   1001  0679							;
   1002  0679				   iERR3
   1003  0679		       20 7d 2d 	      jsr	CRLF
   1004  067c		       60		      rts
   1005  067d
   1006  067d				   iErr2
   1007  067d		       20 27 06 	      jsr	DisplayError
   1008  0680
   1009  0680				   iErrComplete
   1010  0680		       20 70 26 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1011  0683		       a9 00		      lda	#0
   1012  0685		       85 5b		      sta	RunMode	; fall through...
   1013  0687							;
   1014  0687							;=====================================================
   1015  0687							; Reset the IL to be back at the idle loop.  Does not
   1016  0687							; clear variables so the user can see what state
   1017  0687							; the program is in.
   1018  0687							;
   1019  0687		       a9 00	   ResetIL    lda	#0
   1020  0689		       85 4f		      sta	CURPTR
   1021  068b		       85 51		      sta	CUROFF
   1022  068d		       85 47		      sta	ILSTACKPTR
   1023  068f		       ad 24 43 	      lda	errGoto
   1024  0692		       85 43		      sta	ILPC
   1025  0694		       ad 25 43 	      lda	errGoto+1
   1026  0697		       85 44		      sta	ILPC+1
   1027  0699		       a2 ff		      ldx	#$FF	; make sure the stack pointer is reset
   1028  069b		       9a		      txs
   1029  069c		       4c b1 02 	      jmp	NextIL
   1030  069f
   1031  069f							;
   1032  069f							;=====================================================
   1033  069f							; Pop two items off stack, add them, then place the
   1034  069f							; result back onto the stack.
   1035  069f							;
   1036  069f		       20 c4 2c    iADD       jsr	popR0
   1037  06a2		       20 dc 2c 	      jsr	popR1
   1038  06a5				   iADDfast
   1039  06a5		       18		      clc
   1040  06a6		       a5 52		      lda	R0
   1041  06a8		       65 54		      adc	R1
   1042  06aa		       85 52		      sta	R0
   1043  06ac		       a5 53		      lda	R0+1
   1044  06ae		       65 55		      adc	R1+1
   1045  06b0		       85 53		      sta	R0+1
   1046  06b2		       4c 1d 07 	      jmp	pushR0nextIl
   1047  06b5							;
   1048  06b5							;=====================================================
   1049  06b5							; Pop two items off the stack.  Subtract the top of
   1050  06b5							; stack from the lower entry.
   1051  06b5							;
   1052  06b5		       20 dc 2c    iSUB       jsr	popR1
   1053  06b8		       20 c4 2c 	      jsr	popR0
   1054  06bb		       38		      sec
   1055  06bc		       a5 52		      lda	R0
   1056  06be		       e5 54		      sbc	R1
   1057  06c0		       85 52		      sta	R0
   1058  06c2		       a5 53		      lda	R0+1
   1059  06c4		       e5 55		      sbc	R1+1
   1060  06c6		       85 53		      sta	R0+1
   1061  06c8		       4c 1d 07 	      jmp	pushR0nextIl
   1062  06cb							;
   1063  06cb							;=====================================================
   1064  06cb							; Negate the top of stack.
   1065  06cb							;
   1066  06cb		       20 c4 2c    iNEG       jsr	popR0
   1067  06ce		       a5 52		      lda	R0
   1068  06d0		       49 ff		      eor	#$ff
   1069  06d2		       85 52		      sta	R0
   1070  06d4		       a5 53		      lda	R0+1
   1071  06d6		       49 ff		      eor	#$ff
   1072  06d8		       85 53		      sta	R0+1
   1073  06da		       e6 52		      inc	R0
   1074  06dc		       d0 02		      bne	iNEG2
   1075  06de		       e6 53		      inc	R0+1
   1076  06e0		       4c 1d 07    iNEG2      jmp	pushR0nextIl
   1077  06e3							;
   1078  06e3							;=====================================================
   1079  06e3							; Multiply top two items on the stack, put the results
   1080  06e3							; on top.  This uses the algorithm documented on page
   1081  06e3							; 115 of "Microprocessor Programming for Computer
   1082  06e3							; Hobbyists" by Neill Graham.
   1083  06e3							;
   1084  06e3		       20 e9 06    iMUL       jsr	iMultiply
   1085  06e6		       4c b1 02 	      jmp	NextIL
   1086  06e9
   1087  06e9				   iMultiply
   1088  06e9		       20 c4 2c 	      jsr	popR0	;AC
   1089  06ec		       20 dc 2c 	      jsr	popR1	;OP
   1090  06ef							;
   1091  06ef		       a5 52		      lda	R0
   1092  06f1		       85 56		      sta	MQ
   1093  06f3		       a5 53		      lda	R0+1
   1094  06f5		       85 57		      sta	MQ+1
   1095  06f7		       a9 00		      lda	#0	;clear result
   1096  06f9		       85 52		      sta	R0
   1097  06fb		       85 53		      sta	R0+1
   1098  06fd							;
   1099  06fd		       a2 10		      ldx	#16	;number of bits in value
   1100  06ff		       06 52	   multloop   asl	R0
   1101  0701		       26 53		      rol	R0+1
   1102  0703		       06 56		      asl	MQ
   1103  0705		       26 57		      rol	MQ+1
   1104  0707		       90 0d		      bcc	multno	;skip add if no carry
   1105  0709							;
   1106  0709							; Add R1 back into R0
   1107  0709							;
   1108  0709		       18		      clc
   1109  070a		       a5 52		      lda	R0
   1110  070c		       65 54		      adc	R1
   1111  070e		       85 52		      sta	R0
   1112  0710		       a5 53		      lda	R0+1
   1113  0712		       65 55		      adc	R1+1
   1114  0714		       85 53		      sta	R0+1
   1115  0716							;
   1116  0716		       ca	   multno     dex		;did all bits yet?
   1117  0717		       d0 e6		      bne	multloop
   1118  0719		       20 32 2c 	      jsr	pushR0	;OP
   1119  071c		       60		      rts
   1120  071d							;
   1121  071d				   pushR0nextIl
   1122  071d		       20 32 2c 	      jsr	pushR0	;OP
   1123  0720		       4c b1 02 	      jmp	NextIL
   1124  0723							;
   1125  0723							;=====================================================
   1126  0723							; Divide the top of stack into the next to top item.
   1127  0723							; Leave results on stack.  Taken from:
   1128  0723							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1129  0723							;
   1130  0723							; R0 = R0 / R1
   1131  0723							; Remainder is in MQ
   1132  0723							;
   1133  0723		       20 3d 07    iDIV       jsr	iDoDiv
   1134  0726		       20 45 2d 	      jsr	RestoreSigns
   1135  0729		       4c 1d 07 	      jmp	pushR0nextIl
   1136  072c
   1137  072c		       20 3d 07    iMOD       jsr	iDoDiv
   1138  072f		       20 45 2d 	      jsr	RestoreSigns
   1139  0732		       a5 56		      lda	MQ
   1140  0734		       85 52		      sta	R0
   1141  0736		       a5 57		      lda	MQ+1
   1142  0738		       85 53		      sta	R0+1
   1143  073a		       4c 1d 07 	      jmp	pushR0nextIl
   1144  073d
   1145  073d				   iDoDiv
   1146  073d		       20 dc 2c 	      jsr	popR1
   1147  0740		       20 c4 2c 	      jsr	popR0
   1148  0743							;
   1149  0743							; Check for divide by zero
   1150  0743							;
   1151  0743
   1152  0743				   iDivNoPop
   1153  0743		       a5 54		      lda	R1
   1154  0745		       05 55		      ora	R1+1
   1155  0747		       f0 29		      beq	divby0
   1156  0749							;
   1157  0749		       20 0a 2d 	      jsr	SaveSigns
   1158  074c		       a9 00		      lda	#0	;preset remainder to 0
   1159  074e		       85 56		      sta	MQ
   1160  0750		       85 57		      sta	MQ+1
   1161  0752		       a2 10		      ldx	#16	;repeat for each bit: ...
   1162  0754				   divloop
   1163  0754		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1164  0756		       26 53		      rol	R0+1
   1165  0758		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1166  075a		       26 57		      rol	MQ+1
   1167  075c		       a5 56		      lda	MQ
   1168  075e		       38		      sec
   1169  075f		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1170  0761		       a8		      tay		;lb result -> Y, for we may need it later
   1171  0762		       a5 57		      lda	MQ+1
   1172  0764		       e5 55		      sbc	R1+1
   1173  0766		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1174  0768
   1175  0768		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1176  076a		       84 56		      sty	MQ
   1177  076c		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1178  076e
   1179  076e		       ca	   skip       dex
   1180  076f		       d0 e3		      bne	divloop
   1181  0771		       60		      rts
   1182  0772							;
   1183  0772							; Indicate divide-by-zero error
   1184  0772							;
   1185  0772		       68	   divby0     pla		; remove the reyurn from the stack
   1186  0773		       68		      pla
   1187  0774		       a2 06		      ldx	#ERR_DIVIDE_ZERO	; do the error
   1188  0776		       a9 00		      lda	#0
   1189  0778		       4c 7d 06 	      jmp	iErr2
   1190  077b							;
   1191  077b							;=====================================================
   1192  077b							; This pops the top two items off the stack.  The top
   1193  077b							; item is a data value and the other is an ABSOLUTE address.
   1194  077b							; Save the value into that address.
   1195  077b							;
   1196  077b		       98	   iSTORE     tya
   1197  077c		       48		      pha
   1198  077d		       20 c4 2c 	      jsr	popR0	;data
   1199  0780		       20 dc 2c 	      jsr	popR1	;Storage location
   1200  0783		       a0 01		      ldy	#1
   1201  0785		       a5 58		      lda	R2
   1202  0787		       c9 a2		      cmp	#tByte
   1203  0789		       f0 04		      beq	iStoreB
   1204  078b				   iStoreW
   1205  078b		       a5 53		      lda	R0+1
   1206  078d		       91 54		      sta	(R1),y
   1207  078f				   iStoreB
   1208  078f		       a5 52		      lda	R0
   1209  0791		       88		      dey
   1210  0792		       91 54		      sta	(R1),y
   1211  0794		       68		      pla
   1212  0795		       a8		      tay
   1213  0796		       4c b1 02 	      jmp	NextIL
   1214  0799							;
   1215  0799							;=====================================================
   1216  0799							; Replaces the top of stack with the Value
   1217  0799							; of the variable  whose absolute address it represents.
   1218  0799							;
   1219  0799
   1220  0799		       98	   iIND       tya
   1221  079a		       48		      pha
   1222  079b		       20 dc 2c 	      jsr	popR1
   1223  079e		       a0 01		      ldy	#1
   1224  07a0		       a5 58		      lda	R2
   1225  07a2		       c9 a4		      cmp	#tInteger
   1226  07a4		       f0 04		      beq	iINDW
   1227  07a6				   iINDB
   1228  07a6		       a9 00		      lda	#0
   1229  07a8		       f0 02		      BEQ	iINDC
   1230  07aa				   iINDW
   1231  07aa		       b1 54		      lda	(R1),y
   1232  07ac				   iINDC
   1233  07ac		       85 53		      sta	R0+1
   1234  07ae		       88		      dey
   1235  07af		       b1 54		      lda	(R1),y
   1236  07b1		       85 52		      sta	R0
   1237  07b3		       68		      pla
   1238  07b4		       a8		      tay
   1239  07b5		       4c 1d 07 	      jmp	pushR0nextIl
   1240  07b8
   1241  07b8							;
   1242  07b8							;=====================================================
   1243  07b8							; Check which type of index to use byte or word and jmp to correct
   1244  07b8							; function
   1245  07b8		       98	   iArray     tya
   1246  07b9		       48		      pha
   1247  07ba
   1248  07ba		       20 c4 2c 	      jsr	popR0	; Get the array index
   1249  07bd		       20 dc 2c 	      jsr	popR1	; Get the Variable address
   1250  07c0
   1251  07c0		       20 39 2a 	      jsr	getILByte	; Get type of number to process
   1252  07c3		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Are we testing a valid parameter
   1253  07c5		       f0 52		      beq	iArrayFNparm	; process a fn pramater index
   1254  07c7
   1255  07c7		       29 fe		      and	#$FE	; Turn off the unsigned bit
   1256  07c9		       c9 a2		      cmp	#tByte	; Test for a byte index
   1257  07cb		       f0 10		      beq	iArrayB	; yes so branch to process a byte
   1258  07cd							;=====================================================
   1259  07cd							; Process 32 bit index into memory
   1260  07cd		       c9 a6	   iArrayL    cmp	#tLong	; Are we working with 32 bit integers
   1261  07cf		       d0 06		      bne	iArrayW	; Process with sigle shift
   1262  07d1		       06 52		      asl	R0	; Do the multiply by 2
   1263  07d3		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1264  07d5		       b0 39		      bcs	iArrayError	; if the carry is set we have an error
   1265  07d7							;=====================================================
   1266  07d7							; Get the array index from top of stack get Current variable
   1267  07d7							; address from next on stack, add the offset
   1268  07d7							; push the result back onto the stack
   1269  07d7				   iArrayW		; pointers, arrays etc all use 16 bit unsigned integers
   1270  07d7		       06 52		      asl	R0	; Do the multiply by 2
   1271  07d9		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1272  07db		       b0 33		      bcs	iArrayError	; if the carry is set we have an error
   1273  07dd
   1274  07dd							;=====================================================
   1275  07dd							; Get from Byte array not Integer array
   1276  07dd				   iArrayB
   1277  07dd		       18		      clc
   1278  07de		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1279  07e0		       65 52		      adc	R0
   1280  07e2		       85 52		      sta	R0
   1281  07e4		       a5 55		      lda	R1+1
   1282  07e6		       65 53		      adc	R0+1
   1283  07e8		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1284  07ea		       a5 55		      lda	R1+1
   1285  07ec		       cd 3a 43 	      cmp	ProgramEnd+1	; lets check if we are processing an @ buffer pointer to free memory
   1286  07ef		       d0 08		      bne	iArrayCheckVar
   1287  07f1				   iArrayExit
   1288  07f1		       20 32 2c 	      jsr	pushR0	; Push R0 assume it is correct
   1289  07f4
   1290  07f4		       68		      pla
   1291  07f5		       a8		      tay
   1292  07f6		       4c b1 02 	      jmp	NextIL
   1293  07f9							; Check for valis variable and valid index to use
   1294  07f9		       a5 41	   iArrayCheckVar lda	VARIABLES
   1295  07fb		       18		      clc
   1296  07fc		       69 33		      adc	#[25*2]+1	; the number of actual variable valid bytes
   1297  07fe		       85 56		      sta	MQ	; mq contains the last valid byte we can use
   1298  0800		       a9 00		      lda	#0
   1299  0802		       65 42		      adc	VARIABLES+1	; Memory past last word R0+1 > A then invalid
   1300  0804		       c5 53		      cmp	R0+1
   1301  0806		       90 08		      bcc	iArrayError
   1302  0808		       a5 52		      lda	R0	; a > m invalid past last byte of variable area
   1303  080a		       c5 56		      cmp	MQ
   1304  080c		       f0 e3		      beq	iArrayExit	; If it is equal then it is valid
   1305  080e		       90 e1		      bcc	iArrayExit	; if it is less it is valid
   1306  0810
   1307  0810							; Get here if array index is out of range
   1308  0810		       68	   iArrayError pla
   1309  0811		       98		      tya
   1310  0812		       a9 00		      lda	#0
   1311  0814		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1312  0816		       4c 7d 06 	      jmp	iErr2
   1313  0819							;=====================================================
   1314  0819							; Verify function paramater index is valid
   1315  0819		       20 c6 25    iArrayFNparm jsr	GosubFindParms	; Get a pointer to the current functions parameter list info
   1316  081c		       90 f2		      bcc	iArrayError	; There are no paramters for this call, should never be true
   1317  081e		       88		      dey
   1318  081f		       88		      dey		; Points to parameter count
   1319  0820		       a5 52		      lda	R0	; get parm to be accessed
   1320  0822		       d1 4b		      cmp	(GOSUBSTACK),y	; compare to max number allowed
   1321  0824		       b0 ea		      bcs	iArrayError	; the parameter index should be less than the count
   1322  0826		       06 52		      asl	R0	; Do the multiply by 2
   1323  0828		       26 53		      rol	R0+1
   1324  082a
   1325  082a		       18		      clc
   1326  082b		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1327  082d		       65 52		      adc	R0
   1328  082f		       85 52		      sta	R0
   1329  0831		       a5 55		      lda	R1+1
   1330  0833		       65 53		      adc	R0+1
   1331  0835		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1332  0837		       4c f1 07 	      jmp	iArrayExit	; Get ot we are done
   1333  083a							;
   1334  083a							;=====================================================
   1335  083a							; List the current BASIC program in memory.  Uses R0,
   1336  083a							; tempIly, and dpl.
   1337  083a							;
   1338  083a		       20 c4 2e    iLST       jsr	SetOutConsole
   1339  083d		       ad 37 43    iLST2      lda	ProgramStart
   1340  0840		       85 59		      sta	dpl
   1341  0842		       ad 38 43 	      lda	ProgramStart+1
   1342  0845		       85 5a		      sta	dpl+1
   1343  0847							;
   1344  0847							; dpl/dph point to the current line.  See if we're at
   1345  0847							; the end of the program.
   1346  0847							;
   1347  0847		       a5 59	   iLSTloop   lda	dpl
   1348  0849		       cd 39 43 	      cmp	ProgramEnd
   1349  084c		       d0 07		      bne	iLstNotEnd
   1350  084e		       a5 5a		      lda	dpl+1
   1351  0850		       cd 3a 43 	      cmp	ProgramEnd+1
   1352  0853		       f0 15		      beq	iLstdone
   1353  0855							;
   1354  0855		       20 53 22    iLstNotEnd jsr	PrintProgramLine
   1355  0858							;		  ldy	  #1		  ;Change:  Skip first byte length
   1356  0858							;		  lda	  (dpl),y	  ;line number LSB
   1357  0858							;		  sta	  R0
   1358  0858							;		  iny
   1359  0858							;		  lda	  (dpl),y		 ;line number MSB
   1360  0858							;		  sta	  R0+1
   1361  0858							;		  iny
   1362  0858							;		  sty	  tempIlY
   1363  0858							;		  jsr	  PrintDecimal
   1364  0858							;		  lda	  #SPACE
   1365  0858							;		  jsr	  VOUTCH
   1366  0858							;		  ldy	  tempIlY
   1367  0858							;iLSTl2	  lda	  (dpl),y
   1368  0858							;		  beq	  iLST3 	  ;end of this line 0 value
   1369  0858							;		  sty	  tempIlY
   1370  0858							;		  jsr	  VOUTCH
   1371  0858							;		  ldy	  tempIlY
   1372  0858							;		  iny
   1373  0858							;		  bne	  iLSTl2	  ;do next char
   1374  0858							;
   1375  0858							; End of this line.  Print CR/LF, then move to the
   1376  0858							; next line.
   1377  0858							;
   1378  0858		       a0 00	   iLST3      ldy	#0	;Move to next line
   1379  085a		       b1 59		      lda	(dpl),y	;Current line length
   1380  085c		       18		      clc		;Clear the carry flag
   1381  085d							;		  tya
   1382  085d		       65 59		      adc	dpl	;Add the offset to the pointer
   1383  085f		       85 59		      sta	dpl	;Save the new value
   1384  0861		       a5 5a		      lda	dpl+1	;Next byte
   1385  0863		       69 00		      adc	#0	;ad in the carry if any
   1386  0865		       85 5a		      sta	dpl+1	;Save it
   1387  0867							;
   1388  0867							; Have to manually do CR/LF so it uses the vectored
   1389  0867							; output function.
   1390  0867							;
   1391  0867							;		  lda	  #CR
   1392  0867							;		  jsr	  VOUTCH
   1393  0867							;		  lda	  #LF
   1394  0867							;		  jsr	  VOUTCH
   1395  0867		       4c 47 08 	      jmp	iLSTloop	;do next line
   1396  086a							;
   1397  086a		       20 c4 2e    iLstdone   jsr	SetOutConsole
   1398  086d		       4c b1 02 	      jmp	NextIL
   1399  0870							;
   1400  0870							;=====================================================
   1401  0870							; Get a line of text into LINBUF.  Terminate with a
   1402  0870							; null byte.
   1403  0870							;
   1404  0870				   iGETLINE
   1405  0870		       a9 3e		      lda	#'>	;prompt character
   1406  0872		       a6 00		      ldx	0	;Wait for read to complete
   1407  0874		       20 4f 2b 	      jsr	GetLine
   1408  0877							;
   1409  0877		       a9 00		      lda	#0
   1410  0879		       85 5b		      sta	RunMode
   1411  087b				   iGetParseLine
   1412  087b							; lda	   CUROFF
   1413  087b							; pha
   1414  087b		       20 5e 1d 	      jsr	ParseInputLine
   1415  087e							; pla
   1416  087e							;  sta     CUROFF
   1417  087e		       a9 5b		      lda	#TOKENBUFFER&$FF
   1418  0880		       85 4f		      sta	CURPTR
   1419  0882		       a9 1c		      lda	#TOKENBUFFER>>8
   1420  0884		       85 50		      sta	CURPTR+1
   1421  0886		       a9 01		      lda	#1
   1422  0888		       85 51		      sta	CUROFF
   1423  088a		       4c b1 02 	      jmp	NextIL
   1424  088d							;
   1425  088d							;=====================================================
   1426  088d							; This is called when the input buffer contains a line
   1427  088d							; typed in by the user that starts with a line number.
   1428  088d							; Insert the line into the program or delete the line
   1429  088d							; if there is nothing after the line number,
   1430  088d							;
   1431  088d				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1432  088d		       ad 5c 1c 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1433  0890		       85 52		      sta	R0	; place the number into R0
   1434  0892		       ad 5d 1c 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1435  0895		       85 53		      STA	R0+1	; Place it into
   1436  0897							;
   1437  0897							; Now find the line OR the next higher line OR the
   1438  0897							; end of the program.
   1439  0897							;
   1440  0897		       20 7e 2a 	      jsr	findLine	; Look for the line number in the current program
   1441  089a							; Returns Z and curptr point to the line if found
   1442  089a							; Returns C and curptr at next higher line if not found and there is a higher line
   1443  089a							; Returns ZC clear and curptr to end of program if higher than all other lines
   1444  089a							;
   1445  089a							; If the line exists, it needs to be removed.
   1446  089a							;
   1447  089a		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1448  089c							;
   1449  089c							; Get length of line to be removed, we fall thru to here if we find a matching line
   1450  089c							;
   1451  089c							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1452  089c		       a0 00		      ldy	#0
   1453  089e		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1454  08a0		       a8		      tay
   1455  08a1							;If it is equal we delete the line and replace it, get length
   1456  08a1							;then adjust all program line after up or down depending on len of line
   1457  08a1							;If next higher then just move everythimg down by length bytes
   1458  08a1							;This call will return how many bytes in the line we found
   1459  08a1		       8c 30 43 	      sty	lineLength	;Save the length of the line we found
   1460  08a4							;
   1461  08a4							; Compute the new end of the program first.
   1462  08a4							;
   1463  08a4		       38		      sec		;Set the carry bit
   1464  08a5		       ad 39 43 	      lda	ProgramEnd	;Get low byte of program end
   1465  08a8		       ed 30 43 	      sbc	lineLength	;Subtract the length of the current line
   1466  08ab		       8d 39 43 	      sta	ProgramEnd	;save it
   1467  08ae		       ad 3a 43 	      lda	ProgramEnd+1
   1468  08b1		       e9 00		      sbc	#0	;Process the carry
   1469  08b3		       8d 3a 43 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1470  08b6							;
   1471  08b6							; Copy CURPTR into R1 for working
   1472  08b6							;
   1473  08b6		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1474  08b8		       85 54		      sta	R1
   1475  08ba		       a5 50		      lda	CURPTR+1
   1476  08bc		       85 55		      sta	R1+1
   1477  08be							;
   1478  08be							; See if we're at the end.
   1479  08be							;
   1480  08be		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1481  08c0		       cd 39 43 	      cmp	ProgramEnd
   1482  08c3		       d0 07		      bne	InsDelLoop
   1483  08c5		       a5 55		      lda	R1+1
   1484  08c7		       cd 3a 43 	      cmp	ProgramEnd+1
   1485  08ca		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1486  08cc							;
   1487  08cc							; Move one byte, move to next location.
   1488  08cc							;
   1489  08cc		       ac 30 43    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1490  08cf		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1491  08d1		       b1 54		      lda	(R1),y
   1492  08d3		       a0 00		      ldy	#0
   1493  08d5		       91 54		      sta	(R1),y
   1494  08d7		       e6 54		      inc	R1
   1495  08d9		       d0 e3		      bne	InsDelChk
   1496  08db		       e6 55		      inc	R1+1
   1497  08dd		       4c be 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1498  08e0							;
   1499  08e0							; Deletion is done.
   1500  08e0							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1501  08e0							;
   1502  08e0				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1503  08e0		       ad 5b 1c 	      lda	TOKENBUFFER	; Get the length
   1504  08e3		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1505  08e5							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1506  08e5		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1507  08e7							;
   1508  08e7							; CURPTR points to where the line will be inserted.
   1509  08e7							;
   1510  08e7							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1511  08e7		       ae 5b 1c 	      ldx	TOKENBUFFER
   1512  08ea		       8e 30 43 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1513  08ed							;
   1514  08ed		       ad 39 43 	      lda	ProgramEnd	;Load the start address for the copy
   1515  08f0							;At this point curptr still contains the location we will insert data
   1516  08f0		       85 5c		      sta	FROM
   1517  08f2		       ad 3a 43 	      lda	ProgramEnd+1
   1518  08f5		       85 5d		      sta	FROM+1
   1519  08f7							;
   1520  08f7		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1521  08f9		       b1 5c		      lda	(FROM),y
   1522  08fb		       ac 30 43 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1523  08fe		       91 5c		      sta	(FROM),y	;Save the new byte
   1524  0900							;
   1525  0900		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1526  0902		       c5 4f		      cmp	CURPTR
   1527  0904		       d0 06		      bne	mvUpMore
   1528  0906		       a5 5d		      lda	FROM+1
   1529  0908		       c5 50		      cmp	CURPTR+1
   1530  090a		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1531  090c							;
   1532  090c							; Not done yet
   1533  090c							;
   1534  090c		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1535  090e		       d0 02		      bne	mvUpMore2
   1536  0910		       c6 5d		      dec	FROM+1
   1537  0912		       c6 5c	   mvUpMore2  dec	FROM
   1538  0914		       4c f7 08 	      jmp	mvup1	;Loop until everything is moved
   1539  0917							;
   1540  0917							; All done with copy.
   1541  0917							;
   1542  0917				   mvUpDone
   1543  0917		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1544  0918		       ad 30 43 	      lda	lineLength	;Number of bytes to copy from line buff
   1545  091b		       6d 39 43 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1546  091e		       8d 39 43 	      sta	ProgramEnd
   1547  0921		       ad 3a 43 	      lda	ProgramEnd+1
   1548  0924		       69 00		      adc	#0
   1549  0926		       8d 3a 43 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1550  0929							;
   1551  0929							;===================jlit use length before line newline
   1552  0929
   1553  0929		       a0 00		      ldy	#0	;Set offset of copy
   1554  092b							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1555  092b							;		  sta	  (CURPTR),y	  ;Store the length
   1556  092b							;		  iny
   1557  092b							;		  lda	  R0		  ;Store the line number next
   1558  092b							;		  sta	  (CURPTR),y
   1559  092b							;		  iny
   1560  092b							;		  lda	  R0+1
   1561  092b							;		  sta	  (CURPTR),y
   1562  092b							;		  iny
   1563  092b							;
   1564  092b							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1565  092b		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1566  092d				   mvUpLoop2
   1567  092d							;		  lda	  LINBUF,x	 ;get a byte
   1568  092d		       bd 5b 1c 	      lda	TOKENBUFFER,x	;get a byte
   1569  0930		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1570  0932
   1571  0932		       e8		      inx
   1572  0933		       ec 5b 1c 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1573  0936		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1574  0938		       c8		      iny
   1575  0939		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1576  093b							;
   1577  093b		       4c b1 02    mvUpFini   jmp	NextIL
   1578  093e							;
   1579  093e							;=====================================================
   1580  093e							; Pops the top value of the ILPC stack and stores it
   1581  093e							; in ILPC.  Ie, return from an IL subroutine.
   1582  093e							;
   1583  093e		       20 6c 2a    iRTN       jsr	popILPC
   1584  0941		       4c b1 02 	      jmp	NextIL
   1585  0944							;
   1586  0944							;=====================================================
   1587  0944							; NLINE print a newline
   1588  0944							;
   1589  0944		       20 7d 2d    iNLINE     jsr	CRLF	;user supplied sub
   1590  0947		       4c b1 02 	      jmp	NextIL
   1591  094a							;
   1592  094a							;=====================================================
   1593  094a							; This saves the current ILPC value on the stack, then
   1594  094a							; jumps to the address specified by the next two bytes.
   1595  094a							;
   1596  094a		       20 4f 2a    iCALL      jsr	pushILPC	;save ILPC
   1597  094d		       90 07		      bcc	iJMP
   1598  094f
   1599  094f							;If the push failed not enough stack space
   1600  094f		       a2 15	   ErrILStkOver ldx	#ERR_IL_STACK_OVER_FLOW	; Flag any error in line number
   1601  0951		       a9 00		      lda	#0	; stop the execution
   1602  0953		       4c 7d 06 	      jmp	iErr2
   1603  0956							;
   1604  0956							; Jmp to a specific location in the IL code.  The new
   1605  0956							; address immediately follows the opcode.
   1606  0956							;
   1607  0956		       20 35 2a    iJMP       jsr	getILWord
   1608  0959		       86 43		      stx	ILPC
   1609  095b		       85 44		      sta	ILPC+1
   1610  095d		       4c b1 02 	      jmp	NextIL
   1611  0960
   1612  0960
   1613  0960							;
   1614  0960							;=====================================================
   1615  0960							; Push the next two bytes onto the arithmetic stack.
   1616  0960							;
   1617  0960		       20 39 2a    iSetR2     jsr	getILByte
   1618  0963		       85 58		      sta	R2
   1619  0965		       4c b1 02 	      jmp	NextIL
   1620  0968							;
   1621  0968							;=====================================================
   1622  0968							; Push the next two bytes onto the arithmetic stack.
   1623  0968							;
   1624  0968		       20 35 2a    iLIT       jsr	getILWord
   1625  096b		       86 52		      stx	R0
   1626  096d		       85 53		      sta	R0+1
   1627  096f		       20 32 2c 	      jsr	pushR0
   1628  0972		       4c b1 02 	      jmp	NextIL
   1629  0975							;
   1630  0975							;=====================================================
   1631  0975							; Initialize all variables for a single task.	Ie, set to zero.
   1632  0975							; And internal stack pointers
   1633  0975							;
   1634  0975		       98	   subVINIT   tya
   1635  0976		       48		      pha
   1636  0977
   1637  0977		       a9 00		      lda	#0
   1638  0979		       a0 00		      ldy	#0
   1639  097b		       91 41	   Vinit2     sta	(VARIABLES),y
   1640  097d		       c8		      iny
   1641  097e		       c0 48		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1642  0980		       90 f9		      bcc	Vinit2
   1643  0982		       85 4a		      sta	MATHSTACKPTR	; Clear the math stack
   1644  0984		       85 4d		      sta	GOSUBSTACKPTR	; Clear the gosub stack
   1645  0986		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reset the message queue
   1646  0988		       85 4e		      STA	MESSAGEPTR
   1647  098a
   1648  098a		       68		      pla
   1649  098b		       a8		      tay
   1650  098c		       60		      rts
   1651  098d
   1652  098d				   iVINIT
   1653  098d		       20 75 09 	      jsr	subVINIT
   1654  0990		       20 f5 1f 	      jsr	Compile	; compile line numbers to memory pointers
   1655  0993		       4c b1 02 	      jmp	NextIL
   1656  0996							;
   1657  0996							;=====================================================
   1658  0996							; Set the address of the error handler.  After any
   1659  0996							; error, set to the ILPC to the specified location.
   1660  0996							;
   1661  0996		       20 35 2a    iERRGOTO   jsr	getILWord
   1662  0999		       8e 24 43 	      stx	errGoto
   1663  099c		       8d 25 43 	      sta	errGoto+1
   1664  099f		       4c b1 02 	      jmp	NextIL
   1665  09a2							;
   1666  09a2							;=====================================================
   1667  09a2							; TST is followed by an 8 bit signed offset, then a
   1668  09a2							; null terminated string.  Compare the string against
   1669  09a2							; the string starting at (CURPTR),CUROFF.  If the
   1670  09a2							; strings match, continue executing the next IL
   1671  09a2							; opcode.  Else, add the offset to ILPC.
   1672  09a2							;
   1673  09a2		       20 39 2a    iTST       jsr	getILByte	;Get the relative jump address
   1674  09a5		       8d 2f 43 	      sta	offset	;save it to use if test faile
   1675  09a8		       20 1c 2c 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1676  09ab
   1677  09ab		       a4 51		      ldy	CUROFF
   1678  09ad		       84 59		      sty	dpl	;save for later
   1679  09af							;
   1680  09af		       20 39 2a    iTSTloop   jsr	getILByte	;get next char
   1681  09b2		       f0 11		      beq	iTSTm	;match!
   1682  09b4		       a4 59		      ldy	dpl
   1683  09b6		       d1 4f		      cmp	(CURPTR),y
   1684  09b8		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1685  09ba		       09 20		      ora	#$20	; lets allow lowercase as well
   1686  09bc		       d1 4f		      cmp	(CURPTR),y
   1687  09be		       d0 23		      bne	iTSTfail	;mismatch
   1688  09c0		       c8	   iTSTUpper  iny
   1689  09c1		       84 59		      sty	dpl
   1690  09c3		       d0 ea		      bne	iTSTloop
   1691  09c5							;
   1692  09c5							; It's a match!  Clean up a bit.
   1693  09c5							;
   1694  09c5		       a4 59	   iTSTm      ldy	dpl
   1695  09c7		       84 51		      sty	CUROFF
   1696  09c9		       4c b1 02 	      jmp	NextIL
   1697  09cc
   1698  09cc							; Test for a single quote string
   1699  09cc		       20 39 2a    iTSTStr    jsr	getILByte
   1700  09cf		       8d 2f 43 	      sta	offset
   1701  09d2		       20 1c 2c 	      jsr	saveIL
   1702  09d5		       a4 51		      ldy	CUROFF
   1703  09d7		       a9 22		      lda	#'"
   1704  09d9		       d1 4f		      cmp	(CURPTR),y
   1705  09db		       d0 06		      bne	iTSTfail
   1706  09dd		       c8		      iny
   1707  09de		       84 51		      sty	CUROFF
   1708  09e0		       4c d4 02 	      jmp	NextILStr
   1709  09e3							;
   1710  09e3							; Not a match, reset ILPC and then move to the
   1711  09e3							; offset.
   1712  09e3							;
   1713  09e3		       20 27 2c    iTSTfail   jsr	restoreIL
   1714  09e6		       4c e0 0b 	      jmp	tstBranch
   1715  09e9							;
   1716  09e9							;=================================================JLIT=
   1717  09e9							; Test if we have a let statement without the let keyword
   1718  09e9		       20 39 2a    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1719  09ec		       8d 2f 43 	      sta	offset	; Save the jump offset for fails
   1720  09ef		       20 1c 2c 	      jsr	saveIL	; save to restore when done if fail
   1721  09f2
   1722  09f2		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1723  09f4		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1724  09f6		       c9 01		      cmp	#kLet	; Is it a let keyword
   1725  09f8		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1726  09fa		       c9 80		      cmp	#tVa	; lets check for a variable
   1727  09fc		       90 e5		      bcc	iTSTfail	; Less than variable range
   1728  09fe		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1729  0a00		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1730  0a02		       b0 df		      bcs	iTSTfail	; return it failed
   1731  0a04
   1732  0a04				   iTSTLETGOOD
   1733  0a04		       c8		      iny
   1734  0a05		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1735  0a07				   iTSTGOODVAR
   1736  0a07		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1737  0a0a
   1738  0a0a							;=================================================JLIT=
   1739  0a0a							; Test a byte at an indirect address
   1740  0a0a							; fails if byte is not equal to the value at the address
   1741  0a0a							; The tests an indirect byte and branches if true
   1742  0a0a		       20 39 2a    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1743  0a0d		       8d 2f 43 	      sta	offset	; Save the jump offset for fails
   1744  0a10		       20 1c 2c 	      jsr	saveIL	; save to restore when done if fail
   1745  0a13		       20 35 2a 	      jsr	getILWord	; Get a word into RO
   1746  0a16		       86 52		      stx	R0
   1747  0a18		       85 53		      sta	R0+1
   1748  0a1a		       20 39 2a 	      jsr	getILByte	; Get byte into A
   1749  0a1d		       a0 00		      ldy	#0
   1750  0a1f		       d1 52		      cmp	(R0),y
   1751  0a21		       d0 03		      bne	iTSTByteNotEqual
   1752  0a23		       4c e3 09 	      jmp	iTSTfail
   1753  0a26
   1754  0a26				   iTSTByteNotEqual
   1755  0a26		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1756  0a29
   1757  0a29							;=================================================JLIT=
   1758  0a29							; Test a byte	branch if it fails
   1759  0a29		       20 39 2a    iTSTB      jsr	getILByte	; Get the relative offset byte
   1760  0a2c		       8d 2f 43 	      sta	offset	; Save the jump offset for fails
   1761  0a2f		       20 1c 2c 	      jsr	saveIL	; save to restore when done if fail
   1762  0a32		       20 39 2a 	      jsr	getILByte	; Get a byte into Acc
   1763  0a35		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1764  0a37		       d1 4f		      cmp	(CURPTR),y
   1765  0a39		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1766  0a3b		       4c e3 09 	      jmp	iTSTfail	; REcover and move on to next test
   1767  0a3e
   1768  0a3e				   iTSTBMatch
   1769  0a3e		       c8		      iny
   1770  0a3f		       84 51		      sty	CUROFF	; Point to the next byte
   1771  0a41		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1772  0a44
   1773  0a44							;=================================================JLIT=
   1774  0a44							; Test a byte	branch if it fails
   1775  0a44		       20 39 2a    iTSTW      jsr	getILByte	; Get the relative offset byte
   1776  0a47		       8d 2f 43 	      sta	offset	; Save the jump offset for fails
   1777  0a4a		       20 1c 2c 	      jsr	saveIL	; save to restore when done if fail
   1778  0a4d		       20 35 2a 	      jsr	getILWord	; Get a word into RO
   1779  0a50		       86 52		      stx	R0
   1780  0a52		       85 53		      sta	R0+1
   1781  0a54		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1782  0a56		       8a		      txa
   1783  0a57		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1784  0a59		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1785  0a5b		       4c e3 09 	      jmp	iTSTfail	; REcover and move on to next test
   1786  0a5e		       c8	   iTSTWM1    iny
   1787  0a5f		       a5 53		      lda	R0+1
   1788  0a61		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1789  0a63		       f0 03		      beq	iTSTWMatch
   1790  0a65		       4c e3 09 	      jmp	iTSTfail
   1791  0a68
   1792  0a68				   iTSTWMatch
   1793  0a68		       c8		      iny
   1794  0a69		       84 51		      sty	CUROFF
   1795  0a6b		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1796  0a6e
   1797  0a6e							;================================================jLIT=
   1798  0a6e							;Test for end of line
   1799  0a6e							;
   1800  0a6e				   iTSTDONE
   1801  0a6e		       20 39 2a 	      jsr	getILByte
   1802  0a71		       8d 2f 43 	      sta	offset
   1803  0a74		       20 1c 2c 	      jsr	saveIL
   1804  0a77		       a4 51		      ldy	CUROFF
   1805  0a79		       84 59		      sty	dpl
   1806  0a7b		       b1 4f		      lda	(CURPTR),y
   1807  0a7d		       f0 0b		      beq	iTSTDONEtrue
   1808  0a7f		       c9 e6		      cmp	#oColon
   1809  0a81		       f0 07		      beq	iTSTDONEtrue
   1810  0a83		       a4 59		      ldy	dpl
   1811  0a85		       84 51		      sty	CUROFF
   1812  0a87		       4c e3 09 	      jmp	iTSTfail
   1813  0a8a							;
   1814  0a8a							; Advance to the next line
   1815  0a8a							;
   1816  0a8a				   iTSTDONEtrue
   1817  0a8a		       4c b1 02 	      jmp	NextIL
   1818  0a8d
   1819  0a8d		       4c e0 0b    tstBranchLink jmp	tstBranch
   1820  0a90							;
   1821  0a90							;=====================================================
   1822  0a90							; Inc and dec a variable , faster than a = a + 1
   1823  0a90				   iINCVAR
   1824  0a90		       20 c4 2c 	      jsr	popR0
   1825  0a93		       a0 00		      ldy	#0
   1826  0a95		       18		      clc
   1827  0a96		       a9 01		      lda	#1
   1828  0a98		       71 52		      adc	(R0),y
   1829  0a9a		       91 52		      sta	(R0),y
   1830  0a9c		       90 07		      bcc	iINCDONE
   1831  0a9e		       c8		      iny
   1832  0a9f		       a9 00		      lda	#0
   1833  0aa1		       71 52		      adc	(R0),y
   1834  0aa3		       91 52		      sta	(R0),y
   1835  0aa5				   iINCDONE
   1836  0aa5		       4c b1 02 	      jmp	NextIL
   1837  0aa8
   1838  0aa8				   iDECVAR
   1839  0aa8		       20 c4 2c 	      jsr	popR0
   1840  0aab		       a0 00		      ldy	#0
   1841  0aad		       38		      sec
   1842  0aae		       b1 52		      lda	(R0),y
   1843  0ab0		       e9 01		      sbc	#1
   1844  0ab2		       91 52		      sta	(R0),y
   1845  0ab4		       c8		      iny
   1846  0ab5		       b1 52		      lda	(R0),y
   1847  0ab7		       e9 00		      sbc	#0
   1848  0ab9		       91 52		      sta	(R0),y
   1849  0abb		       4c b1 02 	      jmp	NextIL
   1850  0abe
   1851  0abe
   1852  0abe							;
   1853  0abe							;=====================================================
   1854  0abe							; TSTV is followed by an 8 bit signed offset.	If the
   1855  0abe							; value at (CURPTR),CUROFF appears to be a variable
   1856  0abe							; name, move to the next IL statement.  Else, add the
   1857  0abe							; offset to ILPC. Converted to use actual absolute memory addresses
   1858  0abe							; TSTVT Looks for the task context
   1859  0abe							;
   1860  0abe		       20 dc 2c    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1861  0ac1		       a9 00		      lda	#0
   1862  0ac3		       85 58		      sta	R2
   1863  0ac5		       f0 04		      beq	iTSTVV
   1864  0ac7
   1865  0ac7							; Test for simple variable
   1866  0ac7		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1867  0ac9		       85 58		      sta	R2
   1868  0acb
   1869  0acb		       20 39 2a    iTSTVV     jsr	getILByte	;offset
   1870  0ace		       8d 2f 43 	      sta	offset
   1871  0ad1							;
   1872  0ad1		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1873  0ad3		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1874  0ad5		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1875  0ad7		       4c 8d 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1876  0ada							;
   1877  0ada				   iTSTVnext
   1878  0ada		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1879  0adc		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1880  0ade
   1881  0ade		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1882  0ae0		       f0 5b		      beq	iTSTVParm
   1883  0ae2
   1884  0ae2		       c9 9b		      cmp	#tVhat	; task exit code
   1885  0ae4		       d0 04		      bne	iTSTV_A2Z
   1886  0ae6		       a9 48		      lda	#TASKEXITCODE
   1887  0ae8		       d0 0b		      bne	iTSTVContinue
   1888  0aea
   1889  0aea				   iTSTV_A2Z
   1890  0aea
   1891  0aea		       c9 80		      cmp	#tVa
   1892  0aec		       90 9f		      bcc	tstBranchLink
   1893  0aee		       c9 9a		      cmp	#tVz+1
   1894  0af0		       b0 9b		      bcs	tstBranchLink
   1895  0af2
   1896  0af2
   1897  0af2							;
   1898  0af2							; The condition is true, so convert to an index, push
   1899  0af2							; it onto the stack and continue running.
   1900  0af2							;
   1901  0af2		       29 7f		      and	#%01111111	; Mask off the high bit
   1902  0af4		       0a		      asl		; multiply by two
   1903  0af5
   1904  0af5				   iTSTVContinue
   1905  0af5		       c8		      iny
   1906  0af6		       84 51		      sty	CUROFF	; it is a valid variable
   1907  0af8		       48		      pha		; save the last variable pointer value
   1908  0af9		       a5 58		      lda	R2
   1909  0afb		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1910  0afd
   1911  0afd		       20 0e 2a 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1912  0b00		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1913  0b02
   1914  0b02		       68		      pla		; We have an invalid pid for getting variable value
   1915  0b03		       a2 10		      ldx	#ERR_INVALID_PID
   1916  0b05		       a9 00		      lda	#0
   1917  0b07		       4c 7d 06 	      jmp	iErr2
   1918  0b0a
   1919  0b0a				   iTSTVGOODPID
   1920  0b0a		       20 f6 29 	      jsr	ipc_getcontext	; Get the other tasks variables
   1921  0b0d		       a0 01		      ldy	#VARIABLEPOS
   1922  0b0f		       b1 56		      lda	(MQ),y
   1923  0b11		       85 52		      sta	R0
   1924  0b13		       c8		      iny
   1925  0b14		       b1 56		      lda	(MQ),y
   1926  0b16		       85 53		      sta	R0+1
   1927  0b18		       4c 23 0b 	      jmp	iTSTVAddOffset
   1928  0b1b
   1929  0b1b				   iTSTVLocalValue
   1930  0b1b		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1931  0b1d		       85 52		      sta	R0
   1932  0b1f		       a5 42		      lda	VARIABLES+1
   1933  0b21		       85 53		      sta	R0+1
   1934  0b23
   1935  0b23				   iTSTVAddOffset
   1936  0b23		       68		      pla
   1937  0b24		       85 54		      sta	R1
   1938  0b26		       a9 00		      lda	#0
   1939  0b28		       85 55		      sta	R1+1
   1940  0b2a
   1941  0b2a				   iTSTVcontinue
   1942  0b2a
   1943  0b2a		       4c a5 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1944  0b2d
   1945  0b2d							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1946  0b2d							; an array of integer values or byte.
   1947  0b2d				   iTSTVat
   1948  0b2d		       c8		      iny
   1949  0b2e		       84 51		      sty	CUROFF	;it is a valid variable
   1950  0b30		       ad 39 43 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1951  0b33		       85 52		      sta	R0
   1952  0b35		       ad 3a 43 	      lda	ProgramEnd+1
   1953  0b38		       85 53		      sta	R0+1
   1954  0b3a		       4c 1d 07 	      jmp	pushR0nextIl	;place this onto the stack
   1955  0b3d
   1956  0b3d							; When we get parameters passed we can access them using the # variable with[]
   1957  0b3d							; example #[0] #[1] etc, we dont check yet if there is too many
   1958  0b3d		       c8	   iTSTVParm  iny
   1959  0b3e		       84 51		      sty	CUROFF	;it is a valid variable
   1960  0b40
   1961  0b40							; upon return the y register  point to the gosub Parms entry value entry
   1962  0b40		       20 c6 25 	      jsr	GosubFindParms
   1963  0b43		       90 21		      bcc	iTSTMissingParms
   1964  0b45
   1965  0b45		       88		      dey
   1966  0b46		       88		      dey
   1967  0b47		       88		      dey		;Point to the actual index of first parameter in math stack
   1968  0b48
   1969  0b48		       a5 48		      lda	MATHSTACK
   1970  0b4a		       85 52		      sta	R0
   1971  0b4c		       a5 49		      lda	MATHSTACK+1
   1972  0b4e		       85 53		      sta	R0+1
   1973  0b50		       b1 4b		      lda	(GOSUBSTACK),y	; Get the correct Offset to start of parameters
   1974  0b52		       f0 0b		      beq	iTSTVindex0	; no math if no offset
   1975  0b54		       18		      clc
   1976  0b55		       65 52		      adc	R0	; Point to the actual address that the variables start, not just top of stack
   1977  0b57		       85 52		      sta	R0
   1978  0b59		       a9 00		      lda	#0
   1979  0b5b		       65 53		      adc	R0+1
   1980  0b5d		       85 53		      sta	R0+1
   1981  0b5f				   iTSTVindex0
   1982  0b5f		       a9 81		      lda	#GOSUB_RTN_VALUE
   1983  0b61		       85 58		      sta	R2	; Set the data type as a parameter to a function
   1984  0b63		       4c 1d 07 	      jmp	pushR0nextIl
   1985  0b66
   1986  0b66
   1987  0b66				   iTSTMissingParms
   1988  0b66		       a9 00		      lda	#0
   1989  0b68		       a2 19		      ldx	#ERR_FUNCTION_EXPECTED_PARAMETERS
   1990  0b6a		       4c 7d 06 	      jmp	iErr2
   1991  0b6d
   1992  0b6d							;
   1993  0b6d							;=====================================================
   1994  0b6d							; TSTL seems basically the same as TSTN, but leave the
   1995  0b6d							; value in R0 instead of pushing onto stack.
   1996  0b6d							; This tests for a valid line number
   1997  0b6d							;
   1998  0b6d		       20 39 2a    iTSTL      jsr	getILByte
   1999  0b70		       8d 2f 43 	      sta	offset
   2000  0b73							;
   2001  0b73		       a4 51		      ldy	CUROFF
   2002  0b75		       b1 4f		      lda	(CURPTR),y
   2003  0b77		       c8		      iny
   2004  0b78		       11 4f		      ora	(CURPTR),y
   2005  0b7a		       f0 06		      beq	iTSTLNotLineNo
   2006  0b7c
   2007  0b7c
   2008  0b7c							; In Both cases we need to point to the first usefull byte to process.
   2009  0b7c		       c8		      iny
   2010  0b7d		       84 51		      sty	CUROFF
   2011  0b7f		       4c b1 02 	      jmp	NextIL
   2012  0b82				   iTSTLNotLineNo
   2013  0b82		       c8		      iny
   2014  0b83		       84 51		      sty	CUROFF
   2015  0b85		       4c e0 0b 	      jmp	tstBranch
   2016  0b88
   2017  0b88							;
   2018  0b88							;=====================================================
   2019  0b88							; TSTN checks for a number.  This is very simplistic;
   2020  0b88							; if the character is a digit, assume it's a number.
   2021  0b88							; Convert to a number and push it onto the stack.
   2022  0b88							;
   2023  0b88		       20 39 2a    iTSTN      jsr	getILByte
   2024  0b8b		       8d 2f 43 	      sta	offset
   2025  0b8e							;
   2026  0b8e		       a9 00		      lda	#0
   2027  0b90		       85 59		      sta	dpl
   2028  0b92		       a4 51		      ldy	CUROFF
   2029  0b94				   chkType
   2030  0b94		       b1 4f		      lda	(CURPTR),y
   2031  0b96		       c9 a2		      cmp	#tByte
   2032  0b98		       f0 0e		      beq	chkByte
   2033  0b9a		       c9 a4		      cmp	#tInteger
   2034  0b9c		       f0 16		      beq	chkInteger
   2035  0b9e		       c9 eb		      cmp	#oMinus
   2036  0ba0		       d0 3e		      bne	tstBranch
   2037  0ba2		       e6 59		      inc	dpl
   2038  0ba4		       c8		      iny
   2039  0ba5		       4c 94 0b 	      jmp	chkType
   2040  0ba8
   2041  0ba8				   chkByte
   2042  0ba8		       a9 00		      lda	#0
   2043  0baa		       85 53		      sta	R0+1
   2044  0bac		       c8		      iny
   2045  0bad		       b1 4f		      lda	(CURPTR),y
   2046  0baf		       85 52		      sta	R0
   2047  0bb1		       c8		      iny
   2048  0bb2		       d0 0b		      bne	iTSTN_1
   2049  0bb4
   2050  0bb4				   chkInteger
   2051  0bb4		       c8		      iny
   2052  0bb5		       b1 4f		      lda	(CURPTR),y
   2053  0bb7		       85 52		      sta	R0
   2054  0bb9		       c8		      iny
   2055  0bba		       b1 4f		      lda	(CURPTR),y
   2056  0bbc		       85 53		      sta	R0+1
   2057  0bbe		       c8		      iny
   2058  0bbf							;
   2059  0bbf							; Check if it is negative and make it so
   2060  0bbf							;
   2061  0bbf				   iTSTN_1
   2062  0bbf		       84 51		      sty	CUROFF
   2063  0bc1
   2064  0bc1		       a5 59		      lda	dpl
   2065  0bc3		       f0 18		      beq	iTSTN_2	;positive
   2066  0bc5							;
   2067  0bc5		       a5 52		      lda	R0
   2068  0bc7		       05 53		      ora	R0+1
   2069  0bc9		       f0 12		      beq	iTSTN_2	;zero
   2070  0bcb
   2071  0bcb							; Invert all the bits, then add one.
   2072  0bcb							;
   2073  0bcb		       a5 52		      lda	R0
   2074  0bcd		       49 ff		      eor	#$ff
   2075  0bcf		       85 52		      sta	R0
   2076  0bd1		       a5 53		      lda	R0+1
   2077  0bd3		       49 ff		      eor	#$ff
   2078  0bd5		       85 53		      sta	R0+1
   2079  0bd7							;
   2080  0bd7		       e6 52		      inc	R0
   2081  0bd9		       d0 02		      bne	iTSTN_2
   2082  0bdb		       e6 53		      inc	R0+1
   2083  0bdd				   iTSTN_2
   2084  0bdd		       4c 1d 07 	      jmp	pushR0nextIl	;save onto stack
   2085  0be0
   2086  0be0							;
   2087  0be0							; Common jump point for all TSTx instructions that
   2088  0be0							; fail to meet the requirements.  This takes the
   2089  0be0							; offset and adds/subtracts to/from ILPC.
   2090  0be0							;
   2091  0be0		       ad 2f 43    tstBranch  lda	offset	;get signed offset
   2092  0be3		       10 0e		      bpl	tstPositive
   2093  0be5							;
   2094  0be5							; Do negative branch.	Do sign extension.
   2095  0be5							;
   2096  0be5		       18	   tstNegative clc
   2097  0be6		       65 43		      adc	ILPC
   2098  0be8		       85 43		      sta	ILPC
   2099  0bea							;		  bcc	  tstBothDone
   2100  0bea							;		  dec	  ILPC+1
   2101  0bea							;		  jmp	  NextIL
   2102  0bea
   2103  0bea		       a5 44		      lda	ILPC+1
   2104  0bec		       69 ff		      adc	#$ff
   2105  0bee		       85 44		      sta	ILPC+1
   2106  0bf0		       4c b1 02 	      jmp	NextIL	;keep going
   2107  0bf3							;
   2108  0bf3		       18	   tstPositive clc
   2109  0bf4		       65 43		      adc	ILPC
   2110  0bf6		       85 43		      sta	ILPC
   2111  0bf8		       90 02		      bcc	tstBothDone
   2112  0bfa		       e6 44		      inc	ILPC+1
   2113  0bfc				   tstBothDone
   2114  0bfc		       4c b1 02 	      jmp	NextIL
   2115  0bff
   2116  0bff							;
   2117  0bff							;====================================================
   2118  0bff							; Test for IRQ pending, and test if a break key pressed
   2119  0bff							; Yes I know but this handles all sorts of irq/break issues
   2120  0bff							;
   2121  0bff		       20 39 2a    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2122  0c02		       8d 2f 43 	      sta	offset	; Store the not true jump address offset
   2123  0c05		       ad c6 19    irqNo      lda	IRQPending	; Check if the pending value is set
   2124  0c08		       f0 20		      beq	tstBreak	; if no irq then check for an escape key pressed
   2125  0c0a		       c9 01		      cmp	#1	; only do this if set to first time
   2126  0c0c		       d0 1c		      bne	tstBreak	; We are in a irq service already
   2127  0c0e				   iTSTProcessIRQ
   2128  0c0e		       78		      sei		; disable the interupt until ireturn resets it
   2129  0c0f		       ee c6 19 	      inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2130  0c12		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2131  0c14		       20 4c 2c 	      jsr	pushLN	; Push the next line to be executed
   2132  0c17		       b0 21		      bcs	ErrStkOver	; Check if there was an error
   2133  0c19		       ad c7 19 	      lda	IRQEntry	; Get the line number to branch to
   2134  0c1c		       85 4f		      sta	CURPTR	; put line number into r0
   2135  0c1e		       ad c8 19 	      lda	IRQEntry+1
   2136  0c21		       85 50		      sta	CURPTR+1
   2137  0c23		       a9 03		      lda	#3	; Point to first byte of program text
   2138  0c25		       85 51		      sta	CUROFF
   2139  0c27		       4c b1 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2140  0c2a
   2141  0c2a				   tstBreak
   2142  0c2a		       20 67 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2143  0c2d		       d0 b1		      bne	tstBranch	; z not set of no break found
   2144  0c2f		       ad 31 43 	      lda	taskIOPending
   2145  0c32		       f0 03		      beq	tstBrkComplete
   2146  0c34		       ce 31 43 	      dec	taskIOPending
   2147  0c37		       4c 02 06    tstBrkComplete jmp	iFIN	; Exit out of run mode
   2148  0c3a
   2149  0c3a		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2150  0c3c		       a9 00		      lda	#0	; stop the execution
   2151  0c3e		       4c 7d 06 	      jmp	iErr2
   2152  0c41							;
   2153  0c41
   2154  0c41							;=====================================================
   2155  0c41							; This places the number of free bytes on top of the
   2156  0c41							; stack.
   2157  0c41							;
   2158  0c41		       20 d4 23    iFREE      jsr	MemFree
   2159  0c44		       4c 1d 07 	      jmp	pushR0nextIl
   2160  0c47							;
   2161  0c47							;=====================================================
   2162  0c47							; Generate a random number from 0-FFFF and then MOD
   2163  0c47							; it with the value on top of stack.  Leaves number on
   2164  0c47							; stack
   2165  0c47							;
   2166  0c47		       20 dc 2c    iRANDOM    jsr	popR1	;mod value
   2167  0c4a							;
   2168  0c4a							; If the value is zero, just return a one.
   2169  0c4a							;
   2170  0c4a		       a5 54		      lda	R1
   2171  0c4c		       05 55		      ora	R1+1
   2172  0c4e		       f0 4a		      beq	irandom1
   2173  0c50							;
   2174  0c50		       ad 2a 43 	      lda	random+1
   2175  0c53		       8d 27 43 	      sta	rtemp1
   2176  0c56		       ad 29 43 	      lda	random
   2177  0c59		       0a		      asl
   2178  0c5a		       2e 27 43 	      rol	rtemp1
   2179  0c5d		       0a		      asl
   2180  0c5e		       2e 27 43 	      rol	rtemp1
   2181  0c61		       18		      clc
   2182  0c62		       6d 29 43 	      adc	random
   2183  0c65
   2184  0c65		       48		      pha
   2185  0c66
   2186  0c66		       ad 27 43 	      lda	rtemp1
   2187  0c69		       6d 2a 43 	      adc	random+1
   2188  0c6c		       8d 2a 43 	      sta	random+1
   2189  0c6f
   2190  0c6f		       68		      pla
   2191  0c70
   2192  0c70		       69 11		      adc	#$11
   2193  0c72		       8d 29 43 	      sta	random
   2194  0c75		       ad 2a 43 	      lda	random+1
   2195  0c78		       69 36		      adc	#$36
   2196  0c7a		       8d 2a 43 	      sta	random+1
   2197  0c7d
   2198  0c7d		       ad 29 43 	      lda	random
   2199  0c80		       85 52		      sta	R0
   2200  0c82		       ad 2a 43 	      lda	random+1
   2201  0c85		       29 7f		      and	#$7f	;make positive
   2202  0c87		       85 53		      sta	R0+1
   2203  0c89							;
   2204  0c89							; R0 contains the number and R1 contains the max value.
   2205  0c89							;
   2206  0c89		       20 43 07 	      jsr	iDivNoPop
   2207  0c8c		       20 45 2d 	      jsr	RestoreSigns
   2208  0c8f		       a5 56		      lda	MQ
   2209  0c91		       85 52		      sta	R0
   2210  0c93		       a5 57		      lda	MQ+1
   2211  0c95		       85 53		      sta	R0+1
   2212  0c97		       4c 1d 07 	      jmp	pushR0nextIl
   2213  0c9a				   irandom1
   2214  0c9a		       a9 00		      lda	#0
   2215  0c9c		       85 53		      sta	R0+1
   2216  0c9e		       a9 01		      lda	#1
   2217  0ca0		       85 52		      sta	R0
   2218  0ca2		       4c 1d 07 	      jmp	pushR0nextIl
   2219  0ca5
   2220  0ca5							; The following replaced by call to division/modulo
   2221  0ca5							;iRANDOM_2	lda	R0
   2222  0ca5							;		cmp	R1
   2223  0ca5							;		bne	iRANDOM_1
   2224  0ca5							;		lda	R0+1
   2225  0ca5							;		cmp	R1+1
   2226  0ca5							;		bne	iRANDOM_1	;need to subtract
   2227  0ca5							;
   2228  0ca5							; Subtract R1 from R0
   2229  0ca5							;
   2230  0ca5							;iRANDOM_sub	sec
   2231  0ca5							;		lda	R0
   2232  0ca5							;		sbc	R1
   2233  0ca5							;		sta	R0
   2234  0ca5							;		lda	R0+1
   2235  0ca5							;		sbc	R1+1
   2236  0ca5							;		sta	R0+1
   2237  0ca5							;		jmp	iRANDOM_2
   2238  0ca5							;
   2239  0ca5							; See if R1 > R0.  If so, branch to subtract.
   2240  0ca5							;
   2241  0ca5							;iRANDOM_1	lda	R0
   2242  0ca5							;		cmp	R1
   2243  0ca5							;		lda	R0+1
   2244  0ca5							;		sbc	R1+1
   2245  0ca5							;		bvc	iRANDOM_4
   2246  0ca5							;		eor	#$80
   2247  0ca5							;iRANDOM_4	bpl	iRANDOM_sub
   2248  0ca5							;
   2249  0ca5							; All done.  Almost.  Add one, then push the result.
   2250  0ca5							;
   2251  0ca5							;irandom1	inc	R0
   2252  0ca5							;		bne	iRANDOM_3
   2253  0ca5							;		inc	R0+1
   2254  0ca5							;iRANDOM_3
   2255  0ca5							;		  jsr	pushR0	;return value
   2256  0ca5							;		jmp	NextIL
   2257  0ca5							;
   2258  0ca5							; Poke a value into a memory location
   2259  0ca5		       8c 2b 43    iPOKEMEMORY sty	tempy
   2260  0ca8		       20 c4 2c 	      jsr	popR0
   2261  0cab		       20 dc 2c 	      jsr	popR1
   2262  0cae		       a0 00		      ldy	#0
   2263  0cb0		       a5 52		      lda	R0
   2264  0cb2		       91 54		      sta	(R1),y
   2265  0cb4		       ac 2b 43 	      ldy	tempy
   2266  0cb7		       4c b1 02 	      jmp	NextIL
   2267  0cba							;
   2268  0cba							; Get a value from a memory location
   2269  0cba							;
   2270  0cba		       8c 2b 43    iPEEKMEMORY sty	tempy
   2271  0cbd		       20 c4 2c 	      jsr	popR0
   2272  0cc0		       a0 00		      ldy	#0
   2273  0cc2		       b1 52		      lda	(R0),y
   2274  0cc4		       ac 2b 43 	      ldy	tempy
   2275  0cc7		       85 52		      sta	R0
   2276  0cc9		       a9 00		      lda	#0
   2277  0ccb		       85 53		      sta	R0+1
   2278  0ccd		       4c 1d 07 	      jmp	pushR0nextIl
   2279  0cd0							;
   2280  0cd0							; Call to address return what ever is in a to the stack
   2281  0cd0							; func2 will load a value into a before the call
   2282  0cd0		       20 dc 2c    iCallFunc  jsr	popR1
   2283  0cd3		       a5 54		      lda	R1
   2284  0cd5		       20 e1 0c 	      jsr	iCallRtn
   2285  0cd8		       85 52		      sta	R0
   2286  0cda		       a9 00		      lda	#0
   2287  0cdc		       85 53		      sta	R0+1
   2288  0cde		       20 1d 07 	      jsr	pushR0nextIl
   2289  0ce1				   iCallRtn
   2290  0ce1		       20 c4 2c 	      jsr	popR0
   2291  0ce4		       6c 52 00 	      jmp	(R0)
   2292  0ce7
   2293  0ce7
   2294  0ce7							;===========================================jlit======
   2295  0ce7							;Get a character from the terminal convert to value
   2296  0ce7							;leave the number on top of the stack
   2297  0ce7							;
   2298  0ce7				   iGETCHAR
   2299  0ce7		       20 66 1a 	      jsr	VGETCH
   2300  0cea					      if	CTMON65
   2301  0cea		       48		      pha
   2302  0ceb		       20 63 1a 	      jsr	VOUTCH	;echo echo echo
   2303  0cee		       68		      pla
   2304  0cef					      endif
   2305  0cef		       85 52		      sta	R0
   2306  0cf1		       a9 00		      lda	#0
   2307  0cf3		       85 53		      sta	R0+1
   2308  0cf5		       20 32 2c 	      jsr	pushR0
   2309  0cf8							;
   2310  0cf8		       4c b1 02 	      jmp	NextIL
   2311  0cfb							;===========================================jusilostintim======
   2312  0cfb							;Put a character to the terminal convert to
   2313  0cfb							;
   2314  0cfb		       20 c4 2c    iPUTCHAR   jsr	popR0
   2315  0cfe		       a5 52		      lda	R0
   2316  0d00		       20 63 1a 	      jsr	VOUTCH
   2317  0d03		       4c b1 02 	      jmp	NextIL
   2318  0d06							;=====================================================
   2319  0d06							; Put the number on the stack out as hex, suppress leading 0
   2320  0d06				   iHexOut
   2321  0d06		       20 c4 2c 	      jsr	popR0
   2322  0d09		       a5 53		      lda	R0+1
   2323  0d0b		       f0 03		      beq	iHexSecondByte
   2324  0d0d		       20 9e 21 	      jsr	OUTHEX
   2325  0d10				   iHexSecondByte
   2326  0d10		       a5 52		      lda	R0
   2327  0d12		       20 9e 21 	      jsr	OUTHEX
   2328  0d15		       4c b1 02 	      jmp	NextIL
   2329  0d18							;
   2330  0d18							;=====================================================
   2331  0d18							; Replace TOS with its absolute value.
   2332  0d18							;
   2333  0d18		       20 c4 2c    iABS       jsr	popR0
   2334  0d1b		       a5 53		      lda	R0+1
   2335  0d1d		       10 10		      bpl	iABS_1	;already positive
   2336  0d1f		       49 ff		      eor	#$ff
   2337  0d21		       85 53		      sta	R0+1
   2338  0d23		       a5 52		      lda	R0
   2339  0d25		       49 ff		      eor	#$ff
   2340  0d27		       85 52		      sta	R0
   2341  0d29		       e6 52		      inc	R0
   2342  0d2b		       d0 02		      bne	iABS_1
   2343  0d2d		       e6 53		      inc	R0+1
   2344  0d2f		       4c 1d 07    iABS_1     jmp	pushR0nextIl
   2345  0d32
   2346  0d32							;
   2347  0d32							;================================================================
   2348  0d32							; The set of logical operators
   2349  0d32				   iLogAnd
   2350  0d32		       20 c4 2c 	      jsr	popR0
   2351  0d35		       20 dc 2c 	      jsr	popR1
   2352  0d38		       a5 52		      lda	R0
   2353  0d3a		       25 54		      and	R1
   2354  0d3c		       85 52		      sta	R0
   2355  0d3e		       a5 53		      lda	R0+1
   2356  0d40		       25 55		      and	R1+1
   2357  0d42		       85 53		      sta	R0+1
   2358  0d44		       4c 1d 07 	      jmp	pushR0nextIl
   2359  0d47
   2360  0d47				   iLogOr
   2361  0d47		       20 c4 2c 	      jsr	popR0
   2362  0d4a		       20 dc 2c 	      jsr	popR1
   2363  0d4d		       a5 52		      lda	R0
   2364  0d4f		       05 54		      ora	R1
   2365  0d51		       85 52		      sta	R0
   2366  0d53		       a5 53		      lda	R0+1
   2367  0d55		       05 55		      ora	R1+1
   2368  0d57		       85 53		      sta	R0+1
   2369  0d59		       4c 1d 07 	      jmp	pushR0nextIl
   2370  0d5c				   iLogXor
   2371  0d5c		       20 c4 2c 	      jsr	popR0
   2372  0d5f		       20 dc 2c 	      jsr	popR1
   2373  0d62		       a5 52		      lda	R0
   2374  0d64		       45 54		      eor	R1
   2375  0d66		       85 52		      sta	R0
   2376  0d68		       a5 53		      lda	R0+1
   2377  0d6a		       45 55		      eor	R1+1
   2378  0d6c		       85 53		      sta	R0+1
   2379  0d6e		       4c 1d 07 	      jmp	pushR0nextIl
   2380  0d71				   iLogNot
   2381  0d71		       20 c4 2c 	      jsr	popR0
   2382  0d74		       a5 52		      lda	R0
   2383  0d76		       49 ff		      eor	#$FF
   2384  0d78		       85 52		      sta	R0
   2385  0d7a		       a5 53		      lda	R0+1
   2386  0d7c		       49 ff		      eor	#$FF
   2387  0d7e		       85 53		      sta	R0+1
   2388  0d80		       4c 1d 07 	      jmp	pushR0nextIl
   2389  0d83
   2390  0d83				   iTruth
   2391  0d83		       a9 ff		      lda	#$FF
   2392  0d85		       85 52		      sta	R0
   2393  0d87		       85 53		      sta	R0+1
   2394  0d89		       4c 1d 07 	      jmp	pushR0nextIl
   2395  0d8c				   iFalse
   2396  0d8c		       a9 00		      lda	#$00
   2397  0d8e		       85 52		      sta	R0
   2398  0d90		       85 53		      sta	R0+1
   2399  0d92		       4c 1d 07 	      jmp	pushR0nextIl
   2400  0d95							;===============================================================
   2401  0d95							;Shift instruction right 1, left 0
   2402  0d95							;
   2403  0d95		       8a	   iShift     txa
   2404  0d96		       48		      pha
   2405  0d97		       20 c4 2c 	      jsr	popR0	; number of places to shift 0 to 16 really
   2406  0d9a		       20 dc 2c 	      jsr	popR1	; value to shift
   2407  0d9d		       a6 52		      ldx	R0	; get number of times to shift
   2408  0d9f		       20 39 2a 	      jsr	getILByte	; get direction to shift
   2409  0da2		       c9 01		      cmp	#1	; Should we be doing left
   2410  0da4		       f0 0a		      beq	iShiftRight
   2411  0da6							;
   2412  0da6							; Shift r1 left n bits
   2413  0da6				   iShiftLeft
   2414  0da6		       18	   iShiftLloop clc
   2415  0da7		       26 54		      rol	R1
   2416  0da9		       26 55		      rol	R1+1
   2417  0dab		       ca		      dex
   2418  0dac		       d0 f8		      bne	iShiftLloop
   2419  0dae		       f0 07		      beq	iShiftExit
   2420  0db0							;
   2421  0db0							; Shift R1 right n bits
   2422  0db0							;
   2423  0db0				   iShiftRight
   2424  0db0		       46 55	   iShiftRloop lsr	R1+1
   2425  0db2		       46 54		      lsr	R1
   2426  0db4		       ca		      dex
   2427  0db5		       d0 f9		      bne	iShiftRloop
   2428  0db7				   iShiftExit
   2429  0db7		       68		      pla
   2430  0db8		       aa		      tax
   2431  0db9		       20 aa 2c 	      jsr	pushR1
   2432  0dbc		       4c b1 02 	      jmp	NextIL
   2433  0dbf
   2434  0dbf							;================================================================
   2435  0dbf							;Set the IRQ service rtn line number
   2436  0dbf							;
   2437  0dbf		       78	   iSetIrq    sei		; disable the interupts
   2438  0dc0		       a9 00		      lda	#0	; Zero the Status flag
   2439  0dc2		       8d c5 19 	      sta	IRQStatus
   2440  0dc5		       20 c4 2c 	      jsr	popR0	; get the line number
   2441  0dc8		       a5 52		      lda	R0
   2442  0dca		       05 53		      ora	R0+1
   2443  0dcc		       f0 22		      beq	iSetExt	; if it is zero disable all
   2444  0dce		       a9 01		      lda	#GOSUB_RTN	; default push type
   2445  0dd0		       20 4c 2c 	      jsr	pushLN	; Save the current line pointer
   2446  0dd3		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2447  0dd5		       4c 3a 0c 	      jmp	ErrStkOver	; Check if there was an error
   2448  0dd8				   iSetIrqOk
   2449  0dd8		       20 7e 2a 	      jsr	findLine	; Find the IRQ func Line Pointer
   2450  0ddb		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2451  0ddd		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2452  0ddf		       8d c8 19 	      sta	IRQEntry+1
   2453  0de2		       a5 4f		      lda	CURPTR
   2454  0de4		       8d c7 19 	      sta	IRQEntry
   2455  0de7		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2456  0de9		       8d c5 19 	      sta	IRQStatus
   2457  0dec		       20 75 2c 	      jsr	popLN	; Restore the old line number
   2458  0def		       58		      cli		; Enable the interupts
   2459  0df0		       4c b1 02    iSetExt    jmp	NextIL
   2460  0df3
   2461  0df3		       20 75 2c    iSetIrqErr jsr	popLN
   2462  0df6		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2463  0df8		       a9 00		      lda	#0
   2464  0dfa		       4c 7d 06 	      jmp	iErr2
   2465  0dfd							;
   2466  0dfd		       20 c4 2c    iTRACEPROG jsr	popR0
   2467  0e00		       a5 52		      lda	R0
   2468  0e02		       85 40		      sta	ILTrace
   2469  0e04		       4c b1 02 	      jmp	NextIL
   2470  0e07
   2471  0e07							;=====================================================
   2472  0e07							; Define start of non page zero data
   2473 U4341 ????				      seg.u	TBData
   2474 U366b					      org	PROGEND
   2475 U366b							;=================================================================
   2476 U366b							;
   2477 U366b					      if	IL_DEBUG_TEXT
------- FILE ILKeyText.inc LEVEL 2 PASS 6
      0 U366b					      include	"ILKeyText.inc"
      1  0e07					      seg	Code
      2  0e07					      if	IL_DEBUG_TEXT
      3  0e07				   ILTEXTTABLE
      0  0e07					      db	0,23,"iXINIT		   ",0
      1  0e07		       00 17 69 58*	      .byte.b	0,23,"iXINIT		   ",0
      0  0e1e					      db	1,23,"iDONE		   ",0
      1  0e1e		       01 17 69 44*	      .byte.b	1,23,"iDONE		   ",0
      0  0e35					      db	2,23,"iPRS		   ",0
      1  0e35		       02 17 69 50*	      .byte.b	2,23,"iPRS		   ",0
      0  0e4c					      db	3,23,"iPRN		   ",0
      1  0e4c		       03 17 69 50*	      .byte.b	3,23,"iPRN		   ",0
      0  0e63					      db	4,23,"iSPC		   ",0
      1  0e63		       04 17 69 53*	      .byte.b	4,23,"iSPC		   ",0
      0  0e7a					      db	5,23,"iNLINE		   ",0
      1  0e7a		       05 17 69 4e*	      .byte.b	5,23,"iNLINE		   ",0
      0  0e91					      db	6,23,"iNXT		   ",0
      1  0e91		       06 17 69 4e*	      .byte.b	6,23,"iNXT		   ",0
      0  0ea8					      db	7,23,"iXFER		   ",0
      1  0ea8		       07 17 69 58*	      .byte.b	7,23,"iXFER		   ",0
      0  0ebf					      db	8,23,"iSAV		   ",0
      1  0ebf		       08 17 69 53*	      .byte.b	8,23,"iSAV		   ",0
      0  0ed6					      db	9,23,"iRSTR		   ",0
      1  0ed6		       09 17 69 52*	      .byte.b	9,23,"iRSTR		   ",0
      0  0eed					      db	10,23,"iCMPR		    ",0
      1  0eed		       0a 17 69 43*	      .byte.b	10,23,"iCMPR		    ",0
      0  0f04					      db	11,23,"iINNUM		    ",0
      1  0f04		       0b 17 69 49*	      .byte.b	11,23,"iINNUM		    ",0
      0  0f1b					      db	12,23,"iFIN		    ",0
      1  0f1b		       0c 17 69 46*	      .byte.b	12,23,"iFIN		    ",0
      0  0f32					      db	13,23,"iERR		    ",0
      1  0f32		       0d 17 69 45*	      .byte.b	13,23,"iERR		    ",0
      0  0f49					      db	14,23,"iADD		    ",0
      1  0f49		       0e 17 69 41*	      .byte.b	14,23,"iADD		    ",0
      0  0f60					      db	15,23,"iSUB		    ",0
      1  0f60		       0f 17 69 53*	      .byte.b	15,23,"iSUB		    ",0
      0  0f77					      db	16,23,"iNEG		    ",0
      1  0f77		       10 17 69 4e*	      .byte.b	16,23,"iNEG		    ",0
      0  0f8e					      db	17,23,"iMUL		    ",0
      1  0f8e		       11 17 69 4d*	      .byte.b	17,23,"iMUL		    ",0
      0  0fa5					      db	18,23,"iDIV		    ",0
      1  0fa5		       12 17 69 44*	      .byte.b	18,23,"iDIV		    ",0
      0  0fbc					      db	19,23,"iSTORE		    ",0
      1  0fbc		       13 17 69 53*	      .byte.b	19,23,"iSTORE		    ",0
      0  0fd3					      db	20,23,"iIND		    ",0
      1  0fd3		       14 17 69 49*	      .byte.b	20,23,"iIND		    ",0
      0  0fea					      db	21,23,"iLST		    ",0
      1  0fea		       15 17 69 4c*	      .byte.b	21,23,"iLST		    ",0
      0  1001					      db	22,23,"iINIT		    ",0
      1  1001		       16 17 69 49*	      .byte.b	22,23,"iINIT		    ",0
      0  1018					      db	23,23,"iGETLINE	    ",0
      1  1018		       17 17 69 47*	      .byte.b	23,23,"iGETLINE	    ",0
      0  102f					      db	24,23,"iINSRT		    ",0
      1  102f		       18 17 69 49*	      .byte.b	24,23,"iINSRT		    ",0
      0  1046					      db	25,23,"iRTN		    ",0
      1  1046		       19 17 69 52*	      .byte.b	25,23,"iRTN		    ",0
      0  105d					      db	26,23,"MONITOR 	    ",0
      1  105d		       1a 17 4d 4f*	      .byte.b	26,23,"MONITOR 	    ",0
      0  1074					      db	27,23,"iLIT		    ",0
      1  1074		       1b 17 69 4c*	      .byte.b	27,23,"iLIT		    ",0
      0  108b					      db	28,23,"iCALL		    ",0
      1  108b		       1c 17 69 43*	      .byte.b	28,23,"iCALL		    ",0
      0  10a2					      db	29,23,"iJMP		    ",0
      1  10a2		       1d 17 69 4a*	      .byte.b	29,23,"iJMP		    ",0
      0  10b9					      db	30,23,"iVINIT		    ",0
      1  10b9		       1e 17 69 56*	      .byte.b	30,23,"iVINIT		    ",0
      0  10d0					      db	31,23,"iERRGOTO	    ",0
      1  10d0		       1f 17 69 45*	      .byte.b	31,23,"iERRGOTO	    ",0
      0  10e7					      db	32,23,"iTST		    ",0
      1  10e7		       20 17 69 54*	      .byte.b	32,23,"iTST		    ",0
      0  10fe					      db	33,23,"iTSTV		    ",0
      1  10fe		       21 17 69 54*	      .byte.b	33,23,"iTSTV		    ",0
      0  1115					      db	34,23,"iTSTL		    ",0
      1  1115		       22 17 69 54*	      .byte.b	34,23,"iTSTL		    ",0
      0  112c					      db	35,23,"iTSTN		    ",0
      1  112c		       23 17 69 54*	      .byte.b	35,23,"iTSTN		    ",0
      0  1143					      db	36,23,"iFREE		    ",0
      1  1143		       24 17 69 46*	      .byte.b	36,23,"iFREE		    ",0
      0  115a					      db	37,23,"iRANDOM 	    ",0
      1  115a		       25 17 69 52*	      .byte.b	37,23,"iRANDOM 	    ",0
      0  1171					      db	38,23,"iABS		    ",0
      1  1171		       26 17 69 41*	      .byte.b	38,23,"iABS		    ",0
      0  1188					      db	39,23,"iOPENREAD	    ",0
      1  1188		       27 17 69 4f*	      .byte.b	39,23,"iOPENREAD	    ",0
      0  119f					      db	40,23,"iOPENWRITE	    ",0
      1  119f		       28 17 69 4f*	      .byte.b	40,23,"iOPENWRITE	    ",0
      0  11b6					      db	41,23,"iDCLOSE 	    ",0
      1  11b6		       29 17 69 44*	      .byte.b	41,23,"iDCLOSE 	    ",0
      0  11cd					      db	42,23,"iDGETLINE	    ",0
      1  11cd		       2a 17 69 44*	      .byte.b	42,23,"iDGETLINE	    ",0
      0  11e4					      db	43,23,"iDLIST		    ",0
      1  11e4		       2b 17 69 44*	      .byte.b	43,23,"iDLIST		    ",0
      0  11fb					      db	44,23,"iDDIR		    ",0
      1  11fb		       2c 17 69 44*	      .byte.b	44,23,"iDDIR		    ",0
      0  1212					      db	45,23,"iRMFILE 	    ",0
      1  1212		       2d 17 69 52*	      .byte.b	45,23,"iRMFILE 	    ",0
      0  1229					      db	39,23,"NextIL		    ",0
      1  1229		       27 17 4e 65*	      .byte.b	39,23,"NextIL		    ",0
      0  1240					      db	40,23,"NextIL		    ",0
      1  1240		       28 17 4e 65*	      .byte.b	40,23,"NextIL		    ",0
      0  1257					      db	41,23,"NextIL		    ",0
      1  1257		       29 17 4e 65*	      .byte.b	41,23,"NextIL		    ",0
      0  126e					      db	42,23,"NextIL		    ",0
      1  126e		       2a 17 4e 65*	      .byte.b	42,23,"NextIL		    ",0
      0  1285					      db	43,23,"NextIL		    ",0
      1  1285		       2b 17 4e 65*	      .byte.b	43,23,"NextIL		    ",0
      0  129c					      db	44,23,"NextIL		    ",0
      1  129c		       2c 17 4e 65*	      .byte.b	44,23,"NextIL		    ",0
      0  12b3					      db	45,23,"NextIL		    ",0
      1  12b3		       2d 17 4e 65*	      .byte.b	45,23,"NextIL		    ",0
      0  12ca					      db	46,23,"iCLEARSCREEN	    ",0
      1  12ca		       2e 17 69 43*	      .byte.b	46,23,"iCLEARSCREEN	    ",0
      0  12e1					      db	47,23,"iPOKEMEMORY	    ",0
      1  12e1		       2f 17 69 50*	      .byte.b	47,23,"iPOKEMEMORY	    ",0
      0  12f8					      db	48,23,"iPEEKMEMORY	    ",0
      1  12f8		       30 17 69 50*	      .byte.b	48,23,"iPEEKMEMORY	    ",0
      0  130f					      db	49,23,"iTSTLET 	    ",0
      1  130f		       31 17 69 54*	      .byte.b	49,23,"iTSTLET 	    ",0
      0  1326					      db	50,23,"iTSTDONE	    ",0
      1  1326		       32 17 69 54*	      .byte.b	50,23,"iTSTDONE	    ",0
      0  133d					      db	51,23,"iGETCHAR	    ",0
      1  133d		       33 17 69 47*	      .byte.b	51,23,"iGETCHAR	    ",0
      0  1354					      db	52,23,"iPUTCHAR	    ",0
      1  1354		       34 17 69 50*	      .byte.b	52,23,"iPUTCHAR	    ",0
      0  136b					      db	53,23,"iCallFunc	    ",0
      1  136b		       35 17 69 43*	      .byte.b	53,23,"iCallFunc	    ",0
      0  1382					      db	54,23,"iBranch 	    ",0
      1  1382		       36 17 69 42*	      .byte.b	54,23,"iBranch 	    ",0
      0  1399					      db	55,23,"iTSTStr 	    ",0
      1  1399		       37 17 69 54*	      .byte.b	55,23,"iTSTStr 	    ",0
      0  13b0					      db	56,23,"iSetIrq 	    ",0
      1  13b0		       38 17 69 53*	      .byte.b	56,23,"iSetIrq 	    ",0
      0  13c7					      db	57,23,"iTstIrq 	    ",0
      1  13c7		       39 17 69 54*	      .byte.b	57,23,"iTstIrq 	    ",0
      0  13de					      db	58,23,"iRET		    ",0
      1  13de		       3a 17 69 52*	      .byte.b	58,23,"iRET		    ",0
      0  13f5					      db	59,23,"iINSTR		    ",0
      1  13f5		       3b 17 69 49*	      .byte.b	59,23,"iINSTR		    ",0
      0  140c					      db	60,23,"iMOD		    ",0
      1  140c		       3c 17 69 4d*	      .byte.b	60,23,"iMOD		    ",0
      0  1423					      db	61,23,"iTaskSet	    ",0
      1  1423		       3d 17 69 54*	      .byte.b	61,23,"iTaskSet	    ",0
      0  143a					      db	62,23,"iETask		    ",0
      1  143a		       3e 17 69 45*	      .byte.b	62,23,"iETask		    ",0
      0  1451					      db	63,23,"iNTask		    ",0
      1  1451		       3f 17 69 4e*	      .byte.b	63,23,"iNTask		    ",0
      0  1468					      db	64,23,"iArray		    ",0
      1  1468		       40 17 69 41*	      .byte.b	64,23,"iArray		    ",0
      0  147f					      db	65,23,"iTaskKill	    ",0
      1  147f		       41 17 69 54*	      .byte.b	65,23,"iTaskKill	    ",0
      0  1496					      db	66,23,"iTaskStat	    ",0
      1  1496		       42 17 69 54*	      .byte.b	66,23,"iTaskStat	    ",0
      0  14ad					      db	67,23,"iHexOut 	    ",0
      1  14ad		       43 17 69 48*	      .byte.b	67,23,"iHexOut 	    ",0
      0  14c4					      db	68,23,"iReadComplete	    ",0
      1  14c4		       44 17 69 52*	      .byte.b	68,23,"iReadComplete	    ",0
      0  14db					      db	69,23,"iReadStart	    ",0
      1  14db		       45 17 69 52*	      .byte.b	69,23,"iReadStart	    ",0
      0  14f2					      db	70,23,"iStartIO	    ",0
      1  14f2		       46 17 69 53*	      .byte.b	70,23,"iStartIO	    ",0
      0  1509					      db	71,23,"iEndIO		    ",0
      1  1509		       47 17 69 45*	      .byte.b	71,23,"iEndIO		    ",0
      0  1520					      db	72,23,"iLogNot 	    ",0
      1  1520		       48 17 69 4c*	      .byte.b	72,23,"iLogNot 	    ",0
      0  1537					      db	73,23,"iLogOr		    ",0
      1  1537		       49 17 69 4c*	      .byte.b	73,23,"iLogOr		    ",0
      0  154e					      db	74,23,"iLogAnd 	    ",0
      1  154e		       4a 17 69 4c*	      .byte.b	74,23,"iLogAnd 	    ",0
      0  1565					      db	75,23,"iLogXor 	    ",0
      1  1565		       4b 17 69 4c*	      .byte.b	75,23,"iLogXor 	    ",0
      0  157c					      db	76,23,"iWTASK		    ",0
      1  157c		       4c 17 69 57*	      .byte.b	76,23,"iWTASK		    ",0
      0  1593					      db	77,23,"iTASKPID	    ",0
      1  1593		       4d 17 69 54*	      .byte.b	77,23,"iTASKPID	    ",0
      0  15aa					      db	78,23,"iTRACEPROG	    ",0
      1  15aa		       4e 17 69 54*	      .byte.b	78,23,"iTRACEPROG	    ",0
      0  15c1					      db	79,23,"idbgBasic	    ",0
      1  15c1		       4f 17 69 64*	      .byte.b	79,23,"idbgBasic	    ",0
      0  15d8					      db	80,23,"iIPCS		    ",0
      1  15d8		       50 17 69 49*	      .byte.b	80,23,"iIPCS		    ",0
      0  15ef					      db	81,23,"iIPCR		    ",0
      1  15ef		       51 17 69 49*	      .byte.b	81,23,"iIPCR		    ",0
      0  1606					      db	82,23,"iIPCC		    ",0
      1  1606		       52 17 69 49*	      .byte.b	82,23,"iIPCC		    ",0
      0  161d					      db	83,23,"iIPCIO		    ",0
      1  161d		       53 17 69 49*	      .byte.b	83,23,"iIPCIO		    ",0
      0  1634					      db	84,23,"iPushMathStack	    ",0
      1  1634		       54 17 69 50*	      .byte.b	84,23,"iPushMathStack	    ",0
      0  164b					      db	85,23,"iPopMathStack	    ",0
      1  164b		       55 17 69 50*	      .byte.b	85,23,"iPopMathStack	    ",0
      0  1662					      db	86,23,"iSaveMathStack	    ",0
      1  1662		       56 17 69 53*	      .byte.b	86,23,"iSaveMathStack	    ",0
      0  1679					      db	87,23,"iRestoreMathStack   ",0
      1  1679		       57 17 69 52*	      .byte.b	87,23,"iRestoreMathStack   ",0
      0  1690					      db	88,23,"iIncParmCount	    ",0
      1  1690		       58 17 69 49*	      .byte.b	88,23,"iIncParmCount	    ",0
      0  16a7					      db	89,23,"iTaskGetMathStack   ",0
      1  16a7		       59 17 69 54*	      .byte.b	89,23,"iTaskGetMathStack   ",0
      0  16be					      db	90,23,"iTaskEnable	    ",0
      1  16be		       5a 17 69 54*	      .byte.b	90,23,"iTaskEnable	    ",0
      0  16d5					      db	91,23,"iTaskSuspend	    ",0
      1  16d5		       5b 17 69 54*	      .byte.b	91,23,"iTaskSuspend	    ",0
      0  16ec					      db	92,23,"iTaskPutMathPtr     ",0
      1  16ec		       5c 17 69 54*	      .byte.b	92,23,"iTaskPutMathPtr     ",0
      0  1703					      db	93,23,"iTSTVT		    ",0
      1  1703		       5d 17 69 54*	      .byte.b	93,23,"iTSTVT		    ",0
      0  171a					      db	94,23,"iSetR2		    ",0
      1  171a		       5e 17 69 53*	      .byte.b	94,23,"iSetR2		    ",0
      0  1731					      db	95,23,"iStk2Tmp	    ",0
      1  1731		       5f 17 69 53*	      .byte.b	95,23,"iStk2Tmp	    ",0
      0  1748					      db	96,23,"iTmp2Stk	    ",0
      1  1748		       60 17 69 54*	      .byte.b	96,23,"iTmp2Stk	    ",0
      0  175f					      db	97,23,"iTSTBYTE	    ",0
      1  175f		       61 17 69 54*	      .byte.b	97,23,"iTSTBYTE	    ",0
      0  1776					      db	98,23,"iINCVAR 	    ",0
      1  1776		       62 17 69 49*	      .byte.b	98,23,"iINCVAR 	    ",0
      0  178d					      db	99,23,"iDECVAR 	    ",0
      1  178d		       63 17 69 44*	      .byte.b	99,23,"iDECVAR 	    ",0
      0  17a4					      db	100,23,"iSLICE 	     ",0
      1  17a4		       64 17 69 53*	      .byte.b	100,23,"iSLICE 	     ",0
      0  17bb					      db	101,23,"iTSTB		     ",0
      1  17bb		       65 17 69 54*	      .byte.b	101,23,"iTSTB		     ",0
      0  17d2					      db	102,23,"iTSTW		     ",0
      1  17d2		       66 17 69 54*	      .byte.b	102,23,"iTSTW		     ",0
      0  17e9					      db	103,23,"iOnGoto	     ",0
      1  17e9		       67 17 69 4f*	      .byte.b	103,23,"iOnGoto	     ",0
      0  1800					      db	104,23,"iTSTRELOP	     ",0
      1  1800		       68 17 69 54*	      .byte.b	104,23,"iTSTRELOP	     ",0
      0  1817					      db	105,23,"iRepeatLine	     ",0
      1  1817		       69 17 69 52*	      .byte.b	105,23,"iRepeatLine	     ",0
      0  182e					      db	106,23,"iTSTBRANCH	     ",0
      1  182e		       6a 17 69 54*	      .byte.b	106,23,"iTSTBRANCH	     ",0
      0  1845					      db	107,23,"iFastXfer	     ",0
      1  1845		       6b 17 69 46*	      .byte.b	107,23,"iFastXfer	     ",0
      0  185c					      db	108,23,"iSetTerminal	     ",0
      1  185c		       6c 17 69 53*	      .byte.b	108,23,"iSetTerminal	     ",0
      0  1873					      db	109,23,"iINDB		     ",0
      1  1873		       6d 17 69 49*	      .byte.b	109,23,"iINDB		     ",0
      0  188a					      db	110,23,"iSetBlock	     ",0
      1  188a		       6e 17 69 53*	      .byte.b	110,23,"iSetBlock	     ",0
      0  18a1					      db	111,23,"iCopyBlock	     ",0
      1  18a1		       6f 17 69 43*	      .byte.b	111,23,"iCopyBlock	     ",0
      0  18b8					      db	112,23,"iCmpBlock	     ",0
      1  18b8		       70 17 69 43*	      .byte.b	112,23,"iCmpBlock	     ",0
      0  18cf					      db	113,23,"iShift 	     ",0
      1  18cf		       71 17 69 53*	      .byte.b	113,23,"iShift 	     ",0
      0  18e6					      db	114,23,"iTimer 	     ",0
      1  18e6		       72 17 69 54*	      .byte.b	114,23,"iTimer 	     ",0
      0  18fd					      db	$FF,23,"0		     ",0
      1  18fd		       ff 17 30 20*	      .byte.b	$FF,23,"0		     ",0
    127  1914
    128  1914							; Search for the il instruction and print the correct text for it
    129  1914							; on entry a contains the ip instruction to print
    130  1914
    131 U366b					      seg.u	TBData
    132 U366b		       00 00	   R0TempIL   ds	2
    133 U366d		       00	   ILSTA      ds	1
    134 U366e
    135  1914					      Seg	Code
    136  1914
    137  1914		       8d 6d 36    PrintILText sta	ILSTA
    138  1917		       98		      tya
    139  1918		       48		      pha
    140  1919		       8a		      txa
    141  191a		       48		      pha
    142  191b		       a5 52		      lda	R0
    143  191d		       8d 6b 36 	      sta	R0TempIL
    144  1920		       a5 53		      lda	R0+1
    145  1922		       8d 6b 36 	      sta	R0TempIL
    146  1925		       a9 07		      lda	#ILTEXTTABLE&$FF
    147  1927		       85 52		      sta	R0
    148  1929		       a9 0e		      LDA	#ILTEXTTABLE>>8
    149  192b		       85 53		      sta	R0+1
    150  192d							;Loop Here for each entry
    151  192d		       a0 00	   PrintILLoop ldy	#0
    152  192f		       b1 52		      lda	(R0),y
    153  1931		       c9 ff		      cmp	#$FF
    154  1933		       f0 2a		      beq	PrintILNotFound
    155  1935		       cd 6d 36 	      cmp	ILSTA
    156  1938		       f0 11		      beq	PrintILFound
    157  193a		       c8		      iny
    158  193b		       b1 52		      lda	(R0),y
    159  193d		       18		      clc
    160  193e		       65 52		      adc	R0
    161  1940		       85 52		      sta	R0
    162  1942		       a9 00		      lda	#0
    163  1944		       65 53		      adc	R0+1
    164  1946		       85 53		      sta	R0+1
    165  1948		       4c 2d 19 	      jmp	PrintILLoop
    166  194b							; The text was discovered
    167  194b		       c8	   PrintILFound iny		; point to length of instruction
    168  194c		       c8		      iny		; Point to start of text
    169  194d		       98		      tya
    170  194e		       18		      clc
    171  194f		       65 52		      adc	R0
    172  1951		       a8		      tay		; Low order byte of address
    173  1952		       a9 00		      lda	#0
    174  1954		       65 53		      adc	R0+1
    175  1956		       aa		      tax		; High order byte of address
    176  1957		       a9 00		      lda	#0	; Termination byte of string
    177  1959		       20 f9 21 	      jsr	PrtStr	; print the string
    178  195c		       4c 65 19 	      jmp	PrintILDone
    179  195f
    180  195f		       ad 6d 36    PrintILNotFound lda	ILSTA
    181  1962		       20 9e 21 	      jsr	HexToOut
    182  1965
    183  1965		       ad 6b 36    PrintILDone lda	R0TempIL
    184  1968		       85 52		      sta	R0
    185  196a		       ad 6c 36 	      lda	R0TempIL+1
    186  196d		       85 52		      sta	R0
    187  196f		       68		      pla
    188  1970		       aa		      tax
    189  1971		       68		      pla
    190  1972		       a8		      tay
    191  1973		       60		      rts
    192  1974					      endif
------- FILE mytb.asm
   2479  1974					      endif
------- FILE time.asm LEVEL 2 PASS 6
      0  1974					      include	"time.asm"
      1  1974							;This is the timer management functions
      2  1974							; a = 0 turn off irq, stop timer
      3  1974							; a = 1 turn on irq, set parm contained in x
      4  1974							; a = 4 get low value
      5  1974							; a = 2 get high value
      6  1974
      7  1974		       e0 10	   timerinterface equ	$E010
      8  1974		       00 1e	   cTimerControl equ	$1E
      9  1974		       00 00	   cTimerStop equ	0
     10  1974		       00 01	   cTimerStart equ	1
     11  1974		       00 02	   cTimerLow  equ	2
     12  1974		       00 04	   cTimerHigh equ	4
     13  1974
     14  1974							; il interface to the timer
     15  1974
     16  1974				   iTimer
     17  1974		       20 c4 2c 	      jsr	popR0
     18  1977		       a6 52		      ldx	R0	; Set time parameter
     19  1979		       20 c4 2c 	      jsr	popR0
     20  197c		       a5 52		      lda	R0	; control parameter 0-4
     21  197e		       20 88 19 	      jsr	iTimerif
     22  1981		       85 52		      sta	R0
     23  1983		       86 53		      stx	R0+1
     24  1985		       4c 1d 07 	      jmp	pushR0nextIl
     25  1988
     26  1988							; Actual system interface to the timer
     27  1988							; x is value 9 = 1 second, 1-5 = value * 10ms 6 = 100ms, 7=250ms, 8=500ms
     28  1988							; a is 0,1,2,4
     29  1988				   iTimerif
     30  1988		       c9 02		      cmp	#cTimerLow	; Do they want the low byte
     31  198a		       b0 2a		      bcs	iTimerValue	; Just get the value we need
     32  198c		       48		      pha		; Save the command we will use
     33  198d		       a9 1e		      lda	#cTimerControl	; Load the timer control command
     34  198f		       8d 10 e0 	      sta	timerinterface	; Write it to the timer port
     35  1992		       68		      pla		; Get the actual command back
     36  1993		       8d 10 e0 	      sta	timerinterface	; write it to the port
     37  1996		       c9 01		      cmp	#cTimerStart	; if the command was start timer then write value
     38  1998		       f0 04		      beq	iTimerParm	; if not then get ack/nak and continue
     39  199a		       78		      sei		; Disable the interupts
     40  199b		       4c b0 19 	      jmp	iTimerAck	; get ack and exit
     41  199e
     42  199e				   iTimerParm
     43  199e		       8e 10 e0 	      stx	timerinterface	; Write the program value otherwise
     44  19a1		       a9 00		      lda	#0	; Clear the counter
     45  19a3		       8d 33 43 	      sta	timercounter
     46  19a6		       8d 34 43 	      sta	timercounter+1
     47  19a9		       8d 35 43 	      sta	timercounter+2
     48  19ac		       8d 36 43 	      sta	timercounter+3
     49  19af		       58		      cli		; enable the interupts, this is start/restart timer
     50  19b0
     51  19b0				   iTimerAck
     52  19b0		       ad 10 e0 	      lda	timerinterface	; get the ack nak
     53  19b3		       a2 00		      ldx	#0	; the ack value is single byte so pad with x
     54  19b5		       60		      rts
     55  19b6
     56  19b6				   iTimerValue		; get the value from the offsets provided
     57  19b6		       08		      php
     58  19b7		       78		      sei
     59  19b8		       aa		      tax		; the control is also the value
     60  19b9		       bd 31 43 	      lda	[timercounter-2],x	; get the high byte of value
     61  19bc		       48		      pha
     62  19bd		       bd 32 43 	      lda	[timercounter-1],x	; get the low part of value
     63  19c0		       aa		      tax
     64  19c1		       68		      pla
     65  19c2		       28		      plp		; restore the interupt flag if it was enabled
     66  19c3		       60		      rts
     67  19c4
     68  19c4
     69  19c4
------- FILE mytb.asm
------- FILE io.asm LEVEL 2 PASS 6
      0  19c4					      include	"io.asm"
      1  19c4							; This is the io blocks and function for reading and writing
      2  19c4							; to devices attached to this computer.
      3  19c4							; This supports devices mapped at e000 thru efff in slot sizes of 16 byte
      4  19c4							;
      5  19c4							;=====================================================================
      6  19c4							; Device configuration equates
      7  19c4		       00 00	   ConsoleID  equ	0
      8  19c4		       00 08	   SerialID   equ	[1<<3]
      9  19c4		       00 10	   ClockID    equ	[2<<3]
     10  19c4		       00 18	   TimerID    equ	[3<<3]
     11  19c4		       00 20	   DiskID     equ	[4<<3]
     12  19c4
     13  19c4		       00 0a	   IO_MAX_DEVICES equ	10
     14  19c4		       00 06	   IO_VECT_LEN equ	6
     15  19c4
     16  19c4		       00 01	   IO_DEVICE_CLOSED equ	1	; The device is not open
     17  19c4		       00 02	   IO_DEVICE_INVALID equ	2	; The Device number provided is invalid
     18  19c4
     19  19c4							;========================================================================================
     20  19c4							; Uninitialized data segment
     21 U366e					      seg.u	TBData
     22 U366e
     23 U366e		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
     24 U3670		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
     25 U3672		       00 00	   BStatVec   ds	2	; This is used by inteface to read write status/config information
      0 U3674				   BActiveDevice db	1	; the index of the current device block
      1 U3674		       01		      .byte.b	1
      0 U3675				   BActiveDriver db	1	; Index of the device driver block
      1 U3675		       01		      .byte.b	1
     28 U3676
     29 U3676							;============================================================================================
     30  19c4					      Seg	Code
     31  19c4							; IRQ BASIC Code Service RTN Support
      0  19c4				   SaveIrqReg db	0	; Store current setting
      1  19c4		       00		      .byte.b	0
      0  19c5				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1  19c5		       00		      .byte.b	0
      0  19c6				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1  19c6		       00		      .byte.b	0
      0  19c7				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1  19c7		       00 00		      .byte.b	0,0
     36  19c9
     37  19c9							;============================================================================================
     38  19c9							; Define the device interface blocks
     39  19c9				   DeviceDriverBlocks
     40  19c9				   ConsoleDevice		; Block 0
      0  19c9					      dw	ConsoleID	; device idenifier Console
      1  19c9		       00 00		      .word.w	ConsoleID
      0  19cb					      dw	cin	; read function vector
      1  19cb		       09 f0		      .word.w	cin
      0  19cd					      dw	cout	; write function vector
      1  19cd		       0c f0		      .word.w	cout
      0  19cf					      dw	cstatus	; Get current Status info/Write config
      1  19cf		       0f f0		      .word.w	cstatus
     45  19d1
     46  19d1				   SerialDevice 		; Block 1
      0  19d1					      dw	SerialID	; device idenifier Serial
      1  19d1		       08 00		      .word.w	SerialID
      0  19d3					      dw	SerialIn	; read function vector
      1  19d3		       bf 1a		      .word.w	SerialIn
      0  19d5					      dw	SerialOut	; write function vector
      1  19d5		       bf 1a		      .word.w	SerialOut
      0  19d7					      dw	SerialStatus	; Get current Status info/Write config
      1  19d7		       bf 1a		      .word.w	SerialStatus
     51  19d9
     52  19d9				   ClockDevice		; Block 2
      0  19d9					      dw	ClockID	; Day/date Clock
      1  19d9		       10 00		      .word.w	ClockID
      0  19db					      dw	ClockRead	; Read the date from clock
      1  19db		       c0 1a		      .word.w	ClockRead
      0  19dd					      dw	ClockWrite	; Set the date/time of clock
      1  19dd		       c0 1a		      .word.w	ClockWrite
      0  19df					      dw	#0	; No Status/Config Function
      1  19df		       00 00		      .word.w	#0
     57  19e1
     58  19e1				   TimerDevice		; Block 3
      0  19e1					      dw	TimerID	; Timer/interrupt interface
      1  19e1		       18 00		      .word.w	TimerID
      0  19e3					      dw	TimerStart	; Start the timer
      1  19e3		       c1 1a		      .word.w	TimerStart
      0  19e5					      dw	TimerStop	; Stop the timer
      1  19e5		       c1 1a		      .word.w	TimerStop
      0  19e7					      dw	TimerStatus	; Config/read status
      1  19e7		       c1 1a		      .word.w	TimerStatus
     63  19e9
      0  19e9				   DiskDevice dw	DiskID	; Block 4
      1  19e9		       20 00		      .word.w	DiskID
      0  19eb					      dw	DIN	; Disk Input / read function
      1  19eb		       6b 31		      .word.w	DIN
      0  19ed					      dw	DOUT	; Disk Output / write function
      1  19ed		       52 31		      .word.w	DOUT
      0  19ef					      dw	DSTAT	; Disk Status/open/close etc information
      1  19ef		       84 31		      .word.w	DSTAT
     68  19f1							;
     69  19f1							;======================================================================
     70  19f1							; Define the Device/Slot,driver control blocks
     71  19f1							; entry format: ControlWord,DeviceDriver,PortAddress,StatusWord
     72  19f1							; Fixed at 10 devices memory usage is getting pretty big!!!!!!
     73  19f1							; Control word : bit 0 = active 1, Free 0
     74  19f1
     75  19f1				   DeviceIoBlocks
      0  19f1					      dw	1, ConsoleID, $E000, 0	; Console device is 0 file
      1  19f1		       01 00 00 00*	      .word.w	1, ConsoleID, $E000, 0
      0  19f9					      dw	1, ClockID, $E010, 0	; Port for the day/time clock
      1  19f9		       01 00 10 00*	      .word.w	1, ClockID, $E010, 0
      0  1a01					      dw	1, TimerID, $E010, 0	; Timer interface
      1  1a01		       01 00 18 00*	      .word.w	1, TimerID, $E010, 0
      0  1a09					      dw	1, DiskID, $E010, 0	; Disk Driver interface
      1  1a09		       01 00 20 00*	      .word.w	1, DiskID, $E010, 0
      0  1a11					      dw	1, SerialID, $E020, 0	; Second terminal(default Basic debug)
      1  1a11		       01 00 08 00*	      .word.w	1, SerialID, $E020, 0
      0  1a19					      dw	0, SerialID, $E030, 0	; Unused slot
      1  1a19		       00 00 08 00*	      .word.w	0, SerialID, $E030, 0
      0  1a21					      dw	0, SerialID, $E040, 0	; Unused slot
      1  1a21		       00 00 08 00*	      .word.w	0, SerialID, $E040, 0
      0  1a29					      dw	0, SerialID, $E050, 0	; Unused slot
      1  1a29		       00 00 08 00*	      .word.w	0, SerialID, $E050, 0
      0  1a31					      dw	0, SerialID, $E060, 0	; Unused slot
      1  1a31		       00 00 08 00*	      .word.w	0, SerialID, $E060, 0
      0  1a39					      dw	0, SerialID, $E070, 0	; Unused slot
      1  1a39		       00 00 08 00*	      .word.w	0, SerialID, $E070, 0
     86  1a41							;
     87  1a41							;======================================================================
     88  1a41							;
     89  1a41					      Seg	Code
     90  1a41							;======================================================================
     91  1a41							; This is the Basic IRQ handler, works with task manager, assumes timer interupt
     92  1a41							;
     93  1a41		       48	   ServiceIrq pha
     94  1a42		       8a		      txa
     95  1a43		       48		      pha
     96  1a44		       a2 00		      ldx	#0
     97  1a46				   ServiceLoop
     98  1a46		       fe 33 43 	      inc	timercounter,x
     99  1a49		       d0 05		      bne	ServiceCont
    100  1a4b		       e8		      inx
    101  1a4c		       e0 04		      cpx	#4
    102  1a4e		       d0 f6		      bne	ServiceLoop
    103  1a50				   ServiceCont
    104  1a50		       ad c5 19 	      lda	IRQStatus
    105  1a53		       f0 0a		      beq	RetIrq
    106  1a55		       ad c6 19 	      lda	IRQPending
    107  1a58		       d0 05		      bne	RetIrq
    108  1a5a		       a9 01		      lda	#1
    109  1a5c		       8d c6 19 	      sta	IRQPending
    110  1a5f				   RetIrq
    111  1a5f		       68		      pla
    112  1a60		       aa		      tax
    113  1a61		       68		      pla
    114  1a62		       40		      rti
    115  1a63							;======================================================================
    116  1a63							; Jump to the output/input function in BOutVec/BInVec
    117  1a63							;
    118  1a63		       6c 70 36    VOUTCH     jmp	(BOutVec)	; Primary block io vectors
    119  1a66		       6c 6e 36    VGETCH     jmp	(BInVec)
    120  1a69		       6c 72 36    VSTAT      jmp	(BStatVec)
    121  1a6c							;
    122  1a6c							;======================================================================
    123  1a6c							; IO Service functions
    124  1a6c							; Validate the device index and set x to offest in table
    125  1a6c							; does not return to ioInterface if invalid, returns to original caller
    126  1a6c							; should be called immediatly after entering the ioInterface call
    127  1a6c				   ioValidateDevice
    128  1a6c		       e0 0a		      cpx	#IO_MAX_DEVICES
    129  1a6e		       90 04		      bcc	ioValidIndex
    130  1a70		       a2 02		      ldx	#IO_DEVICE_INVALID
    131  1a72		       b0 13		      bcs	ioInvalidDevice
    132  1a74				   ioValidIndex
    133  1a74		       8a		      txa
    134  1a75		       0a		      asl		; Multiply by 8
    135  1a76		       0a		      asl
    136  1a77		       0a		      asl
    137  1a78		       aa		      tax		; Point to actual offset in the table
    138  1a79		       ec 74 36 	      cpx	BActiveDevice	; is it already active ?
    139  1a7c		       f0 0d		      beq	ioValidDevice	; Shortcut if this is the active device already
    140  1a7e		       a9 01		      lda	#1	; Active flag
    141  1a80		       3d f1 19 	      and	DeviceIoBlocks,x	; Check if the device is active
    142  1a83		       d0 06		      bne	ioValidDevice	; The device is active and valid index
    143  1a85		       a2 01		      ldx	#IO_DEVICE_CLOSED
    144  1a87
    145  1a87				   ioInvalidDevice
    146  1a87		       68		      pla		; Remove return address of IO interface
    147  1a88		       68		      pla
    148  1a89		       38		      sec		; ensure that carry is set
    149  1a8a		       60		      rts
    150  1a8b
    151  1a8b				   ioValidDevice
    152  1a8b		       18		      clc
    153  1a8c		       60		      rts
    154  1a8d							;
    155  1a8d							;===================================================================================
    156  1a8d							; Set the io device jmp vectors
    157  1a8d							; input x contains the vector to the active Device IO Block
    158  1a8d							; output a, x undefined y unchanged
    159  1a8d				   ioSetDeviceVectors
    160  1a8d		       ec 74 36 	      cpx	BActiveDevice	; Check if already set
    161  1a90		       f0 1b		      beq	ioSetDevExit	; if already set then do nothing
    162  1a92
    163  1a92		       8e 74 36 	      stx	BActiveDevice	; set the active device vector
    164  1a95		       98		      tya
    165  1a96		       48		      pha
    166  1a97
    167  1a97		       bc f3 19 	      ldy	DeviceIoBlocks+2,x	; Get the device driver index
    168  1a9a		       8c 75 36 	      sty	BActiveDriver	; Pointer to active Device driver
    169  1a9d		       a2 00		      ldx	#0	; Transfer the 6 pointers to the Vectors
    170  1a9f				   ioSetDevLoop
    171  1a9f		       b9 cb 19 	      lda	DeviceDriverBlocks+2,y
    172  1aa2		       9d 6e 36 	      sta	BInVec,x
    173  1aa5		       e8		      inx
    174  1aa6		       c8		      iny
    175  1aa7		       e0 06		      cpx	#IO_VECT_LEN	; Transfer the vector length to copy
    176  1aa9		       d0 f4		      bne	ioSetDevLoop
    177  1aab
    178  1aab		       68		      pla
    179  1aac		       a8		      tay
    180  1aad				   ioSetDevExit
    181  1aad		       60		      rts
    182  1aae							;
    183  1aae							;======================================================================
    184  1aae							; Generic call interface for devices
    185  1aae							; input x = DeviceIoBlockIndex
    186  1aae							; Carry set if error, x contains the error code
    187  1aae							; all other parameters are dependant upon the actual device interface
    188  1aae							;
    189  1aae							; ioPutCH  a contains the character to send
    190  1aae		       20 6c 1a    ioPutCH    jsr	ioValidateDevice
    191  1ab1		       48		      pha
    192  1ab2		       20 8d 1a 	      jsr	ioSetDeviceVectors
    193  1ab5		       68		      pla
    194  1ab6		       20 63 1a 	      jsr	VOUTCH
    195  1ab9		       18		      clc
    196  1aba		       60		      rts
    197  1abb
    198  1abb							; io Getch returns the character read from device
    199  1abb		       20 6c 1a    ioGetCH    jsr	ioValidateDevice
    200  1abe
    201  1abe		       60		      rts
    202  1abf							;
    203  1abf							;======================================================================
    204  1abf							;TTY interface functions,
    205  1abf							;	a contains the character to send
    206  1abf							;	x contains the Device ID (equals index into io blocks)	of the io block to used
    207  1abf							;
    208  1abf				   SerialIn
    209  1abf
    210  1abf				   SerialOut
    211  1abf
    212  1abf				   SerialStatus
    213  1abf		       60		      rts
    214  1ac0							;
    215  1ac0							;======================================================================
    216  1ac0							; Date/Time clock interface
    217  1ac0				   ClockRead
    218  1ac0
    219  1ac0				   ClockWrite
    220  1ac0		       60		      rts
    221  1ac1							;
    222  1ac1							;======================================================================
    223  1ac1							;
    224  1ac1				   TimerStart
    225  1ac1
    226  1ac1				   TimerStop
    227  1ac1
    228  1ac1				   TimerStatus
    229  1ac1		       60		      rts
    230  1ac2
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  1ac2					      include	"tokenizer.asm"
      1  1ac2					      seg	Code
      2  1ac2		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  1ac2
      4  1ac2							; Define the types of tokens found, and identifiers
      5  1ac2		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  1ac2		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  1ac2		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  1ac2		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  1ac2
     10  1ac2		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  1ac2		       00 9c	   tVhash     equ	$9C	; Variable #
     12  1ac2		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  1ac2
     14  1ac2							; Base variable type supported by This basic
     15  1ac2							; Unsigned types always have the 0 bit set to 1
     16  1ac2		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     17  1ac2		       00 a2	   tByte      equ	$A2	; Signed Byte value
     18  1ac2		       00 a4	   tInteger   equ	$A4	; all tokenized integers start with 251 as first byte 16 bit signed number
     19  1ac2		       00 a6	   tLong      equ	$A6	; Signed 32 bit integer
     20  1ac2
     21  1ac2		       00 a1	   tArray     equ	$A1	; Identifies Array Type, the byte following defines the length of each element
     22  1ac2							; Arrays of string are arrays of pointers 2 bytes each
     23  1ac2		       00 a3	   tPointer   equ	$A3	; Pointer  unsigned 16 bit
     24  1ac2		       00 a5	   tIndirect  equ	$A5	; Points to an address that points to the data 16 bits
     25  1ac2		       00 a7	   tuByte     equ	$A7	; Unsigned byte value 8 bit unsigned value
     26  1ac2		       00 a9	   tUint      equ	$A9	; unsigned integer type 16 bit
     27  1ac2		       00 ab	   tUlong     equ	$AB	; Unsigned 32 bit integer
     28  1ac2
     29  1ac2		       3c 3e	   Operators  BYTE.b	"<>"
     30  1ac4		       3c 3d		      BYTE.b	"<="
     31  1ac6		       3e 3d		      BYTE.b	">="
     32  1ac8		       3c 3c		      Byte.b	"<<"
     33  1aca		       3e 3e		      Byte.b	">>"
     34  1acc		       3c 00		      BYTE.b	"<",0
     35  1ace		       3d 00		      BYTE.b	"=",0
     36  1ad0		       3e 00		      BYTE.b	">",0
     37  1ad2		       2b 2b		      Byte.b	"++"
     38  1ad4		       2b 00		      BYTE.b	"+",0
     39  1ad6		       2d 2d		      Byte.b	"--"
     40  1ad8		       2d 00		      BYTE.b	"-",0
     41  1ada		       2f 00		      BYTE.b	"/",0
     42  1adc		       25 00		      BYTE.b	"%",0
     43  1ade		       2a 00		      BYTE.b	"*",0
     44  1ae0		       28 00		      BYTE.b	"(",0
     45  1ae2		       29 00		      BYTE.b	")",0
     46  1ae4		       2c 00		      BYTE.b	",",0
     47  1ae6		       3b 00		      BYTE.b	";",0
     48  1ae8		       5b 00		      BYTE.b	"[",0
     49  1aea		       5d 00		      BYTE.b	"]",0
     50  1aec		       3a 00		      BYTE.b	":",0
     51  1aee		       24 00		      BYTE.b	"$",0
     52  1af0		       21 00		      BYTE.b	"!",0
     53  1af2		       3f 00		      BYTE.b	"?",0
     54  1af4		       2e 00		      BYTE.b	".",0
     55  1af6		       26 00		      BYTE.b	"&",0
     56  1af8		       27 00		      Byte.b	"'",0
     57  1afa		       7c 00		      Byte.b	"|",0
     58  1afc		       7e 00		      Byte.b	"~",0
     59  1afe		       00 00		      BYTE.b	0,0
     60  1b00
     61  1b00		       f5 f3 f6 29*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oSHL,oSHR,oLess,oEqual,oGreater
     62  1b08		       02 ea 03 eb*	      BYTE.b	oINC, oPlus, oDEC, oMinus, oDivide, oModulo, oMultiply
     63  1b0f		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     64  1b15		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod, oAmphistan, oQuote, oBar,oTilde
     65  1b1e
     66  1b1e		       00 0b	   oQuestion  equ	kPrint
     67  1b1e							;    2 is =
     68  1b1e							;    1 is <
     69  1b1e							;    3 is <=
     70  1b1e							;    5 is <>
     71  1b1e							;    4 is >
     72  1b1e							;    6 is >=
     73  1b1e		       00 f1	   oLess      equ	$F1
     74  1b1e		       00 f2	   oEqual     equ	$F2
     75  1b1e		       00 f3	   oLessEqual equ	$F3
     76  1b1e		       00 f4	   oGreater   equ	$F4
     77  1b1e		       00 f5	   oNotEqual  equ	$F5
     78  1b1e		       00 f6	   oGreaterEqual equ	$F6
     79  1b1e
     80  1b1e		       00 e0	   oLeftBracket equ	$E0
     81  1b1e		       00 e1	   oRightBracket equ	$E1
     82  1b1e		       00 e2	   oComma     equ	$E2
     83  1b1e		       00 e3	   oSemiColon equ	$E3
     84  1b1e		       00 e4	   oLeftSQBracket equ	$E4
     85  1b1e		       00 e5	   oRightSQBracket equ	$E5
     86  1b1e		       00 e6	   oColon     equ	$E6
     87  1b1e		       00 e7	   oDollar    equ	$E7
     88  1b1e		       00 e8	   oBang      equ	$E8
     89  1b1e		       00 e9	   oPeriod    equ	$E9
     90  1b1e
     91  1b1e
     92  1b1e		       00 ea	   oPlus      equ	$EA
     93  1b1e		       00 eb	   oMinus     equ	$EB
     94  1b1e		       00 ec	   oDivide    equ	$EC
     95  1b1e		       00 ed	   oModulo    equ	$ED
     96  1b1e		       00 ee	   oMultiply  equ	$EE
     97  1b1e
     98  1b1e		       00 ed	   oPercent   equ	oModulo
     99  1b1e		       00 27	   oAmphistan equ	kAnd
    100  1b1e		       00 25	   oBar       equ	kOr
    101  1b1e		       00 0a	   oQuote     equ	kRem
    102  1b1e		       00 26	   oTilde     equ	kXor
    103  1b1e		       00 28	   oSHR       equ	kShr
    104  1b1e		       00 29	   oSHL       equ	kShl
    105  1b1e		       00 02	   oINC       equ	kInc
    106  1b1e		       00 03	   oDEC       equ	kDec
    107  1b1e
    108  1b1e		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
    109  1b1e
    110  1b1e		       00 ff	   tError     equ	$FF	; Error should never happen
    111  1b1e							;============================================================================================
    112  1b1e							; Keyword and seperator values
    113  1b1e				   '
    114  1b1e		       00 01	   kBeginKey  equ	kLet
    115  1b1e							;
    116  1b1e		       00 01	   kLet       equ	1
    117  1b1e		       00 02	   kInc       equ	kLet+1
    118  1b1e		       00 03	   kDec       equ	kInc+1
    119  1b1e		       00 04	   kIreturn   equ	kDec+1
    120  1b1e		       00 05	   kIf	      equ	kIreturn+1
    121  1b1e		       00 06	   kThen      equ	kIf+1
    122  1b1e		       00 07	   kGoto      equ	kThen+1
    123  1b1e		       00 08	   kGosub     equ	kGoto+1
    124  1b1e		       00 09	   kReturn    equ	kGosub+1
    125  1b1e		       00 0a	   kRem       equ	kReturn+1
    126  1b1e		       00 0b	   kPrint     equ	kRem+1
    127  1b1e		       00 0c	   kTaske     equ	kPrint+1
    128  1b1e		       00 0d	   kTaskn     equ	kTaske+1
    129  1b1e		       00 0e	   kTaskw     equ	kTaskn+1
    130  1b1e		       00 0f	   kPoke      equ	kTaskw+1
    131  1b1e		       00 10	   kPutch     equ	kPoke+1
    132  1b1e		       00 11	   kCls       equ	kPutch+1
    133  1b1e		       00 12	   kInput     equ	kCls+1
    134  1b1e		       00 13	   kEnd       equ	kInput+1
    135  1b1e		       00 14	   kIrq       equ	kEnd+1
    136  1b1e		       00 15	   kKill      equ	kIrq+1
    137  1b1e		       00 16	   kList      equ	kKill+1
    138  1b1e		       00 17	   kRun       equ	kList+1
    139  1b1e		       00 18	   kNew       equ	kRun+1
    140  1b1e		       00 19	   kSlice     equ	kNew+1
    141  1b1e		       00 1a	   kTrace     equ	kSlice+1
    142  1b1e		       00 1b	   kExit      equ	kTrace+1
    143  1b1e		       00 1c	   kSave      equ	kExit+1
    144  1b1e		       00 1d	   kLoad      equ	kSave+1
    145  1b1e		       00 1e	   kErase     equ	kLoad+1
    146  1b1e		       00 1f	   kDir       equ	kErase+1
    147  1b1e		       00 20	   kSetTerm   equ	kDir+1
    148  1b1e		       00 21	   kSetMemB   equ	kSetTerm+1
    149  1b1e		       00 22	   kSetMemW   equ	kSetMemB+1
    150  1b1e		       00 23	   kCopyMem   equ	kSetMemW+1
    151  1b1e							;
    152  1b1e							; End of actual key words
    153  1b1e							;
    154  1b1e		       00 22	   kKeyCount  equ	kCopyMem-kBeginKey
    155  1b1e							;
    156  1b1e							; Logical operators
    157  1b1e							;
    158  1b1e		       00 24	   kNot       equ	kCopyMem+1
    159  1b1e		       00 25	   kOr	      equ	kNot+1
    160  1b1e		       00 26	   kXor       equ	kOr+1
    161  1b1e		       00 27	   kAnd       equ	kXor+1
    162  1b1e							;
    163  1b1e							; Shift operators
    164  1b1e							;
    165  1b1e		       00 28	   kShr       equ	kAnd+1
    166  1b1e		       00 29	   kShl       equ	kShr+1
    167  1b1e
    168  1b1e							; numeric functions
    169  1b1e							;
    170  1b1e		       00 2a	   kBeginFunc equ	kTrue
    171  1b1e							;
    172  1b1e							; Truth operators
    173  1b1e							;
    174  1b1e		       00 2a	   kTrue      equ	kShl+1
    175  1b1e		       00 2b	   kFalse     equ	kTrue+1
    176  1b1e							; Functions
    177  1b1e		       00 2c	   kFree      equ	kFalse+1
    178  1b1e		       00 2d	   kGetch     equ	kFree+1
    179  1b1e		       00 2e	   kPeek      equ	kGetch+1
    180  1b1e		       00 2f	   kTask      equ	kPeek+1
    181  1b1e		       00 30	   kIpcc      equ	kTask+1
    182  1b1e		       00 31	   kIpcs      equ	kIpcc+1
    183  1b1e		       00 32	   kIpcr      equ	kIpcs+1
    184  1b1e		       00 33	   kRnd       equ	kIpcr+1
    185  1b1e		       00 34	   kStat      equ	kRnd+1
    186  1b1e		       00 35	   kAbs       equ	kStat+1
    187  1b1e		       00 36	   kCall      equ	kAbs+1
    188  1b1e		       00 37	   kGofn      equ	kCall+1
    189  1b1e		       00 38	   kPid       equ	kGofn+1
    190  1b1e		       00 39	   kAddr      equ	kPid+1
    191  1b1e		       00 3a	   kCmpMem    equ	kAddr+1
    192  1b1e		       00 3b	   kTimer     equ	kCmpMem+1
    193  1b1e							;
    194  1b1e		       00 12	   kFuncCount equ	((kTimer - kBeginFunc) + 1)
    195  1b1e
    196  1b1e							;
    197  1b1e							; Keyword table contains 54 keywords
    198  1b1e				   KeyWordTable
      0  1b1e					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  1b1e		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  1b22					      db	kInc,"inC"
      1  1b22		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  1b26					      db	kDec,"deC"
      1  1b26		       03 64 65 43	      .byte.b	kDec,"deC"
      0  1b2a					      db	kIreturn,"ireturN"
      1  1b2a		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  1b32					      db	kIf,"iF"
      1  1b32		       05 69 46 	      .byte.b	kIf,"iF"
      0  1b35					      db	kThen,"theN"
      1  1b35		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  1b3a					      db	kGoto,"gotO"
      1  1b3a		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  1b3f					      db	kGosub,"gosuB"
      1  1b3f		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  1b45					      db	kReturn,"returN"
      1  1b45		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  1b4c					      db	kRem,"reM"
      1  1b4c		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  1b50					      db	kPrint,"prinT"
      1  1b50		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  1b56					      db	kTaske,"taskE"
      1  1b56		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  1b5c					      db	kTaskn,"taskN"
      1  1b5c		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  1b62					      db	kTaskw,"taskW"
      1  1b62		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  1b68					      db	kPoke,"pokE"
      1  1b68		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  1b6d					      db	kPutch,"putcH"
      1  1b6d		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  1b73					      db	kCls,"clS"
      1  1b73		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  1b77					      db	kInput,"inpuT"
      1  1b77		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  1b7d					      db	kEnd,"enD"
      1  1b7d		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  1b81					      db	kIrq,"irQ"
      1  1b81		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  1b85					      db	kKill,"kilL"
      1  1b85		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  1b8a					      db	kList,"lisT"
      1  1b8a		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  1b8f					      db	kRun,"ruN"
      1  1b8f		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  1b93					      db	kNew,"neW"
      1  1b93		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  1b97					      db	kSlice,"slicE"
      1  1b97		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  1b9d					      db	kTrace,"tracE"
      1  1b9d		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  1ba3					      db	kExit,"exiT"
      1  1ba3		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  1ba8					      db	kSave,"savE"
      1  1ba8		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  1bad					      db	kLoad,"loaD"
      1  1bad		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  1bb2					      db	kErase,"erasE"
      1  1bb2		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  1bb8					      db	kDir,"diR"
      1  1bb8		       1f 64 69 52	      .byte.b	kDir,"diR"
    230  1bbc							;Short form for statements:
      0  1bbc					      db	kIreturn,"ireT"
      1  1bbc		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  1bc1					      db	kReturn,"reT"
      1  1bc1		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  1bc5					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  1bc5		       0b 70 52 	      .byte.b	kPrint,"pR"
      0  1bc8					      db	kSetTerm, "setterM"
      1  1bc8		       20 73 65 74*	      .byte.b	kSetTerm, "setterM"
      0  1bd0					      db	kSetMemB, "setmemB"
      1  1bd0		       21 73 65 74*	      .byte.b	kSetMemB, "setmemB"
      0  1bd8					      db	kSetMemW, "setmemW"
      1  1bd8		       22 73 65 74*	      .byte.b	kSetMemW, "setmemW"
      0  1be0					      db	kCopyMem, "copymeM"
      1  1be0		       23 63 6f 70*	      .byte.b	kCopyMem, "copymeM"
    238  1be8
    239  1be8							; Shift operators
      0  1be8					      db	kShr,"shR"
      1  1be8		       28 73 68 52	      .byte.b	kShr,"shR"
      0  1bec					      db	kShl,"shL"
      1  1bec		       29 73 68 4c	      .byte.b	kShl,"shL"
    242  1bf0
    243  1bf0							;Logical and truth operators
      0  1bf0					      db	kNot,"noT"
      1  1bf0		       24 6e 6f 54	      .byte.b	kNot,"noT"
      0  1bf4					      db	kOr,"oR"
      1  1bf4		       25 6f 52 	      .byte.b	kOr,"oR"
      0  1bf7					      db	kXor,"xoR"
      1  1bf7		       26 78 6f 52	      .byte.b	kXor,"xoR"
      0  1bfb					      db	kAnd,"anD"
      1  1bfb		       27 61 6e 44	      .byte.b	kAnd,"anD"
    248  1bff
    249  1bff							; Truth values
      0  1bff					      db	kTrue,"truE"
      1  1bff		       2a 74 72 75*	      .byte.b	kTrue,"truE"
      0  1c04					      db	kFalse,"falsE"
      1  1c04		       2b 66 61 6c*	      .byte.b	kFalse,"falsE"
    252  1c0a
    253  1c0a
    254  1c0a
    255  1c0a							;functions returning values
    256  1c0a
      0  1c0a					      db	kFree,"freE"
      1  1c0a		       2c 66 72 65*	      .byte.b	kFree,"freE"
      0  1c0f					      db	kGetch,"getcH"
      1  1c0f		       2d 67 65 74*	      .byte.b	kGetch,"getcH"
      0  1c15					      db	kPeek,"peeK"
      1  1c15		       2e 70 65 65*	      .byte.b	kPeek,"peeK"
      0  1c1a					      db	kTask,"tasK"
      1  1c1a		       2f 74 61 73*	      .byte.b	kTask,"tasK"
      0  1c1f					      db	kIpcc,"ipcC"
      1  1c1f		       30 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  1c24					      db	kIpcs,"ipcS"
      1  1c24		       31 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  1c29					      db	kIpcr,"ipcR"
      1  1c29		       32 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  1c2e					      db	kRnd,"rnD"
      1  1c2e		       33 72 6e 44	      .byte.b	kRnd,"rnD"
      0  1c32					      db	kStat,"staT"
      1  1c32		       34 73 74 61*	      .byte.b	kStat,"staT"
      0  1c37					      db	kAbs,"abS"
      1  1c37		       35 61 62 53	      .byte.b	kAbs,"abS"
      0  1c3b					      db	kCall,"calL"
      1  1c3b		       36 63 61 6c*	      .byte.b	kCall,"calL"
      0  1c40					      db	kGofn,"fN"
      1  1c40		       37 66 4e 	      .byte.b	kGofn,"fN"
      0  1c43					      db	kPid,"piD"
      1  1c43		       38 70 69 44	      .byte.b	kPid,"piD"
      0  1c47					      db	kAddr,"addR"
      1  1c47		       39 61 64 64*	      .byte.b	kAddr,"addR"
      0  1c4c					      db	kCmpMem, "cmpmeM"
      1  1c4c		       3a 63 6d 70*	      .byte.b	kCmpMem, "cmpmeM"
      0  1c53					      db	kTimer,"timeR"
      1  1c53		       3b 74 69 6d*	      .byte.b	kTimer,"timeR"
      0  1c59					      db	0,0
      1  1c59		       00 00		      .byte.b	0,0
    274  1c5b
    275  1c5b		       1c 5b	   KeyWordTableEnd equ	*
    276  1c5b		       01 3d	   KeyWordTableLength equ	* - KeyWordTable
    277  1c5b		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    278  1d5b		       00 00 00    printStorage ds	3
    279  1d5e							;==================================================================================================================
    280  1d5e							; Read accross the inputline and output to TOKENBUFFER
    281  1d5e							; Format   byte      Description
    282  1d5e							;	     0	      length of line 1-255
    283  1d5e							;	    0-1       Line Number
    284  1d5e							;	    Tokens and litteral values encoded into the line
    285  1d5e							;
    286  1d5e							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    287  1d5e							;  if fails then test for keywords
    288  1d5e							;  if fails then test for variables and arrays
    289  1d5e							;  if fails check for operators/seperators  + - < > = % / * () [] , ; : >> <<
    290  1d5e
    291  1d5e				   ParseInputLine
    292  1d5e				  -	      if	DEBUGPARSER
    293  1d5e				  -	      jsr	SetOutDebug
    294  1d5e				  -	      jsr	DebugClearBuffer
    295  1d5e					      endif
    296  1d5e		       a5 51		      lda	CUROFF
    297  1d60		       48		      pha
    298  1d61		       8a		      txa
    299  1d62		       48		      pha
    300  1d63		       98		      tya
    301  1d64		       48		      pha
    302  1d65		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    303  1d67		       20 e4 2a 	      jsr	getDecimal	; Check for a line number, none is ok too
    304  1d6a		       84 51		      sty	CUROFF
    305  1d6c		       20 2a 1f 	      jsr	R02TOKEN	; Move R0 to token buffer
    306  1d6f
    307  1d6f				   ParseInputLoop
    308  1d6f		       a4 51		      ldy	CUROFF
    309  1d71		       20 74 2d 	      jsr	SkipSpaces	; Skip any spaces
    310  1d74		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    311  1d76		       b9 9a 42 	      lda	LINBUF,y	; Check for end of line
    312  1d79		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    313  1d7b
    314  1d7b				   ParseForNumber
    315  1d7b		       20 7e 1e 	      jsr	ParseNumeric	; Check for a numeric value
    316  1d7e		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    317  1d80
    318  1d80				   ParseForString
    319  1d80		       20 54 1e 	      jsr	ParseString	; Check for a string
    320  1d83		       90 ea		      bcc	ParseInputLoop	; It was a string
    321  1d85
    322  1d85				   ParseForOp
    323  1d85		       20 bc 1e 	      jsr	ParseForOperator	; Check for operator or punctuation
    324  1d88		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    325  1d8a
    326  1d8a				   ParseForKey
    327  1d8a		       20 b1 1d 	      jsr	ParseLookupKey	; Check for a keyword value
    328  1d8d		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    329  1d8f
    330  1d8f				   ParseForVar
    331  1d8f		       20 f3 1e 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    332  1d92		       90 db		      bcc	ParseInputLoop
    333  1d94
    334  1d94				   ParseKeepChar		; if it does not parse just keep it safe
    335  1d94		       b9 9a 42 	      lda	LINBUF,y
    336  1d97		       9d 5b 1c 	      sta	TOKENBUFFER,x
    337  1d9a		       e8		      inx
    338  1d9b		       c8		      iny
    339  1d9c		       84 51		      sty	CUROFF
    340  1d9e		       d0 cf		      bne	ParseInputLoop
    341  1da0
    342  1da0				   ParseComplete
    343  1da0		       a9 00		      lda	#0
    344  1da2		       9d 5b 1c 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    345  1da5		       e8		      inx
    346  1da6		       8e 5b 1c 	      stx	TOKENBUFFER	; Place size including null into buffer start
    347  1da9
    348  1da9		       68		      pla
    349  1daa		       a8		      tay
    350  1dab		       68		      pla
    351  1dac		       aa		      tax
    352  1dad		       68		      pla
    353  1dae		       85 51		      sta	CUROFF
    354  1db0
    355  1db0				  -	      if	DEBUGPARSER
    356  1db0				  -
    357  1db0				  -	      jsr	printTokenBuffer
    358  1db0				  -			;jsr	  DebugPrintProgramLine
    359  1db0				  -	      jsr	SetOutDebugEnd
    360  1db0				  -
    361  1db0					      endif
    362  1db0		       60		      rts
    363  1db1
    364  1db1							;==================================================================================================================
    365  1db1							; Look at curptr, curpos and check for a valid KeyWord
    366  1db1							; A contains the index value. c is clear
    367  1db1							;		     not found c set  A undefined
    368  1db1							; X is prerserved
    369  1db1							;
    370  1db1				   ParseLookupKey
    371  1db1		       86 58		      stx	R2
    372  1db3		       a0 00		      ldy	#0
    373  1db5		       a9 1e		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    374  1db7		       85 54		      sta	R1
    375  1db9		       a9 1b		      lda	#KeyWordTable>>8
    376  1dbb		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    377  1dbd		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    378  1dbf		       85 52		      sta	R0	; Save until next keyword
    379  1dc1		       c8		      iny		; Point to first character of keyword
    380  1dc2		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    381  1dc4
    382  1dc4				  -	      if	DEBUGPARSER
    383  1dc4				  -			;    jsr DebugKeyword
    384  1dc4					      endif
    385  1dc4
    386  1dc4				   ParseLookupLoop
    387  1dc4		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    388  1dc6		       29 df		      and	#%11011111	; Force Keyword to upper case
    389  1dc8		       dd 9a 42 	      cmp	LINBUF,x	; Check the input buffer
    390  1dcb		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    391  1dcd		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    392  1dcf		       dd 9a 42 	      cmp	LINBUF,x	; Compare value to upercase
    393  1dd2		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    394  1dd4
    395  1dd4				   ParseNextLetter
    396  1dd4		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    397  1dd6		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    398  1dd8		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    399  1dda		       e8		      inx		; Point to next char in the input buffer
    400  1ddb		       c8		      iny		; Point to the next character in the Keyword table
    401  1ddc		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    402  1dde		       dd 9a 42 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    403  1de1		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    404  1de3		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    405  1de5
    406  1de5				   ParseKeyFound
    407  1de5		       a5 52		      lda	R0	; get the keyword index
    408  1de7
    409  1de7				   ParseKeyDone
    410  1de7		       e8		      inx		; point past the last character
    411  1de8		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    412  1dea		       a6 58		      ldx	R2	; Restore the original x pointer
    413  1dec		       9d 5b 1c 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    414  1def		       e8		      inx		; Point to next position in the output buffer
    415  1df0		       86 58		      stx	R2	; Save next position in buffer
    416  1df2		       c9 0a		      cmp	#kRem	; remark statement
    417  1df4		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    418  1df6		       c9 07		      cmp	#kGoto
    419  1df8		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    420  1dfa		       c9 08		      cmp	#kGosub
    421  1dfc		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    422  1dfe		       c9 37		      cmp	#kGofn
    423  1e00		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    424  1e02		       c9 2f		      cmp	#kTask
    425  1e04		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    426  1e06
    427  1e06		       18		      clc		; C flag clear, we found it
    428  1e07		       60		      rts
    429  1e08
    430  1e08							; Move forward to the next entry in table
    431  1e08				   ParseNextEntry
    432  1e08		       b1 54		      lda	(R1),y	; Get the next character in the token
    433  1e0a		       29 20		      and	#%00100000	; Is it the last character
    434  1e0c		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    435  1e0e		       c8		      iny		; Point to next char in the entry
    436  1e0f		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    437  1e11
    438  1e11				   ParseEndOfEntry
    439  1e11		       c8		      iny		; Point to the byte after the last character
    440  1e12		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    441  1e13		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    442  1e14		       65 54		      adc	R1
    443  1e16		       85 54		      sta	R1
    444  1e18		       a5 55		      lda	R1+1
    445  1e1a		       69 00		      adc	#0
    446  1e1c		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    447  1e1e		       a0 00		      ldy	#0	; Reset the index back to zero
    448  1e20		       b1 54		      lda	(R1),y	; get keyword value
    449  1e22		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    450  1e24		       85 52		      sta	R0	; save the next token value
    451  1e26		       c8		      iny		; Inc past token value
    452  1e27
    453  1e27				  -	      if	DEBUGPARSER
    454  1e27				  -			;    jsr DebugKeyword
    455  1e27					      endif
    456  1e27		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    457  1e29		       4c c4 1d 	      jmp	ParseLookupLoop	; branch back for next key word
    458  1e2c
    459  1e2c				   ParseNoneFound
    460  1e2c		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    461  1e2e		       38		      sec		; c clear, not found
    462  1e2f		       60		      rts
    463  1e30
    464  1e30							;===============================================================================
    465  1e30							; Move everything from current position until the end of line into the token buffer
    466  1e30							;
    467  1e30		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    468  1e32		       a6 58		      ldx	R2	; where to place in the buffer
    469  1e34				   ParseMoveLoop
    470  1e34		       b9 9a 42 	      lda	LINBUF,y	; get the next byte
    471  1e37		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    472  1e39		       9d 5b 1c 	      sta	TOKENBUFFER,x	; save the byte
    473  1e3c		       c8		      iny
    474  1e3d		       e8		      inx
    475  1e3e		       d0 f4		      bne	ParseMoveLoop
    476  1e40				   ParseMoveDone
    477  1e40		       84 51		      sty	CUROFF
    478  1e42		       18		      clc
    479  1e43		       60		      rts
    480  1e44							;================================================================================================
    481  1e44							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    482  1e44							; transfer to a memory address
    483  1e44				   ParseHandleBranches
    484  1e44		       a6 58		      ldx	R2
    485  1e46		       a9 00		      lda	#0
    486  1e48		       9d 5b 1c 	      sta	TOKENBUFFER,x
    487  1e4b		       e8		      inx
    488  1e4c		       9d 5b 1c 	      sta	TOKENBUFFER,x
    489  1e4f		       e8		      inx
    490  1e50		       86 58		      stx	R2
    491  1e52		       18		      clc
    492  1e53		       60		      rts
    493  1e54
    494  1e54							;=========================================================================================================
    495  1e54							;ParseString Parse a quotes string
    496  1e54							; on input X = outbuf position
    497  1e54							; y = inbuf position
    498  1e54							; Copies string to output buffer, updates x and y
    499  1e54				   ParseString
    500  1e54		       a4 51		      ldy	CUROFF
    501  1e56		       a9 a0		      lda	#tString
    502  1e58		       9d 5b 1c 	      sta	TOKENBUFFER,X
    503  1e5b		       b9 9a 42 	      lda	LINBUF,y
    504  1e5e		       c9 22		      cmp	#'"
    505  1e60		       d0 1a		      bne	ParseStringInvalid
    506  1e62		       e8		      inx
    507  1e63		       9d 5b 1c 	      sta	TOKENBUFFER,x
    508  1e66		       e8		      inx
    509  1e67		       c8		      iny
    510  1e68
    511  1e68				   ParseStringLoop
    512  1e68		       b9 9a 42 	      lda	LINBUF,y
    513  1e6b		       9d 5b 1c 	      sta	TOKENBUFFER,x
    514  1e6e		       c9 22		      cmp	#'"
    515  1e70		       f0 04		      beq	ParseStringDone
    516  1e72		       c8		      iny
    517  1e73		       e8		      inx
    518  1e74		       d0 f2		      bne	ParseStringLoop
    519  1e76
    520  1e76				   ParseStringDone
    521  1e76		       e8		      inx
    522  1e77		       c8		      iny
    523  1e78		       84 51		      sty	CUROFF
    524  1e7a		       18		      clc
    525  1e7b		       60		      rts
    526  1e7c
    527  1e7c				   ParseStringInvalid
    528  1e7c		       38		      sec
    529  1e7d		       60		      rts
    530  1e7e
    531  1e7e							;=========================================================================================================
    532  1e7e							; Get numeric values and return value in RO and type in a
    533  1e7e							;
    534  1e7e				   ParseNumeric
    535  1e7e		       a4 51		      ldy	CUROFF
    536  1e80		       b9 9a 42 	      lda	LINBUF,y
    537  1e83		       c9 30		      cmp	#'0
    538  1e85		       90 33		      bcc	ParseNumInvalid
    539  1e87		       c9 3a		      cmp	#'9+1
    540  1e89		       b0 2f		      bcs	ParseNumInvalid
    541  1e8b		       86 58		      stx	R2
    542  1e8d		       20 e4 2a 	      jsr	getDecimal
    543  1e90		       a6 58		      ldx	R2
    544  1e92		       84 51		      sty	CUROFF
    545  1e94		       a5 53		      lda	R0+1
    546  1e96		       f0 14		      beq	ParseByteValue
    547  1e98
    548  1e98				   ParseIntegerValue
    549  1e98		       a9 a4		      lda	#tInteger
    550  1e9a		       9d 5b 1c 	      sta	TOKENBUFFER,x
    551  1e9d		       e8		      inx
    552  1e9e		       a5 52		      lda	R0
    553  1ea0		       9d 5b 1c 	      sta	TOKENBUFFER,x
    554  1ea3		       e8		      inx
    555  1ea4		       a5 53		      lda	R0+1
    556  1ea6		       9d 5b 1c 	      sta	TOKENBUFFER,X
    557  1ea9		       e8		      inx
    558  1eaa		       18		      clc
    559  1eab		       60		      rts
    560  1eac
    561  1eac				   ParseByteValue
    562  1eac		       a9 a2		      lda	#tByte
    563  1eae		       9d 5b 1c 	      sta	TOKENBUFFER,x
    564  1eb1		       e8		      inx
    565  1eb2		       a5 52		      lda	R0
    566  1eb4		       9d 5b 1c 	      sta	TOKENBUFFER,x
    567  1eb7		       e8		      inx
    568  1eb8		       18		      clc
    569  1eb9		       60		      rts
    570  1eba
    571  1eba				   ParseNumInvalid		;Not a valid Numeric
    572  1eba		       38		      sec
    573  1ebb		       60		      rts
    574  1ebc
    575  1ebc							;=========================================================================================================
    576  1ebc							;Parse for operators and seperators
    577  1ebc							; on exit the A has the oper code, c is clear
    578  1ebc							;		 not found then c is set
    579  1ebc							;	x is preserved
    580  1ebc							;
    581  1ebc				   ParseForOperator
    582  1ebc		       86 58		      stx	R2
    583  1ebe		       a4 51		      ldy	CUROFF
    584  1ec0		       a2 00		      ldx	#0
    585  1ec2				  -	      if	DEBUGPARSER
    586  1ec2				  -			;	jsr    DebugPrintOP
    587  1ec2					      endif
    588  1ec2
    589  1ec2				   ParseOpLoop
    590  1ec2		       bd c2 1a 	      lda	Operators,x	; First byte of operator
    591  1ec5		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    592  1ec7
    593  1ec7		       d9 9a 42 	      cmp	LINBUF,y	; Check the first byte
    594  1eca		       d0 1c		      bne	ParseOpNext
    595  1ecc
    596  1ecc		       c8		      iny
    597  1ecd
    598  1ecd		       bd c3 1a 	      lda	Operators+1,x
    599  1ed0		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    600  1ed2
    601  1ed2		       d9 9a 42 	      cmp	LINBUF,y
    602  1ed5		       d0 11		      bne	ParseOpNext
    603  1ed7
    604  1ed7				   ParseOpFound
    605  1ed7		       c8		      iny
    606  1ed8
    607  1ed8				   ParseOpFoundSingle
    608  1ed8		       84 51		      sty	CUROFF
    609  1eda
    610  1eda		       8a		      txa
    611  1edb		       4a		      lsr
    612  1edc		       aa		      tax
    613  1edd		       bd 00 1b 	      lda	OperValues,x
    614  1ee0		       a6 58		      ldx	R2
    615  1ee2		       9d 5b 1c 	      sta	TOKENBUFFER,x
    616  1ee5		       e8		      inx
    617  1ee6		       18		      clc
    618  1ee7		       60		      rts
    619  1ee8
    620  1ee8				   ParseOpNext
    621  1ee8		       e8		      inx
    622  1ee9		       e8		      inx
    623  1eea
    624  1eea				  -	      if	DEBUGPARSER
    625  1eea				  -			;	 jsr	DebugPrintOP
    626  1eea					      endif
    627  1eea		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    628  1eec		       4c c2 1e 	      jmp	ParseOpLoop
    629  1eef
    630  1eef				   ParseOpNotFound
    631  1eef		       a6 58		      ldx	R2
    632  1ef1		       38		      sec
    633  1ef2		       60		      rts
    634  1ef3							;=========================================================================================================
    635  1ef3				  -	      if	DEBUGPARSER
    636  1ef3				  -			;Print the text of a keyword
    637  1ef3				  -			;Input R1    = offset into table
    638  1ef3				  -DebugKeyword
    639  1ef3				  -	      tya
    640  1ef3				  -	      pha
    641  1ef3				  -	      ldy	#1
    642  1ef3				  -DebugKeyLoop
    643  1ef3				  -	      lda	(R1),y
    644  1ef3				  -	      jsr	VOUTCH
    645  1ef3				  -	      and	#%00100000
    646  1ef3				  -	      beq	DebugKeyDone
    647  1ef3				  -	      iny
    648  1ef3				  -	      bne	DebugKeyLoop
    649  1ef3				  -
    650  1ef3				  -DebugKeyDone
    651  1ef3				  -	      jsr	CRLF
    652  1ef3				  -	      pla
    653  1ef3				  -	      tay
    654  1ef3				  -	      rts
    655  1ef3				  -			;========================================
    656  1ef3				  -DebugPrintOP
    657  1ef3				  -	      pha
    658  1ef3				  -	      lda	Operators,x
    659  1ef3				  -	      jsr	VOUTCH
    660  1ef3				  -	      lda	Operators+1,x
    661  1ef3				  -	      beq	DbgPrtOpDone
    662  1ef3				  -	      jsr	VOUTCH
    663  1ef3				  -
    664  1ef3				  -DbgPrtOpDone
    665  1ef3				  -	      jsr	CRLF
    666  1ef3				  -	      pla
    667  1ef3				  -	      rts
    668  1ef3				  -			;=======================================
    669  1ef3				  -DebugClearBuffer
    670  1ef3				  -	      txa
    671  1ef3				  -	      pha
    672  1ef3				  -	      ldx	#$FF
    673  1ef3				  -	      lda	#0
    674  1ef3				  -DebugClrLoop
    675  1ef3				  -	      sta	TOKENBUFFER,x
    676  1ef3				  -	      dex
    677  1ef3				  -	      bne	DebugClrLoop
    678  1ef3				  -	      sta	TOKENBUFFER,x
    679  1ef3				  -	      pla
    680  1ef3				  -	      tax
    681  1ef3				  -	      rts
    682  1ef3				  -
    683  1ef3				  -			;=====================================================
    684  1ef3				  -			; Print the parser buffer as hex values
    685  1ef3				  -printTokenBuffer
    686  1ef3				  -	      stx	printStorage
    687  1ef3				  -	      sty	printStorage+1
    688  1ef3				  -	      sta	printStorage+2
    689  1ef3				  -
    690  1ef3				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    691  1ef3				  -	      inx		; we want to show the last zero byte
    692  1ef3				  -	      ldy	#0
    693  1ef3				  -
    694  1ef3				  -printHexLoop
    695  1ef3				  -	      lda	TOKENBUFFER,y	; get the character
    696  1ef3				  -	      jsr	HexToOut	; print it
    697  1ef3				  -	      lda	#$20
    698  1ef3				  -	      jsr	VOUTCH
    699  1ef3				  -	      iny
    700  1ef3				  -	      dex
    701  1ef3				  -	      cpx	#0
    702  1ef3				  -	      bne	printHexLoop
    703  1ef3				  -	      jsr	CRLF
    704  1ef3				  -
    705  1ef3				  -	      ldy	printStorage+1
    706  1ef3				  -	      ldx	printStorage
    707  1ef3				  -	      lda	printStorage+2
    708  1ef3				  -printHexDone
    709  1ef3				  -	      clc
    710  1ef3				  -	      rts
    711  1ef3					      endif
    712  1ef3
    713  1ef3
    714  1ef3							;=========================================================================================================
    715  1ef3							; Parse for variables A-Z @, ^  x!x x[op]
    716  1ef3				   ParseForVariable
    717  1ef3		       a4 51		      ldy	CUROFF
    718  1ef5		       b9 9a 42 	      lda	LINBUF,y
    719  1ef8		       c9 5e		      cmp	#'^	; is it an exit code
    720  1efa		       d0 04		      bne	ParseVarMem
    721  1efc		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    722  1efe		       d0 1f		      bne	ParseVarSpecial
    723  1f00
    724  1f00				   ParseVarMem
    725  1f00		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    726  1f02		       d0 04		      bne	ParseVarStack
    727  1f04		       a9 9d		      lda	#tVat
    728  1f06		       d0 17		      bne	ParseVarSpecial
    729  1f08
    730  1f08				   ParseVarStack
    731  1f08		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    732  1f0a		       d0 04		      bne	ParseVarLetters
    733  1f0c		       a9 9c		      lda	#tVhash
    734  1f0e		       d0 0f		      bne	ParseVarSpecial
    735  1f10
    736  1f10				   ParseVarLetters
    737  1f10		       29 df		      and	#%11011111	; Force upper case
    738  1f12		       c9 41		      cmp	#'A
    739  1f14		       90 12		      bcc	ParseVarInvalid
    740  1f16		       c9 5b		      cmp	#'Z+1
    741  1f18		       b0 0e		      bcs	ParseVarInvalid
    742  1f1a							;
    743  1f1a							; The condition is true, so convert to an index, push
    744  1f1a							; it onto the stack and continue running.
    745  1f1a							;
    746  1f1a		       38		      sec
    747  1f1b		       e9 41		      sbc	#'A	;index is zero based
    748  1f1d		       09 80		      ora	#$80
    749  1f1f
    750  1f1f				   ParseVarSpecial
    751  1f1f		       9d 5b 1c 	      sta	TOKENBUFFER,x
    752  1f22		       e8		      inx
    753  1f23		       c8		      iny
    754  1f24		       84 51		      sty	CUROFF
    755  1f26		       18		      clc
    756  1f27		       60		      rts
    757  1f28
    758  1f28				   ParseVarInvalid
    759  1f28		       38		      sec
    760  1f29		       60		      rts
    761  1f2a
    762  1f2a
    763  1f2a							;=========================================================================================================
    764  1f2a							; Transfer R0 to the TOKENBUFFER
    765  1f2a							;
    766  1f2a				   R02TOKEN
    767  1f2a		       a5 52		      lda	R0
    768  1f2c		       9d 5b 1c 	      sta	TOKENBUFFER,x
    769  1f2f		       e8		      inx
    770  1f30		       a5 53		      lda	R0+1
    771  1f32		       9d 5b 1c 	      sta	TOKENBUFFER,x
    772  1f35		       e8		      inx
    773  1f36		       18		      clc
    774  1f37		       60		      rts
    775  1f38							;=========================================================================
    776  1f38							; Transfer word in Token Buffer to R0
    777  1f38				   TOKEN2R0
    778  1f38		       b9 5b 1c 	      lda	TOKENBUFFER,y
    779  1f3b		       85 52		      sta	R0
    780  1f3d		       c8		      iny
    781  1f3e		       ca		      dex
    782  1f3f		       b9 5b 1c 	      lda	TOKENBUFFER,y
    783  1f42		       c8		      iny
    784  1f43		       ca		      dex
    785  1f44		       85 53		      sta	R0+1
    786  1f46		       60		      rts
    787  1f47							;==========================================================================
    788  1f47							; Transfer	Display Buffer position to R0
    789  1f47							;
    790  1f47				   DPL2R0
    791  1f47		       b1 59		      lda	(dpl),y
    792  1f49		       85 52		      sta	R0
    793  1f4b		       c8		      iny
    794  1f4c		       ca		      dex
    795  1f4d		       b1 59		      lda	(dpl),y
    796  1f4f		       c8		      iny
    797  1f50		       ca		      dex
    798  1f51		       85 53		      sta	R0+1
    799  1f53		       60		      rts
    800  1f54
    801  1f54
    802  1f54							;=========================================================================
    803  1f54							; Read an IL byte lookit up in the table, of words
    804  1f54							; set the next ilpc to point to that address
    805  1f54							; if not found then do ussual filter stuff
    806  1f54							; ongoto ilvectortable, not found address
    807  1f54		       20 35 2a    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    808  1f57		       86 52		      stx	R0
    809  1f59		       85 53		      sta	R0+1
    810  1f5b
    811  1f5b		       a4 51		      ldy	CUROFF
    812  1f5d		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    813  1f5f		       a0 00		      ldy	#0
    814  1f61		       38		      sec
    815  1f62		       f1 52		      sbc	(R0),y	; Subract the base value
    816  1f64		       c8		      iny
    817  1f65		       d1 52		      cmp	(R0),y	; Check if we are in range
    818  1f67		       b0 12		      bcs	iOnGotoInvalid
    819  1f69		       e6 51		      inc	CUROFF	; Save the offset
    820  1f6b
    821  1f6b		       0a		      asl
    822  1f6c		       a8		      tay		; Turn into vector
    823  1f6d		       c8		      iny		; Inc must include the table base and entry count
    824  1f6e		       c8		      iny
    825  1f6f
    826  1f6f		       b1 52		      lda	(R0),y
    827  1f71		       85 43		      sta	ILPC
    828  1f73		       c8		      iny
    829  1f74		       b1 52		      lda	(R0),y
    830  1f76		       85 44		      sta	ILPC+1
    831  1f78		       4c b1 02 	      jmp	NextIL
    832  1f7b
    833  1f7b				   iOnGotoInvalid
    834  1f7b		       20 35 2a 	      jsr	getILWord
    835  1f7e		       86 43		      stx	ILPC
    836  1f80		       85 44		      sta	ILPC+1
    837  1f82		       4c b1 02 	      jmp	NextIL
    838  1f85							;
    839  1f85							;==========================================================================================
    840  1f85							; Test the token for relop and push the value onto the stack if true
    841  1f85							;
    842  1f85				   iTSTRELOP
    843  1f85		       20 39 2a 	      jsr	getILByte
    844  1f88		       8d 2f 43 	      sta	offset
    845  1f8b
    846  1f8b		       a4 51		      ldy	CUROFF
    847  1f8d		       b1 4f		      lda	(CURPTR),y
    848  1f8f		       48		      pha
    849  1f90		       29 f0		      and	#$F0
    850  1f92		       c9 f0		      cmp	#$F0
    851  1f94		       d0 12		      bne	iTSTRELOPNOT
    852  1f96		       68		      pla
    853  1f97		       29 0f		      and	#$0F	; get the actual value
    854  1f99		       85 52		      sta	R0	; save it for later
    855  1f9b		       a9 00		      lda	#0
    856  1f9d		       85 53		      sta	R0+1
    857  1f9f		       20 32 2c 	      jsr	pushR0
    858  1fa2		       c8		      iny
    859  1fa3		       84 51		      sty	CUROFF	; save the y pointer
    860  1fa5		       4c b1 02 	      jmp	NextIL
    861  1fa8
    862  1fa8				   iTSTRELOPNOT
    863  1fa8		       68		      pla
    864  1fa9		       4c e0 0b 	      jmp	tstBranch
    865  1fac
    866  1fac							;
    867  1fac							;===================================================================================================
    868  1fac							; Test the token and following info for precompiled address information
    869  1fac							; skip it if zero, transfer and skip next integer value if not zero
    870  1fac							; used by both gosub, goto and gofN
    871  1fac							;
    872  1fac				   iTSTBRANCH		; il format TSTBRANCH whereToGoIfFailed
    873  1fac		       20 39 2a 	      jsr	getILByte	; Get jump address if vector is valid
    874  1faf		       8d 2f 43 	      sta	offset	; Mark offset for later if vector found
    875  1fb2		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    876  1fb4		       88		      dey		; point back to the type of branch
    877  1fb5		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    878  1fb7		       48		      pha		; Save till needed
    879  1fb8		       c8		      iny		; back to memory vectors
    880  1fb9				   ITSTBRANCHCont
    881  1fb9		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    882  1fbb		       85 52		      sta	R0	; R0 will contain mem pointer of present
    883  1fbd		       c8		      iny		; Point to next byte of mem vector
    884  1fbe		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    885  1fc0		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    886  1fc2		       c8		      iny		; Point to the byte past memory vector
    887  1fc3		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    888  1fc5
    889  1fc5		       05 52		      ora	R0	; Get the second byte of the mem
    890  1fc7		       f0 28		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    891  1fc9		       68		      pla
    892  1fca		       c9 07		      cmp	#kGoto	; Short cut lots if a goto stuff
    893  1fcc		       d0 03		      bne	NotGoto
    894  1fce		       4c dc 04 	      jmp	FastFastXfer
    895  1fd1				   NotGoto
    896  1fd1		       c9 2f		      cmp	#kTask	; Task defined with Task() so bypass the first bracket
    897  1fd3		       d0 07		      bne	iTSTBRANCHCont
    898  1fd5		       b1 4f		      lda	(CURPTR),y
    899  1fd7		       c9 e0		      cmp	#oLeftBracket
    900  1fd9		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    901  1fdb		       c8		      iny		; Increment past the bracket
    902  1fdc				   iTSTBRANCHCont
    903  1fdc		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    904  1fde		       c9 a2		      cmp	#tByte	; A byte value is valid
    905  1fe0		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    906  1fe2		       c9 a4		      cmp	#tInteger	; An integer value is valid
    907  1fe4		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    908  1fe6		       c8		      iny		; skip type indicator for
    909  1fe7				   ITSTBRANCHBYTE
    910  1fe7		       c8		      iny		; skip first byte of value line number
    911  1fe8		       c8		      iny		; Skip second byte of line number
    912  1fe9
    913  1fe9				   iTSTBRANCHVALID
    914  1fe9		       84 51		      sty	CUROFF
    915  1feb		       20 32 2c 	      jsr	pushR0	; place transfer address on top of stack
    916  1fee		       4c e0 0b 	      jmp	tstBranch
    917  1ff1
    918  1ff1				   iTSTBRANCHNoCompile
    919  1ff1		       68		      pla
    920  1ff2				   iTSTBRANCHErr
    921  1ff2		       4c b1 02 	      jmp	NextIL
    922  1ff5
    923  1ff5
    924  1ff5
    925  1ff5
    926  1ff5
    927  1ff5
    928  1ff5
    929  1ff5
    930  1ff5
    931  1ff5
------- FILE mytb.asm
------- FILE compile.asm LEVEL 2 PASS 6
      0  1ff5					      include	"compile.asm"
      1  1ff5					      Seg	Code
      2  1ff5							;
      3  1ff5							;=====================================================================
      4  1ff5							; Scan the loaded program just before running and insert memory locations of each
      5  1ff5							; line number branched to. goto gosub, gofn
      6  1ff5							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value}
      7  1ff5				   Compile
      8  1ff5		       a9 00		      lda	#0
      9  1ff7		       85 52		      sta	R0	; keep track of how many errors we find
     10  1ff9		       a5 5b		      lda	RunMode
     11  1ffb		       48		      pha
     12  1ffc		       e6 5b		      inc	RunMode	; force run mode for error reporting
     13  1ffe		       a5 4f		      lda	CURPTR
     14  2000		       48		      pha
     15  2001		       a5 50		      lda	CURPTR+1
     16  2003		       48		      pha
     17  2004		       a5 51		      lda	CUROFF
     18  2006		       48		      pha
     19  2007		       ad 37 43 	      lda	ProgramStart
     20  200a		       85 59		      sta	dpl
     21  200c		       ad 38 43 	      lda	ProgramStart+1
     22  200f		       85 5a		      sta	dpl+1
     23  2011
     24  2011				   CompileLineStart
     25  2011		       a5 59		      lda	dpl
     26  2013		       cd 39 43 	      cmp	ProgramEnd
     27  2016		       d0 07		      bne	CompileContinue
     28  2018		       a5 5a		      lda	dpl+1
     29  201a		       cd 3a 43 	      cmp	ProgramEnd+1
     30  201d		       f0 3f		      beq	CompileComplete
     31  201f
     32  201f				   CompileContinue
     33  201f		       a0 03		      ldy	#3	; first real character in the line
     34  2021
     35  2021				   CompileLoop
     36  2021		       b1 59		      lda	(dpl),y	; get the byte
     37  2023		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     38  2025		       c8		      iny		; Pass this byte
     39  2026		       c9 07		      cmp	#kGoto
     40  2028		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     41  202a		       c9 08		      cmp	#kGosub
     42  202c		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     43  202e		       c9 37		      cmp	#kGofn
     44  2030		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  2032		       c9 2f		      cmp	#kTask
     46  2034		       f0 4c		      beq	CompileField
     47  2036		       c9 0a		      cmp	#kRem
     48  2038		       f0 12		      beq	CompileRem	; Skip until end of line
     49  203a		       c9 a0		      cmp	#tString
     50  203c		       f0 2f		      beq	CompileString
     51  203e		       c9 a4		      cmp	#tInteger
     52  2040		       f0 06		      beq	CompileInteger
     53  2042		       c9 a2		      cmp	#tByte
     54  2044		       f0 03		      beq	CompileByte
     55  2046		       d0 d9		      bne	CompileLoop	; Next character
     56  2048
     57  2048				   CompileInteger
     58  2048		       c8		      iny
     59  2049				   CompileByte
     60  2049		       c8		      iny
     61  204a		       d0 d5		      bne	CompileLoop
     62  204c				   CompileRem
     63  204c				   CompileEndOfLine
     64  204c		       a0 00		      ldy	#0
     65  204e		       b1 59		      lda	(dpl),y
     66  2050		       18		      clc
     67  2051		       65 59		      adc	dpl
     68  2053		       85 59		      sta	dpl
     69  2055		       a9 00		      lda	#0
     70  2057		       65 5a		      adc	dpl+1
     71  2059		       85 5a		      sta	dpl+1
     72  205b
     73  205b		       4c 11 20 	      jmp	CompileLineStart
     74  205e
     75  205e				   CompileComplete
     76  205e		       68		      pla
     77  205f		       85 51		      sta	CUROFF
     78  2061		       68		      pla
     79  2062		       85 50		      sta	CURPTR+1
     80  2064		       68		      pla
     81  2065		       85 4f		      sta	CURPTR
     82  2067		       68		      pla
     83  2068		       85 5b		      sta	RunMode
     84  206a		       a5 52		      lda	R0	; returning the number of errors
     85  206c		       60		      rts
     86  206d
     87  206d
     88  206d				   CompileString
     89  206d		       c8		      iny		; point past first "
     90  206e				   CompileStringLoop
     91  206e		       b1 59		      lda	(dpl),y
     92  2070		       f0 0d		      beq	CompileStrDone2	; end of line
     93  2072		       c9 22		      cmp	#'"	; end of string
     94  2074		       f0 08		      beq	CompileStrDone
     95  2076		       c9 5c		      cmp	#'\	; escape character
     96  2078		       d0 01		      bne	CompileStrNext
     97  207a		       c8		      iny		; skip the escape character
     98  207b				   CompileStrNext
     99  207b		       c8		      iny		; Next character
    100  207c		       d0 f0		      bne	CompileStringLoop	; test for end
    101  207e				   CompileStrDone
    102  207e		       c8		      iny
    103  207f				   CompileStrDone2
    104  207f		       4c 21 20 	      Jmp	CompileLoop
    105  2082							;
    106  2082							;===============================================================
    107  2082							; on entry y points to storage location y+2 points to line number
    108  2082							; on exit y points to line number type
    109  2082
    110  2082		       85 52	   CompileField sta	R0
    111  2084		       98		      tya		; save the y pointer to store the memory value
    112  2085		       48		      pha
    113  2086		       c8		      iny		; Skip over the memory vector
    114  2087		       c8		      iny
    115  2088		       a5 52		      lda	R0
    116  208a		       c9 2f		      cmp	#kTask	; for a task it is the next byte after a bracket
    117  208c		       d0 07		      bne	CompNoBracket
    118  208e
    119  208e		       b1 59		      lda	(dpl),y	; Lets make sure it is a )
    120  2090		       c9 e0		      cmp	#oLeftBracket
    121  2092		       d0 01		      bne	CompNoBracket	; in case of error
    122  2094		       c8		      iny		; skip the bracket
    123  2095
    124  2095				   CompNoBracket
    125  2095		       a9 00		      lda	#0	; In case the value is a byte
    126  2097		       85 53		      sta	R0+1
    127  2099
    128  2099		       b1 59		      lda	(dpl),Y	; get the type of the next byte t something or other
    129  209b		       c9 a2		      cmp	#tByte
    130  209d		       f0 15		      beq	CompByteLoad
    131  209f		       c9 a4		      cmp	#tInteger
    132  20a1		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    133  20a3		       68		      pla
    134  20a4		       4c 21 20 	      jmp	CompileLoop	; Ignore the saved stack
    135  20a7				   CompIntLoad
    136  20a7		       c8		      iny
    137  20a8		       b1 59		      lda	(dpl),y
    138  20aa		       85 52		      sta	R0
    139  20ac		       c8		      iny
    140  20ad		       b1 59		      lda	(dpl),y
    141  20af		       85 53		      sta	R0+1
    142  20b1		       4c b9 20 	      jmp	CompFindLine
    143  20b4				   CompByteLoad
    144  20b4		       c8		      iny
    145  20b5		       b1 59		      lda	(dpl),y
    146  20b7		       85 52		      sta	R0
    147  20b9				   CompFindLine
    148  20b9		       20 7e 2a 	      jsr	findLine
    149  20bc		       f0 1d		      beq	CompFoundLine
    150  20be		       e6 52		      inc	R0	; number of errors
    151  20c0
    152  20c0		       a5 59		      lda	dpl
    153  20c2		       85 4f		      sta	CURPTR
    154  20c4		       a5 5a		      lda	dpl+1
    155  20c6		       85 50		      sta	CURPTR+1
    156  20c8		       84 51		      sty	CUROFF
    157  20ca
    158  20ca		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    159  20cc		       a9 00		      lda	#0
    160  20ce
    161  20ce		       20 27 06 	      jsr	DisplayError
    162  20d1		       20 53 22 	      jsr	PrintProgramLine
    163  20d4
    164  20d4		       68		      pla
    165  20d5		       a8		      tay
    166  20d6		       c8		      iny
    167  20d7		       c8		      iny
    168  20d8		       4c 21 20 	      jmp	CompileLoop
    169  20db
    170  20db				   CompFoundLine
    171  20db		       68		      pla
    172  20dc		       a8		      tay
    173  20dd		       a5 4f		      lda	CURPTR
    174  20df		       91 59		      sta	(dpl),y
    175  20e1		       c8		      iny
    176  20e2		       a5 50		      lda	CURPTR+1
    177  20e4		       91 59		      sta	(dpl),y
    178  20e6		       c8		      iny
    179  20e7		       4c 21 20 	      jmp	CompileLoop
    180  20ea
    181  20ea
    182  20ea
    183  20ea
    184  20ea
    185  20ea
    186  20ea
    187  20ea
    188  20ea
    189  20ea
    190  20ea
    191  20ea
    192  20ea
    193  20ea
    194  20ea
    195  20ea
    196  20ea
    197  20ea
    198  20ea
    199  20ea
    200  20ea
    201  20ea
    202  20ea
    203  20ea
    204  20ea
    205  20ea
    206  20ea
    207  20ea
    208  20ea
    209  20ea
    210  20ea
    211  20ea
    212  20ea
    213  20ea
    214  20ea
    215  20ea
    216  20ea
    217  20ea
    218  20ea
    219  20ea
    220  20ea
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  20ea					      include	"print.asm"
      1  20ea					      Seg	Code
      2  20ea							;---------------------------
      3  20ea							; Print 24-bit decimal number or  16bit unsigned
      4  20ea							; ---------------------------
      5  20ea							; On entry, R0=number to print
      6  20ea							;	     Defaults to pad=0 , y=21 default
      7  20ea							;	     R2 = 1 unsigned 16 bit
      8  20ea							;	     R2 = 0 Signed   16 bit
      9  20ea
     10  20ea							; On entry at PrintDecPadded:
     11  20ea							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  20ea
     13  20ea							; On exit,  A,X,Y,num,pad corrupted
     14  20ea							; Size      129 bytes, Table 24 bytes	--- total 153
     15  20ea							; -----------------------------------------------------------------
     16  20ea
     17  20ea				   PrintDecimal
     18  20ea		       8a		      TXA
     19  20eb		       48		      pha
     20  20ec		       98		      tya
     21  20ed		       48		      pha
     22  20ee		       a9 00		      lda	#0
     23  20f0		       8d 85 21 	      sta	pad
     24  20f3		       a0 15		      LDY	#21	; Offset to powers of ten
     25  20f5		       4c fb 20 	      JMP	PrintDo
     26  20f8
     27  20f8				   PrintDecPadded
     28  20f8		       8e 85 21 	      stx	pad
     29  20fb
     30  20fb				   PrintDo
     31  20fb		       a9 00		      lda	#0
     32  20fd		       85 54		      sta	R1
     33  20ff
     34  20ff		       a5 58		      lda	R2
     35  2101		       c9 a9		      cmp	#tUint
     36  2103		       f0 29		      beq	PrintPos
     37  2105
     38  2105		       a5 53		      lda	R0+1	;MSB has sign
     39  2107		       10 25		      bpl	PrintPos	;it's a positive number;
     40  2109
     41  2109
     42  2109							; Negative numbers need more work.  Invert all the bits,
     43  2109							; then add one.
     44  2109
     45  2109		       a9 2d		      lda	#'-
     46  210b		       20 63 1a 	      jsr	VOUTCH	;print the negative sign
     47  210e
     48  210e		       a9 ff		      lda	#$FF
     49  2110		       85 54		      sta	R1
     50  2112		       a5 52		      lda	R0	;invert bits
     51  2114		       49 ff		      eor	#$ff
     52  2116		       85 52		      sta	R0
     53  2118		       a5 53		      lda	R0+1
     54  211a		       49 ff		      eor	#$ff
     55  211c		       85 53		      sta	R0+1
     56  211e		       a5 54		      lda	R1
     57  2120		       49 ff		      eor	#$ff
     58  2122		       85 54		      sta	R1
     59  2124		       e6 52		      inc	R0	;add one
     60  2126		       d0 06		      bne	PrintPos
     61  2128		       e6 53		      inc	R0+1
     62  212a		       d0 02		      bne	PrintPos
     63  212c		       e6 54		      inc	R1
     64  212e				   PrintPos
     65  212e
     66  212e				   PrDec24Lp1
     67  212e		       a2 ff		      LDX	#$FF
     68  2130		       38		      SEC		; Start with digit=-1
     69  2131				   PrDec24Lp2
     70  2131		       a5 52		      LDA	R0+0
     71  2133		       f9 86 21 	      SBC	PrDec24Tens+0,Y
     72  2136		       85 52		      STA	R0+0	; Subtract current tens
     73  2138		       a5 53		      LDA	R0+1
     74  213a		       f9 87 21 	      SBC	PrDec24Tens+1,Y
     75  213d		       85 53		      STA	R0+1
     76  213f		       a5 54		      LDA	R0+2
     77  2141		       f9 88 21 	      SBC	PrDec24Tens+2,Y
     78  2144		       85 54		      STA	R0+2
     79  2146		       e8		      INX
     80  2147		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     81  2149		       a5 52		      LDA	R0+0
     82  214b		       79 86 21 	      ADC	PrDec24Tens+0,Y
     83  214e		       85 52		      STA	R0+0	; Add current tens back in
     84  2150		       a5 53		      LDA	R0+1
     85  2152		       79 87 21 	      ADC	PrDec24Tens+1,Y
     86  2155		       85 53		      STA	R0+1
     87  2157		       a5 54		      LDA	R0+2
     88  2159		       79 88 21 	      ADC	PrDec24Tens+2,Y
     89  215c		       85 54		      STA	R0+2
     90  215e		       8a		      TXA
     91  215f		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     92  2161		       ad 85 21 	      LDA	pad
     93  2164		       d0 09		      BNE	PrDec24Print
     94  2166		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     95  2168				   PrDec24Digit
     96  2168		       a2 30		      LDX	#'0
     97  216a		       8e 85 21 	      STX	pad	; No more zero padding
     98  216d		       09 30		      ORA	#'0	; Print this digit
     99  216f				   PrDec24Print
    100  216f		       20 63 1a 	      JSR	VOUTCH
    101  2172				   PrDec24Next
    102  2172		       88		      DEY
    103  2173		       88		      DEY
    104  2174		       88		      DEY
    105  2175		       f0 07		      beq	PrDec24LastDigit
    106  2177		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    107  2179		       68		      pla
    108  217a		       a8		      tay
    109  217b		       68		      pla
    110  217c		       aa		      tax
    111  217d		       60		      RTS
    112  217e				   PrDec24LastDigit
    113  217e		       a2 30		      LDX	#'0
    114  2180		       8e 85 21 	      STX	pad	; No more zero padding
    115  2183		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    116  2185
      0  2185				   pad	      db	0
      1  2185		       00		      .byte.b	0
    118  2186
    119  2186				   PrDec24Tens
      0  2186					      dw	1
      1  2186		       01 00		      .word.w	1
      0  2188					      db	(1 / 65536)
      1  2188		       00		      .byte.b	(1 / 65536)
      0  2189					      dw	10
      1  2189		       0a 00		      .word.w	10
      0  218b					      db	(10 / 65536)
      1  218b		       00		      .byte.b	(10 / 65536)
      0  218c					      dw	100
      1  218c		       64 00		      .word.w	100
      0  218e					      db	(100 / 65536)
      1  218e		       00		      .byte.b	(100 / 65536)
      0  218f					      dw	1000
      1  218f		       e8 03		      .word.w	1000
      0  2191					      db	(1000 / 65536)
      1  2191		       00		      .byte.b	(1000 / 65536)
      0  2192					      dw	10000
      1  2192		       10 27		      .word.w	10000
      0  2194					      db	(10000 / 65536)
      1  2194		       00		      .byte.b	(10000 / 65536)
      0  2195					      dw	100000
      1  2195		       a0 86		      .word.w	100000
      0  2197					      db	(100000 / 65536)
      1  2197		       01		      .byte.b	(100000 / 65536)
      0  2198					      dw	1000000
      1  2198		       40 42		      .word.w	1000000
      0  219a					      db	(1000000 / 65536)
      1  219a		       0f		      .byte.b	(1000000 / 65536)
      0  219b					      dw	10000000
      1  219b		       80 96		      .word.w	10000000
      0  219d					      db	(10000000 / 65536)
      1  219d		       98		      .byte.b	(10000000 / 65536)
    136  219e							;=====================================================
    137  219e							; Print character in A as two hex digits to the Console
    138  219e
    139  219e		       48	   HexToOut   pha		;save return value
    140  219f		       48		      pha
    141  21a0		       4a		      lsr		;a  ;move top nibble to bottom
    142  21a1		       4a		      lsr		;a
    143  21a2		       4a		      lsr		;a
    144  21a3		       4a		      lsr		;a
    145  21a4		       20 ad 21 	      jsr	hexta	;output nibble
    146  21a7		       68		      pla
    147  21a8		       20 ad 21 	      jsr	hexta
    148  21ab		       68		      pla		;restore
    149  21ac		       60		      rts
    150  21ad							;
    151  21ad		       29 0f	   hexta      and	#%0001111
    152  21af		       c9 0a		      cmp	#$0a
    153  21b1		       18		      clc
    154  21b2		       30 02		      bmi	hexta1
    155  21b4		       69 07		      adc	#7
    156  21b6		       69 30	   hexta1     adc	#'0	;then fall into...
    157  21b8		       4c 63 1a 	      jmp	VOUTCH
    158  21bb							;
    159  21bb							;=====================================================
    160  21bb							; Print the string that immediately follows the JSR to
    161  21bb							; this function.  Stops when a null byte is found,
    162  21bb							; then returns to the instruction immediately
    163  21bb							; following the null.
    164  21bb							;
    165  21bb							; Thanks to Ross Archer for this code.
    166  21bb							; http://www.6502.org/source/io/primm.htm
    167  21bb							;
    168  21bb
    169  21bb		       68	   tbputs     pla		;Get the low part of "return" address
    170  21bc							;(data start address)
    171  21bc		       85 5e		      sta	PrtFrom
    172  21be		       68		      pla
    173  21bf		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    174  21c1							;(data start address)
    175  21c1							;Note: actually we're pointing one short
    176  21c1		       a0 01	   PSINB      ldy	#1
    177  21c3		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    178  21c5		       e6 5e		      inc	PrtFrom	;update the pointer
    179  21c7		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    180  21c9		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    181  21cb		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    182  21cd							;   Accumulator
    183  21cd		       f0 06		      beq	PSIX1	;don't print the final NULL
    184  21cf		       20 63 1a 	      jsr	VOUTCH	;write it out
    185  21d2		       4c c1 21 	      jmp	PSINB	;back around
    186  21d5		       e6 5e	   PSIX1      inc	PrtFrom
    187  21d7		       d0 02		      bne	PSIX2
    188  21d9		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    189  21db		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    190  21de
    191  21de							;+
    192  21de							;====================================================
    193  21de		       43 2b	   PrtTerm    equ	tempy
    194  21de
    195  21de							; on exit Print Y has the offset to use
    196  21de							; input y =	 addr low
    197  21de							;	 x =	 addr high
    198  21de							;	 a =	 termination string
    199  21de
    200  21de
    201  21de				   PrtQuoted		; Print a quoted string from the current program space
    202  21de		       a9 22		      lda	#'"
    203  21e0		       a4 51		      ldy	CUROFF
    204  21e2		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    205  21e4		       d0 03		      bne	PrtNoInc
    206  21e6		       c8		      iny
    207  21e7		       84 51		      sty	CUROFF
    208  21e9				   PrtNoInc
    209  21e9		       8d 2b 43 	      sta	PrtTerm
    210  21ec
    211  21ec				   PrtPrgString 		; Print a terminated string from the static program space
    212  21ec		       a4 51		      ldy	CUROFF
    213  21ee		       a5 4f		      lda	CURPTR
    214  21f0		       85 5e		      sta	PrtFrom
    215  21f2		       a5 50		      lda	CURPTR+1
    216  21f4		       85 5f		      sta	PrtFrom+1
    217  21f6		       4c 02 22 	      jmp	PrtLoop
    218  21f9
    219  21f9							; Print a string pointed to by x= h, y=l terminated by value in  accumulator
    220  21f9							; Return y as the length
    221  21f9
    222  21f9		       86 5f	   PrtStr     stx	PrtFrom+1
    223  21fb		       84 5e		      sty	PrtFrom
    224  21fd		       8d 2b 43 	      sta	PrtTerm
    225  2200		       a0 00		      ldy	#0
    226  2202							;
    227  2202							; On entry here ptrfrom and prtterm point to area to print
    228  2202							;
    229  2202		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    230  2204		       cd 2b 43 	      cmp	PrtTerm
    231  2207		       f0 0b		      beq	PrtEnd
    232  2209		       c9 00		      cmp	#0	; always end if 0 is found
    233  220b		       f0 07		      beq	PrtEnd
    234  220d		       20 63 1a 	      jsr	VOUTCH
    235  2210		       c8		      iny
    236  2211		       4c 02 22 	      jmp	PrtLoop
    237  2214		       c8	   PrtEnd     iny		;return byte after the write
    238  2215		       60		      rts
    239  2216
    240  2216							;
    241  2216							;=======================================================
    242  2216							; Print all Variables
    243  2216				   PrintAllVars
    244  2216		       a0 00		      ldy	#0
    245  2218		       a9 41		      lda	#'A
    246  221a				   PrintAllVarsLoop
    247  221a		       48		      pha
    248  221b		       b1 41		      lda	(VARIABLES),y
    249  221d		       85 52		      sta	R0
    250  221f		       c8		      iny
    251  2220		       b1 41		      lda	(VARIABLES),y
    252  2222		       85 53		      sta	R0+1
    253  2224
    254  2224		       68		      pla		;get the current letter
    255  2225		       48		      pha
    256  2226		       20 63 1a 	      jsr	VOUTCH
    257  2229		       20 bb 21 	      jsr	puts
      0  222c					      db	"=",0
      1  222c		       3d 00		      .byte.b	"=",0
    259  222e		       68		      pla
    260  222f		       aa		      tax
    261  2230		       e8		      inx
    262  2231		       8a		      txa
    263  2232		       48		      pha		;
    264  2233
    265  2233		       98		      tya
    266  2234		       48		      pha
    267  2235		       20 ea 20 	      jsr	PrintDecimal
    268  2238		       20 bb 21 	      jsr	puts
      0  223b					      db	" ",0
      1  223b		       20 00		      .byte.b	" ",0
    270  223d		       68		      pla
    271  223e		       a8		      tay
    272  223f		       c8		      iny
    273  2240		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    274  2242		       90 d6		      bcc	PrintAllVarsLoop
    275  2244		       20 7d 2d 	      jsr	CRLF
    276  2247
    277  2247		       68		      pla
    278  2248		       60		      rts
    279  2249							;==========================================================================================================
    280  2249							;Debug   Print a Program Line from compile buffer
    281  2249							;
    282  2249				   DebugPrintProgramLine
    283  2249		       48		      pha
    284  224a		       a9 5b		      lda	#TOKENBUFFER&$FF
    285  224c		       85 59		      sta	dpl
    286  224e		       a9 1c		      lda	#TOKENBUFFER>>8
    287  2250		       85 5a		      sta	dpl+1
    288  2252		       68		      pla
    289  2253
    290  2253							; Decode and print a line of program text
    291  2253							; on entry	 dpl points to line of code to print
    292  2253							; on exit	 no change in reg or dpl
    293  2253							;
    294  2253				   PrintProgramLine
    295  2253
    296  2253		       8e 5b 1d 	      stx	printStorage
    297  2256		       8c 5c 1d 	      sty	printStorage+1
    298  2259		       48		      pha
    299  225a
    300  225a		       a0 01		      ldy	#1	; index into the token buffer
    301  225c		       84 58		      sty	R2	; print unsigned decimal
    302  225e		       a0 00		      ldy	#0
    303  2260		       b1 59		      lda	(dpl),y	; get number of bytes
    304  2262		       aa		      tax		; place pointer into x
    305  2263		       c8		      iny
    306  2264		       ca		      dex		; Deduct the length byte
    307  2265		       20 47 1f 	      jsr	DPL2R0	; Print the line number
    308  2268		       20 ea 20 	      jsr	PrintDecimal
    309  226b		       a9 20		      lda	#$20
    310  226d		       20 63 1a 	      jsr	VOUTCH
    311  2270
    312  2270				   PrintProgLoop
    313  2270		       b1 59		      lda	(dpl),y	; Get a character
    314  2272		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    315  2274		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    316  2276		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    317  2278
    318  2278				   PrintProgVars
    319  2278		       b1 59		      lda	(dpl),y
    320  227a		       29 e0		      and	#$E0	; Check for operators and punctuation
    321  227c		       c9 e0		      cmp	#$E0
    322  227e		       f0 6b		      beq	PrintProgOperatorVect
    323  2280
    324  2280		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    325  2282		       c9 9e		      cmp	#$9D+1
    326  2284		       90 62		      bcc	PrintProgVariableVec
    327  2286		       29 a0		      and	#$A0	; Check for a valid datatype
    328  2288		       c9 a0		      cmp	#$A0
    329  228a		       f0 06		      beq	PrintDataType	; if not just print the character
    330  228c		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    331  228e		       ca		      dex		; Ok we are processing it
    332  228f		       c8		      iny
    333  2290		       d0 25		      bne	PrintContinue	; Print and do the next character
    334  2292
    335  2292				   PrintDataType
    336  2292		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    337  2294		       c9 a0		      cmp	#tString
    338  2296		       f0 31		      beq	PrintStringVariable
    339  2298
    340  2298				   PrintProgNumber
    341  2298		       c8		      iny		; we have a numerical integer value
    342  2299		       ca		      dex
    343  229a		       48		      pha
    344  229b		       a9 00		      lda	#0
    345  229d		       85 53		      sta	R0+1
    346  229f		       85 58		      sta	R2	; Set to print signed number
    347  22a1		       b1 59		      lda	(dpl),y
    348  22a3		       85 52		      sta	R0
    349  22a5		       68		      pla
    350  22a6		       c9 a4		      cmp	#tInteger
    351  22a8		       d0 06		      bne	PrintProgNumDone
    352  22aa		       c8		      iny
    353  22ab		       ca		      dex
    354  22ac		       b1 59		      lda	(dpl),y
    355  22ae		       85 53		      sta	R0+1
    356  22b0
    357  22b0				   PrintProgNumDone
    358  22b0		       c8		      iny
    359  22b1		       ca		      dex
    360  22b2		       20 ea 20 	      jsr	PrintDecimal
    361  22b5
    362  22b5				   PrintProgNext
    363  22b5		       a9 20		      lda	#$20
    364  22b7				   PrintContinue
    365  22b7		       20 63 1a 	      jsr	VOUTCH
    366  22ba				   PrintProgSkipSpace
    367  22ba		       e0 00		      cpx	#0
    368  22bc		       d0 b2		      bne	PrintProgLoop
    369  22be				   PrintProgramComplete
    370  22be		       20 7d 2d 	      jsr	CRLF
    371  22c1
    372  22c1		       ae 5b 1d 	      ldx	printStorage
    373  22c4		       ac 5c 1d 	      ldy	printStorage+1
    374  22c7		       68		      pla
    375  22c8
    376  22c8		       60		      rts
    377  22c9							;=================================================================================================================
    378  22c9							; Print a string variable including the quotes
    379  22c9							; On Input	 y is offset into buffer
    380  22c9							; On Exit	 y is updated to new offset
    381  22c9
    382  22c9				   PrintStringVariable
    383  22c9		       c8		      iny
    384  22ca		       a9 22		      lda	#'"
    385  22cc		       20 63 1a 	      jsr	VOUTCH
    386  22cf		       c8		      iny
    387  22d0		       a5 59		      lda	dpl
    388  22d2		       85 5e		      sta	PrtFrom
    389  22d4		       a5 5a		      lda	dpl+1
    390  22d6		       85 5f		      sta	PrtFrom+1
    391  22d8		       a9 22		      lda	#'"
    392  22da		       8d 2b 43 	      sta	PrtTerm
    393  22dd		       20 02 22 	      jsr	PrtLoop
    394  22e0		       a9 22		      lda	#'"
    395  22e2		       20 63 1a 	      jsr	VOUTCH
    396  22e5		       4c b5 22 	      jmp	PrintProgNext
    397  22e8
    398  22e8				   PrintProgVariableVec
    399  22e8		       4c 88 23 	      jmp	PrintProgVariable
    400  22eb
    401  22eb				   PrintProgOperatorVect
    402  22eb		       4c 5f 23 	      jmp	PrintProgOperator
    403  22ee							;===============================================================================================================
    404  22ee							; On entry dpl points to the buffer we are printing from
    405  22ee							;	    y	current offset into the dpl buffer
    406  22ee							; all registers preserved
    407  22ee							;
    408  22ee				   PrintKeyword
    409  22ee
    410  22ee		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    411  22f0		       85 52		      sta	R0	; The value we are looking for
    412  22f2		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    413  22f4		       f0 0c		      beq	PrintKeyBranch
    414  22f6		       c9 08		      cmp	#kGosub
    415  22f8		       f0 08		      beq	PrintKeyBranch
    416  22fa		       c9 2f		      cmp	#kTask
    417  22fc		       f0 04		      beq	PrintKeyBranch
    418  22fe		       c9 37		      cmp	#kGofn
    419  2300		       d0 04		      bne	PrintKeySkipped
    420  2302				   PrintKeyBranch
    421  2302		       c8		      iny		; Skip the compiled memory address
    422  2303		       c8		      iny
    423  2304		       ca		      dex		; Change number of bytes to print
    424  2305		       ca		      dex		; Remove the bytes to print
    425  2306
    426  2306				   PrintKeySkipped
    427  2306		       c8		      iny		; Inc y to point to the next char to be printed
    428  2307		       ca		      dex		; Reduce number of bytes to print
    429  2308		       98		      tya		; Save y and x for the return
    430  2309		       48		      pha
    431  230a		       8a		      txa
    432  230b		       48		      pha
    433  230c
    434  230c		       a9 1e		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    435  230e		       85 54		      sta	R1
    436  2310		       a9 1b		      lda	#KeyWordTable>>8
    437  2312		       85 55		      sta	R1+1
    438  2314
    439  2314
    440  2314				   PrintKeyLoop
    441  2314		       a0 00		      ldy	#0	; Index into the keyword entry
    442  2316		       b1 54		      lda	(R1),y	; Get token value for this entry
    443  2318		       c8		      iny		; Point to first byte of key
    444  2319		       c5 52		      cmp	R0	; Compare to the token we are looking for
    445  231b		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    446  231d
    447  231d				   PrintKeyNext
    448  231d		       b1 54		      lda	(R1),y	; Get key letter
    449  231f		       c8		      iny		; Point to next byte always
    450  2320		       29 20		      and	#%00100000	; Check for last character in key work
    451  2322		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    452  2324
    453  2324		       98		      tya		; Trabsfer y to a for the addition
    454  2325		       18		      clc		; Table > 256 bytes
    455  2326		       65 54		      adc	R1
    456  2328		       85 54		      sta	R1
    457  232a		       a9 00		      lda	#0
    458  232c		       65 55		      adc	R1+1
    459  232e		       85 55		      sta	R1+1
    460  2330		       4c 14 23 	      jmp	PrintKeyLoop
    461  2333
    462  2333				   PrintKeyFound
    463  2333		       b1 54		      lda	(R1),y	; letter from key table
    464  2335		       48		      pha		; Save it for later check
    465  2336		       09 20		      ora	#%00100000	; Force it to lower case
    466  2338		       20 63 1a 	      jsr	VOUTCH	; Print it out
    467  233b		       c8		      iny		; Point to next character
    468  233c		       68		      pla		; Restore the value
    469  233d		       29 20		      and	#%00100000	; Check if it was last char in keyword
    470  233f		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    471  2341
    472  2341		       68		      pla		; Restore the x and y values
    473  2342		       aa		      tax
    474  2343		       68		      pla
    475  2344		       a8		      tay
    476  2345
    477  2345				   PrintChkRem
    478  2345		       a9 0a		      lda	#kRem
    479  2347		       c5 52		      cmp	R0
    480  2349		       d0 11		      bne	PrintKeyDone
    481  234b				   PrintKeyRem
    482  234b		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    483  234d		       85 5e		      sta	PrtFrom
    484  234f		       a5 5a		      lda	dpl+1
    485  2351		       85 5f		      sta	PrtFrom+1
    486  2353		       a9 00		      lda	#0
    487  2355		       8d 2b 43 	      sta	PrtTerm
    488  2358		       20 02 22 	      jsr	PrtLoop
    489  235b		       88		      dey		; point back to the terminating null value
    490  235c				   PrintKeyDone
    491  235c		       4c b5 22 	      jmp	PrintProgNext
    492  235f							;==================================================================================================================
    493  235f							;Print Variable, number or operator
    494  235f				   PrintProgOperator
    495  235f		       b1 59		      lda	(dpl),y
    496  2361		       c8		      iny
    497  2362		       ca		      dex
    498  2363		       8e 5d 1d 	      stx	printStorage+2
    499  2366		       a2 00		      ldx	#0
    500  2368				   PrintOprLoop
    501  2368		       dd 00 1b 	      cmp	OperValues,x
    502  236b		       f0 03		      beq	PrintOprFound
    503  236d		       e8		      inx
    504  236e		       d0 f8		      bne	PrintOprLoop
    505  2370				   PrintOprFound
    506  2370		       8a		      txa
    507  2371		       0a		      asl
    508  2372		       aa		      tax
    509  2373		       bd c2 1a 	      lda	Operators,x
    510  2376		       20 63 1a 	      jsr	VOUTCH
    511  2379		       e8		      inx
    512  237a		       bd c2 1a 	      lda	Operators,x
    513  237d		       f0 03		      beq	PrintOprDone
    514  237f		       20 63 1a 	      jsr	VOUTCH
    515  2382				   PrintOprDone
    516  2382		       ae 5d 1d 	      ldx	printStorage+2
    517  2385		       4c b5 22 	      jmp	PrintProgNext
    518  2388
    519  2388							;=================================================================================================================
    520  2388							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    521  2388							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    522  2388							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    523  2388							;tVhat 	    equ     155 		   ; Variable ^
    524  2388							;tVhash	    equ     156 		   ; Variable #
    525  2388							;tVat		    equ     157 		   ; Variable @ = 0
    526  2388				   PrintProgVariable
    527  2388		       b1 59		      lda	(dpl),y
    528  238a		       c8		      iny
    529  238b		       ca		      dex
    530  238c		       c9 9b		      cmp	#tVhat
    531  238e		       d0 04		      bne	PrintProgChkHash
    532  2390		       a9 5e		      lda	#'^
    533  2392		       d0 15		      bne	PrintTheVar
    534  2394				   PrintProgChkHash
    535  2394		       c9 9c		      cmp	#tVhash
    536  2396		       d0 04		      bne	PrintProgChkAt
    537  2398		       a9 23		      lda	#'#
    538  239a		       d0 0d		      bne	PrintTheVar
    539  239c				   PrintProgChkAt
    540  239c		       c9 9d		      cmp	#tVat
    541  239e		       d0 04		      bne	PrintProgVarLetter
    542  23a0		       a9 40		      lda	#'@
    543  23a2		       d0 05		      bne	PrintTheVar
    544  23a4				   PrintProgVarLetter
    545  23a4		       29 7f		      and	#%01111111
    546  23a6		       18		      clc
    547  23a7		       69 41		      adc	#'A
    548  23a9				   PrintTheVar
    549  23a9		       20 63 1a 	      jsr	VOUTCH
    550  23ac		       4c b5 22 	      jmp	PrintProgNext
    551  23af
    552  23af
    553  23af							;==================================================================================================
    554  23af							; Size of print functions
    555  23af		       02 c5	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  23af					      include	"mem.asm"
      1  23af							;===================================================================
      2  23af							;This file contains the memory allocation and free functions
      3  23af							; This is the management of free memory in the system
      4  23af							; the interface to these functions
      5  23af							; a,x returns or provides the low hi bytes of the managed addresses
      6  23af							; This uses the programend, to memory end as the area to manage
      7  23af							;===================================================================
      8 U3676					      Seg.u	TBData
      9 U3676							;
     10 U3676							;=====================================================
     11 U3676							;Pointers for memory Management
     12 U3676							;Allocated block are not chained but can be followed for all memory by the associated length
     13 U3676							; Mem block format is
     14 U3676							;	 0-1   pointer to next block for free blocks
     15 U3676							;	 0-1   for allocated blocks
     16 U3676							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     17 U3676							;	   1   refrence counter ... lol only up to 256 but it is something
     18 U3676							;	 2-3   length constant for exevy type of memory block
     19 U3676							; Memory is recombined as it is released
     20 U3676							; The memory manager is not interupted durring allocation
     21 U3676							; or freeing of memory
     22 U3676							;====================================================
     23 U3676		       00 00	   MemFreeList ds	2	; list of free blocks of memory
     24 U3678		       00 00	   MemR0      ds	2	; source for copy/move/Init
     25 U367a		       00 00	   MemR1      ds	2	; Destination for copy/move
     26 U367c							;=====================================================
     27  23af					      Seg	Code
     28  23af							;=====================================================
     29  23af				   MemInit
     30  23af		       a9 41		      lda	#FreeMemStart&$FF
     31  23b1		       8d 37 43 	      sta	ProgramStart
     32  23b4		       8d 39 43 	      sta	ProgramEnd
     33  23b7		       a9 43		      lda	#FreeMemStart>>8
     34  23b9		       8d 38 43 	      sta	ProgramStart+1
     35  23bc		       8d 3a 43 	      sta	ProgramEnd+1
     36  23bf
     37  23bf		       20 c9 23 	      jsr	GetSizes
     38  23c2		       20 d4 23 	      jsr	MemFree
     39  23c5		       20 ec 23 	      jsr	MemUsed
     40  23c8				   MemInitEnd
     41  23c8		       60		      rts
     42  23c9
     43  23c9
     44  23c9							;
     45  23c9							;=====================================================
     46  23c9							; This function might go away eventually, but was
     47  23c9							; added to provide data for other pieces of code.
     48  23c9							; It has some ties to the operating environment that
     49  23c9							; will need to be customized for the target system.
     50  23c9							;
     51  23c9				   GetSizes
     52  23c9							;
     53  23c9							; Here is machine specific code to get the highest
     54  23c9							; memory location that can be used by BASIC.
     55  23c9							;
     56  23c9				  -	      if	ProgramStart < $2000
     57  23c9				  -	      lda	#$ff
     58  23c9				  -	      sta	HighMem	;$13ff for KIM-1
     59  23c9				  -	      sta	MemFreeList
     60  23c9				  -	      lda	#$DE	;#$13
     61  23c9				  -	      sta	HighMem+1
     62  23c9				  -	      sta	MemFreeList+1
     63  23c9					      else
     64  23c9		       a9 ff		      lda	#$ff
     65  23cb		       8d 3b 43 	      sta	HighMem	;$CFFF otherwise
     66  23ce		       a9 cf		      lda	#$cf
     67  23d0		       8d 3c 43 	      sta	HighMem+1
     68  23d3					      endif
     69  23d3		       60		      rts
     70  23d4							;
     71  23d4							; This computes the available memory remaining.
     72  23d4							;
     73  23d4				   MemFree
     74  23d4		       38		      sec
     75  23d5		       ad 3b 43 	      lda	HighMem
     76  23d8		       ed 39 43 	      sbc	ProgramEnd
     77  23db		       8d 3f 43 	      sta	FreeMem
     78  23de		       85 52		      sta	R0
     79  23e0		       ad 3c 43 	      lda	HighMem+1
     80  23e3		       ed 3a 43 	      sbc	ProgramEnd+1
     81  23e6		       8d 40 43 	      sta	FreeMem+1
     82  23e9		       85 53		      sta	R0+1
     83  23eb		       60		      rts
     84  23ec							;
     85  23ec							; This computes the size of the current user program.
     86  23ec							;
     87  23ec				   MemUsed
     88  23ec		       38		      sec
     89  23ed		       ad 39 43 	      lda	ProgramEnd
     90  23f0		       ed 37 43 	      sbc	ProgramStart
     91  23f3		       8d 3d 43 	      sta	UsedMem
     92  23f6		       85 52		      sta	R0
     93  23f8		       ad 3a 43 	      lda	ProgramEnd+1
     94  23fb		       ed 38 43 	      sbc	ProgramStart+1
     95  23fe		       8d 3e 43 	      sta	UsedMem+1
     96  2401		       85 53		      sta	R0+1
     97  2403							;
     98  2403		       60		      rts
     99  2404							;
    100  2404							;=====================================================
    101  2404							; Set a block of memory to a value
    102  2404		       8a	   iSetBlock  txa
    103  2405		       48		      pha
    104  2406		       98		      tya
    105  2407		       48		      pha
    106  2408		       20 c4 2c 	      jsr	popR0	; the address to write to
    107  240b		       a5 52		      lda	R0
    108  240d		       85 59		      sta	dpl
    109  240f		       a5 53		      lda	R0+1
    110  2411		       85 5a		      sta	dpl+1
    111  2413		       20 dc 2c 	      jsr	popR1	; Number of bytes to write
    112  2416		       20 c4 2c 	      jsr	popR0	; Get the value to store into memory
    113  2419		       20 39 2a 	      jsr	getILByte
    114  241c		       85 58		      sta	R2	; store the data type into R2
    115  241e		       c9 a4		      cmp	#tInteger
    116  2420		       f0 08		      beq	memset	; skip this if we have an integer
    117  2422		       a5 52		      lda	R0	; Revers the order so they can be copied in correct order
    118  2424		       a6 53		      ldx	R0+1
    119  2426		       86 52		      stx	R0
    120  2428		       85 53		      sta	R0+1
    121  242a
    122  242a				   memset
    123  242a		       a0 00		      ldy	#0	; Set for length of block to copy
    124  242c		       a2 00		      ldx	#0	; set for number of block of 256 to copy
    125  242e
    126  242e		       a5 58	   iSetBlockLoop lda	R2	; Get Datatype
    127  2430		       c9 a2		      cmp	#tByte
    128  2432		       f0 09		      beq	iSetBlockB
    129  2434
    130  2434		       a5 52	   iSetBlockW lda	R0
    131  2436		       91 59		      sta	(dpl),y
    132  2438		       20 4d 24 	      jsr	iSetBlockEnd
    133  243b		       f0 09		      beq	iSetBlockComplete
    134  243d
    135  243d		       a5 53	   iSetBlockB lda	R0+1
    136  243f		       91 59		      sta	(dpl),y
    137  2441		       20 4d 24 	      jsr	iSetBlockEnd
    138  2444		       d0 e8		      bne	iSetBlockLoop
    139  2446
    140  2446				   iSetBlockComplete
    141  2446		       68		      pla
    142  2447		       a8		      tay
    143  2448		       68		      pla
    144  2449		       aa		      tax
    145  244a		       4c b1 02 	      jmp	NextIL
    146  244d							;
    147  244d							; Check if we have reached the end of the initialization/Copy
    148  244d							;
    149  244d		       c8	   iSetBlockEnd iny
    150  244e		       d0 03		      bne	iSetBlockEndChk
    151  2450		       e8		      inx
    152  2451		       e6 5a		      inc	dpl+1
    153  2453				   iSetBlockEndChk
    154  2453		       c4 54		      cpy	R1
    155  2455		       d0 02		      bne	iSetBlockEndExit
    156  2457		       e4 55		      cpx	R1+1
    157  2459				   iSetBlockEndExit
    158  2459		       60		      rts
    159  245a							;
    160  245a							;================================================================
    161  245a							; Copy a block of memory from one location to another
    162  245a							;
    163  245a		       8a	   iCopyBlock txa
    164  245b		       48		      pha
    165  245c		       98		      tya
    166  245d		       48		      pha
    167  245e		       20 c4 2c 	      jsr	popR0	; get the source address
    168  2461		       20 dc 2c 	      jsr	popR1	; Destination address
    169  2464		       a5 54		      lda	R1
    170  2466		       85 59		      sta	dpl
    171  2468		       a5 55		      lda	R1+1
    172  246a		       85 5a		      sta	dpl+1
    173  246c		       20 dc 2c 	      jsr	popR1	; Number of bytes to copy
    174  246f				   memcpy
    175  246f		       a2 00		      ldx	#0
    176  2471		       a0 00		      ldy	#0
    177  2473				   iCopyBlockLoop
    178  2473		       b1 52		      lda	(R0),y	;  Get the byte to copy
    179  2475		       91 59		      sta	(dpl),y	;  Store the byte
    180  2477		       c8		      iny
    181  2478		       d0 05		      bne	iCopyChkEnd
    182  247a		       e8		      inx
    183  247b		       e6 53		      inc	R0+1
    184  247d		       e6 5a		      inc	dpl+1
    185  247f		       c4 54	   iCopyChkEnd cpy	R1
    186  2481		       d0 f0		      bne	iCopyBlockLoop
    187  2483		       e4 55		      cpx	R1+1
    188  2485		       d0 ec		      bne	iCopyBlockLoop
    189  2487				   iCopyBlockDone
    190  2487		       68		      pla
    191  2488		       a8		      tay
    192  2489		       68		      pla
    193  248a		       aa		      tax
    194  248b		       4c b1 02 	      jmp	NextIL
    195  248e							;
    196  248e							;=============================================================================
    197  248e							; Compare memory block location
    198  248e							; returns on the stack
    199  248e							; 0 - equals
    200  248e							; -1 - s1  <  s2
    201  248e							; 1   s1  >  s2
    202  248e		       8a	   iCmpBlock  txa
    203  248f		       48		      pha
    204  2490		       98		      tya
    205  2491		       48		      pha
    206  2492		       20 dc 2c 	      jsr	popR1	; Get the Source 2 pointer
    207  2495		       a5 54		      lda	R1
    208  2497		       85 59		      sta	dpl	; store the secon source in dpl
    209  2499		       a5 55		      lda	R1+1
    210  249b		       85 5a		      sta	dpl+1
    211  249d		       20 c4 2c 	      jsr	popR0	; Get the Source 1 pointer
    212  24a0		       20 dc 2c 	      jsr	popR1	; Get the length of the compare to do
    213  24a3		       a0 00		      ldy	#0
    214  24a5		       a2 00		      ldx	#0
    215  24a7		       4c b4 24 	      jmp	iCmpCheckEnd
    216  24aa
    217  24aa		       b1 59	   iCmpLoop   lda	(dpl),y
    218  24ac		       d1 52		      cmp	(R0),y
    219  24ae		       d0 19		      bne	iCmpDone
    220  24b0		       c8		      iny
    221  24b1		       d0 01		      bne	iCmpCheckEnd
    222  24b3		       e8		      inx
    223  24b4				   iCmpCheckEnd
    224  24b4		       c4 54		      cpy	R1
    225  24b6		       d0 f2		      bne	iCmpLoop
    226  24b8		       e4 55		      cpx	R1+1
    227  24ba		       d0 ee		      bne	iCmpLoop
    228  24bc		       a5 00		      lda	0
    229  24be		       85 53		      sta	R0+1
    230  24c0		       85 52		      sta	R0
    231  24c2				   iCmpReturn
    232  24c2		       68		      pla
    233  24c3		       a8		      tay
    234  24c4		       68		      pla
    235  24c5		       aa		      tax
    236  24c6		       4c 1d 07 	      jmp	pushR0nextIl
    237  24c9
    238  24c9				   iCmpDone
    239  24c9		       90 0a		      bcc	iCmpGreater
    240  24cb				   iCmpLess
    241  24cb		       a9 00		      lda	#0
    242  24cd		       85 53		      sta	R0+1
    243  24cf		       a9 01		      lda	#1
    244  24d1		       85 52		      sta	R0
    245  24d3		       d0 ed		      bne	iCmpReturn
    246  24d5				   iCmpGreater
    247  24d5		       a9 ff		      lda	#-1
    248  24d7		       85 52		      sta	R0
    249  24d9		       85 53		      sta	R0+1
    250  24db		       d0 e5		      bne	iCmpReturn
    251  24dd
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  24dd					      include	"gosub.asm"
      1  24dd					      seg	Code
      2  24dd
      3  24dd							; Gosub and return related functions
      4  24dd							;==========================================================
      5  24dd							; Push the current math stack frame onto the gosub stack
      6  24dd				   iPushMathStack
      7  24dd		       98		      tya
      8  24de		       48		      pha
      9  24df		       a4 4d		      ldy	GOSUBSTACKPTR
     10  24e1		       a5 4a		      lda	MATHSTACKPTR
     11  24e3		       91 4b		      sta	(GOSUBSTACK),y
     12  24e5		       a9 00		      lda	#0
     13  24e7		       c8		      iny
     14  24e8		       91 4b		      sta	(GOSUBSTACK),y
     15  24ea		       c8		      iny
     16  24eb		       91 4b		      sta	(GOSUBSTACK),y
     17  24ed		       c8		      iny
     18  24ee		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  24f0		       91 4b		      sta	(GOSUBSTACK),y
     20  24f2		       c8		      iny
     21  24f3		       84 4d		      sty	GOSUBSTACKPTR
     22  24f5		       68		      pla
     23  24f6		       a8		      tay
     24  24f7		       4c b1 02 	      jmp	NextIL
     25  24fa							;
     26  24fa							;==========================================================
     27  24fa							; Increment parameter count. Assume Stack frame is top of stack
     28  24fa				   iIncParmCount
     29  24fa		       98		      tya
     30  24fb		       48		      pha
     31  24fc
     32  24fc		       a4 4d		      ldy	GOSUBSTACKPTR
     33  24fe		       88		      dey
     34  24ff		       88		      dey
     35  2500		       88		      dey
     36  2501		       b1 4b		      lda	(GOSUBSTACK),y
     37  2503		       18		      clc
     38  2504		       69 01		      adc	#1
     39  2506		       91 4b		      sta	(GOSUBSTACK),y
     40  2508
     41  2508		       68		      pla
     42  2509		       a8		      tay
     43  250a		       4c b1 02 	      jmp	NextIL
     44  250d							;
     45  250d							;==========================================================
     46  250d							;Restore the math stack frame
     47  250d		       20 13 25    iPopMathStack jsr	PopMathStackNow
     48  2510		       4c b1 02 	      jmp	NextIL
     49  2513
     50  2513				   PopMathStackNow
     51  2513		       98		      tya
     52  2514		       48		      pha
     53  2515
     54  2515		       a4 4d		      ldy	GOSUBSTACKPTR
     55  2517		       88		      dey
     56  2518		       b1 4b		      lda	(GOSUBSTACK),y
     57  251a		       c9 05		      cmp	#GOSUB_STACK_FRAME
     58  251c		       d0 09		      bne	iPopMathStackNoFrame
     59  251e		       88		      dey
     60  251f		       88		      dey
     61  2520		       88		      dey
     62  2521		       b1 4b		      lda	(GOSUBSTACK),y
     63  2523		       85 4a		      sta	MATHSTACKPTR
     64  2525		       84 4d		      sty	GOSUBSTACKPTR
     65  2527
     66  2527				   iPopMathStackNoFrame
     67  2527
     68  2527		       68		      pla
     69  2528		       a8		      tay
     70  2529		       60		      rts
     71  252a
     72  252a
     73  252a							;==========================================================
     74  252a							; Push the current math stack information onto the gosub stack
     75  252a				   iSaveMathStack
     76  252a		       98		      tya
     77  252b		       48		      pha
     78  252c
     79  252c		       a4 4d		      ldy	GOSUBSTACKPTR
     80  252e		       a5 4a		      lda	MATHSTACKPTR
     81  2530		       91 4b		      sta	(GOSUBSTACK),y
     82  2532		       a5 48		      lda	MATHSTACK
     83  2534		       c8		      iny
     84  2535
     85  2535		       91 4b		      sta	(GOSUBSTACK),y
     86  2537		       c8		      iny
     87  2538
     88  2538		       a5 49		      lda	MATHSTACK+1
     89  253a		       91 4b		      sta	(GOSUBSTACK),y
     90  253c		       c8		      iny
     91  253d
     92  253d		       a9 06		      lda	#GOSUB_STACK_SAVE
     93  253f		       91 4b		      sta	(GOSUBSTACK),y
     94  2541		       c8		      iny
     95  2542
     96  2542		       84 4d		      sty	GOSUBSTACKPTR
     97  2544
     98  2544		       68		      pla
     99  2545		       a8		      tay
    100  2546		       4c b1 02 	      jmp	NextIL
    101  2549							;
    102  2549							;==========================================================
    103  2549							;Restore the math stack information from the gosub stack
    104  2549				   iRestoreMathStack
    105  2549		       98		      tya
    106  254a		       48		      pha
    107  254b
    108  254b		       a5 4a		      lda	MATHSTACKPTR
    109  254d		       85 58		      sta	R2	; save the current offset for whatever task to R2
    110  254f
    111  254f		       a4 4d		      ldy	GOSUBSTACKPTR
    112  2551		       88		      dey
    113  2552		       b1 4b		      lda	(GOSUBSTACK),y
    114  2554		       c9 06		      cmp	#GOSUB_STACK_SAVE
    115  2556		       d0 16		      bne	iPopMathStack_Err
    116  2558		       88		      dey
    117  2559		       b1 4b		      lda	(GOSUBSTACK),y
    118  255b		       85 49		      sta	MATHSTACK+1
    119  255d		       88		      dey
    120  255e		       b1 4b		      lda	(GOSUBSTACK),y
    121  2560		       85 48		      sta	MATHSTACK
    122  2562		       88		      dey
    123  2563		       b1 4b		      lda	(GOSUBSTACK),y
    124  2565		       85 4a		      sta	MATHSTACKPTR
    125  2567		       84 4d		      sty	GOSUBSTACKPTR
    126  2569
    127  2569		       68		      pla
    128  256a		       a8		      tay
    129  256b		       4c b1 02 	      jmp	NextIL
    130  256e
    131  256e				   iPopMathStack_Err
    132  256e		       68		      pla
    133  256f		       a8		      tay
    134  2570		       a9 00		      lda	#0
    135  2572		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    136  2574		       4c 7d 06 	      jmp	iErr2
    137  2577							;=========================================
    138  2577							; For functions and tasks the variable address of # means
    139  2577							; a passed parameter so #[0] is the first parameter etc
    140  2577							; will try for a better way later
    141  2577							;=====================================================
    142  2577							; On entry il, branch to if function
    143  2577							;	    il+1, value to be returned or not true or false
    144  2577							;
    145  2577							; Return from GOSUB  or function function
    146  2577							; format   RSTR 0   --- return form gosub
    147  2577							;	    RSTR 1   --- return from Function
    148  2577							;
    149  2577		       20 39 2a    iRSTR      jsr	getILByte	; get where to go if 0 = gosub/1=function call
    150  257a		       8d 2f 43 	      sta	offset
    151  257d		       20 1c 2c 	      jsr	saveIL	; for later jump if needed add extra entry to	the return stack
    152  2580
    153  2580		       20 75 2c 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    154  2583		       85 54		      sta	R1	; keep the type of call returning from
    155  2585		       b0 2b		      bcs	iRSTRErr	; stack underflow error possible
    156  2587
    157  2587		       20 39 2a 	      jsr	getILByte	; get if a value is being returned
    158  258a
    159  258a		       48		      pha		; save if a value was passed to be returned
    160  258b
    161  258b		       c9 00		      cmp	#0	; yes attemping to return a value
    162  258d		       f0 03		      beq	iRSTRPOP	; no value to return
    163  258f		       20 c4 2c 	      jsr	popR0	; Get the value from the stack save if needed
    164  2592
    165  2592				   iRSTRPOP
    166  2592		       20 13 25 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    167  2595		       a5 54		      lda	R1	; called as a statement ?
    168  2597		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    169  2599		       f0 13		      beq	iRSTRExit
    170  259b
    171  259b		       68		      pla		; get back if value returned or not
    172  259c		       c9 01		      cmp	#1	; we have a value to return
    173  259e		       f0 05		      beq	iRSTRVALUE
    174  25a0
    175  25a0		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    176  25a2		       4c 12 05 	      jmp	iSAVErr2	; jump to general error reporting function
    177  25a5
    178  25a5				   iRSTRVALUE
    179  25a5		       20 32 2c 	      jsr	pushR0	; return value back to top of stack
    180  25a8		       20 27 2c 	      jsr	restoreIL	; get the correct il
    181  25ab		       4c e0 0b 	      jmp	tstBranch	; And called as a function
    182  25ae
    183  25ae				   iRSTRExit
    184  25ae		       68		      pla		; throw away gosub/func flag
    185  25af		       4c b1 02 	      jmp	NextIL
    186  25b2
    187  25b2				   iRSTRNORETURNVALUE
    188  25b2
    189  25b2
    190  25b2		       ad be 36    iRSTRErr   lda	taskPtr	; Check if this is task zero
    191  25b5		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    192  25b7		       a5 56		      lda	MQ
    193  25b9		       d0 03		      bne	taskRet
    194  25bb		       20 ff 2e 	      jsr	pushFalse	; the result code by default is 0
    195  25be				   taskRet
    196  25be		       4c 32 28 	      jmp	iETask	; not task zero then do a task end instead
    197  25c1				   taskZeroEnd
    198  25c1		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    199  25c3		       4c 12 05 	      jmp	iSAVErr2
    200  25c6							;
    201  25c6							;==========================================================================================
    202  25c6							; Find the next gosub function parameter info	position on the stack
    203  25c6							; Returns y = index and c set if found clear c otherwise
    204  25c6		       a4 4d	   GosubFindParms ldy	GOSUBSTACKPTR	;Get the Pointer to the top of stack
    205  25c8		       88		      dey		;Point to stack entry type
    206  25c9
    207  25c9							;Veryify the stack size and position for the call
    208  25c9							;Loops here until it finds a GOSUB with value entry or gosub-rtn entry
    209  25c9
    210  25c9		       c0 00	   GosubFindLoop cpy	#0	;If we reach the top of the stack then no parametrs
    211  25cb		       f0 2d		      beq	GosubNotFunc
    212  25cd		       c0 10		      cpy	#GOSUBSTACKSIZE	;Tst if we are outside the stack size
    213  25cf		       b0 29		      bcs	GosubNotFunc	;Not valid
    214  25d1
    215  25d1							;Look for the	 GOSUB_RTN_VALUE stack position
    216  25d1		       b1 4b		      lda	(GOSUBSTACK),y	;Get the type of call - if it is not a fn call error
    217  25d3		       c9 01		      cmp	#GOSUB_RTN	;if we find this then this function had no parameters
    218  25d5		       f0 0f		      beq	GosubParmFnd	;We can pass parameters to a function that returns nothing
    219  25d7
    220  25d7		       c9 81		      cmp	#GOSUB_RTN_VALUE	;Parameters with the gosub call
    221  25d9		       f0 0b		      beq	GosubParmFnd	;Skip any non Gosub related entries
    222  25db
    223  25db		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    224  25dd		       f0 13		      beq	GosubParmSkip	;We have a stackframe good
    225  25df
    226  25df		       88		      dey
    227  25e0		       88		      dey
    228  25e1		       88		      dey
    229  25e2		       88		      dey
    230  25e3		       4c c9 25 	      jmp	GosubFindLoop
    231  25e6
    232  25e6		       c0 03	   GosubParmFnd cpy	#3	; Check if we are outside the stack
    233  25e8		       90 10		      bcc	GosubNotFunc	; if y < 3 then error not found
    234  25ea		       c0 10		      cpy	#GOSUBSTACKSIZE	; Largest value
    235  25ec		       b0 0c		      bcs	GosubNotFunc	; no parameters passed
    236  25ee
    237  25ee		       88		      dey		; Point to hopefully Math Stack frame information
    238  25ef		       88		      dey
    239  25f0		       88		      dey
    240  25f1		       88		      dey
    241  25f2				   GosubParmSkip
    242  25f2		       b1 4b		      lda	(GOSUBSTACK),y	;This should be a stack frame pointer
    243  25f4		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    244  25f6		       d0 02		      bne	GosubNotFunc	;No parameters passed but expected
    245  25f8		       38		      sec
    246  25f9		       60		      rts
    247  25fa
    248  25fa		       18	   GosubNotFunc clc
    249  25fb		       60		      rts
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  25fc					      include	"tasks.asm"
      1  25fc							;=====================================================
      2  25fc							; Tiny Basic IL task management
      3  25fc							; Data required by task management
      4  25fc							; currently each context is about 30 bytes and is swapped
      5  25fc							; into and out of page zero on each task switch....
      6  25fc							; LOL yes it is slow, but works for this iteration.
      7  25fc							;
      8  25fc
      9  25fc					      Seg	Code
     10  25fc							;=====================================================
     11  25fc							; Sets the pointers to the math,IL and gosub stacks
     12  25fc							; Creates the initial Context for each task slot
     13  25fc				   taskSetStacks
     14  25fc		       a9 be		      lda	#mathStack&$FF
     15  25fe		       85 48		      sta	MATHSTACK
     16  2600		       a9 37		      lda	#mathStack>>8
     17  2602		       85 49		      sta	MATHSTACK+1
     18  2604
     19  2604		       a9 4e		      lda	#ilStack&$ff
     20  2606		       85 45		      sta	ILSTACK
     21  2608		       a9 39		      lda	#ilStack>>8
     22  260a		       85 46		      sta	ILSTACK+1
     23  260c
     24  260c		       a9 36		      lda	#gosubStack&$FF
     25  260e		       85 4b		      sta	GOSUBSTACK
     26  2610		       a9 3d		      lda	#gosubStack>>8
     27  2612		       85 4c		      sta	GOSUBSTACK+1
     28  2614
     29  2614		       a9 b6		      lda	#variableStack&$FF
     30  2616		       85 41		      sta	VARIABLES
     31  2618		       a9 3f		      lda	#variableStack>>8
     32  261a		       85 42		      sta	VARIABLES+1
     33  261c		       a2 0a		      ldx	#TASKCOUNT
     34  261e		       a0 00		      ldy	#0
     35  2620		       20 f0 28 	      jsr	ContextSave	; Save the Task 0 context
     36  2623
     37  2623		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  2625		       b0 3a		      bcs	taskSetDone
     39  2627
     40  2627		       a5 4b		      lda	GOSUBSTACK
     41  2629		       18		      clc
     42  262a		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  262c		       85 4b		      sta	GOSUBSTACK
     44  262e		       a5 4c		      lda	GOSUBSTACK+1
     45  2630		       69 00		      adc	#0
     46  2632		       85 4c		      sta	GOSUBSTACK+1
     47  2634
     48  2634		       a5 45		      lda	ILSTACK	; must be less than 256
     49  2636		       18		      clc
     50  2637		       69 64		      adc	#ILSTACKSIZE*2
     51  2639		       85 45		      sta	ILSTACK
     52  263b		       a5 46		      lda	ILSTACK+1
     53  263d		       69 00		      adc	#0
     54  263f		       85 46		      sta	ILSTACK+1
     55  2641
     56  2641		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  2643		       18		      clc
     58  2644		       69 28		      adc	#MATHSTACKSIZE*2
     59  2646		       85 48		      sta	MATHSTACK
     60  2648		       a5 49		      lda	MATHSTACK+1
     61  264a		       69 00		      adc	#0
     62  264c		       85 49		      sta	MATHSTACK+1
     63  264e
     64  264e		       a5 41		      lda	VARIABLES	; must be less than 256
     65  2650		       18		      clc
     66  2651		       69 4a		      adc	#VARIABLESSIZE*2
     67  2653		       85 41		      sta	VARIABLES
     68  2655		       a5 42		      lda	VARIABLES+1
     69  2657		       69 00		      adc	#0
     70  2659		       85 42		      sta	VARIABLES+1
     71  265b		       20 f0 28 	      jsr	ContextSave
     72  265e		       4c 23 26 	      jmp	taskSetLoop
     73  2661
     74  2661				   taskSetDone
     75  2661		       a0 00		      ldy	#0	; reload the main loop context
     76  2663		       20 ff 28 	      jsr	ContextLoad
     77  2666		       60		      rts
     78  2667							;
     79  2667							;============================================================
     80  2667							; Saves the io block to the context
     81  2667
     82  2667
     83  2667		       98	   SaveIOblock tya
     84  2668		       48		      pha
     85  2669		       8a		      txa
     86  266a		       48		      pha
     87  266b
     88  266b
     89  266b
     90  266b		       68		      pla
     91  266c		       aa		      tax
     92  266d		       68		      pla
     93  266e		       a8		      tay
     94  266f		       60		      rts
     95  2670
     96  2670							;
     97  2670							;=====================================================
     98  2670							; In some error cases the math stacks may be left pointing to the wrong stack
     99  2670							; This function will reset those stack addresses but not the actual pointer
    100  2670				   taskResetStacks
    101  2670		       a0 00		      ldy	#0
    102  2672		       20 ff 28 	      jsr	ContextLoad
    103  2675		       4c fc 25 	      jmp	taskSetStacks
    104  2678							;
    105  2678							;=====================================================
    106  2678							; Clear all task entries and task stacks
    107  2678		       98	   taskReset  tya		; Save Y
    108  2679		       48		      pha
    109  267a		       a9 01		      lda	#1
    110  267c		       8d bd 37 	      sta	taskCounter	; Set number of active tasks to 1
    111  267f		       ac be 36 	      ldy	taskPtr	; Set the active task to 0 MAIN
    112  2682		       c0 00		      cpy	#0	; check if we are the main context
    113  2684		       f0 08		      beq	taskResetCont	; if we are just continue
    114  2686
    115  2686		       a0 00		      ldy	#0	; else we need to switch to the main context
    116  2688		       8c be 36 	      sty	taskPtr
    117  268b		       20 ff 28 	      jsr	ContextLoad	; load the System Task context
    118  268e				   taskResetCont
    119  268e		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    120  2690
    121  2690				   taskResetLoop
    122  2690		       a9 00		      lda	#TASKINACTIVE
    123  2692		       99 bf 36 	      sta	taskTable,y	; Ensure that the task is made inactive
    124  2695		       18		      clc
    125  2696		       98		      tya
    126  2697		       69 19		      adc	#CONTEXTLEN
    127  2699		       a8		      tay
    128  269a		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    129  269c		       90 f2		      bcc	taskResetLoop	; Go for more
    130  269e
    131  269e				   taskResetComplete
    132  269e
    133  269e		       68		      pla		; Restore y
    134  269f		       a8		      tay
    135  26a0		       60		      rts
    136  26a1
    137  26a1							;
    138  26a1							;======================================================
    139  26a1							; iTaskSwitch	 switch to new task if not interrupt and
    140  26a1							;		 count is exceded for task time slice gets here
    141  26a1							;		 when time slice has reached zero
    142  26a1							;
    143  26a1		       98	   iTaskSwitch tya
    144  26a2		       48		      pha
    145  26a3
    146  26a3		       ad bb 37 	      lda	taskResetValue	; Always reset the counter value
    147  26a6		       8d b9 37 	      sta	taskCurrentCycles	; Update the counter with the new value
    148  26a9		       ce ba 37 	      dec	taskCurrentCycles+1	; dec high order byte
    149  26ac		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    150  26ae
    151  26ae		       ad bc 37 	      lda	taskResetValue+1
    152  26b1		       8d ba 37 	      sta	taskCurrentCycles+1
    153  26b4
    154  26b4		       ad c6 19 	      lda	IRQPending	; Skip this if we are processing an irq
    155  26b7		       0d 31 43 	      ora	taskIOPending	; If set then don't switch
    156  26ba		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    157  26bc
    158  26bc		       ad bd 37    iTaskMain  lda	taskCounter	; Number of tasks
    159  26bf		       c9 01		      cmp	#1	; if there is only one task must be main
    160  26c1		       d0 07		      bne	itasknext	; if it some other number continue to next
    161  26c3
    162  26c3		       ac be 36 	      ldy	taskPtr	; check if we have not just ended some other task
    163  26c6		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    164  26c8		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    165  26ca							;
    166  26ca							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    167  26ca							;
    168  26ca				   itasknext
    169  26ca		       ac be 36 	      ldy	taskPtr
    170  26cd		       20 f0 28 	      jsr	ContextSave	; Save the current context, y points to next context
    171  26d0				   itaskLoop
    172  26d0		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    173  26d2		       90 04		      bcc	iTaskNextChk
    174  26d4
    175  26d4		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    176  26d6		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    177  26d8
    178  26d8				   iTaskNextChk
    179  26d8		       b9 bf 36 	      lda	taskTable,y	; there is always at least one entry in table
    180  26db		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    181  26dd		       18	   iTaskNext  clc
    182  26de		       98		      tya
    183  26df		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    184  26e1		       a8		      tay
    185  26e2		       4c d0 26 	      jmp	itaskLoop	; Check for busy entry
    186  26e5
    187  26e5		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    188  26e7		       59 bf 36 	      eor	taskTable,y	; Check for anything waiting io
    189  26ea		       d0 f1		      bne	iTaskNext
    190  26ec		       20 ff 28 	      jsr	ContextLoad	; load the next context
    191  26ef		       8c be 36 	      sty	taskPtr	; update the task pointer
    192  26f2
    193  26f2				   iTaskSwitchDone
    194  26f2		       68		      pla
    195  26f3		       a8		      tay
    196  26f4		       60		      rts
    197  26f5							;
    198  26f5							;================================================================
    199  26f5							; Task Set task number to line number to start
    200  26f5							; on entry stack contains, type of line description and  memvector or linenumber
    201  26f5							; Task Table structure:
    202  26f5							;    byte 0	-   Active inactive
    203  26f5							;    byte 1-2	-   Basic code line pointer
    204  26f5							;    byte 3	-   Offset on current line
    205  26f5		       98	   iTaskSet   tya		;preserve Y
    206  26f6		       48		      pha		; push a
    207  26f7		       20 dc 2c 	      jsr	popR1	; Get if compiled or line number expression
    208  26fa		       20 c4 2c 	      jsr	popR0	; Get the line number to be saved
    209  26fd
    210  26fd
    211  26fd
    212  26fd		       ac be 36 	      ldy	taskPtr	; find out where we are
    213  2700		       20 f0 28 	      jsr	ContextSave	; Save the current context
    214  2703
    215  2703							;Find the pointer to the line we need to start at
    216  2703		       a5 54		      lda	R1
    217  2705		       f0 0b		      beq	iTaskLineNum
    218  2707		       a5 52		      lda	R0
    219  2709		       85 4f		      sta	CURPTR
    220  270b		       a5 53		      lda	R0+1
    221  270d		       85 50		      sta	CURPTR+1
    222  270f		       4c 22 27 	      jmp	iTaskCont
    223  2712
    224  2712				   iTaskLineNum
    225  2712		       20 7e 2a 	      jsr	findLine	; Get the offset of the line to start task at
    226  2715		       f0 0b		      beq	iTaskCont
    227  2717
    228  2717		       ac be 36 	      ldy	taskPtr	; Restore the original Context Error Exit
    229  271a		       20 ff 28 	      jsr	ContextLoad
    230  271d
    231  271d		       68		      pla		; pop a - exit
    232  271e		       a8		      tay
    233  271f		       4c f3 0d 	      jmp	iSetIrqErr	; Bad line number provided
    234  2722
    235  2722				   iTaskCont
    236  2722		       20 c2 28 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    237  2725		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    238  2727
    239  2727		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    240  2729		       99 bf 36 	      sta	taskTable,y	; new task as active
    241  272c
    242  272c		       a5 4f		      lda	CURPTR
    243  272e		       48		      pha		; push a
    244  272f		       a5 50		      lda	CURPTR+1
    245  2731		       48		      pha		; push a
    246  2732
    247  2732		       20 ff 28 	      jsr	ContextLoad	; load the context of the new task
    248  2735
    249  2735		       68		      pla		; pop a
    250  2736		       85 50		      sta	CURPTR+1
    251  2738		       68		      pla		; pop a
    252  2739		       85 4f		      sta	CURPTR
    253  273b		       a9 03		      lda	#3	; Offset to first instruction
    254  273d		       85 51		      sta	CUROFF
    255  273f
    256  273f		       a9 00		      lda	#0
    257  2741		       85 47		      sta	ILSTACKPTR
    258  2743		       85 4a		      sta	MATHSTACKPTR
    259  2745		       85 4d		      sta	GOSUBSTACKPTR
    260  2747		       a9 40		      lda	#GOSUBSTACKSIZE*4
    261  2749		       85 4e		      sta	MESSAGEPTR
    262  274b
    263  274b		       20 75 09 	      jsr	subVINIT	; Clear the variables
    264  274e
    265  274e		       a9 0f		      lda	#STMT&$FF
    266  2750		       85 43		      sta	ILPC
    267  2752		       a9 32		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    268  2754		       85 44		      sta	ILPC+1
    269  2756
    270  2756		       98		      tya		; Save the new context offset to return to user
    271  2757		       48		      pha		; push a
    272  2758
    273  2758		       20 f0 28    itaskSetSave jsr	ContextSave	; save the updated context
    274  275b		       ee bd 37 	      inc	taskCounter	; Update the number of Tasks running
    275  275e
    276  275e		       ac be 36 	      ldy	taskPtr
    277  2761		       20 ff 28 	      jsr	ContextLoad	; restore the original context
    278  2764
    279  2764		       a9 00		      lda	#0	; Set the R0 upper to zero
    280  2766		       85 53		      sta	R0+1
    281  2768		       68		      pla		; Get the task pid we stored				 ; pop a
    282  2769		       85 52		      sta	R0	; Get the table entry value
    283  276b
    284  276b		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    285  276c		       a8		      tay
    286  276d
    287  276d		       4c 1d 07 	      jmp	pushR0nextIl	; Push R0 and continue
    288  2770				   iTaskNoEmpty
    289  2770		       ac be 36 	      ldy	taskPtr
    290  2773		       20 ff 28 	      jsr	ContextLoad
    291  2776
    292  2776		       68		      pla		; pop a    -- exit
    293  2777		       a8		      tay
    294  2778
    295  2778		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    296  277a		       a9 00		      lda	#0
    297  277c		       4c 7d 06 	      jmp	iErr2
    298  277f							;
    299  277f							;===============================================================
    300  277f							; Run the task whos PID is on the stack, preserve the stack
    301  277f							;
    302  277f				   iTaskEnable
    303  277f		       98		      tya
    304  2780		       48		      pha
    305  2781		       20 dc 2c 	      jsr	popR1
    306  2784		       20 aa 2c 	      jsr	pushR1
    307  2787		       20 f6 29 	      jsr	ipc_getcontext	; get context pointer into mq
    308  278a		       a0 00		      ldy	#0
    309  278c		       b1 56		      lda	(MQ),y
    310  278e		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    311  2790		       09 80		      ora	#TASKACTIVE
    312  2792		       91 56		      sta	(MQ),y
    313  2794		       68		      pla
    314  2795		       a8		      tay
    315  2796		       4c b1 02 	      jmp	NextIL
    316  2799
    317  2799							;
    318  2799							;===============================================================
    319  2799							; Suspend the task whos PID  is on the stack, preserve the stack
    320  2799							;
    321  2799				   iTaskSuspend
    322  2799		       98		      tya
    323  279a		       48		      pha
    324  279b		       20 dc 2c 	      jsr	popR1
    325  279e		       20 aa 2c 	      jsr	pushR1
    326  27a1		       20 f6 29 	      jsr	ipc_getcontext	; get context pointer into mq
    327  27a4		       a0 00		      ldy	#0
    328  27a6		       b1 56		      lda	(MQ),y
    329  27a8		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    330  27aa		       09 80		      ora	#TASKACTIVE
    331  27ac		       68		      pla
    332  27ad		       a8		      tay
    333  27ae		       4c b1 02 	      jmp	NextIL
    334  27b1
    335  27b1							;================================================================
    336  27b1							; Returns task Status
    337  27b1				   iTaskStat
    338  27b1		       98		      tya
    339  27b2		       48		      pha
    340  27b3		       20 c5 27 	      jsr	iTaskValid	; returns pointer to task entry
    341  27b6		       b9 bf 36 	      lda	taskTable,y
    342  27b9		       f0 05		      beq	iTaskStatExit
    343  27bb		       68		      pla
    344  27bc		       a8		      tay
    345  27bd		       4c 83 0d 	      jmp	iTruth
    346  27c0				   iTaskStatExit
    347  27c0		       68		      pla
    348  27c1		       a8		      tay
    349  27c2		       4c 8c 0d 	      jmp	iFalse
    350  27c5
    351  27c5							;
    352  27c5							;================================================================
    353  27c5							; Validate the task number on top of the stack
    354  27c5							; on exit y points to the requested task entry
    355  27c5							;
    356  27c5		       20 c4 2c    iTaskValid jsr	popR0	; get result of the multiply
    357  27c8		       a5 53		      lda	R0+1
    358  27ca		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    359  27cc		       a5 52		      lda	R0
    360  27ce		       c9 fa		      cmp	#TASKTABLELEN
    361  27d0		       90 09		      bcc	iTaskIsValid
    362  27d2
    363  27d2		       68	   iTaskValidErr pla		;remove return address
    364  27d3		       68		      pla
    365  27d4		       a2 10		      ldx	#ERR_INVALID_PID
    366  27d6		       a9 00		      lda	#0
    367  27d8		       4c 7d 06 	      jmp	iErr2
    368  27db
    369  27db		       a8	   iTaskIsValid tay
    370  27dc		       60		      rts
    371  27dd							;
    372  27dd							;================================================================
    373  27dd							; Kill a running task, do nothing if already stopped
    374  27dd		       20 c5 27    iTaskKill  jsr	iTaskValid
    375  27e0		       a9 00		      lda	#0
    376  27e2		       99 bf 36 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    377  27e5							;
    378  27e5							;================================================================
    379  27e5							;Skip to next task
    380  27e5				   iNTask
    381  27e5		       a9 01		      lda	#1
    382  27e7		       8d b9 37 	      sta	taskCurrentCycles
    383  27ea		       8d ba 37 	      sta	taskCurrentCycles+1
    384  27ed		       4c b1 02 	      jmp	NextIL
    385  27f0							;
    386  27f0							;=======================================================
    387  27f0							; Wait for a task to complete
    388  27f0				   iWTASK
    389  27f0		       20 39 2a 	      jsr	getILByte
    390  27f3		       8d 2f 43 	      sta	offset
    391  27f6							;
    392  27f6		       20 1c 2c 	      jsr	saveIL	;in case of failure
    393  27f9
    394  27f9		       20 c5 27 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    395  27fc		       b9 bf 36 	      lda	taskTable,y
    396  27ff		       d0 03		      bne	iWTASKWAIT
    397  2801				   iWTASKEXITED
    398  2801		       4c b1 02 	      jmp	NextIL
    399  2804				   iWTASKWAIT
    400  2804		       20 32 2c 	      jsr	pushR0	; Push R0 back onto the stack
    401  2807		       a9 01		      lda	#1
    402  2809		       8d b9 37 	      sta	taskCurrentCycles	; Give up the cycles
    403  280c		       8d ba 37 	      sta	taskCurrentCycles+1
    404  280f		       20 27 2c 	      jsr	restoreIL
    405  2812		       4c e0 0b 	      jmp	tstBranch
    406  2815							;
    407  2815							;=======================================================
    408  2815							; Set task io lock
    409  2815		       ee 31 43    iStartIO   inc	taskIOPending
    410  2818		       4c b1 02 	      jmp	NextIL
    411  281b							;
    412  281b							;=======================================================
    413  281b							; Release the io lock
    414  281b		       ad 31 43    iEndIO     lda	taskIOPending
    415  281e		       f0 03		      beq	iEndIOExit
    416  2820		       ce 31 43 	      dec	taskIOPending
    417  2823		       4c b1 02    iEndIOExit jmp	NextIL
    418  2826							;
    419  2826							;===============================================================
    420  2826							; Return the task PID
    421  2826				   iTASKPID
    422  2826		       a9 00		      lda	#0
    423  2828		       85 53		      sta	R0+1
    424  282a		       ad be 36 	      lda	taskPtr
    425  282d		       85 52		      sta	R0
    426  282f		       4c 1d 07 	      jmp	pushR0nextIl
    427  2832							;
    428  2832							;================================================================
    429  2832							; Terminate a task
    430  2832		       ac be 36    iETask     ldy	taskPtr
    431  2835		       c0 00		      cpy	#0
    432  2837		       d0 03		      bne	iETaskCont
    433  2839		       4c 02 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    434  283c				   iETaskCont
    435  283c		       a9 00		      lda	#TASKINACTIVE
    436  283e		       99 bf 36 	      sta	taskTable,y	; mark entry as free
    437  2841		       ce bd 37 	      dec	taskCounter	; reduce the number of active tasks
    438  2844		       a9 01		      lda	#1
    439  2846		       8d b9 37 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    440  2849		       8d ba 37 	      sta	taskCurrentCycles+1
    441  284c		       20 dd 28 	      jsr	TaskSetExitCode
    442  284f				   iETaskExit
    443  284f		       4c b1 02 	      jmp	NextIL
    444  2852							;================================================================
    445  2852							; make the current tasks math stack equal another tasks stack
    446  2852							; The task to get is stored on the math stack
    447  2852
    448  2852				   iTaskGetMathStack
    449  2852		       20 03 2f 	      jsr	CopyStackR1	; Get the top of stack to R1
    450  2855		       20 f6 29 	      jsr	ipc_getcontext	; MQ now has the context address
    451  2858		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  285a		       b1 56		      lda	(MQ),y
    453  285c		       85 4a		      sta	MATHSTACKPTR
    454  285e		       a0 08		      ldy	#MATHSTACKPOS
    455  2860		       b1 56		      lda	(MQ),y
    456  2862		       85 48		      sta	MATHSTACK
    457  2864		       c8		      iny
    458  2865		       b1 56		      lda	(MQ),y
    459  2867		       85 49		      sta	MATHSTACK+1
    460  2869		       4c b1 02 	      jmp	NextIL
    461  286c							;==================================================================
    462  286c							; Updates the tasks math stack pointer with contents of R2
    463  286c							; PID is on top of the stack
    464  286c				   iTaskPutMathPtr
    465  286c		       20 03 2f 	      jsr	CopyStackR1	; Get the top of stack to R1
    466  286f		       20 f6 29 	      jsr	ipc_getcontext	; MQ now has the context address
    467  2872		       a5 58		      lda	R2	; R2 contains the number of parameters/offset
    468  2874		       a0 0a		      ldy	#MATHSTACKPTRPOS	; Pointer to new tasks stack pointer
    469  2876		       91 56		      sta	(MQ),y	; update it to point to the free space on stack
    470  2878							;if parm count > 0 then we need to create a parameter block on the tasks gosubStack
    471  2878		       c9 00		      cmp	#0	; if no parameters then
    472  287a		       f0 26		      beq	iTaskPutMathPtrExit	; just get out of here
    473  287c
    474  287c		       a0 0b		      ldy	#GOSUBSTKPOS
    475  287e		       b1 56		      lda	(MQ),y	; get the address of the new tasks gosub stack into R1
    476  2880		       85 54		      sta	R1
    477  2882		       c8		      iny
    478  2883		       b1 56		      lda	(MQ),y
    479  2885		       85 55		      sta	R1+1
    480  2887
    481  2887		       a9 00		      lda	#0	; Store the math stack offset into new gosub stack, always 0
    482  2889		       91 54		      sta	(R1),y
    483  288b
    484  288b		       c8		      iny
    485  288c		       18		      clc		; We need to turn stack ptr to actual parm count
    486  288d		       e9 01		      sbc	#1	; Stack pointer always point to next free byte
    487  288f		       0a		      asl
    488  2890		       91 54		      sta	(R1),y
    489  2892
    490  2892		       c8		      iny
    491  2893		       a9 ff		      lda	#$FF	; Dummy field, not used
    492  2895		       91 54		      sta	(R1),y
    493  2897		       c8		      iny
    494  2898		       a9 05		      lda	#GOSUB_STACK_FRAME	; Tell its a stck frame, ie identify param cnt etc
    495  289a		       91 54		      sta	(R1),y
    496  289c		       c8		      iny
    497  289d		       98		      tya
    498  289e		       a0 0d		      ldy	#GOSUBPTRPOS
    499  28a0		       91 56		      sta	(MQ),y	; update the new tasks gosub stk pointer
    500  28a2
    501  28a2				   iTaskPutMathPtrExit
    502  28a2		       4c b1 02 	      jmp	NextIL
    503  28a5							;
    504  28a5							;================================================================
    505  28a5							; Set the time slice for each task
    506  28a5				   iSLICE
    507  28a5		       20 c4 2c 	      jsr	popR0
    508  28a8		       a5 52		      lda	R0
    509  28aa		       8d bb 37 	      sta	taskResetValue
    510  28ad		       a5 53		      lda	R0+1
    511  28af		       8d bc 37 	      sta	taskResetValue+1
    512  28b2		       d0 0b		      bne	iSliceSet
    513  28b4		       ee bc 37 	      inc	taskResetValue+1	; must be at least 1 high counter
    514  28b7		       a9 01		      lda	#1
    515  28b9		       8d b9 37 	      sta	taskCurrentCycles
    516  28bc		       8d ba 37 	      sta	taskCurrentCycles+1
    517  28bf				   iSliceSet
    518  28bf		       4c b1 02 	      jmp	NextIL
    519  28c2							;================================================================
    520  28c2							; Find an empty slot in the taskTable
    521  28c2							; Return the index in y
    522  28c2							; on exit   c set if an empty slot is found
    523  28c2							;	     c clear if not found
    524  28c2							;================================================================
    525  28c2							;
    526  28c2		       ad bd 37    TaskEmpty  lda	taskCounter
    527  28c5		       c9 0a		      cmp	#TASKCOUNT
    528  28c7		       b0 10		      bcs	TaskNoSlot
    529  28c9		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    530  28cb				   TaskLoop
    531  28cb		       b9 bf 36 	      lda	taskTable,y
    532  28ce		       f0 0b		      beq	TaskEmptyFnd
    533  28d0		       98		      tya
    534  28d1		       18		      clc
    535  28d2		       69 19		      adc	#CONTEXTLEN
    536  28d4		       a8		      tay
    537  28d5		       c0 fa		      cpy	#TASKTABLELEN
    538  28d7		       90 f2		      bcc	TaskLoop	; Y is never zero
    539  28d9				   TaskNoSlot
    540  28d9		       18		      clc
    541  28da		       60		      rts
    542  28db				   TaskEmptyFnd
    543  28db		       38		      sec
    544  28dc		       60		      rts
    545  28dd							;====================================================
    546  28dd							; Set the task exit code called from the return command
    547  28dd							; on entry stack top hold exit value
    548  28dd				   TaskSetExitCode
    549  28dd		       98		      tya
    550  28de		       48		      pha
    551  28df		       20 c4 2c 	      jsr	popR0
    552  28e2		       a0 48		      ldy	#TASKEXITCODE
    553  28e4		       a5 52		      lda	R0
    554  28e6		       91 41		      sta	(VARIABLES),y
    555  28e8		       c8		      iny
    556  28e9		       a5 53		      lda	R0+1
    557  28eb		       91 41		      sta	(VARIABLES),y
    558  28ed		       68		      pla
    559  28ee		       98		      tya
    560  28ef		       60		      rts
    561  28f0
    562  28f0							;
    563  28f0							;=====================================================
    564  28f0							; Save Context Store the context to the TASK Table
    565  28f0							; on entry y contains the task table entry to save to
    566  28f0							; on exit y points to next task table entry
    567  28f0							;	   x contains the number of bytes copied
    568  28f0		       a2 00	   ContextSave ldx	#0
    569  28f2		       c8		      iny		;inc past the task flags
    570  28f3		       b5 41	   ContextSvLoop lda	CONTEXT,x
    571  28f5		       99 bf 36 	      sta	taskTable,y
    572  28f8		       c8		      iny
    573  28f9		       e8		      inx
    574  28fa		       e0 18		      cpx	#[CONTEXTLEN-1]
    575  28fc		       90 f5		      bcc	ContextSvLoop
    576  28fe		       60		      rts
    577  28ff							;
    578  28ff							; Load Context transfer context from task table to the Current Context
    579  28ff							; on entry y contains the task table entry to transfer
    580  28ff							; on exit y points to the original task table entry
    581  28ff							;	   x contains the number of bytes copied
    582  28ff		       98	   ContextLoad tya
    583  2900		       48		      pha
    584  2901		       a2 00		      ldx	#0
    585  2903		       c8		      iny		;inc past the task flags
    586  2904		       b9 bf 36    ContextLDLoop lda	taskTable,y
    587  2907		       95 41		      sta	CONTEXT,x
    588  2909		       c8		      iny
    589  290a		       e8		      inx
    590  290b		       e0 18		      cpx	#[CONTEXTLEN-1]
    591  290d		       90 f5		      bcc	ContextLDLoop
    592  290f		       68		      pla
    593  2910		       a8		      tay
    594  2911		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  2912					      include	"ipc.asm"
      1  2912							;======================================================
      2  2912							; Inter process communications.
      3  2912							; Tasks may write/read integer messages among
      4  2912							; them selves.
      5  2912							; This uses each tasks gosub stack as a message queue
      6  2912							; Gosub calls start at the highest address and the
      7  2912							; msg queue starts at the highest address.
      8  2912							;
      9  2912							;======================================================
     10  2912							; ipcs   - Send msg to another task or many tasks
     11  2912							; on entry  math stack contains the  top PID
     12  2912							;				      2ND Message value
     13  2912							; on exit   math stack contain top True-good or False-failed
     14  2912							;
     15  2912							; it may not be sent if queue is full
     16  2912							;
     17  2912							; a = ipcs(<message-expression>,<task PID-expression>)
     18  2912							;
     19  2912				   iIPCS
     20  2912		       98		      tya
     21  2913		       48		      pha
     22  2914		       20 7b 29 	      jsr	ipc_enqueue
     23  2917		       b0 08		      bcs	iIPC_BAD
     24  2919		       20 f5 2e 	      jsr	pushTrue
     25  291c		       68		      pla
     26  291d		       a8		      tay
     27  291e		       4c b1 02 	      jmp	NextIL
     28  2921				   iIPC_BAD
     29  2921		       68		      pla
     30  2922		       a8		      tay
     31  2923		       20 ff 2e 	      jsr	pushFalse
     32  2926		       4c b1 02 	      jmp	NextIL
     33  2929
     34  2929							;======================================================
     35  2929							; ipcr   - Recieve msg from task
     36  2929							; on exit  the message value is returned from message queue
     37  2929							;	    message -1	is reserved meaning no entry found
     38  2929							; The provided variable contains the pid of the sending
     39  2929							; task. This is optional. This always waits for a message
     40  2929							; before returning.
     41  2929							;
     42  2929							; a = ipcr(<variable name>)
     43  2929							;
     44  2929				   iIPCR
     45  2929		       98		      tya
     46  292a		       48		      pha
     47  292b		       20 bd 29 	      jsr	ipc_dequeue
     48  292e		       b0 05		      bcs	iIPCR_Q_Empty
     49  2930		       68		      pla
     50  2931		       a8		      tay
     51  2932		       4c b1 02 	      jmp	NextIL
     52  2935				   iIPCR_Q_Empty
     53  2935		       68		      pla
     54  2936		       a8		      tay
     55  2937		       20 f5 2e 	      jsr	pushTrue	; puts -1 on the stack
     56  293a		       4c b1 02 	      jmp	NextIL
     57  293d
     58  293d							;=======================================================
     59  293d							; ipcc   - Check if message available
     60  293d							; on exit  Stack contains number of messages
     61  293d							;
     62  293d							; a = ipcc()
     63  293d							;
     64  293d				   iIPCC
     65  293d		       98		      tya
     66  293e		       48		      pha
     67  293f		       20 68 29 	      jsr	ipc_queue_count
     68  2942		       20 32 2c 	      jsr	pushR0	; return the count
     69  2945		       68		      pla
     70  2946		       a8		      tay
     71  2947		       4c b1 02 	      jmp	NextIL
     72  294a
     73  294a							;=======================================================
     74  294a							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  294a				   iIPCIO
     76  294a		       98		      tya
     77  294b		       48		      pha
     78  294c		       20 68 29 	      jsr	ipc_queue_count
     79  294f		       a5 52		      lda	R0
     80  2951		       d0 10		      bne	iIPCIO_No_Halt
     81  2953		       a9 01		      lda	#1
     82  2955		       8d b9 37 	      sta	taskCurrentCycles	; force a task switch
     83  2958		       a9 01		      lda	#TASKWAITIPC
     84  295a		       ac be 36 	      ldy	taskPtr
     85  295d		       19 bf 36 	      ora	taskTable,y
     86  2960		       99 bf 36 	      sta	taskTable,y
     87  2963
     88  2963				   iIPCIO_No_Halt
     89  2963		       68		      pla
     90  2964		       a8		      tay
     91  2965		       4c b1 02 	      jmp	NextIL
     92  2968							;======================================================
     93  2968							;ipc_queue_count
     94  2968				   ipc_queue_count
     95  2968		       a5 4e		      lda	MESSAGEPTR
     96  296a		       18		      clc
     97  296b		       4a		      lsr		; divide by 4
     98  296c		       4a		      lsr
     99  296d		       85 52		      sta	R0	; store into R0
    100  296f		       a9 10		      lda	#GOSUBSTACKSIZE
    101  2971		       38		      sec
    102  2972		       e5 52		      sbc	R0	; Get how many entries on queue
    103  2974		       85 52		      sta	R0
    104  2976		       a9 00		      lda	#0
    105  2978		       85 53		      sta	R0+1
    106  297a		       60		      rts
    107  297b							;=======================================================
    108  297b							; Support functions for messaging
    109  297b							;
    110  297b							; Enqueue message -> onto PID's MSG Q
    111  297b							; on entry top of stack contains the PID
    112  297b							;	    second contains the Message of the task
    113  297b							; on exit contains c set if failed
    114  297b							;		    c cleared if success
    115  297b							;		    PID's MSG Q PTR points to the message
    116  297b							;
    117  297b				   ipc_enqueue
    118  297b		       20 dc 2c 	      jsr	popR1	; Get the pid
    119  297e		       20 f6 29 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  2981
    121  2981		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  2983		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  2985		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  2987		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  2989		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  298b
    127  298b
    128  298b							; Get the PID'S stack address into R0
    129  298b		       a0 0b		      ldy	#GOSUBSTKPOS
    130  298d		       b1 56		      lda	(MQ),y
    131  298f		       85 52		      sta	R0
    132  2991		       c8		      iny
    133  2992		       b1 56		      lda	(MQ),y
    134  2994		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  2996
    136  2996							; Set y to point to the msg q entry
    137  2996		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  2998		       b1 56		      lda	(MQ),y	; Get the index
    139  299a		       a8		      tay		; Set y to queue offset
    140  299b
    141  299b							; enqueue the message
    142  299b		       88		      dey		; First byte to save to
    143  299c		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  299e		       91 52		      sta	(R0),y	; Set the entry type
    145  29a0
    146  29a0		       88		      dey
    147  29a1		       ad be 36 	      lda	taskPtr	; Store the PID into queue
    148  29a4		       91 52		      sta	(R0),y
    149  29a6		       20 dc 2c 	      jsr	popR1	; Get the actual message value
    150  29a9		       20 2a 2a 	      jsr	ipc_pushR1	; Store Message value into queue
    151  29ac
    152  29ac		       98		      tya		; Save the new q ptr
    153  29ad		       a0 0e		      ldy	#MSGPTRPOS
    154  29af		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  29b1		       a0 00		      ldy	#0	; points to context root
    156  29b3		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  29b5		       51 56		      eor	(MQ),y	; Turn off the bit
    158  29b7		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  29b9		       18		      clc
    160  29ba		       60		      rts
    161  29bb				   ipc_enq_full
    162  29bb		       38		      sec
    163  29bc		       60		      rts
    164  29bd							;=============================================================
    165  29bd							; De-queue for message stack -> local tasks msg q
    166  29bd							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  29bd							;  message into
    168  29bd							;  on exit   math stack contains value of message
    169  29bd							;				  Variable if provided is pid
    170  29bd				   ipc_dequeue
    171  29bd		       20 f3 2c 	      jsr	popMQ	; Variable address to put PID into
    172  29c0
    173  29c0		       a4 4e		      ldy	MESSAGEPTR
    174  29c2		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    175  29c4		       b0 2e		      bcs	ipc_deq_empty
    176  29c6		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  29c8		       85 52		      sta	R0
    178  29ca		       c8		      iny
    179  29cb		       b1 4b		      lda	(GOSUBSTACK),y
    180  29cd		       85 53		      sta	R0+1
    181  29cf		       c8		      iny
    182  29d0		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  29d2		       85 54		      sta	R1
    184  29d4		       c8		      iny
    185  29d5		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  29d7		       c8		      iny
    187  29d8		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  29da
    189  29da		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  29dc		       d0 16		      bne	ipc_deq_empty
    191  29de
    192  29de		       20 32 2c 	      jsr	pushR0	; place value on stack
    193  29e1
    194  29e1		       a5 56		      lda	MQ
    195  29e3		       05 57		      ora	MQ+1
    196  29e5		       f0 0b		      beq	ipc_deq_done
    197  29e7		       a5 54		      lda	R1
    198  29e9		       a0 00		      ldy	#0
    199  29eb		       91 56		      sta	(MQ),y
    200  29ed		       c8		      iny
    201  29ee		       a9 00		      lda	#0
    202  29f0		       91 56		      sta	(MQ),y
    203  29f2				   ipc_deq_done
    204  29f2		       18		      clc
    205  29f3		       60		      rts
    206  29f4
    207  29f4				   ipc_deq_empty
    208  29f4		       38		      sec
    209  29f5		       60		      rts
    210  29f6
    211  29f6							;=============================================
    212  29f6							;  Get the context address into MQ from R1 with
    213  29f6							;  context/index/pid
    214  29f6				   ipc_getcontext
    215  29f6		       18		      clc		; Get pointer to Task context
    216  29f7		       a9 bf		      lda	#taskTable&$FF	; change ptr to address
    217  29f9		       65 54		      adc	R1
    218  29fb		       85 56		      sta	MQ
    219  29fd		       a9 36		      lda	#taskTable>>8
    220  29ff		       65 55		      adc	R1+1
    221  2a01		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  2a03		       60		      rts
    223  2a04							;
    224  2a04							;==============================================
    225  2a04							; on entry R1 has a context value,
    226  2a04							; on exit c is set if fails
    227  2a04							;
    228  2a04				   ipc_CONTEXTVALUES
      0  2a04					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  2a04		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  2a08					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  2a08		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  2a0c					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  2a0c		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    232  2a0e
    233  2a0e				   ipc_ValidateContext
    234  2a0e		       48		      pha
    235  2a0f		       8a		      txa
    236  2a10		       48		      pha
    237  2a11		       a5 55		      lda	R1+1
    238  2a13		       d0 0e		      bne	ipc_Validate_Fail
    239  2a15		       a2 00		      ldx	#0
    240  2a17		       a5 54		      lda	R1
    241  2a19				   ipc_ValidateLoop
    242  2a19		       dd 04 2a 	      cmp	ipc_CONTEXTVALUES,x
    243  2a1c		       f0 09		      beq	ipc_Valid_Context
    244  2a1e		       e8		      inx
    245  2a1f		       e0 0a		      cpx	#TASKCOUNT
    246  2a21		       90 f6		      bcc	ipc_ValidateLoop
    247  2a23
    248  2a23				   ipc_Validate_Fail
    249  2a23		       68		      pla
    250  2a24		       aa		      tax
    251  2a25		       68		      pla
    252  2a26		       60		      rts
    253  2a27
    254  2a27				   ipc_Valid_Context
    255  2a27		       18		      clc
    256  2a28		       90 f9		      bcc	ipc_Validate_Fail
    257  2a2a							;
    258  2a2a							;==============================================
    259  2a2a							;Push R1 onto the stack
    260  2a2a							;on entry y = next entry
    261  2a2a							;R0 points to the stack space
    262  2a2a							;on exit y points to next free byte
    263  2a2a				   ipc_pushR1
    264  2a2a		       88		      dey
    265  2a2b		       a5 55		      lda	R1+1	; PID first
    266  2a2d		       91 52		      sta	(R0),y
    267  2a2f		       88		      dey
    268  2a30		       a5 54		      lda	R1
    269  2a32		       91 52		      sta	(R0),y
    270  2a34		       60		      rts
    271  2a35
    272  2a35
    273  2a35
    274  2a35
    275  2a35
    276  2a35
    277  2a35
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  2a35					      include	"support.asm"
      1  2a35							;
      2  2a35							;=====================================================
      3  2a35							;=====================================================
      4  2a35							;=====================================================
      5  2a35							; This marks the start of support functions used by
      6  2a35							; the IL opcodes.  These are support functions, NOT
      7  2a35							; the IL code.
      8  2a35							;=====================================================
      9  2a35							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  2a35							;=====================================================
     11  2a35					      Seg	Code
     12  2a35							;=====================================================
     13  2a35							; This gets the next two bytes pointed to by ILPC and
     14  2a35							; returns them; X contains LSB, A contains MSB.  ILPC
     15  2a35							; is advanced by two, and Y contains 0 on return.
     16  2a35
     17  2a35							;
     18  2a35		       20 39 2a    getILWord  jsr	getILByte	;LSB
     19  2a38		       aa		      tax
     20  2a39							;
     21  2a39							;=====================================================
     22  2a39							; This gets the next byte pointed to by ILPC and
     23  2a39							; returns it in A.  On return, X is unchanged but Y
     24  2a39							; contains 0.
     25  2a39							;
     26  2a39		       a0 00	   getILByte  ldy	#0
     27  2a3b		       b1 43		      lda	(ILPC),y	;get byte
     28  2a3d		       08		      php		;save status
     29  2a3e		       e6 43		      inc	ILPC	;inc LSB
     30  2a40		       d0 02		      bne	getILb2	;branch if no overflow
     31  2a42		       e6 44		      inc	ILPC+1	;inc MSB
     32  2a44		       28	   getILb2    plp		;restore status
     33  2a45		       60		      rts
     34  2a46							;
     35  2a46							;=====================================================
     36  2a46							; Decrement ILPC by one.
     37  2a46							;
     38  2a46		       a5 43	   decIL      lda	ILPC
     39  2a48		       d0 02		      bne	decIL2
     40  2a4a		       c6 44		      dec	ILPC+1
     41  2a4c		       c6 43	   decIL2     dec	ILPC
     42  2a4e		       60		      rts
     43  2a4f							;
     44  2a4f							;=====================================================
     45  2a4f							; Push the ILPC onto the return stack.  Actually, this
     46  2a4f							; pushes the address of ILPC+2 since that's the next
     47  2a4f							; address to execute.
     48  2a4f							;
     49  2a4f		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  2a51		       c0 64		      cpy	#ILSTACKSIZE<<1
     51  2a53		       b0 15		      bcs	pushErr
     52  2a55		       a5 43		      lda	ILPC
     53  2a57		       18		      clc
     54  2a58		       69 02		      adc	#2
     55  2a5a		       91 45		      sta	(ILSTACK),y
     56  2a5c		       08		      php		;save C bit
     57  2a5d		       c8		      iny
     58  2a5e		       a5 44		      lda	ILPC+1
     59  2a60		       28		      plp		;restore C
     60  2a61		       69 00		      adc	#0
     61  2a63		       91 45		      sta	(ILSTACK),y
     62  2a65		       c8		      iny
     63  2a66		       84 47		      sty	ILSTACKPTR
     64  2a68		       18		      clc
     65  2a69		       60		      rts
     66  2a6a				   pushErr
     67  2a6a		       38		      sec
     68  2a6b		       60		      rts
     69  2a6c							;
     70  2a6c							;=====================================================
     71  2a6c							; Pull the top entry from return stack and put into
     72  2a6c							; ILPC.
     73  2a6c							;
     74  2a6c		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  2a6e		       f0 fa		      beq	pushErr
     76  2a70		       88		      dey
     77  2a71		       b1 45		      lda	(ILSTACK),y
     78  2a73		       85 44		      sta	ILPC+1
     79  2a75		       88		      dey
     80  2a76		       b1 45		      lda	(ILSTACK),y
     81  2a78		       85 43		      sta	ILPC
     82  2a7a		       84 47		      sty	ILSTACKPTR
     83  2a7c		       18		      clc
     84  2a7d		       60		      rts
     85  2a7e							;
     86  2a7e							;=====================================================
     87  2a7e							; This searches for a specific line number that is in
     88  2a7e							; R0.	There are three possible return conditions:
     89  2a7e							; Line numbers are now the third byte, the first byte is now
     90  2a7e							; a pointer to the next line, of course no longer than 255 byte
     91  2a7e							; per line.
     92  2a7e							;
     93  2a7e							; Exact match was found:
     94  2a7e							;    * Z set
     95  2a7e							;    * CURPTR points to two-byte line number for that
     96  2a7e							;	line.
     97  2a7e							;
     98  2a7e							; Next highest line found:
     99  2a7e							;    * Z cleared
    100  2a7e							;    * C set
    101  2a7e							;    * CURPTR points to two-byte line number for that
    102  2a7e							;	line.
    103  2a7e							;
    104  2a7e							; End of program reached:
    105  2a7e							;    * Z cleared
    106  2a7e							;    * C cleared
    107  2a7e							;    * CURPTR points to first free byte at end of
    108  2a7e							;	program.  Ie, it has save value as PROGRAMEND.
    109  2a7e							;
    110  2a7e							; A, X, and Y are all undefined on return.
    111  2a7e							;
    112  2a7e
    113  2a7e				   findLine
    114  2a7e		       ad 37 43 	      lda	ProgramStart	;Start of program -> CURPTR
    115  2a81		       85 4f		      sta	CURPTR
    116  2a83		       ad 38 43 	      lda	ProgramStart+1
    117  2a86		       85 50		      sta	CURPTR+1
    118  2a88							;
    119  2a88							; At end of code?
    120  2a88							;
    121  2a88				   iXFER1
    122  2a88		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  2a8a		       cd 39 43 	      cmp	ProgramEnd	; at end of program then stop run
    124  2a8d		       d0 0b		      bne	xfer2	; not end
    125  2a8f		       a5 50		      lda	CURPTR+1
    126  2a91		       cd 3a 43 	      cmp	ProgramEnd+1
    127  2a94		       d0 04		      bne	xfer2	;Not at end
    128  2a96							;
    129  2a96							; Line not found and the end of the program was
    130  2a96							; reached.  Return Z and C both clear.
    131  2a96							;
    132  2a96		       a9 01		      lda	#1	;clear Z
    133  2a98		       18		      clc		;clear C
    134  2a99		       60		      rts
    135  2a9a							;
    136  2a9a							; Check for an exact line number match
    137  2a9a							;
    138  2a9a		       a5 52	   xfer2      lda	R0
    139  2a9c		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  2a9e		       d1 4f		      cmp	(CURPTR),y
    141  2aa0		       d0 08		      bne	xfernotit
    142  2aa2		       c8		      iny
    143  2aa3		       a5 53		      lda	R0+1
    144  2aa5		       d1 4f		      cmp	(CURPTR),y
    145  2aa7		       d0 01		      bne	xfernotit	; not a matching line number
    146  2aa9							;
    147  2aa9							; This is exactly the line we want.
    148  2aa9							;
    149  2aa9		       60		      rts		;it matches exactly
    150  2aaa							;
    151  2aaa							; See if this line is greater than the one we're
    152  2aaa							; searching for.
    153  2aaa							;
    154  2aaa		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  2aac		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  2aae		       c5 53		      cmp	R0+1
    157  2ab0		       90 0b		      bcc	xfer3
    158  2ab2		       d0 07		      bne	xfer4
    159  2ab4		       88		      dey
    160  2ab5		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  2ab7		       c5 52		      cmp	R0
    162  2ab9		       90 02		      bcc	xfer3
    163  2abb							;
    164  2abb							; This line is greater than the one we want, so
    165  2abb							; return Z clear and C set.
    166  2abb							;
    167  2abb		       38	   xfer4      sec		;We found a line number greater
    168  2abc		       60		      rts		;both conditions set
    169  2abd							;
    170  2abd							; Not the line (or droid) we're looking for.  Move to
    171  2abd							; the next line.
    172  2abd							;
    173  2abd		       20 c3 2a    xfer3      jsr	FindNextLine
    174  2ac0		       4c 88 2a 	      jmp	iXFER1
    175  2ac3							;
    176  2ac3							;=====================================================
    177  2ac3							; This advances CURPTR to the next line.  If there
    178  2ac3							; are no more lines, this leaves CURPTR equal to
    179  2ac3							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  2ac3							; CURPTR is pointing to a valid line on entry.  This
    181  2ac3							; pointer points to the two-byte line number.
    182  2ac3							; Update this points to the 1 byte line length  ****************
    183  2ac3							;
    184  2ac3				   FindNextLine
    185  2ac3		       a0 03		      ldy	#3	;skip line number and length byte
    186  2ac5		       84 51		      sty	CUROFF	;this is the new offset
    187  2ac7		       a0 00		      ldy	#0
    188  2ac9		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  2acb		       18		      clc
    190  2acc		       65 4f		      adc	CURPTR
    191  2ace		       85 4f		      sta	CURPTR
    192  2ad0		       a5 50		      lda	CURPTR+1
    193  2ad2		       69 00		      adc	#0
    194  2ad4		       85 50		      sta	CURPTR+1
    195  2ad6		       60	   FindNext4  rts
    196  2ad7							;
    197  2ad7							;=====================================================
    198  2ad7							; This compares CURPTR to PROGRAMEND and returns Z set
    199  2ad7							; if they are equal, Z clear if not.
    200  2ad7							;
    201  2ad7		       a5 4f	   AtEnd      lda	CURPTR
    202  2ad9		       cd 39 43 	      cmp	ProgramEnd
    203  2adc		       d0 05		      bne	atendexit
    204  2ade		       a5 50		      lda	CURPTR+1
    205  2ae0		       cd 3a 43 	      cmp	ProgramEnd+1
    206  2ae3		       60	   atendexit  rts
    207  2ae4							;
    208  2ae4
    209  2ae4							;
    210  2ae4							;=====================================================
    211  2ae4							; Convert an ASCII string to a number.  On input,
    212  2ae4							; (CURPTR),Y points to the first digit.  This gets
    213  2ae4							; digit-by-digit until finding a non-number.  Returns
    214  2ae4							; Y pointing to the non-digit, and R0 contains the
    215  2ae4							; number.  This does NOT check for valid ranges, so
    216  2ae4							; a value like "123456789" will produce something,
    217  2ae4							; but not what you had expected.
    218  2ae4							;
    219  2ae4		       a9 00	   getDecimal lda	#0
    220  2ae6		       85 52		      sta	R0
    221  2ae8		       85 53		      sta	R0+1
    222  2aea		       85 59		      sta	dpl	;temporary negative flag
    223  2aec							;
    224  2aec							; See if it's negative...
    225  2aec							;
    226  2aec							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  2aec		       b1 4f		      lda	(CURPTR),y
    228  2aee		       c9 2d		      cmp	#'-
    229  2af0		       d0 02		      bne	getDecLoop
    230  2af2		       e6 59		      inc	dpl	;it's negative
    231  2af4							;
    232  2af4		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  2af6		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  2af8		       c9 30		      cmp	#'0
    235  2afa		       90 36		      bcc	getDdone
    236  2afc		       c9 3a		      cmp	#'9+1
    237  2afe		       b0 32		      bcs	getDdone
    238  2b00		       38		      sec
    239  2b01		       e9 30		      sbc	#'0	;convert to binary
    240  2b03		       48		      pha
    241  2b04							;
    242  2b04							; Now multiply R0 by 10.  Remember that
    243  2b04							; 2*N + 8*N = 10*N.
    244  2b04							;
    245  2b04		       06 52		      asl	R0
    246  2b06		       26 53		      rol	R0+1	;*2
    247  2b08		       a5 52		      lda	R0
    248  2b0a		       85 54		      sta	R1
    249  2b0c		       a5 53		      lda	R0+1
    250  2b0e		       85 55		      sta	R1+1
    251  2b10		       06 52		      asl	R0
    252  2b12		       26 53		      rol	R0+1	;*4
    253  2b14		       06 52		      asl	R0
    254  2b16		       26 53		      rol	R0+1	;*8
    255  2b18		       18		      clc		;now add the partial sums...
    256  2b19		       a5 52		      lda	R0	;...to get *10
    257  2b1b		       65 54		      adc	R1
    258  2b1d		       85 52		      sta	R0
    259  2b1f		       a5 53		      lda	R0+1
    260  2b21		       65 55		      adc	R1+1
    261  2b23		       85 53		      sta	R0+1
    262  2b25							;
    263  2b25							; Add in the new digit
    264  2b25							;
    265  2b25		       68		      pla
    266  2b26		       18		      clc
    267  2b27		       65 52		      adc	R0
    268  2b29		       85 52		      sta	R0
    269  2b2b		       90 02		      bcc	getD2
    270  2b2d		       e6 53		      inc	R0+1
    271  2b2f							;
    272  2b2f							; Move to next character
    273  2b2f							;
    274  2b2f		       c8	   getD2      iny
    275  2b30		       d0 c2		      bne	getDecLoop
    276  2b32							;
    277  2b32							; All done with digits, so now deal with it being
    278  2b32							; negative.  If zero, then don't check for negative
    279  2b32							; flag.  Ie, -0 is stored as 0.
    280  2b32							;
    281  2b32		       a5 52	   getDdone   lda	R0
    282  2b34		       05 53		      ora	R0+1
    283  2b36		       f0 16		      beq	getDone2	;zero
    284  2b38		       a5 59		      lda	dpl
    285  2b3a		       f0 12		      beq	getDone2	;positive
    286  2b3c							;
    287  2b3c							; Invert all the bits, then add one.
    288  2b3c							;
    289  2b3c		       a5 52		      lda	R0
    290  2b3e		       49 ff		      eor	#$ff
    291  2b40		       85 52		      sta	R0
    292  2b42		       a5 53		      lda	R0+1
    293  2b44		       49 ff		      eor	#$ff
    294  2b46		       85 53		      sta	R0+1
    295  2b48							;
    296  2b48		       e6 52		      inc	R0
    297  2b4a		       d0 02		      bne	getDone2
    298  2b4c		       e6 53		      inc	R0+1
    299  2b4e				   getDone2
    300  2b4e							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  2b4e							;lda	  R0
    302  2b4e							;sta	  $0010
    303  2b4e							;lda	  R0+1
    304  2b4e							;sta	  $0011
    305  2b4e							;lda	  dpl
    306  2b4e							;sta	  $012
    307  2b4e
    308  2b4e		       60		      rts
    309  2b4f
    310  2b4f							;=====================================================
    311  2b4f							; Gets a line of input into LINBUF.
    312  2b4f							;
    313  2b4f							; On entry:
    314  2b4f							;    A contains the prompt character, or 0 if none.
    315  2b4f							;    X = 1 Background read
    316  2b4f							;    x = 0 Forground read with wait
    317  2b4f							;
    318  2b4f							; On exit:
    319  2b4f							;    CURPTR points to LINBUF
    320  2b4f							;    LINBUF contains the line with 0 at the end.
    321  2b4f							;    Y has offset to first non-space character
    322  2b4f							;    CURROFF has the same as Y.
    323  2b4f							;
    324  2b4f		       20 9e 2b    GetLine    jsr	ReadPrompt
    325  2b52		       e0 00		      cpx	#0
    326  2b54		       f0 14		      beq	GetLineRetry
    327  2b56		       ae be 36 	      ldx	taskPtr
    328  2b59		       bd bf 36 	      lda	taskTable,x
    329  2b5c		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  2b5e		       d0 3d		      bne	taskWaitingIO
    331  2b60		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  2b62		       9d bf 36 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  2b65		       ce 9d 2b 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  2b68		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  2b6a
    336  2b6a							;
    337  2b6a							; Now read a line and wait for the CR
    338  2b6a							;
    339  2b6a				   GetLineRetry
    340  2b6a		       a9 00		      lda	#0	;Wait for input to complete
    341  2b6c		       20 b6 2b 	      jsr	ReadLine
    342  2b6f
    343  2b6f							;
    344  2b6f							; Point to the line we just read
    345  2b6f							; Set the current pointer to point to the input line
    346  2b6f							;
    347  2b6f		       a0 00	   ReadComplete ldy	#0
    348  2b71		       84 51		      sty	CUROFF
    349  2b73		       a2 9a		      ldx	#LINBUF&$ff
    350  2b75		       86 4f		      stx	CURPTR
    351  2b77		       a2 42		      ldx	#LINBUF>>8
    352  2b79		       86 50		      stx	CURPTR+1
    353  2b7b							;
    354  2b7b							; Output a CR/LF
    355  2b7b							;
    356  2b7b		       20 7d 2d 	      jsr	CRLF
    357  2b7e							;
    358  2b7e							; If a blank line, prompt again.
    359  2b7e							;
    360  2b7e		       20 74 2d 	      jsr	SkipSpaces
    361  2b81		       b1 4f		      lda	(CURPTR),y
    362  2b83		       d0 10		      bne	GetLineDone	;We have data then exit
    363  2b85		       20 a1 2b 	      jsr	ReadPromptRetry
    364  2b88		       ae be 36 	      ldx	taskPtr	;if this task is waiting for IO
    365  2b8b		       bd bf 36 	      lda	taskTable,x	;then get out, wait for line to
    366  2b8e		       29 40		      and	#TASKWAITIO	;Complete again
    367  2b90		       d0 0b		      bne	taskWaitingIO
    368  2b92		       4c 6a 2b 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  2b95
    370  2b95				   GetLineDone
    371  2b95		       ae be 36 	      ldx	taskPtr
    372  2b98		       a9 80		      lda	#TASKACTIVE
    373  2b9a		       9d bf 36 	      sta	taskTable,x	;IO is complete
    374  2b9d
    375  2b9d				   taskWaitingIO
    376  2b9d		       60		      rts
    377  2b9e
    378  2b9e							;
    379  2b9e							;=======================================================================
    380  2b9e							; Display the prompt character
    381  2b9e							; On entry
    382  2b9e							;	    A contains the prompt character
    383  2b9e							; On exit
    384  2b9e							;	    The readbuffer index is reset to 0
    385  2b9e							;
    386  2b9e		       8d 21 43    ReadPrompt sta	promptChar
    387  2ba1
    388  2ba1							;
    389  2ba1							; Prompt
    390  2ba1							;
    391  2ba1
    392  2ba1		       ad 21 43    ReadPromptRetry lda	promptChar
    393  2ba4		       09 00		      ora	#0	;any prompt?
    394  2ba6		       f0 08		      beq	getlinenp
    395  2ba8		       20 63 1a 	      jsr	VOUTCH
    396  2bab		       a9 20		      lda	#$20
    397  2bad		       20 63 1a 	      jsr	VOUTCH	;Space after prompt
    398  2bb0							;
    399  2bb0		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  2bb2		       8e 1e 43 	      stx	getlinx
    401  2bb5		       60		      rts
    402  2bb6							;
    403  2bb6							;===============================================================
    404  2bb6							; This fuction is the driver for the line input
    405  2bb6							; on call if a = 0 then it waits for all input
    406  2bb6							;	      a = 1 then nowait for input
    407  2bb6							; On exit
    408  2bb6							;		       c clear if not complete line
    409  2bb6							;		       c set if it was a complete line
    410  2bb6
    411  2bb6				   ReadLine
    412  2bb6		       8d 20 43 	      sta	inputNoWait
    413  2bb9		       c9 00		      cmp	#0
    414  2bbb		       f0 05		      beq	getline1
    415  2bbd		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  2bc0		       f0 2b		      beq	GetLineNoWait
    417  2bc2		       20 66 1a    getline1   jsr	VGETCH
    418  2bc5					      if	CTMON65
    419  2bc5		       48		      pha
    420  2bc6		       20 63 1a 	      jsr	VOUTCH	;echo echo echo
    421  2bc9		       68		      pla
    422  2bca					      endif
    423  2bca		       c9 0d		      cmp	#CR
    424  2bcc		       f0 15		      beq	getlind	;end of line
    425  2bce		       c9 08		      cmp	#BS	;backspace?
    426  2bd0		       f0 1d		      beq	getlinebs
    427  2bd2		       ae 1e 43 	      ldx	getlinx
    428  2bd5		       9d 9a 42 	      sta	LINBUF,x
    429  2bd8		       e8		      inx
    430  2bd9		       8e 1e 43 	      stx	getlinx
    431  2bdc		       ad 20 43 	      lda	inputNoWait
    432  2bdf		       f0 e1		      beq	getline1
    433  2be1		       d0 0a		      bne	GetLineNoWait
    434  2be3							;
    435  2be3							; CR was hit
    436  2be3							;
    437  2be3		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  2be5		       ae 1e 43 	      ldx	getlinx
    439  2be8		       9d 9a 42 	      sta	LINBUF,x
    440  2beb
    441  2beb		       38		      sec		; Carry set then cr received
    442  2bec		       60		      rts
    443  2bed
    444  2bed				   GetLineNoWait
    445  2bed		       18		      clc		; Carry clear no end of line
    446  2bee		       60		      rts
    447  2bef							;
    448  2bef							; Backspace was hit
    449  2bef							;
    450  2bef		       ae 1e 43    getlinebs  ldx	getlinx
    451  2bf2		       f0 0e		      beq	getlineEOL	;at start of line
    452  2bf4		       ca		      dex
    453  2bf5		       8e 1e 43 	      stx	getlinx
    454  2bf8		       20 bb 21    getlinepbs jsr	puts
      0  2bfb					      db	27,"[K",0
      1  2bfb		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  2bff		       4c c2 2b 	      jmp	getline1
    457  2c02		       a9 20	   getlineEOL lda	#SPACE
    458  2c04		       20 63 1a 	      jsr	VOUTCH
    459  2c07		       d0 ef		      bne	getlinepbs
    460  2c09							;
    461  2c09							;=====================================================
    462  2c09							; Count the length of the line currently in LINBUF
    463  2c09							; starting at offset Y.  Returns the length in X.  The
    464  2c09							; starting offset in Y should point past the ASCII
    465  2c09							; line number.  Also counts the trailing NULL and two
    466  2c09							; extra bytes for where the line number will be.
    467  2c09							; Update must now include leading length byte not the null at end ****************
    468  2c09							;
    469  2c09				   getLineLength
    470  2c09		       a2 00		      ldx	#0	;size
    471  2c0b		       b9 9a 42    getLineL2  lda	LINBUF,y
    472  2c0e		       f0 04		      beq	getLineL3
    473  2c10		       c8		      iny
    474  2c11		       e8		      inx
    475  2c12		       d0 f7		      bne	getLineL2
    476  2c14		       e8	   getLineL3  inx		;count null at end
    477  2c15		       e8		      inx		;line number LSB
    478  2c16		       e8		      inx		;MSB
    479  2c17		       e8		      inx		;change: count new leading line length
    480  2c18		       8e 30 43 	      stx	lineLength
    481  2c1b		       60		      rts
    482  2c1c							;
    483  2c1c							;=====================================================
    484  2c1c							; Count the length of the line pointed to by CURPTR.
    485  2c1c							; This also counts the line number and the terminating
    486  2c1c							; null.  Ie, this string returns 8:
    487  2c1c							;
    488  2c1c							; <lineLow><lineHi>Hello<null>
    489  2c1c							;
    490  2c1c							; Another way of looking at it: add the return value
    491  2c1c							; to the CURPTR and it'll point to the next line's
    492  2c1c							; line number.  Returns the value in Y.
    493  2c1c							; Update to ject get the leading byte length ********************
    494  2c1c							;
    495  2c1c							;getCURPTRLength
    496  2c1c							;		ldy	CURPTR
    497  2c1c							;		ldy	#3	;change: skip line number and leading length byte
    498  2c1c							;getCLineL2	lda	(CURPTR),y
    499  2c1c							;		beq	getCLineL3
    500  2c1c							;		iny
    501  2c1c							;		bne	getCLineL2
    502  2c1c							;getCLineL3	iny		;count null at end
    503  2c1c							;		rts
    504  2c1c
    505  2c1c							;
    506  2c1c							;=====================================================
    507  2c1c							; This saves ILPC.  This saves to a single save area,
    508  2c1c							; so it can't be called more than once.
    509  2c1c							;
    510  2c1c		       a5 43	   saveIL     lda	ILPC
    511  2c1e		       8d 2c 43 	      sta	tempIL
    512  2c21		       a5 44		      lda	ILPC+1
    513  2c23		       8d 2d 43 	      sta	tempIL+1
    514  2c26		       60		      rts
    515  2c27							;
    516  2c27							;=====================================================
    517  2c27							; This restores ILPC.
    518  2c27							;
    519  2c27		       ad 2c 43    restoreIL  lda	tempIL
    520  2c2a		       85 43		      sta	ILPC
    521  2c2c		       ad 2d 43 	      lda	tempIL+1
    522  2c2f		       85 44		      sta	ILPC+1
    523  2c31		       60		      rts
    524  2c32							;
    525  2c32							;=====================================================
    526  2c32							; This pushes R0 onto the stack.
    527  2c32							;
    528  2c32		       8c 27 43    pushR0     sty	rtemp1
    529  2c35		       a4 4a		      ldy	MATHSTACKPTR
    530  2c37		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  2c39		       b0 38		      bcs	pusherr
    532  2c3b		       a5 52		      lda	R0
    533  2c3d		       91 48		      sta	(MATHSTACK),y
    534  2c3f		       c8		      iny
    535  2c40		       a5 53		      lda	R0+1
    536  2c42		       91 48		      sta	(MATHSTACK),y
    537  2c44		       c8		      iny
    538  2c45		       84 4a		      sty	MATHSTACKPTR
    539  2c47		       ac 27 43 	      ldy	rtemp1
    540  2c4a		       18		      clc
    541  2c4b		       60		      rts
    542  2c4c
    543  2c4c							;=====================================================
    544  2c4c							; This pushes curptr basic current line onto the call stack.
    545  2c4c							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  2c4c
    547  2c4c				   pushLN
    548  2c4c		       8d 28 43 	      STA	rtemp1+1	; Store type of push being done
    549  2c4f		       8c 27 43 	      sty	rtemp1
    550  2c52		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  2c54		       c5 4d		      cmp	GOSUBSTACKPTR
    552  2c56		       90 1b		      bcc	pusherr	; No error
    553  2c58		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  2c5a		       a2 00		      ldx	#0	; Start of bytes to copy
    555  2c5c				   pushLoop
    556  2c5c		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  2c5e		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  2c60		       c8		      iny		; Next destination
    559  2c61		       e8		      inx		; Next Source byte
    560  2c62		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  2c64		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  2c66
    563  2c66		       ad 28 43    pushDone   lda	rtemp1+1	; Type of stack entry
    564  2c69		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  2c6b		       c8		      iny		; Next entry
    566  2c6c
    567  2c6c		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  2c6e		       ac 27 43 	      ldy	rtemp1
    569  2c71		       18		      clc
    570  2c72		       60		      rts
    571  2c73				   pusherr
    572  2c73		       38		      sec
    573  2c74		       60		      rts
    574  2c75							;=====================================================
    575  2c75							; This pops Top Off gosub call Stack and
    576  2c75							; places it in CURPTR/CUROFF.
    577  2c75							; This checks if the type = 1 GOSUB
    578  2c75							; if not it removes what ever is on the stack
    579  2c75							; until it finds the next return. Allowing
    580  2c75							; a return from within a for/next
    581  2c75							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  2c75		       8c 27 43    popLN      sty	rtemp1
    583  2c78		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  2c7a		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  2c7c
    586  2c7c				   popContinue
    587  2c7c		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  2c7e		       90 22		      bcc	poperr	; Process an error
    589  2c80
    590  2c80		       88		      dey		; Position to read entry type
    591  2c81		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  2c83		       8d 28 43 	      sta	rtemp1+1	; Save to be returned
    593  2c86		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  2c88		       f0 04		      beq	popLoop	; Restore the line
    595  2c8a		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  2c8c		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  2c8e
    598  2c8e				   popLoop
    599  2c8e		       88		      dey
    600  2c8f		       ca		      dex
    601  2c90		       b1 4b		      lda	(GOSUBSTACK),y
    602  2c92		       95 4f		      sta	CURPTR,x
    603  2c94		       e0 00		      cpx	#0
    604  2c96		       d0 f6		      bne	popLoop	; Loop until all moved
    605  2c98
    606  2c98
    607  2c98		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  2c9a		       ac 27 43 	      ldy	rtemp1
    609  2c9d		       ad 28 43 	      lda	rtemp1+1	; get the type of return
    610  2ca0		       18		      clc
    611  2ca1		       60		      rts
    612  2ca2
    613  2ca2		       38	   poperr     sec
    614  2ca3		       60		      rts
    615  2ca4
    616  2ca4		       88	   popSkipEntry dey
    617  2ca5		       88		      dey
    618  2ca6		       88		      dey
    619  2ca7		       4c 7c 2c 	      jmp	popContinue
    620  2caa
    621  2caa							;
    622  2caa							;=====================================================
    623  2caa							; This pushes R1 onto the stack
    624  2caa							;
    625  2caa		       8c 27 43    pushR1     sty	rtemp1
    626  2cad		       a4 4a		      ldy	MATHSTACKPTR
    627  2caf		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  2cb1		       b0 ef		      bcs	poperr
    629  2cb3		       a5 54		      lda	R1
    630  2cb5		       91 48		      sta	(MATHSTACK),y
    631  2cb7		       c8		      iny
    632  2cb8		       a5 55		      lda	R1+1
    633  2cba		       91 48		      sta	(MATHSTACK),y
    634  2cbc		       c8		      iny
    635  2cbd		       84 4a		      sty	MATHSTACKPTR
    636  2cbf		       ac 27 43 	      ldy	rtemp1
    637  2cc2		       18		      clc
    638  2cc3		       60		      rts
    639  2cc4							;
    640  2cc4							;=====================================================
    641  2cc4							; This pops Top Of Stack and places it in R0.
    642  2cc4							;
    643  2cc4		       8c 27 43    popR0      sty	rtemp1
    644  2cc7		       a4 4a		      ldy	MATHSTACKPTR
    645  2cc9		       f0 d7		      beq	poperr
    646  2ccb		       88		      dey
    647  2ccc		       b1 48		      lda	(MATHSTACK),y
    648  2cce		       85 53		      sta	R0+1
    649  2cd0		       88		      dey
    650  2cd1		       b1 48		      lda	(MATHSTACK),y
    651  2cd3		       85 52		      sta	R0
    652  2cd5		       84 4a		      sty	MATHSTACKPTR
    653  2cd7		       ac 27 43 	      ldy	rtemp1
    654  2cda		       18		      clc
    655  2cdb		       60		      rts
    656  2cdc
    657  2cdc							;
    658  2cdc							;=====================================================
    659  2cdc							; This pops TOS and places it in R1.
    660  2cdc							;
    661  2cdc		       8c 27 43    popR1      sty	rtemp1
    662  2cdf		       a4 4a		      ldy	MATHSTACKPTR
    663  2ce1		       f0 bf		      beq	poperr
    664  2ce3		       88		      dey
    665  2ce4		       b1 48		      lda	(MATHSTACK),y
    666  2ce6		       85 55		      sta	R1+1
    667  2ce8		       88		      dey
    668  2ce9		       b1 48		      lda	(MATHSTACK),y
    669  2ceb		       85 54		      sta	R1
    670  2ced		       84 4a		      sty	MATHSTACKPTR
    671  2cef		       ac 27 43 	      ldy	rtemp1
    672  2cf2		       60		      rts
    673  2cf3							;
    674  2cf3							;=====================================================
    675  2cf3							; This pops TOS and places it in MQ.
    676  2cf3							;
    677  2cf3		       8c 27 43    popMQ      sty	rtemp1
    678  2cf6		       a4 4a		      ldy	MATHSTACKPTR
    679  2cf8		       f0 a8		      beq	poperr
    680  2cfa		       88		      dey
    681  2cfb		       b1 48		      lda	(MATHSTACK),y
    682  2cfd		       85 57		      sta	MQ+1
    683  2cff		       88		      dey
    684  2d00		       b1 48		      lda	(MATHSTACK),y
    685  2d02		       85 56		      sta	MQ
    686  2d04		       84 4a		      sty	MATHSTACKPTR
    687  2d06		       ac 27 43 	      ldy	rtemp1
    688  2d09		       60		      rts
    689  2d0a							;
    690  2d0a							;=====================================================
    691  2d0a							; This assists with multiplication and division by
    692  2d0a							; looking at R0 and R1 and saving a flag as to what
    693  2d0a							; sign the result will be.  Math is always done on
    694  2d0a							; positive numbers, so this converts negative numbers
    695  2d0a							; into positives.  On exit, R0 and R1 are both
    696  2d0a							; positive.  If the signs were different then 'signs'
    697  2d0a							; will be non-zero.
    698  2d0a							;
    699  2d0a		       a9 00	   SaveSigns  lda	#0
    700  2d0c		       8d 26 43 	      sta	sign	;assume positive
    701  2d0f		       a5 53		      lda	R0+1	;MSB
    702  2d11		       10 13		      bpl	SaveSigns1
    703  2d13		       ee 26 43 	      inc	sign	;it's negative
    704  2d16		       49 ff		      eor	#$ff	;flip bits
    705  2d18		       85 53		      sta	R0+1
    706  2d1a		       a5 52		      lda	R0
    707  2d1c		       49 ff		      eor	#$ff
    708  2d1e		       85 52		      sta	R0
    709  2d20		       e6 52		      inc	R0
    710  2d22		       d0 02		      bne	SaveSigns1
    711  2d24		       e6 53		      inc	R0+1
    712  2d26		       a5 55	   SaveSigns1 lda	R1+1
    713  2d28		       10 1a		      bpl	SaveSigns2
    714  2d2a		       48		      pha
    715  2d2b		       ad 26 43 	      lda	sign
    716  2d2e		       49 01		      eor	#1
    717  2d30		       8d 26 43 	      sta	sign
    718  2d33		       68		      pla
    719  2d34		       49 ff		      eor	#$ff	;flip bits
    720  2d36		       85 55		      sta	R1+1
    721  2d38		       a5 54		      lda	R1
    722  2d3a		       49 ff		      eor	#$ff
    723  2d3c		       85 54		      sta	R1
    724  2d3e		       e6 54		      inc	R1
    725  2d40		       d0 02		      bne	SaveSigns2
    726  2d42		       e6 55		      inc	R1+1
    727  2d44		       60	   SaveSigns2 rts
    728  2d45							;
    729  2d45							;=====================================================
    730  2d45							; This looks at the value of 'signs' and will convert
    731  2d45							; both R0 and R1 to negative if set.
    732  2d45							;
    733  2d45				   RestoreSigns
    734  2d45		       ad 26 43 	      lda	sign
    735  2d48		       f0 28		      beq	restoresigns2
    736  2d4a							;
    737  2d4a		       a5 52		      lda	R0
    738  2d4c		       d0 02		      bne	restoresigns3
    739  2d4e		       c6 53		      dec	R0+1
    740  2d50				   restoresigns3
    741  2d50		       c6 52		      dec	R0
    742  2d52		       a5 52		      lda	R0
    743  2d54		       49 ff		      eor	#$ff
    744  2d56		       85 52		      sta	R0
    745  2d58		       a5 53		      lda	R0+1
    746  2d5a		       49 ff		      eor	#$ff
    747  2d5c		       85 53		      sta	R0+1
    748  2d5e							;
    749  2d5e		       a5 54		      lda	R1
    750  2d60		       d0 02		      bne	restoresigns4
    751  2d62		       c6 55		      dec	R1+1
    752  2d64				   restoresigns4
    753  2d64		       c6 54		      dec	R1
    754  2d66		       a5 54		      lda	R1
    755  2d68		       49 ff		      eor	#$ff
    756  2d6a		       85 54		      sta	R1
    757  2d6c		       a5 55		      lda	R1+1
    758  2d6e		       49 ff		      eor	#$ff
    759  2d70		       85 55		      sta	R1+1
    760  2d72							;
    761  2d72				   restoresigns2
    762  2d72		       60		      rts
    763  2d73							;
    764  2d73							;=====================================================
    765  2d73							; Skip over spaces.  Returns Y with the offset to
    766  2d73							; either the last character in the line, or the first
    767  2d73							; non-space character.
    768  2d73							;
    769  2d73
    770  2d73		       c8	   skipsp2    iny
    771  2d74		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  2d76		       f0 04		      beq	Skip3	;end of line
    773  2d78		       c9 20		      cmp	#SPACE
    774  2d7a		       f0 f7		      beq	skipsp2
    775  2d7c		       60	   Skip3      rts
    776  2d7d							;*********************************************************
    777  2d7d							; Output a CR/LF combination to the console.  Preserves
    778  2d7d							; all registers.
    779  2d7d							;
    780  2d7d		       48	   tbcrlf     pha
    781  2d7e		       a9 0d		      lda	#CR
    782  2d80		       20 63 1a 	      jsr	VOUTCH
    783  2d83		       a9 0a		      lda	#LF
    784  2d85		       20 63 1a 	      jsr	VOUTCH
    785  2d88		       68		      pla
    786  2d89		       60		      rts
    787  2d8a							;
    788  2d8a							;=====================================================
    789  2d8a							; Some logic to print the Line of basic code being executed
    790  2d8a		       24 40	   idbgBasic  bit	ILTrace
    791  2d8c		       50 75		      bvc	dbgBasicNone
    792  2d8e		       98		      tya
    793  2d8f		       48		      pha
    794  2d90		       20 18 2f 	      jsr	SetOutDebug
    795  2d93
    796  2d93		       a5 4f		      lda	CURPTR
    797  2d95		       85 59		      sta	dpl
    798  2d97		       a5 50		      lda	CURPTR+1
    799  2d99		       85 5a		      sta	dpl+1
    800  2d9b
    801  2d9b		       20 53 22 	      jsr	PrintProgramLine
    802  2d9e
    803  2d9e		       a5 40		      lda	ILTrace
    804  2da0		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  2da2		       f0 5a		      beq	dbgBasicDone
    806  2da4		       20 2f 2f 	      jsr	SetInDebug
    807  2da7		       20 bb 21 	      jsr	puts
      0  2daa					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  2daa		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  2de7				   dbgBasicLoop
    810  2de7		       20 66 1a 	      jsr	VGETCH
    811  2dea		       20 7d 2d 	      jsr	CRLF
    812  2ded		       20 53 2f 	      jsr	SetInDebugEnd
    813  2df0
    814  2df0		       c9 73		      cmp	#'s	; Quit program
    815  2df2		       f0 12		      beq	dbgBasicStop
    816  2df4
    817  2df4		       c9 64		      cmp	#'d	; Display Variables
    818  2df6		       d0 06		      bne	dbgBasicDone
    819  2df8
    820  2df8		       20 16 22 	      jsr	PrintAllVars
    821  2dfb		       18		      clc
    822  2dfc		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  2dfe
    824  2dfe		       20 46 2f    dbgBasicDone jsr	SetOutDebugEnd
    825  2e01		       68		      pla
    826  2e02		       a8		      tay
    827  2e03		       4c b1 02    dbgBasicNone jmp	NextIL
    828  2e06
    829  2e06				   dbgBasicStop
    830  2e06		       20 46 2f 	      jsr	SetOutDebugEnd
    831  2e09		       68		      pla
    832  2e0a		       a8		      tay
    833  2e0b		       4c 02 06 	      jmp	iFIN
    834  2e0e							;
    835  2e0e							;=====================================================
    836  2e0e							; This is some debug logic which displays the current
    837  2e0e							; value of the ILPC and the line buffer.
    838  2e0e							;
    839  2e0e		       24 40	   dbgLine    bit	ILTrace
    840  2e10		       30 01		      bmi	dbgPrt
    841  2e12		       60		      rts
    842  2e13				   dbgPrt
    843  2e13		       20 18 2f 	      jsr	SetOutDebug
    844  2e16		       20 bb 21 	      jsr	puts
      0  2e19					      db	"ILPC:",0
      1  2e19		       49 4c 50 43*	      .byte.b	"ILPC:",0
    846  2e1f		       a5 44		      lda	ILPC+1
    847  2e21		       20 9e 21 	      jsr	OUTHEX
    848  2e24		       a5 43		      lda	ILPC
    849  2e26		       20 9e 21 	      jsr	OUTHEX
    850  2e29		       a9 20		      lda	#SPACE
    851  2e2b		       20 63 1a 	      jsr	VOUTCH
    852  2e2e
    853  2e2e		       a0 00		      ldy	#0
    854  2e30		       b1 43		      lda	(ILPC),y	;Get the il pcode value
    855  2e32					      if	IL_DEBUG_TEXT
    856  2e32		       20 14 19 	      jsr	PrintILText
    857  2e35				  -	      else
    858  2e35				  -	      jsr	OUTHEX
    859  2e35					      endif
    860  2e35		       20 bb 21 	      jsr	puts
      0  2e38					      db	" ILSP:",0
      1  2e38		       20 49 4c 53*	      .byte.b	" ILSP:",0
    862  2e3f		       a5 47		      lda	ILSTACKPTR
    863  2e41		       20 9e 21 	      jsr	OUTHEX
    864  2e44		       a9 20		      lda	#SPACE
    865  2e46		       20 63 1a 	      jsr	VOUTCH
    866  2e49
    867  2e49							; Display the CURPTR value and offset
    868  2e49							;
    869  2e49		       20 bb 21 	      jsr	puts
      0  2e4c					      db	", CURPTR: ",0
      1  2e4c		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    871  2e57		       a5 50		      lda	CURPTR+1
    872  2e59		       20 9e 21 	      jsr	OUTHEX
    873  2e5c		       a5 4f		      lda	CURPTR
    874  2e5e		       20 9e 21 	      jsr	OUTHEX
    875  2e61		       a9 2b		      lda	#'+
    876  2e63		       20 63 1a 	      jsr	VOUTCH
    877  2e66		       a5 51		      lda	CUROFF
    878  2e68		       20 9e 21 	      jsr	OUTHEX
    879  2e6b							;
    880  2e6b		       20 7d 2d 	      jsr	CRLF
    881  2e6e		       20 46 2f 	      jsr	SetOutDebugEnd
    882  2e71		       20 a4 2e 	      jsr	ILChkRange
    883  2e74		       b0 02		      bcs	dbgLineErr
    884  2e76		       18		      clc
    885  2e77		       60		      rts
    886  2e78
    887  2e78				   dbgLineErr
    888  2e78		       20 18 2f 	      jsr	SetOutDebug
    889  2e7b		       20 bb 21 	      jsr	puts
      0  2e7e					      db	"Outside Valid IL Address Range",CR,LF,0
      1  2e7e		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    891  2e9f		       20 46 2f 	      jsr	SetOutDebugEnd
    892  2ea2		       38		      sec
    893  2ea3		       60		      rts
    894  2ea4
    895  2ea4		       a5 44	   ILChkRange lda	ILPC+1
    896  2ea6		       c9 32		      cmp	#IL>>8
    897  2ea8		       90 18		      bcc	ILBadRange
    898  2eaa		       d0 06		      bne	ILChkHigh
    899  2eac
    900  2eac		       a5 43		      lda	ILPC
    901  2eae		       c9 01		      cmp	#IL&$ff
    902  2eb0		       90 10		      bcc	ILBadRange
    903  2eb2
    904  2eb2		       a5 44	   ILChkHigh  lda	ILPC+1
    905  2eb4		       c9 36		      cmp	#ILEND>>8
    906  2eb6		       90 08		      bcc	ILGoodRange
    907  2eb8		       d0 08		      bne	ILBadRange
    908  2eba
    909  2eba		       a5 43		      lda	ILPC
    910  2ebc		       c9 6b		      cmp	#ILEND&$ff
    911  2ebe		       b0 02		      bcs	ILBadRange
    912  2ec0
    913  2ec0		       18	   ILGoodRange clc
    914  2ec1		       60		      rts
    915  2ec2				   ILBadRange
    916  2ec2		       38		      sec
    917  2ec3		       60		      rts
    918  2ec4
    919  2ec4
    920  2ec4							;=====================================================
    921  2ec4							; Set output vector to the console output function
    922  2ec4							;
    923  2ec4				   SetOutConsole
    924  2ec4		       48		      pha
    925  2ec5		       a9 0c		      lda	#OUTCH&$ff
    926  2ec7		       8d 70 36 	      sta	BOutVec
    927  2eca		       a9 f0		      lda	#OUTCH>>8
    928  2ecc		       8d 71 36 	      sta	BOutVec+1
    929  2ecf		       68		      pla
    930  2ed0		       60		      rts
    931  2ed1
    932  2ed1				   SetInConsole
    933  2ed1		       48		      pha
    934  2ed2		       a9 09		      lda	#GETCH&$ff
    935  2ed4		       8d 6e 36 	      sta	BInVec
    936  2ed7		       a9 f0		      lda	#GETCH>>8
    937  2ed9		       8d 6f 36 	      sta	BInVec+1
    938  2edc		       68		      pla
    939  2edd		       60		      rts
    940  2ede
    941  2ede
    942  2ede
    943  2ede							;====================================================
    944  2ede							;Clear the terminal assume it is ansii or vt100
    945  2ede							;
    946  2ede				   iCLEARSCREEN
    947  2ede		       20 bb 21 	      jsr	puts
      0  2ee1					      db	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
      1  2ee1		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
    949  2ef2		       4c b1 02 	      jmp	NextIL
    950  2ef5
    951  2ef5							;====================================================
    952  2ef5							; Push true and false onto math stack
    953  2ef5				   pushTrue
    954  2ef5		       a9 ff		      lda	#$ff
    955  2ef7		       85 52	   pushTF     sta	R0
    956  2ef9		       85 53		      sta	R0+1
    957  2efb		       20 32 2c 	      jsr	pushR0
    958  2efe		       60		      rts
    959  2eff		       a9 00	   pushFalse  lda	#0
    960  2f01		       f0 f4		      beq	pushTF
    961  2f03
    962  2f03							;======================================================
    963  2f03							; Copy stack top to R1
    964  2f03				   CopyStackR1
    965  2f03		       98		      tya
    966  2f04		       48		      pha
    967  2f05		       a4 4a		      ldy	MATHSTACKPTR
    968  2f07		       88		      dey
    969  2f08		       b1 48		      lda	(MATHSTACK),y
    970  2f0a		       85 55		      sta	R1+1
    971  2f0c		       88		      dey
    972  2f0d		       b1 48		      lda	(MATHSTACK),y
    973  2f0f		       85 54		      sta	R1
    974  2f11		       68		      pla
    975  2f12		       a8		      tay
    976  2f13		       60		      rts
    977  2f14
    978  2f14
    979  2f14							;====================================================
    980  2f14							;Swap the out debug call for standard calls
    981  2f14		       00 00	   DebugIOSave ds	2
    982  2f16		       00 00	   DebugInSave ds	2
    983  2f18				   SetOutDebug
    984  2f18		       ad 70 36 	      lda	BOutVec
    985  2f1b		       8d 14 2f 	      sta	DebugIOSave
    986  2f1e		       ad 71 36 	      lda	BOutVec+1
    987  2f21		       8d 15 2f 	      sta	DebugIOSave+1
    988  2f24		       a9 ac		      lda	#OUTDEBUG&$ff	; Put the Debug output
    989  2f26		       8d 70 36 	      sta	BOutVec
    990  2f29		       a9 2f		      lda	#OUTDEBUG>>8
    991  2f2b		       8d 71 36 	      sta	BOutVec+1
    992  2f2e		       60		      rts
    993  2f2f				   SetInDebug
    994  2f2f		       ad 6e 36 	      lda	BInVec
    995  2f32		       8d 16 2f 	      sta	DebugInSave
    996  2f35		       ad 6f 36 	      lda	BInVec+1
    997  2f38		       8d 17 2f 	      sta	DebugInSave+1
    998  2f3b		       a9 b0		      lda	#INDEBUG&$ff
    999  2f3d		       8d 6e 36 	      sta	BInVec
   1000  2f40		       a9 2f		      lda	#INDEBUG>>8
   1001  2f42		       8d 6f 36 	      sta	BInVec+1
   1002  2f45		       60		      rts
   1003  2f46				   SetOutDebugEnd
   1004  2f46		       ad 14 2f 	      lda	DebugIOSave
   1005  2f49		       8d 70 36 	      sta	BOutVec
   1006  2f4c		       ad 15 2f 	      lda	DebugIOSave+1
   1007  2f4f		       8d 71 36 	      sta	BOutVec+1
   1008  2f52		       60		      rts
   1009  2f53				   SetInDebugEnd
   1010  2f53		       ad 16 2f 	      lda	DebugInSave
   1011  2f56		       8d 6e 36 	      sta	BInVec
   1012  2f59		       ad 17 2f 	      lda	DebugInSave+1
   1013  2f5c		       8d 6f 36 	      sta	BInVec+1
   1014  2f5f		       60		      rts
   1015  2f60							;
   1016  2f60							;====================================================
   1017  2f60							; Set the input and output terminal address
   1018  2f60							; The math stack stack byte is the output io slot
   1019  2f60							; The math stack  is the input io slot
   1020  2f60
   1021  2f60				   iSetTerminal
   1022  2f60		       20 c4 2c 	      jsr	popR0	; Process the output io addresses
   1023  2f63		       20 8d 2f 	      jsr	CalcSlot
   1024  2f66		       a5 52		      lda	R0
   1025  2f68		       09 01		      ora	#1
   1026  2f6a		       8d ad 2f 	      sta	TerminalOutputPort
   1027  2f6d		       a5 53		      lda	R0+1
   1028  2f6f		       8d ae 2f 	      sta	TerminalOutputPort+1
   1029  2f72
   1030  2f72		       20 c4 2c 	      jsr	popR0	; Process the input io address
   1031  2f75		       20 8d 2f 	      jsr	CalcSlot
   1032  2f78		       a5 52		      lda	R0
   1033  2f7a		       8d b1 2f 	      sta	TerminalStatusPort
   1034  2f7d		       09 01		      ora	#1
   1035  2f7f		       8d b8 2f 	      sta	TerminalInputPort
   1036  2f82		       a5 53		      lda	R0+1
   1037  2f84		       8d b9 2f 	      sta	TerminalInputPort+1
   1038  2f87		       8d b2 2f 	      sta	TerminalStatusPort+1
   1039  2f8a		       4c b1 02 	      jmp	NextIL
   1040  2f8d
   1041  2f8d							;===================================================
   1042  2f8d							; Calculate the slot address the the slot number
   1043  2f8d							; R0 contains the slot number 0-255
   1044  2f8d
   1045  2f8d				   CalcSlot
   1046  2f8d		       8a		      txa
   1047  2f8e		       48		      pha
   1048  2f8f
   1049  2f8f		       a2 04		      ldx	#4
   1050  2f91				   CalcSlotLoop
   1051  2f91		       18		      clc
   1052  2f92		       26 52		      rol	R0
   1053  2f94		       26 53		      rol	R0+1
   1054  2f96		       ca		      dex
   1055  2f97		       d0 f8		      bne	CalcSlotLoop
   1056  2f99
   1057  2f99		       a9 e0		      lda	#$E0
   1058  2f9b		       05 53		      ora	R0+1
   1059  2f9d		       85 53		      sta	R0+1
   1060  2f9f		       68		      pla
   1061  2fa0
   1062  2fa0		       aa		      tax
   1063  2fa1		       60		      rts
   1064  2fa2							;
   1065  2fa2							;====================================================
   1066  2fa2							; Output to the Terminal/Debug console
   1067  2fa2							;     x = high address byte
   1068  2fa2							;     y = low address byte
   1069  2fa2							;     a = Terminator for string
   1070  2fa2				   TerminalWrite
   1071  2fa2				   DebugWrite
   1072  2fa2		       20 18 2f 	      jsr	SetOutDebug
   1073  2fa5		       20 f9 21 	      jsr	PrtStr
   1074  2fa8		       20 46 2f 	      jsr	SetOutDebugEnd
   1075  2fab		       60		      rts
   1076  2fac
   1077  2fac				   TerminalIOblock
   1078  2fac				   OUTDEBUG
   1079  2fac		       8d		      .byte.b	$8D	; STA
   1080  2fad				   TerminalOutputPort
   1081  2fad		       21 e0	   DEBUGPORT  .word.w	$E021	; Dont check anything just output the byte
   1082  2faf		       60		      RTS
   1083  2fb0
   1084  2fb0				   TerminalRead
   1085  2fb0				   INDEBUG
   1086  2fb0		       ad		      .byte.b	$AD	; LDA
   1087  2fb1				   TerminalStatusPort
   1088  2fb1		       20 e0	   DEBUGPORTSTATUS .word.w	$E020
   1089  2fb3
   1090  2fb3		       29 01		      and	#$01
   1091  2fb5		       f0 f9		      beq	INDEBUG
   1092  2fb7
   1093  2fb7		       ad		      .byte.b	$AD	; LDA
   1094  2fb8				   TerminalInputPort
   1095  2fb8		       21 e0	   DEBUGPORTIN .word.w	$E021
   1096  2fba		       60		      rts
   1097  2fbb				   TerminalIOblockEnd
   1098  2fbb							;======================================================================
   1099  2fbb							;Copy Quoted string to buffer, terminate with 0 byte
   1100  2fbb							; R0  Source tring points to tString type
   1101  2fbb							; x is terminator
   1102  2fbb							; R1 points to destinition location
   1103  2fbb							; On exit R0 contains length of copy Plus Term and leading bytes
   1104  2fbb
   1105  2fbb				   qstrcpy
   1106  2fbb		       20 32 2c 	      jsr	pushR0
   1107  2fbe		       20 0b 30 	      jsr	IncR0	; point past the tString
   1108  2fc1		       20 0b 30 	      jsr	IncR0	; Point Past the opening "
   1109  2fc4		       a2 22		      ldx	#'"	; copy Termination
   1110  2fc6		       20 e0 2f 	      jsr	pstrcpy
   1111  2fc9		       20 0b 30 	      jsr	IncR0	; point to "
   1112  2fcc		       20 0b 30 	      jsr	IncR0	; Point to next free byte
   1113  2fcf		       20 dc 2c 	      jsr	popR1
   1114  2fd2		       38		      sec
   1115  2fd3		       a5 52		      lda	R0
   1116  2fd5		       e5 54		      sbc	R1
   1117  2fd7		       85 52		      sta	R0
   1118  2fd9		       a5 53		      lda	R0+1
   1119  2fdb		       e5 55		      sbc	R1+1
   1120  2fdd		       85 53		      sta	R0+1
   1121  2fdf		       60		      rts
   1122  2fe0
   1123  2fe0							;=========================================================================
   1124  2fe0							;Copy string from R0 to R1, terminator in x
   1125  2fe0							; On exit    R0 contains the length of the copy
   1126  2fe0				   pstrcpy
   1127  2fe0		       a0 00		      ldy	#0
   1128  2fe2		       86 58		      stx	R2
   1129  2fe4
   1130  2fe4				   strcpyLoop
   1131  2fe4		       b1 52		      lda	(R0),y
   1132  2fe6		       c5 58		      cmp	R2
   1133  2fe8		       f0 0a		      beq	strcpyDone
   1134  2fea		       91 54		      sta	(R1),y
   1135  2fec		       20 0b 30 	      jsr	IncR0
   1136  2fef		       20 f9 2f 	      jsr	IncR1
   1137  2ff2		       90 f0		      bcc	strcpyLoop
   1138  2ff4				   strcpyDone
   1139  2ff4		       a9 00		      lda	#0
   1140  2ff6		       91 54		      sta	(R1),y
   1141  2ff8
   1142  2ff8		       60		      rts
   1143  2ff9
   1144  2ff9							;=========================================================================
   1145  2ff9							; on exit c is set on overflow
   1146  2ff9				   IncR1
   1147  2ff9		       48		      pha
   1148  2ffa		       18		      clc
   1149  2ffb		       a9 01		      lda	#1
   1150  2ffd		       65 54		      adc	R1
   1151  2fff		       85 54		      sta	R1
   1152  3001		       90 06		      bcc	IncR1Done
   1153  3003		       a9 00		      lda	#0
   1154  3005		       65 55		      adc	R1+1
   1155  3007		       85 55		      sta	R1+1
   1156  3009				   IncR1Done
   1157  3009		       68		      pla
   1158  300a		       60		      rts
   1159  300b							;=========================================================================
   1160  300b							; on exit c is set on overflow
   1161  300b				   IncR0
   1162  300b		       48		      pha
   1163  300c		       18		      clc
   1164  300d		       a9 01		      lda	#1
   1165  300f		       65 52		      adc	R0
   1166  3011		       85 52		      sta	R0
   1167  3013		       90 06		      bcc	IncR0Done
   1168  3015		       a9 00		      lda	#0
   1169  3017		       65 53		      adc	R0+1
   1170  3019		       85 53		      sta	R0+1
   1171  301b				   IncR0Done
   1172  301b		       68		      pla
   1173  301c		       60		      rts
   1174  301d
   1175  301d
   1176  301d
   1177  301d
   1178  301d
   1179  301d
   1180  301d
   1181  301d
   1182  301d
   1183  301d
   1184  301d
   1185  301d
   1186  301d
   1187  301d
   1188  301d
   1189  301d
------- FILE mytb.asm
   2490  301d
   2491  301d					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  301d					      include	"storage.asm"
      1  301d							;
      2  301d							;=====================================================
      3  301d							;=====================================================
      4  301d							;=====================================================
      5  301d							; This file contains the functions for saving and
      6  301d							; restoring programs from some sort of mass storage
      7  301d							; device.  This particular version is for using the
      8  301d							; Corsham Tech SD Card System.
      9  301d							;=====================================================
     10  301d							;=====================================================
     11  301d							;=====================================================
     12  301d
     13 U367c					      seg.u	TBData
     14 U367c		       00	   diskBufLength ds	1
     15 U367d		       00	   diskBufOffset ds	1
     16 U367e		       00 00 00 00*DiskFileName ds	64
     17 U36be
     18  301d					      SEG	Code
     19  301d
     20  301d							;
     21  301d							;=====================================================
     22  301d							; Open a file for reading as a program.  The next
     23  301d							; thing on the line should be the filename.
     24  301d							;
     25  301d				   iOPENREAD
     26  301d					      if	XKIM || CTMON65
     27  301d		       20 37 30 	      jsr	setFileName	;Set the file name to open
     28  3020		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  3023		       90 07		      bcc	Ropenok	;branch if opened ok
     30  3025							;
     31  3025							; Open failed
     32  3025							;
     33  3025		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  3027		       a9 00	   Rdfail2    lda	#0
     35  3029		       4c 7d 06 	      jmp	iErr2
     36  302c							;
     37  302c							; Clear counts and offsets so the next read will
     38  302c							; cause the file to be read.
     39  302c							;
     40  302c		       a9 00	   Ropenok    lda	#0
     41  302e		       8d 7d 36 	      sta	diskBufOffset
     42  3031		       8d 7c 36 	      sta	diskBufLength
     43  3034		       4c b1 02 	      jmp	NextIL
     44  3037					      endif
     45  3037
     46  3037							;===============================================================
     47  3037							; Set file name
     48  3037				   setFileName
     49  3037		       a4 51		      ldy	CUROFF
     50  3039		       b1 4f		      lda	(CURPTR),y
     51  303b		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  303d		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  303f
     54  303f		       18		      clc
     55  3040		       98		      tya
     56  3041		       65 4f		      adc	CURPTR
     57  3043		       85 52		      sta	R0	;LSB
     58  3045		       a5 50		      lda	CURPTR+1
     59  3047		       69 00		      adc	#0
     60  3049		       85 53		      sta	R0+1
     61  304b		       a9 7e		      lda	#DiskFileName&$ff
     62  304d		       85 54		      sta	R1
     63  304f		       a9 36		      lda	#DiskFileName>>8
     64  3051		       85 55		      sta	R1+1
     65  3053		       20 bb 2f 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  3056		       a5 52		      lda	R0
     67  3058		       18		      clc
     68  3059		       65 51		      adc	CUROFF	; add the current offset
     69  305b		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  305d				   ResetFileName
     71  305d		       a0 7e		      ldy	#DiskFileName&$ff
     72  305f		       a2 36		      ldx	#DiskFileName>>8
     73  3061		       18		      clc
     74  3062		       60		      rts
     75  3063
     76  3063				   setFileNameNotFound
     77  3063		       68		      pla
     78  3064		       68		      pla		; remove the return address from the stack
     79  3065		       a9 00		      lda	#0
     80  3067		       a2 09		      ldx	#ERR_NO_FILENAME
     81  3069		       4c 7d 06 	      jmp	iErr2
     82  306c
     83  306c							;
     84  306c							;==============================JUSTLOSTINTIME 08/02/2022========
     85  306c							;Remove a file from the disk
     86  306c				   iRMFILE
     87  306c					      if	XKIM || CTMON65
     88  306c		       20 37 30 	      jsr	setFileName
     89  306f		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  3072		       90 07		      bcc	wrmOk	;branch if removed ok
     91  3074		       a9 00		      lda	#0
     92  3076		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  3078		       4c 7d 06 	      jmp	iErr2
     94  307b				   wrmOk
     95  307b		       4c b1 02 	      jmp	NextIL
     96  307e
     97  307e					      endif
     98  307e							;
     99  307e							;=====================================================
    100  307e				   iOPENWRITE
    101  307e					      if	XKIM || CTMON65
    102  307e		       20 37 30 	      jsr	setFileName
    103  3081		       20 39 2a 	      jsr	getILByte	;get the append or create byte
    104  3084		       c9 01		      cmp	#1	;create/truncate
    105  3086		       d0 06		      bne	iopencont
    106  3088		       20 5d 30 	      jsr	ResetFileName	;point back to the file name
    107  308b		       20 45 f0 	      jsr	DiskRmFile	;by default files opened for write are append
    108  308e
    109  308e				   iopencont
    110  308e		       20 5d 30 	      jsr	ResetFileName	;point back to the file name
    111  3091		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    112  3094		       90 07		      bcc	Wopenok	;branch if opened ok
    113  3096							;
    114  3096							; Open failed
    115  3096							;
    116  3096		       a9 00	   Wdfail     lda	#0
    117  3098		       a2 08		      ldx	#ERR_WRITE_FAIL
    118  309a		       4c 7d 06 	      jmp	iErr2
    119  309d							;
    120  309d		       4c b1 02    Wopenok    jmp	NextIL
    121  30a0					      endif
    122  30a0							;
    123  30a0							;=====================================================
    124  30a0							; Gets a line of input from the disk file and puts it
    125  30a0							; into LINBUF.
    126  30a0							;
    127  30a0							; On exit:
    128  30a0							;    CURPTR points to LINBUF
    129  30a0							;    LINBUF contains the line with 0 at the end.
    130  30a0							;    Y has offset to first non-space character
    131  30a0							;    CURROFF has the same as Y.
    132  30a0							;
    133  30a0				   iDGETLINE
    134  30a0					      if	XKIM || CTMON65
    135  30a0		       a2 9a		      ldx	#LINBUF&$ff
    136  30a2		       86 4f		      stx	CURPTR
    137  30a4		       a2 42		      ldx	#LINBUF>>8
    138  30a6		       86 50		      stx	CURPTR+1
    139  30a8							;
    140  30a8		       a2 00		      ldx	#0	;offset
    141  30aa		       8e 1e 43    iDgetLoop  stx	getlinx
    142  30ad		       20 18 31 	      jsr	getNextFileByte
    143  30b0		       b0 16		      bcs	iGetEOF
    144  30b2		       c9 0d		      cmp	#CR
    145  30b4		       f0 0d		      beq	iGetEOL
    146  30b6		       c9 0a		      cmp	#LF
    147  30b8		       f0 09		      beq	iGetEOL
    148  30ba		       ae 1e 43 	      ldx	getlinx
    149  30bd		       9d 9a 42 	      sta	LINBUF,x
    150  30c0		       e8		      inx
    151  30c1		       d0 e7		      bne	iDgetLoop
    152  30c3							;
    153  30c3							; Handle end of line.	If the line has nothing, loop
    154  30c3							; back and get another line.
    155  30c3							;
    156  30c3		       ae 1e 43    iGetEOL    ldx	getlinx	;blank line?
    157  30c6		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    158  30c8							;
    159  30c8							; This can fall through when there is a line, or
    160  30c8							; called directly when EOF is encountered.
    161  30c8							;
    162  30c8		       ae 1e 43    iGetEOF    ldx	getlinx
    163  30cb		       a9 00		      lda	#0
    164  30cd		       9d 9a 42 	      sta	LINBUF,x
    165  30d0		       a0 00		      ldy	#0
    166  30d2		       20 74 2d 	      jsr	SkipSpaces
    167  30d5		       20 5e 1d 	      jsr	ParseInputLine
    168  30d8		       a9 5b		      lda	#TOKENBUFFER&$ff
    169  30da		       85 4f		      sta	CURPTR
    170  30dc		       a9 1c		      lda	#TOKENBUFFER>>8
    171  30de		       85 50		      sta	CURPTR+1
    172  30e0		       a9 01		      lda	#1
    173  30e2		       85 51		      sta	CUROFF
    174  30e4		       4c b1 02 	      jmp	NextIL
    175  30e7					      endif
    176  30e7
    177  30e7							;
    178  30e7							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    179  30e7							; DISK
    180  30e7							;
    181  30e7				   iDDIR
    182  30e7					      if	XKIM || CTMON65
    183  30e7		       20 30 f0 	      jsr	DiskDir
    184  30ea							;
    185  30ea							; Get/Display each entry
    186  30ea							;
    187  30ea		       a2 36	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    188  30ec		       a0 7e		      ldy	#DiskFileName&$ff
    189  30ee		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    190  30f1		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    191  30f3		       20 bb 21 	      jsr	puts
      0  30f6					      db	"   ",0
      1  30f6		       20 20 20 00	      .byte.b	"   ",0
    193  30fa							; Print the line to the console
    194  30fa		       a2 36		      ldx	#DiskFileName>>8	;pointer to buffer
    195  30fc		       a0 7e		      ldy	#DiskFileName&$ff
    196  30fe		       a5 00		      lda	0
    197  3100		       20 f9 21 	      jsr	PrtStr	;else print name
    198  3103		       20 18 f0 	      jsr	crlf
    199  3106
    200  3106		       4c ea 30 	      jmp	DiskDirLoop	;do next entry
    201  3109
    202  3109		       4c b1 02    DiskDirEnd jmp	NextIL
    203  310c					      endif
    204  310c							;
    205  310c							;=====================================================
    206  310c							; Does a LIST to a Disk file.
    207  310c							;
    208  310c				   iDLIST
    209  310c					      if	XKIM || CTMON65
    210  310c		       20 47 31 	      jsr	SetOutDisk
    211  310f		       4c 3d 08 	      jmp	iLST2
    212  3112					      endif
    213  3112							;
    214  3112							;=====================================================
    215  3112							; Closes any pending disk file.  Okay to call if there
    216  3112							; is no open file.
    217  3112							;
    218  3112				   iDCLOSE
    219  3112					      if	XKIM || CTMON65
    220  3112		       20 42 f0 	      jsr	DiskClose
    221  3115		       4c b1 02 	      jmp	NextIL
    222  3118					      endif
    223  3118							;
    224  3118							;=====================================================
    225  3118							; This gets the next byte from an open disk file.  If
    226  3118							; there are no more bytes left, this returns C set.
    227  3118							; Else, C is clear and A contains the character.
    228  3118							;
    229  3118				   getNextFileByte
    230  3118					      if	XKIM || CTMON65
    231  3118		       ae 7d 36 	      ldx	diskBufOffset
    232  311b		       ec 7c 36 	      cpx	diskBufLength
    233  311e		       d0 14		      bne	hasdata	;branch if still data
    234  3120							;
    235  3120							; There is no data left in the buffer, so read a
    236  3120							; block from the SD system.
    237  3120							;
    238  3120		       a9 84		      lda	#BUFFER_SIZE
    239  3122		       a2 df		      ldx	#buffer>>8
    240  3124		       a0 0a		      ldy	#buffer&$ff
    241  3126		       20 3c f0 	      jsr	DiskRead
    242  3129		       b0 12		      bcs	getNextEof
    243  312b							;
    244  312b							; A contains the number of bytes actually read.
    245  312b							;
    246  312b		       8d 7c 36 	      sta	diskBufLength	;save length
    247  312e		       c9 00		      cmp	#0	;shouldn't happen
    248  3130		       f0 0b		      beq	getNextEof
    249  3132							;
    250  3132		       a2 00		      ldx	#0
    251  3134		       bd 0a df    hasdata    lda	buffer,x
    252  3137		       e8		      inx
    253  3138		       8e 7d 36 	      stx	diskBufOffset
    254  313b		       18		      clc
    255  313c		       60		      rts
    256  313d							;
    257  313d		       a9 00	   getNextEof lda	#0
    258  313f		       8d 7d 36 	      sta	diskBufOffset
    259  3142		       8d 7c 36 	      sta	diskBufLength
    260  3145		       38		      sec
    261  3146		       60		      rts
    262  3147							;
    263  3147							;=====================================================
    264  3147							; Set output vector to the disk output function
    265  3147							;
    266  3147		       a9 52	   SetOutDisk lda	#DOUT&$ff
    267  3149		       8d 70 36 	      sta	BOutVec
    268  314c		       a9 31		      lda	#DOUT/256
    269  314e		       8d 71 36 	      sta	BOutVec+1
    270  3151		       60		      rts
    271  3152							;
    272  3152							;=====================================================
    273  3152							; input a contains charater to write to open file
    274  3152							; output:
    275  3152							;	    C flag clear if no error
    276  3152							;
    277  3152		       8e 7e 36    DOUT       stx	DiskFileName	; Save the x value, fulename not used
    278  3155		       8c 7f 36 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    279  3158		       8d 0a df 	      sta	buffer	; Store the byte to send into the buffer
    280  315b		       a9 01		      lda	#1	; set number of bytes to send to 1
    281  315d		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    282  315f		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    283  3161		       20 3f f0 	      jsr	DiskWrite	; Place the character to disk if a file is open
    284  3164		       ae 7e 36 	      ldx	DiskFileName	; Restore the x value that was saved
    285  3167		       ac 7f 36 	      ldy	DiskFileName+1	; Restore the y value saved
    286  316a		       60		      rts
    287  316b							;=======================================================
    288  316b							; output:
    289  316b							;	  c flag is clear if no error, a contains bytes read
    290  316b							;	  c flag set Reached eof, a undefined
    291  316b							;
    292  316b		       8e 7e 36    DIN	      stx	DiskFileName	; Save the x value, filename not used just storage
    293  316e		       8c 7f 36 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    294  3171		       a9 01		      lda	#1	; set number of bytes to read to 1
    295  3173		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    296  3175		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    297  3177		       20 3c f0 	      jsr	DiskRead
    298  317a		       ad 0a df 	      lda	buffer	; Get the byte just read
    299  317d		       ae 7e 36 	      ldx	DiskFileName
    300  3180		       ac 7f 36 	      ldy	DiskFileName+1
    301  3183		       60		      rts
    302  3184
    303  3184							;========================================================
    304  3184							; Dstat / open/close/stat files
    305  3184				   DSTAT
    306  3184		       60		      rts
    307  3185							;========================================================
    308  3185					      endif
------- FILE mytb.asm
   2493  3185					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  3185					      include	"IL.inc"
      1  3185
      2  3185							;=====================================================
      3  3185							; IL.inc
      4  3185							; These are macros for IL instructions
      5  3185							;
      6  3185					      mac	dw
      7  3185					      .word	{0}
      8  3185					      endm
      9  3185					      mac	db
     10  3185					      .byte	{0}
     11  3185					      endm
     12  3185					      macro	xinit
     13  3185					      db	0
     14  3185					      endm		;reset the il to start clear all
     15  3185							;
     16  3185					      macro	done
     17  3185					      db	1
     18  3185					      endm		;print an error if not end of line
     19  3185							;
     20  3185					      macro	prs
     21  3185					      db	2
     22  3185					      endm		;print a quoted string
     23  3185							;
     24  3185					      macro	prn
     25  3185					      db	3
     26  3185					      endm		;print a number
     27  3185							;
     28  3185					      macro	spc
     29  3185					      db	4
     30  3185					      endm		;print space til new tabstop
     31  3185							;
     32  3185					      macro	nline
     33  3185					      db	5
     34  3185					      endm		;print a new line crlf
     35  3185							;
     36  3185							; My NXT is a bit different in that it takes one
     37  3185							; parameter, which is an address.  If the BASIC
     38  3185							; program is currently running then move to the
     39  3185							; next line and continue execution.  However, if
     40  3185							; in direct mode, jump to the specified IL label.
     41  3185							;
     42  3185					      macro	nxt
     43  3185					      db	6
     44  3185					      dw	{1}	; addr
     45  3185					      endm		; addr
     46  3185							;
     47  3185					      macro	xfer
     48  3185					      db	7
     49  3185					      endm
     50  3185							;
     51  3185					      macro	sav
     52  3185					      db	8
     53  3185					      db	{1}
     54  3185					      endm
     55  3185							;
     56  3185							;  Passed jump if function called, and true false value returned
     57  3185					      macro	rstr
     58  3185					      db	9
     59  3185					      db	({1}-*)-1	;(addr-*)-1
     60  3185					      db	{2}
     61  3185					      endm
     62  3185							;
     63  3185					      macro	cmpr
     64  3185					      db	10
     65  3185					      endm
     66  3185							;
     67  3185					      macro	innum
     68  3185					      db	11
     69  3185					      endm
     70  3185							;
     71  3185					      macro	fin
     72  3185					      db	12
     73  3185					      endm
     74  3185							;
     75  3185							; ERR is followed by an error number.	The error
     76  3185							; code is printed along with the line number.
     77  3185							; Control is passed to the statement set with
     78  3185							; the ERRGOTO statement.
     79  3185							;
     80  3185					      macro	errmsg
     81  3185					      db	13
     82  3185					      dw	{1}	;ecode
     83  3185					      endm		;ecode
     84  3185							;
     85  3185					      macro	add
     86  3185					      db	14
     87  3185					      endm
     88  3185							;
     89  3185					      macro	sub
     90  3185					      db	15
     91  3185					      endm
     92  3185							;
     93  3185					      macro	neg
     94  3185					      db	16
     95  3185					      endm
     96  3185							;
     97  3185					      macro	mul
     98  3185					      db	17
     99  3185					      endm
    100  3185							;
    101  3185					      macro	div
    102  3185					      db	18
    103  3185					      endm
    104  3185							;
    105  3185					      macro	store
    106  3185					      db	19
    107  3185					      endm
    108  3185							;
    109  3185					      macro	ind
    110  3185					      db	20
    111  3185					      endm
    112  3185							;
    113  3185					      macro	lst
    114  3185					      db	21
    115  3185					      endm
    116  3185							;
    117  3185					      macro	init
    118  3185					      db	22
    119  3185					      endm
    120  3185							;
    121  3185					      macro	getline
    122  3185					      db	23
    123  3185					      endm
    124  3185							;
    125  3185					      macro	insert
    126  3185					      db	24
    127  3185					      endm
    128  3185							;
    129  3185					      macro	rtn
    130  3185					      db	25
    131  3185					      endm
    132  3185							;
    133  3185					      macro	exit
    134  3185					      db	26
    135  3185					      endm
    136  3185							;
    137  3185					      macro	lit
    138  3185					      db	27
    139  3185					      dw	{1}	;value
    140  3185					      endm		; value LIT
    141  3185							;
    142  3185					      macro	call
    143  3185					      db	28
    144  3185					      dw	{1}	;addr
    145  3185					      endm		;addr
    146  3185							;
    147  3185							; IJMP will set the IL PC to the specified value.
    148  3185							;
    149  3185					      macro	ijmp
    150  3185					      db	29
    151  3185					      dw	{1}	;addr
    152  3185					      endm		;addr
    153  3185							;
    154  3185					      macro	vinit
    155  3185					      db	30
    156  3185					      endm
    157  3185							;
    158  3185							; ERRGOTO sets the point in the code where the IL
    159  3185							; interpreter will go after any error.
    160  3185							;
    161  3185					      macro	errgoto
    162  3185					      db	31
    163  3185					      dw	{1}	;addr
    164  3185					      endm		;addr
    165  3185							;
    166  3185					      macro	tst
    167  3185					      db	32
    168  3185					      db	({1}-*)-1	;(addr-*)-1
    169  3185					      db	{2},0	;string,0
    170  3185					      endm		;addr,string
    171  3185							;
    172  3185					      macro	tstv
    173  3185					      db	33
    174  3185					      db	({1}-*)-1	;(addr-*)-1
    175  3185					      endm		;addr
    176  3185							;
    177  3185					      macro	tstl
    178  3185					      db	34
    179  3185					      db	({1}-*)-1	;(addr-*)-1
    180  3185					      endm		;addr
    181  3185							;
    182  3185					      macro	tstn
    183  3185					      db	35
    184  3185					      db	({1}-*)-1	;(addr-*)-1
    185  3185					      endm		;addr
    186  3185							;
    187  3185							; FREE returns the amount of free RAM on top of
    188  3185							; the stack.  This is the amount of room the user
    189  3185							; program has available.
    190  3185							;
    191  3185					      macro	free
    192  3185					      db	36
    193  3185					      endm
    194  3185							;
    195  3185							; RANDOM takes the top item off the stack and
    196  3185							; replaces it with a random number that is
    197  3185							; MOD the initial value.  Ie, if the TOS is
    198  3185							; 42 then RANDOM returns a value from 0 to 41.
    199  3185							;
    200  3185					      macro	random
    201  3185					      db	37
    202  3185					      endm
    203  3185							;
    204  3185							; ABS will replace the top of stack with the
    205  3185							; absolute value.
    206  3185							;
    207  3185					      macro	abs
    208  3185					      db	38
    209  3185					      endm
    210  3185							;
    211  3185							; OPENREAD opens a file for reading, as in getting
    212  3185							; statements from it.
    213  3185							;
    214  3185					      macro	openread
    215  3185					      db	39
    216  3185					      endm
    217  3185							;
    218  3185							; OPENWRITE opens a file for writing, as in saving
    219  3185							; the current program to it.
    220  3185							;
    221  3185					      macro	openwrite
    222  3185					      db	40
    223  3185					      db	{1}	; 0= append 1 = create/truncate
    224  3185					      endm
    225  3185							;
    226  3185							; DCLOSE closes any open disk file.
    227  3185							;
    228  3185					      macro	dclose
    229  3185					      db	41
    230  3185					      endm
    231  3185							;
    232  3185							; DGETLINE gets one line from the disk file and puts it
    233  3185							; into LINBUFF.
    234  3185							;
    235  3185					      macro	dgetline
    236  3185					      db	42
    237  3185					      endm
    238  3185							;
    239  3185							; DLIST saves the program to an open disk file.
    240  3185							;
    241  3185					      macro	dlist
    242  3185					      db	43
    243  3185					      endm
    244  3185							; DDIR list the current directory
    245  3185							;
    246  3185					      macro	ddir
    247  3185					      db	44
    248  3185					      endm
    249  3185
    250  3185							; RMFILE remove a fle from disk
    251  3185					      macro	rmfile
    252  3185					      db	45
    253  3185					      endm
    254  3185
    255  3185							; CLEARSCREEN clear the screen
    256  3185					      macro	clearscreen
    257  3185					      db	46
    258  3185					      endm
    259  3185							; POKEMEM Poke value into memory
    260  3185					      macro	pokemem
    261  3185					      db	47
    262  3185					      endm
    263  3185							; PEEKMEM peek at value in memory
    264  3185					      macro	peekmem
    265  3185					      db	48
    266  3185					      endm
    267  3185							; TSTLET Test if the statement is a let without the keyword let
    268  3185					      macro	tstlet
    269  3185					      db	49
    270  3185					      db	({1}-*)-1	;(addr-*)-1
    271  3185					      endm		;addr
    272  3185							; TSTDONE if we reach the end of a statement
    273  3185					      macro	tstdone
    274  3185					      db	50
    275  3185					      db	({1}-*)-1	;(addr-*)-1
    276  3185					      endm		;addr
    277  3185							; GETCHAR	get a character from the input line leave it in RO
    278  3185					      macro	getchar
    279  3185					      db	51
    280  3185					      endm
    281  3185							; PUTCHAR	Put a character to the terminal
    282  3185					      macro	putchar
    283  3185					      db	52
    284  3185					      endm
    285  3185							; Call		Call a machine function return a to stack
    286  3185					      macro	callfunc
    287  3185					      db	53
    288  3185					      endm
    289  3185
    290  3185							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    291  3185					      macro	ibranch
    292  3185					      db	54
    293  3185					      endm
    294  3185
    295  3185							; TSTSTR	 Tests for the open quote in a string
    296  3185					      macro	tststr
    297  3185					      db	55
    298  3185					      db	({1}-*)-1	;(addr-*)-1
    299  3185					      endm
    300  3185							; SETIRQ	Sets the line number to run when an irq happens irq 550
    301  3185					      macro	setirq
    302  3185					      db	56
    303  3185					      endm
    304  3185
    305  3185							; TSTIRQ	Test for irq pending,
    306  3185							;		if so push the IRQ LINE NUMBER into RO, onto stack
    307  3185					      macro	tstirq
    308  3185					      db	57
    309  3185					      db	({1}-*)-1	;(addr-*)-1
    310  3185					      endm
    311  3185
    312  3185							; IRET    return from interupt service
    313  3185					      macro	iret
    314  3185					      db	58
    315  3185					      endm
    316  3185
    317  3185							; INSTR   read a string from the input
    318  3185					      macro	instr
    319  3185					      db	59
    320  3185					      endm
    321  3185
    322  3185							; MODULO Returns the remainder of the division
    323  3185					      macro	modulo
    324  3185					      db	60
    325  3185					      endm
    326  3185							; Set a task line
    327  3185					      macro	taskcreate
    328  3185					      db	61
    329  3185					      endm
    330  3185							; End a task
    331  3185					      macro	etask
    332  3185					      db	62
    333  3185					      endm
    334  3185							; Skip to next task
    335  3185					      macro	ntask
    336  3185					      db	63
    337  3185					      endm
    338  3185							; Subscript
    339  3185					      macro	subscript
    340  3185					      db	64
    341  3185					      db	{1}
    342  3185					      endm
    343  3185							; KILL Task
    344  3185					      macro	taskkill
    345  3185					      db	65
    346  3185					      endm
    347  3185							; STAT Task
    348  3185					      macro	taskstat
    349  3185					      db	66
    350  3185					      endm
    351  3185							;  output value as hex
    352  3185					      macro	hexprt
    353  3185					      db	67
    354  3185					      endm
    355  3185							;  Read in background has completed
    356  3185					      macro	readcomplete
    357  3185					      db	68
    358  3185					      endm
    359  3185							;  ReadInput line
    360  3185					      macro	readstart
    361  3185					      db	69
    362  3185					      endm
    363  3185							; Startio request
    364  3185					      macro	startio
    365  3185					      db	70
    366  3185					      endm
    367  3185							; Endio
    368  3185					      macro	endio
    369  3185					      db	71
    370  3185					      endm
    371  3185							; Logical not
    372  3185					      macro	lognot
    373  3185					      db	72
    374  3185					      endm
    375  3185							; Logical OR
    376  3185					      macro	logor
    377  3185					      db	73
    378  3185					      endm
    379  3185							;Logical and
    380  3185					      macro	logand
    381  3185					      db	74
    382  3185					      endm
    383  3185							;Logical XOR
    384  3185					      macro	logxor
    385  3185					      db	75
    386  3185					      endm
    387  3185							;Wait for task to complete, or list of tasks
    388  3185					      macro	wtask
    389  3185					      db	76
    390  3185					      db	({1}-*)-1	;(addr-*)-1
    391  3185					      endm
    392  3185							;Get the current task id
    393  3185					      MACRO	taskpid
    394  3185					      db	77
    395  3185					      endm
    396  3185							;Trace the basic execution
    397  3185					      Macro	traceprogram
    398  3185					      db	78
    399  3185					      endm
    400  3185							;Do a basic program Trace
    401  3185					      Macro	debugbasic
    402  3185					      db	79
    403  3185					      endm
    404  3185
    405  3185							; Inter Process communications instructions
    406  3185					      Macro	ipcsend
    407  3185					      db	80
    408  3185					      endm
    409  3185					      Macro	ipcreceive
    410  3185					      db	81
    411  3185					      endm
    412  3185					      Macro	ipccheck
    413  3185					      db	82
    414  3185					      endm
    415  3185					      Macro	ipcio
    416  3185					      db	83
    417  3185					      endm
    418  3185					      Macro	pushmathstack
    419  3185					      db	84
    420  3185					      endm
    421  3185					      Macro	popmathstack
    422  3185					      db	85
    423  3185					      endm
    424  3185					      Macro	savemathstack
    425  3185					      db	86
    426  3185					      endm
    427  3185					      Macro	restoremathstack
    428  3185					      db	87
    429  3185					      endm
    430  3185					      Macro	incparmcount
    431  3185					      db	88
    432  3185					      endm
    433  3185					      Macro	taskgetmathstack
    434  3185					      db	89
    435  3185					      endm
    436  3185					      Macro	taskenable
    437  3185					      db	90
    438  3185					      endm
    439  3185					      Macro	tasksuspend
    440  3185					      db	91
    441  3185					      endm
    442  3185					      Macro	taskputmathptr
    443  3185					      db	92
    444  3185					      endm
    445  3185							; Test for an extension type of variable that allows access to a tasks variables
    446  3185							; Using  PID!<Var name>
    447  3185					      Macro	tstvt
    448  3185					      db	93
    449  3185					      db	({1}-*)-1	;(addr-*)-1
    450  3185					      endm
    451  3185
    452  3185							; Provide access to R2 for the IL program
    453  3185					      Macro	setr2
    454  3185					      db	94
    455  3185					      db	{1}	; R2 is only one byte
    456  3185					      endm
    457  3185
    458  3185							;Move stack top to temp
    459  3185					      Macro	stk2tmp
    460  3185					      db	95
    461  3185					      endm
    462  3185
    463  3185					      Macro	tmp2stk
    464  3185					      db	96
    465  3185					      endm
    466  3185
    467  3185					      Macro	tstbyte
    468  3185					      db	97
    469  3185					      db	({1}-*)-1	; (addr-*)-1 goto if match
    470  3185					      dw	{2}	; address to check
    471  3185					      db	{3}	; Value to compare
    472  3185					      endm
    473  3185
    474  3185					      Macro	incvar
    475  3185					      db	98
    476  3185					      endm
    477  3185					      Macro	decvar
    478  3185					      db	99
    479  3185					      endm
    480  3185
    481  3185					      Macro	slice
    482  3185					      db	100
    483  3185					      endm
    484  3185
    485  3185					      Macro	tstb
    486  3185					      db	101
    487  3185					      db	({1}-*)-1
    488  3185					      db	{2}
    489  3185					      endm
    490  3185
    491  3185					      Macro	tstw
    492  3185					      db	102
    493  3185					      db	({1}-*)-1
    494  3185					      dw	{2}
    495  3185					      endm
    496  3185
    497  3185					      Macro	ongoto
    498  3185					      db	103
    499  3185					      dw	{1}
    500  3185					      dw	{2}
    501  3185					      endm
    502  3185
    503  3185					      Macro	tstrelop
    504  3185					      db	104
    505  3185					      db	({1}-*)-1
    506  3185					      endm
    507  3185
    508  3185					      Macro	repeatline
    509  3185					      db	105
    510  3185					      endm
    511  3185
    512  3185							; Check for a precompiled branch, will take branch if precompiled value present
    513  3185					      Macro	tstbranch
    514  3185					      db	106
    515  3185					      db	({1}-*)-1
    516  3185					      endm
    517  3185
    518  3185					      Macro	fastxfer
    519  3185					      db	107
    520  3185					      endm
    521  3185
    522  3185							; Set all io to to a terminal for input output
    523  3185							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    524  3185							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    525  3185					      Macro	setterminal
    526  3185					      db	108
    527  3185					      endm
    528  3185
    529  3185							;Fetch a single byte from memory
    530  3185					      Macro	indb
    531  3185					      db	109
    532  3185					      endm
    533  3185
    534  3185							; Set a block of memory to a fixed value, byte or word
    535  3185							; Stack must contain destiniation address, length to set in bytes, value {byte of word} to initialize to
    536  3185					      Macro	setblock
    537  3185					      db	110
    538  3185					      db	{1}	; the data type to initialize	tByte or tInteger
    539  3185					      endm
    540  3185
    541  3185							; Copy a block of memory
    542  3185							; Stack must contain source address, destination address, length in bytes
    543  3185					      Macro	copyblock
    544  3185					      db	111
    545  3185					      endm
    546  3185
    547  3185							; Compare one block of memory to another
    548  3185							; Stack contains Length, Source1 Source 2
    549  3185							; Place on stack 0 equal, 1 s1>s2, -1 s1 < s2
    550  3185					      Macro	cmpmem
    551  3185					      db	112
    552  3185					      endm
    553  3185
    554  3185							; Shift Left and Right
    555  3185					      Macro	shift
    556  3185					      db	113
    557  3185					      db	{1}	; direction  0 = left 1 = right
    558  3185					      endm
    559  3185
    560  3185							; set of timer macros
    561  3185					      Macro	timerset
    562  3185					      db	114,1
    563  3185					      db	{1}	; value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    564  3185					      endm
    565  3185
    566  3185					      Macro	timerstop
    567  3185					      db	114,0,0
    568  3185					      endm
    569  3185
    570  3185					      Macro	timervaluelow
    571  3185					      db	114,2,0
    572  3185					      endm
    573  3185
    574  3185					      Macro	timervaluehigh
    575  3185					      db	114,3,0
    576  3185					      endm
    577  3185
    578  3185					      Macro	timer
    579  3185					      db	114
    580  3185					      endm
------- FILE mytb.asm
   2495  3185							;
   2496  3185				  -	      if	FIXED
   2497  3185				  -	      org	$1000
   2498  3185					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  3185					      include	"basic.il"
      1  3185					      seg	Code
      2  3185							; on goto table
      3  3185							; format :   first byte is value Base, subtracted from value found
      4  3185							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  3185				   BasicStmts
      0  3185					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  3185		       01 23		      .byte.b	kBeginKey,(kKeyCount+1)
      0  3187					      dw	ekLet
      1  3187		       14 32		      .word.w	ekLet
      0  3189					      dw	ekInc
      1  3189		       46 32		      .word.w	ekInc
      0  318b					      dw	ekDec
      1  318b		       53 32		      .word.w	ekDec
      0  318d					      dw	ekIreturn
      1  318d		       60 32		      .word.w	ekIreturn
      0  318f					      dw	ekIf
      1  318f		       65 32		      .word.w	ekIf
      0  3191					      dw	ekThen
      1  3191		       6b 32		      .word.w	ekThen
      0  3193					      dw	ekGoto
      1  3193		       6f 32		      .word.w	ekGoto
      0  3195					      dw	ekGosub
      1  3195		       12 36		      .word.w	ekGosub
      0  3197					      dw	ekReturn
      1  3197		       20 36		      .word.w	ekReturn
      0  3199					      dw	ekRem
      1  3199		       83 32		      .word.w	ekRem
      0  319b					      dw	ekPrint	; should be entry for print
      1  319b		       99 32		      .word.w	ekPrint
      0  319d					      dw	ekTaske
      1  319d		       e6 32		      .word.w	ekTaske
      0  319f					      dw	ekTaskn
      1  319f		       fc 32		      .word.w	ekTaskn
      0  31a1					      dw	ekTaskw
      1  31a1		       03 33		      .word.w	ekTaskw
      0  31a3					      dw	ekPoke
      1  31a3		       1e 33		      .word.w	ekPoke
      0  31a5					      dw	ekPutch
      1  31a5		       80 33		      .word.w	ekPutch
      0  31a7					      dw	ekCls
      1  31a7		       8b 33		      .word.w	ekCls
      0  31a9					      dw	ekInput
      1  31a9		       92 33		      .word.w	ekInput
      0  31ab					      dw	ekEnd
      1  31ab		       c0 33		      .word.w	ekEnd
      0  31ad					      dw	ekIrq
      1  31ad		       c4 33		      .word.w	ekIrq
      0  31af					      dw	ekKill
      1  31af		       cf 33		      .word.w	ekKill
      0  31b1					      dw	ekList
      1  31b1		       da 33		      .word.w	ekList
      0  31b3					      dw	ekRun
      1  31b3		       df 33		      .word.w	ekRun
      0  31b5					      dw	ekNew
      1  31b5		       e8 33		      .word.w	ekNew
      0  31b7					      dw	ekSlice
      1  31b7		       ec 33		      .word.w	ekSlice
      0  31b9					      dw	ekTrace
      1  31b9		       f7 33		      .word.w	ekTrace
      0  31bb					      dw	ekExit
      1  31bb		       08 34		      .word.w	ekExit
      0  31bd					      dw	ekSave
      1  31bd		       09 34		      .word.w	ekSave
      0  31bf					      dw	ekLoad
      1  31bf		       10 34		      .word.w	ekLoad
      0  31c1					      dw	ekErase
      1  31c1		       20 34		      .word.w	ekErase
      0  31c3					      dw	ekDir
      1  31c3		       1c 34		      .word.w	ekDir
      0  31c5					      dw	ekSetTerm
      1  31c5		       89 32		      .word.w	ekSetTerm
      0  31c7					      dw	ekSetMemB
      1  31c7		       35 33		      .word.w	ekSetMemB
      0  31c9					      dw	ekSetMemW
      1  31c9		       41 33		      .word.w	ekSetMemW
      0  31cb					      dw	ekCopyMem
      1  31cb		       63 33		      .word.w	ekCopyMem
     42  31cd							;
     43  31cd							; Logical operators
      0  31cd				   BasicLogical db	kOr,3
      1  31cd		       25 03		      .byte.b	kOr,3
      0  31cf					      dw	ekOr
      1  31cf		       55 34		      .word.w	ekOr
      0  31d1					      dw	ekXor
      1  31d1		       5a 34		      .word.w	ekXor
      0  31d3					      dw	ekAnd
      1  31d3		       50 34		      .word.w	ekAnd
     48  31d5
      0  31d5				   BasicShift db	kShr,2
      1  31d5		       28 02		      .byte.b	kShr,2
      0  31d7					      dw	ekShiftRight
      1  31d7		       45 34		      .word.w	ekShiftRight
      0  31d9					      dw	ekShiftLeft
      1  31d9		       3f 34		      .word.w	ekShiftLeft
     52  31db
     53  31db							;functions returning values
     54  31db
      0  31db				   BasicFuncs db	kBeginFunc,kFuncCount
      1  31db		       2a 12		      .byte.b	kBeginFunc,kFuncCount
      0  31dd					      dw	ekTrue
      1  31dd		       af 34		      .word.w	ekTrue
      0  31df					      dw	ekFalse
      1  31df		       b3 34		      .word.w	ekFalse
      0  31e1					      dw	ekFree
      1  31e1		       b7 34		      .word.w	ekFree
      0  31e3					      dw	ekGetch
      1  31e3		       bf 34		      .word.w	ekGetch
      0  31e5					      dw	ekPeek
      1  31e5		       04 35		      .word.w	ekPeek
      0  31e7					      dw	ekTask
      1  31e7		       0f 35		      .word.w	ekTask
      0  31e9					      dw	ekIpcc
      1  31e9		       5b 35		      .word.w	ekIpcc
      0  31eb					      dw	ekIpcs
      1  31eb		       36 35		      .word.w	ekIpcs
      0  31ed					      dw	ekIpcr
      1  31ed		       47 35		      .word.w	ekIpcr
      0  31ef					      dw	ekRnd
      1  31ef		       66 35		      .word.w	ekRnd
      0  31f1					      dw	ekStat
      1  31f1		       84 35		      .word.w	ekStat
      0  31f3					      dw	ekAbs
      1  31f3		       79 35		      .word.w	ekAbs
      0  31f5					      dw	ekCall
      1  31f5		       91 35		      .word.w	ekCall
      0  31f7					      dw	ekGofn
      1  31f7		       19 36		      .word.w	ekGofn
      0  31f9					      dw	ekPid
      1  31f9		       8f 35		      .word.w	ekPid
      0  31fb					      dw	ekAddr
      1  31fb		       c7 34		      .word.w	ekAddr
      0  31fd					      dw	ekCmpMem
      1  31fd		       d6 34		      .word.w	ekCmpMem
      0  31ff					      dw	eKTimer
      1  31ff		       ed 34		      .word.w	eKTimer
     74  3201							;====================================================
     75  3201							; file constants
     76  3201		       00 00	   OPEN_APPEND equ	0	; append to file
     77  3201		       00 01	   OPEN_CREATE equ	1	; truncate/create file
     78  3201
     79  3201							;=====================================================
     80  3201							; This is the IL of the BASIC (or whatever) language.
     81  3201							; Because of the way macros are implemented by as65,
     82  3201							; labels can't be on the same line as a macro
     83  3201							; invocation, so that's why labels are on separate
     84  3201							; lines.
     85  3201							;
     86  3201		       32 01	   IL	      equ	*
     87  3201
     88  3201							;THE IL CONTROL SECTION
     89  3201
     90  3201				   START
      0  3201					      INIT		;INITIALIZE
      0  3201					      db	22
      1  3201		       16		      .byte.b	22
      0  3202					      NLINE		;WRITE CRLF
      0  3202					      db	5
      1  3202		       05		      .byte.b	5
      0  3203					      ERRGOTO	CO	;where to go after an error
      0  3203					      db	31
      1  3203		       1f		      .byte.b	31
      0  3204					      dw	CO
      1  3204		       07 32		      .word.w	CO
      0  3206					      VINIT		;clear all variables
      0  3206					      db	30
      1  3206		       1e		      .byte.b	30
     95  3207							;
     96  3207							; This is where we jump to get a line of commands or
     97  3207							; a program from the user.
     98  3207							;
     99  3207				   CO
      0  3207					      GETLINE		;WRITE PROMPT AND GET LINE
      0  3207					      db	23
      1  3207		       17		      .byte.b	23
      0  3208					      TSTL	XEC	;TEST FOR LINE NUMBER, if none then execute the line
      0  3208					      db	34
      1  3208		       22		      .byte.b	34
      0  3209					      db	(XEC-*)-1
      1  3209		       04		      .byte.b	(XEC-*)-1
      0  320a					      INSERT		;INSERT IT (MAY BE DELETE)
      0  320a					      db	24
      1  320a		       18		      .byte.b	24
      0  320b					      IJMP	CO
      0  320b					      db	29
      1  320b		       1d		      .byte.b	29
      0  320c					      dw	CO
      1  320c		       07 32		      .word.w	CO
    104  320e				   XEC
      0  320e					      XINIT		;INITIALIZE
      0  320e					      db	0
      1  320e		       00		      .byte.b	0
    106  320f							;============================================================================
    107  320f							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
    108  320f							;
    109  320f				   STMT
      0  320f					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  320f					      db	57
      1  320f		       39		      .byte.b	57
      0  3210					      db	(notirq-*)-1
      1  3210		       00		      .byte.b	(notirq-*)-1
    111  3211							;==========================================================================================
    112  3211							; Process a let statement implied or explicit.
    113  3211							;
    114  3211				   notirq
      0  3211					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  3211					      db	79
      1  3211		       4f		      .byte.b	79
      0  3212					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  3212					      db	49
      1  3212		       31		      .byte.b	49
      0  3213					      db	(DoVector-*)-1
      1  3213		       2d		      .byte.b	(DoVector-*)-1
    117  3214				   ekLet
      0  3214					      TSTV	DoVector	; Test for variable
      0  3214					      db	33
      1  3214		       21		      .byte.b	33
      0  3215					      db	(DoVector-*)-1
      1  3215		       2b		      .byte.b	(DoVector-*)-1
      0  3216					      CALL	FactVarPtrNoTst	; get a pointer to the variable
      0  3216					      db	28
      1  3216		       1c		      .byte.b	28
      0  3217					      dw	FactVarPtrNoTst
      1  3217		       d8 35		      .word.w	FactVarPtrNoTst
    120  3219
    121  3219				   LETINDEX_ALL
      0  3219					      TSTB	ERRMissingEquals,oEqual	; (This line originally omitted)
      0  3219					      db	101
      1  3219		       65		      .byte.b	101
      0  321a					      db	(ERRMissingEquals-*)-1
      1  321a		       20		      .byte.b	(ERRMissingEquals-*)-1
      0  321b					      db	oEqual
      1  321b		       f2		      .byte.b	oEqual
    123  321c				   LETBE
      0  321c					      TSTBYTE	LETAssignByte,R2,tByte	; Check for a byte conversion
      0  321c					      db	97
      1  321c		       61		      .byte.b	97
      0  321d					      db	(LETAssignByte-*)-1
      1  321d		       10		      .byte.b	(LETAssignByte-*)-1
      0  321e					      dw	R2
      1  321e		       58 00		      .word.w	R2
      0  3220					      db	tByte
      1  3220		       a2		      .byte.b	tByte
      0  3221					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  3221					      db	28
      1  3221		       1c		      .byte.b	28
      0  3222					      dw	EXPR
      1  3222		       28 34		      .word.w	EXPR
      0  3224					      DONE		; REPORT ERROR IF NOT NEXT
      0  3224					      db	1
      1  3224		       01		      .byte.b	1
      0  3225					      SETR2	tInteger	; Store an integer type
      0  3225					      db	94
      1  3225		       5e		      .byte.b	94
      0  3226					      db	tInteger
      1  3226		       a4		      .byte.b	tInteger
      0  3227					      STORE		; STORE RESULT at variable address
      0  3227					      db	19
      1  3227		       13		      .byte.b	19
      0  3228					      NXT	CO	; AND SEQUENCE TO NEXT
      0  3228					      db	6
      1  3228		       06		      .byte.b	6
      0  3229					      dw	CO
      1  3229		       07 32		      .word.w	CO
      0  322b					      IJMP	STMT	; Next statement
      0  322b					      db	29
      1  322b		       1d		      .byte.b	29
      0  322c					      dw	STMT
      1  322c		       0f 32		      .word.w	STMT
    131  322e
    132  322e				   LETAssignByte
      0  322e					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  322e					      db	28
      1  322e		       1c		      .byte.b	28
      0  322f					      dw	EXPR
      1  322f		       28 34		      .word.w	EXPR
      0  3231					      DONE		; REPORT ERROR IF NOT NEXT
      0  3231					      db	1
      1  3231		       01		      .byte.b	1
      0  3232					      SETR2	tByte	; Set to store a byte value
      0  3232					      db	94
      1  3232		       5e		      .byte.b	94
      0  3233					      db	tByte
      1  3233		       a2		      .byte.b	tByte
      0  3234					      STORE		; STORE RESULT at variable address
      0  3234					      db	19
      1  3234		       13		      .byte.b	19
      0  3235					      NXT	CO	; AND SEQUENCE TO NEXT
      0  3235					      db	6
      1  3235		       06		      .byte.b	6
      0  3236					      dw	CO
      1  3236		       07 32		      .word.w	CO
      0  3238					      IJMP	STMT	; Next statement
      0  3238					      db	29
      1  3238		       1d		      .byte.b	29
      0  3239					      dw	STMT
      1  3239		       0f 32		      .word.w	STMT
    139  323b
    140  323b				   ERRMissingEquals
      0  323b					      ERRMSG	ERR_MISSINGEQUALSIGN	; Missing asignment
      0  323b					      db	13
      1  323b		       0d		      .byte.b	13
      0  323c					      dw	ERR_MISSINGEQUALSIGN
      1  323c		       18 00		      .word.w	ERR_MISSINGEQUALSIGN
    142  323e
    143  323e				   ERRVEC2
      0  323e					      IJMP	UNKNOWN
      0  323e					      db	29
      1  323e		       1d		      .byte.b	29
      0  323f					      dw	UNKNOWN
      1  323f		       24 34		      .word.w	UNKNOWN
    145  3241							;=============================================================
    146  3241							;Branch on a valid statement start
    147  3241				   DoVector
      0  3241					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  3241					      db	103
      1  3241		       67		      .byte.b	103
      0  3242					      dw	BasicStmts
      1  3242		       85 31		      .word.w	BasicStmts
      0  3244					      dw	UNKNOWN
      1  3244		       24 34		      .word.w	UNKNOWN
    149  3246							;This will never return here!
    150  3246							;=============================================================
    151  3246							; Inc or dec a variable
    152  3246				   ekInc
      0  3246					      TSTV	ERRVEC2	; Verify we have a variable
      0  3246					      db	33
      1  3246		       21		      .byte.b	33
      0  3247					      db	(ERRVEC2-*)-1
      1  3247		       f6		      .byte.b	(ERRVEC2-*)-1
      0  3248					      CALL	FactVarPtrNoTst	; Get a pointer to the memory location to increment
      0  3248					      db	28
      1  3248		       1c		      .byte.b	28
      0  3249					      dw	FactVarPtrNoTst
      1  3249		       d8 35		      .word.w	FactVarPtrNoTst
    155  324b							;	  TSTB	     eDoInc,oBang		    ; Allow to inc or dec other tasks variables
    156  324b							;	  IND					    ; we just got a pid
    157  324b							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    158  324b				   eDoInc
      0  324b					      INCVAR		; Do the increment of the variable
      0  324b					      db	98
      1  324b		       62		      .byte.b	98
      0  324c					      DONE		; Test for end of line or end of statement ":"
      0  324c					      db	1
      1  324c		       01		      .byte.b	1
      0  324d					      NXT	CO	; Get the next statement, branch CO if end of program
      0  324d					      db	6
      1  324d		       06		      .byte.b	6
      0  324e					      dw	CO
      1  324e		       07 32		      .word.w	CO
      0  3250					      IJMP	STMT	; Process the next statement
      0  3250					      db	29
      1  3250		       1d		      .byte.b	29
      0  3251					      dw	STMT
      1  3251		       0f 32		      .word.w	STMT
    163  3253							;S1Dec:
    164  3253							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    165  3253				   ekDec
      0  3253					      TSTV	ERRVEC2	; Must be followed by a variable
      0  3253					      db	33
      1  3253		       21		      .byte.b	33
      0  3254					      db	(ERRVEC2-*)-1
      1  3254		       e9		      .byte.b	(ERRVEC2-*)-1
      0  3255					      CALL	FactVarPtrNoTst	; Get a pointer to the variable to update
      0  3255					      db	28
      1  3255		       1c		      .byte.b	28
      0  3256					      dw	FactVarPtrNoTst
      1  3256		       d8 35		      .word.w	FactVarPtrNoTst
    168  3258							;	  TSTB	     eDoDec,oBang		    ; Allow to inc or dec other tasks variables
    169  3258							;	  IND					    ; we just got a pid
    170  3258							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    171  3258				   eDoDec
      0  3258					      DECVAR		; Decrement the actual variable
      0  3258					      db	99
      1  3258		       63		      .byte.b	99
      0  3259					      DONE		; Test if end of line or : statement
      0  3259					      db	1
      1  3259		       01		      .byte.b	1
      0  325a					      NXT	CO	; If at end of program then got the console
      0  325a					      db	6
      1  325a		       06		      .byte.b	6
      0  325b					      dw	CO
      1  325b		       07 32		      .word.w	CO
      0  325d					      IJMP	STMT	; Process the next statement of command line
      0  325d					      db	29
      1  325d		       1d		      .byte.b	29
      0  325e					      dw	STMT
      1  325e		       0f 32		      .word.w	STMT
    176  3260							;=============================================================================================================================
    177  3260							; iret or ireturn, Return from interupt process
    178  3260							;
    179  3260							;S1Iret:
    180  3260							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    181  3260							;S1Sa:
    182  3260				   ekIreturn
      0  3260					      DONE		; Must be only thing on the line
      0  3260					      db	1
      1  3260		       01		      .byte.b	1
      0  3261					      IRET		; RESTORE LINE NUMBER OF CALL
      0  3261					      db	58
      1  3261		       3a		      .byte.b	58
      0  3262					      IJMP	STMT
      0  3262					      db	29
      1  3262		       1d		      .byte.b	29
      0  3263					      dw	STMT
      1  3263		       0f 32		      .word.w	STMT
    186  3265							;==============================================================================================================================
    187  3265							;Process if statement, if true then process all statements until end of line reached
    188  3265							;S1S1:
    189  3265							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    190  3265				   ekIf
      0  3265					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  3265					      db	28
      1  3265		       1c		      .byte.b	28
      0  3266					      dw	EXPR
      1  3266		       28 34		      .word.w	EXPR
      0  3268					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  3268					      db	101
      1  3268		       65		      .byte.b	101
      0  3269					      db	(S1W-*)-1
      1  3269		       01		      .byte.b	(S1W-*)-1
      0  326a					      db	kThen
      1  326a		       06		      .byte.b	kThen
    193  326b				   ekThen
    194  326b				   S1W
      0  326b					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  326b					      db	54
      1  326b		       36		      .byte.b	54
      0  326c					      IJMP	STMT
      0  326c					      db	29
      1  326c		       1d		      .byte.b	29
      0  326d					      dw	STMT
      1  326d		       0f 32		      .word.w	STMT
    197  326f							;===============================================================================================================================
    198  326f							; Test for GOTO
    199  326f							;S1Z:
    200  326f							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    201  326f							;
    202  326f				   ekGoto
      0  326f					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  326f					      db	106
      1  326f		       6a		      .byte.b	106
      0  3270					      db	(ekGotoCompiled-*)-1
      1  3270		       0e		      .byte.b	(ekGotoCompiled-*)-1
    204  3271							; Else we have the address and just goto that address
      0  3271					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  3271					      db	101
      1  3271		       65		      .byte.b	101
      0  3272					      db	(ekGotoLine-*)-1
      1  3272		       05		      .byte.b	(ekGotoLine-*)-1
      0  3273					      db	oPeriod
      1  3273		       e9		      .byte.b	oPeriod
      0  3274					      REPEATLINE		; Repeat the same line again
      0  3274					      db	105
      1  3274		       69		      .byte.b	105
      0  3275					      IJMP	STMT	; Go do the statement
      0  3275					      db	29
      1  3275		       1d		      .byte.b	29
      0  3276					      dw	STMT
      1  3276		       0f 32		      .word.w	STMT
    208  3278
    209  3278				   ekGotoLine
      0  3278					      CALL	EXPR	; GET LABEL
      0  3278					      db	28
      1  3278		       1c		      .byte.b	28
      0  3279					      dw	EXPR
      1  3279		       28 34		      .word.w	EXPR
      0  327b					      lit	0	; Place indicator for line num on stack
      0  327b					      db	27
      1  327b		       1b		      .byte.b	27
      0  327c					      dw	0
      1  327c		       00 00		      .word.w	0
      0  327e					      FASTXFER
      0  327e					      db	107
      1  327e		       6b		      .byte.b	107
    213  327f				   ekGotoCompiled
      0  327f					      lit	1	; tell it that mempointer on the stack
      0  327f					      db	27
      1  327f		       1b		      .byte.b	27
      0  3280					      dw	1
      1  3280		       01 00		      .word.w	1
      0  3282					      FASTXFER		; put top of stack into curptr
      0  3282					      db	107
      1  3282		       6b		      .byte.b	107
    216  3283
    217  3283
    218  3283							;==================================================================================================================================
    219  3283							; Process REM statement
    220  3283							;
    221  3283							;S2a:
    222  3283							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    223  3283				   ekRem
      0  3283					      NXT	CO	; The rest of the line is ignored
      0  3283					      db	6
      1  3283		       06		      .byte.b	6
      0  3284					      dw	CO
      1  3284		       07 32		      .word.w	CO
      0  3286					      IJMP	STMT	; Process the next statement
      0  3286					      db	29
      1  3286		       1d		      .byte.b	29
      0  3287					      dw	STMT
      1  3287		       0f 32		      .word.w	STMT
    226  3289							;====================================================================================================================================
    227  3289							; Set the Task input output slot each slot is 16 byte starting at e000
    228  3289							; so 0,1,...
    229  3289				   ekSetTerm
      0  3289					      CALL	EXPR
      0  3289					      db	28
      1  3289		       1c		      .byte.b	28
      0  328a					      dw	EXPR
      1  328a		       28 34		      .word.w	EXPR
      0  328c					      TSTB	ERRVEC,oComma
      0  328c					      db	101
      1  328c		       65		      .byte.b	101
      0  328d					      db	(ERRVEC-*)-1
      1  328d		       2f		      .byte.b	(ERRVEC-*)-1
      0  328e					      db	oComma
      1  328e		       e2		      .byte.b	oComma
      0  328f					      CALL	EXPR
      0  328f					      db	28
      1  328f		       1c		      .byte.b	28
      0  3290					      dw	EXPR
      1  3290		       28 34		      .word.w	EXPR
      0  3292					      SETTERMINAL
      0  3292					      db	108
      1  3292		       6c		      .byte.b	108
      0  3293					      NXT	CO	;Next statement to execute
      0  3293					      db	6
      1  3293		       06		      .byte.b	6
      0  3294					      dw	CO
      1  3294		       07 32		      .word.w	CO
      0  3296					      IJMP	STMT
      0  3296					      db	29
      1  3296		       1d		      .byte.b	29
      0  3297					      dw	STMT
      1  3297		       0f 32		      .word.w	STMT
    236  3299							;==================================================================================================================================
    237  3299							; Print statement
    238  3299							;
    239  3299							;S3:
    240  3299							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    241  3299				   ekPrint
      0  3299					      STARTIO		; Lock task until io completes
      0  3299					      db	70
      1  3299		       46		      .byte.b	70
    243  329a				   S4
      0  329a					      TSTDONE	S4a	; Test if we just want crlf printed
      0  329a					      db	50
      1  329a		       32		      .byte.b	50
      0  329b					      db	(S4a-*)-1
      1  329b		       03		      .byte.b	(S4a-*)-1
      0  329c					      IJMP	S6
      0  329c					      db	29
      1  329c		       1d		      .byte.b	29
      0  329d					      dw	S6
      1  329d		       b4 32		      .word.w	S6
    246  329f
    247  329f				   S4a
      0  329f					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  329f					      db	101
      1  329f		       65		      .byte.b	101
      0  32a0					      db	(S7-*)-1
      1  32a0		       1f		      .byte.b	(S7-*)-1
      0  32a1					      db	tString
      1  32a1		       a0		      .byte.b	tString
      0  32a2					      PRS		; PRINT STRING
      0  32a2					      db	2
      1  32a2		       02		      .byte.b	2
    250  32a3				   S5
      0  32a3					      TSTB	S6A,oComma	; IS THERE MORE?
      0  32a3					      db	101
      1  32a3		       65		      .byte.b	101
      0  32a4					      db	(S6A-*)-1
      1  32a4		       07		      .byte.b	(S6A-*)-1
      0  32a5					      db	oComma
      1  32a5		       e2		      .byte.b	oComma
      0  32a6					      SPC		; SPACE TO NEXT ZONE
      0  32a6					      db	4
      1  32a6		       04		      .byte.b	4
      0  32a7					      TSTDONE	S4	; Not end of line jump back
      0  32a7					      db	50
      1  32a7		       32		      .byte.b	50
      0  32a8					      db	(S4-*)-1
      1  32a8		       f1		      .byte.b	(S4-*)-1
      0  32a9					      IJMP	S6Z	; YES JUMP BACK
      0  32a9					      db	29
      1  32a9		       1d		      .byte.b	29
      0  32aa					      dw	S6Z
      1  32aa		       b6 32		      .word.w	S6Z
    255  32ac
    256  32ac							;
    257  32ac							; If a semicolon, don't do anything.
    258  32ac							;
    259  32ac				   S6A
      0  32ac					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  32ac					      db	101
      1  32ac		       65		      .byte.b	101
      0  32ad					      db	(S6-*)-1
      1  32ad		       06		      .byte.b	(S6-*)-1
      0  32ae					      db	oSemiColon
      1  32ae		       e3		      .byte.b	oSemiColon
      0  32af					      TSTDONE	S4	; Jump Back if not end of line
      0  32af					      db	50
      1  32af		       32		      .byte.b	50
      0  32b0					      db	(S4-*)-1
      1  32b0		       e9		      .byte.b	(S4-*)-1
      0  32b1					      IJMP	S6Z
      0  32b1					      db	29
      1  32b1		       1d		      .byte.b	29
      0  32b2					      dw	S6Z
      1  32b2		       b6 32		      .word.w	S6Z
    263  32b4
    264  32b4				   S6
    265  32b4
      0  32b4					      DONE		; ERROR IF CR NOT NEXT
      0  32b4					      db	1
      1  32b4		       01		      .byte.b	1
      0  32b5					      NLINE
      0  32b5					      db	5
      1  32b5		       05		      .byte.b	5
    268  32b6				   S6Z
      0  32b6					      ENDIO		; release task io completed
      0  32b6					      db	71
      1  32b6		       47		      .byte.b	71
      0  32b7					      NXT	CO	; exit here if , or ; at end of print
      0  32b7					      db	6
      1  32b7		       06		      .byte.b	6
      0  32b8					      dw	CO
      1  32b8		       07 32		      .word.w	CO
      0  32ba					      IJMP	STMT
      0  32ba					      db	29
      1  32ba		       1d		      .byte.b	29
      0  32bb					      dw	STMT
      1  32bb		       0f 32		      .word.w	STMT
    272  32bd							;
    273  32bd							; A jump for code too far away for relative branch
    274  32bd							;
    275  32bd				   ERRVEC
      0  32bd					      IJMP	UNKNOWN
      0  32bd					      db	29
      1  32bd		       1d		      .byte.b	29
      0  32be					      dw	UNKNOWN
      1  32be		       24 34		      .word.w	UNKNOWN
    277  32c0							;
    278  32c0							; Get here if there is an expression to print
    279  32c0				   S7
      0  32c0					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  32c0					      db	101
      1  32c0		       65		      .byte.b	101
      0  32c1					      db	(S7AUnsigned-*)-1
      1  32c1		       08		      .byte.b	(S7AUnsigned-*)-1
      0  32c2					      db	oDollar
      1  32c2		       e7		      .byte.b	oDollar
      0  32c3					      CALL	EXPR
      0  32c3					      db	28
      1  32c3		       1c		      .byte.b	28
      0  32c4					      dw	EXPR
      1  32c4		       28 34		      .word.w	EXPR
      0  32c6					      HEXPRT
      0  32c6					      db	67
      1  32c6		       43		      .byte.b	67
      0  32c7					      IJMP	S5
      0  32c7					      db	29
      1  32c7		       1d		      .byte.b	29
      0  32c8					      dw	S5
      1  32c8		       a3 32		      .word.w	S5
    284  32ca
    285  32ca				   S7AUnsigned
    286  32ca
      0  32ca					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  32ca					      db	101
      1  32ca		       65		      .byte.b	101
      0  32cb					      db	(S7A-*)-1
      1  32cb		       0a		      .byte.b	(S7A-*)-1
      0  32cc					      db	oPercent
      1  32cc		       ed		      .byte.b	oPercent
      0  32cd					      CALL	EXPR
      0  32cd					      db	28
      1  32cd		       1c		      .byte.b	28
      0  32ce					      dw	EXPR
      1  32ce		       28 34		      .word.w	EXPR
      0  32d0					      SETR2	tUint
      0  32d0					      db	94
      1  32d0		       5e		      .byte.b	94
      0  32d1					      db	tUint
      1  32d1		       a9		      .byte.b	tUint
      0  32d2					      PRN
      0  32d2					      db	3
      1  32d2		       03		      .byte.b	3
      0  32d3					      IJMP	S5
      0  32d3					      db	29
      1  32d3		       1d		      .byte.b	29
      0  32d4					      dw	S5
      1  32d4		       a3 32		      .word.w	S5
    292  32d6
    293  32d6				   S7A
    294  32d6
      0  32d6					      CALL	EXPR
      0  32d6					      db	28
      1  32d6		       1c		      .byte.b	28
      0  32d7					      dw	EXPR
      1  32d7		       28 34		      .word.w	EXPR
      0  32d9					      TSTB	S7B,oDollar	; Print the value as a single character
      0  32d9					      db	101
      1  32d9		       65		      .byte.b	101
      0  32da					      db	(S7B-*)-1
      1  32da		       05		      .byte.b	(S7B-*)-1
      0  32db					      db	oDollar
      1  32db		       e7		      .byte.b	oDollar
      0  32dc					      PUTCHAR
      0  32dc					      db	52
      1  32dc		       34		      .byte.b	52
      0  32dd					      IJMP	S5
      0  32dd					      db	29
      1  32dd		       1d		      .byte.b	29
      0  32de					      dw	S5
      1  32de		       a3 32		      .word.w	S5
    299  32e0
    300  32e0				   S7B
      0  32e0					      SETR2	tInteger	; Print the value as a signed number
      0  32e0					      db	94
      1  32e0		       5e		      .byte.b	94
      0  32e1					      db	tInteger
      1  32e1		       a4		      .byte.b	tInteger
      0  32e2					      PRN		; PRINT IT
      0  32e2					      db	3
      1  32e2		       03		      .byte.b	3
      0  32e3					      IJMP	S5	; IS THERE MORE?
      0  32e3					      db	29
      1  32e3		       1d		      .byte.b	29
      0  32e4					      dw	S5
      1  32e4		       a3 32		      .word.w	S5
    304  32e6							;
    305  32e6							;===========================================================
    306  32e6							; PROCESS ALL THE TASK STATEMENTS
    307  32e6							;
    308  32e6							;S8:
    309  32e6							;	  TSTB	      S8G,kTaske		 ; End Task
    310  32e6				   ekTaske
      0  32e6					      TSTB	S8NoParm,oLeftBracket
      0  32e6					      db	101
      1  32e6		       65		      .byte.b	101
      0  32e7					      db	(S8NoParm-*)-1
      1  32e7		       0c		      .byte.b	(S8NoParm-*)-1
      0  32e8					      db	oLeftBracket
      1  32e8		       e0		      .byte.b	oLeftBracket
      0  32e9					      CALL	EXPR
      0  32e9					      db	28
      1  32e9		       1c		      .byte.b	28
      0  32ea					      dw	EXPR
      1  32ea		       28 34		      .word.w	EXPR
      0  32ec					      TSTB	UNKNOWNLnk,oRightBracket
      0  32ec					      db	101
      1  32ec		       65		      .byte.b	101
      0  32ed					      db	(UNKNOWNLnk-*)-1
      1  32ed		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  32ee					      db	oRightBracket
      1  32ee		       e1		      .byte.b	oRightBracket
      0  32ef					      ETASK
      0  32ef					      db	62
      1  32ef		       3e		      .byte.b	62
      0  32f0					      DONE
      0  32f0					      db	1
      1  32f0		       01		      .byte.b	1
      0  32f1					      IJMP	STMT
      0  32f1					      db	29
      1  32f1		       1d		      .byte.b	29
      0  32f2					      dw	STMT
      1  32f2		       0f 32		      .word.w	STMT
    317  32f4				   S8NoParm
      0  32f4					      LIT	0
      0  32f4					      db	27
      1  32f4		       1b		      .byte.b	27
      0  32f5					      dw	0
      1  32f5		       00 00		      .word.w	0
      0  32f7					      ETASK
      0  32f7					      db	62
      1  32f7		       3e		      .byte.b	62
      0  32f8					      DONE		; Must be last thing on a line
      0  32f8					      db	1
      1  32f8		       01		      .byte.b	1
      0  32f9					      IJMP	STMT
      0  32f9					      db	29
      1  32f9		       1d		      .byte.b	29
      0  32fa					      dw	STMT
      1  32fa		       0f 32		      .word.w	STMT
    322  32fc							;
    323  32fc							;===========================================================
    324  32fc							; The task gives up the rest of the cycles
    325  32fc							;S8G:
    326  32fc							;	  TSTB	      S8a,kTaskn	 ;Next task
    327  32fc				   ekTaskn
      0  32fc					      NTASK
      0  32fc					      db	63
      1  32fc		       3f		      .byte.b	63
      0  32fd					      NXT	CO	;Next statement to execute
      0  32fd					      db	6
      1  32fd		       06		      .byte.b	6
      0  32fe					      dw	CO
      1  32fe		       07 32		      .word.w	CO
      0  3300					      IJMP	STMT
      0  3300					      db	29
      1  3300		       1d		      .byte.b	29
      0  3301					      dw	STMT
      1  3301		       0f 32		      .word.w	STMT
    331  3303							;
    332  3303							;===========================================================
    333  3303							; Waits for a task or list of tasks to complete
    334  3303
    335  3303				   ekTaskw
      0  3303					      TSTB	UNKNOWNLnk,oLeftBracket
      0  3303					      db	101
      1  3303		       65		      .byte.b	101
      0  3304					      db	(UNKNOWNLnk-*)-1
      1  3304		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  3305					      db	oLeftBracket
      1  3305		       e0		      .byte.b	oLeftBracket
    337  3306				   S8TSK
      0  3306					      Call	EXPR	;Gets the PID of task to wait for
      0  3306					      db	28
      1  3306		       1c		      .byte.b	28
      0  3307					      dw	EXPR
      1  3307		       28 34		      .word.w	EXPR
    339  3309				   S8LOOP
      0  3309					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  3309					      db	76
      1  3309		       4c		      .byte.b	76
      0  330a					      db	(S8LOOP-*)-1
      1  330a		       fe		      .byte.b	(S8LOOP-*)-1
      0  330b					      TSTB	S8aa,oComma	;Checks for more tasks
      0  330b					      db	101
      1  330b		       65		      .byte.b	101
      0  330c					      db	(S8aa-*)-1
      1  330c		       04		      .byte.b	(S8aa-*)-1
      0  330d					      db	oComma
      1  330d		       e2		      .byte.b	oComma
      0  330e					      IJMP	S8TSK	;Go for the next task number
      0  330e					      db	29
      1  330e		       1d		      .byte.b	29
      0  330f					      dw	S8TSK
      1  330f		       06 33		      .word.w	S8TSK
    343  3311				   S8aa
      0  3311					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  3311					      db	101
      1  3311		       65		      .byte.b	101
      0  3312					      db	(UNKNOWNLnk-*)-1
      1  3312		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  3313					      db	oRightBracket
      1  3313		       e1		      .byte.b	oRightBracket
      0  3314					      DONE
      0  3314					      db	1
      1  3314		       01		      .byte.b	1
      0  3315					      NXT	CO
      0  3315					      db	6
      1  3315		       06		      .byte.b	6
      0  3316					      dw	CO
      1  3316		       07 32		      .word.w	CO
      0  3318					      IJMP	STMT	;Next Statement
      0  3318					      db	29
      1  3318		       1d		      .byte.b	29
      0  3319					      dw	STMT
      1  3319		       0f 32		      .word.w	STMT
    348  331b
    349  331b
    350  331b
    351  331b				   UNKNOWNLnk
      0  331b					      iJMP	UNKNOWN
      0  331b					      db	29
      1  331b		       1d		      .byte.b	29
      0  331c					      dw	UNKNOWN
      1  331c		       24 34		      .word.w	UNKNOWN
    353  331e
    354  331e							;
    355  331e							;===========================================================
    356  331e							; Update a memory location with a value
    357  331e							;  Use @[offset] to write a word value to memory
    358  331e							;
    359  331e							;S8a1:
    360  331e							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    361  331e				   ekPoke
      0  331e					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  331e					      db	101
      1  331e		       65		      .byte.b	101
      0  331f					      db	(UNKNOWNV-*)-1
      1  331f		       a1		      .byte.b	(UNKNOWNV-*)-1
      0  3320					      db	oLeftBracket
      1  3320		       e0		      .byte.b	oLeftBracket
      0  3321					      CALL	EXPR	; Get address to write to
      0  3321					      db	28
      1  3321		       1c		      .byte.b	28
      0  3322					      dw	EXPR
      1  3322		       28 34		      .word.w	EXPR
      0  3324					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  3324					      db	101
      1  3324		       65		      .byte.b	101
      0  3325					      db	(UNKNOWNV-*)-1
      1  3325		       9b		      .byte.b	(UNKNOWNV-*)-1
      0  3326					      db	oComma
      1  3326		       e2		      .byte.b	oComma
      0  3327					      CALL	EXPR	; Get the value to poke
      0  3327					      db	28
      1  3327		       1c		      .byte.b	28
      0  3328					      dw	EXPR
      1  3328		       28 34		      .word.w	EXPR
      0  332a					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  332a					      db	101
      1  332a		       65		      .byte.b	101
      0  332b					      db	(UNKNOWNV-*)-1
      1  332b		       95		      .byte.b	(UNKNOWNV-*)-1
      0  332c					      db	oRightBracket
      1  332c		       e1		      .byte.b	oRightBracket
      0  332d					      POKEMEM
      0  332d					      db	47
      1  332d		       2f		      .byte.b	47
      0  332e					      DONE
      0  332e					      db	1
      1  332e		       01		      .byte.b	1
      0  332f					      NXT	CO	;AND SEQUENCE TO NEXT
      0  332f					      db	6
      1  332f		       06		      .byte.b	6
      0  3330					      dw	CO
      1  3330		       07 32		      .word.w	CO
      0  3332					      IJMP	STMT
      0  3332					      db	29
      1  3332		       1d		      .byte.b	29
      0  3333					      dw	STMT
      1  3333		       0f 32		      .word.w	STMT
    371  3335							;
    372  3335							;================================================================
    373  3335							; Set a block of memory to a value word or byte
    374  3335							; SetMem(Value, Length, Destination)
    375  3335				   ekSetMemB
      0  3335					      CALL	ekSetMem
      0  3335					      db	28
      1  3335		       1c		      .byte.b	28
      0  3336					      dw	ekSetMem
      1  3336		       4d 33		      .word.w	ekSetMem
      0  3338					      SETBLOCK	tByte	; set value as byte
      0  3338					      db	110
      1  3338		       6e		      .byte.b	110
      0  3339					      db	tByte
      1  3339		       a2		      .byte.b	tByte
      0  333a					      DONE
      0  333a					      db	1
      1  333a		       01		      .byte.b	1
      0  333b					      NXT	CO
      0  333b					      db	6
      1  333b		       06		      .byte.b	6
      0  333c					      dw	CO
      1  333c		       07 32		      .word.w	CO
      0  333e					      IJMP	STMT
      0  333e					      db	29
      1  333e		       1d		      .byte.b	29
      0  333f					      dw	STMT
      1  333f		       0f 32		      .word.w	STMT
    381  3341
    382  3341				   ekSetMemW
      0  3341					      CALL	ekSetMem
      0  3341					      db	28
      1  3341		       1c		      .byte.b	28
      0  3342					      dw	ekSetMem
      1  3342		       4d 33		      .word.w	ekSetMem
      0  3344					      SETBLOCK	tInteger	; set value as byte
      0  3344					      db	110
      1  3344		       6e		      .byte.b	110
      0  3345					      db	tInteger
      1  3345		       a4		      .byte.b	tInteger
      0  3346					      DONE
      0  3346					      db	1
      1  3346		       01		      .byte.b	1
      0  3347					      NXT	CO
      0  3347					      db	6
      1  3347		       06		      .byte.b	6
      0  3348					      dw	CO
      1  3348		       07 32		      .word.w	CO
      0  334a					      IJMP	STMT
      0  334a					      db	29
      1  334a		       1d		      .byte.b	29
      0  334b					      dw	STMT
      1  334b		       0f 32		      .word.w	STMT
    388  334d
    389  334d				   ekSetMem
      0  334d					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  334d					      db	101
      1  334d		       65		      .byte.b	101
      0  334e					      db	(UNKNOWNV-*)-1
      1  334e		       72		      .byte.b	(UNKNOWNV-*)-1
      0  334f					      db	oLeftBracket
      1  334f		       e0		      .byte.b	oLeftBracket
      0  3350					      CALL	EXPR	; Value to set
      0  3350					      db	28
      1  3350		       1c		      .byte.b	28
      0  3351					      dw	EXPR
      1  3351		       28 34		      .word.w	EXPR
      0  3353					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3353					      db	101
      1  3353		       65		      .byte.b	101
      0  3354					      db	(UNKNOWNV-*)-1
      1  3354		       6c		      .byte.b	(UNKNOWNV-*)-1
      0  3355					      db	oComma
      1  3355		       e2		      .byte.b	oComma
      0  3356					      CALL	EXPR	; Get The Length
      0  3356					      db	28
      1  3356		       1c		      .byte.b	28
      0  3357					      dw	EXPR
      1  3357		       28 34		      .word.w	EXPR
      0  3359					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3359					      db	101
      1  3359		       65		      .byte.b	101
      0  335a					      db	(UNKNOWNV-*)-1
      1  335a		       66		      .byte.b	(UNKNOWNV-*)-1
      0  335b					      db	oComma
      1  335b		       e2		      .byte.b	oComma
      0  335c					      CALL	EXPR	; GET the address to start at
      0  335c					      db	28
      1  335c		       1c		      .byte.b	28
      0  335d					      dw	EXPR
      1  335d		       28 34		      .word.w	EXPR
      0  335f					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  335f					      db	101
      1  335f		       65		      .byte.b	101
      0  3360					      db	(UNKNOWNV-*)-1
      1  3360		       60		      .byte.b	(UNKNOWNV-*)-1
      0  3361					      db	oRightBracket
      1  3361		       e1		      .byte.b	oRightBracket
      0  3362					      RTN
      0  3362					      db	25
      1  3362		       19		      .byte.b	25
    398  3363							;
    399  3363							;================================================================
    400  3363							; Copy a block of memory
    401  3363							; CopyMem(Length, Destination, Source)
    402  3363				   ekCopyMem
      0  3363					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3363					      db	101
      1  3363		       65		      .byte.b	101
      0  3364					      db	(UNKNOWNV-*)-1
      1  3364		       5c		      .byte.b	(UNKNOWNV-*)-1
      0  3365					      db	oLeftBracket
      1  3365		       e0		      .byte.b	oLeftBracket
      0  3366					      CALL	EXPR	; Length
      0  3366					      db	28
      1  3366		       1c		      .byte.b	28
      0  3367					      dw	EXPR
      1  3367		       28 34		      .word.w	EXPR
      0  3369					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3369					      db	101
      1  3369		       65		      .byte.b	101
      0  336a					      db	(UNKNOWNV-*)-1
      1  336a		       56		      .byte.b	(UNKNOWNV-*)-1
      0  336b					      db	oComma
      1  336b		       e2		      .byte.b	oComma
      0  336c					      CALL	EXPR	; Destination
      0  336c					      db	28
      1  336c		       1c		      .byte.b	28
      0  336d					      dw	EXPR
      1  336d		       28 34		      .word.w	EXPR
      0  336f					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  336f					      db	101
      1  336f		       65		      .byte.b	101
      0  3370					      db	(UNKNOWNV-*)-1
      1  3370		       50		      .byte.b	(UNKNOWNV-*)-1
      0  3371					      db	oComma
      1  3371		       e2		      .byte.b	oComma
      0  3372					      CALL	EXPR	; Source
      0  3372					      db	28
      1  3372		       1c		      .byte.b	28
      0  3373					      dw	EXPR
      1  3373		       28 34		      .word.w	EXPR
      0  3375					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3375					      db	101
      1  3375		       65		      .byte.b	101
      0  3376					      db	(UNKNOWNV-*)-1
      1  3376		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  3377					      db	oRightBracket
      1  3377		       e1		      .byte.b	oRightBracket
      0  3378					      COPYBLOCK		; Copy the memory
      0  3378					      db	111
      1  3378		       6f		      .byte.b	111
      0  3379					      DONE
      0  3379					      db	1
      1  3379		       01		      .byte.b	1
      0  337a					      NXT	CO
      0  337a					      db	6
      1  337a		       06		      .byte.b	6
      0  337b					      dw	CO
      1  337b		       07 32		      .word.w	CO
      0  337d					      IJMP	STMT
      0  337d					      db	29
      1  337d		       1d		      .byte.b	29
      0  337e					      dw	STMT
      1  337e		       0f 32		      .word.w	STMT
    414  3380
    415  3380							;================================================================
    416  3380							; Write a single byte to the output device
    417  3380							;
    418  3380				   ekPutch
      0  3380					      CALL	EXPR
      0  3380					      db	28
      1  3380		       1c		      .byte.b	28
      0  3381					      dw	EXPR
      1  3381		       28 34		      .word.w	EXPR
      0  3383					      PUTCHAR
      0  3383					      db	52
      1  3383		       34		      .byte.b	52
      0  3384					      DONE
      0  3384					      db	1
      1  3384		       01		      .byte.b	1
      0  3385					      NXT	CO	;AND SEQUENCE TO NEXT
      0  3385					      db	6
      1  3385		       06		      .byte.b	6
      0  3386					      dw	CO
      1  3386		       07 32		      .word.w	CO
      0  3388					      IJMP	STMT
      0  3388					      db	29
      1  3388		       1d		      .byte.b	29
      0  3389					      dw	STMT
      1  3389		       0f 32		      .word.w	STMT
    424  338b							;================================================================
    425  338b							; Clear the screen lines
    426  338b							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    427  338b							;
    428  338b				   ekCls
      0  338b					      CLEARSCREEN
      0  338b					      db	46
      1  338b		       2e		      .byte.b	46
      0  338c					      NXT	CO	;AND SEQUENCE TO NEXT
      0  338c					      db	6
      1  338c		       06		      .byte.b	6
      0  338d					      dw	CO
      1  338d		       07 32		      .word.w	CO
      0  338f					      IJMP	STMT
      0  338f					      db	29
      1  338f		       1d		      .byte.b	29
      0  3390					      dw	STMT
      1  3390		       0f 32		      .word.w	STMT
    432  3392							;==================================================================
    433  3392							; Get input from the terminal
    434  3392							;   Reads from the currently active input device
    435  3392							;
    436  3392				   ekInput
    437  3392				   S10
      0  3392					      TSTB	S10A,tString	;If there is a string print the prompt
      0  3392					      db	101
      1  3392		       65		      .byte.b	101
      0  3393					      db	(S10A-*)-1
      1  3393		       05		      .byte.b	(S10A-*)-1
      0  3394					      db	tString
      1  3394		       a0		      .byte.b	tString
      0  3395					      PRS
      0  3395					      db	2
      1  3395		       02		      .byte.b	2
      0  3396					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  3396					      db	101
      1  3396		       65		      .byte.b	101
      0  3397					      db	(S10Z-*)-1
      1  3397		       1e		      .byte.b	(S10Z-*)-1
      0  3398					      db	oSemiColon
      1  3398		       e3		      .byte.b	oSemiColon
    441  3399				   S10A
      0  3399					      TSTB	InNoString,oDollar	; Check if we are reading characters
      0  3399					      db	101
      1  3399		       65		      .byte.b	101
      0  339a					      db	(InNoString-*)-1
      1  339a		       0c		      .byte.b	(InNoString-*)-1
      0  339b					      db	oDollar
      1  339b		       e7		      .byte.b	oDollar
      0  339c					      TSTV	UNKNOWN
      0  339c					      db	33
      1  339c		       21		      .byte.b	33
      0  339d					      db	(UNKNOWN-*)-1
      1  339d		       86		      .byte.b	(UNKNOWN-*)-1
      0  339e					      CALL	FactVarPtrNoTst
      0  339e					      db	28
      1  339e		       1c		      .byte.b	28
      0  339f					      dw	FactVarPtrNoTst
      1  339f		       d8 35		      .word.w	FactVarPtrNoTst
      0  33a1					      INSTR		;Move character From tty to AESTK
      0  33a1					      db	59
      1  33a1		       3b		      .byte.b	59
      0  33a2					      SETR2	tByte
      0  33a2					      db	94
      1  33a2		       5e		      .byte.b	94
      0  33a3					      db	tByte
      1  33a3		       a2		      .byte.b	tByte
      0  33a4					      IJMP	S10A2
      0  33a4					      db	29
      1  33a4		       1d		      .byte.b	29
      0  33a5					      dw	S10A2
      1  33a5		       af 33		      .word.w	S10A2
    448  33a7
    449  33a7				   InNoString
      0  33a7					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  33a7					      db	33
      1  33a7		       21		      .byte.b	33
      0  33a8					      db	(UNKNOWN-*)-1
      1  33a8		       7b		      .byte.b	(UNKNOWN-*)-1
      0  33a9					      CALL	FactVarPtrNoTst
      0  33a9					      db	28
      1  33a9		       1c		      .byte.b	28
      0  33aa					      dw	FactVarPtrNoTst
      1  33aa		       d8 35		      .word.w	FactVarPtrNoTst
      0  33ac					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  33ac					      db	11
      1  33ac		       0b		      .byte.b	11
      0  33ad					      SETR2	tInteger
      0  33ad					      db	94
      1  33ad		       5e		      .byte.b	94
      0  33ae					      db	tInteger
      1  33ae		       a4		      .byte.b	tInteger
    454  33af
    455  33af				   S10A2
      0  33af					      STORE		;STORE IT
      0  33af					      db	19
      1  33af		       13		      .byte.b	19
      0  33b0					      TSTB	S11,oComma	;IS THERE MORE?
      0  33b0					      db	101
      1  33b0		       65		      .byte.b	101
      0  33b1					      db	(S11-*)-1
      1  33b1		       07		      .byte.b	(S11-*)-1
      0  33b2					      db	oComma
      1  33b2		       e2		      .byte.b	oComma
      0  33b3					      IJMP	S10	;YES
      0  33b3					      db	29
      1  33b3		       1d		      .byte.b	29
      0  33b4					      dw	S10
      1  33b4		       92 33		      .word.w	S10
    459  33b6				   S10Z
      0  33b6					      iJMP	UNKNOWN
      0  33b6					      db	29
      1  33b6		       1d		      .byte.b	29
      0  33b7					      dw	UNKNOWN
      1  33b7		       24 34		      .word.w	UNKNOWN
    461  33b9				   S11
      0  33b9					      DONE		;MUST BE CR
      0  33b9					      db	1
      1  33b9		       01		      .byte.b	1
      0  33ba					      NXT	CO	;SEQUENCE TO NEXT
      0  33ba					      db	6
      1  33ba		       06		      .byte.b	6
      0  33bb					      dw	CO
      1  33bb		       07 32		      .word.w	CO
      0  33bd					      IJMP	STMT
      0  33bd					      db	29
      1  33bd		       1d		      .byte.b	29
      0  33be					      dw	STMT
      1  33be		       0f 32		      .word.w	STMT
    465  33c0							;=====================================================================
    466  33c0							; End of program, return to command line process
    467  33c0							; Main Task may also use taske or return to stopped
    468  33c0							;
    469  33c0				   ekEnd
      0  33c0					      FIN
      0  33c0					      db	12
      1  33c0		       0c		      .byte.b	12
    471  33c1				   UNKNOWNV
      0  33c1					      IJMP	UNKNOWN
      0  33c1					      db	29
      1  33c1		       1d		      .byte.b	29
      0  33c2					      dw	UNKNOWN
      1  33c2		       24 34		      .word.w	UNKNOWN
    473  33c4							;====================================================================
    474  33c4							; IRQ <IRQ-HANDLER-Line expression>
    475  33c4							;   Specify a line number subroutine to call when an interupt is processed
    476  33c4							;   These subroutines must use iret to return.
    477  33c4							;
    478  33c4				   ekIrq
      0  33c4					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  33c4					      db	28
      1  33c4		       1c		      .byte.b	28
      0  33c5					      dw	EXPR
      1  33c5		       28 34		      .word.w	EXPR
      0  33c7					      DONE		;must be CR
      0  33c7					      db	1
      1  33c7		       01		      .byte.b	1
      0  33c8					      SETIRQ		;Set the line number now
      0  33c8					      db	56
      1  33c8		       38		      .byte.b	56
      0  33c9					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  33c9					      db	6
      1  33c9		       06		      .byte.b	6
      0  33ca					      dw	CO
      1  33ca		       07 32		      .word.w	CO
      0  33cc					      IJMP	STMT
      0  33cc					      db	29
      1  33cc		       1d		      .byte.b	29
      0  33cd					      dw	STMT
      1  33cd		       0f 32		      .word.w	STMT
    484  33cf
    485  33cf							;=========================================================================
    486  33cf							; KILL PID-expression	 kill a running task
    487  33cf							;  ignored of task has already stopped
    488  33cf							;
    489  33cf				   ekKill
      0  33cf					      CALL	EXPR
      0  33cf					      db	28
      1  33cf		       1c		      .byte.b	28
      0  33d0					      dw	EXPR
      1  33d0		       28 34		      .word.w	EXPR
      0  33d2					      DONE
      0  33d2					      db	1
      1  33d2		       01		      .byte.b	1
      0  33d3					      TASKKILL
      0  33d3					      db	65
      1  33d3		       41		      .byte.b	65
      0  33d4					      NXT	CO
      0  33d4					      db	6
      1  33d4		       06		      .byte.b	6
      0  33d5					      dw	CO
      1  33d5		       07 32		      .word.w	CO
      0  33d7					      IJMP	STMT
      0  33d7					      db	29
      1  33d7		       1d		      .byte.b	29
      0  33d8					      dw	STMT
      1  33d8		       0f 32		      .word.w	STMT
    495  33da
    496  33da							;============================================================================
    497  33da							; List all program lines
    498  33da							;
    499  33da				   ekList
      0  33da					      DONE
      0  33da					      db	1
      1  33da		       01		      .byte.b	1
      0  33db					      LST
      0  33db					      db	21
      1  33db		       15		      .byte.b	21
      0  33dc					      IJMP	CO
      0  33dc					      db	29
      1  33dc		       1d		      .byte.b	29
      0  33dd					      dw	CO
      1  33dd		       07 32		      .word.w	CO
    503  33df							;=======================================================================
    504  33df							;RUN begin to executed the program in memory
    505  33df							;
    506  33df				   ekRun
      0  33df					      DONE
      0  33df					      db	1
      1  33df		       01		      .byte.b	1
      0  33e0					      VINIT		;clear variables compile the line numbers
      0  33e0					      db	30
      1  33e0		       1e		      .byte.b	30
      0  33e1					      LIT	1	;GOTO line 1
      0  33e1					      db	27
      1  33e1		       1b		      .byte.b	27
      0  33e2					      dw	1
      1  33e2		       01 00		      .word.w	1
      0  33e4					      XFER		;Bob's addition
      0  33e4					      db	7
      1  33e4		       07		      .byte.b	7
    511  33e5							; EXIT
      0  33e5					      IJMP	STMT	;and run!
      0  33e5					      db	29
      1  33e5		       1d		      .byte.b	29
      0  33e6					      dw	STMT
      1  33e6		       0f 32		      .word.w	STMT
    513  33e8							;=========================================================================
    514  33e8							;Clear the program memory, delete all proram lines
    515  33e8							;
    516  33e8				   ekNew
      0  33e8					      DONE
      0  33e8					      db	1
      1  33e8		       01		      .byte.b	1
      0  33e9					      IJMP	START
      0  33e9					      db	29
      1  33e9		       1d		      .byte.b	29
      0  33ea					      dw	START
      1  33ea		       01 32		      .word.w	START
    519  33ec
    520  33ec							;========================================================================
    521  33ec							; Slice(slice legth expression)
    522  33ec							;   set the length of time between task switches
    523  33ec							;
    524  33ec				   ekSlice
      0  33ec					      CALL	EXPR
      0  33ec					      db	28
      1  33ec		       1c		      .byte.b	28
      0  33ed					      dw	EXPR
      1  33ed		       28 34		      .word.w	EXPR
      0  33ef					      SLICE
      0  33ef					      db	100
      1  33ef		       64		      .byte.b	100
      0  33f0					      DONE
      0  33f0					      db	1
      1  33f0		       01		      .byte.b	1
      0  33f1					      NXT	CO
      0  33f1					      db	6
      1  33f1		       06		      .byte.b	6
      0  33f2					      dw	CO
      1  33f2		       07 32		      .word.w	CO
      0  33f4					      IJMP	STMT
      0  33f4					      db	29
      1  33f4		       1d		      .byte.b	29
      0  33f5					      dw	STMT
      1  33f5		       0f 32		      .word.w	STMT
    530  33f7							;==========================================================================
    531  33f7							; Turn off and on the thrace functions
    532  33f7							; a debug terminal needs to be available
    533  33f7							; Trace( Trace flag expression)
    534  33f7							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    535  33f7							;	for individual lines of basic code. These can be combined
    536  33f7				   ekTrace
      0  33f7					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  33f7					      db	101
      1  33f7		       65		      .byte.b	101
      0  33f8					      db	(UNKNOWN-*)-1
      1  33f8		       2b		      .byte.b	(UNKNOWN-*)-1
      0  33f9					      db	oLeftBracket
      1  33f9		       e0		      .byte.b	oLeftBracket
      0  33fa					      CALL	EXPR
      0  33fa					      db	28
      1  33fa		       1c		      .byte.b	28
      0  33fb					      dw	EXPR
      1  33fb		       28 34		      .word.w	EXPR
      0  33fd					      TSTB	UNKNOWN,oRightBracket
      0  33fd					      db	101
      1  33fd		       65		      .byte.b	101
      0  33fe					      db	(UNKNOWN-*)-1
      1  33fe		       25		      .byte.b	(UNKNOWN-*)-1
      0  33ff					      db	oRightBracket
      1  33ff		       e1		      .byte.b	oRightBracket
      0  3400					      TRACEPROGRAM
      0  3400					      db	78
      1  3400		       4e		      .byte.b	78
      0  3401					      DONE
      0  3401					      db	1
      1  3401		       01		      .byte.b	1
      0  3402					      NXT	CO
      0  3402					      db	6
      1  3402		       06		      .byte.b	6
      0  3403					      dw	CO
      1  3403		       07 32		      .word.w	CO
      0  3405					      IJMP	STMT
      0  3405					      db	29
      1  3405		       1d		      .byte.b	29
      0  3406					      dw	STMT
      1  3406		       0f 32		      .word.w	STMT
    544  3408							;=====================================================================
    545  3408							; Exit basic to machine monitor
    546  3408							;
    547  3408				   ekExit
      0  3408					      EXIT
      0  3408					      db	26
      1  3408		       1a		      .byte.b	26
    549  3409
    550  3409							;=======================================================================
    551  3409							; Commands related to saving/restoring programs
    552  3409							; to/from mass storage.
    553  3409							;=======================================================================
    554  3409							; Save a program file
    555  3409							;
    556  3409					      if	(XKIM || CTMON65) && DISK_ACCESS
    557  3409
    558  3409				   ekSave
      0  3409					      OPENWRITE	OPEN_CREATE
      0  3409					      db	40
      1  3409		       28		      .byte.b	40
      0  340a					      db	OPEN_CREATE
      1  340a		       01		      .byte.b	OPEN_CREATE
      0  340b					      DLIST
      0  340b					      db	43
      1  340b		       2b		      .byte.b	43
      0  340c					      DCLOSE
      0  340c					      db	41
      1  340c		       29		      .byte.b	41
      0  340d					      IJMP	CO
      0  340d					      db	29
      1  340d		       1d		      .byte.b	29
      0  340e					      dw	CO
      1  340e		       07 32		      .word.w	CO
    563  3410							;=========================================================================
    564  3410							; Load a program file
    565  3410							;
    566  3410				   ekLoad
      0  3410					      OPENREAD
      0  3410					      db	39
      1  3410		       27		      .byte.b	39
    568  3411				   S17CLP
      0  3411					      DGETLINE		;get line from file
      0  3411					      db	42
      1  3411		       2a		      .byte.b	42
      0  3412					      TSTL	S17EOL	;no line num means EOL
      0  3412					      db	34
      1  3412		       22		      .byte.b	34
      0  3413					      db	(S17EOL-*)-1
      1  3413		       04		      .byte.b	(S17EOL-*)-1
      0  3414					      INSERT		;put it into the program
      0  3414					      db	24
      1  3414		       18		      .byte.b	24
      0  3415					      IJMP	S17CLP	;keep going
      0  3415					      db	29
      1  3415		       1d		      .byte.b	29
      0  3416					      dw	S17CLP
      1  3416		       11 34		      .word.w	S17CLP
    573  3418				   S17EOL
      0  3418					      DCLOSE		;close disk file
      0  3418					      db	41
      1  3418		       29		      .byte.b	41
      0  3419					      IJMP	CO	;back to start
      0  3419					      db	29
      1  3419		       1d		      .byte.b	29
      0  341a					      dw	CO
      1  341a		       07 32		      .word.w	CO
    576  341c							;=========================================================================
    577  341c							; Display the directory content
    578  341c							;
    579  341c				   ekDir
      0  341c					      DDIR		;Display the directory content
      0  341c					      db	44
      1  341c		       2c		      .byte.b	44
      0  341d					      IJMP	CO
      0  341d					      db	29
      1  341d		       1d		      .byte.b	29
      0  341e					      dw	CO
      1  341e		       07 32		      .word.w	CO
    582  3420							;=========================================================================
    583  3420							; Erase a file from disk
    584  3420							;
    585  3420				   ekErase
      0  3420					      RMFILE		;Erase the file from the disk
      0  3420					      db	45
      1  3420		       2d		      .byte.b	45
      0  3421					      IJMP	CO
      0  3421					      db	29
      1  3421		       1d		      .byte.b	29
      0  3422					      dw	CO
      1  3422		       07 32		      .word.w	CO
    588  3424
    589  3424					      endif
    590  3424
    591  3424							;===========================================================================
    592  3424							; Else, unknown command.
    593  3424							;
    594  3424				   UNKNOWN
      0  3424					      ENDIO
      0  3424					      db	71
      1  3424		       47		      .byte.b	71
    596  3425
    597  3425				   NotKnownStatement
    598  3425
      0  3425					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  3425					      db	13
      1  3425		       0d		      .byte.b	13
      0  3426					      dw	ERR_SYNTAX
      1  3426		       05 00		      .word.w	ERR_SYNTAX
    600  3428
    601  3428							;=======================================================
    602  3428							; Process Expresions, precidence is represented by the
    603  3428							; various call levels
    604  3428							;
    605  3428				   EXPR
      0  3428					      TSTB	EXPRLOGS,kNot
      0  3428					      db	101
      1  3428		       65		      .byte.b	101
      0  3429					      db	(EXPRLOGS-*)-1
      1  3429		       06		      .byte.b	(EXPRLOGS-*)-1
      0  342a					      db	kNot
      1  342a		       24		      .byte.b	kNot
    607  342b				   ekNot
      0  342b					      Call	EXPR
      0  342b					      db	28
      1  342b		       1c		      .byte.b	28
      0  342c					      dw	EXPR
      1  342c		       28 34		      .word.w	EXPR
      0  342e					      LOGNOT
      0  342e					      db	72
      1  342e		       48		      .byte.b	72
      0  342f					      RTN
      0  342f					      db	25
      1  342f		       19		      .byte.b	25
    611  3430
    612  3430							;=========================================================
    613  3430							;Look for logical operators, but does get first part of expression
    614  3430				   EXPRLOGS
      0  3430					      Call	EXPR2	; get the left first expression
      0  3430					      db	28
      1  3430		       1c		      .byte.b	28
      0  3431					      dw	EXPR2
      1  3431		       5f 34		      .word.w	EXPR2
      0  3433					      TSTRELOP	EXPSHIFT	; Exit level if no rel ops found
      0  3433					      db	104
      1  3433		       68		      .byte.b	104
      0  3434					      db	(EXPSHIFT-*)-1
      1  3434		       05		      .byte.b	(EXPSHIFT-*)-1
    617  3435							;	  TSTB	     iR0,oEqual
    618  3435							;	  LIT	     2		     ;=
    619  3435							;	  IJMP	     iRFound
    620  3435							;iR0:
    621  3435							;	  TSTB	      iR1,oLessEqual
    622  3435							;	  LIT	      3 	      ;<=
    623  3435							;	  IJMP	     iRFound
    624  3435							;iR1:
    625  3435							;	  TSTB	     iR3,oNotEqual
    626  3435							;	  LIT	     5		      ;<>
    627  3435							;	      IJMP	  iRFound
    628  3435							;iR3:
    629  3435							;	  TSTB	     iR4,oLess
    630  3435							;	  LIT	     1		     ;<
    631  3435							;	      IJMP	  iRFound
    632  3435							;iR4:
    633  3435							;	  TST	     iR5,oGreaterEqual
    634  3435							;	  LIT	     6		     ;>=
    635  3435							;	      IJMP	  iRFound
    636  3435							;iR5:
    637  3435							;	  TSTB	     iRDone,oGreater
    638  3435							;	  LIT	     4		     ;>
    639  3435				   iRFound
      0  3435					      Call	EXPR2	; EXPR; get the right side of the expression
      0  3435					      db	28
      1  3435		       1c		      .byte.b	28
      0  3436					      dw	EXPR2
      1  3436		       5f 34		      .word.w	EXPR2
      0  3438					      CMPR		; Push the value of the true false onto the stack
      0  3438					      db	10
      1  3438		       0a		      .byte.b	10
      0  3439					      RTN
      0  3439					      db	25
      1  3439		       19		      .byte.b	25
    643  343a
    644  343a							;=========================================================
    645  343a							;Look for shift left and shift right level
    646  343a				   EXPSHIFT
      0  343a					      OnGoto	BasicShift,EXPRLOGICAL
      0  343a					      db	103
      1  343a		       67		      .byte.b	103
      0  343b					      dw	BasicShift
      1  343b		       d5 31		      .word.w	BasicShift
      0  343d					      dw	EXPRLOGICAL
      1  343d		       4b 34		      .word.w	EXPRLOGICAL
    648  343f
    649  343f				   ekShiftLeft
      0  343f					      Call	EXPR
      0  343f					      db	28
      1  343f		       1c		      .byte.b	28
      0  3440					      dw	EXPR
      1  3440		       28 34		      .word.w	EXPR
      0  3442					      SHIFT	0
      0  3442					      db	113
      1  3442		       71		      .byte.b	113
      0  3443					      db	0
      1  3443		       00		      .byte.b	0
      0  3444					      RTN
      0  3444					      db	25
      1  3444		       19		      .byte.b	25
    653  3445
    654  3445				   ekShiftRight
      0  3445					      Call	EXPR
      0  3445					      db	28
      1  3445		       1c		      .byte.b	28
      0  3446					      dw	EXPR
      1  3446		       28 34		      .word.w	EXPR
      0  3448					      SHIFT	1
      0  3448					      db	113
      1  3448		       71		      .byte.b	113
      0  3449					      db	1
      1  3449		       01		      .byte.b	1
      0  344a					      RTN
      0  344a					      db	25
      1  344a		       19		      .byte.b	25
    658  344b
    659  344b							;======================================================================
    660  344b				   EXPRLOGICAL
      0  344b					      OnGoto	BasicLogical,iLOGExit
      0  344b					      db	103
      1  344b		       67		      .byte.b	103
      0  344c					      dw	BasicLogical
      1  344c		       cd 31		      .word.w	BasicLogical
      0  344e					      dw	iLOGExit
      1  344e		       5e 34		      .word.w	iLOGExit
    662  3450				   ekAnd
      0  3450					      Call	EXPR
      0  3450					      db	28
      1  3450		       1c		      .byte.b	28
      0  3451					      dw	EXPR
      1  3451		       28 34		      .word.w	EXPR
      0  3453					      LOGAND
      0  3453					      db	74
      1  3453		       4a		      .byte.b	74
      0  3454					      RTN
      0  3454					      db	25
      1  3454		       19		      .byte.b	25
    666  3455				   ekOr
      0  3455					      Call	EXPR
      0  3455					      db	28
      1  3455		       1c		      .byte.b	28
      0  3456					      dw	EXPR
      1  3456		       28 34		      .word.w	EXPR
      0  3458					      LOGOR
      0  3458					      db	73
      1  3458		       49		      .byte.b	73
      0  3459					      RTN
      0  3459					      db	25
      1  3459		       19		      .byte.b	25
    670  345a				   ekXor
      0  345a					      Call	EXPR
      0  345a					      db	28
      1  345a		       1c		      .byte.b	28
      0  345b					      dw	EXPR
      1  345b		       28 34		      .word.w	EXPR
      0  345d					      LOGXOR
      0  345d					      db	75
      1  345d		       4b		      .byte.b	75
    673  345e				   iLOGExit
      0  345e					      RTN
      0  345e					      db	25
      1  345e		       19		      .byte.b	25
    675  345f
    676  345f							; get the right part of an expression
    677  345f				   EXPR2
      0  345f					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  345f					      db	101
      1  345f		       65		      .byte.b	101
      0  3460					      db	(E0-*)-1
      1  3460		       08		      .byte.b	(E0-*)-1
      0  3461					      db	oMinus
      1  3461		       eb		      .byte.b	oMinus
      0  3462					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  3462					      db	28
      1  3462		       1c		      .byte.b	28
      0  3463					      dw	TERM
      1  3463		       85 34		      .word.w	TERM
      0  3465					      NEG		; Make value negated
      0  3465					      db	16
      1  3465		       10		      .byte.b	16
      0  3466					      IJMP	E1	; We have Left term process operators next
      0  3466					      db	29
      1  3466		       1d		      .byte.b	29
      0  3467					      dw	E1
      1  3467		       6f 34		      .word.w	E1
    682  3469				   E0
      0  3469					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  3469					      db	101
      1  3469		       65		      .byte.b	101
      0  346a					      db	(E1A-*)-1
      1  346a		       01		      .byte.b	(E1A-*)-1
      0  346b					      db	oPlus
      1  346b		       ea		      .byte.b	oPlus
    684  346c				   E1A
      0  346c					      CALL	TERM	; Get the left term if it was not negated
      0  346c					      db	28
      1  346c		       1c		      .byte.b	28
      0  346d					      dw	TERM
      1  346d		       85 34		      .word.w	TERM
    686  346f				   E1
      0  346f					      TST	E2,oPlus	; Check if we are adding left term to something
      0  346f					      db	32
      1  346f		       20		      .byte.b	32
      0  3470					      db	(E2-*)-1
      1  3470		       09		      .byte.b	(E2-*)-1
      0  3471					      db	oPlus,0
      1  3471		       ea 00		      .byte.b	oPlus,0
      0  3473					      CALL	TERM	; if adding then get the right side term
      0  3473					      db	28
      1  3473		       1c		      .byte.b	28
      0  3474					      dw	TERM
      1  3474		       85 34		      .word.w	TERM
      0  3476					      ADD		; Add it to left term
      0  3476					      db	14
      1  3476		       0e		      .byte.b	14
      0  3477					      IJMP	E1	; look for next + or -
      0  3477					      db	29
      1  3477		       1d		      .byte.b	29
      0  3478					      dw	E1
      1  3478		       6f 34		      .word.w	E1
    691  347a				   E2
      0  347a					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  347a					      db	101
      1  347a		       65		      .byte.b	101
      0  347b					      db	(E3-*)-1
      1  347b		       08		      .byte.b	(E3-*)-1
      0  347c					      db	oMinus
      1  347c		       eb		      .byte.b	oMinus
      0  347d					      CALL	TERM	; get right side to subtract Diffrence
      0  347d					      db	28
      1  347d		       1c		      .byte.b	28
      0  347e					      dw	TERM
      1  347e		       85 34		      .word.w	TERM
      0  3480					      SUB		; Subtract the value
      0  3480					      db	15
      1  3480		       0f		      .byte.b	15
      0  3481					      IJMP	E1	; Look for next + or -
      0  3481					      db	29
      1  3481		       1d		      .byte.b	29
      0  3482					      dw	E1
      1  3482		       6f 34		      .word.w	E1
    696  3484				   E3			; Finish processing the expression
      0  3484					      RTN		; We are finished processing the Expression
      0  3484					      db	25
      1  3484		       19		      .byte.b	25
    698  3485							;
    699  3485							; Get one of the terms of an expression
    700  3485							;
    701  3485				   TERM
      0  3485					      CALL	FACT	; Get a value
      0  3485					      db	28
      1  3485		       1c		      .byte.b	28
      0  3486					      dw	FACT
      1  3486		       aa 34		      .word.w	FACT
    703  3488				   T0			; Check for higher precidence operators
      0  3488					      TSTB	T1,oMultiply	; Check for *
      0  3488					      db	101
      1  3488		       65		      .byte.b	101
      0  3489					      db	(T1-*)-1
      1  3489		       08		      .byte.b	(T1-*)-1
      0  348a					      db	oMultiply
      1  348a		       ee		      .byte.b	oMultiply
      0  348b					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  348b					      db	28
      1  348b		       1c		      .byte.b	28
      0  348c					      dw	FACT
      1  348c		       aa 34		      .word.w	FACT
      0  348e					      MUL		; Multiply factors
      0  348e					      db	17
      1  348e		       11		      .byte.b	17
      0  348f					      IJMP	T0	; Check for * or /
      0  348f					      db	29
      1  348f		       1d		      .byte.b	29
      0  3490					      dw	T0
      1  3490		       88 34		      .word.w	T0
    708  3492				   T1
      0  3492					      TSTB	T2,oDivide	; Check for a division
      0  3492					      db	101
      1  3492		       65		      .byte.b	101
      0  3493					      db	(T2-*)-1
      1  3493		       08		      .byte.b	(T2-*)-1
      0  3494					      db	oDivide
      1  3494		       ec		      .byte.b	oDivide
      0  3495					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  3495					      db	28
      1  3495		       1c		      .byte.b	28
      0  3496					      dw	FACT
      1  3496		       aa 34		      .word.w	FACT
      0  3498					      DIV		; do division
      0  3498					      db	18
      1  3498		       12		      .byte.b	18
      0  3499					      IJMP	T0	; check for more * or /
      0  3499					      db	29
      1  3499		       1d		      .byte.b	29
      0  349a					      dw	T0
      1  349a		       88 34		      .word.w	T0
    713  349c				   T2
      0  349c					      TSTB	T3,oModulo	; Check for a division
      0  349c					      db	101
      1  349c		       65		      .byte.b	101
      0  349d					      db	(T3-*)-1
      1  349d		       08		      .byte.b	(T3-*)-1
      0  349e					      db	oModulo
      1  349e		       ed		      .byte.b	oModulo
      0  349f					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  349f					      db	28
      1  349f		       1c		      .byte.b	28
      0  34a0					      dw	FACT
      1  34a0		       aa 34		      .word.w	FACT
      0  34a2					      MODULO		; do division for remainder
      0  34a2					      db	60
      1  34a2		       3c		      .byte.b	60
      0  34a3					      IJMP	T0	; check for more * or / or %
      0  34a3					      db	29
      1  34a3		       1d		      .byte.b	29
      0  34a4					      dw	T0
      1  34a4		       88 34		      .word.w	T0
    718  34a6				   T3			; Finish processing the Term
      0  34a6					      RTN
      0  34a6					      db	25
      1  34a6		       19		      .byte.b	25
    720  34a7
    721  34a7				   UNKNOWNVEC
      0  34a7					      IJMP	UNKNOWN
      0  34a7					      db	29
      1  34a7		       1d		      .byte.b	29
      0  34a8					      dw	UNKNOWN
      1  34a8		       24 34		      .word.w	UNKNOWN
    723  34aa
    724  34aa							;=============================================================================================
    725  34aa							; Factor an expression.  Always test for functions
    726  34aa							; first or else they'll be confused for variables.
    727  34aa							;
    728  34aa				   FACT
      0  34aa					      OnGoto	BasicFuncs,FactNumber
      0  34aa					      db	103
      1  34aa		       67		      .byte.b	103
      0  34ab					      dw	BasicFuncs
      1  34ab		       db 31		      .word.w	BasicFuncs
      0  34ad					      dw	FactNumber
      1  34ad		       aa 35		      .word.w	FactNumber
    730  34af
    731  34af							;FACTCONTINUE:
    732  34af							;	  TSTB	     F1AA,kTrue
    733  34af				   ekTrue
      0  34af					      LIT	-1
      0  34af					      db	27
      1  34af		       1b		      .byte.b	27
      0  34b0					      dw	-1
      1  34b0		       ff ff		      .word.w	-1
      0  34b2					      RTN
      0  34b2					      db	25
      1  34b2		       19		      .byte.b	25
    736  34b3							;F1AA:
    737  34b3							;	  TSTB	     F1AB,kFalse
    738  34b3				   ekFalse
      0  34b3					      LIT	0
      0  34b3					      db	27
      1  34b3		       1b		      .byte.b	27
      0  34b4					      dw	0
      1  34b4		       00 00		      .word.w	0
      0  34b6					      RTN
      0  34b6					      db	25
      1  34b6		       19		      .byte.b	25
    741  34b7							;==================================================================================
    742  34b7							; Returns the amount of free SPACE
    743  34b7				   ekFree
      0  34b7					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34b7					      db	101
      1  34b7		       65		      .byte.b	101
      0  34b8					      db	(UNKNOWNVEC-*)-1
      1  34b8		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  34b9					      db	oLeftBracket
      1  34b9		       e0		      .byte.b	oLeftBracket
      0  34ba					      TSTB	UNKNOWNVEC,oRightBracket
      0  34ba					      db	101
      1  34ba		       65		      .byte.b	101
      0  34bb					      db	(UNKNOWNVEC-*)-1
      1  34bb		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  34bc					      db	oRightBracket
      1  34bc		       e1		      .byte.b	oRightBracket
      0  34bd					      FREE
      0  34bd					      db	36
      1  34bd		       24		      .byte.b	36
      0  34be					      RTN
      0  34be					      db	25
      1  34be		       19		      .byte.b	25
    748  34bf							;===================================================================================
    749  34bf							; getch() read a character from the input device
    750  34bf							;
    751  34bf				   ekGetch
      0  34bf					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34bf					      db	101
      1  34bf		       65		      .byte.b	101
      0  34c0					      db	(UNKNOWNVEC-*)-1
      1  34c0		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  34c1					      db	oLeftBracket
      1  34c1		       e0		      .byte.b	oLeftBracket
      0  34c2					      TSTB	UNKNOWNVEC,oRightBracket
      0  34c2					      db	101
      1  34c2		       65		      .byte.b	101
      0  34c3					      db	(UNKNOWNVEC-*)-1
      1  34c3		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  34c4					      db	oRightBracket
      1  34c4		       e1		      .byte.b	oRightBracket
      0  34c5					      GETCHAR
      0  34c5					      db	51
      1  34c5		       33		      .byte.b	51
      0  34c6					      RTN
      0  34c6					      db	25
      1  34c6		       19		      .byte.b	25
    756  34c7							;
    757  34c7							;====================================================================================
    758  34c7							; addr(variable definition)
    759  34c7							; Returns the address of a variable on top of the stack
    760  34c7				   ekAddr
      0  34c7					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34c7					      db	101
      1  34c7		       65		      .byte.b	101
      0  34c8					      db	(UNKNOWNVEC-*)-1
      1  34c8		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  34c9					      db	oLeftBracket
      1  34c9		       e0		      .byte.b	oLeftBracket
      0  34ca					      TSTV	ExpectedVariable
      0  34ca					      db	33
      1  34ca		       21		      .byte.b	33
      0  34cb					      db	(ExpectedVariable-*)-1
      1  34cb		       07		      .byte.b	(ExpectedVariable-*)-1
      0  34cc					      CALL	FactVarPtrNoTst
      0  34cc					      db	28
      1  34cc		       1c		      .byte.b	28
      0  34cd					      dw	FactVarPtrNoTst
      1  34cd		       d8 35		      .word.w	FactVarPtrNoTst
      0  34cf					      TSTB	UNKNOWNVEC,oRightBracket
      0  34cf					      db	101
      1  34cf		       65		      .byte.b	101
      0  34d0					      db	(UNKNOWNVEC-*)-1
      1  34d0		       d6		      .byte.b	(UNKNOWNVEC-*)-1
      0  34d1					      db	oRightBracket
      1  34d1		       e1		      .byte.b	oRightBracket
      0  34d2					      RTN
      0  34d2					      db	25
      1  34d2		       19		      .byte.b	25
    766  34d3
    767  34d3				   ExpectedVariable
      0  34d3					      ERRMSG	ERR_SYNTAX	;Expected Variable
      0  34d3					      db	13
      1  34d3		       0d		      .byte.b	13
      0  34d4					      dw	ERR_SYNTAX
      1  34d4		       05 00		      .word.w	ERR_SYNTAX
    769  34d6							;
    770  34d6							;================================================================
    771  34d6							; Compare a block of memory
    772  34d6							; CmpMem(Length, Source 1, Source 2)
    773  34d6							; returns on the stack 0 equal, 1 s1>s2, -1 s1<s2
    774  34d6				   ekCmpMem
      0  34d6					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  34d6					      db	101
      1  34d6		       65		      .byte.b	101
      0  34d7					      db	(UNKNOWNVEC-*)-1
      1  34d7		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  34d8					      db	oLeftBracket
      1  34d8		       e0		      .byte.b	oLeftBracket
      0  34d9					      CALL	EXPR	; Length
      0  34d9					      db	28
      1  34d9		       1c		      .byte.b	28
      0  34da					      dw	EXPR
      1  34da		       28 34		      .word.w	EXPR
      0  34dc					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  34dc					      db	101
      1  34dc		       65		      .byte.b	101
      0  34dd					      db	(UNKNOWNVEC-*)-1
      1  34dd		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  34de					      db	oComma
      1  34de		       e2		      .byte.b	oComma
      0  34df					      CALL	EXPR	; Source 1
      0  34df					      db	28
      1  34df		       1c		      .byte.b	28
      0  34e0					      dw	EXPR
      1  34e0		       28 34		      .word.w	EXPR
      0  34e2					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  34e2					      db	101
      1  34e2		       65		      .byte.b	101
      0  34e3					      db	(UNKNOWNVEC-*)-1
      1  34e3		       c3		      .byte.b	(UNKNOWNVEC-*)-1
      0  34e4					      db	oComma
      1  34e4		       e2		      .byte.b	oComma
      0  34e5					      CALL	EXPR	; Source 2
      0  34e5					      db	28
      1  34e5		       1c		      .byte.b	28
      0  34e6					      dw	EXPR
      1  34e6		       28 34		      .word.w	EXPR
      0  34e8					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  34e8					      db	101
      1  34e8		       65		      .byte.b	101
      0  34e9					      db	(UNKNOWNVEC-*)-1
      1  34e9		       bd		      .byte.b	(UNKNOWNVEC-*)-1
      0  34ea					      db	oRightBracket
      1  34ea		       e1		      .byte.b	oRightBracket
      0  34eb					      CMPMEM		; Compare the memory
      0  34eb					      db	112
      1  34eb		       70		      .byte.b	112
      0  34ec					      RTN
      0  34ec					      db	25
      1  34ec		       19		      .byte.b	25
    784  34ed							;
    785  34ed							;===============================================================================
    786  34ed							; Set/stop/return timer values
    787  34ed							;value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    788  34ed							;cmd	0 =
    789  34ed				   eKTimer
      0  34ed					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  34ed					      db	101
      1  34ed		       65		      .byte.b	101
      0  34ee					      db	(UNKNOWNVEC-*)-1
      1  34ee		       b8		      .byte.b	(UNKNOWNVEC-*)-1
      0  34ef					      db	oLeftBracket
      1  34ef		       e0		      .byte.b	oLeftBracket
      0  34f0					      CALL	EXPR	; purpose 0-4
      0  34f0					      db	28
      1  34f0		       1c		      .byte.b	28
      0  34f1					      dw	EXPR
      1  34f1		       28 34		      .word.w	EXPR
      0  34f3					      TSTB	eKTimerZero,oComma	; Must have a comma if more than one value
      0  34f3					      db	101
      1  34f3		       65		      .byte.b	101
      0  34f4					      db	(eKTimerZero-*)-1
      1  34f4		       07		      .byte.b	(eKTimerZero-*)-1
      0  34f5					      db	oComma
      1  34f5		       e2		      .byte.b	oComma
      0  34f6					      CALL	EXPR	; only used by set parameters
      0  34f6					      db	28
      1  34f6		       1c		      .byte.b	28
      0  34f7					      dw	EXPR
      1  34f7		       28 34		      .word.w	EXPR
      0  34f9					      iJMP	eKTimerOut	; get out
      0  34f9					      db	29
      1  34f9		       1d		      .byte.b	29
      0  34fa					      dw	eKTimerOut
      1  34fa		       ff 34		      .word.w	eKTimerOut
    795  34fc				   eKTimerZero
      0  34fc					      lit	0	; no second parameter
      0  34fc					      db	27
      1  34fc		       1b		      .byte.b	27
      0  34fd					      dw	0
      1  34fd		       00 00		      .word.w	0
    797  34ff				   eKTimerOut
      0  34ff					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  34ff					      db	101
      1  34ff		       65		      .byte.b	101
      0  3500					      db	(UNKNOWNVEC-*)-1
      1  3500		       a6		      .byte.b	(UNKNOWNVEC-*)-1
      0  3501					      db	oRightBracket
      1  3501		       e1		      .byte.b	oRightBracket
      0  3502					      Timer
      0  3502					      db	114
      1  3502		       72		      .byte.b	114
      0  3503					      RTN
      0  3503					      db	25
      1  3503		       19		      .byte.b	25
    801  3504
    802  3504							;====================================================================================
    803  3504							; peek(mem address) return the value of a byte in memory
    804  3504							; @[offset] return a word value from offset -- see tstv
    805  3504							;
    806  3504							;F1A2:
    807  3504							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    808  3504				   ekPeek
      0  3504					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3504					      db	101
      1  3504		       65		      .byte.b	101
      0  3505					      db	(UNKNOWNVEC-*)-1
      1  3505		       a1		      .byte.b	(UNKNOWNVEC-*)-1
      0  3506					      db	oLeftBracket
      1  3506		       e0		      .byte.b	oLeftBracket
      0  3507					      CALL	EXPR	;Get the address to write to
      0  3507					      db	28
      1  3507		       1c		      .byte.b	28
      0  3508					      dw	EXPR
      1  3508		       28 34		      .word.w	EXPR
      0  350a					      TSTB	UNKNOWNVEC,oRightBracket
      0  350a					      db	101
      1  350a		       65		      .byte.b	101
      0  350b					      db	(UNKNOWNVEC-*)-1
      1  350b		       9b		      .byte.b	(UNKNOWNVEC-*)-1
      0  350c					      db	oRightBracket
      1  350c		       e1		      .byte.b	oRightBracket
      0  350d					      PEEKMEM
      0  350d					      db	48
      1  350d		       30		      .byte.b	48
      0  350e					      RTN
      0  350e					      db	25
      1  350e		       19		      .byte.b	25
    814  350f							;=======================================================================================
    815  350f							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    816  350f							;
    817  350f							;F2AZ:
    818  350f							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    819  350f				   ekTask
      0  350f					      TSTBRANCH	ekTaskCompiled
      0  350f					      db	106
      1  350f		       6a		      .byte.b	106
      0  3510					      db	(ekTaskCompiled-*)-1
      1  3510		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  3511					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3511					      db	101
      1  3511		       65		      .byte.b	101
      0  3512					      db	(UNKNOWNVEC-*)-1
      1  3512		       94		      .byte.b	(UNKNOWNVEC-*)-1
      0  3513					      db	oLeftBracket
      1  3513		       e0		      .byte.b	oLeftBracket
      0  3514					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  3514					      db	28
      1  3514		       1c		      .byte.b	28
      0  3515					      dw	EXPR
      1  3515		       28 34		      .word.w	EXPR
      0  3517					      lit	0
      0  3517					      db	27
      1  3517		       1b		      .byte.b	27
      0  3518					      dw	0
      1  3518		       00 00		      .word.w	0
      0  351a					      iJMP	ekTaskLinenum
      0  351a					      db	29
      1  351a		       1d		      .byte.b	29
      0  351b					      dw	ekTaskLinenum
      1  351b		       20 35		      .word.w	ekTaskLinenum
    825  351d
    826  351d				   ekTaskCompiled
      0  351d					      lit	1
      0  351d					      db	27
      1  351d		       1b		      .byte.b	27
      0  351e					      dw	1
      1  351e		       01 00		      .word.w	1
    828  3520
    829  3520				   ekTaskLinenum
      0  3520					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  3520					      db	61
      1  3520		       3d		      .byte.b	61
      0  3521					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  3521					      db	101
      1  3521		       65		      .byte.b	101
      0  3522					      db	(F2AZNoParms-*)-1
      1  3522		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  3523					      db	oComma
      1  3523		       e2		      .byte.b	oComma
      0  3524					      SAVEMATHSTACK		;Push The mathstack
      0  3524					      db	86
      1  3524		       56		      .byte.b	86
      0  3525					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  3525					      db	89
      1  3525		       59		      .byte.b	89
    834  3526
    835  3526				   F2AZLOOP
      0  3526					      CALL	EXPR
      0  3526					      db	28
      1  3526		       1c		      .byte.b	28
      0  3527					      dw	EXPR
      1  3527		       28 34		      .word.w	EXPR
      0  3529					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  3529					      db	101
      1  3529		       65		      .byte.b	101
      0  352a					      db	(F2AZEndParm-*)-1
      1  352a		       04		      .byte.b	(F2AZEndParm-*)-1
      0  352b					      db	oComma
      1  352b		       e2		      .byte.b	oComma
      0  352c					      IJMP	F2AZLOOP	;check for more
      0  352c					      db	29
      1  352c		       1d		      .byte.b	29
      0  352d					      dw	F2AZLOOP
      1  352d		       26 35		      .word.w	F2AZLOOP
    839  352f
    840  352f				   F2AZEndParm
      0  352f					      RESTOREMATHSTACK		;Back to normal stack
      0  352f					      db	87
      1  352f		       57		      .byte.b	87
      0  3530					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  3530					      db	92
      1  3530		       5c		      .byte.b	92
    843  3531
    844  3531				   F2AZNoParms
      0  3531					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  3531					      db	101
      1  3531		       65		      .byte.b	101
      0  3532					      db	(UNKNOWNVEC-*)-1
      1  3532		       74		      .byte.b	(UNKNOWNVEC-*)-1
      0  3533					      db	oRightBracket
      1  3533		       e1		      .byte.b	oRightBracket
    846  3534
      0  3534					      TASKENABLE		;Enable the task to execute
      0  3534					      db	90
      1  3534		       5a		      .byte.b	90
    848  3535
      0  3535					      RTN		;Returns the Task number
      0  3535					      db	25
      1  3535		       19		      .byte.b	25
    850  3536							;=========================================================================================
    851  3536							; Check for IPC interproccess instructions
    852  3536							;   IPCS  - Send a message
    853  3536							;
    854  3536							;F2AZ1:
    855  3536							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    856  3536				   ekIpcs
      0  3536					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  3536					      db	101
      1  3536		       65		      .byte.b	101
      0  3537					      db	(UNKNOWNVEC-*)-1
      1  3537		       6f		      .byte.b	(UNKNOWNVEC-*)-1
      0  3538					      db	oLeftBracket
      1  3538		       e0		      .byte.b	oLeftBracket
      0  3539					      CALL	EXPR	;Get the message value
      0  3539					      db	28
      1  3539		       1c		      .byte.b	28
      0  353a					      dw	EXPR
      1  353a		       28 34		      .word.w	EXPR
      0  353c					      TSTB	UNKNOWNVEC,oComma
      0  353c					      db	101
      1  353c		       65		      .byte.b	101
      0  353d					      db	(UNKNOWNVEC-*)-1
      1  353d		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  353e					      db	oComma
      1  353e		       e2		      .byte.b	oComma
      0  353f					      CALL	EXPR	;Get pid of task to send to
      0  353f					      db	28
      1  353f		       1c		      .byte.b	28
      0  3540					      dw	EXPR
      1  3540		       28 34		      .word.w	EXPR
      0  3542					      TSTB	UNKNOWNVEC,oRightBracket
      0  3542					      db	101
      1  3542		       65		      .byte.b	101
      0  3543					      db	(UNKNOWNVEC-*)-1
      1  3543		       63		      .byte.b	(UNKNOWNVEC-*)-1
      0  3544					      db	oRightBracket
      1  3544		       e1		      .byte.b	oRightBracket
      0  3545					      IPCSEND		;Send msg and clear pid msg pending
      0  3545					      db	80
      1  3545		       50		      .byte.b	80
      0  3546					      RTN
      0  3546					      db	25
      1  3546		       19		      .byte.b	25
    864  3547							;================================================================================
    865  3547							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    866  3547							;
    867  3547				   ekIpcr
      0  3547					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  3547					      db	101
      1  3547		       65		      .byte.b	101
      0  3548					      db	(UNKNOWNVEC-*)-1
      1  3548		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  3549					      db	oLeftBracket
      1  3549		       e0		      .byte.b	oLeftBracket
      0  354a					      TSTB	F2AZa1,oRightBracket
      0  354a					      db	101
      1  354a		       65		      .byte.b	101
      0  354b					      db	(F2AZa1-*)-1
      1  354b		       07		      .byte.b	(F2AZa1-*)-1
      0  354c					      db	oRightBracket
      1  354c		       e1		      .byte.b	oRightBracket
      0  354d					      LIT	0	;We dont want the pid returned to us
      0  354d					      db	27
      1  354d		       1b		      .byte.b	27
      0  354e					      dw	0
      1  354e		       00 00		      .word.w	0
      0  3550					      IJMP	ekIpcrComplete
      0  3550					      db	29
      1  3550		       1d		      .byte.b	29
      0  3551					      dw	ekIpcrComplete
      1  3551		       58 35		      .word.w	ekIpcrComplete
    872  3553				   F2AZa1
      0  3553					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  3553					      db	33
      1  3553		       21		      .byte.b	33
      0  3554					      db	(UNKNOWNVEC-*)-1
      1  3554		       52		      .byte.b	(UNKNOWNVEC-*)-1
      0  3555					      TSTB	UNKNOWNVEC,oRightBracket
      0  3555					      db	101
      1  3555		       65		      .byte.b	101
      0  3556					      db	(UNKNOWNVEC-*)-1
      1  3556		       50		      .byte.b	(UNKNOWNVEC-*)-1
      0  3557					      db	oRightBracket
      1  3557		       e1		      .byte.b	oRightBracket
    875  3558
    876  3558				   ekIpcrComplete
      0  3558					      IPCIO		;Set the io bit and exit task till message
      0  3558					      db	83
      1  3558		       53		      .byte.b	83
      0  3559					      IPCRECEIVE		;Get the message
      0  3559					      db	81
      1  3559		       51		      .byte.b	81
      0  355a					      RTN
      0  355a					      db	25
      1  355a		       19		      .byte.b	25
    880  355b							;===============================================================================
    881  355b							; IPCC ---- check if a message is available
    882  355b				   ekIpcc
      0  355b					      TSTB	UNKNOWNVEC,oLeftBracket
      0  355b					      db	101
      1  355b		       65		      .byte.b	101
      0  355c					      db	(UNKNOWNVEC-*)-1
      1  355c		       4a		      .byte.b	(UNKNOWNVEC-*)-1
      0  355d					      db	oLeftBracket
      1  355d		       e0		      .byte.b	oLeftBracket
      0  355e					      TSTB	UNKNOWNVEC,oRightBracket
      0  355e					      db	101
      1  355e		       65		      .byte.b	101
      0  355f					      db	(UNKNOWNVEC-*)-1
      1  355f		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  3560					      db	oRightBracket
      1  3560		       e1		      .byte.b	oRightBracket
      0  3561					      IPCCHECK
      0  3561					      db	82
      1  3561		       52		      .byte.b	82
      0  3562					      RTN
      0  3562					      db	25
      1  3562		       19		      .byte.b	25
    887  3563
    888  3563				   UNKNOWNID
      0  3563					      IJMP	UNKNOWN
      0  3563					      db	29
      1  3563		       1d		      .byte.b	29
      0  3564					      dw	UNKNOWN
      1  3564		       24 34		      .word.w	UNKNOWN
    890  3566							;============================================================
    891  3566							; RND() is supposed to have an argument but if none
    892  3566							; was provided, just assume a large value.
    893  3566							;
    894  3566				   ekRnd
      0  3566					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3566					      db	101
      1  3566		       65		      .byte.b	101
      0  3567					      db	(UNKNOWNVEC-*)-1
      1  3567		       3f		      .byte.b	(UNKNOWNVEC-*)-1
      0  3568					      db	oLeftBracket
      1  3568		       e0		      .byte.b	oLeftBracket
      0  3569					      TSTB	F2A1,oRightBracket
      0  3569					      db	101
      1  3569		       65		      .byte.b	101
      0  356a					      db	(F2A1-*)-1
      1  356a		       06		      .byte.b	(F2A1-*)-1
      0  356b					      db	oRightBracket
      1  356b		       e1		      .byte.b	oRightBracket
      0  356c					      LIT	32766
      0  356c					      db	27
      1  356c		       1b		      .byte.b	27
      0  356d					      dw	32766
      1  356d		       fe 7f		      .word.w	32766
      0  356f					      RANDOM
      0  356f					      db	37
      1  356f		       25		      .byte.b	37
      0  3570					      RTN
      0  3570					      db	25
      1  3570		       19		      .byte.b	25
    900  3571
    901  3571				   F2A1
      0  3571					      CALL	EXPR	;GET RANGE
      0  3571					      db	28
      1  3571		       1c		      .byte.b	28
      0  3572					      dw	EXPR
      1  3572		       28 34		      .word.w	EXPR
      0  3574					      TSTB	UNKNOWNVEC,oRightBracket
      0  3574					      db	101
      1  3574		       65		      .byte.b	101
      0  3575					      db	(UNKNOWNVEC-*)-1
      1  3575		       31		      .byte.b	(UNKNOWNVEC-*)-1
      0  3576					      db	oRightBracket
      1  3576		       e1		      .byte.b	oRightBracket
      0  3577					      RANDOM
      0  3577					      db	37
      1  3577		       25		      .byte.b	37
      0  3578					      RTN
      0  3578					      db	25
      1  3578		       19		      .byte.b	25
    906  3579							;==========================================================
    907  3579							;	Return absolute value of expresion
    908  3579							;
    909  3579				   ekAbs
      0  3579					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3579					      db	101
      1  3579		       65		      .byte.b	101
      0  357a					      db	(UNKNOWNVEC-*)-1
      1  357a		       2c		      .byte.b	(UNKNOWNVEC-*)-1
      0  357b					      db	oLeftBracket
      1  357b		       e0		      .byte.b	oLeftBracket
      0  357c					      CALL	EXPR	;get value
      0  357c					      db	28
      1  357c		       1c		      .byte.b	28
      0  357d					      dw	EXPR
      1  357d		       28 34		      .word.w	EXPR
      0  357f					      TSTB	UNKNOWNVEC,oRightBracket
      0  357f					      db	101
      1  357f		       65		      .byte.b	101
      0  3580					      db	(UNKNOWNVEC-*)-1
      1  3580		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  3581					      db	oRightBracket
      1  3581		       e1		      .byte.b	oRightBracket
      0  3582					      ABS
      0  3582					      db	38
      1  3582		       26		      .byte.b	38
      0  3583					      RTN
      0  3583					      db	25
      1  3583		       19		      .byte.b	25
    915  3584							;============================================================
    916  3584							;     Return the the status of a task, provide the PID
    917  3584							;
    918  3584				   ekStat
      0  3584					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3584					      db	101
      1  3584		       65		      .byte.b	101
      0  3585					      db	(UNKNOWNVEC-*)-1
      1  3585		       21		      .byte.b	(UNKNOWNVEC-*)-1
      0  3586					      db	oLeftBracket
      1  3586		       e0		      .byte.b	oLeftBracket
      0  3587					      Call	EXPR
      0  3587					      db	28
      1  3587		       1c		      .byte.b	28
      0  3588					      dw	EXPR
      1  3588		       28 34		      .word.w	EXPR
      0  358a					      TSTB	UNKNOWNVEC,oRightBracket
      0  358a					      db	101
      1  358a		       65		      .byte.b	101
      0  358b					      db	(UNKNOWNVEC-*)-1
      1  358b		       1b		      .byte.b	(UNKNOWNVEC-*)-1
      0  358c					      db	oRightBracket
      1  358c		       e1		      .byte.b	oRightBracket
      0  358d					      TASKSTAT
      0  358d					      db	66
      1  358d		       42		      .byte.b	66
      0  358e					      RTN
      0  358e					      db	25
      1  358e		       19		      .byte.b	25
    924  358f							;==============================================================
    925  358f							; Return the current tasks pid
    926  358f							;
    927  358f				   ekPid
      0  358f					      TASKPID
      0  358f					      db	77
      1  358f		       4d		      .byte.b	77
      0  3590					      RTN
      0  3590					      db	25
      1  3590		       19		      .byte.b	25
    930  3591							;===========================================================================
    931  3591							; Call a machine function, provide the address to call and optionally
    932  3591							; the value to be passed in reg A
    933  3591				   ekCall
      0  3591					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3591					      db	101
      1  3591		       65		      .byte.b	101
      0  3592					      db	(UNKNOWNVEC-*)-1
      1  3592		       14		      .byte.b	(UNKNOWNVEC-*)-1
      0  3593					      db	oLeftBracket
      1  3593		       e0		      .byte.b	oLeftBracket
      0  3594					      CALL	EXPR
      0  3594					      db	28
      1  3594		       1c		      .byte.b	28
      0  3595					      dw	EXPR
      1  3595		       28 34		      .word.w	EXPR
      0  3597					      TSTB	F2B2A,oComma
      0  3597					      db	101
      1  3597		       65		      .byte.b	101
      0  3598					      db	(F2B2A-*)-1
      1  3598		       09		      .byte.b	(F2B2A-*)-1
      0  3599					      db	oComma
      1  3599		       e2		      .byte.b	oComma
      0  359a					      CALL	EXPR
      0  359a					      db	28
      1  359a		       1c		      .byte.b	28
      0  359b					      dw	EXPR
      1  359b		       28 34		      .word.w	EXPR
      0  359d					      TSTB	UNKNOWNVEC,oRightBracket
      0  359d					      db	101
      1  359d		       65		      .byte.b	101
      0  359e					      db	(UNKNOWNVEC-*)-1
      1  359e		       08		      .byte.b	(UNKNOWNVEC-*)-1
      0  359f					      db	oRightBracket
      1  359f		       e1		      .byte.b	oRightBracket
      0  35a0					      CALLFUNC
      0  35a0					      db	53
      1  35a0		       35		      .byte.b	53
      0  35a1					      RTN
      0  35a1					      db	25
      1  35a1		       19		      .byte.b	25
    941  35a2							; Run the gosub within this function
    942  35a2				   F2B2A
      0  35a2					      TSTB	UNKNOWNID,oRightBracket
      0  35a2					      db	101
      1  35a2		       65		      .byte.b	101
      0  35a3					      db	(UNKNOWNID-*)-1
      1  35a3		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  35a4					      db	oRightBracket
      1  35a4		       e1		      .byte.b	oRightBracket
      0  35a5					      LIT	0	; No parameter passed so just load zero to A
      0  35a5					      db	27
      1  35a5		       1b		      .byte.b	27
      0  35a6					      dw	0
      1  35a6		       00 00		      .word.w	0
      0  35a8					      CALLFUNC
      0  35a8					      db	53
      1  35a8		       35		      .byte.b	53
      0  35a9					      RTN
      0  35a9					      db	25
      1  35a9		       19		      .byte.b	25
    947  35aa
    948  35aa
    949  35aa							;=================================================================================
    950  35aa							;Check for a number !
    951  35aa							;
    952  35aa				   FactNumber
      0  35aa					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  35aa					      db	35
      1  35aa		       23		      .byte.b	35
      0  35ab					      db	(FactVariable-*)-1
      1  35ab		       0f		      .byte.b	(FactVariable-*)-1
      0  35ac					      RTN
      0  35ac					      db	25
      1  35ac		       19		      .byte.b	25
    955  35ad
    956  35ad				   FactWithBracket
      0  35ad					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  35ad					      db	101
      1  35ad		       65		      .byte.b	101
      0  35ae					      db	(F2RTN-*)-1
      1  35ae		       08		      .byte.b	(F2RTN-*)-1
      0  35af					      db	oLeftBracket
      1  35af		       e0		      .byte.b	oLeftBracket
      0  35b0					      CALL	EXPR
      0  35b0					      db	28
      1  35b0		       1c		      .byte.b	28
      0  35b1					      dw	EXPR
      1  35b1		       28 34		      .word.w	EXPR
      0  35b3					      TST	F2,oRightBracket
      0  35b3					      db	32
      1  35b3		       20		      .byte.b	32
      0  35b4					      db	(F2-*)-1
      1  35b4		       03		      .byte.b	(F2-*)-1
      0  35b5					      db	oRightBracket,0
      1  35b5		       e1 00		      .byte.b	oRightBracket,0
    960  35b7				   F2RTN
      0  35b7					      RTN
      0  35b7					      db	25
      1  35b7		       19		      .byte.b	25
    962  35b8
    963  35b8				   F2
      0  35b8					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  35b8					      db	13
      1  35b8		       0d		      .byte.b	13
      0  35b9					      dw	ERR_SYNTAX
      1  35b9		       05 00		      .word.w	ERR_SYNTAX
    965  35bb							;
    966  35bb							;=============================================================================
    967  35bb							; See if this is just a simple variable
    968  35bb							;  Allow a subscript for any variable
    969  35bb							;
    970  35bb				   FactVariable
    971  35bb
      0  35bb					      SETR2	tInteger
      0  35bb					      db	94
      1  35bb		       5e		      .byte.b	94
      0  35bc					      db	tInteger
      1  35bc		       a4		      .byte.b	tInteger
      0  35bd					      TSTV	FactWithBracket
      0  35bd					      db	33
      1  35bd		       21		      .byte.b	33
      0  35be					      db	(FactWithBracket-*)-1
      1  35be		       ee		      .byte.b	(FactWithBracket-*)-1
      0  35bf					      TSTBYTE	FactFNParm,R2,GOSUB_RTN_VALUE
      0  35bf					      db	97
      1  35bf		       61		      .byte.b	97
      0  35c0					      db	(FactFNParm-*)-1
      1  35c0		       08		      .byte.b	(FactFNParm-*)-1
      0  35c1					      dw	R2
      1  35c1		       58 00		      .word.w	R2
      0  35c3					      db	GOSUB_RTN_VALUE
      1  35c3		       81		      .byte.b	GOSUB_RTN_VALUE
      0  35c4					      CALL	FactVarPTR
      0  35c4					      db	28
      1  35c4		       1c		      .byte.b	28
      0  35c5					      dw	FactVarPTR
      1  35c5		       d8 35		      .word.w	FactVarPTR
    976  35c7							;	  CALL	      FactVariableValue
      0  35c7					      IND		; get the variable value
      0  35c7					      db	20
      1  35c7		       14		      .byte.b	20
      0  35c8					      RTN
      0  35c8					      db	25
      1  35c8		       19		      .byte.b	25
    979  35c9
    980  35c9				   FactFNParm
      0  35c9					      TSTB	FactExpectedOpeningBracket,oLeftSQBracket
      0  35c9					      db	101
      1  35c9		       65		      .byte.b	101
      0  35ca					      db	(FactExpectedOpeningBracket-*)-1
      1  35ca		       44		      .byte.b	(FactExpectedOpeningBracket-*)-1
      0  35cb					      db	oLeftSQBracket
      1  35cb		       e4		      .byte.b	oLeftSQBracket
      0  35cc					      CALL	EXPR
      0  35cc					      db	28
      1  35cc		       1c		      .byte.b	28
      0  35cd					      dw	EXPR
      1  35cd		       28 34		      .word.w	EXPR
      0  35cf					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  35cf					      db	101
      1  35cf		       65		      .byte.b	101
      0  35d0					      db	(FactMissingRightBracket-*)-1
      1  35d0		       3b		      .byte.b	(FactMissingRightBracket-*)-1
      0  35d1					      db	oRightSQBracket
      1  35d1		       e5		      .byte.b	oRightSQBracket
      0  35d2					      SUBSCRIPT	GOSUB_RTN_VALUE
      0  35d2					      db	64
      1  35d2		       40		      .byte.b	64
      0  35d3					      db	GOSUB_RTN_VALUE
      1  35d3		       81		      .byte.b	GOSUB_RTN_VALUE
      0  35d4					      SETR2	tInteger
      0  35d4					      db	94
      1  35d4		       5e		      .byte.b	94
      0  35d5					      db	tInteger
      1  35d5		       a4		      .byte.b	tInteger
      0  35d6					      IND
      0  35d6					      db	20
      1  35d6		       14		      .byte.b	20
      0  35d7					      RTN
      0  35d7					      db	25
      1  35d7		       19		      .byte.b	25
    988  35d8
    989  35d8				   FactVarPTR
    990  35d8				   FactVarPtrNoTst
      0  35d8					      TSTB	F2CLocalTask,oBang
      0  35d8					      db	101
      1  35d8		       65		      .byte.b	101
      0  35d9					      db	(F2CLocalTask-*)-1
      1  35d9		       04		      .byte.b	(F2CLocalTask-*)-1
      0  35da					      db	oBang
      1  35da		       e8		      .byte.b	oBang
      0  35db					      IND		; we just got a pid
      0  35db					      db	20
      1  35db		       14		      .byte.b	20
      0  35dc					      TSTVT	UNKNOWNID	; if it is not another variable then error, Call test var. task
      0  35dc					      db	93
      1  35dc		       5d		      .byte.b	93
      0  35dd					      db	(UNKNOWNID-*)-1
      1  35dd		       85		      .byte.b	(UNKNOWNID-*)-1
    994  35de
    995  35de				   F2CLocalTask
      0  35de					      SETR2	tInteger	; Sets the default type to integer
      0  35de					      db	94
      1  35de		       5e		      .byte.b	94
      0  35df					      db	tInteger
      1  35df		       a4		      .byte.b	tInteger
      0  35e0					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  35e0					      db	101
      1  35e0		       65		      .byte.b	101
      0  35e1					      db	(F2INTEGER-*)-1
      1  35e1		       11		      .byte.b	(F2INTEGER-*)-1
      0  35e2					      db	oDollar
      1  35e2		       e7		      .byte.b	oDollar
      0  35e3					      SETR2	tByte
      0  35e3					      db	94
      1  35e3		       5e		      .byte.b	94
      0  35e4					      db	tByte
      1  35e4		       a2		      .byte.b	tByte
      0  35e5					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  35e5					      db	101
      1  35e5		       65		      .byte.b	101
      0  35e6					      db	(F2PTRLOADED-*)-1
      1  35e6		       22		      .byte.b	(F2PTRLOADED-*)-1
      0  35e7					      db	oLeftSQBracket
      1  35e7		       e4		      .byte.b	oLeftSQBracket
      0  35e8					      CALL	EXPR
      0  35e8					      db	28
      1  35e8		       1c		      .byte.b	28
      0  35e9					      dw	EXPR
      1  35e9		       28 34		      .word.w	EXPR
      0  35eb					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  35eb					      db	101
      1  35eb		       65		      .byte.b	101
      0  35ec					      db	(FactMissingRightBracket-*)-1
      1  35ec		       1f		      .byte.b	(FactMissingRightBracket-*)-1
      0  35ed					      db	oRightSQBracket
      1  35ed		       e5		      .byte.b	oRightSQBracket
      0  35ee					      SUBSCRIPT	tByte	; Byte type array
      0  35ee					      db	64
      1  35ee		       40		      .byte.b	64
      0  35ef					      db	tByte
      1  35ef		       a2		      .byte.b	tByte
      0  35f0					      SETR2	tByte	; Set byte data type
      0  35f0					      db	94
      1  35f0		       5e		      .byte.b	94
      0  35f1					      db	tByte
      1  35f1		       a2		      .byte.b	tByte
      0  35f2					      RTN
      0  35f2					      db	25
      1  35f2		       19		      .byte.b	25
   1005  35f3
   1006  35f3				   F2INTEGER
      0  35f3					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  35f3					      db	101
      1  35f3		       65		      .byte.b	101
      0  35f4					      db	(F2PTRLOADED-*)-1
      1  35f4		       14		      .byte.b	(F2PTRLOADED-*)-1
      0  35f5					      db	oLeftSQBracket
      1  35f5		       e4		      .byte.b	oLeftSQBracket
      0  35f6					      CALL	EXPR
      0  35f6					      db	28
      1  35f6		       1c		      .byte.b	28
      0  35f7					      dw	EXPR
      1  35f7		       28 34		      .word.w	EXPR
      0  35f9					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  35f9					      db	101
      1  35f9		       65		      .byte.b	101
      0  35fa					      db	(FactMissingRightBracket-*)-1
      1  35fa		       11		      .byte.b	(FactMissingRightBracket-*)-1
      0  35fb					      db	oRightSQBracket
      1  35fb		       e5		      .byte.b	oRightSQBracket
      0  35fc					      SUBSCRIPT	tInteger	; Integer type array
      0  35fc					      db	64
      1  35fc		       40		      .byte.b	64
      0  35fd					      db	tInteger
      1  35fd		       a4		      .byte.b	tInteger
      0  35fe					      SETR2	tInteger	; Set word datatype
      0  35fe					      db	94
      1  35fe		       5e		      .byte.b	94
      0  35ff					      db	tInteger
      1  35ff		       a4		      .byte.b	tInteger
      0  3600					      TSTB	F2PTRLOADED,oBang	; for a word it can be fillowed by a! as ref to other task variables
      0  3600					      db	101
      1  3600		       65		      .byte.b	101
      0  3601					      db	(F2PTRLOADED-*)-1
      1  3601		       07		      .byte.b	(F2PTRLOADED-*)-1
      0  3602					      db	oBang
      1  3602		       e8		      .byte.b	oBang
      0  3603					      IND		; Get the value of the task context to access
      0  3603					      db	20
      1  3603		       14		      .byte.b	20
      0  3604					      TSTVT	UNKNOWNID	; if it is not another variable name then it is a halt error
      0  3604					      db	93
      1  3604		       5d		      .byte.b	93
      0  3605					      db	(UNKNOWNID-*)-1
      1  3605		       5d		      .byte.b	(UNKNOWNID-*)-1
      0  3606					      IJMP	FactVarPTR	; Process the value on the other side
      0  3606					      db	29
      1  3606		       1d		      .byte.b	29
      0  3607					      dw	FactVarPTR
      1  3607		       d8 35		      .word.w	FactVarPTR
   1016  3609				   F2PTRLOADED
      0  3609					      RTN
      0  3609					      db	25
      1  3609		       19		      .byte.b	25
   1018  360a
   1019  360a				   FactVariableValue
      0  360a					      IND		; YES, GET THE VALUE as word
      0  360a					      db	20
      1  360a		       14		      .byte.b	20
      0  360b					      RTN
      0  360b					      db	25
      1  360b		       19		      .byte.b	25
   1022  360c
   1023  360c				   FactMissingRightBracket
      0  360c					      IJMP	ReturnExpectBracket
      0  360c					      db	29
      1  360c		       1d		      .byte.b	29
      0  360d					      dw	ReturnExpectBracket
      1  360d		       40 36		      .word.w	ReturnExpectBracket
   1025  360f				   FactExpectedOpeningBracket
      0  360f					      ERRMSG	ERR_EXPECTED_OPENING_BRACKET
      0  360f					      db	13
      1  360f		       0d		      .byte.b	13
      0  3610					      dw	ERR_EXPECTED_OPENING_BRACKET
      1  3610		       1a 00		      .word.w	ERR_EXPECTED_OPENING_BRACKET
   1027  3612							;===============================================================================================================================
   1028  3612							;========================= Gosub and function interface ========================================================================
   1029  3612							; Process gosub 1000(Parm1, ...) no return value
   1030  3612							;
   1031  3612				   ekGosub
      0  3612					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  3612					      db	28
      1  3612		       1c		      .byte.b	28
      0  3613					      dw	GOSUBSTATEMENT
      1  3613		       44 36		      .word.w	GOSUBSTATEMENT
      0  3615					      DONE		; ERROR IF CR NOT NEXT
      0  3615					      db	1
      1  3615		       01		      .byte.b	1
      0  3616					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  3616					      db	8
      1  3616		       08		      .byte.b	8
      0  3617					      db	GOSUB_RTN
      1  3617		       01		      .byte.b	GOSUB_RTN
      0  3618					      FASTXFER		; AND JUMP to sub rtn
      0  3618					      db	107
      1  3618		       6b		      .byte.b	107
   1036  3619							;
   1037  3619							; End of gosub processing
   1038  3619							;===========================================================================
   1039  3619							; Same as gosub but expects a return value
   1040  3619							;   FN 1000(parm1, ....)  Expects an integer to be returned
   1041  3619							;
   1042  3619				   ekGofn
      0  3619					      Call	GOSUBSTATEMENT
      0  3619					      db	28
      1  3619		       1c		      .byte.b	28
      0  361a					      dw	GOSUBSTATEMENT
      1  361a		       44 36		      .word.w	GOSUBSTATEMENT
      0  361c					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  361c					      db	8
      1  361c		       08		      .byte.b	8
      0  361d					      db	GOSUB_RTN_VALUE
      1  361d		       81		      .byte.b	GOSUB_RTN_VALUE
      0  361e					      FASTXFER
      0  361e					      db	107
      1  361e		       6b		      .byte.b	107
   1046  361f
   1047  361f				   GOFNRet
      0  361f					      RTN
      0  361f					      db	25
      1  361f		       19		      .byte.b	25
   1049  3620							;===============================================================================================================================
   1050  3620							; Return from a gosub
   1051  3620							;
   1052  3620				   ekReturn
      0  3620					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  3620					      db	101
      1  3620		       65		      .byte.b	101
      0  3621					      db	(S2NoReturnValue-*)-1
      1  3621		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  3622					      db	oLeftBracket
      1  3622		       e0		      .byte.b	oLeftBracket
      0  3623					      CALL	EXPR
      0  3623					      db	28
      1  3623		       1c		      .byte.b	28
      0  3624					      dw	EXPR
      1  3624		       28 34		      .word.w	EXPR
      0  3626					      TSTB	ReturnExpectBracket,oRightBracket	; Now a value is on the stack
      0  3626					      db	101
      1  3626		       65		      .byte.b	101
      0  3627					      db	(ReturnExpectBracket-*)-1
      1  3627		       18		      .byte.b	(ReturnExpectBracket-*)-1
      0  3628					      db	oRightBracket
      1  3628		       e1		      .byte.b	oRightBracket
      0  3629					      DONE
      0  3629					      db	1
      1  3629		       01		      .byte.b	1
      0  362a					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  362a					      db	9
      1  362a		       09		      .byte.b	9
      0  362b					      db	(S2RetFunc-*)-1
      1  362b		       11		      .byte.b	(S2RetFunc-*)-1
      0  362c					      db	1
      1  362c		       01		      .byte.b	1
      0  362d					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  362d					      db	6
      1  362d		       06		      .byte.b	6
      0  362e					      dw	CO
      1  362e		       07 32		      .word.w	CO
      0  3630					      IJMP	STMT	; Process the new statement
      0  3630					      db	29
      1  3630		       1d		      .byte.b	29
      0  3631					      dw	STMT
      1  3631		       0f 32		      .word.w	STMT
   1060  3633
   1061  3633				   S2NoReturnValue
      0  3633					      DONE
      0  3633					      db	1
      1  3633		       01		      .byte.b	1
      0  3634					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  3634					      db	9
      1  3634		       09		      .byte.b	9
      0  3635					      db	(S2RetFunc-*)-1
      1  3635		       07		      .byte.b	(S2RetFunc-*)-1
      0  3636					      db	0
      1  3636		       00		      .byte.b	0
      0  3637					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3637					      db	6
      1  3637		       06		      .byte.b	6
      0  3638					      dw	CO
      1  3638		       07 32		      .word.w	CO
      0  363a					      IJMP	STMT	; Process the new statement
      0  363a					      db	29
      1  363a		       1d		      .byte.b	29
      0  363b					      dw	STMT
      1  363b		       0f 32		      .word.w	STMT
   1066  363d
   1067  363d				   S2RetFunc
      0  363d					      IJMP	GOFNRet	; Back into the Function
      0  363d					      db	29
      1  363d		       1d		      .byte.b	29
      0  363e					      dw	GOFNRet
      1  363e		       1f 36		      .word.w	GOFNRet
   1069  3640
   1070  3640				   ReturnExpectBracket
      0  3640					      ENDIO
      0  3640					      db	71
      1  3640		       47		      .byte.b	71
      0  3641					      ERRMSG	ERR_CLOSINGBRACKET
      0  3641					      db	13
      1  3641		       0d		      .byte.b	13
      0  3642					      dw	ERR_CLOSINGBRACKET
      1  3642		       17 00		      .word.w	ERR_CLOSINGBRACKET
   1073  3644							;
   1074  3644							; End of return from gosub
   1075  3644							;=============================================================
   1076  3644							; Gosub can be both a Function and a Subroutine
   1077  3644				   GOSUBSTATEMENT
      0  3644					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  3644					      db	106
      1  3644		       6a		      .byte.b	106
      0  3645					      db	(GOSUBCOMPILED-*)-1
      1  3645		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  3646					      CALL	EXPR	; GET DESTINATION
      0  3646					      db	28
      1  3646		       1c		      .byte.b	28
      0  3647					      dw	EXPR
      1  3647		       28 34		      .word.w	EXPR
      0  3649					      CALL	GOSUBCONT
      0  3649					      db	28
      1  3649		       1c		      .byte.b	28
      0  364a					      dw	GOSUBCONT
      1  364a		       57 36		      .word.w	GOSUBCONT
      0  364c					      lit	0	; mark as lookup on stack
      0  364c					      db	27
      1  364c		       1b		      .byte.b	27
      0  364d					      dw	0
      1  364d		       00 00		      .word.w	0
      0  364f					      RTN
      0  364f					      db	25
      1  364f		       19		      .byte.b	25
   1083  3650
   1084  3650				   GOSUBCOMPILED
      0  3650					      CALL	GOSUBCONT
      0  3650					      db	28
      1  3650		       1c		      .byte.b	28
      0  3651					      dw	GOSUBCONT
      1  3651		       57 36		      .word.w	GOSUBCONT
      0  3653					      lit	1	;mark as compiled on stack
      0  3653					      db	27
      1  3653		       1b		      .byte.b	27
      0  3654					      dw	1
      1  3654		       01 00		      .word.w	1
      0  3656					      RTN
      0  3656					      db	25
      1  3656		       19		      .byte.b	25
   1088  3657
   1089  3657				   GOSUBCONT
      0  3657					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters If not bracket get out
      0  3657					      db	101
      1  3657		       65		      .byte.b	101
      0  3658					      db	(GOSUBDONE-*)-1
      1  3658		       11		      .byte.b	(GOSUBDONE-*)-1
      0  3659					      db	oLeftBracket
      1  3659		       e0		      .byte.b	oLeftBracket
      0  365a					      STK2TMP		;Transfer stack top to temp, temp gets line to goto
      0  365a					      db	95
      1  365a		       5f		      .byte.b	95
      0  365b					      PUSHMATHSTACK		;Record stack frame for return
      0  365b					      db	84
      1  365b		       54		      .byte.b	84
   1093  365c				   GOSUBLOOP
      0  365c					      CALL	EXPR	; Allows what ever fits onto stack
      0  365c					      db	28
      1  365c		       1c		      .byte.b	28
      0  365d					      dw	EXPR
      1  365d		       28 34		      .word.w	EXPR
      0  365f					      INCPARMCOUNT
      0  365f					      db	88
      1  365f		       58		      .byte.b	88
      0  3660					      TSTB	GOSUBParmDONE,oComma
      0  3660					      db	101
      1  3660		       65		      .byte.b	101
      0  3661					      db	(GOSUBParmDONE-*)-1
      1  3661		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  3662					      db	oComma
      1  3662		       e2		      .byte.b	oComma
      0  3663					      IJMP	GOSUBLOOP
      0  3663					      db	29
      1  3663		       1d		      .byte.b	29
      0  3664					      dw	GOSUBLOOP
      1  3664		       5c 36		      .word.w	GOSUBLOOP
   1098  3666				   GOSUBParmDONE
      0  3666					      TSTB	ReturnExpectBracket,oRightBracket
      0  3666					      db	101
      1  3666		       65		      .byte.b	101
      0  3667					      db	(ReturnExpectBracket-*)-1
      1  3667		       d8		      .byte.b	(ReturnExpectBracket-*)-1
      0  3668					      db	oRightBracket
      1  3668		       e1		      .byte.b	oRightBracket
      0  3669					      TMP2STK		; Restore line to goto
      0  3669					      db	96
      1  3669		       60		      .byte.b	96
   1101  366a				   GOSUBDONE
      0  366a					      RTN
      0  366a					      db	25
      1  366a		       19		      .byte.b	25
   1103  366b
   1104  366b		       36 6b	   ILEND      equ	*
------- FILE mytb.asm
   2500  366b		       36 6b	   PROGEND    equ	*
   2501  366b
   2502  366b
   2503  366b							;=====================================================
   2504  366b							; Define start of non page zero data
   2505 U36be					      seg.u	TBData
   2506 U36be
   2507 U36be							;=====================================================
   2508 U36be							; These are storage items not in page zero.
   2509 U36be							;==================================================================================================
   2510 U36be							; Task Management information
   2511 U36be							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2512 U36be							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2513 U36be							; Task switchs happen at the beginning of the next Basic command line
   2514 U36be							; It will not happen during an input or output operations
   2515 U36be							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2516 U36be							; Task Zero is always the root task, main line program
   2517 U36be							;
   2518 U36be							; Layout is repeated for each configured task
   2519 U36be							; Task Table Byte   use masks follow
   2520 U36be		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2521 U36be		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2522 U36be		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2523 U36be		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2524 U36be		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2525 U36be
   2526 U36be		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2527 U36bf		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2528 U36bf		       37 b9	   TASKTABLEEND equ	*	; End of task table
   2529 U36bf		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2530 U37b9
   2531 U37b9							;Task Cycle Counter and reset count
   2532 U37b9		       00 00	   taskCurrentCycles ds	2
   2533 U37bb		       00 00	   taskResetValue ds	2
   2534 U37bd		       00	   taskCounter ds	1	; Count of active tasks
   2535 U37be
   2536 U37be							;
   2537 U37be							; Math stack and IL call and Gosub/For-next return stack definitions
   2538 U37be							;
   2539 U37be		       37 be	   STACKSTART equ	*
   2540 U37be		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2541 U394e		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2542 U3d36		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2543 U3fb6		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code,taskio block stdin,stdout,stdstat,iostatus
   2544 U3fb6		       00 48	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2545 U3fb6		       42 9a	   STACKEND   equ	*
   2546 U3fb6		       0a dc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2547 U429a							;
   2548 U429a							;
   2549 U429a		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2550 U431e		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2551 U431f		       00	   printtx    ds	1	;temp X for print funcs
   2552 U4320		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2553 U4321		       00	   promptChar ds	1	;the character to use for a prompt
   2554 U4322		       00	   diddigit   ds	1	;for leading zero suppression
   2555 U4323		       00	   putsy      ds	1
   2556 U4324		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2557 U4326		       00	   sign       ds	1	;0 = positive, else negative
   2558 U4327		       00 00	   rtemp1     ds	2	;Temp for x and y
   2559 U4329		       00 00	   random     ds	2
   2560 U432b		       00	   tempy      ds	1	;temp y storage
   2561 U432c
   2562 U432c
   2563 U432c							; Moved from page zero as one clock cycle diff gives more space on page zero
   2564 U432c		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2565 U432e		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2566 U432f		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2567 U4330		       00	   lineLength ds	1	;Length of current line
   2568 U4331
   2569 U4331		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2570 U4332		       00	   taskRDPending ds	1	; 1 = background read is pending
   2571 U4333		       00 00 00 00 timercounter ds	4	; if timer is running then this is continuously incremented
   2572 U4337
   2573 U4337				  -	      if	XKIM
   2574 U4337				  -buffer     ds	BUFFER_SIZE
   2575 U4337					      endif
   2576 U4337							;
   2577 U4337							; PROGRAMEND is the end of the user's BASIC program.
   2578 U4337							; More precisely, it is one byte past the end.  Or,
   2579 U4337							; it's where the next line added to the end will be
   2580 U4337							; placed.
   2581 U4337							;
   2582 U4337		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2583 U4339		       00 00	   ProgramEnd ds	2	; End of users basic program, Next free byte after end
   2584 U433b		       00 00	   HighMem    ds	2	; highest location
   2585 U433d		       00 00	   UsedMem    ds	2	; size of user program
   2586 U433f		       00 00	   FreeMem    ds	2	; amount of free memory
   2587 U4341							;
   2588 U4341							;=====================================================
   2589 U4341							; This is the start of the user's BASIC program space.
   2590 U4341							;
   2591 U4341							; PERSONAL GOAL: This should be no larger than $0DFF.
   2592 U4341							;		  0200-05FF = 1K
   2593 U4341							;		  0200-09FF = 2K
   2594 U4341							;		  0200-0DFF = 3K
   2595 U4341							;		  0200-11FF = 4K
   2596 U4341							;		  0200-13FF = 4.5K
   2597 U4341							;
   2598 U4341				  -	      if	FIXED
   2599 U4341				  -	      org	$2000
   2600 U4341					      endif
   2601 U4341
   2602 U4341		       43 41	   FreeMemStart equ	*
   2603 U4341							;/*
   2604 U4341							;  if	  CTMON65 || XKIM
   2605 U4341							;	  SEG Code
   2606 U4341							;	  org	  AutoRun
   2607 U4341							;	  dw	  TBasicCold
   2608 U4341							;  endif
   2609 U4341							;*/
   2610 U4341					      end
