------- FILE mytb.asm LEVEL 1 PASS 6
      1 U433c				   input      processor	6502
      2 U433c ????						;=====================================================
      3 U433c ????						; Concurrent Tiny Basic, no longer Tiny
      4 U433c ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U433c ????						; Free Time. Now abiut 6K Full OS features.
      6 U433c ????						;
      7 U433c ????						; While working on the Corsham Technologies KIM Clone
      8 U433c ????						; project, I wanted to include a TINY BASIC since that
      9 U433c ????						; was a highly desirable feature of early computers.
     10 U433c ????						;
     11 U433c ????						; Rather than negotiating copyright issues for
     12 U433c ????						; existing BASICs, I decided to just write one from
     13 U433c ????						; scratch.
     14 U433c ????						;
     15 U433c ????						; 10/07/2017
     16 U433c ????						;
     17 U433c ????						; This implements a stripped down Tiny BASIC
     18 U433c ????						; interpreter using the Interpretive Language (IL)
     19 U433c ????						; method as described in the first few issues of
     20 U433c ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U433c ????						; to write various languages simply by changing the
     22 U433c ????						; IL code rather than the interpreter itself.
     23 U433c ????						;
     24 U433c ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U433c ????						;		* Fixed major bug in findLine that
     26 U433c ????						;		  caused corrupted lines, crashes, etc.
     27 U433c ????						;		* If no parameter given to RND, assume
     28 U433c ????						;		  32766.
     29 U433c ????						;		* No more error 5 when a program
     30 U433c ????						;		  reaches the end without an END.
     31 U433c ????						;
     32 U433c ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U433c ????						;		 * Unexpanded version to play with everything
     34 U433c ????						;		 * Add some usefull system level functions
     35 U433c ????						;		 * allow a larger number of tiny basic formats
     36 U433c ????						;		 * Add byte at start of line holding length
     37 U433c ????						;		   for faster execution of goto and gosub
     38 U433c ????						;		 * Re-added gosub
     39 U433c ????						;		 * allow ; or , at end if print stmt
     40 U433c ????						;		   without CRLF being added.
     41 U433c ????						;		 * Added extended function erase to
     42 U433c ????						;		   use the extended ctmon65 rm file
     43 U433c ????						;		 * Fix quoted text to not have to backtrack
     44 U433c ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U433c ????						;		 * Add concurrency features
     46 U433c ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U433c ????						;
     48 U433c ????						; 10/31/2023 v0.5 Justlostintime@gmail.com
     49 U433c ????						;		 * Inline in il some var load value instead of calling
     50 U433c ????						;
     51 U433c ????						; 11/20/2023 v1.1.3 Justlostintime@gmail.com
     52 U433c ????						;		 * Many improvment, bug fixes
     53 U433c ????						;
     54 U433c ????						; www.corshamtech.com
     55 U433c ????						; bob@corshamtech.com
     56 U433c ????						; JustLostInTime@gmail.com
     57 U433c ????						;
     58 U433c ????						;=====================================================
     59 U433c ????						;
     60 U433c ????						; Create TRUE and FALSE values for conditionals.
     61 U433c ????						;
     62 U433c ????
     63 U433c ????	       00 00	   FALSE      equ	0
     64 U433c ????	       ff ff ff ff TRUE       equ	~FALSE
     65 U433c ????						;
     66 U433c ????						;---------------------------------------------------------
     67 U433c ????						; One of these must be set to indicate which environment
     68 U433c ????						; Tiny BASIC will be running in.  Here are the current
     69 U433c ????						; environments:
     70 U433c ????						;
     71 U433c ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     72 U433c ????						; more K of RAM.
     73 U433c ????						;
     74 U433c ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     75 U433c ????						; which enhances, without replacing, the standard KIM
     76 U433c ????						; monitor.  It gives access to routines to save/load files
     77 U433c ????						; to a micro SD card.
     78 U433c ????						;
     79 U433c ????						; CTMON65 is a from-scratch monitor written for the
     80 U433c ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     81 U433c ????						; easily be ported to other systems.  It has support for
     82 U433c ????						; using a micro SD card for file storage/retrieval.
     83 U433c ????						;
     84 U433c ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     85 U433c ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     86 U433c ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     87 U433c ????	       ff ff ff ff IL_DEBUG_TEXT equ	TRUE	;Print out as text IL instructions
     88 U433c ????						;
     89 U433c ????						;   Need to define some macros for the dasm assembler
     90 U433c ????						;
     91 U433c ????				      MACRO	dw
     92 U433c ????				      .word	{0}
     93 U433c ????				      ENDM
     94 U433c ????
     95 U433c ????				      MACRO	db
     96 U433c ????				      .byte	{0}
     97 U433c ????				      ENDM
     98 U433c ????
     99 U433c ????						;
    100 U433c ????						; If set, include disk functions.
    101 U433c ????						;
    102 U433c ????	       ff ff ff ff DISK_ACCESS equ	TRUE
    103 U433c ????						;
    104 U433c ????						; If ILTRACE is set then dump out the address of every
    105 U433c ????						; IL opcode before executing it.
    106 U433c ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    107 U433c ????						;
    108 U433c ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    109 U433c ????						;
    110 U433c ????						; If FIXED is set, put the IL code and the user
    111 U433c ????						; program space at fixed locations in memory.	This is
    112 U433c ????						; meant only for debugging.
    113 U433c ????						;
    114 U433c ????	       00 00	   FIXED      equ	FALSE
    115 U433c ????
    116 U433c ????	       00 0f	   terminalIOblockLen equ	[TerminalIOblockEnd - TerminalIOblock]
    117 U433c ????
    118 U433c ????						;
    119 U433c ????						; Sets the arithmetic stack depth.  This is *TINY*
    120 U433c ????						; BASIC, so keep this small!
    121 U433c ????						;
    122 U433c ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    123 U433c ????	       00 32	   ILSTACKSIZE equ	50	;number of entries in ilstack
    124 U433c ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    125 U433c ????	       00 25	   VARIABLESSIZE equ	37	;26 variables + 1 for exit code + 10 entries (20bytes) for ioblock
    126 U433c ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    127 U433c ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    128 U433c ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    129 U433c ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    130 U433c ????
    131 U433c ????	       00 36	   taskSTDIN  equ	[[VARIABLESSIZE - 10]*2]	;io vector
    132 U433c ????	       00 38	   taskSTDOUT equ	[[[VARIABLESSIZE - 10]*2]+2]	;io vector
    133 U433c ????
    134 U433c ????	       00 3f	   taskIOinPort equ	[[[VARIABLESSIZE - 10]*2]+4+5]	;Offset into the ioblock
    135 U433c ????	       00 3b	   taskIOoutPort equ	[[[VARIABLESSIZE - 10]*2]+4+1]	;Offset into the ioblock
    136 U433c ????	       00 46	   taskIOstatusPort equ	[[[VARIABLESSIZE - 10]*2]+4+12]	;Offset into the ioblock
    137 U433c ????						;
    138 U433c ????						; Gosub entry types
    139 U433c ????
    140 U433c ????	       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
    141 U433c ????	       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
    142 U433c ????	       00 02	   GOSUB_FOR  equ	2	; Jump point for a for function
    143 U433c ????	       00 03	   GOSUB_NEXT equ	3	; Next interation and jump point
    144 U433c ????	       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
    145 U433c ????	       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
    146 U433c ????						; 0 byte is the original stack offset, byte 1 is the parameter count
    147 U433c ????						; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
    148 U433c ????	       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
    149 U433c ????	       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
    150 U433c ????						;
    151 U433c ????						; Common ASCII constants
    152 U433c ????						;
    153 U433c ????	       00 07	   BEL	      equ	$07
    154 U433c ????	       00 08	   BS	      equ	$08
    155 U433c ????	       00 09	   TAB	      equ	$09
    156 U433c ????	       00 0a	   LF	      equ	$0A
    157 U433c ????	       00 0d	   CR	      equ	$0D
    158 U433c ????	       00 22	   quote      equ	$22
    159 U433c ????	       00 20	   SPACE      equ	$20
    160 U433c ????	       00 2c	   COMMA      equ	',
    161 U433c ????	       00 3b	   SEMICOLON  equ	';
    162 U433c ????	       00 3a	   COLON      equ	':
    163 U433c ????	       00 24	   DOLLAR     equ	'$
    164 U433c ????						;
    165 U433c ????						; These are error codes
    166 U433c ????						;
    167 U433c ????	       00 00	   ERR_NONE   equ	0	;No Errror
    168 U433c ????	       00 01	   ERR_EXPR   equ	1	;expression error
    169 U433c ????	       00 02	   ERR_UNDER  equ	2	;The Math stack underflow
    170 U433c ????	       00 03	   ERR_OVER   equ	3	;The Math stack overflow
    171 U433c ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    172 U433c ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    173 U433c ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    174 U433c ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    175 U433c ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    176 U433c ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    177 U433c ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    178 U433c ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    179 U433c ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;the gosub Stack overflow
    180 U433c ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    181 U433c ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    182 U433c ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    183 U433c ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    184 U433c ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    185 U433c ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    186 U433c ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    187 U433c ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    188 U433c ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    189 U433c ????	       00 16	   ERR_EXPECTVAR equ	22	;Expected a variable name or definition
    190 U433c ????	       00 17	   ERR_CLOSINGBRACKET equ	23	;Expected a closing bracket
    191 U433c ????	       00 18	   ERR_MISSINGEQUALSIGN equ	24	;Expected an equal sign for assignment
    192 U433c ????	       00 19	   ERR_FUNCTION_EXPECTED_PARAMETERS equ	25	;Function expected parameters
    193 U433c ????	       00 1a	   ERR_EXPECTED_OPENING_BRACKET equ	26	;Expected opening bracket [ or (
    194 U433c ????						;
    195 U433c ????						;=====================================================
    196 U433c ????						; Zero page storage.
    197 U433c ????						;
    198 U00f6 ????				      SEG.U	ZEROPAGE
    199 U0040					      org	$0040
    200 U0040
    201 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    202 U0041
    203 U0041							; The context is used to locate a task switch
    204 U0041							; it copies from here till all task fields are saved/swapped
    205 U0041							; The max number of tasks is 256 / context length
    206 U0041							; All positions POS values are plus one task table incldues
    207 U0041							; a leading status byte .
    208 U0041							;
    209 U0041		       00 41	   CONTEXT    equ	*
    210 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    211 U0041
    212 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    213 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    214 U0043
    215 U0043		       00 00	   ILPC       ds	2	; IL program counter
    216 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    217 U0047		       00	   ILSTACKPTR ds	1
    218 U0048
    219 U0048
    220 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    221 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    222 U004a
    223 U004a
    224 U004a		       00	   MATHSTACKPTR ds	1
    225 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    226 U004b
    227 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    228 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT + 1	; Get the offset to the gosub/msg stack
    229 U004d
    230 U004d
    231 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    232 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    233 U004e
    234 U004e
    235 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    236 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    237 U004f							;
    238 U004f							; CURPTR is a pointer to curent BASIC line being
    239 U004f							; executed.  Always points to start of line, CUROFF
    240 U004f							; is the offset to the current character.
    241 U004f							; The order of these fields is important
    242 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    243 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    244 U0052							;
    245 U0052							;The order of these fields in important
    246 U0052
    247 U0052							;
    248 U0052							; R0, R1 and MQ are used for arithmetic operations and
    249 U0052							; general use.
    250 U0052							;
    251 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    252 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    253 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    254 U0056		       00 00	   MQ	      ds	2	;used for some math
    255 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    256 U0058		       00 59	   REGISTERSEND equ	*
    257 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    258 U0059
    259 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    260 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    261 U0059
    262 U0059		       00 00	   dpl	      ds	2	; Used as a pointer to call il instructions
    263 U005b							;
    264 U005b							; This is zero if in immediate mode, or non-zero
    265 U005b							; if currently running a program.  Any input from
    266 U005b							; the main loop clears this, and the XFER IL
    267 U005b							; statement will set it.
    268 U005b							;
    269 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    270 U005c							;
    271 U005c							; Used for line insertion/removal.
    272 U005c							;
    273 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    274 U005e
    275 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    276 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    277 U005e							;
    278 U005e		       00 00	   PrtFrom    ds	2	; FROM
    279 U0060
    280 U0060							;
    281 U0060							;=====================================================
    282 U0060							;
    283  3666 ????				      SEG	Code
    284  0200					      org	$0200
    285  0200							;
    286  0200							; Cold start is at $0200.  Warm start is at $0203.
    287  0200							;
    288  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    289  0203		       4c 82 02    warm       jmp	warm2	;Entry point for worm restart
    290  0206							;
    291  0206							; These are the user-supplied vectors to I/O routines.
    292  0206							; If you want, you can just patch these in the binary
    293  0206							; file, but it would be better to change the source
    294  0206							; code.
    295  0206							;
    296  0206				  -	      if	KIM
    297  0206				  -OUTCH      jmp	$1ea0	;output char in A
    298  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    299  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    300  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    301  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    302  0206					      endif
    303  0206				  -	      if	XKIM
    304  0206				  -	      include	"xkim.inc"
    305  0206				  -	      SEG	Code
    306  0206				  -OUTCH      jmp	$1ea0
    307  0206				  -GETCH      jmp	xkGETCH
    308  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    309  0206				  -OUTHEX     jmp	xkPRTBYT
    310  0206				  -MONITOR    jmp	extKIM
    311  0206				  -puts       equ	putsil
    312  0206				  -BUFFER_SIZE equ	132
    313  0206					      endif
    314  0206
    315  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0060					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    317 Udf8e
    318  0206					      SEG	Code
    319  0206							;
    320  0206		       f0 0c	   OUTCH      equ	cout
    321  0206		       f0 09	   GETCH      equ	cin
    322  0206		       2d 78	   CRLF       equ	tbcrlf
    323  0206		       21 99	   OUTHEX     equ	HexToOut
    324  0206		       f0 03	   MONITOR    equ	WARM
    325  0206		       f0 0f	   ISCHAR     equ	cstatus
    326  0206		       21 b6	   puts       equ	tbputs
    327  0206					      endif
    328  0206							;
    329  0206		       20 bf 2e    cold2      jsr	SetOutConsole
    330  0209		       20 cc 2e 	      jsr	SetInConsole
    331  020c		       20 b6 21 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.30  IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.30  IRQs/Tasks/Tokens"
      0  0241					      db	CR,LF,0
      1  0241		       0d 0a 00 	      .byte.b	CR,LF,0
    335  0244							;
    336  0244		       20 aa 23 	      jsr	MemInit	;setup the free space available
    337  0247
    338  0247		       a9 01	   calcstack  lda	#1
    339  0249		       8d b8 37 	      sta	taskCounter	; Initialize number of tasks to 1
    340  024c		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    341  024e		       8d ba 36 	      sta	taskTable	; mark the main task as active
    342  0251		       20 f7 25 	      jsr	taskSetStacks	; setup all the task stacks/Variables, Init task io block
    343  0254		       a9 fc		      lda	#IL&$ff
    344  0256		       85 43		      sta	ILPC
    345  0258		       a9 31		      lda	#IL>>8
    346  025a		       85 44		      sta	ILPC+1
    347  025c							;
    348  025c							;		  lda	  ProgramStart		     ; user prog
    349  025c							;		  sta	  ProgramEnd
    350  025c							;		  lda	  ProgramStart+1
    351  025c							;		  sta	  ProgramEnd+1
    352  025c							;
    353  025c
    354  025c							;  Init time slices defaults
    355  025c		       a9 02		      lda	#TASKCYCLESHIGH
    356  025e		       8d b7 37 	      sta	taskResetValue+1
    357  0261		       a9 ff		      lda	#TASKCYCLESDEFAULT
    358  0263		       8d b6 37 	      sta	taskResetValue
    359  0266							;
    360  0266							; Initialize the pseudo-random number sequence...
    361  0266							;
    362  0266		       a9 5a		      lda	#$5a
    363  0268		       8d 22 43 	      sta	rtemp1
    364  026b		       a9 9d		      lda	#%10011101
    365  026d		       8d 24 43 	      sta	random
    366  0270		       a9 5b		      lda	#%01011011
    367  0272		       8d 25 43 	      sta	random+1
    368  0275							;
    369  0275							;   Insert a Basic irq handler for the basic Language
    370  0275		       a9 3c		      lda	#ServiceIrq&$ff
    371  0277		       8d 00 df 	      sta	IRQvec
    372  027a		       a9 1a		      lda	#ServiceIrq>>8
    373  027c		       8d 01 df 	      sta	IRQvec+1
    374  027f		       4c 95 02 	      jmp	coldtwo
    375  0282
    376  0282							;
    377  0282							;
    378  0282							; This is the warm start entry point
    379  0282							;
    380  0282		       20 bf 2e    warm2      jsr	SetOutConsole
    381  0285		       20 cc 2e 	      jsr	SetInConsole
    382  0288		       20 78 2d 	      jsr	CRLF
    383  028b		       ad 1f 43 	      lda	errGoto
    384  028e		       85 43		      sta	ILPC
    385  0290		       ad 20 43 	      lda	errGoto+1
    386  0293		       85 44		      sta	ILPC+1
    387  0295							;
    388  0295							; And continue with both starts here
    389  0295							;
    390  0295				   coldtwo
    391  0295							;
    392  0295							; The ILTrace flag is now run-time settable.
    393  0295							;
    394  0295		       a9 00		      lda	#ILTRACE&$ff
    395  0297		       85 40		      sta	ILTrace
    396  0299							;
    397  0299
    398  0299		       a9 00		      lda	#0
    399  029b		       85 5b		      sta	RunMode
    400  029d		       8d 95 42 	      sta	LINBUF
    401  02a0
    402  02a0							; Clear everything from the stacks
    403  02a0
    404  02a0		       8d 2c 43 	      sta	taskIOPending	; No one waiting for io
    405  02a3		       8d 2d 43 	      sta	taskRDPending	; No one waiting for bg io
    406  02a6
    407  02a6		       20 73 26 	      jsr	taskReset
    408  02a9							;
    409  02a9		       a9 95		      lda	#LINBUF&$ff
    410  02ab		       85 4f		      sta	CURPTR
    411  02ad		       a9 42		      lda	#LINBUF>>8
    412  02af		       85 50		      sta	CURPTR+1	;fall through...
    413  02b1
    414  02b1							;=====================================================
    415  02b1							; This is the top of the IL interpreter.  This fetches
    416  02b1							; and executes the instruction currently pointed to
    417  02b1							; by ILPC and adjusts ILPC to point to the next
    418  02b1							; instruction to execute.
    419  02b1							;
    420  02b1				   NextIL
    421  02b1		       ba		      tsx		; Get the stack pointer value
    422  02b2		       e0 ff		      cpx	#$FF	; Should be empty
    423  02b4		       d0 29		      bne	ILbad	; Halt and catch fire now!
    424  02b6
    425  02b6		       ce b4 37 	      dec	taskCurrentCycles
    426  02b9		       d0 03		      bne	NextIlNow
    427  02bb		       20 9c 26 	      jsr	iTaskSwitch	;check for a task switch
    428  02be		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    429  02c0		       f0 03		      beq	NextIL2	;Skip if no bits set
    430  02c2
    431  02c2		       20 09 2e 	      jsr	dbgLine	;Print the IL trace information
    432  02c5
    433  02c5		       a4 51	   NextIL2    ldy	CUROFF
    434  02c7							;		  jsr	  SkipSpaces	       ; no longer needed as tokenizer takes care of this
    435  02c7							;		  sty	  CUROFF
    436  02c7							;Task IO Management
    437  02c7		       ad 2d 43 	      lda	taskRDPending	; if it is zero then Nothing pending
    438  02ca		       f0 08		      beq	NextILStr
    439  02cc		       20 b1 2b 	      jsr	ReadLine	; else Pending and poll keyboard
    440  02cf		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    441  02d1		       ce 2d 43 	      dec	taskRDPending	; Carry is set if CR has been recieved
    442  02d4							;
    443  02d4		       20 34 2a    NextILStr  jsr	getILByte
    444  02d7							;
    445  02d7							; When the handler is called, these are the conditions
    446  02d7							; of several important items:
    447  02d7							;
    448  02d7							;    (ILPC) will point to the byte AFTER the IL
    449  02d7							;    opcode being executed.
    450  02d7							;
    451  02d7							;    (CURPTR),CUROFF will point to the start of the
    452  02d7							;    next word in the input buffer.  Ie, the next word
    453  02d7							;    in the user program.
    454  02d7							;
    455  02d7		       18		      clc		; Clear carry before shift
    456  02d8		       0a		      asl		; valid for 0-127
    457  02d9		       b0 04		      bcs	ILbad	; Out of range
    458  02db		       aa		      tax		; Move value to x
      0  02dc					      db	$7c	; jmp (ILTBL,X) ; dasm does not support 65c02 inst
      1  02dc		       7c		      .byte.b	$7c
      0  02dd					      dw	ILTBL	; Actual IL table address
      1  02dd		       20 03		      .word.w	ILTBL
    461  02df
    462  02df							;		asl
    463  02df							;		cmp	#ILTBLend-ILTBL+2
    464  02df							;		bcc	ILgood
    465  02df							;
    466  02df							; This handles an illegal IL opcode.  This is serious
    467  02df							; and there's no way to recover.
    468  02df							;
    469  02df				   iBadOP
    470  02df		       20 b6 21    ILbad      jsr	puts
      0  02e2					      db	CR,LF
      1  02e2		       0d 0a		      .byte.b	CR,LF
      0  02e4					      db	"Illegal IL "
      1  02e4		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02ef					      db	0
      1  02ef		       00		      .byte.b	0
    474  02f0							;
    475  02f0							; Well this is awkward, we need to back up the IL
    476  02f0							; by one since it no longer points to the current
    477  02f0							; opcode.
    478  02f0							;
    479  02f0		       20 41 2a 	      jsr	decIL
    480  02f3							;
    481  02f3		       a0 00		      ldy	#0
    482  02f5		       b1 43		      lda	(ILPC),y
    483  02f7		       20 99 21 	      jsr	OUTHEX
    484  02fa		       20 b6 21 	      jsr	puts
      0  02fd					      db	" at ",0
      1  02fd		       20 61 74 20*	      .byte.b	" at ",0
    486  0302		       a5 44		      lda	ILPC+1
    487  0304		       20 99 21 	      jsr	OUTHEX
    488  0307		       a5 43		      lda	ILPC
    489  0309		       20 99 21 	      jsr	OUTHEX
    490  030c		       20 78 2d 	      jsr	CRLF
    491  030f		       4c 03 f0 	      jmp	MONITOR
    492  0312							;
    493  0312							; Just jump to the address (ILPC),y.  Have to do
    494  0312							; some goofy stuff.
    495  0312							;
    496  0312		       a8	   ILgood     tay		;move index into Y
    497  0313		       b9 20 03 	      lda	ILTBL,y
    498  0316		       85 59		      sta	dpl
    499  0318		       b9 21 03 	      lda	ILTBL+1,y
    500  031b		       85 5a		      sta	dpl+1
    501  031d		       6c 59 00 	      jmp	(dpl)	;go to handler
    502  0320							;
    503  0320							;=====================================================
    504  0320							; This is the IL jump table.  The IL opcode is
    505  0320							; mulitplied by two, then looked-up in this table.
    506  0320							; There is absolutely nothing special about the order
    507  0320							; of entries here... they all decode at exactly the
    508  0320							; same speed.	However the entry number must match the
    509  0320							; values in IL.inc.
    510  0320							;
    511  0320				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0320					      include	"ilvectortable.asm"
      1  0320					      seg	Code
      2  0320				   ILTBL1
      0  0320					      dw	iXINIT	;0
      1  0320		       58 04		      .word.w	iXINIT
      0  0322					      dw	iDONE	;1
      1  0322		       75 04		      .word.w	iDONE
      0  0324					      dw	iPRS	;2
      1  0324		       8c 04		      .word.w	iPRS
      0  0326					      dw	iPRN	;3
      1  0326		       94 04		      .word.w	iPRN
      0  0328					      dw	iSPC	;4
      1  0328		       9d 04		      .word.w	iSPC
      0  032a					      dw	iNLINE	;5
      1  032a		       44 09		      .word.w	iNLINE
      0  032c					      dw	iNXT	;6
      1  032c		       a5 04		      .word.w	iNXT
      0  032e					      dw	iXFER	;7
      1  032e		       e7 04		      .word.w	iXFER
      0  0330					      dw	iSAV	;8
      1  0330		       05 05		      .word.w	iSAV
      0  0332					      dw	iRSTR	;9
      1  0332		       72 25		      .word.w	iRSTR
      0  0334					      dw	iCMPR	;10
      1  0334		       4b 05		      .word.w	iCMPR
      0  0336					      dw	iINNUM	;11
      1  0336		       ca 05		      .word.w	iINNUM
      0  0338					      dw	iFIN	;12
      1  0338		       02 06		      .word.w	iFIN
      0  033a					      dw	iERR	;13
      1  033a		       16 06		      .word.w	iERR
      0  033c					      dw	iADD	;14
      1  033c		       9f 06		      .word.w	iADD
      0  033e					      dw	iSUB	;15
      1  033e		       b5 06		      .word.w	iSUB
      0  0340					      dw	iNEG	;16
      1  0340		       cb 06		      .word.w	iNEG
      0  0342					      dw	iMUL	;17
      1  0342		       e3 06		      .word.w	iMUL
      0  0344					      dw	iDIV	;18
      1  0344		       23 07		      .word.w	iDIV
      0  0346					      dw	iSTORE	;19
      1  0346		       7b 07		      .word.w	iSTORE
      0  0348					      dw	iIND	;20
      1  0348		       99 07		      .word.w	iIND
      0  034a					      dw	iLST	;21
      1  034a		       3a 08		      .word.w	iLST
      0  034c					      dw	iINIT	;22
      1  034c		       20 04		      .word.w	iINIT
      0  034e					      dw	iGETLINE	;23
      1  034e		       70 08		      .word.w	iGETLINE
      0  0350					      dw	iINSRT	;24
      1  0350		       8d 08		      .word.w	iINSRT
      0  0352					      dw	iRTN	;25
      1  0352		       3e 09		      .word.w	iRTN
      0  0354					      dw	MONITOR	;26
      1  0354		       03 f0		      .word.w	MONITOR
      0  0356					      dw	iLIT	;27
      1  0356		       68 09		      .word.w	iLIT
      0  0358					      dw	iCALL	;28
      1  0358		       4a 09		      .word.w	iCALL
      0  035a					      dw	iJMP	;29
      1  035a		       56 09		      .word.w	iJMP
      0  035c					      dw	iVINIT	;30
      1  035c		       8d 09		      .word.w	iVINIT
      0  035e					      dw	iERRGOTO	;31
      1  035e		       96 09		      .word.w	iERRGOTO
      0  0360					      dw	iTST	;32
      1  0360		       a2 09		      .word.w	iTST
      0  0362					      dw	iTSTV	;33
      1  0362		       c7 0a		      .word.w	iTSTV
      0  0364					      dw	iTSTL	;34
      1  0364		       6d 0b		      .word.w	iTSTL
      0  0366					      dw	iTSTN	;35
      1  0366		       88 0b		      .word.w	iTSTN
      0  0368					      dw	iFREE	;36
      1  0368		       41 0c		      .word.w	iFREE
      0  036a					      dw	iRANDOM	;37
      1  036a		       47 0c		      .word.w	iRANDOM
      0  036c					      dw	iABS	;38
      1  036c		       18 0d		      .word.w	iABS
     42  036e							;
     43  036e							; Disk functions.  There must be pointers
     44  036e							; to functions even if no disk is supported.
     45  036e							; Makes things easier in IL.inc.
     46  036e							;
     47  036e					      if	DISK_ACCESS
      0  036e					      dw	iOPENREAD	;39
      1  036e		       18 30		      .word.w	iOPENREAD
      0  0370					      dw	iOPENWRITE	;40
      1  0370		       79 30		      .word.w	iOPENWRITE
      0  0372					      dw	iDCLOSE	;41
      1  0372		       0d 31		      .word.w	iDCLOSE
      0  0374					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0374		       9b 30		      .word.w	iDGETLINE
      0  0376					      dw	iDLIST	;43 Did you remember your towel?
      1  0376		       07 31		      .word.w	iDLIST
      0  0378					      dw	iDDIR	;44
      1  0378		       e2 30		      .word.w	iDDIR
      0  037a					      dw	iRMFILE	;45
      1  037a		       67 30		      .word.w	iRMFILE
     55  037c				  -	      else
     56  037c				  -	      dw	NextIL	;39
     57  037c				  -	      dw	NextIL	;40
     58  037c				  -	      dw	NextIL	;41
     59  037c				  -	      dw	NextIL	;42
     60  037c				  -	      dw	NextIL	;43
     61  037c				  -	      dw	NextIL	;44
     62  037c				  -	      dw	NextIL	;45
     63  037c					      endif
     64  037c							;
      0  037c					      dw	iCLEARSCREEN	;46
      1  037c		       d9 2e		      .word.w	iCLEARSCREEN
      0  037e					      dw	iPOKEMEMORY	;47
      1  037e		       a5 0c		      .word.w	iPOKEMEMORY
      0  0380					      dw	iPEEKMEMORY	;48
      1  0380		       ba 0c		      .word.w	iPEEKMEMORY
      0  0382					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0382		       e9 09		      .word.w	iTSTLET
      0  0384					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0384		       6e 0a		      .word.w	iTSTDONE
      0  0386					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0386		       e7 0c		      .word.w	iGETCHAR
      0  0388					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0388		       fb 0c		      .word.w	iPUTCHAR
      0  038a					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  038a		       d0 0c		      .word.w	iCallFunc
      0  038c					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  038c		       98 05		      .word.w	iBranch
      0  038e					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  038e		       cc 09		      .word.w	iTSTStr
      0  0390					      dw	iSetIrq	;56	   sets the irq handler
      1  0390		       bf 0d		      .word.w	iSetIrq
      0  0392					      dw	iTstIrq	;57	   test if irq is pending
      1  0392		       ff 0b		      .word.w	iTstIrq
      0  0394					      dw	iRET	;58	   return from interupt
      1  0394		       39 05		      .word.w	iRET
      0  0396					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0396		       e3 05		      .word.w	iINSTR
      0  0398					      dw	iMOD	;60	   returns remainder of division
      1  0398		       2c 07		      .word.w	iMOD
      0  039a					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  039a		       f0 26		      .word.w	iTaskSet
      0  039c					      dw	iETask	;62	   Terminates a task
      1  039c		       2d 28		      .word.w	iETask
      0  039e					      dw	iNTask	;63	   goto next task
      1  039e		       e0 27		      .word.w	iNTask
     83  03a0				   ILTBL2
      0  03a0					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a0		       b8 07		      .word.w	iArray
      0  03a2					      dw	iTaskKill	;65	   kill a running task
      1  03a2		       d8 27		      .word.w	iTaskKill
      0  03a4					      dw	iTaskStat	;66	   return the state of a task PID
      1  03a4		       ac 27		      .word.w	iTaskStat
      0  03a6					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03a6		       06 0d		      .word.w	iHexOut
      0  03a8					      dw	iReadComplete	;68	   Called after a background read completes
      1  03a8		       b4 05		      .word.w	iReadComplete
      0  03aa					      dw	iReadStart	;69	   Called to start a background read request
      1  03aa		       aa 05		      .word.w	iReadStart
      0  03ac					      dw	iStartIO	;70	   Lock task until io complete
      1  03ac		       10 28		      .word.w	iStartIO
      0  03ae					      dw	iEndIO	;71	   release task lock for io
      1  03ae		       16 28		      .word.w	iEndIO
      0  03b0					      dw	iLogNot	;72	   Logical not
      1  03b0		       71 0d		      .word.w	iLogNot
      0  03b2					      dw	iLogOr	;73	   Logical Or
      1  03b2		       47 0d		      .word.w	iLogOr
      0  03b4					      dw	iLogAnd	;74	   Logical And
      1  03b4		       32 0d		      .word.w	iLogAnd
      0  03b6					      dw	iLogXor	;75	   Logical Xor
      1  03b6		       5c 0d		      .word.w	iLogXor
      0  03b8					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03b8		       eb 27		      .word.w	iWTASK
      0  03ba					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03ba		       21 28		      .word.w	iTASKPID
      0  03bc					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03bc		       fd 0d		      .word.w	iTRACEPROG
      0  03be					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03be		       85 2d		      .word.w	idbgBasic
      0  03c0					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c0		       0d 29		      .word.w	iIPCS
      0  03c2					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c2		       24 29		      .word.w	iIPCR
      0  03c4					      dw	iIPCC	;82	   Check if any message available for task
      1  03c4		       38 29		      .word.w	iIPCC
      0  03c6					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03c6		       45 29		      .word.w	iIPCIO
      0  03c8					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03c8		       d8 24		      .word.w	iPushMathStack
      0  03ca					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03ca		       08 25		      .word.w	iPopMathStack
      0  03cc					      dw	iSaveMathStack	;86	   Save all math info
      1  03cc		       25 25		      .word.w	iSaveMathStack
      0  03ce					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03ce		       44 25		      .word.w	iRestoreMathStack
      0  03d0					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d0		       f5 24		      .word.w	iIncParmCount
      0  03d2					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d2		       4d 28		      .word.w	iTaskGetMathStack
      0  03d4					      dw	iTaskEnable	;90	   enable a suspended task
      1  03d4		       7a 27		      .word.w	iTaskEnable
      0  03d6					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03d6		       94 27		      .word.w	iTaskSuspend
      0  03d8					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03d8		       67 28		      .word.w	iTaskPutMathPtr
      0  03da					      dw	iTSTVT	;93	   test for another tasks variable
      1  03da		       be 0a		      .word.w	iTSTVT
      0  03dc					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03dc		       60 09		      .word.w	iSetR2
      0  03de					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03de		       17 05		      .word.w	iStk2Tmp
      0  03e0					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e0		       28 05		      .word.w	iTmp2Stk
      0  03e2					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e2		       0a 0a		      .word.w	iTSTBYTE
      0  03e4					      dw	iINCVAR	;98	   Increment variable
      1  03e4		       90 0a		      .word.w	iINCVAR
      0  03e6					      dw	iDECVAR	;99	   Decrement variable
      1  03e6		       a8 0a		      .word.w	iDECVAR
      0  03e8					      dw	iSLICE	;100	   set the time slice for tasks
      1  03e8		       a0 28		      .word.w	iSLICE
      0  03ea					      dw	iTSTB	;101	   Test if byte equals
      1  03ea		       29 0a		      .word.w	iTSTB
      0  03ec					      dw	iTSTW	;102	   Test If word equals
      1  03ec		       44 0a		      .word.w	iTSTW
      0  03ee					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03ee		       4f 1f		      .word.w	iOnGoto
      0  03f0					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03f0		       80 1f		      .word.w	iTSTRELOP
      0  03f2					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03f2		       cb 04		      .word.w	iRepeatLine
      0  03f4					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch if is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03f4		       a7 1f		      .word.w	iTSTBRANCH
      0  03f6					      dw	iFastXfer	;107	   move top of stack to curptr
      1  03f6		       d2 04		      .word.w	iFastXfer
      0  03f8					      dw	iSetTerminal	;108	   Set the Io Terminal to be used by print and input statements
      1  03f8		       5b 2f		      .word.w	iSetTerminal
      0  03fa					      dw	iINDB	;109	   fetch a single byte from memory indirect
      1  03fa		       a6 07		      .word.w	iINDB
      0  03fc					      dw	iSetBlock	;110	   Set a block or words or byte to a value 16 bit length
      1  03fc		       ff 23		      .word.w	iSetBlock
      0  03fe					      dw	iCopyBlock	;111	   Copy a block or memory from one location to another 16 bit length
      1  03fe		       55 24		      .word.w	iCopyBlock
      0  0400					      dw	iCmpBlock	;112	   Compare to parts of memory
      1  0400		       89 24		      .word.w	iCmpBlock
      0  0402					      dw	iShift	;113	   Shift left 0 or right 1
      1  0402		       95 0d		      .word.w	iShift
      0  0404					      dw	iTimer	;114	   Start/Stop/Set timer and enable disable system irq
      1  0404		       74 19		      .word.w	iTimer
    135  0406
      0  0406					      dw	iBadOP	;115	   Invalid IL op code
      1  0406		       df 02		      .word.w	iBadOP
      0  0408					      dw	iBadOP	;116	   Invalid IL op code
      1  0408		       df 02		      .word.w	iBadOP
      0  040a					      dw	iBadOP	;117	   Invalid IL op code
      1  040a		       df 02		      .word.w	iBadOP
      0  040c					      dw	iBadOP	;118	   Invalid IL op code
      1  040c		       df 02		      .word.w	iBadOP
      0  040e					      dw	iBadOP	;119	   Invalid IL op code
      1  040e		       df 02		      .word.w	iBadOP
      0  0410					      dw	iBadOP	;120	   Invalid IL op code
      1  0410		       df 02		      .word.w	iBadOP
      0  0412					      dw	iBadOP	;121	   Invalid IL op code
      1  0412		       df 02		      .word.w	iBadOP
      0  0414					      dw	iBadOP	;122	   Invalid IL op code
      1  0414		       df 02		      .word.w	iBadOP
      0  0416					      dw	iBadOP	;123	   Invalid IL op code
      1  0416		       df 02		      .word.w	iBadOP
      0  0418					      dw	iBadOP	;124	   Invalid IL op code
      1  0418		       df 02		      .word.w	iBadOP
      0  041a					      dw	iBadOP	;125	   Invalid IL op code
      1  041a		       df 02		      .word.w	iBadOP
      0  041c					      dw	iBadOP	;126	   Invalid IL op code
      1  041c		       df 02		      .word.w	iBadOP
      0  041e					      dw	iBadOP	;127	   Invalid IL op code
      1  041e		       df 02		      .word.w	iBadOP
    149  0420
    150  0420
    151  0420
    152  0420
------- FILE mytb.asm
    513  0420		       04 20	   ILTBLend   equ	*
    514  0420
    515  0420							;
    516  0420							;=====================================================
    517  0420							;=====================================================
    518  0420							;=====================================================
    519  0420							; This marks the start of the handlers for IL opcodes.
    520  0420							;=====================================================
    521  0420							;=====================================================
    522  0420							;=====================================================
    523  0420							;
    524  0420							;
    525  0420		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    526  0422		       85 47		      sta	ILSTACKPTR
    527  0424		       85 4a		      sta	MATHSTACKPTR
    528  0426		       85 4d		      sta	GOSUBSTACKPTR
    529  0428		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    530  042a		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    531  042c							;
    532  042c		       ad 32 43 	      lda	ProgramStart	; user prog
    533  042f		       85 4f		      sta	CURPTR
    534  0431		       8d bb 36 	      sta	taskTable+1
    535  0434		       8d 34 43 	      sta	ProgramEnd
    536  0437		       ad 33 43 	      lda	ProgramStart+1
    537  043a		       85 50		      sta	CURPTR+1
    538  043c		       8d bc 36 	      sta	taskTable+2
    539  043f		       8d 35 43 	      sta	ProgramEnd+1
    540  0442		       a9 80		      lda	#TASKACTIVE
    541  0444		       8d ba 36 	      sta	taskTable	;Mark the first slot as active
    542  0447		       a9 01		      lda	#1
    543  0449		       8d b8 37 	      sta	taskCounter	;there is always one task / Main task
    544  044c		       ad b6 37 	      lda	taskResetValue
    545  044f		       8d b4 37 	      sta	taskCurrentCycles	; set up the task switch counts
    546  0452		       ad b7 37 	      lda	taskResetValue+1
    547  0455		       8d b5 37 	      sta	taskCurrentCycles+1
    548  0458							;
    549  0458							; fall into XINIT...
    550  0458							;
    551  0458							;=====================================================
    552  0458							; This initializes for the start of the next line of
    553  0458							; BASIC text.
    554  0458							;
    555  0458		       78	   iXINIT     sei		; ensure interupts are off
    556  0459		       20 73 26 	      jsr	taskReset	; Clear the task table
    557  045c		       a9 00		      lda	#0	; Clear the irq flags
    558  045e		       8d c1 19 	      sta	IRQPending	; reset the irq pending
    559  0461		       8d c0 19 	      sta	IRQStatus	; Make sure irqs are off
    560  0464
    561  0464		       4c b1 02    goodExit   jmp	NextIL
    562  0467							;
    563  0467							;=====================================================
    564  0467							; This check if the escape key has been entered
    565  0467							; then changes out of run mode. z Set if esc found
    566  0467				   BreakSet
    567  0467		       20 0f f0 	      jsr	ISCHAR
    568  046a		       f0 06		      beq	BreakNo
    569  046c		       20 61 1a 	      jsr	VGETCH
    570  046f		       c9 1b		      cmp	#$1B
    571  0471		       60		      rts
    572  0472				   BreakNo
    573  0472		       a9 01		      lda	#1
    574  0474		       60		      rts
    575  0475
    576  0475							;
    577  0475
    578  0475							;=====================================================
    579  0475							; Verify there is nothing else on this input line.
    580  0475							; If there is, generate an error.
    581  0475							;
    582  0475		       a4 51	   iDONE      ldy	CUROFF
    583  0477		       b1 4f		      lda	(CURPTR),y
    584  0479		       f0 0e		      beq	doneadv
    585  047b		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    586  047d		       d0 03		      bne	idoneErr
    587  047f							;		  sty	  CUROFF
    588  047f		       4c b1 02 	      jmp	NextIL	; continue on this line
    589  0482
    590  0482				   idoneErr
    591  0482		       a2 04		      ldx	#ERR_EXTRA_STUFF
    592  0484		       a9 00		      lda	#0
    593  0486		       4c 7d 06 	      jmp	iErr2
    594  0489							;
    595  0489							; Advance to the next line
    596  0489							;
    597  0489				   doneadv
    598  0489		       4c b1 02 	      jmp	NextIL
    599  048c							;
    600  048c							;=====================================================
    601  048c							; Print the string until a closing quote
    602  048c							;
    603  048c				   iPRS
    604  048c		       20 d9 21 	      jsr	PrtQuoted
    605  048f		       84 51		      sty	CUROFF
    606  0491		       4c b1 02 	      jmp	NextIL
    607  0494							;
    608  0494							;=====================================================
    609  0494							; Pop the top off the stack and print it as a signed
    610  0494							; decimal number.
    611  0494							;
    612  0494				   iPRN
    613  0494		       20 bf 2c 	      jsr	popR0
    614  0497		       20 e5 20 	      jsr	PrintDecimal
    615  049a		       4c b1 02 	      jmp	NextIL
    616  049d							;
    617  049d							;=====================================================
    618  049d							; Space to next zone.	Currently the code does not
    619  049d							; keep track of which column the output is on, so
    620  049d							; just print a tab.
    621  049d							;
    622  049d				   iSPC
    623  049d		       a9 09		      lda	#TAB
    624  049f		       20 5e 1a 	      jsr	VOUTCH
    625  04a2		       4c b1 02 	      jmp	NextIL
    626  04a5							;
    627  04a5							;=====================================================
    628  04a5							; If in immediate mode, jump to the address following
    629  04a5							; the NXT instruction.  Else move to the next line of
    630  04a5							; user code and continue.
    631  04a5							;
    632  04a5		       a5 5b	   iNXT       lda	RunMode
    633  04a7		       d0 03		      bne	iNxtRun	;in run mode
    634  04a9							;
    635  04a9							; Get address and jump to it.
    636  04a9							;
    637  04a9		       4c 56 09 	      jmp	iJMP
    638  04ac							;
    639  04ac				   iNxtRun
    640  04ac		       a4 51		      ldy	CUROFF
    641  04ae		       b1 4f		      lda	(CURPTR),y
    642  04b0		       c9 e6		      cmp	#oColon
    643  04b2		       d0 06		      bne	iNxtRunGo
    644  04b4		       c8		      iny
    645  04b5		       84 51		      sty	CUROFF
    646  04b7		       4c c5 04 	      jmp	iNxtRun2
    647  04ba
    648  04ba				   iNxtRunGo
    649  04ba		       20 be 2a 	      jsr	FindNextLine
    650  04bd		       20 d2 2a 	      jsr	AtEnd
    651  04c0		       d0 03		      bne	iNxtRun2	;not at end
    652  04c2							;
    653  04c2							; At the end of the program.  Pretend an END statement
    654  04c2							; was found.
    655  04c2							;
    656  04c2		       4c 02 06    iFINv      jmp	iFIN
    657  04c5							;
    658  04c5		       20 30 2a    iNxtRun2   jsr	getILWord	;ignore next word
    659  04c8		       4c b1 02 	      jmp	NextIL
    660  04cb							;=====================================================
    661  04cb							;Repeat the same line against
    662  04cb		       a0 03	   iRepeatLine ldy	#3
    663  04cd		       84 51		      sty	CUROFF
    664  04cf		       4c b1 02 	      jmp	NextIL
    665  04d2							;
    666  04d2							;=====================================================
    667  04d2							; XFER takes the number on top of the stack and looks
    668  04d2							; for that line in the program, or the next line
    669  04d2							; higher.  Ie, if it's 1 but there is no line 1, then
    670  04d2							; find the next one after that.
    671  04d2							;
    672  04d2				   iFastXfer
    673  04d2		       20 d7 2c 	      jsr	popR1	; get type of transfer
    674  04d5		       a5 54		      lda	R1
    675  04d7		       f0 0e		      beq	iXFER
    676  04d9
    677  04d9		       20 bf 2c 	      jsr	popR0	; get where to transfer
    678  04dc				   FastFastXfer
    679  04dc		       a5 52		      lda	R0
    680  04de		       85 4f		      sta	CURPTR
    681  04e0		       a5 53		      lda	R0+1
    682  04e2		       85 50		      sta	CURPTR+1
    683  04e4		       4c ed 04 	      jmp	iXFER2
    684  04e7
    685  04e7				   iXFER
    686  04e7		       20 bf 2c 	      jsr	popR0
    687  04ea		       20 79 2a 	      jsr	findLine
    688  04ed
    689  04ed				   iXFER2
    690  04ed		       20 d2 2a 	      jsr	AtEnd	;at end of user program?
    691  04f0		       f0 d0		      beq	iFINv
    692  04f2
    693  04f2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    694  04f4		       84 51		      sty	CUROFF
    695  04f6
    696  04f6							;		  lda	  #$ff
    697  04f6							;		  sta	  RunMode
    698  04f6							;
    699  04f6							; Transfer IL to STMT.  I don't like having this
    700  04f6							; hard-coded; fix it.
    701  04f6							;
    702  04f6							;		  lda	  #STMT&$ff
    703  04f6							;		  sta	  ILPC
    704  04f6							;		  lda	  #STMT>>8
    705  04f6							;		  sta	  ILPC+1
    706  04f6							;		  jmp	  NextIL
    707  04f6							;
    708  04f6							; Run
    709  04f6							;
    710  04f6				   iXferok
    711  04f6		       a9 ff		      lda	#$ff
    712  04f8		       85 5b		      sta	RunMode	;we're running
    713  04fa							;
    714  04fa							; Need a more elegant way to do this
    715  04fa							;
    716  04fa		       a9 0a		      lda	#STMT&$ff
    717  04fc		       85 43		      sta	ILPC
    718  04fe		       a9 32		      lda	#STMT>>8
    719  0500		       85 44		      sta	ILPC+1
    720  0502		       4c b1 02 	      jmp	NextIL
    721  0505							;
    722  0505							;=====================================================
    723  0505							; Save the pointer to the next line to the call stack.
    724  0505							;
    725  0505		       20 34 2a    iSAV       jsr	getILByte	; load type of gosub
    726  0508		       20 47 2c 	      jsr	pushLN	; Type passed in A
    727  050b		       b0 03		      bcs	iSAVErr
    728  050d		       4c b1 02 	      jmp	NextIL
    729  0510
    730  0510		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    731  0512		       a9 00	   iSAVErr2   lda	#0
    732  0514		       4c 7d 06 	      jmp	iErr2
    733  0517							;====================================================
    734  0517							; Move stack top to and from temp area
    735  0517				   iStk2Tmp
    736  0517		       20 bf 2c 	      jsr	popR0
    737  051a		       a5 52		      lda	R0
    738  051c		       a0 48		      ldy	#TASKEXITCODE	; can also be used as temp
    739  051e		       91 41		      sta	(VARIABLES),y
    740  0520		       c8		      iny
    741  0521		       a5 53		      lda	R0+1
    742  0523		       91 41		      sta	(VARIABLES),y
    743  0525		       4c b1 02 	      jmp	NextIL
    744  0528
    745  0528		       a0 48	   iTmp2Stk   ldy	#TASKEXITCODE
    746  052a		       b1 41		      lda	(VARIABLES),y
    747  052c		       85 52		      sta	R0
    748  052e		       c8		      iny
    749  052f		       b1 41		      lda	(VARIABLES),y
    750  0531		       85 53		      sta	R0+1
    751  0533		       20 2d 2c 	      jsr	pushR0
    752  0536		       4c b1 02 	      jmp	NextIL
    753  0539							;
    754  0539							;=====================================================
    755  0539							; Pop the next line from the call stack. IRQ return
    756  0539							;
    757  0539		       20 70 2c    iRET       jsr	popLN
    758  053c		       b0 d2		      bcs	iSAVErr
    759  053e		       a0 03		      ldy	#3
    760  0540		       84 51		      sty	CUROFF
    761  0542		       a9 00		      lda	#0
    762  0544		       8d c1 19 	      sta	IRQPending
    763  0547		       58		      cli
    764  0548		       4c b1 02 	      jmp	NextIL
    765  054b							;
    766  054b							;=====================================================
    767  054b							; Compare items on stack.  Okay, so on input there are
    768  054b							; three things on the stack
    769  054b							;
    770  054b							;    EXPR2 <- Top of stack
    771  054b							;    OP    <- relational operator, next on stack
    772  054b							;    EXPR1 <- last item on stack
    773  054b							;
    774  054b							; Comparison is: EXPR1 <operator> EXPR2
    775  054b							;
    776  054b							; Operator is one of...
    777  054b							;
    778  054b							;    2 is =
    779  054b							;    1 is <
    780  054b							;    3 is <=
    781  054b							;    5 is <>
    782  054b							;    4 is >
    783  054b							;    6 is >=
    784  054b							;
    785  054b							; Those are bit-mapped:
    786  054b							;
    787  054b							;    xxxxxGEL
    788  054b							;
    789  054b							;    G = Greater than
    790  054b							;    E = Equal
    791  054b							;    L = Less than
    792  054b							;
    793  054b							; If the comparison is false, do a NXT, ie, move to the
    794  054b							; next line and continue.  If true, continue executing
    795  054b							; on this line.
    796  054b							;
    797  054b		       00 01	   REL_LT     equ	%001
    798  054b		       00 02	   REL_EQUAL  equ	%010
    799  054b		       00 04	   REL_GT     equ	%100
    800  054b							;
    801  054b		       20 d7 2c    iCMPR      jsr	popR1
    802  054e		       20 ee 2c 	      jsr	popMQ	;operator in MQ
    803  0551		       20 bf 2c 	      jsr	popR0
    804  0554		       20 5d 05 	      jsr	iCMPRsub
    805  0557		       20 2d 2c 	      jsr	pushR0
    806  055a		       4c b1 02 	      jmp	NextIL
    807  055d							;
    808  055d							; See if they are equal or not
    809  055d							;
    810  055d				   iCMPRsub		; Called by internal functions
    811  055d
    812  055d		       a5 52		      lda	R0
    813  055f		       c5 54		      cmp	R1
    814  0561		       d0 0a		      bne	iCMPRnoteq	;try not equal
    815  0563		       a5 53		      lda	R0+1
    816  0565		       c5 55		      cmp	R1+1
    817  0567		       d0 04		      bne	iCMPRnoteq
    818  0569							;
    819  0569							; Equal, set the flag in MQ+1
    820  0569							;
    821  0569		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    822  056b		       d0 14		      bne	iCMPcom	;Exit it is equal
    823  056d							;
    824  056d							; See if EXPR1 (R0) < EXPR2 (R1)
    825  056d							; See www.6502.org/tutorials/compare_beyond.html
    826  056d							;
    827  056d				   iCMPRnoteq
    828  056d		       a5 52		      lda	R0
    829  056f		       c5 54		      cmp	R1	; Sets the carry flag
    830  0571		       a5 53		      lda	R0+1
    831  0573		       e5 55		      sbc	R1+1
    832  0575
    833  0575		       50 02		      bvc	iCMPR_2	; branch if N eor V
    834  0577		       49 80		      eor	#$80
    835  0579
    836  0579		       30 04	   iCMPR_2    bmi	iCMPlt
    837  057b		       a9 04		      lda	#REL_GT
    838  057d		       d0 02		      bne	iCMPcom
    839  057f
    840  057f		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    841  0581
    842  0581				   iCMPcom		;ora	    MQ+1	 ; or with original mask MQ+1 is always zero
    843  0581							;
    844  0581							; Now compare the end result with what the caller
    845  0581							; was looking for.
    846  0581							;
    847  0581		       25 56		      and	MQ
    848  0583		       f0 0c		      beq	iCMPno	; no match
    849  0585		       a9 ff		      lda	#$FF	; true is $ffff
    850  0587		       85 52		      sta	R0
    851  0589		       85 53		      sta	R0+1
    852  058b		       d0 0a		      bne	iCMPDone
    853  058d							;
    854  058d							; R0 > R1
    855  058d							;
    856  058d		       a9 04	   iCMPgt     lda	#REL_GT
    857  058f		       d0 f0		      bne	iCMPcom
    858  0591				   iCMPno
    859  0591		       a9 00		      lda	#0
    860  0593		       85 52		      sta	R0
    861  0595		       85 53		      sta	R0+1
    862  0597
    863  0597				   iCMPDone
    864  0597		       60		      rts
    865  0598
    866  0598							;
    867  0598							; if Not a match, so jump to the next line of code.
    868  0598							; Branches based upon value on top of the stack
    869  0598				   iBranch
    870  0598		       20 bf 2c 	      jsr	popR0
    871  059b		       a5 52		      lda	R0
    872  059d		       05 53		      ora	R0+1
    873  059f		       f0 03		      beq	iBranchFalse	; not true
    874  05a1		       4c b1 02 	      jmp	NextIL	; It is true if any value not zero
    875  05a4							;
    876  05a4				   iBranchFalse
    877  05a4		       20 be 2a 	      jsr	FindNextLine
    878  05a7		       4c ed 04 	      jmp	iXFER2
    879  05aa							;
    880  05aa							;=====================================================
    881  05aa							; Start a read of data in background
    882  05aa				   iReadStart
    883  05aa		       a9 3f		      lda	#'?	; Prompt with question mark
    884  05ac		       a6 01		      ldx	1	; Indicate to start read in background
    885  05ae		       20 4a 2b 	      jsr	GetLine	; Call the getline to start read
    886  05b1		       4c b1 02 	      jmp	NextIL	; next instruction
    887  05b4							;
    888  05b4							;=====================================================
    889  05b4							; Complete the read and return the curptr, curoff pointing to data
    890  05b4				   iReadComplete
    891  05b4		       a9 01		      lda	#GOSUB_RTN
    892  05b6		       20 47 2c 	      jsr	pushLN
    893  05b9		       90 03		      bcc	iReadOk
    894  05bb		       4c 3a 0c    iReadErr   jmp	ErrStkOver	; Check if there was an error
    895  05be				   iReadOk
    896  05be		       20 6a 2b 	      jsr	ReadComplete
    897  05c1		       4c b1 02 	      jmp	NextIL
    898  05c4		       20 70 2c 	      jsr	popLN
    899  05c7		       4c b1 02 	      jmp	NextIL
    900  05ca							;=====================================================
    901  05ca							; Get a line of text from the user, convert to a
    902  05ca							; number, leave on top of stack.
    903  05ca							;
    904  05ca				   iINNUM
    905  05ca		       a9 01		      lda	#GOSUB_RTN
    906  05cc		       20 47 2c 	      jsr	pushLN
    907  05cf		       b0 ea		      bcs	iReadErr	; Stack over flow error
    908  05d1							;
    909  05d1		       a9 3f		      lda	#'?
    910  05d3		       a2 00		      ldx	#0	;Wait for complete
    911  05d5		       20 4a 2b 	      jsr	GetLine
    912  05d8		       20 df 2a 	      jsr	getDecimal
    913  05db		       20 2d 2c 	      jsr	pushR0	;put onto stack
    914  05de		       b0 db		      bcs	iReadErr	;StackOverflow error
    915  05e0							;
    916  05e0		       4c fc 05 	      jmp	ExitIn
    917  05e3							;
    918  05e3							;=====================================================
    919  05e3							; Get a line of text from the user, convert to a
    920  05e3							; character value , leave on top of stack. up to 2 characters
    921  05e3							;
    922  05e3				   iINSTR
    923  05e3		       a9 01		      lda	#GOSUB_RTN
    924  05e5		       20 47 2c 	      jsr	pushLN
    925  05e8		       b0 d1		      bcs	iReadErr	; Stack overflow error
    926  05ea		       a9 3f		      lda	#'?
    927  05ec		       a2 00		      ldx	#0	;wait for read complete
    928  05ee		       20 4a 2b 	      jsr	GetLine
    929  05f1		       b1 4f		      lda	(CURPTR),y
    930  05f3		       85 52		      sta	R0
    931  05f5		       a9 00		      lda	#0
    932  05f7		       85 53		      sta	R0+1
    933  05f9		       20 2d 2c 	      jsr	pushR0	;put onto stack
    934  05fc				   ExitIn
    935  05fc		       20 70 2c 	      jsr	popLN
    936  05ff		       4c b1 02 	      jmp	NextIL
    937  0602							;
    938  0602							;
    939  0602							;=====================================================
    940  0602							; Stop the currently running program.	Actually very
    941  0602							; simple to do... clear the RunMode flag, then set the
    942  0602							; ILPC to the standard handler and continue running.
    943  0602							;
    944  0602		       a9 00	   iFIN       lda	#0
    945  0604		       85 5b		      sta	RunMode
    946  0606		       20 73 26 	      jsr	taskReset
    947  0609							;
    948  0609		       ad 1f 43 	      lda	errGoto
    949  060c		       85 43		      sta	ILPC
    950  060e		       ad 20 43 	      lda	errGoto+1
    951  0611		       85 44		      sta	ILPC+1
    952  0613		       4c b1 02 	      jmp	NextIL
    953  0616							;
    954  0616							;=====================================================
    955  0616							; Handle the ERR opcode.  Following the instruction is
    956  0616							; a 16 bit error number.  Print an error message, and
    957  0616							; if we're in run mode, print the line number.  Stop
    958  0616							; program execution and return to the initial state.
    959  0616							;
    960  0616		       ad 2c 43    iERR       lda	taskIOPending
    961  0619		       f0 03		      beq	iErrNext
    962  061b		       ce 2c 43 	      dec	taskIOPending
    963  061e
    964  061e		       20 30 2a    iErrNext   jsr	getILWord	;get err code
    965  0621		       20 27 06 	      jsr	DisplayError
    966  0624		       4c 80 06 	      jmp	iErrComplete
    967  0627							;
    968  0627							; Enter here with the error code in X (LSB) and A (MSB).
    969  0627							;
    970  0627				   DisplayError
    971  0627		       86 52		      stx	R0
    972  0629		       85 53		      sta	R0+1
    973  062b							;
    974  062b		       20 b6 21 	      jsr	puts
      0  062e					      db	CR,LF,"Error ",0
      1  062e		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    976  0637		       20 e5 20 	      jsr	PrintDecimal
    977  063a							;
    978  063a		       a5 5b		      lda	RunMode	;running?
    979  063c		       f0 3b		      beq	iERR3	;nope
    980  063e		       20 b6 21 	      jsr	puts
      0  0641					      db	" at line ",0
      1  0641		       20 61 74 20*	      .byte.b	" at line ",0
    982  064b		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    983  064d				   iErr2a
    984  064d		       b1 4f		      lda	(CURPTR),y
    985  064f		       85 52		      sta	R0
    986  0651		       c8		      iny
    987  0652		       b1 4f		      lda	(CURPTR),y
    988  0654		       85 53		      sta	R0+1
    989  0656		       20 e5 20 	      jsr	PrintDecimal
    990  0659		       20 b6 21 	      jsr	puts
      0  065c					      db	":",0
      1  065c		       3a 00		      .byte.b	":",0
    992  065e		       a9 00		      lda	#0
    993  0660		       85 53		      sta	R0+1
    994  0662		       a5 51		      lda	CUROFF
    995  0664		       18		      clc
    996  0665		       e9 03		      sbc	#3
    997  0667		       85 52		      sta	R0
    998  0669		       20 e5 20 	      jsr	PrintDecimal
    999  066c		       20 b6 21 	      jsr	puts
      0  066f					      db	":",0
      1  066f		       3a 00		      .byte.b	":",0
   1001  0671		       ad b9 36 	      lda	taskPtr
   1002  0674		       85 52		      sta	R0
   1003  0676		       20 99 21 	      jsr	HexToOut
   1004  0679							;
   1005  0679				   iERR3
   1006  0679		       20 78 2d 	      jsr	CRLF
   1007  067c		       60		      rts
   1008  067d
   1009  067d				   iErr2
   1010  067d		       20 27 06 	      jsr	DisplayError
   1011  0680
   1012  0680				   iErrComplete
   1013  0680		       20 6b 26 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1014  0683		       a9 00		      lda	#0
   1015  0685		       85 5b		      sta	RunMode	; fall through...
   1016  0687							;
   1017  0687							;=====================================================
   1018  0687							; Reset the IL to be back at the idle loop.  Does not
   1019  0687							; clear variables so the user can see what state
   1020  0687							; the program is in.
   1021  0687							;
   1022  0687		       a9 00	   ResetIL    lda	#0
   1023  0689		       85 4f		      sta	CURPTR
   1024  068b		       85 51		      sta	CUROFF
   1025  068d		       85 47		      sta	ILSTACKPTR
   1026  068f		       ad 1f 43 	      lda	errGoto
   1027  0692		       85 43		      sta	ILPC
   1028  0694		       ad 20 43 	      lda	errGoto+1
   1029  0697		       85 44		      sta	ILPC+1
   1030  0699		       a2 ff		      ldx	#$FF	; make sure the stack pointer is reset
   1031  069b		       9a		      txs
   1032  069c		       4c b1 02 	      jmp	NextIL
   1033  069f
   1034  069f							;
   1035  069f							;=====================================================
   1036  069f							; Pop two items off stack, add them, then place the
   1037  069f							; result back onto the stack.
   1038  069f							;
   1039  069f		       20 bf 2c    iADD       jsr	popR0
   1040  06a2		       20 d7 2c 	      jsr	popR1
   1041  06a5				   iADDfast
   1042  06a5		       18		      clc
   1043  06a6		       a5 52		      lda	R0
   1044  06a8		       65 54		      adc	R1
   1045  06aa		       85 52		      sta	R0
   1046  06ac		       a5 53		      lda	R0+1
   1047  06ae		       65 55		      adc	R1+1
   1048  06b0		       85 53		      sta	R0+1
   1049  06b2		       4c 1d 07 	      jmp	pushR0nextIl
   1050  06b5							;
   1051  06b5							;=====================================================
   1052  06b5							; Pop two items off the stack.  Subtract the top of
   1053  06b5							; stack from the lower entry.
   1054  06b5							;
   1055  06b5		       20 d7 2c    iSUB       jsr	popR1
   1056  06b8		       20 bf 2c 	      jsr	popR0
   1057  06bb		       38		      sec
   1058  06bc		       a5 52		      lda	R0
   1059  06be		       e5 54		      sbc	R1
   1060  06c0		       85 52		      sta	R0
   1061  06c2		       a5 53		      lda	R0+1
   1062  06c4		       e5 55		      sbc	R1+1
   1063  06c6		       85 53		      sta	R0+1
   1064  06c8		       4c 1d 07 	      jmp	pushR0nextIl
   1065  06cb							;
   1066  06cb							;=====================================================
   1067  06cb							; Negate the top of stack.
   1068  06cb							;
   1069  06cb		       20 bf 2c    iNEG       jsr	popR0
   1070  06ce		       a5 52		      lda	R0
   1071  06d0		       49 ff		      eor	#$ff
   1072  06d2		       85 52		      sta	R0
   1073  06d4		       a5 53		      lda	R0+1
   1074  06d6		       49 ff		      eor	#$ff
   1075  06d8		       85 53		      sta	R0+1
   1076  06da		       e6 52		      inc	R0
   1077  06dc		       d0 02		      bne	iNEG2
   1078  06de		       e6 53		      inc	R0+1
   1079  06e0		       4c 1d 07    iNEG2      jmp	pushR0nextIl
   1080  06e3							;
   1081  06e3							;=====================================================
   1082  06e3							; Multiply top two items on the stack, put the results
   1083  06e3							; on top.  This uses the algorithm documented on page
   1084  06e3							; 115 of "Microprocessor Programming for Computer
   1085  06e3							; Hobbyists" by Neill Graham.
   1086  06e3							;
   1087  06e3		       20 e9 06    iMUL       jsr	iMultiply
   1088  06e6		       4c b1 02 	      jmp	NextIL
   1089  06e9
   1090  06e9				   iMultiply
   1091  06e9		       20 bf 2c 	      jsr	popR0	;AC
   1092  06ec		       20 d7 2c 	      jsr	popR1	;OP
   1093  06ef							;
   1094  06ef		       a5 52		      lda	R0
   1095  06f1		       85 56		      sta	MQ
   1096  06f3		       a5 53		      lda	R0+1
   1097  06f5		       85 57		      sta	MQ+1
   1098  06f7		       a9 00		      lda	#0	;clear result
   1099  06f9		       85 52		      sta	R0
   1100  06fb		       85 53		      sta	R0+1
   1101  06fd							;
   1102  06fd		       a2 10		      ldx	#16	;number of bits in value
   1103  06ff		       06 52	   multloop   asl	R0
   1104  0701		       26 53		      rol	R0+1
   1105  0703		       06 56		      asl	MQ
   1106  0705		       26 57		      rol	MQ+1
   1107  0707		       90 0d		      bcc	multno	;skip add if no carry
   1108  0709							;
   1109  0709							; Add R1 back into R0
   1110  0709							;
   1111  0709		       18		      clc
   1112  070a		       a5 52		      lda	R0
   1113  070c		       65 54		      adc	R1
   1114  070e		       85 52		      sta	R0
   1115  0710		       a5 53		      lda	R0+1
   1116  0712		       65 55		      adc	R1+1
   1117  0714		       85 53		      sta	R0+1
   1118  0716							;
   1119  0716		       ca	   multno     dex		;did all bits yet?
   1120  0717		       d0 e6		      bne	multloop
   1121  0719		       20 2d 2c 	      jsr	pushR0	;OP
   1122  071c		       60		      rts
   1123  071d							;
   1124  071d				   pushR0nextIl
   1125  071d		       20 2d 2c 	      jsr	pushR0	;OP
   1126  0720		       4c b1 02 	      jmp	NextIL
   1127  0723							;
   1128  0723							;=====================================================
   1129  0723							; Divide the top of stack into the next to top item.
   1130  0723							; Leave results on stack.  Taken from:
   1131  0723							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1132  0723							;
   1133  0723							; R0 = R0 / R1
   1134  0723							; Remainder is in MQ
   1135  0723							;
   1136  0723		       20 3d 07    iDIV       jsr	iDoDiv
   1137  0726		       20 40 2d 	      jsr	RestoreSigns
   1138  0729		       4c 1d 07 	      jmp	pushR0nextIl
   1139  072c
   1140  072c		       20 3d 07    iMOD       jsr	iDoDiv
   1141  072f		       20 40 2d 	      jsr	RestoreSigns
   1142  0732		       a5 56		      lda	MQ
   1143  0734		       85 52		      sta	R0
   1144  0736		       a5 57		      lda	MQ+1
   1145  0738		       85 53		      sta	R0+1
   1146  073a		       4c 1d 07 	      jmp	pushR0nextIl
   1147  073d
   1148  073d				   iDoDiv
   1149  073d		       20 d7 2c 	      jsr	popR1
   1150  0740		       20 bf 2c 	      jsr	popR0
   1151  0743							;
   1152  0743							; Check for divide by zero
   1153  0743							;
   1154  0743
   1155  0743				   iDivNoPop
   1156  0743		       a5 54		      lda	R1
   1157  0745		       05 55		      ora	R1+1
   1158  0747		       f0 29		      beq	divby0
   1159  0749							;
   1160  0749		       20 05 2d 	      jsr	SaveSigns
   1161  074c		       a9 00		      lda	#0	;preset remainder to 0
   1162  074e		       85 56		      sta	MQ
   1163  0750		       85 57		      sta	MQ+1
   1164  0752		       a2 10		      ldx	#16	;repeat for each bit: ...
   1165  0754				   divloop
   1166  0754		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1167  0756		       26 53		      rol	R0+1
   1168  0758		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1169  075a		       26 57		      rol	MQ+1
   1170  075c		       a5 56		      lda	MQ
   1171  075e		       38		      sec
   1172  075f		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1173  0761		       a8		      tay		;lb result -> Y, for we may need it later
   1174  0762		       a5 57		      lda	MQ+1
   1175  0764		       e5 55		      sbc	R1+1
   1176  0766		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1177  0768
   1178  0768		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1179  076a		       84 56		      sty	MQ
   1180  076c		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1181  076e
   1182  076e		       ca	   skip       dex
   1183  076f		       d0 e3		      bne	divloop
   1184  0771		       60		      rts
   1185  0772							;
   1186  0772							; Indicate divide-by-zero error
   1187  0772							;
   1188  0772		       68	   divby0     pla		; remove the reyurn from the stack
   1189  0773		       68		      pla
   1190  0774		       a2 06		      ldx	#ERR_DIVIDE_ZERO	; do the error
   1191  0776		       a9 00		      lda	#0
   1192  0778		       4c 7d 06 	      jmp	iErr2
   1193  077b							;
   1194  077b							;=====================================================
   1195  077b							; This pops the top two items off the stack.  The top
   1196  077b							; item is a data value and the other is an ABSOLUTE address.
   1197  077b							; Save the value into that address.
   1198  077b							;
   1199  077b		       98	   iSTORE     tya
   1200  077c		       48		      pha
   1201  077d		       20 bf 2c 	      jsr	popR0	;data
   1202  0780		       20 d7 2c 	      jsr	popR1	;Storage location
   1203  0783		       a0 01		      ldy	#1
   1204  0785		       a5 58		      lda	R2
   1205  0787		       c9 a2		      cmp	#tByte
   1206  0789		       f0 04		      beq	iStoreB
   1207  078b				   iStoreW
   1208  078b		       a5 53		      lda	R0+1
   1209  078d		       91 54		      sta	(R1),y
   1210  078f				   iStoreB
   1211  078f		       a5 52		      lda	R0
   1212  0791		       88		      dey
   1213  0792		       91 54		      sta	(R1),y
   1214  0794		       68		      pla
   1215  0795		       a8		      tay
   1216  0796		       4c b1 02 	      jmp	NextIL
   1217  0799							;
   1218  0799							;=====================================================
   1219  0799							; Replaces the top of stack with the Value
   1220  0799							; of the variable  whose absolute address it represents.
   1221  0799							;
   1222  0799
   1223  0799		       98	   iIND       tya
   1224  079a		       48		      pha
   1225  079b		       20 d7 2c 	      jsr	popR1
   1226  079e		       a0 01		      ldy	#1
   1227  07a0		       a5 58		      lda	R2
   1228  07a2		       c9 a4		      cmp	#tInteger
   1229  07a4		       f0 04		      beq	iINDW
   1230  07a6				   iINDB
   1231  07a6		       a9 00		      lda	#0
   1232  07a8		       f0 02		      BEQ	iINDC
   1233  07aa				   iINDW
   1234  07aa		       b1 54		      lda	(R1),y
   1235  07ac				   iINDC
   1236  07ac		       85 53		      sta	R0+1
   1237  07ae		       88		      dey
   1238  07af		       b1 54		      lda	(R1),y
   1239  07b1		       85 52		      sta	R0
   1240  07b3		       68		      pla
   1241  07b4		       a8		      tay
   1242  07b5		       4c 1d 07 	      jmp	pushR0nextIl
   1243  07b8
   1244  07b8							;
   1245  07b8							;=====================================================
   1246  07b8							; Check which type of index to use byte or word and jmp to correct
   1247  07b8							; function
   1248  07b8		       98	   iArray     tya
   1249  07b9		       48		      pha
   1250  07ba
   1251  07ba		       20 bf 2c 	      jsr	popR0	; Get the array index
   1252  07bd		       20 d7 2c 	      jsr	popR1	; Get the Variable address
   1253  07c0
   1254  07c0		       20 34 2a 	      jsr	getILByte	; Get type of number to process
   1255  07c3		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Are we testing a valid parameter
   1256  07c5		       f0 52		      beq	iArrayFNparm	; process a fn pramater index
   1257  07c7
   1258  07c7		       29 fe		      and	#$FE	; Turn off the unsigned bit
   1259  07c9		       c9 a2		      cmp	#tByte	; Test for a byte index
   1260  07cb		       f0 10		      beq	iArrayB	; yes so branch to process a byte
   1261  07cd							;=====================================================
   1262  07cd							; Process 32 bit index into memory
   1263  07cd		       c9 a6	   iArrayL    cmp	#tLong	; Are we working with 32 bit integers
   1264  07cf		       d0 06		      bne	iArrayW	; Process with sigle shift
   1265  07d1		       06 52		      asl	R0	; Do the multiply by 2
   1266  07d3		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1267  07d5		       b0 39		      bcs	iArrayError	; if the carry is set we have an error
   1268  07d7							;=====================================================
   1269  07d7							; Get the array index from top of stack get Current variable
   1270  07d7							; address from next on stack, add the offset
   1271  07d7							; push the result back onto the stack
   1272  07d7				   iArrayW		; pointers, arrays etc all use 16 bit unsigned integers
   1273  07d7		       06 52		      asl	R0	; Do the multiply by 2
   1274  07d9		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1275  07db		       b0 33		      bcs	iArrayError	; if the carry is set we have an error
   1276  07dd
   1277  07dd							;=====================================================
   1278  07dd							; Get from Byte array not Integer array
   1279  07dd				   iArrayB
   1280  07dd		       18		      clc
   1281  07de		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1282  07e0		       65 52		      adc	R0
   1283  07e2		       85 52		      sta	R0
   1284  07e4		       a5 55		      lda	R1+1
   1285  07e6		       65 53		      adc	R0+1
   1286  07e8		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1287  07ea		       a5 55		      lda	R1+1
   1288  07ec		       cd 35 43 	      cmp	ProgramEnd+1	; lets check if we are processing an @ buffer pointer to free memory
   1289  07ef		       d0 08		      bne	iArrayCheckVar
   1290  07f1				   iArrayExit
   1291  07f1		       20 2d 2c 	      jsr	pushR0	; Push R0 assume it is correct
   1292  07f4
   1293  07f4		       68		      pla
   1294  07f5		       a8		      tay
   1295  07f6		       4c b1 02 	      jmp	NextIL
   1296  07f9							; Check for valis variable and valid index to use
   1297  07f9		       a5 41	   iArrayCheckVar lda	VARIABLES
   1298  07fb		       18		      clc
   1299  07fc		       69 33		      adc	#[25*2]+1	; the number of actual variable valid bytes
   1300  07fe		       85 56		      sta	MQ	; mq contains the last valid byte we can use
   1301  0800		       a9 00		      lda	#0
   1302  0802		       65 42		      adc	VARIABLES+1	; Memory past last word R0+1 > A then invalid
   1303  0804		       c5 53		      cmp	R0+1
   1304  0806		       90 08		      bcc	iArrayError
   1305  0808		       a5 52		      lda	R0	; a > m invalid past last byte of variable area
   1306  080a		       c5 56		      cmp	MQ
   1307  080c		       f0 e3		      beq	iArrayExit	; If it is equal then it is valid
   1308  080e		       90 e1		      bcc	iArrayExit	; if it is less it is valid
   1309  0810
   1310  0810							; Get here if array index is out of range
   1311  0810		       68	   iArrayError pla
   1312  0811		       98		      tya
   1313  0812		       a9 00		      lda	#0
   1314  0814		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1315  0816		       4c 7d 06 	      jmp	iErr2
   1316  0819							;=====================================================
   1317  0819							; Verify function paramater index is valid
   1318  0819		       20 c1 25    iArrayFNparm jsr	GosubFindParms	; Get a pointer to the current functions parameter list info
   1319  081c		       90 f2		      bcc	iArrayError	; There are no paramters for this call, should never be true
   1320  081e		       88		      dey
   1321  081f		       88		      dey		; Points to parameter count
   1322  0820		       a5 52		      lda	R0	; get parm to be accessed
   1323  0822		       d1 4b		      cmp	(GOSUBSTACK),y	; compare to max number allowed
   1324  0824		       b0 ea		      bcs	iArrayError	; the parameter index should be less than the count
   1325  0826		       06 52		      asl	R0	; Do the multiply by 2
   1326  0828		       26 53		      rol	R0+1
   1327  082a
   1328  082a		       18		      clc
   1329  082b		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1330  082d		       65 52		      adc	R0
   1331  082f		       85 52		      sta	R0
   1332  0831		       a5 55		      lda	R1+1
   1333  0833		       65 53		      adc	R0+1
   1334  0835		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1335  0837		       4c f1 07 	      jmp	iArrayExit	; Get ot we are done
   1336  083a							;
   1337  083a							;=====================================================
   1338  083a							; List the current BASIC program in memory.  Uses R0,
   1339  083a							; tempIly, and dpl.
   1340  083a							;
   1341  083a		       20 bf 2e    iLST       jsr	SetOutConsole
   1342  083d		       ad 32 43    iLST2      lda	ProgramStart
   1343  0840		       85 59		      sta	dpl
   1344  0842		       ad 33 43 	      lda	ProgramStart+1
   1345  0845		       85 5a		      sta	dpl+1
   1346  0847							;
   1347  0847							; dpl/dph point to the current line.  See if we're at
   1348  0847							; the end of the program.
   1349  0847							;
   1350  0847		       a5 59	   iLSTloop   lda	dpl
   1351  0849		       cd 34 43 	      cmp	ProgramEnd
   1352  084c		       d0 07		      bne	iLstNotEnd
   1353  084e		       a5 5a		      lda	dpl+1
   1354  0850		       cd 35 43 	      cmp	ProgramEnd+1
   1355  0853		       f0 15		      beq	iLstdone
   1356  0855							;
   1357  0855		       20 4e 22    iLstNotEnd jsr	PrintProgramLine
   1358  0858							;		  ldy	  #1		  ;Change:  Skip first byte length
   1359  0858							;		  lda	  (dpl),y	  ;line number LSB
   1360  0858							;		  sta	  R0
   1361  0858							;		  iny
   1362  0858							;		  lda	  (dpl),y		 ;line number MSB
   1363  0858							;		  sta	  R0+1
   1364  0858							;		  iny
   1365  0858							;		  sty	  tempIlY
   1366  0858							;		  jsr	  PrintDecimal
   1367  0858							;		  lda	  #SPACE
   1368  0858							;		  jsr	  VOUTCH
   1369  0858							;		  ldy	  tempIlY
   1370  0858							;iLSTl2	  lda	  (dpl),y
   1371  0858							;		  beq	  iLST3 	  ;end of this line 0 value
   1372  0858							;		  sty	  tempIlY
   1373  0858							;		  jsr	  VOUTCH
   1374  0858							;		  ldy	  tempIlY
   1375  0858							;		  iny
   1376  0858							;		  bne	  iLSTl2	  ;do next char
   1377  0858							;
   1378  0858							; End of this line.  Print CR/LF, then move to the
   1379  0858							; next line.
   1380  0858							;
   1381  0858		       a0 00	   iLST3      ldy	#0	;Move to next line
   1382  085a		       b1 59		      lda	(dpl),y	;Current line length
   1383  085c		       18		      clc		;Clear the carry flag
   1384  085d							;		  tya
   1385  085d		       65 59		      adc	dpl	;Add the offset to the pointer
   1386  085f		       85 59		      sta	dpl	;Save the new value
   1387  0861		       a5 5a		      lda	dpl+1	;Next byte
   1388  0863		       69 00		      adc	#0	;ad in the carry if any
   1389  0865		       85 5a		      sta	dpl+1	;Save it
   1390  0867							;
   1391  0867							; Have to manually do CR/LF so it uses the vectored
   1392  0867							; output function.
   1393  0867							;
   1394  0867							;		  lda	  #CR
   1395  0867							;		  jsr	  VOUTCH
   1396  0867							;		  lda	  #LF
   1397  0867							;		  jsr	  VOUTCH
   1398  0867		       4c 47 08 	      jmp	iLSTloop	;do next line
   1399  086a							;
   1400  086a		       20 bf 2e    iLstdone   jsr	SetOutConsole
   1401  086d		       4c b1 02 	      jmp	NextIL
   1402  0870							;
   1403  0870							;=====================================================
   1404  0870							; Get a line of text into LINBUF.  Terminate with a
   1405  0870							; null byte.
   1406  0870							;
   1407  0870				   iGETLINE
   1408  0870		       a9 3e		      lda	#'>	;prompt character
   1409  0872		       a6 00		      ldx	0	;Wait for read to complete
   1410  0874		       20 4a 2b 	      jsr	GetLine
   1411  0877							;
   1412  0877		       a9 00		      lda	#0
   1413  0879		       85 5b		      sta	RunMode
   1414  087b				   iGetParseLine
   1415  087b							; lda	   CUROFF
   1416  087b							; pha
   1417  087b		       20 59 1d 	      jsr	ParseInputLine
   1418  087e							; pla
   1419  087e							;  sta     CUROFF
   1420  087e		       a9 56		      lda	#TOKENBUFFER&$FF
   1421  0880		       85 4f		      sta	CURPTR
   1422  0882		       a9 1c		      lda	#TOKENBUFFER>>8
   1423  0884		       85 50		      sta	CURPTR+1
   1424  0886		       a9 01		      lda	#1
   1425  0888		       85 51		      sta	CUROFF
   1426  088a		       4c b1 02 	      jmp	NextIL
   1427  088d							;
   1428  088d							;=====================================================
   1429  088d							; This is called when the input buffer contains a line
   1430  088d							; typed in by the user that starts with a line number.
   1431  088d							; Insert the line into the program or delete the line
   1432  088d							; if there is nothing after the line number,
   1433  088d							;
   1434  088d				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1435  088d		       ad 57 1c 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1436  0890		       85 52		      sta	R0	; place the number into R0
   1437  0892		       ad 58 1c 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1438  0895		       85 53		      STA	R0+1	; Place it into
   1439  0897							;
   1440  0897							; Now find the line OR the next higher line OR the
   1441  0897							; end of the program.
   1442  0897							;
   1443  0897		       20 79 2a 	      jsr	findLine	; Look for the line number in the current program
   1444  089a							; Returns Z and curptr point to the line if found
   1445  089a							; Returns C and curptr at next higher line if not found and there is a higher line
   1446  089a							; Returns ZC clear and curptr to end of program if higher than all other lines
   1447  089a							;
   1448  089a							; If the line exists, it needs to be removed.
   1449  089a							;
   1450  089a		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1451  089c							;
   1452  089c							; Get length of line to be removed, we fall thru to here if we find a matching line
   1453  089c							;
   1454  089c							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1455  089c		       a0 00		      ldy	#0
   1456  089e		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1457  08a0		       a8		      tay
   1458  08a1							;If it is equal we delete the line and replace it, get length
   1459  08a1							;then adjust all program line after up or down depending on len of line
   1460  08a1							;If next higher then just move everythimg down by length bytes
   1461  08a1							;This call will return how many bytes in the line we found
   1462  08a1		       8c 2b 43 	      sty	lineLength	;Save the length of the line we found
   1463  08a4							;
   1464  08a4							; Compute the new end of the program first.
   1465  08a4							;
   1466  08a4		       38		      sec		;Set the carry bit
   1467  08a5		       ad 34 43 	      lda	ProgramEnd	;Get low byte of program end
   1468  08a8		       ed 2b 43 	      sbc	lineLength	;Subtract the length of the current line
   1469  08ab		       8d 34 43 	      sta	ProgramEnd	;save it
   1470  08ae		       ad 35 43 	      lda	ProgramEnd+1
   1471  08b1		       e9 00		      sbc	#0	;Process the carry
   1472  08b3		       8d 35 43 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1473  08b6							;
   1474  08b6							; Copy CURPTR into R1 for working
   1475  08b6							;
   1476  08b6		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1477  08b8		       85 54		      sta	R1
   1478  08ba		       a5 50		      lda	CURPTR+1
   1479  08bc		       85 55		      sta	R1+1
   1480  08be							;
   1481  08be							; See if we're at the end.
   1482  08be							;
   1483  08be		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1484  08c0		       cd 34 43 	      cmp	ProgramEnd
   1485  08c3		       d0 07		      bne	InsDelLoop
   1486  08c5		       a5 55		      lda	R1+1
   1487  08c7		       cd 35 43 	      cmp	ProgramEnd+1
   1488  08ca		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1489  08cc							;
   1490  08cc							; Move one byte, move to next location.
   1491  08cc							;
   1492  08cc		       ac 2b 43    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1493  08cf		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1494  08d1		       b1 54		      lda	(R1),y
   1495  08d3		       a0 00		      ldy	#0
   1496  08d5		       91 54		      sta	(R1),y
   1497  08d7		       e6 54		      inc	R1
   1498  08d9		       d0 e3		      bne	InsDelChk
   1499  08db		       e6 55		      inc	R1+1
   1500  08dd		       4c be 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1501  08e0							;
   1502  08e0							; Deletion is done.
   1503  08e0							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1504  08e0							;
   1505  08e0				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1506  08e0		       ad 56 1c 	      lda	TOKENBUFFER	; Get the length
   1507  08e3		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1508  08e5							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1509  08e5		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1510  08e7							;
   1511  08e7							; CURPTR points to where the line will be inserted.
   1512  08e7							;
   1513  08e7							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1514  08e7		       ae 56 1c 	      ldx	TOKENBUFFER
   1515  08ea		       8e 2b 43 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1516  08ed							;
   1517  08ed		       ad 34 43 	      lda	ProgramEnd	;Load the start address for the copy
   1518  08f0							;At this point curptr still contains the location we will insert data
   1519  08f0		       85 5c		      sta	FROM
   1520  08f2		       ad 35 43 	      lda	ProgramEnd+1
   1521  08f5		       85 5d		      sta	FROM+1
   1522  08f7							;
   1523  08f7		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1524  08f9		       b1 5c		      lda	(FROM),y
   1525  08fb		       ac 2b 43 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1526  08fe		       91 5c		      sta	(FROM),y	;Save the new byte
   1527  0900							;
   1528  0900		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1529  0902		       c5 4f		      cmp	CURPTR
   1530  0904		       d0 06		      bne	mvUpMore
   1531  0906		       a5 5d		      lda	FROM+1
   1532  0908		       c5 50		      cmp	CURPTR+1
   1533  090a		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1534  090c							;
   1535  090c							; Not done yet
   1536  090c							;
   1537  090c		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1538  090e		       d0 02		      bne	mvUpMore2
   1539  0910		       c6 5d		      dec	FROM+1
   1540  0912		       c6 5c	   mvUpMore2  dec	FROM
   1541  0914		       4c f7 08 	      jmp	mvup1	;Loop until everything is moved
   1542  0917							;
   1543  0917							; All done with copy.
   1544  0917							;
   1545  0917				   mvUpDone
   1546  0917		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1547  0918		       ad 2b 43 	      lda	lineLength	;Number of bytes to copy from line buff
   1548  091b		       6d 34 43 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1549  091e		       8d 34 43 	      sta	ProgramEnd
   1550  0921		       ad 35 43 	      lda	ProgramEnd+1
   1551  0924		       69 00		      adc	#0
   1552  0926		       8d 35 43 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1553  0929							;
   1554  0929							;===================jlit use length before line newline
   1555  0929
   1556  0929		       a0 00		      ldy	#0	;Set offset of copy
   1557  092b							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1558  092b							;		  sta	  (CURPTR),y	  ;Store the length
   1559  092b							;		  iny
   1560  092b							;		  lda	  R0		  ;Store the line number next
   1561  092b							;		  sta	  (CURPTR),y
   1562  092b							;		  iny
   1563  092b							;		  lda	  R0+1
   1564  092b							;		  sta	  (CURPTR),y
   1565  092b							;		  iny
   1566  092b							;
   1567  092b							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1568  092b		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1569  092d				   mvUpLoop2
   1570  092d							;		  lda	  LINBUF,x	 ;get a byte
   1571  092d		       bd 56 1c 	      lda	TOKENBUFFER,x	;get a byte
   1572  0930		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1573  0932
   1574  0932		       e8		      inx
   1575  0933		       ec 56 1c 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1576  0936		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1577  0938		       c8		      iny
   1578  0939		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1579  093b							;
   1580  093b		       4c b1 02    mvUpFini   jmp	NextIL
   1581  093e							;
   1582  093e							;=====================================================
   1583  093e							; Pops the top value of the ILPC stack and stores it
   1584  093e							; in ILPC.  Ie, return from an IL subroutine.
   1585  093e							;
   1586  093e		       20 67 2a    iRTN       jsr	popILPC
   1587  0941		       4c b1 02 	      jmp	NextIL
   1588  0944							;
   1589  0944							;=====================================================
   1590  0944							; NLINE print a newline
   1591  0944							;
   1592  0944		       20 78 2d    iNLINE     jsr	CRLF	;user supplied sub
   1593  0947		       4c b1 02 	      jmp	NextIL
   1594  094a							;
   1595  094a							;=====================================================
   1596  094a							; This saves the current ILPC value on the stack, then
   1597  094a							; jumps to the address specified by the next two bytes.
   1598  094a							;
   1599  094a		       20 4a 2a    iCALL      jsr	pushILPC	;save ILPC
   1600  094d		       90 07		      bcc	iJMP
   1601  094f
   1602  094f							;If the push failed not enough stack space
   1603  094f		       a2 15	   ErrILStkOver ldx	#ERR_IL_STACK_OVER_FLOW	; Flag any error in line number
   1604  0951		       a9 00		      lda	#0	; stop the execution
   1605  0953		       4c 7d 06 	      jmp	iErr2
   1606  0956							;
   1607  0956							; Jmp to a specific location in the IL code.  The new
   1608  0956							; address immediately follows the opcode.
   1609  0956							;
   1610  0956		       20 30 2a    iJMP       jsr	getILWord
   1611  0959		       86 43		      stx	ILPC
   1612  095b		       85 44		      sta	ILPC+1
   1613  095d		       4c b1 02 	      jmp	NextIL
   1614  0960
   1615  0960
   1616  0960							;
   1617  0960							;=====================================================
   1618  0960							; Push the next two bytes onto the arithmetic stack.
   1619  0960							;
   1620  0960		       20 34 2a    iSetR2     jsr	getILByte
   1621  0963		       85 58		      sta	R2
   1622  0965		       4c b1 02 	      jmp	NextIL
   1623  0968							;
   1624  0968							;=====================================================
   1625  0968							; Push the next two bytes onto the arithmetic stack.
   1626  0968							;
   1627  0968		       20 30 2a    iLIT       jsr	getILWord
   1628  096b		       86 52		      stx	R0
   1629  096d		       85 53		      sta	R0+1
   1630  096f		       20 2d 2c 	      jsr	pushR0
   1631  0972		       4c b1 02 	      jmp	NextIL
   1632  0975							;
   1633  0975							;=====================================================
   1634  0975							; Initialize all variables for a single task.	Ie, set to zero.
   1635  0975							; And internal stack pointers
   1636  0975							;
   1637  0975		       98	   subVINIT   tya
   1638  0976		       48		      pha
   1639  0977
   1640  0977		       a9 00		      lda	#0
   1641  0979		       a0 00		      ldy	#0
   1642  097b		       91 41	   Vinit2     sta	(VARIABLES),y
   1643  097d		       c8		      iny
   1644  097e		       c0 48		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1645  0980		       90 f9		      bcc	Vinit2
   1646  0982		       85 4a		      sta	MATHSTACKPTR	; Clear the math stack
   1647  0984		       85 4d		      sta	GOSUBSTACKPTR	; Clear the gosub stack
   1648  0986		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reset the message queue
   1649  0988		       85 4e		      STA	MESSAGEPTR
   1650  098a
   1651  098a		       68		      pla
   1652  098b		       a8		      tay
   1653  098c		       60		      rts
   1654  098d
   1655  098d				   iVINIT
   1656  098d		       20 75 09 	      jsr	subVINIT
   1657  0990		       20 f0 1f 	      jsr	Compile	; compile line numbers to memory pointers
   1658  0993		       4c b1 02 	      jmp	NextIL
   1659  0996							;
   1660  0996							;=====================================================
   1661  0996							; Set the address of the error handler.  After any
   1662  0996							; error, set to the ILPC to the specified location.
   1663  0996							;
   1664  0996		       20 30 2a    iERRGOTO   jsr	getILWord
   1665  0999		       8e 1f 43 	      stx	errGoto
   1666  099c		       8d 20 43 	      sta	errGoto+1
   1667  099f		       4c b1 02 	      jmp	NextIL
   1668  09a2							;
   1669  09a2							;=====================================================
   1670  09a2							; TST is followed by an 8 bit signed offset, then a
   1671  09a2							; null terminated string.  Compare the string against
   1672  09a2							; the string starting at (CURPTR),CUROFF.  If the
   1673  09a2							; strings match, continue executing the next IL
   1674  09a2							; opcode.  Else, add the offset to ILPC.
   1675  09a2							;
   1676  09a2		       20 34 2a    iTST       jsr	getILByte	;Get the relative jump address
   1677  09a5		       8d 2a 43 	      sta	offset	;save it to use if test faile
   1678  09a8		       20 17 2c 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1679  09ab
   1680  09ab		       a4 51		      ldy	CUROFF
   1681  09ad		       84 59		      sty	dpl	;save for later
   1682  09af							;
   1683  09af		       20 34 2a    iTSTloop   jsr	getILByte	;get next char
   1684  09b2		       f0 11		      beq	iTSTm	;match!
   1685  09b4		       a4 59		      ldy	dpl
   1686  09b6		       d1 4f		      cmp	(CURPTR),y
   1687  09b8		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1688  09ba		       09 20		      ora	#$20	; lets allow lowercase as well
   1689  09bc		       d1 4f		      cmp	(CURPTR),y
   1690  09be		       d0 23		      bne	iTSTfail	;mismatch
   1691  09c0		       c8	   iTSTUpper  iny
   1692  09c1		       84 59		      sty	dpl
   1693  09c3		       d0 ea		      bne	iTSTloop
   1694  09c5							;
   1695  09c5							; It's a match!  Clean up a bit.
   1696  09c5							;
   1697  09c5		       a4 59	   iTSTm      ldy	dpl
   1698  09c7		       84 51		      sty	CUROFF
   1699  09c9		       4c b1 02 	      jmp	NextIL
   1700  09cc
   1701  09cc							; Test for a single quote string
   1702  09cc		       20 34 2a    iTSTStr    jsr	getILByte
   1703  09cf		       8d 2a 43 	      sta	offset
   1704  09d2		       20 17 2c 	      jsr	saveIL
   1705  09d5		       a4 51		      ldy	CUROFF
   1706  09d7		       a9 22		      lda	#'"
   1707  09d9		       d1 4f		      cmp	(CURPTR),y
   1708  09db		       d0 06		      bne	iTSTfail
   1709  09dd		       c8		      iny
   1710  09de		       84 51		      sty	CUROFF
   1711  09e0		       4c d4 02 	      jmp	NextILStr
   1712  09e3							;
   1713  09e3							; Not a match, reset ILPC and then move to the
   1714  09e3							; offset.
   1715  09e3							;
   1716  09e3		       20 22 2c    iTSTfail   jsr	restoreIL
   1717  09e6		       4c e0 0b 	      jmp	tstBranch
   1718  09e9							;
   1719  09e9							;=================================================JLIT=
   1720  09e9							; Test if we have a let statement without the let keyword
   1721  09e9		       20 34 2a    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1722  09ec		       8d 2a 43 	      sta	offset	; Save the jump offset for fails
   1723  09ef		       20 17 2c 	      jsr	saveIL	; save to restore when done if fail
   1724  09f2
   1725  09f2		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1726  09f4		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1727  09f6		       c9 01		      cmp	#kLet	; Is it a let keyword
   1728  09f8		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1729  09fa		       c9 80		      cmp	#tVa	; lets check for a variable
   1730  09fc		       90 e5		      bcc	iTSTfail	; Less than variable range
   1731  09fe		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1732  0a00		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1733  0a02		       b0 df		      bcs	iTSTfail	; return it failed
   1734  0a04
   1735  0a04				   iTSTLETGOOD
   1736  0a04		       c8		      iny
   1737  0a05		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1738  0a07				   iTSTGOODVAR
   1739  0a07		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1740  0a0a
   1741  0a0a							;=================================================JLIT=
   1742  0a0a							; Test a byte at an indirect address
   1743  0a0a							; fails if byte is not equal to the value at the address
   1744  0a0a							; The tests an indirect byte and branches if true
   1745  0a0a		       20 34 2a    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1746  0a0d		       8d 2a 43 	      sta	offset	; Save the jump offset for fails
   1747  0a10		       20 17 2c 	      jsr	saveIL	; save to restore when done if fail
   1748  0a13		       20 30 2a 	      jsr	getILWord	; Get a word into RO
   1749  0a16		       86 52		      stx	R0
   1750  0a18		       85 53		      sta	R0+1
   1751  0a1a		       20 34 2a 	      jsr	getILByte	; Get byte into A
   1752  0a1d		       a0 00		      ldy	#0
   1753  0a1f		       d1 52		      cmp	(R0),y
   1754  0a21		       d0 03		      bne	iTSTByteNotEqual
   1755  0a23		       4c e3 09 	      jmp	iTSTfail
   1756  0a26
   1757  0a26				   iTSTByteNotEqual
   1758  0a26		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1759  0a29
   1760  0a29							;=================================================JLIT=
   1761  0a29							; Test a byte	branch if it fails
   1762  0a29		       20 34 2a    iTSTB      jsr	getILByte	; Get the relative offset byte
   1763  0a2c		       8d 2a 43 	      sta	offset	; Save the jump offset for fails
   1764  0a2f		       20 17 2c 	      jsr	saveIL	; save to restore when done if fail
   1765  0a32		       20 34 2a 	      jsr	getILByte	; Get a byte into Acc
   1766  0a35		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1767  0a37		       d1 4f		      cmp	(CURPTR),y
   1768  0a39		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1769  0a3b		       4c e3 09 	      jmp	iTSTfail	; REcover and move on to next test
   1770  0a3e
   1771  0a3e				   iTSTBMatch
   1772  0a3e		       c8		      iny
   1773  0a3f		       84 51		      sty	CUROFF	; Point to the next byte
   1774  0a41		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1775  0a44
   1776  0a44							;=================================================JLIT=
   1777  0a44							; Test a byte	branch if it fails
   1778  0a44		       20 34 2a    iTSTW      jsr	getILByte	; Get the relative offset byte
   1779  0a47		       8d 2a 43 	      sta	offset	; Save the jump offset for fails
   1780  0a4a		       20 17 2c 	      jsr	saveIL	; save to restore when done if fail
   1781  0a4d		       20 30 2a 	      jsr	getILWord	; Get a word into RO
   1782  0a50		       86 52		      stx	R0
   1783  0a52		       85 53		      sta	R0+1
   1784  0a54		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1785  0a56		       8a		      txa
   1786  0a57		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1787  0a59		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1788  0a5b		       4c e3 09 	      jmp	iTSTfail	; REcover and move on to next test
   1789  0a5e		       c8	   iTSTWM1    iny
   1790  0a5f		       a5 53		      lda	R0+1
   1791  0a61		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1792  0a63		       f0 03		      beq	iTSTWMatch
   1793  0a65		       4c e3 09 	      jmp	iTSTfail
   1794  0a68
   1795  0a68				   iTSTWMatch
   1796  0a68		       c8		      iny
   1797  0a69		       84 51		      sty	CUROFF
   1798  0a6b		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1799  0a6e
   1800  0a6e							;================================================jLIT=
   1801  0a6e							;Test for end of line
   1802  0a6e							;
   1803  0a6e				   iTSTDONE
   1804  0a6e		       20 34 2a 	      jsr	getILByte
   1805  0a71		       8d 2a 43 	      sta	offset
   1806  0a74		       20 17 2c 	      jsr	saveIL
   1807  0a77		       a4 51		      ldy	CUROFF
   1808  0a79		       84 59		      sty	dpl
   1809  0a7b		       b1 4f		      lda	(CURPTR),y
   1810  0a7d		       f0 0b		      beq	iTSTDONEtrue
   1811  0a7f		       c9 e6		      cmp	#oColon
   1812  0a81		       f0 07		      beq	iTSTDONEtrue
   1813  0a83		       a4 59		      ldy	dpl
   1814  0a85		       84 51		      sty	CUROFF
   1815  0a87		       4c e3 09 	      jmp	iTSTfail
   1816  0a8a							;
   1817  0a8a							; Advance to the next line
   1818  0a8a							;
   1819  0a8a				   iTSTDONEtrue
   1820  0a8a		       4c b1 02 	      jmp	NextIL
   1821  0a8d
   1822  0a8d		       4c e0 0b    tstBranchLink jmp	tstBranch
   1823  0a90							;
   1824  0a90							;=====================================================
   1825  0a90							; Inc and dec a variable , faster than a = a + 1
   1826  0a90				   iINCVAR
   1827  0a90		       20 bf 2c 	      jsr	popR0
   1828  0a93		       a0 00		      ldy	#0
   1829  0a95		       18		      clc
   1830  0a96		       a9 01		      lda	#1
   1831  0a98		       71 52		      adc	(R0),y
   1832  0a9a		       91 52		      sta	(R0),y
   1833  0a9c		       90 07		      bcc	iINCDONE
   1834  0a9e		       c8		      iny
   1835  0a9f		       a9 00		      lda	#0
   1836  0aa1		       71 52		      adc	(R0),y
   1837  0aa3		       91 52		      sta	(R0),y
   1838  0aa5				   iINCDONE
   1839  0aa5		       4c b1 02 	      jmp	NextIL
   1840  0aa8
   1841  0aa8				   iDECVAR
   1842  0aa8		       20 bf 2c 	      jsr	popR0
   1843  0aab		       a0 00		      ldy	#0
   1844  0aad		       38		      sec
   1845  0aae		       b1 52		      lda	(R0),y
   1846  0ab0		       e9 01		      sbc	#1
   1847  0ab2		       91 52		      sta	(R0),y
   1848  0ab4		       c8		      iny
   1849  0ab5		       b1 52		      lda	(R0),y
   1850  0ab7		       e9 00		      sbc	#0
   1851  0ab9		       91 52		      sta	(R0),y
   1852  0abb		       4c b1 02 	      jmp	NextIL
   1853  0abe
   1854  0abe
   1855  0abe							;
   1856  0abe							;=====================================================
   1857  0abe							; TSTV is followed by an 8 bit signed offset.	If the
   1858  0abe							; value at (CURPTR),CUROFF appears to be a variable
   1859  0abe							; name, move to the next IL statement.  Else, add the
   1860  0abe							; offset to ILPC. Converted to use actual absolute memory addresses
   1861  0abe							; TSTVT Looks for the task context
   1862  0abe							;
   1863  0abe		       20 d7 2c    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1864  0ac1		       a9 00		      lda	#0
   1865  0ac3		       85 58		      sta	R2
   1866  0ac5		       f0 04		      beq	iTSTVV
   1867  0ac7
   1868  0ac7							; Test for simple variable
   1869  0ac7		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1870  0ac9		       85 58		      sta	R2
   1871  0acb
   1872  0acb		       20 34 2a    iTSTVV     jsr	getILByte	;offset
   1873  0ace		       8d 2a 43 	      sta	offset
   1874  0ad1							;
   1875  0ad1		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1876  0ad3		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1877  0ad5		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1878  0ad7		       4c 8d 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1879  0ada							;
   1880  0ada				   iTSTVnext
   1881  0ada		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1882  0adc		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1883  0ade
   1884  0ade		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1885  0ae0		       f0 5b		      beq	iTSTVParm
   1886  0ae2
   1887  0ae2		       c9 9b		      cmp	#tVhat	; task exit code
   1888  0ae4		       d0 04		      bne	iTSTV_A2Z
   1889  0ae6		       a9 48		      lda	#TASKEXITCODE
   1890  0ae8		       d0 0b		      bne	iTSTVContinue
   1891  0aea
   1892  0aea				   iTSTV_A2Z
   1893  0aea
   1894  0aea		       c9 80		      cmp	#tVa
   1895  0aec		       90 9f		      bcc	tstBranchLink
   1896  0aee		       c9 9a		      cmp	#tVz+1
   1897  0af0		       b0 9b		      bcs	tstBranchLink
   1898  0af2
   1899  0af2
   1900  0af2							;
   1901  0af2							; The condition is true, so convert to an index, push
   1902  0af2							; it onto the stack and continue running.
   1903  0af2							;
   1904  0af2		       29 7f		      and	#%01111111	; Mask off the high bit
   1905  0af4		       0a		      asl		; multiply by two
   1906  0af5
   1907  0af5				   iTSTVContinue
   1908  0af5		       c8		      iny
   1909  0af6		       84 51		      sty	CUROFF	; it is a valid variable
   1910  0af8		       48		      pha		; save the last variable pointer value
   1911  0af9		       a5 58		      lda	R2
   1912  0afb		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1913  0afd
   1914  0afd		       20 09 2a 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1915  0b00		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1916  0b02
   1917  0b02		       68		      pla		; We have an invalid pid for getting variable value
   1918  0b03		       a2 10		      ldx	#ERR_INVALID_PID
   1919  0b05		       a9 00		      lda	#0
   1920  0b07		       4c 7d 06 	      jmp	iErr2
   1921  0b0a
   1922  0b0a				   iTSTVGOODPID
   1923  0b0a		       20 f1 29 	      jsr	ipc_getcontext	; Get the other tasks variables
   1924  0b0d		       a0 01		      ldy	#VARIABLEPOS
   1925  0b0f		       b1 56		      lda	(MQ),y
   1926  0b11		       85 52		      sta	R0
   1927  0b13		       c8		      iny
   1928  0b14		       b1 56		      lda	(MQ),y
   1929  0b16		       85 53		      sta	R0+1
   1930  0b18		       4c 23 0b 	      jmp	iTSTVAddOffset
   1931  0b1b
   1932  0b1b				   iTSTVLocalValue
   1933  0b1b		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1934  0b1d		       85 52		      sta	R0
   1935  0b1f		       a5 42		      lda	VARIABLES+1
   1936  0b21		       85 53		      sta	R0+1
   1937  0b23
   1938  0b23				   iTSTVAddOffset
   1939  0b23		       68		      pla
   1940  0b24		       85 54		      sta	R1
   1941  0b26		       a9 00		      lda	#0
   1942  0b28		       85 55		      sta	R1+1
   1943  0b2a
   1944  0b2a				   iTSTVcontinue
   1945  0b2a
   1946  0b2a		       4c a5 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1947  0b2d
   1948  0b2d							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1949  0b2d							; an array of integer values or byte.
   1950  0b2d				   iTSTVat
   1951  0b2d		       c8		      iny
   1952  0b2e		       84 51		      sty	CUROFF	;it is a valid variable
   1953  0b30		       ad 34 43 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1954  0b33		       85 52		      sta	R0
   1955  0b35		       ad 35 43 	      lda	ProgramEnd+1
   1956  0b38		       85 53		      sta	R0+1
   1957  0b3a		       4c 1d 07 	      jmp	pushR0nextIl	;place this onto the stack
   1958  0b3d
   1959  0b3d							; When we get parameters passed we can access them using the # variable with[]
   1960  0b3d							; example #[0] #[1] etc, we dont check yet if there is too many
   1961  0b3d		       c8	   iTSTVParm  iny
   1962  0b3e		       84 51		      sty	CUROFF	;it is a valid variable
   1963  0b40
   1964  0b40							; upon return the y register  point to the gosub Parms entry value entry
   1965  0b40		       20 c1 25 	      jsr	GosubFindParms
   1966  0b43		       90 21		      bcc	iTSTMissingParms
   1967  0b45
   1968  0b45		       88		      dey
   1969  0b46		       88		      dey
   1970  0b47		       88		      dey		;Point to the actual index of first parameter in math stack
   1971  0b48
   1972  0b48		       a5 48		      lda	MATHSTACK
   1973  0b4a		       85 52		      sta	R0
   1974  0b4c		       a5 49		      lda	MATHSTACK+1
   1975  0b4e		       85 53		      sta	R0+1
   1976  0b50		       b1 4b		      lda	(GOSUBSTACK),y	; Get the correct Offset to start of parameters
   1977  0b52		       f0 0b		      beq	iTSTVindex0	; no math if no offset
   1978  0b54		       18		      clc
   1979  0b55		       65 52		      adc	R0	; Point to the actual address that the variables start, not just top of stack
   1980  0b57		       85 52		      sta	R0
   1981  0b59		       a9 00		      lda	#0
   1982  0b5b		       65 53		      adc	R0+1
   1983  0b5d		       85 53		      sta	R0+1
   1984  0b5f				   iTSTVindex0
   1985  0b5f		       a9 81		      lda	#GOSUB_RTN_VALUE
   1986  0b61		       85 58		      sta	R2	; Set the data type as a parameter to a function
   1987  0b63		       4c 1d 07 	      jmp	pushR0nextIl
   1988  0b66
   1989  0b66
   1990  0b66				   iTSTMissingParms
   1991  0b66		       a9 00		      lda	#0
   1992  0b68		       a2 19		      ldx	#ERR_FUNCTION_EXPECTED_PARAMETERS
   1993  0b6a		       4c 7d 06 	      jmp	iErr2
   1994  0b6d
   1995  0b6d							;
   1996  0b6d							;=====================================================
   1997  0b6d							; TSTL seems basically the same as TSTN, but leave the
   1998  0b6d							; value in R0 instead of pushing onto stack.
   1999  0b6d							; This tests for a valid line number
   2000  0b6d							;
   2001  0b6d		       20 34 2a    iTSTL      jsr	getILByte
   2002  0b70		       8d 2a 43 	      sta	offset
   2003  0b73							;
   2004  0b73		       a4 51		      ldy	CUROFF
   2005  0b75		       b1 4f		      lda	(CURPTR),y
   2006  0b77		       c8		      iny
   2007  0b78		       11 4f		      ora	(CURPTR),y
   2008  0b7a		       f0 06		      beq	iTSTLNotLineNo
   2009  0b7c
   2010  0b7c
   2011  0b7c							; In Both cases we need to point to the first usefull byte to process.
   2012  0b7c		       c8		      iny
   2013  0b7d		       84 51		      sty	CUROFF
   2014  0b7f		       4c b1 02 	      jmp	NextIL
   2015  0b82				   iTSTLNotLineNo
   2016  0b82		       c8		      iny
   2017  0b83		       84 51		      sty	CUROFF
   2018  0b85		       4c e0 0b 	      jmp	tstBranch
   2019  0b88
   2020  0b88							;
   2021  0b88							;=====================================================
   2022  0b88							; TSTN checks for a number.  This is very simplistic;
   2023  0b88							; if the character is a digit, assume it's a number.
   2024  0b88							; Convert to a number and push it onto the stack.
   2025  0b88							;
   2026  0b88		       20 34 2a    iTSTN      jsr	getILByte
   2027  0b8b		       8d 2a 43 	      sta	offset
   2028  0b8e							;
   2029  0b8e		       a9 00		      lda	#0
   2030  0b90		       85 59		      sta	dpl
   2031  0b92		       a4 51		      ldy	CUROFF
   2032  0b94				   chkType
   2033  0b94		       b1 4f		      lda	(CURPTR),y
   2034  0b96		       c9 a2		      cmp	#tByte
   2035  0b98		       f0 0e		      beq	chkByte
   2036  0b9a		       c9 a4		      cmp	#tInteger
   2037  0b9c		       f0 16		      beq	chkInteger
   2038  0b9e		       c9 eb		      cmp	#oMinus
   2039  0ba0		       d0 3e		      bne	tstBranch
   2040  0ba2		       e6 59		      inc	dpl
   2041  0ba4		       c8		      iny
   2042  0ba5		       4c 94 0b 	      jmp	chkType
   2043  0ba8
   2044  0ba8				   chkByte
   2045  0ba8		       a9 00		      lda	#0
   2046  0baa		       85 53		      sta	R0+1
   2047  0bac		       c8		      iny
   2048  0bad		       b1 4f		      lda	(CURPTR),y
   2049  0baf		       85 52		      sta	R0
   2050  0bb1		       c8		      iny
   2051  0bb2		       d0 0b		      bne	iTSTN_1
   2052  0bb4
   2053  0bb4				   chkInteger
   2054  0bb4		       c8		      iny
   2055  0bb5		       b1 4f		      lda	(CURPTR),y
   2056  0bb7		       85 52		      sta	R0
   2057  0bb9		       c8		      iny
   2058  0bba		       b1 4f		      lda	(CURPTR),y
   2059  0bbc		       85 53		      sta	R0+1
   2060  0bbe		       c8		      iny
   2061  0bbf							;
   2062  0bbf							; Check if it is negative and make it so
   2063  0bbf							;
   2064  0bbf				   iTSTN_1
   2065  0bbf		       84 51		      sty	CUROFF
   2066  0bc1
   2067  0bc1		       a5 59		      lda	dpl
   2068  0bc3		       f0 18		      beq	iTSTN_2	;positive
   2069  0bc5							;
   2070  0bc5		       a5 52		      lda	R0
   2071  0bc7		       05 53		      ora	R0+1
   2072  0bc9		       f0 12		      beq	iTSTN_2	;zero
   2073  0bcb
   2074  0bcb							; Invert all the bits, then add one.
   2075  0bcb							;
   2076  0bcb		       a5 52		      lda	R0
   2077  0bcd		       49 ff		      eor	#$ff
   2078  0bcf		       85 52		      sta	R0
   2079  0bd1		       a5 53		      lda	R0+1
   2080  0bd3		       49 ff		      eor	#$ff
   2081  0bd5		       85 53		      sta	R0+1
   2082  0bd7							;
   2083  0bd7		       e6 52		      inc	R0
   2084  0bd9		       d0 02		      bne	iTSTN_2
   2085  0bdb		       e6 53		      inc	R0+1
   2086  0bdd				   iTSTN_2
   2087  0bdd		       4c 1d 07 	      jmp	pushR0nextIl	;save onto stack
   2088  0be0
   2089  0be0							;
   2090  0be0							; Common jump point for all TSTx instructions that
   2091  0be0							; fail to meet the requirements.  This takes the
   2092  0be0							; offset and adds/subtracts to/from ILPC.
   2093  0be0							;
   2094  0be0		       ad 2a 43    tstBranch  lda	offset	;get signed offset
   2095  0be3		       10 0e		      bpl	tstPositive
   2096  0be5							;
   2097  0be5							; Do negative branch.	Do sign extension.
   2098  0be5							;
   2099  0be5		       18	   tstNegative clc
   2100  0be6		       65 43		      adc	ILPC
   2101  0be8		       85 43		      sta	ILPC
   2102  0bea							;		  bcc	  tstBothDone
   2103  0bea							;		  dec	  ILPC+1
   2104  0bea							;		  jmp	  NextIL
   2105  0bea
   2106  0bea		       a5 44		      lda	ILPC+1
   2107  0bec		       69 ff		      adc	#$ff
   2108  0bee		       85 44		      sta	ILPC+1
   2109  0bf0		       4c b1 02 	      jmp	NextIL	;keep going
   2110  0bf3							;
   2111  0bf3		       18	   tstPositive clc
   2112  0bf4		       65 43		      adc	ILPC
   2113  0bf6		       85 43		      sta	ILPC
   2114  0bf8		       90 02		      bcc	tstBothDone
   2115  0bfa		       e6 44		      inc	ILPC+1
   2116  0bfc				   tstBothDone
   2117  0bfc		       4c b1 02 	      jmp	NextIL
   2118  0bff
   2119  0bff							;
   2120  0bff							;====================================================
   2121  0bff							; Test for IRQ pending, and test if a break key pressed
   2122  0bff							; Yes I know but this handles all sorts of irq/break issues
   2123  0bff							;
   2124  0bff		       20 34 2a    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2125  0c02		       8d 2a 43 	      sta	offset	; Store the not true jump address offset
   2126  0c05		       ad c1 19    irqNo      lda	IRQPending	; Check if the pending value is set
   2127  0c08		       f0 20		      beq	tstBreak	; if no irq then check for an escape key pressed
   2128  0c0a		       c9 01		      cmp	#1	; only do this if set to first time
   2129  0c0c		       d0 1c		      bne	tstBreak	; We are in a irq service already
   2130  0c0e				   iTSTProcessIRQ
   2131  0c0e		       78		      sei		; disable the interupt until ireturn resets it
   2132  0c0f		       ee c1 19 	      inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2133  0c12		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2134  0c14		       20 47 2c 	      jsr	pushLN	; Push the next line to be executed
   2135  0c17		       b0 21		      bcs	ErrStkOver	; Check if there was an error
   2136  0c19		       ad c2 19 	      lda	IRQEntry	; Get the line number to branch to
   2137  0c1c		       85 4f		      sta	CURPTR	; put line number into r0
   2138  0c1e		       ad c3 19 	      lda	IRQEntry+1
   2139  0c21		       85 50		      sta	CURPTR+1
   2140  0c23		       a9 03		      lda	#3	; Point to first byte of program text
   2141  0c25		       85 51		      sta	CUROFF
   2142  0c27		       4c b1 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2143  0c2a
   2144  0c2a				   tstBreak
   2145  0c2a		       20 67 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2146  0c2d		       d0 b1		      bne	tstBranch	; z not set of no break found
   2147  0c2f		       ad 2c 43 	      lda	taskIOPending
   2148  0c32		       f0 03		      beq	tstBrkComplete
   2149  0c34		       ce 2c 43 	      dec	taskIOPending
   2150  0c37		       4c 02 06    tstBrkComplete jmp	iFIN	; Exit out of run mode
   2151  0c3a
   2152  0c3a		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2153  0c3c		       a9 00		      lda	#0	; stop the execution
   2154  0c3e		       4c 7d 06 	      jmp	iErr2
   2155  0c41							;
   2156  0c41
   2157  0c41							;=====================================================
   2158  0c41							; This places the number of free bytes on top of the
   2159  0c41							; stack.
   2160  0c41							;
   2161  0c41		       20 cf 23    iFREE      jsr	MemFree
   2162  0c44		       4c 1d 07 	      jmp	pushR0nextIl
   2163  0c47							;
   2164  0c47							;=====================================================
   2165  0c47							; Generate a random number from 0-FFFF and then MOD
   2166  0c47							; it with the value on top of stack.  Leaves number on
   2167  0c47							; stack
   2168  0c47							;
   2169  0c47		       20 d7 2c    iRANDOM    jsr	popR1	;mod value
   2170  0c4a							;
   2171  0c4a							; If the value is zero, just return a one.
   2172  0c4a							;
   2173  0c4a		       a5 54		      lda	R1
   2174  0c4c		       05 55		      ora	R1+1
   2175  0c4e		       f0 4a		      beq	irandom1
   2176  0c50							;
   2177  0c50		       ad 25 43 	      lda	random+1
   2178  0c53		       8d 22 43 	      sta	rtemp1
   2179  0c56		       ad 24 43 	      lda	random
   2180  0c59		       0a		      asl
   2181  0c5a		       2e 22 43 	      rol	rtemp1
   2182  0c5d		       0a		      asl
   2183  0c5e		       2e 22 43 	      rol	rtemp1
   2184  0c61		       18		      clc
   2185  0c62		       6d 24 43 	      adc	random
   2186  0c65
   2187  0c65		       48		      pha
   2188  0c66
   2189  0c66		       ad 22 43 	      lda	rtemp1
   2190  0c69		       6d 25 43 	      adc	random+1
   2191  0c6c		       8d 25 43 	      sta	random+1
   2192  0c6f
   2193  0c6f		       68		      pla
   2194  0c70
   2195  0c70		       69 11		      adc	#$11
   2196  0c72		       8d 24 43 	      sta	random
   2197  0c75		       ad 25 43 	      lda	random+1
   2198  0c78		       69 36		      adc	#$36
   2199  0c7a		       8d 25 43 	      sta	random+1
   2200  0c7d
   2201  0c7d		       ad 24 43 	      lda	random
   2202  0c80		       85 52		      sta	R0
   2203  0c82		       ad 25 43 	      lda	random+1
   2204  0c85		       29 7f		      and	#$7f	;make positive
   2205  0c87		       85 53		      sta	R0+1
   2206  0c89							;
   2207  0c89							; R0 contains the number and R1 contains the max value.
   2208  0c89							;
   2209  0c89		       20 43 07 	      jsr	iDivNoPop
   2210  0c8c		       20 40 2d 	      jsr	RestoreSigns
   2211  0c8f		       a5 56		      lda	MQ
   2212  0c91		       85 52		      sta	R0
   2213  0c93		       a5 57		      lda	MQ+1
   2214  0c95		       85 53		      sta	R0+1
   2215  0c97		       4c 1d 07 	      jmp	pushR0nextIl
   2216  0c9a				   irandom1
   2217  0c9a		       a9 00		      lda	#0
   2218  0c9c		       85 53		      sta	R0+1
   2219  0c9e		       a9 01		      lda	#1
   2220  0ca0		       85 52		      sta	R0
   2221  0ca2		       4c 1d 07 	      jmp	pushR0nextIl
   2222  0ca5
   2223  0ca5							; The following replaced by call to division/modulo
   2224  0ca5							;iRANDOM_2	lda	R0
   2225  0ca5							;		cmp	R1
   2226  0ca5							;		bne	iRANDOM_1
   2227  0ca5							;		lda	R0+1
   2228  0ca5							;		cmp	R1+1
   2229  0ca5							;		bne	iRANDOM_1	;need to subtract
   2230  0ca5							;
   2231  0ca5							; Subtract R1 from R0
   2232  0ca5							;
   2233  0ca5							;iRANDOM_sub	sec
   2234  0ca5							;		lda	R0
   2235  0ca5							;		sbc	R1
   2236  0ca5							;		sta	R0
   2237  0ca5							;		lda	R0+1
   2238  0ca5							;		sbc	R1+1
   2239  0ca5							;		sta	R0+1
   2240  0ca5							;		jmp	iRANDOM_2
   2241  0ca5							;
   2242  0ca5							; See if R1 > R0.  If so, branch to subtract.
   2243  0ca5							;
   2244  0ca5							;iRANDOM_1	lda	R0
   2245  0ca5							;		cmp	R1
   2246  0ca5							;		lda	R0+1
   2247  0ca5							;		sbc	R1+1
   2248  0ca5							;		bvc	iRANDOM_4
   2249  0ca5							;		eor	#$80
   2250  0ca5							;iRANDOM_4	bpl	iRANDOM_sub
   2251  0ca5							;
   2252  0ca5							; All done.  Almost.  Add one, then push the result.
   2253  0ca5							;
   2254  0ca5							;irandom1	inc	R0
   2255  0ca5							;		bne	iRANDOM_3
   2256  0ca5							;		inc	R0+1
   2257  0ca5							;iRANDOM_3
   2258  0ca5							;		  jsr	pushR0	;return value
   2259  0ca5							;		jmp	NextIL
   2260  0ca5							;
   2261  0ca5							; Poke a value into a memory location
   2262  0ca5		       8c 26 43    iPOKEMEMORY sty	tempy
   2263  0ca8		       20 bf 2c 	      jsr	popR0
   2264  0cab		       20 d7 2c 	      jsr	popR1
   2265  0cae		       a0 00		      ldy	#0
   2266  0cb0		       a5 52		      lda	R0
   2267  0cb2		       91 54		      sta	(R1),y
   2268  0cb4		       ac 26 43 	      ldy	tempy
   2269  0cb7		       4c b1 02 	      jmp	NextIL
   2270  0cba							;
   2271  0cba							; Get a value from a memory location
   2272  0cba							;
   2273  0cba		       8c 26 43    iPEEKMEMORY sty	tempy
   2274  0cbd		       20 bf 2c 	      jsr	popR0
   2275  0cc0		       a0 00		      ldy	#0
   2276  0cc2		       b1 52		      lda	(R0),y
   2277  0cc4		       ac 26 43 	      ldy	tempy
   2278  0cc7		       85 52		      sta	R0
   2279  0cc9		       a9 00		      lda	#0
   2280  0ccb		       85 53		      sta	R0+1
   2281  0ccd		       4c 1d 07 	      jmp	pushR0nextIl
   2282  0cd0							;
   2283  0cd0							; Call to address return what ever is in a to the stack
   2284  0cd0							; func2 will load a value into a before the call
   2285  0cd0		       20 d7 2c    iCallFunc  jsr	popR1
   2286  0cd3		       a5 54		      lda	R1
   2287  0cd5		       20 e1 0c 	      jsr	iCallRtn
   2288  0cd8		       85 52		      sta	R0
   2289  0cda		       a9 00		      lda	#0
   2290  0cdc		       85 53		      sta	R0+1
   2291  0cde		       20 1d 07 	      jsr	pushR0nextIl
   2292  0ce1				   iCallRtn
   2293  0ce1		       20 bf 2c 	      jsr	popR0
   2294  0ce4		       6c 52 00 	      jmp	(R0)
   2295  0ce7
   2296  0ce7
   2297  0ce7							;===========================================jlit======
   2298  0ce7							;Get a character from the terminal convert to value
   2299  0ce7							;leave the number on top of the stack
   2300  0ce7							;
   2301  0ce7				   iGETCHAR
   2302  0ce7		       20 61 1a 	      jsr	VGETCH
   2303  0cea					      if	CTMON65
   2304  0cea		       48		      pha
   2305  0ceb		       20 5e 1a 	      jsr	VOUTCH	;echo echo echo
   2306  0cee		       68		      pla
   2307  0cef					      endif
   2308  0cef		       85 52		      sta	R0
   2309  0cf1		       a9 00		      lda	#0
   2310  0cf3		       85 53		      sta	R0+1
   2311  0cf5		       20 2d 2c 	      jsr	pushR0
   2312  0cf8							;
   2313  0cf8		       4c b1 02 	      jmp	NextIL
   2314  0cfb							;===========================================jusilostintim======
   2315  0cfb							;Put a character to the terminal convert to
   2316  0cfb							;
   2317  0cfb		       20 bf 2c    iPUTCHAR   jsr	popR0
   2318  0cfe		       a5 52		      lda	R0
   2319  0d00		       20 5e 1a 	      jsr	VOUTCH
   2320  0d03		       4c b1 02 	      jmp	NextIL
   2321  0d06							;=====================================================
   2322  0d06							; Put the number on the stack out as hex, suppress leading 0
   2323  0d06				   iHexOut
   2324  0d06		       20 bf 2c 	      jsr	popR0
   2325  0d09		       a5 53		      lda	R0+1
   2326  0d0b		       f0 03		      beq	iHexSecondByte
   2327  0d0d		       20 99 21 	      jsr	OUTHEX
   2328  0d10				   iHexSecondByte
   2329  0d10		       a5 52		      lda	R0
   2330  0d12		       20 99 21 	      jsr	OUTHEX
   2331  0d15		       4c b1 02 	      jmp	NextIL
   2332  0d18							;
   2333  0d18							;=====================================================
   2334  0d18							; Replace TOS with its absolute value.
   2335  0d18							;
   2336  0d18		       20 bf 2c    iABS       jsr	popR0
   2337  0d1b		       a5 53		      lda	R0+1
   2338  0d1d		       10 10		      bpl	iABS_1	;already positive
   2339  0d1f		       49 ff		      eor	#$ff
   2340  0d21		       85 53		      sta	R0+1
   2341  0d23		       a5 52		      lda	R0
   2342  0d25		       49 ff		      eor	#$ff
   2343  0d27		       85 52		      sta	R0
   2344  0d29		       e6 52		      inc	R0
   2345  0d2b		       d0 02		      bne	iABS_1
   2346  0d2d		       e6 53		      inc	R0+1
   2347  0d2f		       4c 1d 07    iABS_1     jmp	pushR0nextIl
   2348  0d32
   2349  0d32							;
   2350  0d32							;================================================================
   2351  0d32							; The set of logical operators
   2352  0d32				   iLogAnd
   2353  0d32		       20 bf 2c 	      jsr	popR0
   2354  0d35		       20 d7 2c 	      jsr	popR1
   2355  0d38		       a5 52		      lda	R0
   2356  0d3a		       25 54		      and	R1
   2357  0d3c		       85 52		      sta	R0
   2358  0d3e		       a5 53		      lda	R0+1
   2359  0d40		       25 55		      and	R1+1
   2360  0d42		       85 53		      sta	R0+1
   2361  0d44		       4c 1d 07 	      jmp	pushR0nextIl
   2362  0d47
   2363  0d47				   iLogOr
   2364  0d47		       20 bf 2c 	      jsr	popR0
   2365  0d4a		       20 d7 2c 	      jsr	popR1
   2366  0d4d		       a5 52		      lda	R0
   2367  0d4f		       05 54		      ora	R1
   2368  0d51		       85 52		      sta	R0
   2369  0d53		       a5 53		      lda	R0+1
   2370  0d55		       05 55		      ora	R1+1
   2371  0d57		       85 53		      sta	R0+1
   2372  0d59		       4c 1d 07 	      jmp	pushR0nextIl
   2373  0d5c				   iLogXor
   2374  0d5c		       20 bf 2c 	      jsr	popR0
   2375  0d5f		       20 d7 2c 	      jsr	popR1
   2376  0d62		       a5 52		      lda	R0
   2377  0d64		       45 54		      eor	R1
   2378  0d66		       85 52		      sta	R0
   2379  0d68		       a5 53		      lda	R0+1
   2380  0d6a		       45 55		      eor	R1+1
   2381  0d6c		       85 53		      sta	R0+1
   2382  0d6e		       4c 1d 07 	      jmp	pushR0nextIl
   2383  0d71				   iLogNot
   2384  0d71		       20 bf 2c 	      jsr	popR0
   2385  0d74		       a5 52		      lda	R0
   2386  0d76		       49 ff		      eor	#$FF
   2387  0d78		       85 52		      sta	R0
   2388  0d7a		       a5 53		      lda	R0+1
   2389  0d7c		       49 ff		      eor	#$FF
   2390  0d7e		       85 53		      sta	R0+1
   2391  0d80		       4c 1d 07 	      jmp	pushR0nextIl
   2392  0d83
   2393  0d83				   iTruth
   2394  0d83		       a9 ff		      lda	#$FF
   2395  0d85		       85 52		      sta	R0
   2396  0d87		       85 53		      sta	R0+1
   2397  0d89		       4c 1d 07 	      jmp	pushR0nextIl
   2398  0d8c				   iFalse
   2399  0d8c		       a9 00		      lda	#$00
   2400  0d8e		       85 52		      sta	R0
   2401  0d90		       85 53		      sta	R0+1
   2402  0d92		       4c 1d 07 	      jmp	pushR0nextIl
   2403  0d95							;===============================================================
   2404  0d95							;Shift instruction right 1, left 0
   2405  0d95							;
   2406  0d95		       8a	   iShift     txa
   2407  0d96		       48		      pha
   2408  0d97		       20 bf 2c 	      jsr	popR0	; number of places to shift 0 to 16 really
   2409  0d9a		       20 d7 2c 	      jsr	popR1	; value to shift
   2410  0d9d		       a6 52		      ldx	R0	; get number of times to shift
   2411  0d9f		       20 34 2a 	      jsr	getILByte	; get direction to shift
   2412  0da2		       c9 01		      cmp	#1	; Should we be doing left
   2413  0da4		       f0 0a		      beq	iShiftRight
   2414  0da6							;
   2415  0da6							; Shift r1 left n bits
   2416  0da6				   iShiftLeft
   2417  0da6		       18	   iShiftLloop clc
   2418  0da7		       26 54		      rol	R1
   2419  0da9		       26 55		      rol	R1+1
   2420  0dab		       ca		      dex
   2421  0dac		       d0 f8		      bne	iShiftLloop
   2422  0dae		       f0 07		      beq	iShiftExit
   2423  0db0							;
   2424  0db0							; Shift R1 right n bits
   2425  0db0							;
   2426  0db0				   iShiftRight
   2427  0db0		       46 55	   iShiftRloop lsr	R1+1
   2428  0db2		       46 54		      lsr	R1
   2429  0db4		       ca		      dex
   2430  0db5		       d0 f9		      bne	iShiftRloop
   2431  0db7				   iShiftExit
   2432  0db7		       68		      pla
   2433  0db8		       aa		      tax
   2434  0db9		       20 a5 2c 	      jsr	pushR1
   2435  0dbc		       4c b1 02 	      jmp	NextIL
   2436  0dbf
   2437  0dbf							;================================================================
   2438  0dbf							;Set the IRQ service rtn line number
   2439  0dbf							;
   2440  0dbf		       78	   iSetIrq    sei		; disable the interupts
   2441  0dc0		       a9 00		      lda	#0	; Zero the Status flag
   2442  0dc2		       8d c0 19 	      sta	IRQStatus
   2443  0dc5		       20 bf 2c 	      jsr	popR0	; get the line number
   2444  0dc8		       a5 52		      lda	R0
   2445  0dca		       05 53		      ora	R0+1
   2446  0dcc		       f0 22		      beq	iSetExt	; if it is zero disable all
   2447  0dce		       a9 01		      lda	#GOSUB_RTN	; default push type
   2448  0dd0		       20 47 2c 	      jsr	pushLN	; Save the current line pointer
   2449  0dd3		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2450  0dd5		       4c 3a 0c 	      jmp	ErrStkOver	; Check if there was an error
   2451  0dd8				   iSetIrqOk
   2452  0dd8		       20 79 2a 	      jsr	findLine	; Find the IRQ func Line Pointer
   2453  0ddb		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2454  0ddd		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2455  0ddf		       8d c3 19 	      sta	IRQEntry+1
   2456  0de2		       a5 4f		      lda	CURPTR
   2457  0de4		       8d c2 19 	      sta	IRQEntry
   2458  0de7		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2459  0de9		       8d c0 19 	      sta	IRQStatus
   2460  0dec		       20 70 2c 	      jsr	popLN	; Restore the old line number
   2461  0def		       58		      cli		; Enable the interupts
   2462  0df0		       4c b1 02    iSetExt    jmp	NextIL
   2463  0df3
   2464  0df3		       20 70 2c    iSetIrqErr jsr	popLN
   2465  0df6		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2466  0df8		       a9 00		      lda	#0
   2467  0dfa		       4c 7d 06 	      jmp	iErr2
   2468  0dfd							;
   2469  0dfd		       20 bf 2c    iTRACEPROG jsr	popR0
   2470  0e00		       a5 52		      lda	R0
   2471  0e02		       85 40		      sta	ILTrace
   2472  0e04		       4c b1 02 	      jmp	NextIL
   2473  0e07
   2474  0e07							;=====================================================
   2475  0e07							; Define start of non page zero data
   2476 U433c ????				      seg.u	TBData
   2477 U3666					      org	PROGEND
   2478 U3666							;=================================================================
   2479 U3666							;
   2480 U3666					      if	IL_DEBUG_TEXT
------- FILE ILKeyText.inc LEVEL 2 PASS 6
      0 U3666					      include	"ILKeyText.inc"
      1  0e07					      seg	Code
      2  0e07					      if	IL_DEBUG_TEXT
      3  0e07				   ILTEXTTABLE
      0  0e07					      db	0,23,"iXINIT		   ",0
      1  0e07		       00 17 69 58*	      .byte.b	0,23,"iXINIT		   ",0
      0  0e1e					      db	1,23,"iDONE		   ",0
      1  0e1e		       01 17 69 44*	      .byte.b	1,23,"iDONE		   ",0
      0  0e35					      db	2,23,"iPRS		   ",0
      1  0e35		       02 17 69 50*	      .byte.b	2,23,"iPRS		   ",0
      0  0e4c					      db	3,23,"iPRN		   ",0
      1  0e4c		       03 17 69 50*	      .byte.b	3,23,"iPRN		   ",0
      0  0e63					      db	4,23,"iSPC		   ",0
      1  0e63		       04 17 69 53*	      .byte.b	4,23,"iSPC		   ",0
      0  0e7a					      db	5,23,"iNLINE		   ",0
      1  0e7a		       05 17 69 4e*	      .byte.b	5,23,"iNLINE		   ",0
      0  0e91					      db	6,23,"iNXT		   ",0
      1  0e91		       06 17 69 4e*	      .byte.b	6,23,"iNXT		   ",0
      0  0ea8					      db	7,23,"iXFER		   ",0
      1  0ea8		       07 17 69 58*	      .byte.b	7,23,"iXFER		   ",0
      0  0ebf					      db	8,23,"iSAV		   ",0
      1  0ebf		       08 17 69 53*	      .byte.b	8,23,"iSAV		   ",0
      0  0ed6					      db	9,23,"iRSTR		   ",0
      1  0ed6		       09 17 69 52*	      .byte.b	9,23,"iRSTR		   ",0
      0  0eed					      db	10,23,"iCMPR		    ",0
      1  0eed		       0a 17 69 43*	      .byte.b	10,23,"iCMPR		    ",0
      0  0f04					      db	11,23,"iINNUM		    ",0
      1  0f04		       0b 17 69 49*	      .byte.b	11,23,"iINNUM		    ",0
      0  0f1b					      db	12,23,"iFIN		    ",0
      1  0f1b		       0c 17 69 46*	      .byte.b	12,23,"iFIN		    ",0
      0  0f32					      db	13,23,"iERR		    ",0
      1  0f32		       0d 17 69 45*	      .byte.b	13,23,"iERR		    ",0
      0  0f49					      db	14,23,"iADD		    ",0
      1  0f49		       0e 17 69 41*	      .byte.b	14,23,"iADD		    ",0
      0  0f60					      db	15,23,"iSUB		    ",0
      1  0f60		       0f 17 69 53*	      .byte.b	15,23,"iSUB		    ",0
      0  0f77					      db	16,23,"iNEG		    ",0
      1  0f77		       10 17 69 4e*	      .byte.b	16,23,"iNEG		    ",0
      0  0f8e					      db	17,23,"iMUL		    ",0
      1  0f8e		       11 17 69 4d*	      .byte.b	17,23,"iMUL		    ",0
      0  0fa5					      db	18,23,"iDIV		    ",0
      1  0fa5		       12 17 69 44*	      .byte.b	18,23,"iDIV		    ",0
      0  0fbc					      db	19,23,"iSTORE		    ",0
      1  0fbc		       13 17 69 53*	      .byte.b	19,23,"iSTORE		    ",0
      0  0fd3					      db	20,23,"iIND		    ",0
      1  0fd3		       14 17 69 49*	      .byte.b	20,23,"iIND		    ",0
      0  0fea					      db	21,23,"iLST		    ",0
      1  0fea		       15 17 69 4c*	      .byte.b	21,23,"iLST		    ",0
      0  1001					      db	22,23,"iINIT		    ",0
      1  1001		       16 17 69 49*	      .byte.b	22,23,"iINIT		    ",0
      0  1018					      db	23,23,"iGETLINE	    ",0
      1  1018		       17 17 69 47*	      .byte.b	23,23,"iGETLINE	    ",0
      0  102f					      db	24,23,"iINSRT		    ",0
      1  102f		       18 17 69 49*	      .byte.b	24,23,"iINSRT		    ",0
      0  1046					      db	25,23,"iRTN		    ",0
      1  1046		       19 17 69 52*	      .byte.b	25,23,"iRTN		    ",0
      0  105d					      db	26,23,"MONITOR 	    ",0
      1  105d		       1a 17 4d 4f*	      .byte.b	26,23,"MONITOR 	    ",0
      0  1074					      db	27,23,"iLIT		    ",0
      1  1074		       1b 17 69 4c*	      .byte.b	27,23,"iLIT		    ",0
      0  108b					      db	28,23,"iCALL		    ",0
      1  108b		       1c 17 69 43*	      .byte.b	28,23,"iCALL		    ",0
      0  10a2					      db	29,23,"iJMP		    ",0
      1  10a2		       1d 17 69 4a*	      .byte.b	29,23,"iJMP		    ",0
      0  10b9					      db	30,23,"iVINIT		    ",0
      1  10b9		       1e 17 69 56*	      .byte.b	30,23,"iVINIT		    ",0
      0  10d0					      db	31,23,"iERRGOTO	    ",0
      1  10d0		       1f 17 69 45*	      .byte.b	31,23,"iERRGOTO	    ",0
      0  10e7					      db	32,23,"iTST		    ",0
      1  10e7		       20 17 69 54*	      .byte.b	32,23,"iTST		    ",0
      0  10fe					      db	33,23,"iTSTV		    ",0
      1  10fe		       21 17 69 54*	      .byte.b	33,23,"iTSTV		    ",0
      0  1115					      db	34,23,"iTSTL		    ",0
      1  1115		       22 17 69 54*	      .byte.b	34,23,"iTSTL		    ",0
      0  112c					      db	35,23,"iTSTN		    ",0
      1  112c		       23 17 69 54*	      .byte.b	35,23,"iTSTN		    ",0
      0  1143					      db	36,23,"iFREE		    ",0
      1  1143		       24 17 69 46*	      .byte.b	36,23,"iFREE		    ",0
      0  115a					      db	37,23,"iRANDOM 	    ",0
      1  115a		       25 17 69 52*	      .byte.b	37,23,"iRANDOM 	    ",0
      0  1171					      db	38,23,"iABS		    ",0
      1  1171		       26 17 69 41*	      .byte.b	38,23,"iABS		    ",0
      0  1188					      db	39,23,"iOPENREAD	    ",0
      1  1188		       27 17 69 4f*	      .byte.b	39,23,"iOPENREAD	    ",0
      0  119f					      db	40,23,"iOPENWRITE	    ",0
      1  119f		       28 17 69 4f*	      .byte.b	40,23,"iOPENWRITE	    ",0
      0  11b6					      db	41,23,"iDCLOSE 	    ",0
      1  11b6		       29 17 69 44*	      .byte.b	41,23,"iDCLOSE 	    ",0
      0  11cd					      db	42,23,"iDGETLINE	    ",0
      1  11cd		       2a 17 69 44*	      .byte.b	42,23,"iDGETLINE	    ",0
      0  11e4					      db	43,23,"iDLIST		    ",0
      1  11e4		       2b 17 69 44*	      .byte.b	43,23,"iDLIST		    ",0
      0  11fb					      db	44,23,"iDDIR		    ",0
      1  11fb		       2c 17 69 44*	      .byte.b	44,23,"iDDIR		    ",0
      0  1212					      db	45,23,"iRMFILE 	    ",0
      1  1212		       2d 17 69 52*	      .byte.b	45,23,"iRMFILE 	    ",0
      0  1229					      db	39,23,"NextIL		    ",0
      1  1229		       27 17 4e 65*	      .byte.b	39,23,"NextIL		    ",0
      0  1240					      db	40,23,"NextIL		    ",0
      1  1240		       28 17 4e 65*	      .byte.b	40,23,"NextIL		    ",0
      0  1257					      db	41,23,"NextIL		    ",0
      1  1257		       29 17 4e 65*	      .byte.b	41,23,"NextIL		    ",0
      0  126e					      db	42,23,"NextIL		    ",0
      1  126e		       2a 17 4e 65*	      .byte.b	42,23,"NextIL		    ",0
      0  1285					      db	43,23,"NextIL		    ",0
      1  1285		       2b 17 4e 65*	      .byte.b	43,23,"NextIL		    ",0
      0  129c					      db	44,23,"NextIL		    ",0
      1  129c		       2c 17 4e 65*	      .byte.b	44,23,"NextIL		    ",0
      0  12b3					      db	45,23,"NextIL		    ",0
      1  12b3		       2d 17 4e 65*	      .byte.b	45,23,"NextIL		    ",0
      0  12ca					      db	46,23,"iCLEARSCREEN	    ",0
      1  12ca		       2e 17 69 43*	      .byte.b	46,23,"iCLEARSCREEN	    ",0
      0  12e1					      db	47,23,"iPOKEMEMORY	    ",0
      1  12e1		       2f 17 69 50*	      .byte.b	47,23,"iPOKEMEMORY	    ",0
      0  12f8					      db	48,23,"iPEEKMEMORY	    ",0
      1  12f8		       30 17 69 50*	      .byte.b	48,23,"iPEEKMEMORY	    ",0
      0  130f					      db	49,23,"iTSTLET 	    ",0
      1  130f		       31 17 69 54*	      .byte.b	49,23,"iTSTLET 	    ",0
      0  1326					      db	50,23,"iTSTDONE	    ",0
      1  1326		       32 17 69 54*	      .byte.b	50,23,"iTSTDONE	    ",0
      0  133d					      db	51,23,"iGETCHAR	    ",0
      1  133d		       33 17 69 47*	      .byte.b	51,23,"iGETCHAR	    ",0
      0  1354					      db	52,23,"iPUTCHAR	    ",0
      1  1354		       34 17 69 50*	      .byte.b	52,23,"iPUTCHAR	    ",0
      0  136b					      db	53,23,"iCallFunc	    ",0
      1  136b		       35 17 69 43*	      .byte.b	53,23,"iCallFunc	    ",0
      0  1382					      db	54,23,"iBranch 	    ",0
      1  1382		       36 17 69 42*	      .byte.b	54,23,"iBranch 	    ",0
      0  1399					      db	55,23,"iTSTStr 	    ",0
      1  1399		       37 17 69 54*	      .byte.b	55,23,"iTSTStr 	    ",0
      0  13b0					      db	56,23,"iSetIrq 	    ",0
      1  13b0		       38 17 69 53*	      .byte.b	56,23,"iSetIrq 	    ",0
      0  13c7					      db	57,23,"iTstIrq 	    ",0
      1  13c7		       39 17 69 54*	      .byte.b	57,23,"iTstIrq 	    ",0
      0  13de					      db	58,23,"iRET		    ",0
      1  13de		       3a 17 69 52*	      .byte.b	58,23,"iRET		    ",0
      0  13f5					      db	59,23,"iINSTR		    ",0
      1  13f5		       3b 17 69 49*	      .byte.b	59,23,"iINSTR		    ",0
      0  140c					      db	60,23,"iMOD		    ",0
      1  140c		       3c 17 69 4d*	      .byte.b	60,23,"iMOD		    ",0
      0  1423					      db	61,23,"iTaskSet	    ",0
      1  1423		       3d 17 69 54*	      .byte.b	61,23,"iTaskSet	    ",0
      0  143a					      db	62,23,"iETask		    ",0
      1  143a		       3e 17 69 45*	      .byte.b	62,23,"iETask		    ",0
      0  1451					      db	63,23,"iNTask		    ",0
      1  1451		       3f 17 69 4e*	      .byte.b	63,23,"iNTask		    ",0
      0  1468					      db	64,23,"iArray		    ",0
      1  1468		       40 17 69 41*	      .byte.b	64,23,"iArray		    ",0
      0  147f					      db	65,23,"iTaskKill	    ",0
      1  147f		       41 17 69 54*	      .byte.b	65,23,"iTaskKill	    ",0
      0  1496					      db	66,23,"iTaskStat	    ",0
      1  1496		       42 17 69 54*	      .byte.b	66,23,"iTaskStat	    ",0
      0  14ad					      db	67,23,"iHexOut 	    ",0
      1  14ad		       43 17 69 48*	      .byte.b	67,23,"iHexOut 	    ",0
      0  14c4					      db	68,23,"iReadComplete	    ",0
      1  14c4		       44 17 69 52*	      .byte.b	68,23,"iReadComplete	    ",0
      0  14db					      db	69,23,"iReadStart	    ",0
      1  14db		       45 17 69 52*	      .byte.b	69,23,"iReadStart	    ",0
      0  14f2					      db	70,23,"iStartIO	    ",0
      1  14f2		       46 17 69 53*	      .byte.b	70,23,"iStartIO	    ",0
      0  1509					      db	71,23,"iEndIO		    ",0
      1  1509		       47 17 69 45*	      .byte.b	71,23,"iEndIO		    ",0
      0  1520					      db	72,23,"iLogNot 	    ",0
      1  1520		       48 17 69 4c*	      .byte.b	72,23,"iLogNot 	    ",0
      0  1537					      db	73,23,"iLogOr		    ",0
      1  1537		       49 17 69 4c*	      .byte.b	73,23,"iLogOr		    ",0
      0  154e					      db	74,23,"iLogAnd 	    ",0
      1  154e		       4a 17 69 4c*	      .byte.b	74,23,"iLogAnd 	    ",0
      0  1565					      db	75,23,"iLogXor 	    ",0
      1  1565		       4b 17 69 4c*	      .byte.b	75,23,"iLogXor 	    ",0
      0  157c					      db	76,23,"iWTASK		    ",0
      1  157c		       4c 17 69 57*	      .byte.b	76,23,"iWTASK		    ",0
      0  1593					      db	77,23,"iTASKPID	    ",0
      1  1593		       4d 17 69 54*	      .byte.b	77,23,"iTASKPID	    ",0
      0  15aa					      db	78,23,"iTRACEPROG	    ",0
      1  15aa		       4e 17 69 54*	      .byte.b	78,23,"iTRACEPROG	    ",0
      0  15c1					      db	79,23,"idbgBasic	    ",0
      1  15c1		       4f 17 69 64*	      .byte.b	79,23,"idbgBasic	    ",0
      0  15d8					      db	80,23,"iIPCS		    ",0
      1  15d8		       50 17 69 49*	      .byte.b	80,23,"iIPCS		    ",0
      0  15ef					      db	81,23,"iIPCR		    ",0
      1  15ef		       51 17 69 49*	      .byte.b	81,23,"iIPCR		    ",0
      0  1606					      db	82,23,"iIPCC		    ",0
      1  1606		       52 17 69 49*	      .byte.b	82,23,"iIPCC		    ",0
      0  161d					      db	83,23,"iIPCIO		    ",0
      1  161d		       53 17 69 49*	      .byte.b	83,23,"iIPCIO		    ",0
      0  1634					      db	84,23,"iPushMathStack	    ",0
      1  1634		       54 17 69 50*	      .byte.b	84,23,"iPushMathStack	    ",0
      0  164b					      db	85,23,"iPopMathStack	    ",0
      1  164b		       55 17 69 50*	      .byte.b	85,23,"iPopMathStack	    ",0
      0  1662					      db	86,23,"iSaveMathStack	    ",0
      1  1662		       56 17 69 53*	      .byte.b	86,23,"iSaveMathStack	    ",0
      0  1679					      db	87,23,"iRestoreMathStack   ",0
      1  1679		       57 17 69 52*	      .byte.b	87,23,"iRestoreMathStack   ",0
      0  1690					      db	88,23,"iIncParmCount	    ",0
      1  1690		       58 17 69 49*	      .byte.b	88,23,"iIncParmCount	    ",0
      0  16a7					      db	89,23,"iTaskGetMathStack   ",0
      1  16a7		       59 17 69 54*	      .byte.b	89,23,"iTaskGetMathStack   ",0
      0  16be					      db	90,23,"iTaskEnable	    ",0
      1  16be		       5a 17 69 54*	      .byte.b	90,23,"iTaskEnable	    ",0
      0  16d5					      db	91,23,"iTaskSuspend	    ",0
      1  16d5		       5b 17 69 54*	      .byte.b	91,23,"iTaskSuspend	    ",0
      0  16ec					      db	92,23,"iTaskPutMathPtr     ",0
      1  16ec		       5c 17 69 54*	      .byte.b	92,23,"iTaskPutMathPtr     ",0
      0  1703					      db	93,23,"iTSTVT		    ",0
      1  1703		       5d 17 69 54*	      .byte.b	93,23,"iTSTVT		    ",0
      0  171a					      db	94,23,"iSetR2		    ",0
      1  171a		       5e 17 69 53*	      .byte.b	94,23,"iSetR2		    ",0
      0  1731					      db	95,23,"iStk2Tmp	    ",0
      1  1731		       5f 17 69 53*	      .byte.b	95,23,"iStk2Tmp	    ",0
      0  1748					      db	96,23,"iTmp2Stk	    ",0
      1  1748		       60 17 69 54*	      .byte.b	96,23,"iTmp2Stk	    ",0
      0  175f					      db	97,23,"iTSTBYTE	    ",0
      1  175f		       61 17 69 54*	      .byte.b	97,23,"iTSTBYTE	    ",0
      0  1776					      db	98,23,"iINCVAR 	    ",0
      1  1776		       62 17 69 49*	      .byte.b	98,23,"iINCVAR 	    ",0
      0  178d					      db	99,23,"iDECVAR 	    ",0
      1  178d		       63 17 69 44*	      .byte.b	99,23,"iDECVAR 	    ",0
      0  17a4					      db	100,23,"iSLICE 	     ",0
      1  17a4		       64 17 69 53*	      .byte.b	100,23,"iSLICE 	     ",0
      0  17bb					      db	101,23,"iTSTB		     ",0
      1  17bb		       65 17 69 54*	      .byte.b	101,23,"iTSTB		     ",0
      0  17d2					      db	102,23,"iTSTW		     ",0
      1  17d2		       66 17 69 54*	      .byte.b	102,23,"iTSTW		     ",0
      0  17e9					      db	103,23,"iOnGoto	     ",0
      1  17e9		       67 17 69 4f*	      .byte.b	103,23,"iOnGoto	     ",0
      0  1800					      db	104,23,"iTSTRELOP	     ",0
      1  1800		       68 17 69 54*	      .byte.b	104,23,"iTSTRELOP	     ",0
      0  1817					      db	105,23,"iRepeatLine	     ",0
      1  1817		       69 17 69 52*	      .byte.b	105,23,"iRepeatLine	     ",0
      0  182e					      db	106,23,"iTSTBRANCH	     ",0
      1  182e		       6a 17 69 54*	      .byte.b	106,23,"iTSTBRANCH	     ",0
      0  1845					      db	107,23,"iFastXfer	     ",0
      1  1845		       6b 17 69 46*	      .byte.b	107,23,"iFastXfer	     ",0
      0  185c					      db	108,23,"iSetTerminal	     ",0
      1  185c		       6c 17 69 53*	      .byte.b	108,23,"iSetTerminal	     ",0
      0  1873					      db	109,23,"iINDB		     ",0
      1  1873		       6d 17 69 49*	      .byte.b	109,23,"iINDB		     ",0
      0  188a					      db	110,23,"iSetBlock	     ",0
      1  188a		       6e 17 69 53*	      .byte.b	110,23,"iSetBlock	     ",0
      0  18a1					      db	111,23,"iCopyBlock	     ",0
      1  18a1		       6f 17 69 43*	      .byte.b	111,23,"iCopyBlock	     ",0
      0  18b8					      db	112,23,"iCmpBlock	     ",0
      1  18b8		       70 17 69 43*	      .byte.b	112,23,"iCmpBlock	     ",0
      0  18cf					      db	113,23,"iShift 	     ",0
      1  18cf		       71 17 69 53*	      .byte.b	113,23,"iShift 	     ",0
      0  18e6					      db	114,23,"iTimer 	     ",0
      1  18e6		       72 17 69 54*	      .byte.b	114,23,"iTimer 	     ",0
      0  18fd					      db	$FF,23,"0		     ",0
      1  18fd		       ff 17 30 20*	      .byte.b	$FF,23,"0		     ",0
    127  1914
    128  1914							; Search for the il instruction and print the correct text for it
    129  1914							; on entry a contains the ip instruction to print
    130  1914
    131 U3666					      seg.u	TBData
    132 U3666		       00 00	   R0TempIL   ds	2
    133 U3668		       00	   ILSTA      ds	1
    134 U3669
    135  1914					      Seg	Code
    136  1914
    137  1914		       8d 68 36    PrintILText sta	ILSTA
    138  1917		       98		      tya
    139  1918		       48		      pha
    140  1919		       8a		      txa
    141  191a		       48		      pha
    142  191b		       a5 52		      lda	R0
    143  191d		       8d 66 36 	      sta	R0TempIL
    144  1920		       a5 53		      lda	R0+1
    145  1922		       8d 66 36 	      sta	R0TempIL
    146  1925		       a9 07		      lda	#ILTEXTTABLE&$FF
    147  1927		       85 52		      sta	R0
    148  1929		       a9 0e		      LDA	#ILTEXTTABLE>>8
    149  192b		       85 53		      sta	R0+1
    150  192d							;Loop Here for each entry
    151  192d		       a0 00	   PrintILLoop ldy	#0
    152  192f		       b1 52		      lda	(R0),y
    153  1931		       c9 ff		      cmp	#$FF
    154  1933		       f0 2a		      beq	PrintILNotFound
    155  1935		       cd 68 36 	      cmp	ILSTA
    156  1938		       f0 11		      beq	PrintILFound
    157  193a		       c8		      iny
    158  193b		       b1 52		      lda	(R0),y
    159  193d		       18		      clc
    160  193e		       65 52		      adc	R0
    161  1940		       85 52		      sta	R0
    162  1942		       a9 00		      lda	#0
    163  1944		       65 53		      adc	R0+1
    164  1946		       85 53		      sta	R0+1
    165  1948		       4c 2d 19 	      jmp	PrintILLoop
    166  194b							; The text was discovered
    167  194b		       c8	   PrintILFound iny		; point to length of instruction
    168  194c		       c8		      iny		; Point to start of text
    169  194d		       98		      tya
    170  194e		       18		      clc
    171  194f		       65 52		      adc	R0
    172  1951		       a8		      tay		; Low order byte of address
    173  1952		       a9 00		      lda	#0
    174  1954		       65 53		      adc	R0+1
    175  1956		       aa		      tax		; High order byte of address
    176  1957		       a9 00		      lda	#0	; Termination byte of string
    177  1959		       20 f4 21 	      jsr	PrtStr	; print the string
    178  195c		       4c 65 19 	      jmp	PrintILDone
    179  195f
    180  195f		       ad 68 36    PrintILNotFound lda	ILSTA
    181  1962		       20 99 21 	      jsr	HexToOut
    182  1965
    183  1965		       ad 66 36    PrintILDone lda	R0TempIL
    184  1968		       85 52		      sta	R0
    185  196a		       ad 67 36 	      lda	R0TempIL+1
    186  196d		       85 52		      sta	R0
    187  196f		       68		      pla
    188  1970		       aa		      tax
    189  1971		       68		      pla
    190  1972		       a8		      tay
    191  1973		       60		      rts
    192  1974					      endif
------- FILE mytb.asm
   2482  1974					      endif
------- FILE time.asm LEVEL 2 PASS 6
      0  1974					      include	"time.asm"
      1  1974							;This is the timer management functions
      2  1974							; a = 0 turn off irq, stop timer
      3  1974							; a = 1 turn on irq, set parm contained in x
      4  1974							; a = 4 get low value
      5  1974							; a = 2 get high value
      6  1974
      7  1974		       e0 10	   timerinterface equ	$E010
      8  1974		       00 1e	   cTimerControl equ	$1E
      9  1974		       00 00	   cTimerStop equ	0
     10  1974		       00 01	   cTimerStart equ	1
     11  1974		       00 02	   cTimerLow  equ	2
     12  1974		       00 04	   cTimerHigh equ	4
     13  1974
     14  1974							; returns	$82 ack    dec(130)
     15  1974							;		$83 Failed dec(131)
     16  1974
     17  1974							; il interface to the timer
     18  1974
     19  1974				   iTimer
     20  1974		       20 bf 2c 	      jsr	popR0
     21  1977		       a6 52		      ldx	R0	; Set time parameter
     22  1979		       20 bf 2c 	      jsr	popR0
     23  197c		       a5 52		      lda	R0	; control parameter 0-4
     24  197e		       20 88 19 	      jsr	iTimerif
     25  1981		       85 52		      sta	R0
     26  1983		       86 53		      stx	R0+1
     27  1985		       4c 1d 07 	      jmp	pushR0nextIl
     28  1988
     29  1988							; Actual system interface to the timer
     30  1988							; x is value 9 = 1 second, 1-5 = value * 10ms 6 = 100ms, 7=250ms, 8=500ms, 0 = stop timer
     31  1988							; a is 0,1,2,4
     32  1988				   iTimerif
     33  1988
     34  1988		       c9 02		      cmp	#cTimerLow	; Do they want the low byte
     35  198a		       b0 25		      bcs	iTimerValue	; Just get the value we need
     36  198c		       78		      sei		; Disable the interupts
     37  198d		       48		      pha		; save the command
     38  198e		       a9 1e		      lda	#cTimerControl	; Load the timer control command
     39  1990		       8d 10 e0 	      sta	timerinterface	; Write it to the timer port
     40  1993		       8a		      txa		; get value to write, if cmd = 0 stop then x is init to zero
     41  1994		       8d 10 e0 	      sta	timerinterface	; write it to the port the timeout value
     42  1997		       68		      pla		; Get the actual command back
     43  1998		       c9 00		      cmp	#cTimerStop	; if the command was stop timer just get out
     44  199a		       f0 0f		      beq	iTimerAck	; if not then get ack/nak and continue
     45  199c
     46  199c		       a9 00		      lda	#0	; Clear the counter
     47  199e		       8d 2e 43 	      sta	timercounter
     48  19a1		       8d 2f 43 	      sta	timercounter+1
     49  19a4		       8d 30 43 	      sta	timercounter+2
     50  19a7		       8d 31 43 	      sta	timercounter+3
     51  19aa		       58		      cli		; enable the interupts, this is start/restart timer
     52  19ab
     53  19ab				   iTimerAck
     54  19ab		       ad 10 e0 	      lda	timerinterface	; get the ack nak
     55  19ae		       a2 00		      ldx	#0	; the ack value is single byte so pad with x
     56  19b0		       60		      rts		; Get out of here
     57  19b1
     58  19b1				   iTimerValue		; get the value from the offsets provided
     59  19b1		       08		      php		; Save the flags so we can restore irq setting later
     60  19b2		       78		      sei		; turn off the interupts
     61  19b3		       aa		      tax		; the control is also the value
     62  19b4		       bd 2c 43 	      lda	[timercounter-2],x	; get the high byte of value
     63  19b7		       48		      pha		; Save the value for x set
     64  19b8		       bd 2d 43 	      lda	[timercounter-1],x	; get the low part of value
     65  19bb		       aa		      tax
     66  19bc		       68		      pla
     67  19bd		       28		      plp		; restore the interupt flag if it was enabled
     68  19be		       60		      rts
     69  19bf
     70  19bf
     71  19bf
------- FILE mytb.asm
------- FILE io.asm LEVEL 2 PASS 6
      0  19bf					      include	"io.asm"
      1  19bf							; This is the io blocks and function for reading and writing
      2  19bf							; to devices attached to this computer.
      3  19bf							; This supports devices mapped at e000 thru efff in slot sizes of 16 byte
      4  19bf							;
      5  19bf							;=====================================================================
      6  19bf							; Device configuration equates
      7  19bf		       00 00	   ConsoleID  equ	0
      8  19bf		       00 08	   SerialID   equ	[1<<3]
      9  19bf		       00 10	   ClockID    equ	[2<<3]
     10  19bf		       00 18	   TimerID    equ	[3<<3]
     11  19bf		       00 20	   DiskID     equ	[4<<3]
     12  19bf
     13  19bf		       00 0a	   IO_MAX_DEVICES equ	10
     14  19bf		       00 06	   IO_VECT_LEN equ	6
     15  19bf
     16  19bf		       00 01	   IO_DEVICE_CLOSED equ	1	; The device is not open
     17  19bf		       00 02	   IO_DEVICE_INVALID equ	2	; The Device number provided is invalid
     18  19bf
     19  19bf							;========================================================================================
     20  19bf							; Uninitialized data segment
     21 U3669					      seg.u	TBData
     22 U3669
     23 U3669		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
     24 U366b		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
     25 U366d		       00 00	   BStatVec   ds	2	; This is used by inteface to read write status/config information
      0 U366f				   BActiveDevice db	1	; the index of the current device block
      1 U366f		       01		      .byte.b	1
      0 U3670				   BActiveDriver db	1	; Index of the device driver block
      1 U3670		       01		      .byte.b	1
     28 U3671
     29 U3671							;============================================================================================
     30  19bf					      Seg	Code
     31  19bf							; IRQ BASIC Code Service RTN Support
      0  19bf				   SaveIrqReg db	0	; Store current setting
      1  19bf		       00		      .byte.b	0
      0  19c0				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1  19c0		       00		      .byte.b	0
      0  19c1				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1  19c1		       00		      .byte.b	0
      0  19c2				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1  19c2		       00 00		      .byte.b	0,0
     36  19c4
     37  19c4							;============================================================================================
     38  19c4							; Define the device interface blocks
     39  19c4				   DeviceDriverBlocks
     40  19c4				   ConsoleDevice		; Block 0
      0  19c4					      dw	ConsoleID	; device idenifier Console
      1  19c4		       00 00		      .word.w	ConsoleID
      0  19c6					      dw	cin	; read function vector
      1  19c6		       09 f0		      .word.w	cin
      0  19c8					      dw	cout	; write function vector
      1  19c8		       0c f0		      .word.w	cout
      0  19ca					      dw	cstatus	; Get current Status info/Write config
      1  19ca		       0f f0		      .word.w	cstatus
     45  19cc
     46  19cc				   SerialDevice 		; Block 1
      0  19cc					      dw	SerialID	; device idenifier Serial
      1  19cc		       08 00		      .word.w	SerialID
      0  19ce					      dw	SerialIn	; read function vector
      1  19ce		       ba 1a		      .word.w	SerialIn
      0  19d0					      dw	SerialOut	; write function vector
      1  19d0		       ba 1a		      .word.w	SerialOut
      0  19d2					      dw	SerialStatus	; Get current Status info/Write config
      1  19d2		       ba 1a		      .word.w	SerialStatus
     51  19d4
     52  19d4				   ClockDevice		; Block 2
      0  19d4					      dw	ClockID	; Day/date Clock
      1  19d4		       10 00		      .word.w	ClockID
      0  19d6					      dw	ClockRead	; Read the date from clock
      1  19d6		       bb 1a		      .word.w	ClockRead
      0  19d8					      dw	ClockWrite	; Set the date/time of clock
      1  19d8		       bb 1a		      .word.w	ClockWrite
      0  19da					      dw	#0	; No Status/Config Function
      1  19da		       00 00		      .word.w	#0
     57  19dc
     58  19dc				   TimerDevice		; Block 3
      0  19dc					      dw	TimerID	; Timer/interrupt interface
      1  19dc		       18 00		      .word.w	TimerID
      0  19de					      dw	TimerStart	; Start the timer
      1  19de		       bc 1a		      .word.w	TimerStart
      0  19e0					      dw	TimerStop	; Stop the timer
      1  19e0		       bc 1a		      .word.w	TimerStop
      0  19e2					      dw	TimerStatus	; Config/read status
      1  19e2		       bc 1a		      .word.w	TimerStatus
     63  19e4
      0  19e4				   DiskDevice dw	DiskID	; Block 4
      1  19e4		       20 00		      .word.w	DiskID
      0  19e6					      dw	DIN	; Disk Input / read function
      1  19e6		       66 31		      .word.w	DIN
      0  19e8					      dw	DOUT	; Disk Output / write function
      1  19e8		       4d 31		      .word.w	DOUT
      0  19ea					      dw	DSTAT	; Disk Status/open/close etc information
      1  19ea		       7f 31		      .word.w	DSTAT
     68  19ec							;
     69  19ec							;======================================================================
     70  19ec							; Define the Device/Slot,driver control blocks
     71  19ec							; entry format: ControlWord,DeviceDriver,PortAddress,StatusWord
     72  19ec							; Fixed at 10 devices memory usage is getting pretty big!!!!!!
     73  19ec							; Control word : bit 0 = active 1, Free 0
     74  19ec
     75  19ec				   DeviceIoBlocks
      0  19ec					      dw	1, ConsoleID, $E000, 0	; Console device is 0 file
      1  19ec		       01 00 00 00*	      .word.w	1, ConsoleID, $E000, 0
      0  19f4					      dw	1, ClockID, $E010, 0	; Port for the day/time clock
      1  19f4		       01 00 10 00*	      .word.w	1, ClockID, $E010, 0
      0  19fc					      dw	1, TimerID, $E010, 0	; Timer interface
      1  19fc		       01 00 18 00*	      .word.w	1, TimerID, $E010, 0
      0  1a04					      dw	1, DiskID, $E010, 0	; Disk Driver interface
      1  1a04		       01 00 20 00*	      .word.w	1, DiskID, $E010, 0
      0  1a0c					      dw	1, SerialID, $E020, 0	; Second terminal(default Basic debug)
      1  1a0c		       01 00 08 00*	      .word.w	1, SerialID, $E020, 0
      0  1a14					      dw	0, SerialID, $E030, 0	; Unused slot
      1  1a14		       00 00 08 00*	      .word.w	0, SerialID, $E030, 0
      0  1a1c					      dw	0, SerialID, $E040, 0	; Unused slot
      1  1a1c		       00 00 08 00*	      .word.w	0, SerialID, $E040, 0
      0  1a24					      dw	0, SerialID, $E050, 0	; Unused slot
      1  1a24		       00 00 08 00*	      .word.w	0, SerialID, $E050, 0
      0  1a2c					      dw	0, SerialID, $E060, 0	; Unused slot
      1  1a2c		       00 00 08 00*	      .word.w	0, SerialID, $E060, 0
      0  1a34					      dw	0, SerialID, $E070, 0	; Unused slot
      1  1a34		       00 00 08 00*	      .word.w	0, SerialID, $E070, 0
     86  1a3c							;
     87  1a3c							;======================================================================
     88  1a3c							;
     89  1a3c					      Seg	Code
     90  1a3c							;======================================================================
     91  1a3c							; This is the Basic IRQ handler, works with task manager, assumes timer interupt
     92  1a3c							;
     93  1a3c		       48	   ServiceIrq pha
     94  1a3d		       8a		      txa
     95  1a3e		       48		      pha
     96  1a3f		       a2 00		      ldx	#0
     97  1a41				   ServiceLoop
     98  1a41		       fe 2e 43 	      inc	timercounter,x
     99  1a44		       d0 05		      bne	ServiceCont
    100  1a46		       e8		      inx
    101  1a47		       e0 04		      cpx	#4
    102  1a49		       d0 f6		      bne	ServiceLoop
    103  1a4b				   ServiceCont
    104  1a4b		       ad c0 19 	      lda	IRQStatus
    105  1a4e		       f0 0a		      beq	RetIrq
    106  1a50		       ad c1 19 	      lda	IRQPending
    107  1a53		       d0 05		      bne	RetIrq
    108  1a55		       a9 01		      lda	#1
    109  1a57		       8d c1 19 	      sta	IRQPending
    110  1a5a				   RetIrq
    111  1a5a		       68		      pla
    112  1a5b		       aa		      tax
    113  1a5c		       68		      pla
    114  1a5d		       40		      rti
    115  1a5e							;======================================================================
    116  1a5e							; Jump to the output/input function in BOutVec/BInVec
    117  1a5e							;
    118  1a5e		       6c 6b 36    VOUTCH     jmp	(BOutVec)	; Primary block io vectors
    119  1a61		       6c 69 36    VGETCH     jmp	(BInVec)
    120  1a64		       6c 6d 36    VSTAT      jmp	(BStatVec)
    121  1a67							;
    122  1a67							;======================================================================
    123  1a67							; IO Service functions
    124  1a67							; Validate the device index and set x to offest in table
    125  1a67							; does not return to ioInterface if invalid, returns to original caller
    126  1a67							; should be called immediatly after entering the ioInterface call
    127  1a67				   ioValidateDevice
    128  1a67		       e0 0a		      cpx	#IO_MAX_DEVICES
    129  1a69		       90 04		      bcc	ioValidIndex
    130  1a6b		       a2 02		      ldx	#IO_DEVICE_INVALID
    131  1a6d		       b0 13		      bcs	ioInvalidDevice
    132  1a6f				   ioValidIndex
    133  1a6f		       8a		      txa
    134  1a70		       0a		      asl		; Multiply by 8
    135  1a71		       0a		      asl
    136  1a72		       0a		      asl
    137  1a73		       aa		      tax		; Point to actual offset in the table
    138  1a74		       ec 6f 36 	      cpx	BActiveDevice	; is it already active ?
    139  1a77		       f0 0d		      beq	ioValidDevice	; Shortcut if this is the active device already
    140  1a79		       a9 01		      lda	#1	; Active flag
    141  1a7b		       3d ec 19 	      and	DeviceIoBlocks,x	; Check if the device is active
    142  1a7e		       d0 06		      bne	ioValidDevice	; The device is active and valid index
    143  1a80		       a2 01		      ldx	#IO_DEVICE_CLOSED
    144  1a82
    145  1a82				   ioInvalidDevice
    146  1a82		       68		      pla		; Remove return address of IO interface
    147  1a83		       68		      pla
    148  1a84		       38		      sec		; ensure that carry is set
    149  1a85		       60		      rts
    150  1a86
    151  1a86				   ioValidDevice
    152  1a86		       18		      clc
    153  1a87		       60		      rts
    154  1a88							;
    155  1a88							;===================================================================================
    156  1a88							; Set the io device jmp vectors
    157  1a88							; input x contains the vector to the active Device IO Block
    158  1a88							; output a, x undefined y unchanged
    159  1a88				   ioSetDeviceVectors
    160  1a88		       ec 6f 36 	      cpx	BActiveDevice	; Check if already set
    161  1a8b		       f0 1b		      beq	ioSetDevExit	; if already set then do nothing
    162  1a8d
    163  1a8d		       8e 6f 36 	      stx	BActiveDevice	; set the active device vector
    164  1a90		       98		      tya
    165  1a91		       48		      pha
    166  1a92
    167  1a92		       bc ee 19 	      ldy	DeviceIoBlocks+2,x	; Get the device driver index
    168  1a95		       8c 70 36 	      sty	BActiveDriver	; Pointer to active Device driver
    169  1a98		       a2 00		      ldx	#0	; Transfer the 6 pointers to the Vectors
    170  1a9a				   ioSetDevLoop
    171  1a9a		       b9 c6 19 	      lda	DeviceDriverBlocks+2,y
    172  1a9d		       9d 69 36 	      sta	BInVec,x
    173  1aa0		       e8		      inx
    174  1aa1		       c8		      iny
    175  1aa2		       e0 06		      cpx	#IO_VECT_LEN	; Transfer the vector length to copy
    176  1aa4		       d0 f4		      bne	ioSetDevLoop
    177  1aa6
    178  1aa6		       68		      pla
    179  1aa7		       a8		      tay
    180  1aa8				   ioSetDevExit
    181  1aa8		       60		      rts
    182  1aa9							;
    183  1aa9							;======================================================================
    184  1aa9							; Generic call interface for devices
    185  1aa9							; input x = DeviceIoBlockIndex
    186  1aa9							; Carry set if error, x contains the error code
    187  1aa9							; all other parameters are dependant upon the actual device interface
    188  1aa9							;
    189  1aa9							; ioPutCH  a contains the character to send
    190  1aa9		       20 67 1a    ioPutCH    jsr	ioValidateDevice
    191  1aac		       48		      pha
    192  1aad		       20 88 1a 	      jsr	ioSetDeviceVectors
    193  1ab0		       68		      pla
    194  1ab1		       20 5e 1a 	      jsr	VOUTCH
    195  1ab4		       18		      clc
    196  1ab5		       60		      rts
    197  1ab6
    198  1ab6							; io Getch returns the character read from device
    199  1ab6		       20 67 1a    ioGetCH    jsr	ioValidateDevice
    200  1ab9
    201  1ab9		       60		      rts
    202  1aba							;
    203  1aba							;======================================================================
    204  1aba							;TTY interface functions,
    205  1aba							;	a contains the character to send
    206  1aba							;	x contains the Device ID (equals index into io blocks)	of the io block to used
    207  1aba							;
    208  1aba				   SerialIn
    209  1aba
    210  1aba				   SerialOut
    211  1aba
    212  1aba				   SerialStatus
    213  1aba		       60		      rts
    214  1abb							;
    215  1abb							;======================================================================
    216  1abb							; Date/Time clock interface
    217  1abb				   ClockRead
    218  1abb
    219  1abb				   ClockWrite
    220  1abb		       60		      rts
    221  1abc							;
    222  1abc							;======================================================================
    223  1abc							;
    224  1abc				   TimerStart
    225  1abc
    226  1abc				   TimerStop
    227  1abc
    228  1abc				   TimerStatus
    229  1abc		       60		      rts
    230  1abd
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  1abd					      include	"tokenizer.asm"
      1  1abd					      seg	Code
      2  1abd		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  1abd
      4  1abd							; Define the types of tokens found, and identifiers
      5  1abd		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  1abd		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  1abd		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  1abd		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  1abd
     10  1abd		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  1abd		       00 9c	   tVhash     equ	$9C	; Variable #
     12  1abd		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  1abd
     14  1abd							; Base variable type supported by This basic
     15  1abd							; Unsigned types always have the 0 bit set to 1
     16  1abd		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     17  1abd		       00 a2	   tByte      equ	$A2	; Signed Byte value
     18  1abd		       00 a4	   tInteger   equ	$A4	; all tokenized integers start with 251 as first byte 16 bit signed number
     19  1abd		       00 a6	   tLong      equ	$A6	; Signed 32 bit integer
     20  1abd
     21  1abd		       00 a1	   tArray     equ	$A1	; Identifies Array Type, the byte following defines the length of each element
     22  1abd							; Arrays of string are arrays of pointers 2 bytes each
     23  1abd		       00 a3	   tPointer   equ	$A3	; Pointer  unsigned 16 bit
     24  1abd		       00 a5	   tIndirect  equ	$A5	; Points to an address that points to the data 16 bits
     25  1abd		       00 a7	   tuByte     equ	$A7	; Unsigned byte value 8 bit unsigned value
     26  1abd		       00 a9	   tUint      equ	$A9	; unsigned integer type 16 bit
     27  1abd		       00 ab	   tUlong     equ	$AB	; Unsigned 32 bit integer
     28  1abd
     29  1abd		       3c 3e	   Operators  BYTE.b	"<>"
     30  1abf		       3c 3d		      BYTE.b	"<="
     31  1ac1		       3e 3d		      BYTE.b	">="
     32  1ac3		       3c 3c		      Byte.b	"<<"
     33  1ac5		       3e 3e		      Byte.b	">>"
     34  1ac7		       3c 00		      BYTE.b	"<",0
     35  1ac9		       3d 00		      BYTE.b	"=",0
     36  1acb		       3e 00		      BYTE.b	">",0
     37  1acd		       2b 2b		      Byte.b	"++"
     38  1acf		       2b 00		      BYTE.b	"+",0
     39  1ad1		       2d 2d		      Byte.b	"--"
     40  1ad3		       2d 00		      BYTE.b	"-",0
     41  1ad5		       2f 00		      BYTE.b	"/",0
     42  1ad7		       25 00		      BYTE.b	"%",0
     43  1ad9		       2a 00		      BYTE.b	"*",0
     44  1adb		       28 00		      BYTE.b	"(",0
     45  1add		       29 00		      BYTE.b	")",0
     46  1adf		       2c 00		      BYTE.b	",",0
     47  1ae1		       3b 00		      BYTE.b	";",0
     48  1ae3		       5b 00		      BYTE.b	"[",0
     49  1ae5		       5d 00		      BYTE.b	"]",0
     50  1ae7		       3a 00		      BYTE.b	":",0
     51  1ae9		       24 00		      BYTE.b	"$",0
     52  1aeb		       21 00		      BYTE.b	"!",0
     53  1aed		       3f 00		      BYTE.b	"?",0
     54  1aef		       2e 00		      BYTE.b	".",0
     55  1af1		       26 00		      BYTE.b	"&",0
     56  1af3		       27 00		      Byte.b	"'",0
     57  1af5		       7c 00		      Byte.b	"|",0
     58  1af7		       7e 00		      Byte.b	"~",0
     59  1af9		       00 00		      BYTE.b	0,0
     60  1afb
     61  1afb		       f5 f3 f6 29*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oSHL,oSHR,oLess,oEqual,oGreater
     62  1b03		       02 ea 03 eb*	      BYTE.b	oINC, oPlus, oDEC, oMinus, oDivide, oModulo, oMultiply
     63  1b0a		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     64  1b10		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod, oAmphistan, oQuote, oBar,oTilde
     65  1b19
     66  1b19		       00 0b	   oQuestion  equ	kPrint
     67  1b19							;    2 is =
     68  1b19							;    1 is <
     69  1b19							;    3 is <=
     70  1b19							;    5 is <>
     71  1b19							;    4 is >
     72  1b19							;    6 is >=
     73  1b19		       00 f1	   oLess      equ	$F1
     74  1b19		       00 f2	   oEqual     equ	$F2
     75  1b19		       00 f3	   oLessEqual equ	$F3
     76  1b19		       00 f4	   oGreater   equ	$F4
     77  1b19		       00 f5	   oNotEqual  equ	$F5
     78  1b19		       00 f6	   oGreaterEqual equ	$F6
     79  1b19
     80  1b19		       00 e0	   oLeftBracket equ	$E0
     81  1b19		       00 e1	   oRightBracket equ	$E1
     82  1b19		       00 e2	   oComma     equ	$E2
     83  1b19		       00 e3	   oSemiColon equ	$E3
     84  1b19		       00 e4	   oLeftSQBracket equ	$E4
     85  1b19		       00 e5	   oRightSQBracket equ	$E5
     86  1b19		       00 e6	   oColon     equ	$E6
     87  1b19		       00 e7	   oDollar    equ	$E7
     88  1b19		       00 e8	   oBang      equ	$E8
     89  1b19		       00 e9	   oPeriod    equ	$E9
     90  1b19
     91  1b19
     92  1b19		       00 ea	   oPlus      equ	$EA
     93  1b19		       00 eb	   oMinus     equ	$EB
     94  1b19		       00 ec	   oDivide    equ	$EC
     95  1b19		       00 ed	   oModulo    equ	$ED
     96  1b19		       00 ee	   oMultiply  equ	$EE
     97  1b19
     98  1b19		       00 ed	   oPercent   equ	oModulo
     99  1b19		       00 27	   oAmphistan equ	kAnd
    100  1b19		       00 25	   oBar       equ	kOr
    101  1b19		       00 0a	   oQuote     equ	kRem
    102  1b19		       00 26	   oTilde     equ	kXor
    103  1b19		       00 28	   oSHR       equ	kShr
    104  1b19		       00 29	   oSHL       equ	kShl
    105  1b19		       00 02	   oINC       equ	kInc
    106  1b19		       00 03	   oDEC       equ	kDec
    107  1b19
    108  1b19		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
    109  1b19
    110  1b19		       00 ff	   tError     equ	$FF	; Error should never happen
    111  1b19							;============================================================================================
    112  1b19							; Keyword and seperator values
    113  1b19				   '
    114  1b19		       00 01	   kBeginKey  equ	kLet
    115  1b19							;
    116  1b19		       00 01	   kLet       equ	1
    117  1b19		       00 02	   kInc       equ	kLet+1
    118  1b19		       00 03	   kDec       equ	kInc+1
    119  1b19		       00 04	   kIreturn   equ	kDec+1
    120  1b19		       00 05	   kIf	      equ	kIreturn+1
    121  1b19		       00 06	   kThen      equ	kIf+1
    122  1b19		       00 07	   kGoto      equ	kThen+1
    123  1b19		       00 08	   kGosub     equ	kGoto+1
    124  1b19		       00 09	   kReturn    equ	kGosub+1
    125  1b19		       00 0a	   kRem       equ	kReturn+1
    126  1b19		       00 0b	   kPrint     equ	kRem+1
    127  1b19		       00 0c	   kTaske     equ	kPrint+1
    128  1b19		       00 0d	   kTaskn     equ	kTaske+1
    129  1b19		       00 0e	   kTaskw     equ	kTaskn+1
    130  1b19		       00 0f	   kPoke      equ	kTaskw+1
    131  1b19		       00 10	   kPutch     equ	kPoke+1
    132  1b19		       00 11	   kCls       equ	kPutch+1
    133  1b19		       00 12	   kInput     equ	kCls+1
    134  1b19		       00 13	   kEnd       equ	kInput+1
    135  1b19		       00 14	   kIrq       equ	kEnd+1
    136  1b19		       00 15	   kKill      equ	kIrq+1
    137  1b19		       00 16	   kList      equ	kKill+1
    138  1b19		       00 17	   kRun       equ	kList+1
    139  1b19		       00 18	   kNew       equ	kRun+1
    140  1b19		       00 19	   kSlice     equ	kNew+1
    141  1b19		       00 1a	   kTrace     equ	kSlice+1
    142  1b19		       00 1b	   kExit      equ	kTrace+1
    143  1b19		       00 1c	   kSave      equ	kExit+1
    144  1b19		       00 1d	   kLoad      equ	kSave+1
    145  1b19		       00 1e	   kErase     equ	kLoad+1
    146  1b19		       00 1f	   kDir       equ	kErase+1
    147  1b19		       00 20	   kSetTerm   equ	kDir+1
    148  1b19		       00 21	   kSetMemB   equ	kSetTerm+1
    149  1b19		       00 22	   kSetMemW   equ	kSetMemB+1
    150  1b19		       00 23	   kCopyMem   equ	kSetMemW+1
    151  1b19							;
    152  1b19							; End of actual key words
    153  1b19							;
    154  1b19		       00 22	   kKeyCount  equ	kCopyMem-kBeginKey
    155  1b19							;
    156  1b19							; Logical operators
    157  1b19							;
    158  1b19		       00 24	   kNot       equ	kCopyMem+1
    159  1b19		       00 25	   kOr	      equ	kNot+1
    160  1b19		       00 26	   kXor       equ	kOr+1
    161  1b19		       00 27	   kAnd       equ	kXor+1
    162  1b19							;
    163  1b19							; Shift operators
    164  1b19							;
    165  1b19		       00 28	   kShr       equ	kAnd+1
    166  1b19		       00 29	   kShl       equ	kShr+1
    167  1b19
    168  1b19							; numeric functions
    169  1b19							;
    170  1b19		       00 2a	   kBeginFunc equ	kTrue
    171  1b19							;
    172  1b19							; Truth operators
    173  1b19							;
    174  1b19		       00 2a	   kTrue      equ	kShl+1
    175  1b19		       00 2b	   kFalse     equ	kTrue+1
    176  1b19							; Functions
    177  1b19		       00 2c	   kFree      equ	kFalse+1
    178  1b19		       00 2d	   kGetch     equ	kFree+1
    179  1b19		       00 2e	   kPeek      equ	kGetch+1
    180  1b19		       00 2f	   kTask      equ	kPeek+1
    181  1b19		       00 30	   kIpcc      equ	kTask+1
    182  1b19		       00 31	   kIpcs      equ	kIpcc+1
    183  1b19		       00 32	   kIpcr      equ	kIpcs+1
    184  1b19		       00 33	   kRnd       equ	kIpcr+1
    185  1b19		       00 34	   kStat      equ	kRnd+1
    186  1b19		       00 35	   kAbs       equ	kStat+1
    187  1b19		       00 36	   kCall      equ	kAbs+1
    188  1b19		       00 37	   kGofn      equ	kCall+1
    189  1b19		       00 38	   kPid       equ	kGofn+1
    190  1b19		       00 39	   kAddr      equ	kPid+1
    191  1b19		       00 3a	   kCmpMem    equ	kAddr+1
    192  1b19		       00 3b	   kTimer     equ	kCmpMem+1
    193  1b19							;
    194  1b19		       00 12	   kFuncCount equ	((kTimer - kBeginFunc) + 1)
    195  1b19
    196  1b19							;
    197  1b19							; Keyword table contains 54 keywords
    198  1b19				   KeyWordTable
      0  1b19					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  1b19		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  1b1d					      db	kInc,"inC"
      1  1b1d		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  1b21					      db	kDec,"deC"
      1  1b21		       03 64 65 43	      .byte.b	kDec,"deC"
      0  1b25					      db	kIreturn,"ireturN"
      1  1b25		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  1b2d					      db	kIf,"iF"
      1  1b2d		       05 69 46 	      .byte.b	kIf,"iF"
      0  1b30					      db	kThen,"theN"
      1  1b30		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  1b35					      db	kGoto,"gotO"
      1  1b35		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  1b3a					      db	kGosub,"gosuB"
      1  1b3a		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  1b40					      db	kReturn,"returN"
      1  1b40		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  1b47					      db	kRem,"reM"
      1  1b47		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  1b4b					      db	kPrint,"prinT"
      1  1b4b		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  1b51					      db	kTaske,"taskE"
      1  1b51		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  1b57					      db	kTaskn,"taskN"
      1  1b57		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  1b5d					      db	kTaskw,"taskW"
      1  1b5d		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  1b63					      db	kPoke,"pokE"
      1  1b63		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  1b68					      db	kPutch,"putcH"
      1  1b68		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  1b6e					      db	kCls,"clS"
      1  1b6e		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  1b72					      db	kInput,"inpuT"
      1  1b72		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  1b78					      db	kEnd,"enD"
      1  1b78		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  1b7c					      db	kIrq,"irQ"
      1  1b7c		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  1b80					      db	kKill,"kilL"
      1  1b80		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  1b85					      db	kList,"lisT"
      1  1b85		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  1b8a					      db	kRun,"ruN"
      1  1b8a		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  1b8e					      db	kNew,"neW"
      1  1b8e		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  1b92					      db	kSlice,"slicE"
      1  1b92		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  1b98					      db	kTrace,"tracE"
      1  1b98		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  1b9e					      db	kExit,"exiT"
      1  1b9e		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  1ba3					      db	kSave,"savE"
      1  1ba3		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  1ba8					      db	kLoad,"loaD"
      1  1ba8		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  1bad					      db	kErase,"erasE"
      1  1bad		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  1bb3					      db	kDir,"diR"
      1  1bb3		       1f 64 69 52	      .byte.b	kDir,"diR"
    230  1bb7							;Short form for statements:
      0  1bb7					      db	kIreturn,"ireT"
      1  1bb7		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  1bbc					      db	kReturn,"reT"
      1  1bbc		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  1bc0					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  1bc0		       0b 70 52 	      .byte.b	kPrint,"pR"
      0  1bc3					      db	kSetTerm, "setterM"
      1  1bc3		       20 73 65 74*	      .byte.b	kSetTerm, "setterM"
      0  1bcb					      db	kSetMemB, "setmemB"
      1  1bcb		       21 73 65 74*	      .byte.b	kSetMemB, "setmemB"
      0  1bd3					      db	kSetMemW, "setmemW"
      1  1bd3		       22 73 65 74*	      .byte.b	kSetMemW, "setmemW"
      0  1bdb					      db	kCopyMem, "copymeM"
      1  1bdb		       23 63 6f 70*	      .byte.b	kCopyMem, "copymeM"
    238  1be3
    239  1be3							; Shift operators
      0  1be3					      db	kShr,"shR"
      1  1be3		       28 73 68 52	      .byte.b	kShr,"shR"
      0  1be7					      db	kShl,"shL"
      1  1be7		       29 73 68 4c	      .byte.b	kShl,"shL"
    242  1beb
    243  1beb							;Logical and truth operators
      0  1beb					      db	kNot,"noT"
      1  1beb		       24 6e 6f 54	      .byte.b	kNot,"noT"
      0  1bef					      db	kOr,"oR"
      1  1bef		       25 6f 52 	      .byte.b	kOr,"oR"
      0  1bf2					      db	kXor,"xoR"
      1  1bf2		       26 78 6f 52	      .byte.b	kXor,"xoR"
      0  1bf6					      db	kAnd,"anD"
      1  1bf6		       27 61 6e 44	      .byte.b	kAnd,"anD"
    248  1bfa
    249  1bfa							; Truth values
      0  1bfa					      db	kTrue,"truE"
      1  1bfa		       2a 74 72 75*	      .byte.b	kTrue,"truE"
      0  1bff					      db	kFalse,"falsE"
      1  1bff		       2b 66 61 6c*	      .byte.b	kFalse,"falsE"
    252  1c05
    253  1c05
    254  1c05
    255  1c05							;functions returning values
    256  1c05
      0  1c05					      db	kFree,"freE"
      1  1c05		       2c 66 72 65*	      .byte.b	kFree,"freE"
      0  1c0a					      db	kGetch,"getcH"
      1  1c0a		       2d 67 65 74*	      .byte.b	kGetch,"getcH"
      0  1c10					      db	kPeek,"peeK"
      1  1c10		       2e 70 65 65*	      .byte.b	kPeek,"peeK"
      0  1c15					      db	kTask,"tasK"
      1  1c15		       2f 74 61 73*	      .byte.b	kTask,"tasK"
      0  1c1a					      db	kIpcc,"ipcC"
      1  1c1a		       30 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  1c1f					      db	kIpcs,"ipcS"
      1  1c1f		       31 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  1c24					      db	kIpcr,"ipcR"
      1  1c24		       32 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  1c29					      db	kRnd,"rnD"
      1  1c29		       33 72 6e 44	      .byte.b	kRnd,"rnD"
      0  1c2d					      db	kStat,"staT"
      1  1c2d		       34 73 74 61*	      .byte.b	kStat,"staT"
      0  1c32					      db	kAbs,"abS"
      1  1c32		       35 61 62 53	      .byte.b	kAbs,"abS"
      0  1c36					      db	kCall,"calL"
      1  1c36		       36 63 61 6c*	      .byte.b	kCall,"calL"
      0  1c3b					      db	kGofn,"fN"
      1  1c3b		       37 66 4e 	      .byte.b	kGofn,"fN"
      0  1c3e					      db	kPid,"piD"
      1  1c3e		       38 70 69 44	      .byte.b	kPid,"piD"
      0  1c42					      db	kAddr,"addR"
      1  1c42		       39 61 64 64*	      .byte.b	kAddr,"addR"
      0  1c47					      db	kCmpMem, "cmpmeM"
      1  1c47		       3a 63 6d 70*	      .byte.b	kCmpMem, "cmpmeM"
      0  1c4e					      db	kTimer,"timeR"
      1  1c4e		       3b 74 69 6d*	      .byte.b	kTimer,"timeR"
      0  1c54					      db	0,0
      1  1c54		       00 00		      .byte.b	0,0
    274  1c56
    275  1c56		       1c 56	   KeyWordTableEnd equ	*
    276  1c56		       01 3d	   KeyWordTableLength equ	* - KeyWordTable
    277  1c56		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    278  1d56		       00 00 00    printStorage ds	3
    279  1d59							;==================================================================================================================
    280  1d59							; Read accross the inputline and output to TOKENBUFFER
    281  1d59							; Format   byte      Description
    282  1d59							;	     0	      length of line 1-255
    283  1d59							;	    0-1       Line Number
    284  1d59							;	    Tokens and litteral values encoded into the line
    285  1d59							;
    286  1d59							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    287  1d59							;  if fails then test for keywords
    288  1d59							;  if fails then test for variables and arrays
    289  1d59							;  if fails check for operators/seperators  + - < > = % / * () [] , ; : >> <<
    290  1d59
    291  1d59				   ParseInputLine
    292  1d59				  -	      if	DEBUGPARSER
    293  1d59				  -	      jsr	SetOutDebug
    294  1d59				  -	      jsr	DebugClearBuffer
    295  1d59					      endif
    296  1d59		       a5 51		      lda	CUROFF
    297  1d5b		       48		      pha
    298  1d5c		       8a		      txa
    299  1d5d		       48		      pha
    300  1d5e		       98		      tya
    301  1d5f		       48		      pha
    302  1d60		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    303  1d62		       20 df 2a 	      jsr	getDecimal	; Check for a line number, none is ok too
    304  1d65		       84 51		      sty	CUROFF
    305  1d67		       20 25 1f 	      jsr	R02TOKEN	; Move R0 to token buffer
    306  1d6a
    307  1d6a				   ParseInputLoop
    308  1d6a		       a4 51		      ldy	CUROFF
    309  1d6c		       20 6f 2d 	      jsr	SkipSpaces	; Skip any spaces
    310  1d6f		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    311  1d71		       b9 95 42 	      lda	LINBUF,y	; Check for end of line
    312  1d74		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    313  1d76
    314  1d76				   ParseForNumber
    315  1d76		       20 79 1e 	      jsr	ParseNumeric	; Check for a numeric value
    316  1d79		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    317  1d7b
    318  1d7b				   ParseForString
    319  1d7b		       20 4f 1e 	      jsr	ParseString	; Check for a string
    320  1d7e		       90 ea		      bcc	ParseInputLoop	; It was a string
    321  1d80
    322  1d80				   ParseForOp
    323  1d80		       20 b7 1e 	      jsr	ParseForOperator	; Check for operator or punctuation
    324  1d83		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    325  1d85
    326  1d85				   ParseForKey
    327  1d85		       20 ac 1d 	      jsr	ParseLookupKey	; Check for a keyword value
    328  1d88		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    329  1d8a
    330  1d8a				   ParseForVar
    331  1d8a		       20 ee 1e 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    332  1d8d		       90 db		      bcc	ParseInputLoop
    333  1d8f
    334  1d8f				   ParseKeepChar		; if it does not parse just keep it safe
    335  1d8f		       b9 95 42 	      lda	LINBUF,y
    336  1d92		       9d 56 1c 	      sta	TOKENBUFFER,x
    337  1d95		       e8		      inx
    338  1d96		       c8		      iny
    339  1d97		       84 51		      sty	CUROFF
    340  1d99		       d0 cf		      bne	ParseInputLoop
    341  1d9b
    342  1d9b				   ParseComplete
    343  1d9b		       a9 00		      lda	#0
    344  1d9d		       9d 56 1c 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    345  1da0		       e8		      inx
    346  1da1		       8e 56 1c 	      stx	TOKENBUFFER	; Place size including null into buffer start
    347  1da4
    348  1da4		       68		      pla
    349  1da5		       a8		      tay
    350  1da6		       68		      pla
    351  1da7		       aa		      tax
    352  1da8		       68		      pla
    353  1da9		       85 51		      sta	CUROFF
    354  1dab
    355  1dab				  -	      if	DEBUGPARSER
    356  1dab				  -
    357  1dab				  -	      jsr	printTokenBuffer
    358  1dab				  -			;jsr	  DebugPrintProgramLine
    359  1dab				  -	      jsr	SetOutDebugEnd
    360  1dab				  -
    361  1dab					      endif
    362  1dab		       60		      rts
    363  1dac
    364  1dac							;==================================================================================================================
    365  1dac							; Look at curptr, curpos and check for a valid KeyWord
    366  1dac							; A contains the index value. c is clear
    367  1dac							;		     not found c set  A undefined
    368  1dac							; X is prerserved
    369  1dac							;
    370  1dac				   ParseLookupKey
    371  1dac		       86 58		      stx	R2
    372  1dae		       a0 00		      ldy	#0
    373  1db0		       a9 19		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    374  1db2		       85 54		      sta	R1
    375  1db4		       a9 1b		      lda	#KeyWordTable>>8
    376  1db6		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    377  1db8		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    378  1dba		       85 52		      sta	R0	; Save until next keyword
    379  1dbc		       c8		      iny		; Point to first character of keyword
    380  1dbd		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    381  1dbf
    382  1dbf				  -	      if	DEBUGPARSER
    383  1dbf				  -			;    jsr DebugKeyword
    384  1dbf					      endif
    385  1dbf
    386  1dbf				   ParseLookupLoop
    387  1dbf		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    388  1dc1		       29 df		      and	#%11011111	; Force Keyword to upper case
    389  1dc3		       dd 95 42 	      cmp	LINBUF,x	; Check the input buffer
    390  1dc6		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    391  1dc8		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    392  1dca		       dd 95 42 	      cmp	LINBUF,x	; Compare value to upercase
    393  1dcd		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    394  1dcf
    395  1dcf				   ParseNextLetter
    396  1dcf		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    397  1dd1		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    398  1dd3		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    399  1dd5		       e8		      inx		; Point to next char in the input buffer
    400  1dd6		       c8		      iny		; Point to the next character in the Keyword table
    401  1dd7		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    402  1dd9		       dd 95 42 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    403  1ddc		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    404  1dde		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    405  1de0
    406  1de0				   ParseKeyFound
    407  1de0		       a5 52		      lda	R0	; get the keyword index
    408  1de2
    409  1de2				   ParseKeyDone
    410  1de2		       e8		      inx		; point past the last character
    411  1de3		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    412  1de5		       a6 58		      ldx	R2	; Restore the original x pointer
    413  1de7		       9d 56 1c 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    414  1dea		       e8		      inx		; Point to next position in the output buffer
    415  1deb		       86 58		      stx	R2	; Save next position in buffer
    416  1ded		       c9 0a		      cmp	#kRem	; remark statement
    417  1def		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    418  1df1		       c9 07		      cmp	#kGoto
    419  1df3		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    420  1df5		       c9 08		      cmp	#kGosub
    421  1df7		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    422  1df9		       c9 37		      cmp	#kGofn
    423  1dfb		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    424  1dfd		       c9 2f		      cmp	#kTask
    425  1dff		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    426  1e01
    427  1e01		       18		      clc		; C flag clear, we found it
    428  1e02		       60		      rts
    429  1e03
    430  1e03							; Move forward to the next entry in table
    431  1e03				   ParseNextEntry
    432  1e03		       b1 54		      lda	(R1),y	; Get the next character in the token
    433  1e05		       29 20		      and	#%00100000	; Is it the last character
    434  1e07		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    435  1e09		       c8		      iny		; Point to next char in the entry
    436  1e0a		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    437  1e0c
    438  1e0c				   ParseEndOfEntry
    439  1e0c		       c8		      iny		; Point to the byte after the last character
    440  1e0d		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    441  1e0e		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    442  1e0f		       65 54		      adc	R1
    443  1e11		       85 54		      sta	R1
    444  1e13		       a5 55		      lda	R1+1
    445  1e15		       69 00		      adc	#0
    446  1e17		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    447  1e19		       a0 00		      ldy	#0	; Reset the index back to zero
    448  1e1b		       b1 54		      lda	(R1),y	; get keyword value
    449  1e1d		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    450  1e1f		       85 52		      sta	R0	; save the next token value
    451  1e21		       c8		      iny		; Inc past token value
    452  1e22
    453  1e22				  -	      if	DEBUGPARSER
    454  1e22				  -			;    jsr DebugKeyword
    455  1e22					      endif
    456  1e22		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    457  1e24		       4c bf 1d 	      jmp	ParseLookupLoop	; branch back for next key word
    458  1e27
    459  1e27				   ParseNoneFound
    460  1e27		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    461  1e29		       38		      sec		; c clear, not found
    462  1e2a		       60		      rts
    463  1e2b
    464  1e2b							;===============================================================================
    465  1e2b							; Move everything from current position until the end of line into the token buffer
    466  1e2b							;
    467  1e2b		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    468  1e2d		       a6 58		      ldx	R2	; where to place in the buffer
    469  1e2f				   ParseMoveLoop
    470  1e2f		       b9 95 42 	      lda	LINBUF,y	; get the next byte
    471  1e32		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    472  1e34		       9d 56 1c 	      sta	TOKENBUFFER,x	; save the byte
    473  1e37		       c8		      iny
    474  1e38		       e8		      inx
    475  1e39		       d0 f4		      bne	ParseMoveLoop
    476  1e3b				   ParseMoveDone
    477  1e3b		       84 51		      sty	CUROFF
    478  1e3d		       18		      clc
    479  1e3e		       60		      rts
    480  1e3f							;================================================================================================
    481  1e3f							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    482  1e3f							; transfer to a memory address
    483  1e3f				   ParseHandleBranches
    484  1e3f		       a6 58		      ldx	R2
    485  1e41		       a9 00		      lda	#0
    486  1e43		       9d 56 1c 	      sta	TOKENBUFFER,x
    487  1e46		       e8		      inx
    488  1e47		       9d 56 1c 	      sta	TOKENBUFFER,x
    489  1e4a		       e8		      inx
    490  1e4b		       86 58		      stx	R2
    491  1e4d		       18		      clc
    492  1e4e		       60		      rts
    493  1e4f
    494  1e4f							;=========================================================================================================
    495  1e4f							;ParseString Parse a quotes string
    496  1e4f							; on input X = outbuf position
    497  1e4f							; y = inbuf position
    498  1e4f							; Copies string to output buffer, updates x and y
    499  1e4f				   ParseString
    500  1e4f		       a4 51		      ldy	CUROFF
    501  1e51		       a9 a0		      lda	#tString
    502  1e53		       9d 56 1c 	      sta	TOKENBUFFER,X
    503  1e56		       b9 95 42 	      lda	LINBUF,y
    504  1e59		       c9 22		      cmp	#'"
    505  1e5b		       d0 1a		      bne	ParseStringInvalid
    506  1e5d		       e8		      inx
    507  1e5e		       9d 56 1c 	      sta	TOKENBUFFER,x
    508  1e61		       e8		      inx
    509  1e62		       c8		      iny
    510  1e63
    511  1e63				   ParseStringLoop
    512  1e63		       b9 95 42 	      lda	LINBUF,y
    513  1e66		       9d 56 1c 	      sta	TOKENBUFFER,x
    514  1e69		       c9 22		      cmp	#'"
    515  1e6b		       f0 04		      beq	ParseStringDone
    516  1e6d		       c8		      iny
    517  1e6e		       e8		      inx
    518  1e6f		       d0 f2		      bne	ParseStringLoop
    519  1e71
    520  1e71				   ParseStringDone
    521  1e71		       e8		      inx
    522  1e72		       c8		      iny
    523  1e73		       84 51		      sty	CUROFF
    524  1e75		       18		      clc
    525  1e76		       60		      rts
    526  1e77
    527  1e77				   ParseStringInvalid
    528  1e77		       38		      sec
    529  1e78		       60		      rts
    530  1e79
    531  1e79							;=========================================================================================================
    532  1e79							; Get numeric values and return value in RO and type in a
    533  1e79							;
    534  1e79				   ParseNumeric
    535  1e79		       a4 51		      ldy	CUROFF
    536  1e7b		       b9 95 42 	      lda	LINBUF,y
    537  1e7e		       c9 30		      cmp	#'0
    538  1e80		       90 33		      bcc	ParseNumInvalid
    539  1e82		       c9 3a		      cmp	#'9+1
    540  1e84		       b0 2f		      bcs	ParseNumInvalid
    541  1e86		       86 58		      stx	R2
    542  1e88		       20 df 2a 	      jsr	getDecimal
    543  1e8b		       a6 58		      ldx	R2
    544  1e8d		       84 51		      sty	CUROFF
    545  1e8f		       a5 53		      lda	R0+1
    546  1e91		       f0 14		      beq	ParseByteValue
    547  1e93
    548  1e93				   ParseIntegerValue
    549  1e93		       a9 a4		      lda	#tInteger
    550  1e95		       9d 56 1c 	      sta	TOKENBUFFER,x
    551  1e98		       e8		      inx
    552  1e99		       a5 52		      lda	R0
    553  1e9b		       9d 56 1c 	      sta	TOKENBUFFER,x
    554  1e9e		       e8		      inx
    555  1e9f		       a5 53		      lda	R0+1
    556  1ea1		       9d 56 1c 	      sta	TOKENBUFFER,X
    557  1ea4		       e8		      inx
    558  1ea5		       18		      clc
    559  1ea6		       60		      rts
    560  1ea7
    561  1ea7				   ParseByteValue
    562  1ea7		       a9 a2		      lda	#tByte
    563  1ea9		       9d 56 1c 	      sta	TOKENBUFFER,x
    564  1eac		       e8		      inx
    565  1ead		       a5 52		      lda	R0
    566  1eaf		       9d 56 1c 	      sta	TOKENBUFFER,x
    567  1eb2		       e8		      inx
    568  1eb3		       18		      clc
    569  1eb4		       60		      rts
    570  1eb5
    571  1eb5				   ParseNumInvalid		;Not a valid Numeric
    572  1eb5		       38		      sec
    573  1eb6		       60		      rts
    574  1eb7
    575  1eb7							;=========================================================================================================
    576  1eb7							;Parse for operators and seperators
    577  1eb7							; on exit the A has the oper code, c is clear
    578  1eb7							;		 not found then c is set
    579  1eb7							;	x is preserved
    580  1eb7							;
    581  1eb7				   ParseForOperator
    582  1eb7		       86 58		      stx	R2
    583  1eb9		       a4 51		      ldy	CUROFF
    584  1ebb		       a2 00		      ldx	#0
    585  1ebd				  -	      if	DEBUGPARSER
    586  1ebd				  -			;	jsr    DebugPrintOP
    587  1ebd					      endif
    588  1ebd
    589  1ebd				   ParseOpLoop
    590  1ebd		       bd bd 1a 	      lda	Operators,x	; First byte of operator
    591  1ec0		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    592  1ec2
    593  1ec2		       d9 95 42 	      cmp	LINBUF,y	; Check the first byte
    594  1ec5		       d0 1c		      bne	ParseOpNext
    595  1ec7
    596  1ec7		       c8		      iny
    597  1ec8
    598  1ec8		       bd be 1a 	      lda	Operators+1,x
    599  1ecb		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    600  1ecd
    601  1ecd		       d9 95 42 	      cmp	LINBUF,y
    602  1ed0		       d0 11		      bne	ParseOpNext
    603  1ed2
    604  1ed2				   ParseOpFound
    605  1ed2		       c8		      iny
    606  1ed3
    607  1ed3				   ParseOpFoundSingle
    608  1ed3		       84 51		      sty	CUROFF
    609  1ed5
    610  1ed5		       8a		      txa
    611  1ed6		       4a		      lsr
    612  1ed7		       aa		      tax
    613  1ed8		       bd fb 1a 	      lda	OperValues,x
    614  1edb		       a6 58		      ldx	R2
    615  1edd		       9d 56 1c 	      sta	TOKENBUFFER,x
    616  1ee0		       e8		      inx
    617  1ee1		       18		      clc
    618  1ee2		       60		      rts
    619  1ee3
    620  1ee3				   ParseOpNext
    621  1ee3		       e8		      inx
    622  1ee4		       e8		      inx
    623  1ee5
    624  1ee5				  -	      if	DEBUGPARSER
    625  1ee5				  -			;	 jsr	DebugPrintOP
    626  1ee5					      endif
    627  1ee5		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    628  1ee7		       4c bd 1e 	      jmp	ParseOpLoop
    629  1eea
    630  1eea				   ParseOpNotFound
    631  1eea		       a6 58		      ldx	R2
    632  1eec		       38		      sec
    633  1eed		       60		      rts
    634  1eee							;=========================================================================================================
    635  1eee				  -	      if	DEBUGPARSER
    636  1eee				  -			;Print the text of a keyword
    637  1eee				  -			;Input R1    = offset into table
    638  1eee				  -DebugKeyword
    639  1eee				  -	      tya
    640  1eee				  -	      pha
    641  1eee				  -	      ldy	#1
    642  1eee				  -DebugKeyLoop
    643  1eee				  -	      lda	(R1),y
    644  1eee				  -	      jsr	VOUTCH
    645  1eee				  -	      and	#%00100000
    646  1eee				  -	      beq	DebugKeyDone
    647  1eee				  -	      iny
    648  1eee				  -	      bne	DebugKeyLoop
    649  1eee				  -
    650  1eee				  -DebugKeyDone
    651  1eee				  -	      jsr	CRLF
    652  1eee				  -	      pla
    653  1eee				  -	      tay
    654  1eee				  -	      rts
    655  1eee				  -			;========================================
    656  1eee				  -DebugPrintOP
    657  1eee				  -	      pha
    658  1eee				  -	      lda	Operators,x
    659  1eee				  -	      jsr	VOUTCH
    660  1eee				  -	      lda	Operators+1,x
    661  1eee				  -	      beq	DbgPrtOpDone
    662  1eee				  -	      jsr	VOUTCH
    663  1eee				  -
    664  1eee				  -DbgPrtOpDone
    665  1eee				  -	      jsr	CRLF
    666  1eee				  -	      pla
    667  1eee				  -	      rts
    668  1eee				  -			;=======================================
    669  1eee				  -DebugClearBuffer
    670  1eee				  -	      txa
    671  1eee				  -	      pha
    672  1eee				  -	      ldx	#$FF
    673  1eee				  -	      lda	#0
    674  1eee				  -DebugClrLoop
    675  1eee				  -	      sta	TOKENBUFFER,x
    676  1eee				  -	      dex
    677  1eee				  -	      bne	DebugClrLoop
    678  1eee				  -	      sta	TOKENBUFFER,x
    679  1eee				  -	      pla
    680  1eee				  -	      tax
    681  1eee				  -	      rts
    682  1eee				  -
    683  1eee				  -			;=====================================================
    684  1eee				  -			; Print the parser buffer as hex values
    685  1eee				  -printTokenBuffer
    686  1eee				  -	      stx	printStorage
    687  1eee				  -	      sty	printStorage+1
    688  1eee				  -	      sta	printStorage+2
    689  1eee				  -
    690  1eee				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    691  1eee				  -	      inx		; we want to show the last zero byte
    692  1eee				  -	      ldy	#0
    693  1eee				  -
    694  1eee				  -printHexLoop
    695  1eee				  -	      lda	TOKENBUFFER,y	; get the character
    696  1eee				  -	      jsr	HexToOut	; print it
    697  1eee				  -	      lda	#$20
    698  1eee				  -	      jsr	VOUTCH
    699  1eee				  -	      iny
    700  1eee				  -	      dex
    701  1eee				  -	      cpx	#0
    702  1eee				  -	      bne	printHexLoop
    703  1eee				  -	      jsr	CRLF
    704  1eee				  -
    705  1eee				  -	      ldy	printStorage+1
    706  1eee				  -	      ldx	printStorage
    707  1eee				  -	      lda	printStorage+2
    708  1eee				  -printHexDone
    709  1eee				  -	      clc
    710  1eee				  -	      rts
    711  1eee					      endif
    712  1eee
    713  1eee
    714  1eee							;=========================================================================================================
    715  1eee							; Parse for variables A-Z @, ^  x!x x[op]
    716  1eee				   ParseForVariable
    717  1eee		       a4 51		      ldy	CUROFF
    718  1ef0		       b9 95 42 	      lda	LINBUF,y
    719  1ef3		       c9 5e		      cmp	#'^	; is it an exit code
    720  1ef5		       d0 04		      bne	ParseVarMem
    721  1ef7		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    722  1ef9		       d0 1f		      bne	ParseVarSpecial
    723  1efb
    724  1efb				   ParseVarMem
    725  1efb		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    726  1efd		       d0 04		      bne	ParseVarStack
    727  1eff		       a9 9d		      lda	#tVat
    728  1f01		       d0 17		      bne	ParseVarSpecial
    729  1f03
    730  1f03				   ParseVarStack
    731  1f03		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    732  1f05		       d0 04		      bne	ParseVarLetters
    733  1f07		       a9 9c		      lda	#tVhash
    734  1f09		       d0 0f		      bne	ParseVarSpecial
    735  1f0b
    736  1f0b				   ParseVarLetters
    737  1f0b		       29 df		      and	#%11011111	; Force upper case
    738  1f0d		       c9 41		      cmp	#'A
    739  1f0f		       90 12		      bcc	ParseVarInvalid
    740  1f11		       c9 5b		      cmp	#'Z+1
    741  1f13		       b0 0e		      bcs	ParseVarInvalid
    742  1f15							;
    743  1f15							; The condition is true, so convert to an index, push
    744  1f15							; it onto the stack and continue running.
    745  1f15							;
    746  1f15		       38		      sec
    747  1f16		       e9 41		      sbc	#'A	;index is zero based
    748  1f18		       09 80		      ora	#$80
    749  1f1a
    750  1f1a				   ParseVarSpecial
    751  1f1a		       9d 56 1c 	      sta	TOKENBUFFER,x
    752  1f1d		       e8		      inx
    753  1f1e		       c8		      iny
    754  1f1f		       84 51		      sty	CUROFF
    755  1f21		       18		      clc
    756  1f22		       60		      rts
    757  1f23
    758  1f23				   ParseVarInvalid
    759  1f23		       38		      sec
    760  1f24		       60		      rts
    761  1f25
    762  1f25
    763  1f25							;=========================================================================================================
    764  1f25							; Transfer R0 to the TOKENBUFFER
    765  1f25							;
    766  1f25				   R02TOKEN
    767  1f25		       a5 52		      lda	R0
    768  1f27		       9d 56 1c 	      sta	TOKENBUFFER,x
    769  1f2a		       e8		      inx
    770  1f2b		       a5 53		      lda	R0+1
    771  1f2d		       9d 56 1c 	      sta	TOKENBUFFER,x
    772  1f30		       e8		      inx
    773  1f31		       18		      clc
    774  1f32		       60		      rts
    775  1f33							;=========================================================================
    776  1f33							; Transfer word in Token Buffer to R0
    777  1f33				   TOKEN2R0
    778  1f33		       b9 56 1c 	      lda	TOKENBUFFER,y
    779  1f36		       85 52		      sta	R0
    780  1f38		       c8		      iny
    781  1f39		       ca		      dex
    782  1f3a		       b9 56 1c 	      lda	TOKENBUFFER,y
    783  1f3d		       c8		      iny
    784  1f3e		       ca		      dex
    785  1f3f		       85 53		      sta	R0+1
    786  1f41		       60		      rts
    787  1f42							;==========================================================================
    788  1f42							; Transfer	Display Buffer position to R0
    789  1f42							;
    790  1f42				   DPL2R0
    791  1f42		       b1 59		      lda	(dpl),y
    792  1f44		       85 52		      sta	R0
    793  1f46		       c8		      iny
    794  1f47		       ca		      dex
    795  1f48		       b1 59		      lda	(dpl),y
    796  1f4a		       c8		      iny
    797  1f4b		       ca		      dex
    798  1f4c		       85 53		      sta	R0+1
    799  1f4e		       60		      rts
    800  1f4f
    801  1f4f
    802  1f4f							;=========================================================================
    803  1f4f							; Read an IL byte lookit up in the table, of words
    804  1f4f							; set the next ilpc to point to that address
    805  1f4f							; if not found then do ussual filter stuff
    806  1f4f							; ongoto ilvectortable, not found address
    807  1f4f		       20 30 2a    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    808  1f52		       86 52		      stx	R0
    809  1f54		       85 53		      sta	R0+1
    810  1f56
    811  1f56		       a4 51		      ldy	CUROFF
    812  1f58		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    813  1f5a		       a0 00		      ldy	#0
    814  1f5c		       38		      sec
    815  1f5d		       f1 52		      sbc	(R0),y	; Subract the base value
    816  1f5f		       c8		      iny
    817  1f60		       d1 52		      cmp	(R0),y	; Check if we are in range
    818  1f62		       b0 12		      bcs	iOnGotoInvalid
    819  1f64		       e6 51		      inc	CUROFF	; Save the offset
    820  1f66
    821  1f66		       0a		      asl
    822  1f67		       a8		      tay		; Turn into vector
    823  1f68		       c8		      iny		; Inc must include the table base and entry count
    824  1f69		       c8		      iny
    825  1f6a
    826  1f6a		       b1 52		      lda	(R0),y
    827  1f6c		       85 43		      sta	ILPC
    828  1f6e		       c8		      iny
    829  1f6f		       b1 52		      lda	(R0),y
    830  1f71		       85 44		      sta	ILPC+1
    831  1f73		       4c b1 02 	      jmp	NextIL
    832  1f76
    833  1f76				   iOnGotoInvalid
    834  1f76		       20 30 2a 	      jsr	getILWord
    835  1f79		       86 43		      stx	ILPC
    836  1f7b		       85 44		      sta	ILPC+1
    837  1f7d		       4c b1 02 	      jmp	NextIL
    838  1f80							;
    839  1f80							;==========================================================================================
    840  1f80							; Test the token for relop and push the value onto the stack if true
    841  1f80							;
    842  1f80				   iTSTRELOP
    843  1f80		       20 34 2a 	      jsr	getILByte
    844  1f83		       8d 2a 43 	      sta	offset
    845  1f86
    846  1f86		       a4 51		      ldy	CUROFF
    847  1f88		       b1 4f		      lda	(CURPTR),y
    848  1f8a		       48		      pha
    849  1f8b		       29 f0		      and	#$F0
    850  1f8d		       c9 f0		      cmp	#$F0
    851  1f8f		       d0 12		      bne	iTSTRELOPNOT
    852  1f91		       68		      pla
    853  1f92		       29 0f		      and	#$0F	; get the actual value
    854  1f94		       85 52		      sta	R0	; save it for later
    855  1f96		       a9 00		      lda	#0
    856  1f98		       85 53		      sta	R0+1
    857  1f9a		       20 2d 2c 	      jsr	pushR0
    858  1f9d		       c8		      iny
    859  1f9e		       84 51		      sty	CUROFF	; save the y pointer
    860  1fa0		       4c b1 02 	      jmp	NextIL
    861  1fa3
    862  1fa3				   iTSTRELOPNOT
    863  1fa3		       68		      pla
    864  1fa4		       4c e0 0b 	      jmp	tstBranch
    865  1fa7
    866  1fa7							;
    867  1fa7							;===================================================================================================
    868  1fa7							; Test the token and following info for precompiled address information
    869  1fa7							; skip it if zero, transfer and skip next integer value if not zero
    870  1fa7							; used by both gosub, goto and gofN
    871  1fa7							;
    872  1fa7				   iTSTBRANCH		; il format TSTBRANCH whereToGoIfFailed
    873  1fa7		       20 34 2a 	      jsr	getILByte	; Get jump address if vector is valid
    874  1faa		       8d 2a 43 	      sta	offset	; Mark offset for later if vector found
    875  1fad		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    876  1faf		       88		      dey		; point back to the type of branch
    877  1fb0		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    878  1fb2		       48		      pha		; Save till needed
    879  1fb3		       c8		      iny		; back to memory vectors
    880  1fb4				   ITSTBRANCHCont
    881  1fb4		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    882  1fb6		       85 52		      sta	R0	; R0 will contain mem pointer of present
    883  1fb8		       c8		      iny		; Point to next byte of mem vector
    884  1fb9		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    885  1fbb		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    886  1fbd		       c8		      iny		; Point to the byte past memory vector
    887  1fbe		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    888  1fc0
    889  1fc0		       05 52		      ora	R0	; Get the second byte of the mem
    890  1fc2		       f0 28		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    891  1fc4		       68		      pla
    892  1fc5		       c9 07		      cmp	#kGoto	; Short cut lots if a goto stuff
    893  1fc7		       d0 03		      bne	NotGoto
    894  1fc9		       4c dc 04 	      jmp	FastFastXfer
    895  1fcc				   NotGoto
    896  1fcc		       c9 2f		      cmp	#kTask	; Task defined with Task() so bypass the first bracket
    897  1fce		       d0 07		      bne	iTSTBRANCHCont
    898  1fd0		       b1 4f		      lda	(CURPTR),y
    899  1fd2		       c9 e0		      cmp	#oLeftBracket
    900  1fd4		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    901  1fd6		       c8		      iny		; Increment past the bracket
    902  1fd7				   iTSTBRANCHCont
    903  1fd7		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    904  1fd9		       c9 a2		      cmp	#tByte	; A byte value is valid
    905  1fdb		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    906  1fdd		       c9 a4		      cmp	#tInteger	; An integer value is valid
    907  1fdf		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    908  1fe1		       c8		      iny		; skip type indicator for
    909  1fe2				   ITSTBRANCHBYTE
    910  1fe2		       c8		      iny		; skip first byte of value line number
    911  1fe3		       c8		      iny		; Skip second byte of line number
    912  1fe4
    913  1fe4				   iTSTBRANCHVALID
    914  1fe4		       84 51		      sty	CUROFF
    915  1fe6		       20 2d 2c 	      jsr	pushR0	; place transfer address on top of stack
    916  1fe9		       4c e0 0b 	      jmp	tstBranch
    917  1fec
    918  1fec				   iTSTBRANCHNoCompile
    919  1fec		       68		      pla
    920  1fed				   iTSTBRANCHErr
    921  1fed		       4c b1 02 	      jmp	NextIL
    922  1ff0
    923  1ff0
    924  1ff0
    925  1ff0
    926  1ff0
    927  1ff0
    928  1ff0
    929  1ff0
    930  1ff0
    931  1ff0
------- FILE mytb.asm
------- FILE compile.asm LEVEL 2 PASS 6
      0  1ff0					      include	"compile.asm"
      1  1ff0					      Seg	Code
      2  1ff0							;
      3  1ff0							;=====================================================================
      4  1ff0							; Scan the loaded program just before running and insert memory locations of each
      5  1ff0							; line number branched to. goto 100, gosub 100, fn10(), task(100)
      6  1ff0							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value line number value}
      7  1ff0							; goto 100   : 07 0000 A2 64			 the tokenizer optimizes the literal values to byte or int depending on value
      8  1ff0							; gosub 1000 : 08 0000 A4 E803
      9  1ff0							; fn 100()   ; 37 0000 A2 64 40 41
     10  1ff0							; task(1000) : 2F 0000 40 A4 E803 41
     11  1ff0				   Compile
     12  1ff0		       a9 00		      lda	#0
     13  1ff2		       85 52		      sta	R0	; keep track of how many errors we find
     14  1ff4		       a5 5b		      lda	RunMode
     15  1ff6		       48		      pha
     16  1ff7		       e6 5b		      inc	RunMode	; force run mode for error reporting
     17  1ff9		       a5 4f		      lda	CURPTR
     18  1ffb		       48		      pha
     19  1ffc		       a5 50		      lda	CURPTR+1
     20  1ffe		       48		      pha
     21  1fff		       a5 51		      lda	CUROFF
     22  2001		       48		      pha
     23  2002		       ad 32 43 	      lda	ProgramStart
     24  2005		       85 59		      sta	dpl
     25  2007		       ad 33 43 	      lda	ProgramStart+1
     26  200a		       85 5a		      sta	dpl+1
     27  200c
     28  200c				   CompileLineStart
     29  200c		       a5 59		      lda	dpl
     30  200e		       cd 34 43 	      cmp	ProgramEnd
     31  2011		       d0 07		      bne	CompileContinue
     32  2013		       a5 5a		      lda	dpl+1
     33  2015		       cd 35 43 	      cmp	ProgramEnd+1
     34  2018		       f0 3f		      beq	CompileComplete
     35  201a
     36  201a				   CompileContinue
     37  201a		       a0 03		      ldy	#3	; first real character in the line
     38  201c
     39  201c				   CompileLoop
     40  201c		       b1 59		      lda	(dpl),y	; get the byte
     41  201e		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     42  2020		       c8		      iny		; Pass this byte
     43  2021		       c9 07		      cmp	#kGoto
     44  2023		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  2025		       c9 08		      cmp	#kGosub
     46  2027		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     47  2029		       c9 37		      cmp	#kGofn
     48  202b		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     49  202d		       c9 2f		      cmp	#kTask
     50  202f		       f0 4c		      beq	CompileField
     51  2031		       c9 0a		      cmp	#kRem
     52  2033		       f0 12		      beq	CompileRem	; Skip until end of line
     53  2035		       c9 a0		      cmp	#tString
     54  2037		       f0 2f		      beq	CompileString
     55  2039		       c9 a4		      cmp	#tInteger
     56  203b		       f0 06		      beq	CompileInteger
     57  203d		       c9 a2		      cmp	#tByte
     58  203f		       f0 03		      beq	CompileByte
     59  2041		       d0 d9		      bne	CompileLoop	; Next character
     60  2043
     61  2043				   CompileInteger
     62  2043		       c8		      iny
     63  2044				   CompileByte
     64  2044		       c8		      iny
     65  2045		       d0 d5		      bne	CompileLoop
     66  2047				   CompileRem
     67  2047				   CompileEndOfLine
     68  2047		       a0 00		      ldy	#0
     69  2049		       b1 59		      lda	(dpl),y
     70  204b		       18		      clc
     71  204c		       65 59		      adc	dpl
     72  204e		       85 59		      sta	dpl
     73  2050		       a9 00		      lda	#0
     74  2052		       65 5a		      adc	dpl+1
     75  2054		       85 5a		      sta	dpl+1
     76  2056
     77  2056		       4c 0c 20 	      jmp	CompileLineStart
     78  2059
     79  2059				   CompileComplete
     80  2059		       68		      pla
     81  205a		       85 51		      sta	CUROFF
     82  205c		       68		      pla
     83  205d		       85 50		      sta	CURPTR+1
     84  205f		       68		      pla
     85  2060		       85 4f		      sta	CURPTR
     86  2062		       68		      pla
     87  2063		       85 5b		      sta	RunMode
     88  2065		       a5 52		      lda	R0	; returning the number of errors
     89  2067		       60		      rts
     90  2068
     91  2068
     92  2068				   CompileString
     93  2068		       c8		      iny		; point past first "
     94  2069				   CompileStringLoop
     95  2069		       b1 59		      lda	(dpl),y
     96  206b		       f0 0d		      beq	CompileStrDone2	; end of line
     97  206d		       c9 22		      cmp	#'"	; end of string
     98  206f		       f0 08		      beq	CompileStrDone
     99  2071		       c9 5c		      cmp	#'\	; escape character
    100  2073		       d0 01		      bne	CompileStrNext
    101  2075		       c8		      iny		; skip the escape character
    102  2076				   CompileStrNext
    103  2076		       c8		      iny		; Next character
    104  2077		       d0 f0		      bne	CompileStringLoop	; test for end
    105  2079				   CompileStrDone
    106  2079		       c8		      iny
    107  207a				   CompileStrDone2
    108  207a		       4c 1c 20 	      Jmp	CompileLoop
    109  207d							;
    110  207d							;===============================================================
    111  207d							; on entry y points to storage location y+2 points to line number
    112  207d							; on exit y points to line number type
    113  207d
    114  207d		       85 52	   CompileField sta	R0
    115  207f		       98		      tya		; save the y pointer to store the memory value
    116  2080		       48		      pha
    117  2081		       c8		      iny		; Skip over the memory vector
    118  2082		       c8		      iny
    119  2083		       a5 52		      lda	R0
    120  2085		       c9 2f		      cmp	#kTask	; for a task it is the next byte after a bracket
    121  2087		       d0 07		      bne	CompNoBracket
    122  2089
    123  2089		       b1 59		      lda	(dpl),y	; Lets make sure it is a (
    124  208b		       c9 e0		      cmp	#oLeftBracket
    125  208d		       d0 01		      bne	CompNoBracket	; in case of error
    126  208f		       c8		      iny		; skip the bracket
    127  2090
    128  2090				   CompNoBracket
    129  2090		       a9 00		      lda	#0	; In case the value is a byte
    130  2092		       85 53		      sta	R0+1
    131  2094
    132  2094		       b1 59		      lda	(dpl),Y	; get the type of the next byte txxx something or other
    133  2096		       c9 a2		      cmp	#tByte
    134  2098		       f0 15		      beq	CompByteLoad
    135  209a		       c9 a4		      cmp	#tInteger
    136  209c		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    137  209e		       68		      pla
    138  209f		       4c 1c 20 	      jmp	CompileLoop	; Ignore the saved stack
    139  20a2				   CompIntLoad
    140  20a2		       c8		      iny
    141  20a3		       b1 59		      lda	(dpl),y
    142  20a5		       85 52		      sta	R0
    143  20a7		       c8		      iny
    144  20a8		       b1 59		      lda	(dpl),y
    145  20aa		       85 53		      sta	R0+1
    146  20ac		       4c b4 20 	      jmp	CompFindLine
    147  20af				   CompByteLoad
    148  20af		       c8		      iny
    149  20b0		       b1 59		      lda	(dpl),y
    150  20b2		       85 52		      sta	R0
    151  20b4				   CompFindLine
    152  20b4		       20 79 2a 	      jsr	findLine
    153  20b7		       f0 1d		      beq	CompFoundLine
    154  20b9		       e6 52		      inc	R0	; number of errors
    155  20bb
    156  20bb		       a5 59		      lda	dpl
    157  20bd		       85 4f		      sta	CURPTR
    158  20bf		       a5 5a		      lda	dpl+1
    159  20c1		       85 50		      sta	CURPTR+1
    160  20c3		       84 51		      sty	CUROFF
    161  20c5
    162  20c5		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    163  20c7		       a9 00		      lda	#0
    164  20c9
    165  20c9		       20 27 06 	      jsr	DisplayError
    166  20cc		       20 4e 22 	      jsr	PrintProgramLine
    167  20cf
    168  20cf		       68		      pla
    169  20d0		       a8		      tay
    170  20d1		       c8		      iny
    171  20d2		       c8		      iny
    172  20d3		       4c 1c 20 	      jmp	CompileLoop
    173  20d6
    174  20d6				   CompFoundLine
    175  20d6		       68		      pla
    176  20d7		       a8		      tay
    177  20d8		       a5 4f		      lda	CURPTR
    178  20da		       91 59		      sta	(dpl),y
    179  20dc		       c8		      iny
    180  20dd		       a5 50		      lda	CURPTR+1
    181  20df		       91 59		      sta	(dpl),y
    182  20e1		       c8		      iny
    183  20e2		       4c 1c 20 	      jmp	CompileLoop
    184  20e5
    185  20e5
    186  20e5
    187  20e5
    188  20e5
    189  20e5
    190  20e5
    191  20e5
    192  20e5
    193  20e5
    194  20e5
    195  20e5
    196  20e5
    197  20e5
    198  20e5
    199  20e5
    200  20e5
    201  20e5
    202  20e5
    203  20e5
    204  20e5
    205  20e5
    206  20e5
    207  20e5
    208  20e5
    209  20e5
    210  20e5
    211  20e5
    212  20e5
    213  20e5
    214  20e5
    215  20e5
    216  20e5
    217  20e5
    218  20e5
    219  20e5
    220  20e5
    221  20e5
    222  20e5
    223  20e5
    224  20e5
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  20e5					      include	"print.asm"
      1  20e5					      Seg	Code
      2  20e5							;---------------------------
      3  20e5							; Print 24-bit decimal number or  16bit unsigned
      4  20e5							; ---------------------------
      5  20e5							; On entry, R0=number to print
      6  20e5							;	     Defaults to pad=0 , y=21 default
      7  20e5							;	     R2 = 1 unsigned 16 bit
      8  20e5							;	     R2 = 0 Signed   16 bit
      9  20e5
     10  20e5							; On entry at PrintDecPadded:
     11  20e5							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  20e5
     13  20e5							; On exit,  A,X,Y,num,pad corrupted
     14  20e5							; Size      129 bytes, Table 24 bytes	--- total 153
     15  20e5							; -----------------------------------------------------------------
     16  20e5
     17  20e5				   PrintDecimal
     18  20e5		       8a		      TXA
     19  20e6		       48		      pha
     20  20e7		       98		      tya
     21  20e8		       48		      pha
     22  20e9		       a9 00		      lda	#0
     23  20eb		       8d 80 21 	      sta	pad
     24  20ee		       a0 15		      LDY	#21	; Offset to powers of ten
     25  20f0		       4c f6 20 	      JMP	PrintDo
     26  20f3
     27  20f3				   PrintDecPadded
     28  20f3		       8e 80 21 	      stx	pad
     29  20f6
     30  20f6				   PrintDo
     31  20f6		       a9 00		      lda	#0
     32  20f8		       85 54		      sta	R1
     33  20fa
     34  20fa		       a5 58		      lda	R2
     35  20fc		       c9 a9		      cmp	#tUint
     36  20fe		       f0 29		      beq	PrintPos
     37  2100
     38  2100		       a5 53		      lda	R0+1	;MSB has sign
     39  2102		       10 25		      bpl	PrintPos	;it's a positive number;
     40  2104
     41  2104
     42  2104							; Negative numbers need more work.  Invert all the bits,
     43  2104							; then add one.
     44  2104
     45  2104		       a9 2d		      lda	#'-
     46  2106		       20 5e 1a 	      jsr	VOUTCH	;print the negative sign
     47  2109
     48  2109		       a9 ff		      lda	#$FF
     49  210b		       85 54		      sta	R1
     50  210d		       a5 52		      lda	R0	;invert bits
     51  210f		       49 ff		      eor	#$ff
     52  2111		       85 52		      sta	R0
     53  2113		       a5 53		      lda	R0+1
     54  2115		       49 ff		      eor	#$ff
     55  2117		       85 53		      sta	R0+1
     56  2119		       a5 54		      lda	R1
     57  211b		       49 ff		      eor	#$ff
     58  211d		       85 54		      sta	R1
     59  211f		       e6 52		      inc	R0	;add one
     60  2121		       d0 06		      bne	PrintPos
     61  2123		       e6 53		      inc	R0+1
     62  2125		       d0 02		      bne	PrintPos
     63  2127		       e6 54		      inc	R1
     64  2129				   PrintPos
     65  2129
     66  2129				   PrDec24Lp1
     67  2129		       a2 ff		      LDX	#$FF
     68  212b		       38		      SEC		; Start with digit=-1
     69  212c				   PrDec24Lp2
     70  212c		       a5 52		      LDA	R0+0
     71  212e		       f9 81 21 	      SBC	PrDec24Tens+0,Y
     72  2131		       85 52		      STA	R0+0	; Subtract current tens
     73  2133		       a5 53		      LDA	R0+1
     74  2135		       f9 82 21 	      SBC	PrDec24Tens+1,Y
     75  2138		       85 53		      STA	R0+1
     76  213a		       a5 54		      LDA	R0+2
     77  213c		       f9 83 21 	      SBC	PrDec24Tens+2,Y
     78  213f		       85 54		      STA	R0+2
     79  2141		       e8		      INX
     80  2142		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     81  2144		       a5 52		      LDA	R0+0
     82  2146		       79 81 21 	      ADC	PrDec24Tens+0,Y
     83  2149		       85 52		      STA	R0+0	; Add current tens back in
     84  214b		       a5 53		      LDA	R0+1
     85  214d		       79 82 21 	      ADC	PrDec24Tens+1,Y
     86  2150		       85 53		      STA	R0+1
     87  2152		       a5 54		      LDA	R0+2
     88  2154		       79 83 21 	      ADC	PrDec24Tens+2,Y
     89  2157		       85 54		      STA	R0+2
     90  2159		       8a		      TXA
     91  215a		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     92  215c		       ad 80 21 	      LDA	pad
     93  215f		       d0 09		      BNE	PrDec24Print
     94  2161		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     95  2163				   PrDec24Digit
     96  2163		       a2 30		      LDX	#'0
     97  2165		       8e 80 21 	      STX	pad	; No more zero padding
     98  2168		       09 30		      ORA	#'0	; Print this digit
     99  216a				   PrDec24Print
    100  216a		       20 5e 1a 	      JSR	VOUTCH
    101  216d				   PrDec24Next
    102  216d		       88		      DEY
    103  216e		       88		      DEY
    104  216f		       88		      DEY
    105  2170		       f0 07		      beq	PrDec24LastDigit
    106  2172		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    107  2174		       68		      pla
    108  2175		       a8		      tay
    109  2176		       68		      pla
    110  2177		       aa		      tax
    111  2178		       60		      RTS
    112  2179				   PrDec24LastDigit
    113  2179		       a2 30		      LDX	#'0
    114  217b		       8e 80 21 	      STX	pad	; No more zero padding
    115  217e		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    116  2180
      0  2180				   pad	      db	0
      1  2180		       00		      .byte.b	0
    118  2181
    119  2181				   PrDec24Tens
      0  2181					      dw	1
      1  2181		       01 00		      .word.w	1
      0  2183					      db	(1 / 65536)
      1  2183		       00		      .byte.b	(1 / 65536)
      0  2184					      dw	10
      1  2184		       0a 00		      .word.w	10
      0  2186					      db	(10 / 65536)
      1  2186		       00		      .byte.b	(10 / 65536)
      0  2187					      dw	100
      1  2187		       64 00		      .word.w	100
      0  2189					      db	(100 / 65536)
      1  2189		       00		      .byte.b	(100 / 65536)
      0  218a					      dw	1000
      1  218a		       e8 03		      .word.w	1000
      0  218c					      db	(1000 / 65536)
      1  218c		       00		      .byte.b	(1000 / 65536)
      0  218d					      dw	10000
      1  218d		       10 27		      .word.w	10000
      0  218f					      db	(10000 / 65536)
      1  218f		       00		      .byte.b	(10000 / 65536)
      0  2190					      dw	100000
      1  2190		       a0 86		      .word.w	100000
      0  2192					      db	(100000 / 65536)
      1  2192		       01		      .byte.b	(100000 / 65536)
      0  2193					      dw	1000000
      1  2193		       40 42		      .word.w	1000000
      0  2195					      db	(1000000 / 65536)
      1  2195		       0f		      .byte.b	(1000000 / 65536)
      0  2196					      dw	10000000
      1  2196		       80 96		      .word.w	10000000
      0  2198					      db	(10000000 / 65536)
      1  2198		       98		      .byte.b	(10000000 / 65536)
    136  2199							;=====================================================
    137  2199							; Print character in A as two hex digits to the Console
    138  2199
    139  2199		       48	   HexToOut   pha		;save return value
    140  219a		       48		      pha
    141  219b		       4a		      lsr		;a  ;move top nibble to bottom
    142  219c		       4a		      lsr		;a
    143  219d		       4a		      lsr		;a
    144  219e		       4a		      lsr		;a
    145  219f		       20 a8 21 	      jsr	hexta	;output nibble
    146  21a2		       68		      pla
    147  21a3		       20 a8 21 	      jsr	hexta
    148  21a6		       68		      pla		;restore
    149  21a7		       60		      rts
    150  21a8							;
    151  21a8		       29 0f	   hexta      and	#%0001111
    152  21aa		       c9 0a		      cmp	#$0a
    153  21ac		       18		      clc
    154  21ad		       30 02		      bmi	hexta1
    155  21af		       69 07		      adc	#7
    156  21b1		       69 30	   hexta1     adc	#'0	;then fall into...
    157  21b3		       4c 5e 1a 	      jmp	VOUTCH
    158  21b6							;
    159  21b6							;=====================================================
    160  21b6							; Print the string that immediately follows the JSR to
    161  21b6							; this function.  Stops when a null byte is found,
    162  21b6							; then returns to the instruction immediately
    163  21b6							; following the null.
    164  21b6							;
    165  21b6							; Thanks to Ross Archer for this code.
    166  21b6							; http://www.6502.org/source/io/primm.htm
    167  21b6							;
    168  21b6
    169  21b6		       68	   tbputs     pla		;Get the low part of "return" address
    170  21b7							;(data start address)
    171  21b7		       85 5e		      sta	PrtFrom
    172  21b9		       68		      pla
    173  21ba		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    174  21bc							;(data start address)
    175  21bc							;Note: actually we're pointing one short
    176  21bc		       a0 01	   PSINB      ldy	#1
    177  21be		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    178  21c0		       e6 5e		      inc	PrtFrom	;update the pointer
    179  21c2		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    180  21c4		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    181  21c6		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    182  21c8							;   Accumulator
    183  21c8		       f0 06		      beq	PSIX1	;don't print the final NULL
    184  21ca		       20 5e 1a 	      jsr	VOUTCH	;write it out
    185  21cd		       4c bc 21 	      jmp	PSINB	;back around
    186  21d0		       e6 5e	   PSIX1      inc	PrtFrom
    187  21d2		       d0 02		      bne	PSIX2
    188  21d4		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    189  21d6		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    190  21d9
    191  21d9							;+
    192  21d9							;====================================================
    193  21d9		       43 26	   PrtTerm    equ	tempy
    194  21d9
    195  21d9							; on exit Print Y has the offset to use
    196  21d9							; input y =	 addr low
    197  21d9							;	 x =	 addr high
    198  21d9							;	 a =	 termination string
    199  21d9
    200  21d9
    201  21d9				   PrtQuoted		; Print a quoted string from the current program space
    202  21d9		       a9 22		      lda	#'"
    203  21db		       a4 51		      ldy	CUROFF
    204  21dd		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    205  21df		       d0 03		      bne	PrtNoInc
    206  21e1		       c8		      iny
    207  21e2		       84 51		      sty	CUROFF
    208  21e4				   PrtNoInc
    209  21e4		       8d 26 43 	      sta	PrtTerm
    210  21e7
    211  21e7				   PrtPrgString 		; Print a terminated string from the static program space
    212  21e7		       a4 51		      ldy	CUROFF
    213  21e9		       a5 4f		      lda	CURPTR
    214  21eb		       85 5e		      sta	PrtFrom
    215  21ed		       a5 50		      lda	CURPTR+1
    216  21ef		       85 5f		      sta	PrtFrom+1
    217  21f1		       4c fd 21 	      jmp	PrtLoop
    218  21f4
    219  21f4							; Print a string pointed to by x= h, y=l terminated by value in  accumulator
    220  21f4							; Return y as the length
    221  21f4
    222  21f4		       86 5f	   PrtStr     stx	PrtFrom+1
    223  21f6		       84 5e		      sty	PrtFrom
    224  21f8		       8d 26 43 	      sta	PrtTerm
    225  21fb		       a0 00		      ldy	#0
    226  21fd							;
    227  21fd							; On entry here ptrfrom and prtterm point to area to print
    228  21fd							;
    229  21fd		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    230  21ff		       cd 26 43 	      cmp	PrtTerm
    231  2202		       f0 0b		      beq	PrtEnd
    232  2204		       c9 00		      cmp	#0	; always end if 0 is found
    233  2206		       f0 07		      beq	PrtEnd
    234  2208		       20 5e 1a 	      jsr	VOUTCH
    235  220b		       c8		      iny
    236  220c		       4c fd 21 	      jmp	PrtLoop
    237  220f		       c8	   PrtEnd     iny		;return byte after the write
    238  2210		       60		      rts
    239  2211
    240  2211							;
    241  2211							;=======================================================
    242  2211							; Print all Variables
    243  2211				   PrintAllVars
    244  2211		       a0 00		      ldy	#0
    245  2213		       a9 41		      lda	#'A
    246  2215				   PrintAllVarsLoop
    247  2215		       48		      pha
    248  2216		       b1 41		      lda	(VARIABLES),y
    249  2218		       85 52		      sta	R0
    250  221a		       c8		      iny
    251  221b		       b1 41		      lda	(VARIABLES),y
    252  221d		       85 53		      sta	R0+1
    253  221f
    254  221f		       68		      pla		;get the current letter
    255  2220		       48		      pha
    256  2221		       20 5e 1a 	      jsr	VOUTCH
    257  2224		       20 b6 21 	      jsr	puts
      0  2227					      db	"=",0
      1  2227		       3d 00		      .byte.b	"=",0
    259  2229		       68		      pla
    260  222a		       aa		      tax
    261  222b		       e8		      inx
    262  222c		       8a		      txa
    263  222d		       48		      pha		;
    264  222e
    265  222e		       98		      tya
    266  222f		       48		      pha
    267  2230		       20 e5 20 	      jsr	PrintDecimal
    268  2233		       20 b6 21 	      jsr	puts
      0  2236					      db	" ",0
      1  2236		       20 00		      .byte.b	" ",0
    270  2238		       68		      pla
    271  2239		       a8		      tay
    272  223a		       c8		      iny
    273  223b		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    274  223d		       90 d6		      bcc	PrintAllVarsLoop
    275  223f		       20 78 2d 	      jsr	CRLF
    276  2242
    277  2242		       68		      pla
    278  2243		       60		      rts
    279  2244							;==========================================================================================================
    280  2244							;Debug   Print a Program Line from compile buffer
    281  2244							;
    282  2244				   DebugPrintProgramLine
    283  2244		       48		      pha
    284  2245		       a9 56		      lda	#TOKENBUFFER&$FF
    285  2247		       85 59		      sta	dpl
    286  2249		       a9 1c		      lda	#TOKENBUFFER>>8
    287  224b		       85 5a		      sta	dpl+1
    288  224d		       68		      pla
    289  224e
    290  224e							; Decode and print a line of program text
    291  224e							; on entry	 dpl points to line of code to print
    292  224e							; on exit	 no change in reg or dpl
    293  224e							;
    294  224e				   PrintProgramLine
    295  224e
    296  224e		       8e 56 1d 	      stx	printStorage
    297  2251		       8c 57 1d 	      sty	printStorage+1
    298  2254		       48		      pha
    299  2255
    300  2255		       a0 01		      ldy	#1	; index into the token buffer
    301  2257		       84 58		      sty	R2	; print unsigned decimal
    302  2259		       a0 00		      ldy	#0
    303  225b		       b1 59		      lda	(dpl),y	; get number of bytes
    304  225d		       aa		      tax		; place pointer into x
    305  225e		       c8		      iny
    306  225f		       ca		      dex		; Deduct the length byte
    307  2260		       20 42 1f 	      jsr	DPL2R0	; Print the line number
    308  2263		       20 e5 20 	      jsr	PrintDecimal
    309  2266		       a9 20		      lda	#$20
    310  2268		       20 5e 1a 	      jsr	VOUTCH
    311  226b
    312  226b				   PrintProgLoop
    313  226b		       b1 59		      lda	(dpl),y	; Get a character
    314  226d		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    315  226f		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    316  2271		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    317  2273
    318  2273				   PrintProgVars
    319  2273		       b1 59		      lda	(dpl),y
    320  2275		       29 e0		      and	#$E0	; Check for operators and punctuation
    321  2277		       c9 e0		      cmp	#$E0
    322  2279		       f0 6b		      beq	PrintProgOperatorVect
    323  227b
    324  227b		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    325  227d		       c9 9e		      cmp	#$9D+1
    326  227f		       90 62		      bcc	PrintProgVariableVec
    327  2281		       29 a0		      and	#$A0	; Check for a valid datatype
    328  2283		       c9 a0		      cmp	#$A0
    329  2285		       f0 06		      beq	PrintDataType	; if not just print the character
    330  2287		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    331  2289		       ca		      dex		; Ok we are processing it
    332  228a		       c8		      iny
    333  228b		       d0 25		      bne	PrintContinue	; Print and do the next character
    334  228d
    335  228d				   PrintDataType
    336  228d		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    337  228f		       c9 a0		      cmp	#tString
    338  2291		       f0 31		      beq	PrintStringVariable
    339  2293
    340  2293				   PrintProgNumber
    341  2293		       c8		      iny		; we have a numerical integer value
    342  2294		       ca		      dex
    343  2295		       48		      pha
    344  2296		       a9 00		      lda	#0
    345  2298		       85 53		      sta	R0+1
    346  229a		       85 58		      sta	R2	; Set to print signed number
    347  229c		       b1 59		      lda	(dpl),y
    348  229e		       85 52		      sta	R0
    349  22a0		       68		      pla
    350  22a1		       c9 a4		      cmp	#tInteger
    351  22a3		       d0 06		      bne	PrintProgNumDone
    352  22a5		       c8		      iny
    353  22a6		       ca		      dex
    354  22a7		       b1 59		      lda	(dpl),y
    355  22a9		       85 53		      sta	R0+1
    356  22ab
    357  22ab				   PrintProgNumDone
    358  22ab		       c8		      iny
    359  22ac		       ca		      dex
    360  22ad		       20 e5 20 	      jsr	PrintDecimal
    361  22b0
    362  22b0				   PrintProgNext
    363  22b0		       a9 20		      lda	#$20
    364  22b2				   PrintContinue
    365  22b2		       20 5e 1a 	      jsr	VOUTCH
    366  22b5				   PrintProgSkipSpace
    367  22b5		       e0 00		      cpx	#0
    368  22b7		       d0 b2		      bne	PrintProgLoop
    369  22b9				   PrintProgramComplete
    370  22b9		       20 78 2d 	      jsr	CRLF
    371  22bc
    372  22bc		       ae 56 1d 	      ldx	printStorage
    373  22bf		       ac 57 1d 	      ldy	printStorage+1
    374  22c2		       68		      pla
    375  22c3
    376  22c3		       60		      rts
    377  22c4							;=================================================================================================================
    378  22c4							; Print a string variable including the quotes
    379  22c4							; On Input	 y is offset into buffer
    380  22c4							; On Exit	 y is updated to new offset
    381  22c4
    382  22c4				   PrintStringVariable
    383  22c4		       c8		      iny
    384  22c5		       a9 22		      lda	#'"
    385  22c7		       20 5e 1a 	      jsr	VOUTCH
    386  22ca		       c8		      iny
    387  22cb		       a5 59		      lda	dpl
    388  22cd		       85 5e		      sta	PrtFrom
    389  22cf		       a5 5a		      lda	dpl+1
    390  22d1		       85 5f		      sta	PrtFrom+1
    391  22d3		       a9 22		      lda	#'"
    392  22d5		       8d 26 43 	      sta	PrtTerm
    393  22d8		       20 fd 21 	      jsr	PrtLoop
    394  22db		       a9 22		      lda	#'"
    395  22dd		       20 5e 1a 	      jsr	VOUTCH
    396  22e0		       4c b0 22 	      jmp	PrintProgNext
    397  22e3
    398  22e3				   PrintProgVariableVec
    399  22e3		       4c 83 23 	      jmp	PrintProgVariable
    400  22e6
    401  22e6				   PrintProgOperatorVect
    402  22e6		       4c 5a 23 	      jmp	PrintProgOperator
    403  22e9							;===============================================================================================================
    404  22e9							; On entry dpl points to the buffer we are printing from
    405  22e9							;	    y	current offset into the dpl buffer
    406  22e9							; all registers preserved
    407  22e9							;
    408  22e9				   PrintKeyword
    409  22e9
    410  22e9		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    411  22eb		       85 52		      sta	R0	; The value we are looking for
    412  22ed		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    413  22ef		       f0 0c		      beq	PrintKeyBranch
    414  22f1		       c9 08		      cmp	#kGosub
    415  22f3		       f0 08		      beq	PrintKeyBranch
    416  22f5		       c9 2f		      cmp	#kTask
    417  22f7		       f0 04		      beq	PrintKeyBranch
    418  22f9		       c9 37		      cmp	#kGofn
    419  22fb		       d0 04		      bne	PrintKeySkipped
    420  22fd				   PrintKeyBranch
    421  22fd		       c8		      iny		; Skip the compiled memory address
    422  22fe		       c8		      iny
    423  22ff		       ca		      dex		; Change number of bytes to print
    424  2300		       ca		      dex		; Remove the bytes to print
    425  2301
    426  2301				   PrintKeySkipped
    427  2301		       c8		      iny		; Inc y to point to the next char to be printed
    428  2302		       ca		      dex		; Reduce number of bytes to print
    429  2303		       98		      tya		; Save y and x for the return
    430  2304		       48		      pha
    431  2305		       8a		      txa
    432  2306		       48		      pha
    433  2307
    434  2307		       a9 19		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    435  2309		       85 54		      sta	R1
    436  230b		       a9 1b		      lda	#KeyWordTable>>8
    437  230d		       85 55		      sta	R1+1
    438  230f
    439  230f
    440  230f				   PrintKeyLoop
    441  230f		       a0 00		      ldy	#0	; Index into the keyword entry
    442  2311		       b1 54		      lda	(R1),y	; Get token value for this entry
    443  2313		       c8		      iny		; Point to first byte of key
    444  2314		       c5 52		      cmp	R0	; Compare to the token we are looking for
    445  2316		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    446  2318
    447  2318				   PrintKeyNext
    448  2318		       b1 54		      lda	(R1),y	; Get key letter
    449  231a		       c8		      iny		; Point to next byte always
    450  231b		       29 20		      and	#%00100000	; Check for last character in key work
    451  231d		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    452  231f
    453  231f		       98		      tya		; Trabsfer y to a for the addition
    454  2320		       18		      clc		; Table > 256 bytes
    455  2321		       65 54		      adc	R1
    456  2323		       85 54		      sta	R1
    457  2325		       a9 00		      lda	#0
    458  2327		       65 55		      adc	R1+1
    459  2329		       85 55		      sta	R1+1
    460  232b		       4c 0f 23 	      jmp	PrintKeyLoop
    461  232e
    462  232e				   PrintKeyFound
    463  232e		       b1 54		      lda	(R1),y	; letter from key table
    464  2330		       48		      pha		; Save it for later check
    465  2331		       09 20		      ora	#%00100000	; Force it to lower case
    466  2333		       20 5e 1a 	      jsr	VOUTCH	; Print it out
    467  2336		       c8		      iny		; Point to next character
    468  2337		       68		      pla		; Restore the value
    469  2338		       29 20		      and	#%00100000	; Check if it was last char in keyword
    470  233a		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    471  233c
    472  233c		       68		      pla		; Restore the x and y values
    473  233d		       aa		      tax
    474  233e		       68		      pla
    475  233f		       a8		      tay
    476  2340
    477  2340				   PrintChkRem
    478  2340		       a9 0a		      lda	#kRem
    479  2342		       c5 52		      cmp	R0
    480  2344		       d0 11		      bne	PrintKeyDone
    481  2346				   PrintKeyRem
    482  2346		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    483  2348		       85 5e		      sta	PrtFrom
    484  234a		       a5 5a		      lda	dpl+1
    485  234c		       85 5f		      sta	PrtFrom+1
    486  234e		       a9 00		      lda	#0
    487  2350		       8d 26 43 	      sta	PrtTerm
    488  2353		       20 fd 21 	      jsr	PrtLoop
    489  2356		       88		      dey		; point back to the terminating null value
    490  2357				   PrintKeyDone
    491  2357		       4c b0 22 	      jmp	PrintProgNext
    492  235a							;==================================================================================================================
    493  235a							;Print Variable, number or operator
    494  235a				   PrintProgOperator
    495  235a		       b1 59		      lda	(dpl),y
    496  235c		       c8		      iny
    497  235d		       ca		      dex
    498  235e		       8e 58 1d 	      stx	printStorage+2
    499  2361		       a2 00		      ldx	#0
    500  2363				   PrintOprLoop
    501  2363		       dd fb 1a 	      cmp	OperValues,x
    502  2366		       f0 03		      beq	PrintOprFound
    503  2368		       e8		      inx
    504  2369		       d0 f8		      bne	PrintOprLoop
    505  236b				   PrintOprFound
    506  236b		       8a		      txa
    507  236c		       0a		      asl
    508  236d		       aa		      tax
    509  236e		       bd bd 1a 	      lda	Operators,x
    510  2371		       20 5e 1a 	      jsr	VOUTCH
    511  2374		       e8		      inx
    512  2375		       bd bd 1a 	      lda	Operators,x
    513  2378		       f0 03		      beq	PrintOprDone
    514  237a		       20 5e 1a 	      jsr	VOUTCH
    515  237d				   PrintOprDone
    516  237d		       ae 58 1d 	      ldx	printStorage+2
    517  2380		       4c b0 22 	      jmp	PrintProgNext
    518  2383
    519  2383							;=================================================================================================================
    520  2383							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    521  2383							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    522  2383							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    523  2383							;tVhat 	    equ     155 		   ; Variable ^
    524  2383							;tVhash	    equ     156 		   ; Variable #
    525  2383							;tVat		    equ     157 		   ; Variable @ = 0
    526  2383				   PrintProgVariable
    527  2383		       b1 59		      lda	(dpl),y
    528  2385		       c8		      iny
    529  2386		       ca		      dex
    530  2387		       c9 9b		      cmp	#tVhat
    531  2389		       d0 04		      bne	PrintProgChkHash
    532  238b		       a9 5e		      lda	#'^
    533  238d		       d0 15		      bne	PrintTheVar
    534  238f				   PrintProgChkHash
    535  238f		       c9 9c		      cmp	#tVhash
    536  2391		       d0 04		      bne	PrintProgChkAt
    537  2393		       a9 23		      lda	#'#
    538  2395		       d0 0d		      bne	PrintTheVar
    539  2397				   PrintProgChkAt
    540  2397		       c9 9d		      cmp	#tVat
    541  2399		       d0 04		      bne	PrintProgVarLetter
    542  239b		       a9 40		      lda	#'@
    543  239d		       d0 05		      bne	PrintTheVar
    544  239f				   PrintProgVarLetter
    545  239f		       29 7f		      and	#%01111111
    546  23a1		       18		      clc
    547  23a2		       69 41		      adc	#'A
    548  23a4				   PrintTheVar
    549  23a4		       20 5e 1a 	      jsr	VOUTCH
    550  23a7		       4c b0 22 	      jmp	PrintProgNext
    551  23aa
    552  23aa
    553  23aa							;==================================================================================================
    554  23aa							; Size of print functions
    555  23aa		       02 c5	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  23aa					      include	"mem.asm"
      1  23aa							;===================================================================
      2  23aa							;This file contains the memory allocation and free functions
      3  23aa							; This is the management of free memory in the system
      4  23aa							; the interface to these functions
      5  23aa							; a,x returns or provides the low hi bytes of the managed addresses
      6  23aa							; This uses the programend, to memory end as the area to manage
      7  23aa							;===================================================================
      8 U3671					      Seg.u	TBData
      9 U3671							;
     10 U3671							;=====================================================
     11 U3671							;Pointers for memory Management
     12 U3671							;Allocated block are not chained but can be followed for all memory by the associated length
     13 U3671							; Mem block format is
     14 U3671							;	 0-1   pointer to next block for free blocks
     15 U3671							;	 0-1   for allocated blocks
     16 U3671							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     17 U3671							;	   1   refrence counter ... lol only up to 256 but it is something
     18 U3671							;	 2-3   length constant for exevy type of memory block
     19 U3671							; Memory is recombined as it is released
     20 U3671							; The memory manager is not interupted durring allocation
     21 U3671							; or freeing of memory
     22 U3671							;====================================================
     23 U3671		       00 00	   MemFreeList ds	2	; list of free blocks of memory
     24 U3673		       00 00	   MemR0      ds	2	; source for copy/move/Init
     25 U3675		       00 00	   MemR1      ds	2	; Destination for copy/move
     26 U3677							;=====================================================
     27  23aa					      Seg	Code
     28  23aa							;=====================================================
     29  23aa				   MemInit
     30  23aa		       a9 3c		      lda	#FreeMemStart&$FF
     31  23ac		       8d 32 43 	      sta	ProgramStart
     32  23af		       8d 34 43 	      sta	ProgramEnd
     33  23b2		       a9 43		      lda	#FreeMemStart>>8
     34  23b4		       8d 33 43 	      sta	ProgramStart+1
     35  23b7		       8d 35 43 	      sta	ProgramEnd+1
     36  23ba
     37  23ba		       20 c4 23 	      jsr	GetSizes
     38  23bd		       20 cf 23 	      jsr	MemFree
     39  23c0		       20 e7 23 	      jsr	MemUsed
     40  23c3				   MemInitEnd
     41  23c3		       60		      rts
     42  23c4
     43  23c4
     44  23c4							;
     45  23c4							;=====================================================
     46  23c4							; This function might go away eventually, but was
     47  23c4							; added to provide data for other pieces of code.
     48  23c4							; It has some ties to the operating environment that
     49  23c4							; will need to be customized for the target system.
     50  23c4							;
     51  23c4				   GetSizes
     52  23c4							;
     53  23c4							; Here is machine specific code to get the highest
     54  23c4							; memory location that can be used by BASIC.
     55  23c4							;
     56  23c4				  -	      if	ProgramStart < $2000
     57  23c4				  -	      lda	#$ff
     58  23c4				  -	      sta	HighMem	;$13ff for KIM-1
     59  23c4				  -	      sta	MemFreeList
     60  23c4				  -	      lda	#$DE	;#$13
     61  23c4				  -	      sta	HighMem+1
     62  23c4				  -	      sta	MemFreeList+1
     63  23c4					      else
     64  23c4		       a9 ff		      lda	#$ff
     65  23c6		       8d 36 43 	      sta	HighMem	;$CFFF otherwise
     66  23c9		       a9 cf		      lda	#$cf
     67  23cb		       8d 37 43 	      sta	HighMem+1
     68  23ce					      endif
     69  23ce		       60		      rts
     70  23cf							;
     71  23cf							; This computes the available memory remaining.
     72  23cf							;
     73  23cf				   MemFree
     74  23cf		       38		      sec
     75  23d0		       ad 36 43 	      lda	HighMem
     76  23d3		       ed 34 43 	      sbc	ProgramEnd
     77  23d6		       8d 3a 43 	      sta	FreeMem
     78  23d9		       85 52		      sta	R0
     79  23db		       ad 37 43 	      lda	HighMem+1
     80  23de		       ed 35 43 	      sbc	ProgramEnd+1
     81  23e1		       8d 3b 43 	      sta	FreeMem+1
     82  23e4		       85 53		      sta	R0+1
     83  23e6		       60		      rts
     84  23e7							;
     85  23e7							; This computes the size of the current user program.
     86  23e7							;
     87  23e7				   MemUsed
     88  23e7		       38		      sec
     89  23e8		       ad 34 43 	      lda	ProgramEnd
     90  23eb		       ed 32 43 	      sbc	ProgramStart
     91  23ee		       8d 38 43 	      sta	UsedMem
     92  23f1		       85 52		      sta	R0
     93  23f3		       ad 35 43 	      lda	ProgramEnd+1
     94  23f6		       ed 33 43 	      sbc	ProgramStart+1
     95  23f9		       8d 39 43 	      sta	UsedMem+1
     96  23fc		       85 53		      sta	R0+1
     97  23fe							;
     98  23fe		       60		      rts
     99  23ff							;
    100  23ff							;=====================================================
    101  23ff							; Set a block of memory to a value
    102  23ff		       8a	   iSetBlock  txa
    103  2400		       48		      pha
    104  2401		       98		      tya
    105  2402		       48		      pha
    106  2403		       20 bf 2c 	      jsr	popR0	; the address to write to
    107  2406		       a5 52		      lda	R0
    108  2408		       85 59		      sta	dpl
    109  240a		       a5 53		      lda	R0+1
    110  240c		       85 5a		      sta	dpl+1
    111  240e		       20 d7 2c 	      jsr	popR1	; Number of bytes to write
    112  2411		       20 bf 2c 	      jsr	popR0	; Get the value to store into memory
    113  2414		       20 34 2a 	      jsr	getILByte
    114  2417		       85 58		      sta	R2	; store the data type into R2
    115  2419		       c9 a4		      cmp	#tInteger
    116  241b		       f0 08		      beq	memset	; skip this if we have an integer
    117  241d		       a5 52		      lda	R0	; Revers the order so they can be copied in correct order
    118  241f		       a6 53		      ldx	R0+1
    119  2421		       86 52		      stx	R0
    120  2423		       85 53		      sta	R0+1
    121  2425
    122  2425				   memset
    123  2425		       a0 00		      ldy	#0	; Set for length of block to copy
    124  2427		       a2 00		      ldx	#0	; set for number of block of 256 to copy
    125  2429
    126  2429		       a5 58	   iSetBlockLoop lda	R2	; Get Datatype
    127  242b		       c9 a2		      cmp	#tByte
    128  242d		       f0 09		      beq	iSetBlockB
    129  242f
    130  242f		       a5 52	   iSetBlockW lda	R0
    131  2431		       91 59		      sta	(dpl),y
    132  2433		       20 48 24 	      jsr	iSetBlockEnd
    133  2436		       f0 09		      beq	iSetBlockComplete
    134  2438
    135  2438		       a5 53	   iSetBlockB lda	R0+1
    136  243a		       91 59		      sta	(dpl),y
    137  243c		       20 48 24 	      jsr	iSetBlockEnd
    138  243f		       d0 e8		      bne	iSetBlockLoop
    139  2441
    140  2441				   iSetBlockComplete
    141  2441		       68		      pla
    142  2442		       a8		      tay
    143  2443		       68		      pla
    144  2444		       aa		      tax
    145  2445		       4c b1 02 	      jmp	NextIL
    146  2448							;
    147  2448							; Check if we have reached the end of the initialization/Copy
    148  2448							;
    149  2448		       c8	   iSetBlockEnd iny
    150  2449		       d0 03		      bne	iSetBlockEndChk
    151  244b		       e8		      inx
    152  244c		       e6 5a		      inc	dpl+1
    153  244e				   iSetBlockEndChk
    154  244e		       c4 54		      cpy	R1
    155  2450		       d0 02		      bne	iSetBlockEndExit
    156  2452		       e4 55		      cpx	R1+1
    157  2454				   iSetBlockEndExit
    158  2454		       60		      rts
    159  2455							;
    160  2455							;================================================================
    161  2455							; Copy a block of memory from one location to another
    162  2455							;
    163  2455		       8a	   iCopyBlock txa
    164  2456		       48		      pha
    165  2457		       98		      tya
    166  2458		       48		      pha
    167  2459		       20 bf 2c 	      jsr	popR0	; get the source address
    168  245c		       20 d7 2c 	      jsr	popR1	; Destination address
    169  245f		       a5 54		      lda	R1
    170  2461		       85 59		      sta	dpl
    171  2463		       a5 55		      lda	R1+1
    172  2465		       85 5a		      sta	dpl+1
    173  2467		       20 d7 2c 	      jsr	popR1	; Number of bytes to copy
    174  246a				   memcpy
    175  246a		       a2 00		      ldx	#0
    176  246c		       a0 00		      ldy	#0
    177  246e				   iCopyBlockLoop
    178  246e		       b1 52		      lda	(R0),y	;  Get the byte to copy
    179  2470		       91 59		      sta	(dpl),y	;  Store the byte
    180  2472		       c8		      iny
    181  2473		       d0 05		      bne	iCopyChkEnd
    182  2475		       e8		      inx
    183  2476		       e6 53		      inc	R0+1
    184  2478		       e6 5a		      inc	dpl+1
    185  247a		       c4 54	   iCopyChkEnd cpy	R1
    186  247c		       d0 f0		      bne	iCopyBlockLoop
    187  247e		       e4 55		      cpx	R1+1
    188  2480		       d0 ec		      bne	iCopyBlockLoop
    189  2482				   iCopyBlockDone
    190  2482		       68		      pla
    191  2483		       a8		      tay
    192  2484		       68		      pla
    193  2485		       aa		      tax
    194  2486		       4c b1 02 	      jmp	NextIL
    195  2489							;
    196  2489							;=============================================================================
    197  2489							; Compare memory block location
    198  2489							; returns on the stack
    199  2489							; 0 - equals
    200  2489							; -1 - s1  <  s2
    201  2489							; 1   s1  >  s2
    202  2489		       8a	   iCmpBlock  txa
    203  248a		       48		      pha
    204  248b		       98		      tya
    205  248c		       48		      pha
    206  248d		       20 d7 2c 	      jsr	popR1	; Get the Source 2 pointer
    207  2490		       a5 54		      lda	R1
    208  2492		       85 59		      sta	dpl	; store the secon source in dpl
    209  2494		       a5 55		      lda	R1+1
    210  2496		       85 5a		      sta	dpl+1
    211  2498		       20 bf 2c 	      jsr	popR0	; Get the Source 1 pointer
    212  249b		       20 d7 2c 	      jsr	popR1	; Get the length of the compare to do
    213  249e		       a0 00		      ldy	#0
    214  24a0		       a2 00		      ldx	#0
    215  24a2		       4c af 24 	      jmp	iCmpCheckEnd
    216  24a5
    217  24a5		       b1 59	   iCmpLoop   lda	(dpl),y
    218  24a7		       d1 52		      cmp	(R0),y
    219  24a9		       d0 19		      bne	iCmpDone
    220  24ab		       c8		      iny
    221  24ac		       d0 01		      bne	iCmpCheckEnd
    222  24ae		       e8		      inx
    223  24af				   iCmpCheckEnd
    224  24af		       c4 54		      cpy	R1
    225  24b1		       d0 f2		      bne	iCmpLoop
    226  24b3		       e4 55		      cpx	R1+1
    227  24b5		       d0 ee		      bne	iCmpLoop
    228  24b7		       a5 00		      lda	0
    229  24b9		       85 53		      sta	R0+1
    230  24bb		       85 52		      sta	R0
    231  24bd				   iCmpReturn
    232  24bd		       68		      pla
    233  24be		       a8		      tay
    234  24bf		       68		      pla
    235  24c0		       aa		      tax
    236  24c1		       4c 1d 07 	      jmp	pushR0nextIl
    237  24c4
    238  24c4				   iCmpDone
    239  24c4		       90 0a		      bcc	iCmpGreater
    240  24c6				   iCmpLess
    241  24c6		       a9 00		      lda	#0
    242  24c8		       85 53		      sta	R0+1
    243  24ca		       a9 01		      lda	#1
    244  24cc		       85 52		      sta	R0
    245  24ce		       d0 ed		      bne	iCmpReturn
    246  24d0				   iCmpGreater
    247  24d0		       a9 ff		      lda	#-1
    248  24d2		       85 52		      sta	R0
    249  24d4		       85 53		      sta	R0+1
    250  24d6		       d0 e5		      bne	iCmpReturn
    251  24d8
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  24d8					      include	"gosub.asm"
      1  24d8					      seg	Code
      2  24d8
      3  24d8							; Gosub and return related functions
      4  24d8							;==========================================================
      5  24d8							; Push the current math stack frame onto the gosub stack
      6  24d8				   iPushMathStack
      7  24d8		       98		      tya
      8  24d9		       48		      pha
      9  24da		       a4 4d		      ldy	GOSUBSTACKPTR
     10  24dc		       a5 4a		      lda	MATHSTACKPTR
     11  24de		       91 4b		      sta	(GOSUBSTACK),y
     12  24e0		       a9 00		      lda	#0
     13  24e2		       c8		      iny
     14  24e3		       91 4b		      sta	(GOSUBSTACK),y
     15  24e5		       c8		      iny
     16  24e6		       91 4b		      sta	(GOSUBSTACK),y
     17  24e8		       c8		      iny
     18  24e9		       a9 05		      lda	#GOSUB_STACK_FRAME
     19  24eb		       91 4b		      sta	(GOSUBSTACK),y
     20  24ed		       c8		      iny
     21  24ee		       84 4d		      sty	GOSUBSTACKPTR
     22  24f0		       68		      pla
     23  24f1		       a8		      tay
     24  24f2		       4c b1 02 	      jmp	NextIL
     25  24f5							;
     26  24f5							;==========================================================
     27  24f5							; Increment parameter count. Assume Stack frame is top of stack
     28  24f5				   iIncParmCount
     29  24f5		       98		      tya
     30  24f6		       48		      pha
     31  24f7
     32  24f7		       a4 4d		      ldy	GOSUBSTACKPTR
     33  24f9		       88		      dey
     34  24fa		       88		      dey
     35  24fb		       88		      dey
     36  24fc		       b1 4b		      lda	(GOSUBSTACK),y
     37  24fe		       18		      clc
     38  24ff		       69 01		      adc	#1
     39  2501		       91 4b		      sta	(GOSUBSTACK),y
     40  2503
     41  2503		       68		      pla
     42  2504		       a8		      tay
     43  2505		       4c b1 02 	      jmp	NextIL
     44  2508							;
     45  2508							;==========================================================
     46  2508							;Restore the math stack frame
     47  2508		       20 0e 25    iPopMathStack jsr	PopMathStackNow
     48  250b		       4c b1 02 	      jmp	NextIL
     49  250e
     50  250e				   PopMathStackNow
     51  250e		       98		      tya
     52  250f		       48		      pha
     53  2510
     54  2510		       a4 4d		      ldy	GOSUBSTACKPTR
     55  2512		       88		      dey
     56  2513		       b1 4b		      lda	(GOSUBSTACK),y
     57  2515		       c9 05		      cmp	#GOSUB_STACK_FRAME
     58  2517		       d0 09		      bne	iPopMathStackNoFrame
     59  2519		       88		      dey
     60  251a		       88		      dey
     61  251b		       88		      dey
     62  251c		       b1 4b		      lda	(GOSUBSTACK),y
     63  251e		       85 4a		      sta	MATHSTACKPTR
     64  2520		       84 4d		      sty	GOSUBSTACKPTR
     65  2522
     66  2522				   iPopMathStackNoFrame
     67  2522
     68  2522		       68		      pla
     69  2523		       a8		      tay
     70  2524		       60		      rts
     71  2525
     72  2525
     73  2525							;==========================================================
     74  2525							; Push the current math stack information onto the gosub stack
     75  2525				   iSaveMathStack
     76  2525		       98		      tya
     77  2526		       48		      pha
     78  2527
     79  2527		       a4 4d		      ldy	GOSUBSTACKPTR
     80  2529		       a5 4a		      lda	MATHSTACKPTR
     81  252b		       91 4b		      sta	(GOSUBSTACK),y
     82  252d		       a5 48		      lda	MATHSTACK
     83  252f		       c8		      iny
     84  2530
     85  2530		       91 4b		      sta	(GOSUBSTACK),y
     86  2532		       c8		      iny
     87  2533
     88  2533		       a5 49		      lda	MATHSTACK+1
     89  2535		       91 4b		      sta	(GOSUBSTACK),y
     90  2537		       c8		      iny
     91  2538
     92  2538		       a9 06		      lda	#GOSUB_STACK_SAVE
     93  253a		       91 4b		      sta	(GOSUBSTACK),y
     94  253c		       c8		      iny
     95  253d
     96  253d		       84 4d		      sty	GOSUBSTACKPTR
     97  253f
     98  253f		       68		      pla
     99  2540		       a8		      tay
    100  2541		       4c b1 02 	      jmp	NextIL
    101  2544							;
    102  2544							;==========================================================
    103  2544							;Restore the math stack information from the gosub stack
    104  2544				   iRestoreMathStack
    105  2544		       98		      tya
    106  2545		       48		      pha
    107  2546
    108  2546		       a5 4a		      lda	MATHSTACKPTR
    109  2548		       85 58		      sta	R2	; save the current offset for whatever task to R2
    110  254a
    111  254a		       a4 4d		      ldy	GOSUBSTACKPTR
    112  254c		       88		      dey
    113  254d		       b1 4b		      lda	(GOSUBSTACK),y
    114  254f		       c9 06		      cmp	#GOSUB_STACK_SAVE
    115  2551		       d0 16		      bne	iPopMathStack_Err
    116  2553		       88		      dey
    117  2554		       b1 4b		      lda	(GOSUBSTACK),y
    118  2556		       85 49		      sta	MATHSTACK+1
    119  2558		       88		      dey
    120  2559		       b1 4b		      lda	(GOSUBSTACK),y
    121  255b		       85 48		      sta	MATHSTACK
    122  255d		       88		      dey
    123  255e		       b1 4b		      lda	(GOSUBSTACK),y
    124  2560		       85 4a		      sta	MATHSTACKPTR
    125  2562		       84 4d		      sty	GOSUBSTACKPTR
    126  2564
    127  2564		       68		      pla
    128  2565		       a8		      tay
    129  2566		       4c b1 02 	      jmp	NextIL
    130  2569
    131  2569				   iPopMathStack_Err
    132  2569		       68		      pla
    133  256a		       a8		      tay
    134  256b		       a9 00		      lda	#0
    135  256d		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    136  256f		       4c 7d 06 	      jmp	iErr2
    137  2572							;=========================================
    138  2572							; For functions and tasks the variable address of # means
    139  2572							; a passed parameter so #[0] is the first parameter etc
    140  2572							; will try for a better way later
    141  2572							;=====================================================
    142  2572							; On entry il, branch to if function
    143  2572							;	    il+1, value to be returned or not true or false
    144  2572							;
    145  2572							; Return from GOSUB  or function function
    146  2572							; format   RSTR 0   --- return form gosub
    147  2572							;	    RSTR 1   --- return from Function
    148  2572							;
    149  2572		       20 34 2a    iRSTR      jsr	getILByte	; get where to go if 0 = gosub/1=function call
    150  2575		       8d 2a 43 	      sta	offset
    151  2578		       20 17 2c 	      jsr	saveIL	; for later jump if needed add extra entry to	the return stack
    152  257b
    153  257b		       20 70 2c 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    154  257e		       85 54		      sta	R1	; keep the type of call returning from
    155  2580		       b0 2b		      bcs	iRSTRErr	; stack underflow error possible
    156  2582
    157  2582		       20 34 2a 	      jsr	getILByte	; get if a value is being returned
    158  2585
    159  2585		       48		      pha		; save if a value was passed to be returned
    160  2586
    161  2586		       c9 00		      cmp	#0	; yes attemping to return a value
    162  2588		       f0 03		      beq	iRSTRPOP	; no value to return
    163  258a		       20 bf 2c 	      jsr	popR0	; Get the value from the stack save if needed
    164  258d
    165  258d				   iRSTRPOP
    166  258d		       20 0e 25 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    167  2590		       a5 54		      lda	R1	; called as a statement ?
    168  2592		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    169  2594		       f0 13		      beq	iRSTRExit
    170  2596
    171  2596		       68		      pla		; get back if value returned or not
    172  2597		       c9 01		      cmp	#1	; we have a value to return
    173  2599		       f0 05		      beq	iRSTRVALUE
    174  259b
    175  259b		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    176  259d		       4c 12 05 	      jmp	iSAVErr2	; jump to general error reporting function
    177  25a0
    178  25a0				   iRSTRVALUE
    179  25a0		       20 2d 2c 	      jsr	pushR0	; return value back to top of stack
    180  25a3		       20 22 2c 	      jsr	restoreIL	; get the correct il
    181  25a6		       4c e0 0b 	      jmp	tstBranch	; And called as a function
    182  25a9
    183  25a9				   iRSTRExit
    184  25a9		       68		      pla		; throw away gosub/func flag
    185  25aa		       4c b1 02 	      jmp	NextIL
    186  25ad
    187  25ad				   iRSTRNORETURNVALUE
    188  25ad
    189  25ad
    190  25ad		       ad b9 36    iRSTRErr   lda	taskPtr	; Check if this is task zero
    191  25b0		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    192  25b2		       a5 56		      lda	MQ
    193  25b4		       d0 03		      bne	taskRet
    194  25b6		       20 fa 2e 	      jsr	pushFalse	; the result code by default is 0
    195  25b9				   taskRet
    196  25b9		       4c 2d 28 	      jmp	iETask	; not task zero then do a task end instead
    197  25bc				   taskZeroEnd
    198  25bc		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    199  25be		       4c 12 05 	      jmp	iSAVErr2
    200  25c1							;
    201  25c1							;==========================================================================================
    202  25c1							; Find the next gosub function parameter info	position on the stack
    203  25c1							; Returns y = index and c set if found clear c otherwise
    204  25c1		       a4 4d	   GosubFindParms ldy	GOSUBSTACKPTR	;Get the Pointer to the top of stack
    205  25c3		       88		      dey		;Point to stack entry type
    206  25c4
    207  25c4							;Veryify the stack size and position for the call
    208  25c4							;Loops here until it finds a GOSUB with value entry or gosub-rtn entry
    209  25c4
    210  25c4		       c0 00	   GosubFindLoop cpy	#0	;If we reach the top of the stack then no parametrs
    211  25c6		       f0 2d		      beq	GosubNotFunc
    212  25c8		       c0 10		      cpy	#GOSUBSTACKSIZE	;Tst if we are outside the stack size
    213  25ca		       b0 29		      bcs	GosubNotFunc	;Not valid
    214  25cc
    215  25cc							;Look for the	 GOSUB_RTN_VALUE stack position
    216  25cc		       b1 4b		      lda	(GOSUBSTACK),y	;Get the type of call - if it is not a fn call error
    217  25ce		       c9 01		      cmp	#GOSUB_RTN	;if we find this then this function had no parameters
    218  25d0		       f0 0f		      beq	GosubParmFnd	;We can pass parameters to a function that returns nothing
    219  25d2
    220  25d2		       c9 81		      cmp	#GOSUB_RTN_VALUE	;Parameters with the gosub call
    221  25d4		       f0 0b		      beq	GosubParmFnd	;Skip any non Gosub related entries
    222  25d6
    223  25d6		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    224  25d8		       f0 13		      beq	GosubParmSkip	;We have a stackframe good
    225  25da
    226  25da		       88		      dey
    227  25db		       88		      dey
    228  25dc		       88		      dey
    229  25dd		       88		      dey
    230  25de		       4c c4 25 	      jmp	GosubFindLoop
    231  25e1
    232  25e1		       c0 03	   GosubParmFnd cpy	#3	; Check if we are outside the stack
    233  25e3		       90 10		      bcc	GosubNotFunc	; if y < 3 then error not found
    234  25e5		       c0 10		      cpy	#GOSUBSTACKSIZE	; Largest value
    235  25e7		       b0 0c		      bcs	GosubNotFunc	; no parameters passed
    236  25e9
    237  25e9		       88		      dey		; Point to hopefully Math Stack frame information
    238  25ea		       88		      dey
    239  25eb		       88		      dey
    240  25ec		       88		      dey
    241  25ed				   GosubParmSkip
    242  25ed		       b1 4b		      lda	(GOSUBSTACK),y	;This should be a stack frame pointer
    243  25ef		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    244  25f1		       d0 02		      bne	GosubNotFunc	;No parameters passed but expected
    245  25f3		       38		      sec
    246  25f4		       60		      rts
    247  25f5
    248  25f5		       18	   GosubNotFunc clc
    249  25f6		       60		      rts
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  25f7					      include	"tasks.asm"
      1  25f7							;=====================================================
      2  25f7							; Tiny Basic IL task management
      3  25f7							; Data required by task management
      4  25f7							; currently each context is about 30 bytes and is swapped
      5  25f7							; into and out of page zero on each task switch....
      6  25f7							; LOL yes it is slow, but works for this iteration.
      7  25f7							;
      8  25f7
      9  25f7					      Seg	Code
     10  25f7							;=====================================================
     11  25f7							; Sets the pointers to the math,IL and gosub stacks
     12  25f7							; Creates the initial Context for each task slot
     13  25f7				   taskSetStacks
     14  25f7		       a9 b9		      lda	#mathStack&$FF
     15  25f9		       85 48		      sta	MATHSTACK
     16  25fb		       a9 37		      lda	#mathStack>>8
     17  25fd		       85 49		      sta	MATHSTACK+1
     18  25ff
     19  25ff		       a9 49		      lda	#ilStack&$ff
     20  2601		       85 45		      sta	ILSTACK
     21  2603		       a9 39		      lda	#ilStack>>8
     22  2605		       85 46		      sta	ILSTACK+1
     23  2607
     24  2607		       a9 31		      lda	#gosubStack&$FF
     25  2609		       85 4b		      sta	GOSUBSTACK
     26  260b		       a9 3d		      lda	#gosubStack>>8
     27  260d		       85 4c		      sta	GOSUBSTACK+1
     28  260f
     29  260f		       a9 b1		      lda	#variableStack&$FF
     30  2611		       85 41		      sta	VARIABLES
     31  2613		       a9 3f		      lda	#variableStack>>8
     32  2615		       85 42		      sta	VARIABLES+1
     33  2617		       a2 0a		      ldx	#TASKCOUNT
     34  2619		       a0 00		      ldy	#0
     35  261b		       20 eb 28 	      jsr	ContextSave	; Save the Task 0 context
     36  261e
     37  261e		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  2620		       b0 3a		      bcs	taskSetDone
     39  2622
     40  2622		       a5 4b		      lda	GOSUBSTACK
     41  2624		       18		      clc
     42  2625		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  2627		       85 4b		      sta	GOSUBSTACK
     44  2629		       a5 4c		      lda	GOSUBSTACK+1
     45  262b		       69 00		      adc	#0
     46  262d		       85 4c		      sta	GOSUBSTACK+1
     47  262f
     48  262f		       a5 45		      lda	ILSTACK	; must be less than 256
     49  2631		       18		      clc
     50  2632		       69 64		      adc	#ILSTACKSIZE*2
     51  2634		       85 45		      sta	ILSTACK
     52  2636		       a5 46		      lda	ILSTACK+1
     53  2638		       69 00		      adc	#0
     54  263a		       85 46		      sta	ILSTACK+1
     55  263c
     56  263c		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  263e		       18		      clc
     58  263f		       69 28		      adc	#MATHSTACKSIZE*2
     59  2641		       85 48		      sta	MATHSTACK
     60  2643		       a5 49		      lda	MATHSTACK+1
     61  2645		       69 00		      adc	#0
     62  2647		       85 49		      sta	MATHSTACK+1
     63  2649
     64  2649		       a5 41		      lda	VARIABLES	; must be less than 256
     65  264b		       18		      clc
     66  264c		       69 4a		      adc	#VARIABLESSIZE*2
     67  264e		       85 41		      sta	VARIABLES
     68  2650		       a5 42		      lda	VARIABLES+1
     69  2652		       69 00		      adc	#0
     70  2654		       85 42		      sta	VARIABLES+1
     71  2656		       20 eb 28 	      jsr	ContextSave
     72  2659		       4c 1e 26 	      jmp	taskSetLoop
     73  265c
     74  265c				   taskSetDone
     75  265c		       a0 00		      ldy	#0	; reload the main loop context
     76  265e		       20 fa 28 	      jsr	ContextLoad
     77  2661		       60		      rts
     78  2662							;
     79  2662							;============================================================
     80  2662							; Saves the io block to the context
     81  2662
     82  2662
     83  2662		       98	   SaveIOblock tya
     84  2663		       48		      pha
     85  2664		       8a		      txa
     86  2665		       48		      pha
     87  2666
     88  2666
     89  2666
     90  2666		       68		      pla
     91  2667		       aa		      tax
     92  2668		       68		      pla
     93  2669		       a8		      tay
     94  266a		       60		      rts
     95  266b
     96  266b							;
     97  266b							;=====================================================
     98  266b							; In some error cases the math stacks may be left pointing to the wrong stack
     99  266b							; This function will reset those stack addresses but not the actual pointer
    100  266b				   taskResetStacks
    101  266b		       a0 00		      ldy	#0
    102  266d		       20 fa 28 	      jsr	ContextLoad
    103  2670		       4c f7 25 	      jmp	taskSetStacks
    104  2673							;
    105  2673							;=====================================================
    106  2673							; Clear all task entries and task stacks
    107  2673		       98	   taskReset  tya		; Save Y
    108  2674		       48		      pha
    109  2675		       a9 01		      lda	#1
    110  2677		       8d b8 37 	      sta	taskCounter	; Set number of active tasks to 1
    111  267a		       ac b9 36 	      ldy	taskPtr	; Set the active task to 0 MAIN
    112  267d		       c0 00		      cpy	#0	; check if we are the main context
    113  267f		       f0 08		      beq	taskResetCont	; if we are just continue
    114  2681
    115  2681		       a0 00		      ldy	#0	; else we need to switch to the main context
    116  2683		       8c b9 36 	      sty	taskPtr
    117  2686		       20 fa 28 	      jsr	ContextLoad	; load the System Task context
    118  2689				   taskResetCont
    119  2689		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    120  268b
    121  268b				   taskResetLoop
    122  268b		       a9 00		      lda	#TASKINACTIVE
    123  268d		       99 ba 36 	      sta	taskTable,y	; Ensure that the task is made inactive
    124  2690		       18		      clc
    125  2691		       98		      tya
    126  2692		       69 19		      adc	#CONTEXTLEN
    127  2694		       a8		      tay
    128  2695		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    129  2697		       90 f2		      bcc	taskResetLoop	; Go for more
    130  2699
    131  2699				   taskResetComplete
    132  2699
    133  2699		       68		      pla		; Restore y
    134  269a		       a8		      tay
    135  269b		       60		      rts
    136  269c
    137  269c							;
    138  269c							;======================================================
    139  269c							; iTaskSwitch	 switch to new task if not interrupt and
    140  269c							;		 count is exceded for task time slice gets here
    141  269c							;		 when time slice has reached zero
    142  269c							;
    143  269c		       98	   iTaskSwitch tya
    144  269d		       48		      pha
    145  269e
    146  269e		       ad b6 37 	      lda	taskResetValue	; Always reset the counter value
    147  26a1		       8d b4 37 	      sta	taskCurrentCycles	; Update the counter with the new value
    148  26a4		       ce b5 37 	      dec	taskCurrentCycles+1	; dec high order byte
    149  26a7		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    150  26a9
    151  26a9		       ad b7 37 	      lda	taskResetValue+1
    152  26ac		       8d b5 37 	      sta	taskCurrentCycles+1
    153  26af
    154  26af		       ad c1 19 	      lda	IRQPending	; Skip this if we are processing an irq
    155  26b2		       0d 2c 43 	      ora	taskIOPending	; If set then don't switch
    156  26b5		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    157  26b7
    158  26b7		       ad b8 37    iTaskMain  lda	taskCounter	; Number of tasks
    159  26ba		       c9 01		      cmp	#1	; if there is only one task must be main
    160  26bc		       d0 07		      bne	itasknext	; if it some other number continue to next
    161  26be
    162  26be		       ac b9 36 	      ldy	taskPtr	; check if we have not just ended some other task
    163  26c1		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    164  26c3		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    165  26c5							;
    166  26c5							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    167  26c5							;
    168  26c5				   itasknext
    169  26c5		       ac b9 36 	      ldy	taskPtr
    170  26c8		       20 eb 28 	      jsr	ContextSave	; Save the current context, y points to next context
    171  26cb				   itaskLoop
    172  26cb		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    173  26cd		       90 04		      bcc	iTaskNextChk
    174  26cf
    175  26cf		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    176  26d1		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    177  26d3
    178  26d3				   iTaskNextChk
    179  26d3		       b9 ba 36 	      lda	taskTable,y	; there is always at least one entry in table
    180  26d6		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    181  26d8		       18	   iTaskNext  clc
    182  26d9		       98		      tya
    183  26da		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    184  26dc		       a8		      tay
    185  26dd		       4c cb 26 	      jmp	itaskLoop	; Check for busy entry
    186  26e0
    187  26e0		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    188  26e2		       59 ba 36 	      eor	taskTable,y	; Check for anything waiting io
    189  26e5		       d0 f1		      bne	iTaskNext
    190  26e7		       20 fa 28 	      jsr	ContextLoad	; load the next context
    191  26ea		       8c b9 36 	      sty	taskPtr	; update the task pointer
    192  26ed
    193  26ed				   iTaskSwitchDone
    194  26ed		       68		      pla
    195  26ee		       a8		      tay
    196  26ef		       60		      rts
    197  26f0							;
    198  26f0							;================================================================
    199  26f0							; Task Set task number to line number to start
    200  26f0							; on entry stack contains, type of line description and  memvector or linenumber
    201  26f0							; Task Table structure:
    202  26f0							;    byte 0	-   Active inactive
    203  26f0							;    byte 1-2	-   Basic code line pointer
    204  26f0							;    byte 3	-   Offset on current line
    205  26f0		       98	   iTaskSet   tya		;preserve Y
    206  26f1		       48		      pha		; push a
    207  26f2		       20 d7 2c 	      jsr	popR1	; Get if compiled or line number expression
    208  26f5		       20 bf 2c 	      jsr	popR0	; Get the line number to be saved
    209  26f8
    210  26f8
    211  26f8
    212  26f8		       ac b9 36 	      ldy	taskPtr	; find out where we are
    213  26fb		       20 eb 28 	      jsr	ContextSave	; Save the current context
    214  26fe
    215  26fe							;Find the pointer to the line we need to start at
    216  26fe		       a5 54		      lda	R1
    217  2700		       f0 0b		      beq	iTaskLineNum
    218  2702		       a5 52		      lda	R0
    219  2704		       85 4f		      sta	CURPTR
    220  2706		       a5 53		      lda	R0+1
    221  2708		       85 50		      sta	CURPTR+1
    222  270a		       4c 1d 27 	      jmp	iTaskCont
    223  270d
    224  270d				   iTaskLineNum
    225  270d		       20 79 2a 	      jsr	findLine	; Get the offset of the line to start task at
    226  2710		       f0 0b		      beq	iTaskCont
    227  2712
    228  2712		       ac b9 36 	      ldy	taskPtr	; Restore the original Context Error Exit
    229  2715		       20 fa 28 	      jsr	ContextLoad
    230  2718
    231  2718		       68		      pla		; pop a - exit
    232  2719		       a8		      tay
    233  271a		       4c f3 0d 	      jmp	iSetIrqErr	; Bad line number provided
    234  271d
    235  271d				   iTaskCont
    236  271d		       20 bd 28 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    237  2720		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    238  2722
    239  2722		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    240  2724		       99 ba 36 	      sta	taskTable,y	; new task as active
    241  2727
    242  2727		       a5 4f		      lda	CURPTR
    243  2729		       48		      pha		; push a
    244  272a		       a5 50		      lda	CURPTR+1
    245  272c		       48		      pha		; push a
    246  272d
    247  272d		       20 fa 28 	      jsr	ContextLoad	; load the context of the new task
    248  2730
    249  2730		       68		      pla		; pop a
    250  2731		       85 50		      sta	CURPTR+1
    251  2733		       68		      pla		; pop a
    252  2734		       85 4f		      sta	CURPTR
    253  2736		       a9 03		      lda	#3	; Offset to first instruction
    254  2738		       85 51		      sta	CUROFF
    255  273a
    256  273a		       a9 00		      lda	#0
    257  273c		       85 47		      sta	ILSTACKPTR
    258  273e		       85 4a		      sta	MATHSTACKPTR
    259  2740		       85 4d		      sta	GOSUBSTACKPTR
    260  2742		       a9 40		      lda	#GOSUBSTACKSIZE*4
    261  2744		       85 4e		      sta	MESSAGEPTR
    262  2746
    263  2746		       20 75 09 	      jsr	subVINIT	; Clear the variables
    264  2749
    265  2749		       a9 0a		      lda	#STMT&$FF
    266  274b		       85 43		      sta	ILPC
    267  274d		       a9 32		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    268  274f		       85 44		      sta	ILPC+1
    269  2751
    270  2751		       98		      tya		; Save the new context offset to return to user
    271  2752		       48		      pha		; push a
    272  2753
    273  2753		       20 eb 28    itaskSetSave jsr	ContextSave	; save the updated context
    274  2756		       ee b8 37 	      inc	taskCounter	; Update the number of Tasks running
    275  2759
    276  2759		       ac b9 36 	      ldy	taskPtr
    277  275c		       20 fa 28 	      jsr	ContextLoad	; restore the original context
    278  275f
    279  275f		       a9 00		      lda	#0	; Set the R0 upper to zero
    280  2761		       85 53		      sta	R0+1
    281  2763		       68		      pla		; Get the task pid we stored				 ; pop a
    282  2764		       85 52		      sta	R0	; Get the table entry value
    283  2766
    284  2766		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    285  2767		       a8		      tay
    286  2768
    287  2768		       4c 1d 07 	      jmp	pushR0nextIl	; Push R0 and continue
    288  276b				   iTaskNoEmpty
    289  276b		       ac b9 36 	      ldy	taskPtr
    290  276e		       20 fa 28 	      jsr	ContextLoad
    291  2771
    292  2771		       68		      pla		; pop a    -- exit
    293  2772		       a8		      tay
    294  2773
    295  2773		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    296  2775		       a9 00		      lda	#0
    297  2777		       4c 7d 06 	      jmp	iErr2
    298  277a							;
    299  277a							;===============================================================
    300  277a							; Run the task whos PID is on the stack, preserve the stack
    301  277a							;
    302  277a				   iTaskEnable
    303  277a		       98		      tya
    304  277b		       48		      pha
    305  277c		       20 d7 2c 	      jsr	popR1
    306  277f		       20 a5 2c 	      jsr	pushR1
    307  2782		       20 f1 29 	      jsr	ipc_getcontext	; get context pointer into mq
    308  2785		       a0 00		      ldy	#0
    309  2787		       b1 56		      lda	(MQ),y
    310  2789		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    311  278b		       09 80		      ora	#TASKACTIVE
    312  278d		       91 56		      sta	(MQ),y
    313  278f		       68		      pla
    314  2790		       a8		      tay
    315  2791		       4c b1 02 	      jmp	NextIL
    316  2794
    317  2794							;
    318  2794							;===============================================================
    319  2794							; Suspend the task whos PID  is on the stack, preserve the stack
    320  2794							;
    321  2794				   iTaskSuspend
    322  2794		       98		      tya
    323  2795		       48		      pha
    324  2796		       20 d7 2c 	      jsr	popR1
    325  2799		       20 a5 2c 	      jsr	pushR1
    326  279c		       20 f1 29 	      jsr	ipc_getcontext	; get context pointer into mq
    327  279f		       a0 00		      ldy	#0
    328  27a1		       b1 56		      lda	(MQ),y
    329  27a3		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    330  27a5		       09 80		      ora	#TASKACTIVE
    331  27a7		       68		      pla
    332  27a8		       a8		      tay
    333  27a9		       4c b1 02 	      jmp	NextIL
    334  27ac
    335  27ac							;================================================================
    336  27ac							; Returns task Status
    337  27ac				   iTaskStat
    338  27ac		       98		      tya
    339  27ad		       48		      pha
    340  27ae		       20 c0 27 	      jsr	iTaskValid	; returns pointer to task entry
    341  27b1		       b9 ba 36 	      lda	taskTable,y
    342  27b4		       f0 05		      beq	iTaskStatExit
    343  27b6		       68		      pla
    344  27b7		       a8		      tay
    345  27b8		       4c 83 0d 	      jmp	iTruth
    346  27bb				   iTaskStatExit
    347  27bb		       68		      pla
    348  27bc		       a8		      tay
    349  27bd		       4c 8c 0d 	      jmp	iFalse
    350  27c0
    351  27c0							;
    352  27c0							;================================================================
    353  27c0							; Validate the task number on top of the stack
    354  27c0							; on exit y points to the requested task entry
    355  27c0							;
    356  27c0		       20 bf 2c    iTaskValid jsr	popR0	; get result of the multiply
    357  27c3		       a5 53		      lda	R0+1
    358  27c5		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    359  27c7		       a5 52		      lda	R0
    360  27c9		       c9 fa		      cmp	#TASKTABLELEN
    361  27cb		       90 09		      bcc	iTaskIsValid
    362  27cd
    363  27cd		       68	   iTaskValidErr pla		;remove return address
    364  27ce		       68		      pla
    365  27cf		       a2 10		      ldx	#ERR_INVALID_PID
    366  27d1		       a9 00		      lda	#0
    367  27d3		       4c 7d 06 	      jmp	iErr2
    368  27d6
    369  27d6		       a8	   iTaskIsValid tay
    370  27d7		       60		      rts
    371  27d8							;
    372  27d8							;================================================================
    373  27d8							; Kill a running task, do nothing if already stopped
    374  27d8		       20 c0 27    iTaskKill  jsr	iTaskValid
    375  27db		       a9 00		      lda	#0
    376  27dd		       99 ba 36 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    377  27e0							;
    378  27e0							;================================================================
    379  27e0							;Skip to next task
    380  27e0				   iNTask
    381  27e0		       a9 01		      lda	#1
    382  27e2		       8d b4 37 	      sta	taskCurrentCycles
    383  27e5		       8d b5 37 	      sta	taskCurrentCycles+1
    384  27e8		       4c b1 02 	      jmp	NextIL
    385  27eb							;
    386  27eb							;=======================================================
    387  27eb							; Wait for a task to complete
    388  27eb				   iWTASK
    389  27eb		       20 34 2a 	      jsr	getILByte
    390  27ee		       8d 2a 43 	      sta	offset
    391  27f1							;
    392  27f1		       20 17 2c 	      jsr	saveIL	;in case of failure
    393  27f4
    394  27f4		       20 c0 27 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    395  27f7		       b9 ba 36 	      lda	taskTable,y
    396  27fa		       d0 03		      bne	iWTASKWAIT
    397  27fc				   iWTASKEXITED
    398  27fc		       4c b1 02 	      jmp	NextIL
    399  27ff				   iWTASKWAIT
    400  27ff		       20 2d 2c 	      jsr	pushR0	; Push R0 back onto the stack
    401  2802		       a9 01		      lda	#1
    402  2804		       8d b4 37 	      sta	taskCurrentCycles	; Give up the cycles
    403  2807		       8d b5 37 	      sta	taskCurrentCycles+1
    404  280a		       20 22 2c 	      jsr	restoreIL
    405  280d		       4c e0 0b 	      jmp	tstBranch
    406  2810							;
    407  2810							;=======================================================
    408  2810							; Set task io lock
    409  2810		       ee 2c 43    iStartIO   inc	taskIOPending
    410  2813		       4c b1 02 	      jmp	NextIL
    411  2816							;
    412  2816							;=======================================================
    413  2816							; Release the io lock
    414  2816		       ad 2c 43    iEndIO     lda	taskIOPending
    415  2819		       f0 03		      beq	iEndIOExit
    416  281b		       ce 2c 43 	      dec	taskIOPending
    417  281e		       4c b1 02    iEndIOExit jmp	NextIL
    418  2821							;
    419  2821							;===============================================================
    420  2821							; Return the task PID
    421  2821				   iTASKPID
    422  2821		       a9 00		      lda	#0
    423  2823		       85 53		      sta	R0+1
    424  2825		       ad b9 36 	      lda	taskPtr
    425  2828		       85 52		      sta	R0
    426  282a		       4c 1d 07 	      jmp	pushR0nextIl
    427  282d							;
    428  282d							;================================================================
    429  282d							; Terminate a task
    430  282d		       ac b9 36    iETask     ldy	taskPtr
    431  2830		       c0 00		      cpy	#0
    432  2832		       d0 03		      bne	iETaskCont
    433  2834		       4c 02 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    434  2837				   iETaskCont
    435  2837		       a9 00		      lda	#TASKINACTIVE
    436  2839		       99 ba 36 	      sta	taskTable,y	; mark entry as free
    437  283c		       ce b8 37 	      dec	taskCounter	; reduce the number of active tasks
    438  283f		       a9 01		      lda	#1
    439  2841		       8d b4 37 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    440  2844		       8d b5 37 	      sta	taskCurrentCycles+1
    441  2847		       20 d8 28 	      jsr	TaskSetExitCode
    442  284a				   iETaskExit
    443  284a		       4c b1 02 	      jmp	NextIL
    444  284d							;================================================================
    445  284d							; make the current tasks math stack equal another tasks stack
    446  284d							; The task to get is stored on the math stack
    447  284d
    448  284d				   iTaskGetMathStack
    449  284d		       20 fe 2e 	      jsr	CopyStackR1	; Get the top of stack to R1
    450  2850		       20 f1 29 	      jsr	ipc_getcontext	; MQ now has the context address
    451  2853		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  2855		       b1 56		      lda	(MQ),y
    453  2857		       85 4a		      sta	MATHSTACKPTR
    454  2859		       a0 08		      ldy	#MATHSTACKPOS
    455  285b		       b1 56		      lda	(MQ),y
    456  285d		       85 48		      sta	MATHSTACK
    457  285f		       c8		      iny
    458  2860		       b1 56		      lda	(MQ),y
    459  2862		       85 49		      sta	MATHSTACK+1
    460  2864		       4c b1 02 	      jmp	NextIL
    461  2867							;==================================================================
    462  2867							; Updates the tasks math stack pointer with contents of R2
    463  2867							; PID is on top of the stack
    464  2867				   iTaskPutMathPtr
    465  2867		       20 fe 2e 	      jsr	CopyStackR1	; Get the top of stack to R1
    466  286a		       20 f1 29 	      jsr	ipc_getcontext	; MQ now has the context address
    467  286d		       a5 58		      lda	R2	; R2 contains the number of parameters/offset
    468  286f		       a0 0a		      ldy	#MATHSTACKPTRPOS	; Pointer to new tasks stack pointer
    469  2871		       91 56		      sta	(MQ),y	; update it to point to the free space on stack
    470  2873							;if parm count > 0 then we need to create a parameter block on the tasks gosubStack
    471  2873		       c9 00		      cmp	#0	; if no parameters then
    472  2875		       f0 26		      beq	iTaskPutMathPtrExit	; just get out of here
    473  2877
    474  2877		       a0 0b		      ldy	#GOSUBSTKPOS
    475  2879		       b1 56		      lda	(MQ),y	; get the address of the new tasks gosub stack into R1
    476  287b		       85 54		      sta	R1
    477  287d		       c8		      iny
    478  287e		       b1 56		      lda	(MQ),y
    479  2880		       85 55		      sta	R1+1
    480  2882
    481  2882		       a9 00		      lda	#0	; Store the math stack offset into new gosub stack, always 0
    482  2884		       91 54		      sta	(R1),y
    483  2886
    484  2886		       c8		      iny
    485  2887		       18		      clc		; We need to turn stack ptr to actual parm count
    486  2888		       e9 01		      sbc	#1	; Stack pointer always point to next free byte
    487  288a		       0a		      asl
    488  288b		       91 54		      sta	(R1),y
    489  288d
    490  288d		       c8		      iny
    491  288e		       a9 ff		      lda	#$FF	; Dummy field, not used
    492  2890		       91 54		      sta	(R1),y
    493  2892		       c8		      iny
    494  2893		       a9 05		      lda	#GOSUB_STACK_FRAME	; Tell its a stck frame, ie identify param cnt etc
    495  2895		       91 54		      sta	(R1),y
    496  2897		       c8		      iny
    497  2898		       98		      tya
    498  2899		       a0 0d		      ldy	#GOSUBPTRPOS
    499  289b		       91 56		      sta	(MQ),y	; update the new tasks gosub stk pointer
    500  289d
    501  289d				   iTaskPutMathPtrExit
    502  289d		       4c b1 02 	      jmp	NextIL
    503  28a0							;
    504  28a0							;================================================================
    505  28a0							; Set the time slice for each task
    506  28a0				   iSLICE
    507  28a0		       20 bf 2c 	      jsr	popR0
    508  28a3		       a5 52		      lda	R0
    509  28a5		       8d b6 37 	      sta	taskResetValue
    510  28a8		       a5 53		      lda	R0+1
    511  28aa		       8d b7 37 	      sta	taskResetValue+1
    512  28ad		       d0 0b		      bne	iSliceSet
    513  28af		       ee b7 37 	      inc	taskResetValue+1	; must be at least 1 high counter
    514  28b2		       a9 01		      lda	#1
    515  28b4		       8d b4 37 	      sta	taskCurrentCycles
    516  28b7		       8d b5 37 	      sta	taskCurrentCycles+1
    517  28ba				   iSliceSet
    518  28ba		       4c b1 02 	      jmp	NextIL
    519  28bd							;================================================================
    520  28bd							; Find an empty slot in the taskTable
    521  28bd							; Return the index in y
    522  28bd							; on exit   c set if an empty slot is found
    523  28bd							;	     c clear if not found
    524  28bd							;================================================================
    525  28bd							;
    526  28bd		       ad b8 37    TaskEmpty  lda	taskCounter
    527  28c0		       c9 0a		      cmp	#TASKCOUNT
    528  28c2		       b0 10		      bcs	TaskNoSlot
    529  28c4		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    530  28c6				   TaskLoop
    531  28c6		       b9 ba 36 	      lda	taskTable,y
    532  28c9		       f0 0b		      beq	TaskEmptyFnd
    533  28cb		       98		      tya
    534  28cc		       18		      clc
    535  28cd		       69 19		      adc	#CONTEXTLEN
    536  28cf		       a8		      tay
    537  28d0		       c0 fa		      cpy	#TASKTABLELEN
    538  28d2		       90 f2		      bcc	TaskLoop	; Y is never zero
    539  28d4				   TaskNoSlot
    540  28d4		       18		      clc
    541  28d5		       60		      rts
    542  28d6				   TaskEmptyFnd
    543  28d6		       38		      sec
    544  28d7		       60		      rts
    545  28d8							;====================================================
    546  28d8							; Set the task exit code called from the return command
    547  28d8							; on entry stack top hold exit value
    548  28d8				   TaskSetExitCode
    549  28d8		       98		      tya
    550  28d9		       48		      pha
    551  28da		       20 bf 2c 	      jsr	popR0
    552  28dd		       a0 48		      ldy	#TASKEXITCODE
    553  28df		       a5 52		      lda	R0
    554  28e1		       91 41		      sta	(VARIABLES),y
    555  28e3		       c8		      iny
    556  28e4		       a5 53		      lda	R0+1
    557  28e6		       91 41		      sta	(VARIABLES),y
    558  28e8		       68		      pla
    559  28e9		       98		      tya
    560  28ea		       60		      rts
    561  28eb
    562  28eb							;
    563  28eb							;=====================================================
    564  28eb							; Save Context Store the context to the TASK Table
    565  28eb							; on entry y contains the task table entry to save to
    566  28eb							; on exit y points to next task table entry
    567  28eb							;	   x contains the number of bytes copied
    568  28eb		       a2 00	   ContextSave ldx	#0
    569  28ed		       c8		      iny		;inc past the task flags
    570  28ee		       b5 41	   ContextSvLoop lda	CONTEXT,x
    571  28f0		       99 ba 36 	      sta	taskTable,y
    572  28f3		       c8		      iny
    573  28f4		       e8		      inx
    574  28f5		       e0 18		      cpx	#[CONTEXTLEN-1]
    575  28f7		       90 f5		      bcc	ContextSvLoop
    576  28f9		       60		      rts
    577  28fa							;
    578  28fa							; Load Context transfer context from task table to the Current Context
    579  28fa							; on entry y contains the task table entry to transfer
    580  28fa							; on exit y points to the original task table entry
    581  28fa							;	   x contains the number of bytes copied
    582  28fa		       98	   ContextLoad tya
    583  28fb		       48		      pha
    584  28fc		       a2 00		      ldx	#0
    585  28fe		       c8		      iny		;inc past the task flags
    586  28ff		       b9 ba 36    ContextLDLoop lda	taskTable,y
    587  2902		       95 41		      sta	CONTEXT,x
    588  2904		       c8		      iny
    589  2905		       e8		      inx
    590  2906		       e0 18		      cpx	#[CONTEXTLEN-1]
    591  2908		       90 f5		      bcc	ContextLDLoop
    592  290a		       68		      pla
    593  290b		       a8		      tay
    594  290c		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  290d					      include	"ipc.asm"
      1  290d							;======================================================
      2  290d							; Inter process communications.
      3  290d							; Tasks may write/read integer messages among
      4  290d							; them selves.
      5  290d							; This uses each tasks gosub stack as a message queue
      6  290d							; Gosub calls start at the highest address and the
      7  290d							; msg queue starts at the highest address.
      8  290d							;
      9  290d							;======================================================
     10  290d							; ipcs   - Send msg to another task or many tasks
     11  290d							; on entry  math stack contains the  top PID
     12  290d							;				      2ND Message value
     13  290d							; on exit   math stack contain top True-good or False-failed
     14  290d							;
     15  290d							; it may not be sent if queue is full
     16  290d							;
     17  290d							; a = ipcs(<message-expression>,<task PID-expression>)
     18  290d							;
     19  290d				   iIPCS
     20  290d		       98		      tya
     21  290e		       48		      pha
     22  290f		       20 76 29 	      jsr	ipc_enqueue
     23  2912		       b0 08		      bcs	iIPC_BAD
     24  2914		       20 f0 2e 	      jsr	pushTrue
     25  2917		       68		      pla
     26  2918		       a8		      tay
     27  2919		       4c b1 02 	      jmp	NextIL
     28  291c				   iIPC_BAD
     29  291c		       68		      pla
     30  291d		       a8		      tay
     31  291e		       20 fa 2e 	      jsr	pushFalse
     32  2921		       4c b1 02 	      jmp	NextIL
     33  2924
     34  2924							;======================================================
     35  2924							; ipcr   - Recieve msg from task
     36  2924							; on exit  the message value is returned from message queue
     37  2924							;	    message -1	is reserved meaning no entry found
     38  2924							; The provided variable contains the pid of the sending
     39  2924							; task. This is optional. This always waits for a message
     40  2924							; before returning.
     41  2924							;
     42  2924							; a = ipcr(<variable name>)
     43  2924							;
     44  2924				   iIPCR
     45  2924		       98		      tya
     46  2925		       48		      pha
     47  2926		       20 b8 29 	      jsr	ipc_dequeue
     48  2929		       b0 05		      bcs	iIPCR_Q_Empty
     49  292b		       68		      pla
     50  292c		       a8		      tay
     51  292d		       4c b1 02 	      jmp	NextIL
     52  2930				   iIPCR_Q_Empty
     53  2930		       68		      pla
     54  2931		       a8		      tay
     55  2932		       20 f0 2e 	      jsr	pushTrue	; puts -1 on the stack
     56  2935		       4c b1 02 	      jmp	NextIL
     57  2938
     58  2938							;=======================================================
     59  2938							; ipcc   - Check if message available
     60  2938							; on exit  Stack contains number of messages
     61  2938							;
     62  2938							; a = ipcc()
     63  2938							;
     64  2938				   iIPCC
     65  2938		       98		      tya
     66  2939		       48		      pha
     67  293a		       20 63 29 	      jsr	ipc_queue_count
     68  293d		       20 2d 2c 	      jsr	pushR0	; return the count
     69  2940		       68		      pla
     70  2941		       a8		      tay
     71  2942		       4c b1 02 	      jmp	NextIL
     72  2945
     73  2945							;=======================================================
     74  2945							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  2945				   iIPCIO
     76  2945		       98		      tya
     77  2946		       48		      pha
     78  2947		       20 63 29 	      jsr	ipc_queue_count
     79  294a		       a5 52		      lda	R0
     80  294c		       d0 10		      bne	iIPCIO_No_Halt
     81  294e		       a9 01		      lda	#1
     82  2950		       8d b4 37 	      sta	taskCurrentCycles	; force a task switch
     83  2953		       a9 01		      lda	#TASKWAITIPC
     84  2955		       ac b9 36 	      ldy	taskPtr
     85  2958		       19 ba 36 	      ora	taskTable,y
     86  295b		       99 ba 36 	      sta	taskTable,y
     87  295e
     88  295e				   iIPCIO_No_Halt
     89  295e		       68		      pla
     90  295f		       a8		      tay
     91  2960		       4c b1 02 	      jmp	NextIL
     92  2963							;======================================================
     93  2963							;ipc_queue_count
     94  2963				   ipc_queue_count
     95  2963		       a5 4e		      lda	MESSAGEPTR
     96  2965		       18		      clc
     97  2966		       4a		      lsr		; divide by 4
     98  2967		       4a		      lsr
     99  2968		       85 52		      sta	R0	; store into R0
    100  296a		       a9 10		      lda	#GOSUBSTACKSIZE
    101  296c		       38		      sec
    102  296d		       e5 52		      sbc	R0	; Get how many entries on queue
    103  296f		       85 52		      sta	R0
    104  2971		       a9 00		      lda	#0
    105  2973		       85 53		      sta	R0+1
    106  2975		       60		      rts
    107  2976							;=======================================================
    108  2976							; Support functions for messaging
    109  2976							;
    110  2976							; Enqueue message -> onto PID's MSG Q
    111  2976							; on entry top of stack contains the PID
    112  2976							;	    second contains the Message of the task
    113  2976							; on exit contains c set if failed
    114  2976							;		    c cleared if success
    115  2976							;		    PID's MSG Q PTR points to the message
    116  2976							;
    117  2976				   ipc_enqueue
    118  2976		       20 d7 2c 	      jsr	popR1	; Get the pid
    119  2979		       20 f1 29 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    120  297c
    121  297c		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    122  297e		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    123  2980		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    124  2982		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    125  2984		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    126  2986
    127  2986
    128  2986							; Get the PID'S stack address into R0
    129  2986		       a0 0b		      ldy	#GOSUBSTKPOS
    130  2988		       b1 56		      lda	(MQ),y
    131  298a		       85 52		      sta	R0
    132  298c		       c8		      iny
    133  298d		       b1 56		      lda	(MQ),y
    134  298f		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    135  2991
    136  2991							; Set y to point to the msg q entry
    137  2991		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    138  2993		       b1 56		      lda	(MQ),y	; Get the index
    139  2995		       a8		      tay		; Set y to queue offset
    140  2996
    141  2996							; enqueue the message
    142  2996		       88		      dey		; First byte to save to
    143  2997		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    144  2999		       91 52		      sta	(R0),y	; Set the entry type
    145  299b
    146  299b		       88		      dey
    147  299c		       ad b9 36 	      lda	taskPtr	; Store the PID into queue
    148  299f		       91 52		      sta	(R0),y
    149  29a1		       20 d7 2c 	      jsr	popR1	; Get the actual message value
    150  29a4		       20 25 2a 	      jsr	ipc_pushR1	; Store Message value into queue
    151  29a7
    152  29a7		       98		      tya		; Save the new q ptr
    153  29a8		       a0 0e		      ldy	#MSGPTRPOS
    154  29aa		       91 56		      sta	(MQ),y	; Update the message stack pointer
    155  29ac		       a0 00		      ldy	#0	; points to context root
    156  29ae		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    157  29b0		       51 56		      eor	(MQ),y	; Turn off the bit
    158  29b2		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    159  29b4		       18		      clc
    160  29b5		       60		      rts
    161  29b6				   ipc_enq_full
    162  29b6		       38		      sec
    163  29b7		       60		      rts
    164  29b8							;=============================================================
    165  29b8							; De-queue for message stack -> local tasks msg q
    166  29b8							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    167  29b8							;  message into
    168  29b8							;  on exit   math stack contains value of message
    169  29b8							;				  Variable if provided is pid
    170  29b8				   ipc_dequeue
    171  29b8		       20 ee 2c 	      jsr	popMQ	; Variable address to put PID into
    172  29bb
    173  29bb		       a4 4e		      ldy	MESSAGEPTR
    174  29bd		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    175  29bf		       b0 2e		      bcs	ipc_deq_empty
    176  29c1		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    177  29c3		       85 52		      sta	R0
    178  29c5		       c8		      iny
    179  29c6		       b1 4b		      lda	(GOSUBSTACK),y
    180  29c8		       85 53		      sta	R0+1
    181  29ca		       c8		      iny
    182  29cb		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    183  29cd		       85 54		      sta	R1
    184  29cf		       c8		      iny
    185  29d0		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    186  29d2		       c8		      iny
    187  29d3		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    188  29d5
    189  29d5		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    190  29d7		       d0 16		      bne	ipc_deq_empty
    191  29d9
    192  29d9		       20 2d 2c 	      jsr	pushR0	; place value on stack
    193  29dc
    194  29dc		       a5 56		      lda	MQ
    195  29de		       05 57		      ora	MQ+1
    196  29e0		       f0 0b		      beq	ipc_deq_done
    197  29e2		       a5 54		      lda	R1
    198  29e4		       a0 00		      ldy	#0
    199  29e6		       91 56		      sta	(MQ),y
    200  29e8		       c8		      iny
    201  29e9		       a9 00		      lda	#0
    202  29eb		       91 56		      sta	(MQ),y
    203  29ed				   ipc_deq_done
    204  29ed		       18		      clc
    205  29ee		       60		      rts
    206  29ef
    207  29ef				   ipc_deq_empty
    208  29ef		       38		      sec
    209  29f0		       60		      rts
    210  29f1
    211  29f1							;=============================================
    212  29f1							;  Get the context address into MQ from R1 with
    213  29f1							;  context/index/pid
    214  29f1				   ipc_getcontext
    215  29f1		       18		      clc		; Get pointer to Task context
    216  29f2		       a9 ba		      lda	#taskTable&$FF	; change ptr to address
    217  29f4		       65 54		      adc	R1
    218  29f6		       85 56		      sta	MQ
    219  29f8		       a9 36		      lda	#taskTable>>8
    220  29fa		       65 55		      adc	R1+1
    221  29fc		       85 57		      sta	MQ+1	; We now have a pointer into the context
    222  29fe		       60		      rts
    223  29ff							;
    224  29ff							;==============================================
    225  29ff							; on entry R1 has a context value,
    226  29ff							; on exit c is set if fails
    227  29ff							;
    228  29ff				   ipc_CONTEXTVALUES
      0  29ff					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  29ff		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  2a03					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  2a03		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  2a07					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  2a07		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    232  2a09
    233  2a09				   ipc_ValidateContext
    234  2a09		       48		      pha
    235  2a0a		       8a		      txa
    236  2a0b		       48		      pha
    237  2a0c		       a5 55		      lda	R1+1
    238  2a0e		       d0 0e		      bne	ipc_Validate_Fail
    239  2a10		       a2 00		      ldx	#0
    240  2a12		       a5 54		      lda	R1
    241  2a14				   ipc_ValidateLoop
    242  2a14		       dd ff 29 	      cmp	ipc_CONTEXTVALUES,x
    243  2a17		       f0 09		      beq	ipc_Valid_Context
    244  2a19		       e8		      inx
    245  2a1a		       e0 0a		      cpx	#TASKCOUNT
    246  2a1c		       90 f6		      bcc	ipc_ValidateLoop
    247  2a1e
    248  2a1e				   ipc_Validate_Fail
    249  2a1e		       68		      pla
    250  2a1f		       aa		      tax
    251  2a20		       68		      pla
    252  2a21		       60		      rts
    253  2a22
    254  2a22				   ipc_Valid_Context
    255  2a22		       18		      clc
    256  2a23		       90 f9		      bcc	ipc_Validate_Fail
    257  2a25							;
    258  2a25							;==============================================
    259  2a25							;Push R1 onto the stack
    260  2a25							;on entry y = next entry
    261  2a25							;R0 points to the stack space
    262  2a25							;on exit y points to next free byte
    263  2a25				   ipc_pushR1
    264  2a25		       88		      dey
    265  2a26		       a5 55		      lda	R1+1	; PID first
    266  2a28		       91 52		      sta	(R0),y
    267  2a2a		       88		      dey
    268  2a2b		       a5 54		      lda	R1
    269  2a2d		       91 52		      sta	(R0),y
    270  2a2f		       60		      rts
    271  2a30
    272  2a30
    273  2a30
    274  2a30
    275  2a30
    276  2a30
    277  2a30
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  2a30					      include	"support.asm"
      1  2a30							;
      2  2a30							;=====================================================
      3  2a30							;=====================================================
      4  2a30							;=====================================================
      5  2a30							; This marks the start of support functions used by
      6  2a30							; the IL opcodes.  These are support functions, NOT
      7  2a30							; the IL code.
      8  2a30							;=====================================================
      9  2a30							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  2a30							;=====================================================
     11  2a30					      Seg	Code
     12  2a30							;=====================================================
     13  2a30							; This gets the next two bytes pointed to by ILPC and
     14  2a30							; returns them; X contains LSB, A contains MSB.  ILPC
     15  2a30							; is advanced by two, and Y contains 0 on return.
     16  2a30
     17  2a30							;
     18  2a30		       20 34 2a    getILWord  jsr	getILByte	;LSB
     19  2a33		       aa		      tax
     20  2a34							;
     21  2a34							;=====================================================
     22  2a34							; This gets the next byte pointed to by ILPC and
     23  2a34							; returns it in A.  On return, X is unchanged but Y
     24  2a34							; contains 0.
     25  2a34							;
     26  2a34		       a0 00	   getILByte  ldy	#0
     27  2a36		       b1 43		      lda	(ILPC),y	;get byte
     28  2a38		       08		      php		;save status
     29  2a39		       e6 43		      inc	ILPC	;inc LSB
     30  2a3b		       d0 02		      bne	getILb2	;branch if no overflow
     31  2a3d		       e6 44		      inc	ILPC+1	;inc MSB
     32  2a3f		       28	   getILb2    plp		;restore status
     33  2a40		       60		      rts
     34  2a41							;
     35  2a41							;=====================================================
     36  2a41							; Decrement ILPC by one.
     37  2a41							;
     38  2a41		       a5 43	   decIL      lda	ILPC
     39  2a43		       d0 02		      bne	decIL2
     40  2a45		       c6 44		      dec	ILPC+1
     41  2a47		       c6 43	   decIL2     dec	ILPC
     42  2a49		       60		      rts
     43  2a4a							;
     44  2a4a							;=====================================================
     45  2a4a							; Push the ILPC onto the return stack.  Actually, this
     46  2a4a							; pushes the address of ILPC+2 since that's the next
     47  2a4a							; address to execute.
     48  2a4a							;
     49  2a4a		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  2a4c		       c0 64		      cpy	#ILSTACKSIZE<<1
     51  2a4e		       b0 15		      bcs	pushErr
     52  2a50		       a5 43		      lda	ILPC
     53  2a52		       18		      clc
     54  2a53		       69 02		      adc	#2
     55  2a55		       91 45		      sta	(ILSTACK),y
     56  2a57		       08		      php		;save C bit
     57  2a58		       c8		      iny
     58  2a59		       a5 44		      lda	ILPC+1
     59  2a5b		       28		      plp		;restore C
     60  2a5c		       69 00		      adc	#0
     61  2a5e		       91 45		      sta	(ILSTACK),y
     62  2a60		       c8		      iny
     63  2a61		       84 47		      sty	ILSTACKPTR
     64  2a63		       18		      clc
     65  2a64		       60		      rts
     66  2a65				   pushErr
     67  2a65		       38		      sec
     68  2a66		       60		      rts
     69  2a67							;
     70  2a67							;=====================================================
     71  2a67							; Pull the top entry from return stack and put into
     72  2a67							; ILPC.
     73  2a67							;
     74  2a67		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  2a69		       f0 fa		      beq	pushErr
     76  2a6b		       88		      dey
     77  2a6c		       b1 45		      lda	(ILSTACK),y
     78  2a6e		       85 44		      sta	ILPC+1
     79  2a70		       88		      dey
     80  2a71		       b1 45		      lda	(ILSTACK),y
     81  2a73		       85 43		      sta	ILPC
     82  2a75		       84 47		      sty	ILSTACKPTR
     83  2a77		       18		      clc
     84  2a78		       60		      rts
     85  2a79							;
     86  2a79							;=====================================================
     87  2a79							; This searches for a specific line number that is in
     88  2a79							; R0.	There are three possible return conditions:
     89  2a79							; Line numbers are now the third byte, the first byte is now
     90  2a79							; a pointer to the next line, of course no longer than 255 byte
     91  2a79							; per line.
     92  2a79							;
     93  2a79							; Exact match was found:
     94  2a79							;    * Z set
     95  2a79							;    * CURPTR points to two-byte line number for that
     96  2a79							;	line.
     97  2a79							;
     98  2a79							; Next highest line found:
     99  2a79							;    * Z cleared
    100  2a79							;    * C set
    101  2a79							;    * CURPTR points to two-byte line number for that
    102  2a79							;	line.
    103  2a79							;
    104  2a79							; End of program reached:
    105  2a79							;    * Z cleared
    106  2a79							;    * C cleared
    107  2a79							;    * CURPTR points to first free byte at end of
    108  2a79							;	program.  Ie, it has save value as PROGRAMEND.
    109  2a79							;
    110  2a79							; A, X, and Y are all undefined on return.
    111  2a79							;
    112  2a79
    113  2a79				   findLine
    114  2a79		       ad 32 43 	      lda	ProgramStart	;Start of program -> CURPTR
    115  2a7c		       85 4f		      sta	CURPTR
    116  2a7e		       ad 33 43 	      lda	ProgramStart+1
    117  2a81		       85 50		      sta	CURPTR+1
    118  2a83							;
    119  2a83							; At end of code?
    120  2a83							;
    121  2a83				   iXFER1
    122  2a83		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  2a85		       cd 34 43 	      cmp	ProgramEnd	; at end of program then stop run
    124  2a88		       d0 0b		      bne	xfer2	; not end
    125  2a8a		       a5 50		      lda	CURPTR+1
    126  2a8c		       cd 35 43 	      cmp	ProgramEnd+1
    127  2a8f		       d0 04		      bne	xfer2	;Not at end
    128  2a91							;
    129  2a91							; Line not found and the end of the program was
    130  2a91							; reached.  Return Z and C both clear.
    131  2a91							;
    132  2a91		       a9 01		      lda	#1	;clear Z
    133  2a93		       18		      clc		;clear C
    134  2a94		       60		      rts
    135  2a95							;
    136  2a95							; Check for an exact line number match
    137  2a95							;
    138  2a95		       a5 52	   xfer2      lda	R0
    139  2a97		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  2a99		       d1 4f		      cmp	(CURPTR),y
    141  2a9b		       d0 08		      bne	xfernotit
    142  2a9d		       c8		      iny
    143  2a9e		       a5 53		      lda	R0+1
    144  2aa0		       d1 4f		      cmp	(CURPTR),y
    145  2aa2		       d0 01		      bne	xfernotit	; not a matching line number
    146  2aa4							;
    147  2aa4							; This is exactly the line we want.
    148  2aa4							;
    149  2aa4		       60		      rts		;it matches exactly
    150  2aa5							;
    151  2aa5							; See if this line is greater than the one we're
    152  2aa5							; searching for.
    153  2aa5							;
    154  2aa5		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  2aa7		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  2aa9		       c5 53		      cmp	R0+1
    157  2aab		       90 0b		      bcc	xfer3
    158  2aad		       d0 07		      bne	xfer4
    159  2aaf		       88		      dey
    160  2ab0		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  2ab2		       c5 52		      cmp	R0
    162  2ab4		       90 02		      bcc	xfer3
    163  2ab6							;
    164  2ab6							; This line is greater than the one we want, so
    165  2ab6							; return Z clear and C set.
    166  2ab6							;
    167  2ab6		       38	   xfer4      sec		;We found a line number greater
    168  2ab7		       60		      rts		;both conditions set
    169  2ab8							;
    170  2ab8							; Not the line (or droid) we're looking for.  Move to
    171  2ab8							; the next line.
    172  2ab8							;
    173  2ab8		       20 be 2a    xfer3      jsr	FindNextLine
    174  2abb		       4c 83 2a 	      jmp	iXFER1
    175  2abe							;
    176  2abe							;=====================================================
    177  2abe							; This advances CURPTR to the next line.  If there
    178  2abe							; are no more lines, this leaves CURPTR equal to
    179  2abe							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  2abe							; CURPTR is pointing to a valid line on entry.  This
    181  2abe							; pointer points to the two-byte line number.
    182  2abe							; Update this points to the 1 byte line length  ****************
    183  2abe							;
    184  2abe				   FindNextLine
    185  2abe		       a0 03		      ldy	#3	;skip line number and length byte
    186  2ac0		       84 51		      sty	CUROFF	;this is the new offset
    187  2ac2		       a0 00		      ldy	#0
    188  2ac4		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  2ac6		       18		      clc
    190  2ac7		       65 4f		      adc	CURPTR
    191  2ac9		       85 4f		      sta	CURPTR
    192  2acb		       a5 50		      lda	CURPTR+1
    193  2acd		       69 00		      adc	#0
    194  2acf		       85 50		      sta	CURPTR+1
    195  2ad1		       60	   FindNext4  rts
    196  2ad2							;
    197  2ad2							;=====================================================
    198  2ad2							; This compares CURPTR to PROGRAMEND and returns Z set
    199  2ad2							; if they are equal, Z clear if not.
    200  2ad2							;
    201  2ad2		       a5 4f	   AtEnd      lda	CURPTR
    202  2ad4		       cd 34 43 	      cmp	ProgramEnd
    203  2ad7		       d0 05		      bne	atendexit
    204  2ad9		       a5 50		      lda	CURPTR+1
    205  2adb		       cd 35 43 	      cmp	ProgramEnd+1
    206  2ade		       60	   atendexit  rts
    207  2adf							;
    208  2adf
    209  2adf							;
    210  2adf							;=====================================================
    211  2adf							; Convert an ASCII string to a number.  On input,
    212  2adf							; (CURPTR),Y points to the first digit.  This gets
    213  2adf							; digit-by-digit until finding a non-number.  Returns
    214  2adf							; Y pointing to the non-digit, and R0 contains the
    215  2adf							; number.  This does NOT check for valid ranges, so
    216  2adf							; a value like "123456789" will produce something,
    217  2adf							; but not what you had expected.
    218  2adf							;
    219  2adf		       a9 00	   getDecimal lda	#0
    220  2ae1		       85 52		      sta	R0
    221  2ae3		       85 53		      sta	R0+1
    222  2ae5		       85 59		      sta	dpl	;temporary negative flag
    223  2ae7							;
    224  2ae7							; See if it's negative...
    225  2ae7							;
    226  2ae7							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  2ae7		       b1 4f		      lda	(CURPTR),y
    228  2ae9		       c9 2d		      cmp	#'-
    229  2aeb		       d0 02		      bne	getDecLoop
    230  2aed		       e6 59		      inc	dpl	;it's negative
    231  2aef							;
    232  2aef		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  2af1		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  2af3		       c9 30		      cmp	#'0
    235  2af5		       90 36		      bcc	getDdone
    236  2af7		       c9 3a		      cmp	#'9+1
    237  2af9		       b0 32		      bcs	getDdone
    238  2afb		       38		      sec
    239  2afc		       e9 30		      sbc	#'0	;convert to binary
    240  2afe		       48		      pha
    241  2aff							;
    242  2aff							; Now multiply R0 by 10.  Remember that
    243  2aff							; 2*N + 8*N = 10*N.
    244  2aff							;
    245  2aff		       06 52		      asl	R0
    246  2b01		       26 53		      rol	R0+1	;*2
    247  2b03		       a5 52		      lda	R0
    248  2b05		       85 54		      sta	R1
    249  2b07		       a5 53		      lda	R0+1
    250  2b09		       85 55		      sta	R1+1
    251  2b0b		       06 52		      asl	R0
    252  2b0d		       26 53		      rol	R0+1	;*4
    253  2b0f		       06 52		      asl	R0
    254  2b11		       26 53		      rol	R0+1	;*8
    255  2b13		       18		      clc		;now add the partial sums...
    256  2b14		       a5 52		      lda	R0	;...to get *10
    257  2b16		       65 54		      adc	R1
    258  2b18		       85 52		      sta	R0
    259  2b1a		       a5 53		      lda	R0+1
    260  2b1c		       65 55		      adc	R1+1
    261  2b1e		       85 53		      sta	R0+1
    262  2b20							;
    263  2b20							; Add in the new digit
    264  2b20							;
    265  2b20		       68		      pla
    266  2b21		       18		      clc
    267  2b22		       65 52		      adc	R0
    268  2b24		       85 52		      sta	R0
    269  2b26		       90 02		      bcc	getD2
    270  2b28		       e6 53		      inc	R0+1
    271  2b2a							;
    272  2b2a							; Move to next character
    273  2b2a							;
    274  2b2a		       c8	   getD2      iny
    275  2b2b		       d0 c2		      bne	getDecLoop
    276  2b2d							;
    277  2b2d							; All done with digits, so now deal with it being
    278  2b2d							; negative.  If zero, then don't check for negative
    279  2b2d							; flag.  Ie, -0 is stored as 0.
    280  2b2d							;
    281  2b2d		       a5 52	   getDdone   lda	R0
    282  2b2f		       05 53		      ora	R0+1
    283  2b31		       f0 16		      beq	getDone2	;zero
    284  2b33		       a5 59		      lda	dpl
    285  2b35		       f0 12		      beq	getDone2	;positive
    286  2b37							;
    287  2b37							; Invert all the bits, then add one.
    288  2b37							;
    289  2b37		       a5 52		      lda	R0
    290  2b39		       49 ff		      eor	#$ff
    291  2b3b		       85 52		      sta	R0
    292  2b3d		       a5 53		      lda	R0+1
    293  2b3f		       49 ff		      eor	#$ff
    294  2b41		       85 53		      sta	R0+1
    295  2b43							;
    296  2b43		       e6 52		      inc	R0
    297  2b45		       d0 02		      bne	getDone2
    298  2b47		       e6 53		      inc	R0+1
    299  2b49				   getDone2
    300  2b49							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  2b49							;lda	  R0
    302  2b49							;sta	  $0010
    303  2b49							;lda	  R0+1
    304  2b49							;sta	  $0011
    305  2b49							;lda	  dpl
    306  2b49							;sta	  $012
    307  2b49
    308  2b49		       60		      rts
    309  2b4a
    310  2b4a							;=====================================================
    311  2b4a							; Gets a line of input into LINBUF.
    312  2b4a							;
    313  2b4a							; On entry:
    314  2b4a							;    A contains the prompt character, or 0 if none.
    315  2b4a							;    X = 1 Background read
    316  2b4a							;    x = 0 Forground read with wait
    317  2b4a							;
    318  2b4a							; On exit:
    319  2b4a							;    CURPTR points to LINBUF
    320  2b4a							;    LINBUF contains the line with 0 at the end.
    321  2b4a							;    Y has offset to first non-space character
    322  2b4a							;    CURROFF has the same as Y.
    323  2b4a							;
    324  2b4a		       20 99 2b    GetLine    jsr	ReadPrompt
    325  2b4d		       e0 00		      cpx	#0
    326  2b4f		       f0 14		      beq	GetLineRetry
    327  2b51		       ae b9 36 	      ldx	taskPtr
    328  2b54		       bd ba 36 	      lda	taskTable,x
    329  2b57		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  2b59		       d0 3d		      bne	taskWaitingIO
    331  2b5b		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  2b5d		       9d ba 36 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  2b60		       ce 98 2b 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  2b63		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  2b65
    336  2b65							;
    337  2b65							; Now read a line and wait for the CR
    338  2b65							;
    339  2b65				   GetLineRetry
    340  2b65		       a9 00		      lda	#0	;Wait for input to complete
    341  2b67		       20 b1 2b 	      jsr	ReadLine
    342  2b6a
    343  2b6a							;
    344  2b6a							; Point to the line we just read
    345  2b6a							; Set the current pointer to point to the input line
    346  2b6a							;
    347  2b6a		       a0 00	   ReadComplete ldy	#0
    348  2b6c		       84 51		      sty	CUROFF
    349  2b6e		       a2 95		      ldx	#LINBUF&$ff
    350  2b70		       86 4f		      stx	CURPTR
    351  2b72		       a2 42		      ldx	#LINBUF>>8
    352  2b74		       86 50		      stx	CURPTR+1
    353  2b76							;
    354  2b76							; Output a CR/LF
    355  2b76							;
    356  2b76		       20 78 2d 	      jsr	CRLF
    357  2b79							;
    358  2b79							; If a blank line, prompt again.
    359  2b79							;
    360  2b79		       20 6f 2d 	      jsr	SkipSpaces
    361  2b7c		       b1 4f		      lda	(CURPTR),y
    362  2b7e		       d0 10		      bne	GetLineDone	;We have data then exit
    363  2b80		       20 9c 2b 	      jsr	ReadPromptRetry
    364  2b83		       ae b9 36 	      ldx	taskPtr	;if this task is waiting for IO
    365  2b86		       bd ba 36 	      lda	taskTable,x	;then get out, wait for line to
    366  2b89		       29 40		      and	#TASKWAITIO	;Complete again
    367  2b8b		       d0 0b		      bne	taskWaitingIO
    368  2b8d		       4c 65 2b 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  2b90
    370  2b90				   GetLineDone
    371  2b90		       ae b9 36 	      ldx	taskPtr
    372  2b93		       a9 80		      lda	#TASKACTIVE
    373  2b95		       9d ba 36 	      sta	taskTable,x	;IO is complete
    374  2b98
    375  2b98				   taskWaitingIO
    376  2b98		       60		      rts
    377  2b99
    378  2b99							;
    379  2b99							;=======================================================================
    380  2b99							; Display the prompt character
    381  2b99							; On entry
    382  2b99							;	    A contains the prompt character
    383  2b99							; On exit
    384  2b99							;	    The readbuffer index is reset to 0
    385  2b99							;
    386  2b99		       8d 1c 43    ReadPrompt sta	promptChar
    387  2b9c
    388  2b9c							;
    389  2b9c							; Prompt
    390  2b9c							;
    391  2b9c
    392  2b9c		       ad 1c 43    ReadPromptRetry lda	promptChar
    393  2b9f		       09 00		      ora	#0	;any prompt?
    394  2ba1		       f0 08		      beq	getlinenp
    395  2ba3		       20 5e 1a 	      jsr	VOUTCH
    396  2ba6		       a9 20		      lda	#$20
    397  2ba8		       20 5e 1a 	      jsr	VOUTCH	;Space after prompt
    398  2bab							;
    399  2bab		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  2bad		       8e 19 43 	      stx	getlinx
    401  2bb0		       60		      rts
    402  2bb1							;
    403  2bb1							;===============================================================
    404  2bb1							; This fuction is the driver for the line input
    405  2bb1							; on call if a = 0 then it waits for all input
    406  2bb1							;	      a = 1 then nowait for input
    407  2bb1							; On exit
    408  2bb1							;		       c clear if not complete line
    409  2bb1							;		       c set if it was a complete line
    410  2bb1
    411  2bb1				   ReadLine
    412  2bb1		       8d 1b 43 	      sta	inputNoWait
    413  2bb4		       c9 00		      cmp	#0
    414  2bb6		       f0 05		      beq	getline1
    415  2bb8		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  2bbb		       f0 2b		      beq	GetLineNoWait
    417  2bbd		       20 61 1a    getline1   jsr	VGETCH
    418  2bc0					      if	CTMON65
    419  2bc0		       48		      pha
    420  2bc1		       20 5e 1a 	      jsr	VOUTCH	;echo echo echo
    421  2bc4		       68		      pla
    422  2bc5					      endif
    423  2bc5		       c9 0d		      cmp	#CR
    424  2bc7		       f0 15		      beq	getlind	;end of line
    425  2bc9		       c9 08		      cmp	#BS	;backspace?
    426  2bcb		       f0 1d		      beq	getlinebs
    427  2bcd		       ae 19 43 	      ldx	getlinx
    428  2bd0		       9d 95 42 	      sta	LINBUF,x
    429  2bd3		       e8		      inx
    430  2bd4		       8e 19 43 	      stx	getlinx
    431  2bd7		       ad 1b 43 	      lda	inputNoWait
    432  2bda		       f0 e1		      beq	getline1
    433  2bdc		       d0 0a		      bne	GetLineNoWait
    434  2bde							;
    435  2bde							; CR was hit
    436  2bde							;
    437  2bde		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  2be0		       ae 19 43 	      ldx	getlinx
    439  2be3		       9d 95 42 	      sta	LINBUF,x
    440  2be6
    441  2be6		       38		      sec		; Carry set then cr received
    442  2be7		       60		      rts
    443  2be8
    444  2be8				   GetLineNoWait
    445  2be8		       18		      clc		; Carry clear no end of line
    446  2be9		       60		      rts
    447  2bea							;
    448  2bea							; Backspace was hit
    449  2bea							;
    450  2bea		       ae 19 43    getlinebs  ldx	getlinx
    451  2bed		       f0 0e		      beq	getlineEOL	;at start of line
    452  2bef		       ca		      dex
    453  2bf0		       8e 19 43 	      stx	getlinx
    454  2bf3		       20 b6 21    getlinepbs jsr	puts
      0  2bf6					      db	27,"[K",0
      1  2bf6		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  2bfa		       4c bd 2b 	      jmp	getline1
    457  2bfd		       a9 20	   getlineEOL lda	#SPACE
    458  2bff		       20 5e 1a 	      jsr	VOUTCH
    459  2c02		       d0 ef		      bne	getlinepbs
    460  2c04							;
    461  2c04							;=====================================================
    462  2c04							; Count the length of the line currently in LINBUF
    463  2c04							; starting at offset Y.  Returns the length in X.  The
    464  2c04							; starting offset in Y should point past the ASCII
    465  2c04							; line number.  Also counts the trailing NULL and two
    466  2c04							; extra bytes for where the line number will be.
    467  2c04							; Update must now include leading length byte not the null at end ****************
    468  2c04							;
    469  2c04				   getLineLength
    470  2c04		       a2 00		      ldx	#0	;size
    471  2c06		       b9 95 42    getLineL2  lda	LINBUF,y
    472  2c09		       f0 04		      beq	getLineL3
    473  2c0b		       c8		      iny
    474  2c0c		       e8		      inx
    475  2c0d		       d0 f7		      bne	getLineL2
    476  2c0f		       e8	   getLineL3  inx		;count null at end
    477  2c10		       e8		      inx		;line number LSB
    478  2c11		       e8		      inx		;MSB
    479  2c12		       e8		      inx		;change: count new leading line length
    480  2c13		       8e 2b 43 	      stx	lineLength
    481  2c16		       60		      rts
    482  2c17							;
    483  2c17							;=====================================================
    484  2c17							; Count the length of the line pointed to by CURPTR.
    485  2c17							; This also counts the line number and the terminating
    486  2c17							; null.  Ie, this string returns 8:
    487  2c17							;
    488  2c17							; <lineLow><lineHi>Hello<null>
    489  2c17							;
    490  2c17							; Another way of looking at it: add the return value
    491  2c17							; to the CURPTR and it'll point to the next line's
    492  2c17							; line number.  Returns the value in Y.
    493  2c17							; Update to ject get the leading byte length ********************
    494  2c17							;
    495  2c17							;getCURPTRLength
    496  2c17							;		ldy	CURPTR
    497  2c17							;		ldy	#3	;change: skip line number and leading length byte
    498  2c17							;getCLineL2	lda	(CURPTR),y
    499  2c17							;		beq	getCLineL3
    500  2c17							;		iny
    501  2c17							;		bne	getCLineL2
    502  2c17							;getCLineL3	iny		;count null at end
    503  2c17							;		rts
    504  2c17
    505  2c17							;
    506  2c17							;=====================================================
    507  2c17							; This saves ILPC.  This saves to a single save area,
    508  2c17							; so it can't be called more than once.
    509  2c17							;
    510  2c17		       a5 43	   saveIL     lda	ILPC
    511  2c19		       8d 27 43 	      sta	tempIL
    512  2c1c		       a5 44		      lda	ILPC+1
    513  2c1e		       8d 28 43 	      sta	tempIL+1
    514  2c21		       60		      rts
    515  2c22							;
    516  2c22							;=====================================================
    517  2c22							; This restores ILPC.
    518  2c22							;
    519  2c22		       ad 27 43    restoreIL  lda	tempIL
    520  2c25		       85 43		      sta	ILPC
    521  2c27		       ad 28 43 	      lda	tempIL+1
    522  2c2a		       85 44		      sta	ILPC+1
    523  2c2c		       60		      rts
    524  2c2d							;
    525  2c2d							;=====================================================
    526  2c2d							; This pushes R0 onto the stack.
    527  2c2d							;
    528  2c2d		       8c 22 43    pushR0     sty	rtemp1
    529  2c30		       a4 4a		      ldy	MATHSTACKPTR
    530  2c32		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  2c34		       b0 38		      bcs	pusherr
    532  2c36		       a5 52		      lda	R0
    533  2c38		       91 48		      sta	(MATHSTACK),y
    534  2c3a		       c8		      iny
    535  2c3b		       a5 53		      lda	R0+1
    536  2c3d		       91 48		      sta	(MATHSTACK),y
    537  2c3f		       c8		      iny
    538  2c40		       84 4a		      sty	MATHSTACKPTR
    539  2c42		       ac 22 43 	      ldy	rtemp1
    540  2c45		       18		      clc
    541  2c46		       60		      rts
    542  2c47
    543  2c47							;=====================================================
    544  2c47							; This pushes curptr basic current line onto the call stack.
    545  2c47							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  2c47
    547  2c47				   pushLN
    548  2c47		       8d 23 43 	      STA	rtemp1+1	; Store type of push being done
    549  2c4a		       8c 22 43 	      sty	rtemp1
    550  2c4d		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  2c4f		       c5 4d		      cmp	GOSUBSTACKPTR
    552  2c51		       90 1b		      bcc	pusherr	; No error
    553  2c53		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  2c55		       a2 00		      ldx	#0	; Start of bytes to copy
    555  2c57				   pushLoop
    556  2c57		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  2c59		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  2c5b		       c8		      iny		; Next destination
    559  2c5c		       e8		      inx		; Next Source byte
    560  2c5d		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  2c5f		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  2c61
    563  2c61		       ad 23 43    pushDone   lda	rtemp1+1	; Type of stack entry
    564  2c64		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  2c66		       c8		      iny		; Next entry
    566  2c67
    567  2c67		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  2c69		       ac 22 43 	      ldy	rtemp1
    569  2c6c		       18		      clc
    570  2c6d		       60		      rts
    571  2c6e				   pusherr
    572  2c6e		       38		      sec
    573  2c6f		       60		      rts
    574  2c70							;=====================================================
    575  2c70							; This pops Top Off gosub call Stack and
    576  2c70							; places it in CURPTR/CUROFF.
    577  2c70							; This checks if the type = 1 GOSUB
    578  2c70							; if not it removes what ever is on the stack
    579  2c70							; until it finds the next return. Allowing
    580  2c70							; a return from within a for/next
    581  2c70							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  2c70		       8c 22 43    popLN      sty	rtemp1
    583  2c73		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  2c75		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  2c77
    586  2c77				   popContinue
    587  2c77		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  2c79		       90 22		      bcc	poperr	; Process an error
    589  2c7b
    590  2c7b		       88		      dey		; Position to read entry type
    591  2c7c		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  2c7e		       8d 23 43 	      sta	rtemp1+1	; Save to be returned
    593  2c81		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  2c83		       f0 04		      beq	popLoop	; Restore the line
    595  2c85		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  2c87		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  2c89
    598  2c89				   popLoop
    599  2c89		       88		      dey
    600  2c8a		       ca		      dex
    601  2c8b		       b1 4b		      lda	(GOSUBSTACK),y
    602  2c8d		       95 4f		      sta	CURPTR,x
    603  2c8f		       e0 00		      cpx	#0
    604  2c91		       d0 f6		      bne	popLoop	; Loop until all moved
    605  2c93
    606  2c93
    607  2c93		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  2c95		       ac 22 43 	      ldy	rtemp1
    609  2c98		       ad 23 43 	      lda	rtemp1+1	; get the type of return
    610  2c9b		       18		      clc
    611  2c9c		       60		      rts
    612  2c9d
    613  2c9d		       38	   poperr     sec
    614  2c9e		       60		      rts
    615  2c9f
    616  2c9f		       88	   popSkipEntry dey
    617  2ca0		       88		      dey
    618  2ca1		       88		      dey
    619  2ca2		       4c 77 2c 	      jmp	popContinue
    620  2ca5
    621  2ca5							;
    622  2ca5							;=====================================================
    623  2ca5							; This pushes R1 onto the stack
    624  2ca5							;
    625  2ca5		       8c 22 43    pushR1     sty	rtemp1
    626  2ca8		       a4 4a		      ldy	MATHSTACKPTR
    627  2caa		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  2cac		       b0 ef		      bcs	poperr
    629  2cae		       a5 54		      lda	R1
    630  2cb0		       91 48		      sta	(MATHSTACK),y
    631  2cb2		       c8		      iny
    632  2cb3		       a5 55		      lda	R1+1
    633  2cb5		       91 48		      sta	(MATHSTACK),y
    634  2cb7		       c8		      iny
    635  2cb8		       84 4a		      sty	MATHSTACKPTR
    636  2cba		       ac 22 43 	      ldy	rtemp1
    637  2cbd		       18		      clc
    638  2cbe		       60		      rts
    639  2cbf							;
    640  2cbf							;=====================================================
    641  2cbf							; This pops Top Of Stack and places it in R0.
    642  2cbf							;
    643  2cbf		       8c 22 43    popR0      sty	rtemp1
    644  2cc2		       a4 4a		      ldy	MATHSTACKPTR
    645  2cc4		       f0 d7		      beq	poperr
    646  2cc6		       88		      dey
    647  2cc7		       b1 48		      lda	(MATHSTACK),y
    648  2cc9		       85 53		      sta	R0+1
    649  2ccb		       88		      dey
    650  2ccc		       b1 48		      lda	(MATHSTACK),y
    651  2cce		       85 52		      sta	R0
    652  2cd0		       84 4a		      sty	MATHSTACKPTR
    653  2cd2		       ac 22 43 	      ldy	rtemp1
    654  2cd5		       18		      clc
    655  2cd6		       60		      rts
    656  2cd7
    657  2cd7							;
    658  2cd7							;=====================================================
    659  2cd7							; This pops TOS and places it in R1.
    660  2cd7							;
    661  2cd7		       8c 22 43    popR1      sty	rtemp1
    662  2cda		       a4 4a		      ldy	MATHSTACKPTR
    663  2cdc		       f0 bf		      beq	poperr
    664  2cde		       88		      dey
    665  2cdf		       b1 48		      lda	(MATHSTACK),y
    666  2ce1		       85 55		      sta	R1+1
    667  2ce3		       88		      dey
    668  2ce4		       b1 48		      lda	(MATHSTACK),y
    669  2ce6		       85 54		      sta	R1
    670  2ce8		       84 4a		      sty	MATHSTACKPTR
    671  2cea		       ac 22 43 	      ldy	rtemp1
    672  2ced		       60		      rts
    673  2cee							;
    674  2cee							;=====================================================
    675  2cee							; This pops TOS and places it in MQ.
    676  2cee							;
    677  2cee		       8c 22 43    popMQ      sty	rtemp1
    678  2cf1		       a4 4a		      ldy	MATHSTACKPTR
    679  2cf3		       f0 a8		      beq	poperr
    680  2cf5		       88		      dey
    681  2cf6		       b1 48		      lda	(MATHSTACK),y
    682  2cf8		       85 57		      sta	MQ+1
    683  2cfa		       88		      dey
    684  2cfb		       b1 48		      lda	(MATHSTACK),y
    685  2cfd		       85 56		      sta	MQ
    686  2cff		       84 4a		      sty	MATHSTACKPTR
    687  2d01		       ac 22 43 	      ldy	rtemp1
    688  2d04		       60		      rts
    689  2d05							;
    690  2d05							;=====================================================
    691  2d05							; This assists with multiplication and division by
    692  2d05							; looking at R0 and R1 and saving a flag as to what
    693  2d05							; sign the result will be.  Math is always done on
    694  2d05							; positive numbers, so this converts negative numbers
    695  2d05							; into positives.  On exit, R0 and R1 are both
    696  2d05							; positive.  If the signs were different then 'signs'
    697  2d05							; will be non-zero.
    698  2d05							;
    699  2d05		       a9 00	   SaveSigns  lda	#0
    700  2d07		       8d 21 43 	      sta	sign	;assume positive
    701  2d0a		       a5 53		      lda	R0+1	;MSB
    702  2d0c		       10 13		      bpl	SaveSigns1
    703  2d0e		       ee 21 43 	      inc	sign	;it's negative
    704  2d11		       49 ff		      eor	#$ff	;flip bits
    705  2d13		       85 53		      sta	R0+1
    706  2d15		       a5 52		      lda	R0
    707  2d17		       49 ff		      eor	#$ff
    708  2d19		       85 52		      sta	R0
    709  2d1b		       e6 52		      inc	R0
    710  2d1d		       d0 02		      bne	SaveSigns1
    711  2d1f		       e6 53		      inc	R0+1
    712  2d21		       a5 55	   SaveSigns1 lda	R1+1
    713  2d23		       10 1a		      bpl	SaveSigns2
    714  2d25		       48		      pha
    715  2d26		       ad 21 43 	      lda	sign
    716  2d29		       49 01		      eor	#1
    717  2d2b		       8d 21 43 	      sta	sign
    718  2d2e		       68		      pla
    719  2d2f		       49 ff		      eor	#$ff	;flip bits
    720  2d31		       85 55		      sta	R1+1
    721  2d33		       a5 54		      lda	R1
    722  2d35		       49 ff		      eor	#$ff
    723  2d37		       85 54		      sta	R1
    724  2d39		       e6 54		      inc	R1
    725  2d3b		       d0 02		      bne	SaveSigns2
    726  2d3d		       e6 55		      inc	R1+1
    727  2d3f		       60	   SaveSigns2 rts
    728  2d40							;
    729  2d40							;=====================================================
    730  2d40							; This looks at the value of 'signs' and will convert
    731  2d40							; both R0 and R1 to negative if set.
    732  2d40							;
    733  2d40				   RestoreSigns
    734  2d40		       ad 21 43 	      lda	sign
    735  2d43		       f0 28		      beq	restoresigns2
    736  2d45							;
    737  2d45		       a5 52		      lda	R0
    738  2d47		       d0 02		      bne	restoresigns3
    739  2d49		       c6 53		      dec	R0+1
    740  2d4b				   restoresigns3
    741  2d4b		       c6 52		      dec	R0
    742  2d4d		       a5 52		      lda	R0
    743  2d4f		       49 ff		      eor	#$ff
    744  2d51		       85 52		      sta	R0
    745  2d53		       a5 53		      lda	R0+1
    746  2d55		       49 ff		      eor	#$ff
    747  2d57		       85 53		      sta	R0+1
    748  2d59							;
    749  2d59		       a5 54		      lda	R1
    750  2d5b		       d0 02		      bne	restoresigns4
    751  2d5d		       c6 55		      dec	R1+1
    752  2d5f				   restoresigns4
    753  2d5f		       c6 54		      dec	R1
    754  2d61		       a5 54		      lda	R1
    755  2d63		       49 ff		      eor	#$ff
    756  2d65		       85 54		      sta	R1
    757  2d67		       a5 55		      lda	R1+1
    758  2d69		       49 ff		      eor	#$ff
    759  2d6b		       85 55		      sta	R1+1
    760  2d6d							;
    761  2d6d				   restoresigns2
    762  2d6d		       60		      rts
    763  2d6e							;
    764  2d6e							;=====================================================
    765  2d6e							; Skip over spaces.  Returns Y with the offset to
    766  2d6e							; either the last character in the line, or the first
    767  2d6e							; non-space character.
    768  2d6e							;
    769  2d6e
    770  2d6e		       c8	   skipsp2    iny
    771  2d6f		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  2d71		       f0 04		      beq	Skip3	;end of line
    773  2d73		       c9 20		      cmp	#SPACE
    774  2d75		       f0 f7		      beq	skipsp2
    775  2d77		       60	   Skip3      rts
    776  2d78							;*********************************************************
    777  2d78							; Output a CR/LF combination to the console.  Preserves
    778  2d78							; all registers.
    779  2d78							;
    780  2d78		       48	   tbcrlf     pha
    781  2d79		       a9 0d		      lda	#CR
    782  2d7b		       20 5e 1a 	      jsr	VOUTCH
    783  2d7e		       a9 0a		      lda	#LF
    784  2d80		       20 5e 1a 	      jsr	VOUTCH
    785  2d83		       68		      pla
    786  2d84		       60		      rts
    787  2d85							;
    788  2d85							;=====================================================
    789  2d85							; Some logic to print the Line of basic code being executed
    790  2d85		       24 40	   idbgBasic  bit	ILTrace
    791  2d87		       50 75		      bvc	dbgBasicNone
    792  2d89		       98		      tya
    793  2d8a		       48		      pha
    794  2d8b		       20 13 2f 	      jsr	SetOutDebug
    795  2d8e
    796  2d8e		       a5 4f		      lda	CURPTR
    797  2d90		       85 59		      sta	dpl
    798  2d92		       a5 50		      lda	CURPTR+1
    799  2d94		       85 5a		      sta	dpl+1
    800  2d96
    801  2d96		       20 4e 22 	      jsr	PrintProgramLine
    802  2d99
    803  2d99		       a5 40		      lda	ILTrace
    804  2d9b		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  2d9d		       f0 5a		      beq	dbgBasicDone
    806  2d9f		       20 2a 2f 	      jsr	SetInDebug
    807  2da2		       20 b6 21 	      jsr	puts
      0  2da5					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  2da5		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  2de2				   dbgBasicLoop
    810  2de2		       20 61 1a 	      jsr	VGETCH
    811  2de5		       20 78 2d 	      jsr	CRLF
    812  2de8		       20 4e 2f 	      jsr	SetInDebugEnd
    813  2deb
    814  2deb		       c9 73		      cmp	#'s	; Quit program
    815  2ded		       f0 12		      beq	dbgBasicStop
    816  2def
    817  2def		       c9 64		      cmp	#'d	; Display Variables
    818  2df1		       d0 06		      bne	dbgBasicDone
    819  2df3
    820  2df3		       20 11 22 	      jsr	PrintAllVars
    821  2df6		       18		      clc
    822  2df7		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  2df9
    824  2df9		       20 41 2f    dbgBasicDone jsr	SetOutDebugEnd
    825  2dfc		       68		      pla
    826  2dfd		       a8		      tay
    827  2dfe		       4c b1 02    dbgBasicNone jmp	NextIL
    828  2e01
    829  2e01				   dbgBasicStop
    830  2e01		       20 41 2f 	      jsr	SetOutDebugEnd
    831  2e04		       68		      pla
    832  2e05		       a8		      tay
    833  2e06		       4c 02 06 	      jmp	iFIN
    834  2e09							;
    835  2e09							;=====================================================
    836  2e09							; This is some debug logic which displays the current
    837  2e09							; value of the ILPC and the line buffer.
    838  2e09							;
    839  2e09		       24 40	   dbgLine    bit	ILTrace
    840  2e0b		       30 01		      bmi	dbgPrt
    841  2e0d		       60		      rts
    842  2e0e				   dbgPrt
    843  2e0e		       20 13 2f 	      jsr	SetOutDebug
    844  2e11		       20 b6 21 	      jsr	puts
      0  2e14					      db	"ILPC:",0
      1  2e14		       49 4c 50 43*	      .byte.b	"ILPC:",0
    846  2e1a		       a5 44		      lda	ILPC+1
    847  2e1c		       20 99 21 	      jsr	OUTHEX
    848  2e1f		       a5 43		      lda	ILPC
    849  2e21		       20 99 21 	      jsr	OUTHEX
    850  2e24		       a9 20		      lda	#SPACE
    851  2e26		       20 5e 1a 	      jsr	VOUTCH
    852  2e29
    853  2e29		       a0 00		      ldy	#0
    854  2e2b		       b1 43		      lda	(ILPC),y	;Get the il pcode value
    855  2e2d					      if	IL_DEBUG_TEXT
    856  2e2d		       20 14 19 	      jsr	PrintILText
    857  2e30				  -	      else
    858  2e30				  -	      jsr	OUTHEX
    859  2e30					      endif
    860  2e30		       20 b6 21 	      jsr	puts
      0  2e33					      db	" ILSP:",0
      1  2e33		       20 49 4c 53*	      .byte.b	" ILSP:",0
    862  2e3a		       a5 47		      lda	ILSTACKPTR
    863  2e3c		       20 99 21 	      jsr	OUTHEX
    864  2e3f		       a9 20		      lda	#SPACE
    865  2e41		       20 5e 1a 	      jsr	VOUTCH
    866  2e44
    867  2e44							; Display the CURPTR value and offset
    868  2e44							;
    869  2e44		       20 b6 21 	      jsr	puts
      0  2e47					      db	", CURPTR: ",0
      1  2e47		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    871  2e52		       a5 50		      lda	CURPTR+1
    872  2e54		       20 99 21 	      jsr	OUTHEX
    873  2e57		       a5 4f		      lda	CURPTR
    874  2e59		       20 99 21 	      jsr	OUTHEX
    875  2e5c		       a9 2b		      lda	#'+
    876  2e5e		       20 5e 1a 	      jsr	VOUTCH
    877  2e61		       a5 51		      lda	CUROFF
    878  2e63		       20 99 21 	      jsr	OUTHEX
    879  2e66							;
    880  2e66		       20 78 2d 	      jsr	CRLF
    881  2e69		       20 41 2f 	      jsr	SetOutDebugEnd
    882  2e6c		       20 9f 2e 	      jsr	ILChkRange
    883  2e6f		       b0 02		      bcs	dbgLineErr
    884  2e71		       18		      clc
    885  2e72		       60		      rts
    886  2e73
    887  2e73				   dbgLineErr
    888  2e73		       20 13 2f 	      jsr	SetOutDebug
    889  2e76		       20 b6 21 	      jsr	puts
      0  2e79					      db	"Outside Valid IL Address Range",CR,LF,0
      1  2e79		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    891  2e9a		       20 41 2f 	      jsr	SetOutDebugEnd
    892  2e9d		       38		      sec
    893  2e9e		       60		      rts
    894  2e9f
    895  2e9f		       a5 44	   ILChkRange lda	ILPC+1
    896  2ea1		       c9 31		      cmp	#IL>>8
    897  2ea3		       90 18		      bcc	ILBadRange
    898  2ea5		       d0 06		      bne	ILChkHigh
    899  2ea7
    900  2ea7		       a5 43		      lda	ILPC
    901  2ea9		       c9 fc		      cmp	#IL&$ff
    902  2eab		       90 10		      bcc	ILBadRange
    903  2ead
    904  2ead		       a5 44	   ILChkHigh  lda	ILPC+1
    905  2eaf		       c9 36		      cmp	#ILEND>>8
    906  2eb1		       90 08		      bcc	ILGoodRange
    907  2eb3		       d0 08		      bne	ILBadRange
    908  2eb5
    909  2eb5		       a5 43		      lda	ILPC
    910  2eb7		       c9 66		      cmp	#ILEND&$ff
    911  2eb9		       b0 02		      bcs	ILBadRange
    912  2ebb
    913  2ebb		       18	   ILGoodRange clc
    914  2ebc		       60		      rts
    915  2ebd				   ILBadRange
    916  2ebd		       38		      sec
    917  2ebe		       60		      rts
    918  2ebf
    919  2ebf
    920  2ebf							;=====================================================
    921  2ebf							; Set output vector to the console output function
    922  2ebf							;
    923  2ebf				   SetOutConsole
    924  2ebf		       48		      pha
    925  2ec0		       a9 0c		      lda	#OUTCH&$ff
    926  2ec2		       8d 6b 36 	      sta	BOutVec
    927  2ec5		       a9 f0		      lda	#OUTCH>>8
    928  2ec7		       8d 6c 36 	      sta	BOutVec+1
    929  2eca		       68		      pla
    930  2ecb		       60		      rts
    931  2ecc
    932  2ecc				   SetInConsole
    933  2ecc		       48		      pha
    934  2ecd		       a9 09		      lda	#GETCH&$ff
    935  2ecf		       8d 69 36 	      sta	BInVec
    936  2ed2		       a9 f0		      lda	#GETCH>>8
    937  2ed4		       8d 6a 36 	      sta	BInVec+1
    938  2ed7		       68		      pla
    939  2ed8		       60		      rts
    940  2ed9
    941  2ed9
    942  2ed9
    943  2ed9							;====================================================
    944  2ed9							;Clear the terminal assume it is ansii or vt100
    945  2ed9							;
    946  2ed9				   iCLEARSCREEN
    947  2ed9		       20 b6 21 	      jsr	puts
      0  2edc					      db	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
      1  2edc		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
    949  2eed		       4c b1 02 	      jmp	NextIL
    950  2ef0
    951  2ef0							;====================================================
    952  2ef0							; Push true and false onto math stack
    953  2ef0				   pushTrue
    954  2ef0		       a9 ff		      lda	#$ff
    955  2ef2		       85 52	   pushTF     sta	R0
    956  2ef4		       85 53		      sta	R0+1
    957  2ef6		       20 2d 2c 	      jsr	pushR0
    958  2ef9		       60		      rts
    959  2efa		       a9 00	   pushFalse  lda	#0
    960  2efc		       f0 f4		      beq	pushTF
    961  2efe
    962  2efe							;======================================================
    963  2efe							; Copy stack top to R1
    964  2efe				   CopyStackR1
    965  2efe		       98		      tya
    966  2eff		       48		      pha
    967  2f00		       a4 4a		      ldy	MATHSTACKPTR
    968  2f02		       88		      dey
    969  2f03		       b1 48		      lda	(MATHSTACK),y
    970  2f05		       85 55		      sta	R1+1
    971  2f07		       88		      dey
    972  2f08		       b1 48		      lda	(MATHSTACK),y
    973  2f0a		       85 54		      sta	R1
    974  2f0c		       68		      pla
    975  2f0d		       a8		      tay
    976  2f0e		       60		      rts
    977  2f0f
    978  2f0f
    979  2f0f							;====================================================
    980  2f0f							;Swap the out debug call for standard calls
    981  2f0f		       00 00	   DebugIOSave ds	2
    982  2f11		       00 00	   DebugInSave ds	2
    983  2f13				   SetOutDebug
    984  2f13		       ad 6b 36 	      lda	BOutVec
    985  2f16		       8d 0f 2f 	      sta	DebugIOSave
    986  2f19		       ad 6c 36 	      lda	BOutVec+1
    987  2f1c		       8d 10 2f 	      sta	DebugIOSave+1
    988  2f1f		       a9 a7		      lda	#OUTDEBUG&$ff	; Put the Debug output
    989  2f21		       8d 6b 36 	      sta	BOutVec
    990  2f24		       a9 2f		      lda	#OUTDEBUG>>8
    991  2f26		       8d 6c 36 	      sta	BOutVec+1
    992  2f29		       60		      rts
    993  2f2a				   SetInDebug
    994  2f2a		       ad 69 36 	      lda	BInVec
    995  2f2d		       8d 11 2f 	      sta	DebugInSave
    996  2f30		       ad 6a 36 	      lda	BInVec+1
    997  2f33		       8d 12 2f 	      sta	DebugInSave+1
    998  2f36		       a9 ab		      lda	#INDEBUG&$ff
    999  2f38		       8d 69 36 	      sta	BInVec
   1000  2f3b		       a9 2f		      lda	#INDEBUG>>8
   1001  2f3d		       8d 6a 36 	      sta	BInVec+1
   1002  2f40		       60		      rts
   1003  2f41				   SetOutDebugEnd
   1004  2f41		       ad 0f 2f 	      lda	DebugIOSave
   1005  2f44		       8d 6b 36 	      sta	BOutVec
   1006  2f47		       ad 10 2f 	      lda	DebugIOSave+1
   1007  2f4a		       8d 6c 36 	      sta	BOutVec+1
   1008  2f4d		       60		      rts
   1009  2f4e				   SetInDebugEnd
   1010  2f4e		       ad 11 2f 	      lda	DebugInSave
   1011  2f51		       8d 69 36 	      sta	BInVec
   1012  2f54		       ad 12 2f 	      lda	DebugInSave+1
   1013  2f57		       8d 6a 36 	      sta	BInVec+1
   1014  2f5a		       60		      rts
   1015  2f5b							;
   1016  2f5b							;====================================================
   1017  2f5b							; Set the input and output terminal address
   1018  2f5b							; The math stack stack byte is the output io slot
   1019  2f5b							; The math stack  is the input io slot
   1020  2f5b
   1021  2f5b				   iSetTerminal
   1022  2f5b		       20 bf 2c 	      jsr	popR0	; Process the output io addresses
   1023  2f5e		       20 88 2f 	      jsr	CalcSlot
   1024  2f61		       a5 52		      lda	R0
   1025  2f63		       09 01		      ora	#1
   1026  2f65		       8d a8 2f 	      sta	TerminalOutputPort
   1027  2f68		       a5 53		      lda	R0+1
   1028  2f6a		       8d a9 2f 	      sta	TerminalOutputPort+1
   1029  2f6d
   1030  2f6d		       20 bf 2c 	      jsr	popR0	; Process the input io address
   1031  2f70		       20 88 2f 	      jsr	CalcSlot
   1032  2f73		       a5 52		      lda	R0
   1033  2f75		       8d ac 2f 	      sta	TerminalStatusPort
   1034  2f78		       09 01		      ora	#1
   1035  2f7a		       8d b3 2f 	      sta	TerminalInputPort
   1036  2f7d		       a5 53		      lda	R0+1
   1037  2f7f		       8d b4 2f 	      sta	TerminalInputPort+1
   1038  2f82		       8d ad 2f 	      sta	TerminalStatusPort+1
   1039  2f85		       4c b1 02 	      jmp	NextIL
   1040  2f88
   1041  2f88							;===================================================
   1042  2f88							; Calculate the slot address the the slot number
   1043  2f88							; R0 contains the slot number 0-255
   1044  2f88
   1045  2f88				   CalcSlot
   1046  2f88		       8a		      txa
   1047  2f89		       48		      pha
   1048  2f8a
   1049  2f8a		       a2 04		      ldx	#4
   1050  2f8c				   CalcSlotLoop
   1051  2f8c		       18		      clc
   1052  2f8d		       26 52		      rol	R0
   1053  2f8f		       26 53		      rol	R0+1
   1054  2f91		       ca		      dex
   1055  2f92		       d0 f8		      bne	CalcSlotLoop
   1056  2f94
   1057  2f94		       a9 e0		      lda	#$E0
   1058  2f96		       05 53		      ora	R0+1
   1059  2f98		       85 53		      sta	R0+1
   1060  2f9a		       68		      pla
   1061  2f9b
   1062  2f9b		       aa		      tax
   1063  2f9c		       60		      rts
   1064  2f9d							;
   1065  2f9d							;====================================================
   1066  2f9d							; Output to the Terminal/Debug console
   1067  2f9d							;     x = high address byte
   1068  2f9d							;     y = low address byte
   1069  2f9d							;     a = Terminator for string
   1070  2f9d				   TerminalWrite
   1071  2f9d				   DebugWrite
   1072  2f9d		       20 13 2f 	      jsr	SetOutDebug
   1073  2fa0		       20 f4 21 	      jsr	PrtStr
   1074  2fa3		       20 41 2f 	      jsr	SetOutDebugEnd
   1075  2fa6		       60		      rts
   1076  2fa7
   1077  2fa7				   TerminalIOblock
   1078  2fa7				   OUTDEBUG
   1079  2fa7		       8d		      .byte.b	$8D	; STA
   1080  2fa8				   TerminalOutputPort
   1081  2fa8		       21 e0	   DEBUGPORT  .word.w	$E021	; Dont check anything just output the byte
   1082  2faa		       60		      RTS
   1083  2fab
   1084  2fab				   TerminalRead
   1085  2fab				   INDEBUG
   1086  2fab		       ad		      .byte.b	$AD	; LDA
   1087  2fac				   TerminalStatusPort
   1088  2fac		       20 e0	   DEBUGPORTSTATUS .word.w	$E020
   1089  2fae
   1090  2fae		       29 01		      and	#$01
   1091  2fb0		       f0 f9		      beq	INDEBUG
   1092  2fb2
   1093  2fb2		       ad		      .byte.b	$AD	; LDA
   1094  2fb3				   TerminalInputPort
   1095  2fb3		       21 e0	   DEBUGPORTIN .word.w	$E021
   1096  2fb5		       60		      rts
   1097  2fb6				   TerminalIOblockEnd
   1098  2fb6							;======================================================================
   1099  2fb6							;Copy Quoted string to buffer, terminate with 0 byte
   1100  2fb6							; R0  Source tring points to tString type
   1101  2fb6							; x is terminator
   1102  2fb6							; R1 points to destinition location
   1103  2fb6							; On exit R0 contains length of copy Plus Term and leading bytes
   1104  2fb6
   1105  2fb6				   qstrcpy
   1106  2fb6		       20 2d 2c 	      jsr	pushR0
   1107  2fb9		       20 06 30 	      jsr	IncR0	; point past the tString
   1108  2fbc		       20 06 30 	      jsr	IncR0	; Point Past the opening "
   1109  2fbf		       a2 22		      ldx	#'"	; copy Termination
   1110  2fc1		       20 db 2f 	      jsr	pstrcpy
   1111  2fc4		       20 06 30 	      jsr	IncR0	; point to "
   1112  2fc7		       20 06 30 	      jsr	IncR0	; Point to next free byte
   1113  2fca		       20 d7 2c 	      jsr	popR1
   1114  2fcd		       38		      sec
   1115  2fce		       a5 52		      lda	R0
   1116  2fd0		       e5 54		      sbc	R1
   1117  2fd2		       85 52		      sta	R0
   1118  2fd4		       a5 53		      lda	R0+1
   1119  2fd6		       e5 55		      sbc	R1+1
   1120  2fd8		       85 53		      sta	R0+1
   1121  2fda		       60		      rts
   1122  2fdb
   1123  2fdb							;=========================================================================
   1124  2fdb							;Copy string from R0 to R1, terminator in x
   1125  2fdb							; On exit    R0 contains the length of the copy
   1126  2fdb				   pstrcpy
   1127  2fdb		       a0 00		      ldy	#0
   1128  2fdd		       86 58		      stx	R2
   1129  2fdf
   1130  2fdf				   strcpyLoop
   1131  2fdf		       b1 52		      lda	(R0),y
   1132  2fe1		       c5 58		      cmp	R2
   1133  2fe3		       f0 0a		      beq	strcpyDone
   1134  2fe5		       91 54		      sta	(R1),y
   1135  2fe7		       20 06 30 	      jsr	IncR0
   1136  2fea		       20 f4 2f 	      jsr	IncR1
   1137  2fed		       90 f0		      bcc	strcpyLoop
   1138  2fef				   strcpyDone
   1139  2fef		       a9 00		      lda	#0
   1140  2ff1		       91 54		      sta	(R1),y
   1141  2ff3
   1142  2ff3		       60		      rts
   1143  2ff4
   1144  2ff4							;=========================================================================
   1145  2ff4							; on exit c is set on overflow
   1146  2ff4				   IncR1
   1147  2ff4		       48		      pha
   1148  2ff5		       18		      clc
   1149  2ff6		       a9 01		      lda	#1
   1150  2ff8		       65 54		      adc	R1
   1151  2ffa		       85 54		      sta	R1
   1152  2ffc		       90 06		      bcc	IncR1Done
   1153  2ffe		       a9 00		      lda	#0
   1154  3000		       65 55		      adc	R1+1
   1155  3002		       85 55		      sta	R1+1
   1156  3004				   IncR1Done
   1157  3004		       68		      pla
   1158  3005		       60		      rts
   1159  3006							;=========================================================================
   1160  3006							; on exit c is set on overflow
   1161  3006				   IncR0
   1162  3006		       48		      pha
   1163  3007		       18		      clc
   1164  3008		       a9 01		      lda	#1
   1165  300a		       65 52		      adc	R0
   1166  300c		       85 52		      sta	R0
   1167  300e		       90 06		      bcc	IncR0Done
   1168  3010		       a9 00		      lda	#0
   1169  3012		       65 53		      adc	R0+1
   1170  3014		       85 53		      sta	R0+1
   1171  3016				   IncR0Done
   1172  3016		       68		      pla
   1173  3017		       60		      rts
   1174  3018
   1175  3018
   1176  3018
   1177  3018
   1178  3018
   1179  3018
   1180  3018
   1181  3018
   1182  3018
   1183  3018
   1184  3018
   1185  3018
   1186  3018
   1187  3018
   1188  3018
   1189  3018
------- FILE mytb.asm
   2493  3018
   2494  3018					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  3018					      include	"storage.asm"
      1  3018							;
      2  3018							;=====================================================
      3  3018							;=====================================================
      4  3018							;=====================================================
      5  3018							; This file contains the functions for saving and
      6  3018							; restoring programs from some sort of mass storage
      7  3018							; device.  This particular version is for using the
      8  3018							; Corsham Tech SD Card System.
      9  3018							;=====================================================
     10  3018							;=====================================================
     11  3018							;=====================================================
     12  3018
     13 U3677					      seg.u	TBData
     14 U3677		       00	   diskBufLength ds	1
     15 U3678		       00	   diskBufOffset ds	1
     16 U3679		       00 00 00 00*DiskFileName ds	64
     17 U36b9
     18  3018					      SEG	Code
     19  3018
     20  3018							;
     21  3018							;=====================================================
     22  3018							; Open a file for reading as a program.  The next
     23  3018							; thing on the line should be the filename.
     24  3018							;
     25  3018				   iOPENREAD
     26  3018					      if	XKIM || CTMON65
     27  3018		       20 32 30 	      jsr	setFileName	;Set the file name to open
     28  301b		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  301e		       90 07		      bcc	Ropenok	;branch if opened ok
     30  3020							;
     31  3020							; Open failed
     32  3020							;
     33  3020		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  3022		       a9 00	   Rdfail2    lda	#0
     35  3024		       4c 7d 06 	      jmp	iErr2
     36  3027							;
     37  3027							; Clear counts and offsets so the next read will
     38  3027							; cause the file to be read.
     39  3027							;
     40  3027		       a9 00	   Ropenok    lda	#0
     41  3029		       8d 78 36 	      sta	diskBufOffset
     42  302c		       8d 77 36 	      sta	diskBufLength
     43  302f		       4c b1 02 	      jmp	NextIL
     44  3032					      endif
     45  3032
     46  3032							;===============================================================
     47  3032							; Set file name
     48  3032				   setFileName
     49  3032		       a4 51		      ldy	CUROFF
     50  3034		       b1 4f		      lda	(CURPTR),y
     51  3036		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  3038		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  303a
     54  303a		       18		      clc
     55  303b		       98		      tya
     56  303c		       65 4f		      adc	CURPTR
     57  303e		       85 52		      sta	R0	;LSB
     58  3040		       a5 50		      lda	CURPTR+1
     59  3042		       69 00		      adc	#0
     60  3044		       85 53		      sta	R0+1
     61  3046		       a9 79		      lda	#DiskFileName&$ff
     62  3048		       85 54		      sta	R1
     63  304a		       a9 36		      lda	#DiskFileName>>8
     64  304c		       85 55		      sta	R1+1
     65  304e		       20 b6 2f 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  3051		       a5 52		      lda	R0
     67  3053		       18		      clc
     68  3054		       65 51		      adc	CUROFF	; add the current offset
     69  3056		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  3058				   ResetFileName
     71  3058		       a0 79		      ldy	#DiskFileName&$ff
     72  305a		       a2 36		      ldx	#DiskFileName>>8
     73  305c		       18		      clc
     74  305d		       60		      rts
     75  305e
     76  305e				   setFileNameNotFound
     77  305e		       68		      pla
     78  305f		       68		      pla		; remove the return address from the stack
     79  3060		       a9 00		      lda	#0
     80  3062		       a2 09		      ldx	#ERR_NO_FILENAME
     81  3064		       4c 7d 06 	      jmp	iErr2
     82  3067
     83  3067							;
     84  3067							;==============================JUSTLOSTINTIME 08/02/2022========
     85  3067							;Remove a file from the disk
     86  3067				   iRMFILE
     87  3067					      if	XKIM || CTMON65
     88  3067		       20 32 30 	      jsr	setFileName
     89  306a		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  306d		       90 07		      bcc	wrmOk	;branch if removed ok
     91  306f		       a9 00		      lda	#0
     92  3071		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  3073		       4c 7d 06 	      jmp	iErr2
     94  3076				   wrmOk
     95  3076		       4c b1 02 	      jmp	NextIL
     96  3079
     97  3079					      endif
     98  3079							;
     99  3079							;=====================================================
    100  3079				   iOPENWRITE
    101  3079					      if	XKIM || CTMON65
    102  3079		       20 32 30 	      jsr	setFileName
    103  307c		       20 34 2a 	      jsr	getILByte	;get the append or create byte
    104  307f		       c9 01		      cmp	#1	;create/truncate
    105  3081		       d0 06		      bne	iopencont
    106  3083		       20 58 30 	      jsr	ResetFileName	;point back to the file name
    107  3086		       20 45 f0 	      jsr	DiskRmFile	;by default files opened for write are append
    108  3089
    109  3089				   iopencont
    110  3089		       20 58 30 	      jsr	ResetFileName	;point back to the file name
    111  308c		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    112  308f		       90 07		      bcc	Wopenok	;branch if opened ok
    113  3091							;
    114  3091							; Open failed
    115  3091							;
    116  3091		       a9 00	   Wdfail     lda	#0
    117  3093		       a2 08		      ldx	#ERR_WRITE_FAIL
    118  3095		       4c 7d 06 	      jmp	iErr2
    119  3098							;
    120  3098		       4c b1 02    Wopenok    jmp	NextIL
    121  309b					      endif
    122  309b							;
    123  309b							;=====================================================
    124  309b							; Gets a line of input from the disk file and puts it
    125  309b							; into LINBUF.
    126  309b							;
    127  309b							; On exit:
    128  309b							;    CURPTR points to LINBUF
    129  309b							;    LINBUF contains the line with 0 at the end.
    130  309b							;    Y has offset to first non-space character
    131  309b							;    CURROFF has the same as Y.
    132  309b							;
    133  309b				   iDGETLINE
    134  309b					      if	XKIM || CTMON65
    135  309b		       a2 95		      ldx	#LINBUF&$ff
    136  309d		       86 4f		      stx	CURPTR
    137  309f		       a2 42		      ldx	#LINBUF>>8
    138  30a1		       86 50		      stx	CURPTR+1
    139  30a3							;
    140  30a3		       a2 00		      ldx	#0	;offset
    141  30a5		       8e 19 43    iDgetLoop  stx	getlinx
    142  30a8		       20 13 31 	      jsr	getNextFileByte
    143  30ab		       b0 16		      bcs	iGetEOF
    144  30ad		       c9 0d		      cmp	#CR
    145  30af		       f0 0d		      beq	iGetEOL
    146  30b1		       c9 0a		      cmp	#LF
    147  30b3		       f0 09		      beq	iGetEOL
    148  30b5		       ae 19 43 	      ldx	getlinx
    149  30b8		       9d 95 42 	      sta	LINBUF,x
    150  30bb		       e8		      inx
    151  30bc		       d0 e7		      bne	iDgetLoop
    152  30be							;
    153  30be							; Handle end of line.	If the line has nothing, loop
    154  30be							; back and get another line.
    155  30be							;
    156  30be		       ae 19 43    iGetEOL    ldx	getlinx	;blank line?
    157  30c1		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    158  30c3							;
    159  30c3							; This can fall through when there is a line, or
    160  30c3							; called directly when EOF is encountered.
    161  30c3							;
    162  30c3		       ae 19 43    iGetEOF    ldx	getlinx
    163  30c6		       a9 00		      lda	#0
    164  30c8		       9d 95 42 	      sta	LINBUF,x
    165  30cb		       a0 00		      ldy	#0
    166  30cd		       20 6f 2d 	      jsr	SkipSpaces
    167  30d0		       20 59 1d 	      jsr	ParseInputLine
    168  30d3		       a9 56		      lda	#TOKENBUFFER&$ff
    169  30d5		       85 4f		      sta	CURPTR
    170  30d7		       a9 1c		      lda	#TOKENBUFFER>>8
    171  30d9		       85 50		      sta	CURPTR+1
    172  30db		       a9 01		      lda	#1
    173  30dd		       85 51		      sta	CUROFF
    174  30df		       4c b1 02 	      jmp	NextIL
    175  30e2					      endif
    176  30e2
    177  30e2							;
    178  30e2							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    179  30e2							; DISK
    180  30e2							;
    181  30e2				   iDDIR
    182  30e2					      if	XKIM || CTMON65
    183  30e2		       20 30 f0 	      jsr	DiskDir
    184  30e5							;
    185  30e5							; Get/Display each entry
    186  30e5							;
    187  30e5		       a2 36	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    188  30e7		       a0 79		      ldy	#DiskFileName&$ff
    189  30e9		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    190  30ec		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    191  30ee		       20 b6 21 	      jsr	puts
      0  30f1					      db	"   ",0
      1  30f1		       20 20 20 00	      .byte.b	"   ",0
    193  30f5							; Print the line to the console
    194  30f5		       a2 36		      ldx	#DiskFileName>>8	;pointer to buffer
    195  30f7		       a0 79		      ldy	#DiskFileName&$ff
    196  30f9		       a5 00		      lda	0
    197  30fb		       20 f4 21 	      jsr	PrtStr	;else print name
    198  30fe		       20 18 f0 	      jsr	crlf
    199  3101
    200  3101		       4c e5 30 	      jmp	DiskDirLoop	;do next entry
    201  3104
    202  3104		       4c b1 02    DiskDirEnd jmp	NextIL
    203  3107					      endif
    204  3107							;
    205  3107							;=====================================================
    206  3107							; Does a LIST to a Disk file.
    207  3107							;
    208  3107				   iDLIST
    209  3107					      if	XKIM || CTMON65
    210  3107		       20 42 31 	      jsr	SetOutDisk
    211  310a		       4c 3d 08 	      jmp	iLST2
    212  310d					      endif
    213  310d							;
    214  310d							;=====================================================
    215  310d							; Closes any pending disk file.  Okay to call if there
    216  310d							; is no open file.
    217  310d							;
    218  310d				   iDCLOSE
    219  310d					      if	XKIM || CTMON65
    220  310d		       20 42 f0 	      jsr	DiskClose
    221  3110		       4c b1 02 	      jmp	NextIL
    222  3113					      endif
    223  3113							;
    224  3113							;=====================================================
    225  3113							; This gets the next byte from an open disk file.  If
    226  3113							; there are no more bytes left, this returns C set.
    227  3113							; Else, C is clear and A contains the character.
    228  3113							;
    229  3113				   getNextFileByte
    230  3113					      if	XKIM || CTMON65
    231  3113		       ae 78 36 	      ldx	diskBufOffset
    232  3116		       ec 77 36 	      cpx	diskBufLength
    233  3119		       d0 14		      bne	hasdata	;branch if still data
    234  311b							;
    235  311b							; There is no data left in the buffer, so read a
    236  311b							; block from the SD system.
    237  311b							;
    238  311b		       a9 84		      lda	#BUFFER_SIZE
    239  311d		       a2 df		      ldx	#buffer>>8
    240  311f		       a0 0a		      ldy	#buffer&$ff
    241  3121		       20 3c f0 	      jsr	DiskRead
    242  3124		       b0 12		      bcs	getNextEof
    243  3126							;
    244  3126							; A contains the number of bytes actually read.
    245  3126							;
    246  3126		       8d 77 36 	      sta	diskBufLength	;save length
    247  3129		       c9 00		      cmp	#0	;shouldn't happen
    248  312b		       f0 0b		      beq	getNextEof
    249  312d							;
    250  312d		       a2 00		      ldx	#0
    251  312f		       bd 0a df    hasdata    lda	buffer,x
    252  3132		       e8		      inx
    253  3133		       8e 78 36 	      stx	diskBufOffset
    254  3136		       18		      clc
    255  3137		       60		      rts
    256  3138							;
    257  3138		       a9 00	   getNextEof lda	#0
    258  313a		       8d 78 36 	      sta	diskBufOffset
    259  313d		       8d 77 36 	      sta	diskBufLength
    260  3140		       38		      sec
    261  3141		       60		      rts
    262  3142							;
    263  3142							;=====================================================
    264  3142							; Set output vector to the disk output function
    265  3142							;
    266  3142		       a9 4d	   SetOutDisk lda	#DOUT&$ff
    267  3144		       8d 6b 36 	      sta	BOutVec
    268  3147		       a9 31		      lda	#DOUT/256
    269  3149		       8d 6c 36 	      sta	BOutVec+1
    270  314c		       60		      rts
    271  314d							;
    272  314d							;=====================================================
    273  314d							; input a contains charater to write to open file
    274  314d							; output:
    275  314d							;	    C flag clear if no error
    276  314d							;
    277  314d		       8e 79 36    DOUT       stx	DiskFileName	; Save the x value, fulename not used
    278  3150		       8c 7a 36 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    279  3153		       8d 0a df 	      sta	buffer	; Store the byte to send into the buffer
    280  3156		       a9 01		      lda	#1	; set number of bytes to send to 1
    281  3158		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    282  315a		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    283  315c		       20 3f f0 	      jsr	DiskWrite	; Place the character to disk if a file is open
    284  315f		       ae 79 36 	      ldx	DiskFileName	; Restore the x value that was saved
    285  3162		       ac 7a 36 	      ldy	DiskFileName+1	; Restore the y value saved
    286  3165		       60		      rts
    287  3166							;=======================================================
    288  3166							; output:
    289  3166							;	  c flag is clear if no error, a contains bytes read
    290  3166							;	  c flag set Reached eof, a undefined
    291  3166							;
    292  3166		       8e 79 36    DIN	      stx	DiskFileName	; Save the x value, filename not used just storage
    293  3169		       8c 7a 36 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    294  316c		       a9 01		      lda	#1	; set number of bytes to read to 1
    295  316e		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    296  3170		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    297  3172		       20 3c f0 	      jsr	DiskRead
    298  3175		       ad 0a df 	      lda	buffer	; Get the byte just read
    299  3178		       ae 79 36 	      ldx	DiskFileName
    300  317b		       ac 7a 36 	      ldy	DiskFileName+1
    301  317e		       60		      rts
    302  317f
    303  317f							;========================================================
    304  317f							; Dstat / open/close/stat files
    305  317f				   DSTAT
    306  317f		       60		      rts
    307  3180							;========================================================
    308  3180					      endif
------- FILE mytb.asm
   2496  3180					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  3180					      include	"IL.inc"
      1  3180
      2  3180							;=====================================================
      3  3180							; IL.inc
      4  3180							; These are macros for IL instructions
      5  3180							;
      6  3180					      mac	dw
      7  3180					      .word	{0}
      8  3180					      endm
      9  3180					      mac	db
     10  3180					      .byte	{0}
     11  3180					      endm
     12  3180					      macro	xinit
     13  3180					      db	0
     14  3180					      endm		;reset the il to start clear all
     15  3180							;
     16  3180					      macro	done
     17  3180					      db	1
     18  3180					      endm		;print an error if not end of line
     19  3180							;
     20  3180					      macro	prs
     21  3180					      db	2
     22  3180					      endm		;print a quoted string
     23  3180							;
     24  3180					      macro	prn
     25  3180					      db	3
     26  3180					      endm		;print a number
     27  3180							;
     28  3180					      macro	spc
     29  3180					      db	4
     30  3180					      endm		;print space til new tabstop
     31  3180							;
     32  3180					      macro	nline
     33  3180					      db	5
     34  3180					      endm		;print a new line crlf
     35  3180							;
     36  3180							; My NXT is a bit different in that it takes one
     37  3180							; parameter, which is an address.  If the BASIC
     38  3180							; program is currently running then move to the
     39  3180							; next line and continue execution.  However, if
     40  3180							; in direct mode, jump to the specified IL label.
     41  3180							;
     42  3180					      macro	nxt
     43  3180					      db	6
     44  3180					      dw	{1}	; addr
     45  3180					      endm		; addr
     46  3180							;
     47  3180					      macro	xfer
     48  3180					      db	7
     49  3180					      endm
     50  3180							;
     51  3180					      macro	sav
     52  3180					      db	8
     53  3180					      db	{1}
     54  3180					      endm
     55  3180							;
     56  3180							;  Passed jump if function called, and true false value returned
     57  3180					      macro	rstr
     58  3180					      db	9
     59  3180					      db	({1}-*)-1	;(addr-*)-1
     60  3180					      db	{2}
     61  3180					      endm
     62  3180							;
     63  3180					      macro	cmpr
     64  3180					      db	10
     65  3180					      endm
     66  3180							;
     67  3180					      macro	innum
     68  3180					      db	11
     69  3180					      endm
     70  3180							;
     71  3180					      macro	fin
     72  3180					      db	12
     73  3180					      endm
     74  3180							;
     75  3180							; ERR is followed by an error number.	The error
     76  3180							; code is printed along with the line number.
     77  3180							; Control is passed to the statement set with
     78  3180							; the ERRGOTO statement.
     79  3180							;
     80  3180					      macro	errmsg
     81  3180					      db	13
     82  3180					      dw	{1}	;ecode
     83  3180					      endm		;ecode
     84  3180							;
     85  3180					      macro	add
     86  3180					      db	14
     87  3180					      endm
     88  3180							;
     89  3180					      macro	sub
     90  3180					      db	15
     91  3180					      endm
     92  3180							;
     93  3180					      macro	neg
     94  3180					      db	16
     95  3180					      endm
     96  3180							;
     97  3180					      macro	mul
     98  3180					      db	17
     99  3180					      endm
    100  3180							;
    101  3180					      macro	div
    102  3180					      db	18
    103  3180					      endm
    104  3180							;
    105  3180					      macro	store
    106  3180					      db	19
    107  3180					      endm
    108  3180							;
    109  3180					      macro	ind
    110  3180					      db	20
    111  3180					      endm
    112  3180							;
    113  3180					      macro	lst
    114  3180					      db	21
    115  3180					      endm
    116  3180							;
    117  3180					      macro	init
    118  3180					      db	22
    119  3180					      endm
    120  3180							;
    121  3180					      macro	getline
    122  3180					      db	23
    123  3180					      endm
    124  3180							;
    125  3180					      macro	insert
    126  3180					      db	24
    127  3180					      endm
    128  3180							;
    129  3180					      macro	rtn
    130  3180					      db	25
    131  3180					      endm
    132  3180							;
    133  3180					      macro	exit
    134  3180					      db	26
    135  3180					      endm
    136  3180							;
    137  3180					      macro	lit
    138  3180					      db	27
    139  3180					      dw	{1}	;value
    140  3180					      endm		; value LIT
    141  3180							;
    142  3180					      macro	call
    143  3180					      db	28
    144  3180					      dw	{1}	;addr
    145  3180					      endm		;addr
    146  3180							;
    147  3180							; IJMP will set the IL PC to the specified value.
    148  3180							;
    149  3180					      macro	ijmp
    150  3180					      db	29
    151  3180					      dw	{1}	;addr
    152  3180					      endm		;addr
    153  3180							;
    154  3180					      macro	vinit
    155  3180					      db	30
    156  3180					      endm
    157  3180							;
    158  3180							; ERRGOTO sets the point in the code where the IL
    159  3180							; interpreter will go after any error.
    160  3180							;
    161  3180					      macro	errgoto
    162  3180					      db	31
    163  3180					      dw	{1}	;addr
    164  3180					      endm		;addr
    165  3180							;
    166  3180					      macro	tst
    167  3180					      db	32
    168  3180					      db	({1}-*)-1	;(addr-*)-1
    169  3180					      db	{2},0	;string,0
    170  3180					      endm		;addr,string
    171  3180							;
    172  3180					      macro	tstv
    173  3180					      db	33
    174  3180					      db	({1}-*)-1	;(addr-*)-1
    175  3180					      endm		;addr
    176  3180							;
    177  3180					      macro	tstl
    178  3180					      db	34
    179  3180					      db	({1}-*)-1	;(addr-*)-1
    180  3180					      endm		;addr
    181  3180							;
    182  3180					      macro	tstn
    183  3180					      db	35
    184  3180					      db	({1}-*)-1	;(addr-*)-1
    185  3180					      endm		;addr
    186  3180							;
    187  3180							; FREE returns the amount of free RAM on top of
    188  3180							; the stack.  This is the amount of room the user
    189  3180							; program has available.
    190  3180							;
    191  3180					      macro	free
    192  3180					      db	36
    193  3180					      endm
    194  3180							;
    195  3180							; RANDOM takes the top item off the stack and
    196  3180							; replaces it with a random number that is
    197  3180							; MOD the initial value.  Ie, if the TOS is
    198  3180							; 42 then RANDOM returns a value from 0 to 41.
    199  3180							;
    200  3180					      macro	random
    201  3180					      db	37
    202  3180					      endm
    203  3180							;
    204  3180							; ABS will replace the top of stack with the
    205  3180							; absolute value.
    206  3180							;
    207  3180					      macro	abs
    208  3180					      db	38
    209  3180					      endm
    210  3180							;
    211  3180							; OPENREAD opens a file for reading, as in getting
    212  3180							; statements from it.
    213  3180							;
    214  3180					      macro	openread
    215  3180					      db	39
    216  3180					      endm
    217  3180							;
    218  3180							; OPENWRITE opens a file for writing, as in saving
    219  3180							; the current program to it.
    220  3180							;
    221  3180					      macro	openwrite
    222  3180					      db	40
    223  3180					      db	{1}	; 0= append 1 = create/truncate
    224  3180					      endm
    225  3180							;
    226  3180							; DCLOSE closes any open disk file.
    227  3180							;
    228  3180					      macro	dclose
    229  3180					      db	41
    230  3180					      endm
    231  3180							;
    232  3180							; DGETLINE gets one line from the disk file and puts it
    233  3180							; into LINBUFF.
    234  3180							;
    235  3180					      macro	dgetline
    236  3180					      db	42
    237  3180					      endm
    238  3180							;
    239  3180							; DLIST saves the program to an open disk file.
    240  3180							;
    241  3180					      macro	dlist
    242  3180					      db	43
    243  3180					      endm
    244  3180							; DDIR list the current directory
    245  3180							;
    246  3180					      macro	ddir
    247  3180					      db	44
    248  3180					      endm
    249  3180
    250  3180							; RMFILE remove a fle from disk
    251  3180					      macro	rmfile
    252  3180					      db	45
    253  3180					      endm
    254  3180
    255  3180							; CLEARSCREEN clear the screen
    256  3180					      macro	clearscreen
    257  3180					      db	46
    258  3180					      endm
    259  3180							; POKEMEM Poke value into memory
    260  3180					      macro	pokemem
    261  3180					      db	47
    262  3180					      endm
    263  3180							; PEEKMEM peek at value in memory
    264  3180					      macro	peekmem
    265  3180					      db	48
    266  3180					      endm
    267  3180							; TSTLET Test if the statement is a let without the keyword let
    268  3180					      macro	tstlet
    269  3180					      db	49
    270  3180					      db	({1}-*)-1	;(addr-*)-1
    271  3180					      endm		;addr
    272  3180							; TSTDONE if we reach the end of a statement
    273  3180					      macro	tstdone
    274  3180					      db	50
    275  3180					      db	({1}-*)-1	;(addr-*)-1
    276  3180					      endm		;addr
    277  3180							; GETCHAR	get a character from the input line leave it in RO
    278  3180					      macro	getchar
    279  3180					      db	51
    280  3180					      endm
    281  3180							; PUTCHAR	Put a character to the terminal
    282  3180					      macro	putchar
    283  3180					      db	52
    284  3180					      endm
    285  3180							; Call		Call a machine function return a to stack
    286  3180					      macro	callfunc
    287  3180					      db	53
    288  3180					      endm
    289  3180
    290  3180							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    291  3180					      macro	ibranch
    292  3180					      db	54
    293  3180					      endm
    294  3180
    295  3180							; TSTSTR	 Tests for the open quote in a string
    296  3180					      macro	tststr
    297  3180					      db	55
    298  3180					      db	({1}-*)-1	;(addr-*)-1
    299  3180					      endm
    300  3180							; SETIRQ	Sets the line number to run when an irq happens irq 550
    301  3180					      macro	setirq
    302  3180					      db	56
    303  3180					      endm
    304  3180
    305  3180							; TSTIRQ	Test for irq pending,
    306  3180							;		if so push the IRQ LINE NUMBER into RO, onto stack
    307  3180					      macro	tstirq
    308  3180					      db	57
    309  3180					      db	({1}-*)-1	;(addr-*)-1
    310  3180					      endm
    311  3180
    312  3180							; IRET    return from interupt service
    313  3180					      macro	iret
    314  3180					      db	58
    315  3180					      endm
    316  3180
    317  3180							; INSTR   read a string from the input
    318  3180					      macro	instr
    319  3180					      db	59
    320  3180					      endm
    321  3180
    322  3180							; MODULO Returns the remainder of the division
    323  3180					      macro	modulo
    324  3180					      db	60
    325  3180					      endm
    326  3180							; Set a task line
    327  3180					      macro	taskcreate
    328  3180					      db	61
    329  3180					      endm
    330  3180							; End a task
    331  3180					      macro	etask
    332  3180					      db	62
    333  3180					      endm
    334  3180							; Skip to next task
    335  3180					      macro	ntask
    336  3180					      db	63
    337  3180					      endm
    338  3180							; Subscript
    339  3180					      macro	subscript
    340  3180					      db	64
    341  3180					      db	{1}
    342  3180					      endm
    343  3180							; KILL Task
    344  3180					      macro	taskkill
    345  3180					      db	65
    346  3180					      endm
    347  3180							; STAT Task
    348  3180					      macro	taskstat
    349  3180					      db	66
    350  3180					      endm
    351  3180							;  output value as hex
    352  3180					      macro	hexprt
    353  3180					      db	67
    354  3180					      endm
    355  3180							;  Read in background has completed
    356  3180					      macro	readcomplete
    357  3180					      db	68
    358  3180					      endm
    359  3180							;  ReadInput line
    360  3180					      macro	readstart
    361  3180					      db	69
    362  3180					      endm
    363  3180							; Startio request
    364  3180					      macro	startio
    365  3180					      db	70
    366  3180					      endm
    367  3180							; Endio
    368  3180					      macro	endio
    369  3180					      db	71
    370  3180					      endm
    371  3180							; Logical not
    372  3180					      macro	lognot
    373  3180					      db	72
    374  3180					      endm
    375  3180							; Logical OR
    376  3180					      macro	logor
    377  3180					      db	73
    378  3180					      endm
    379  3180							;Logical and
    380  3180					      macro	logand
    381  3180					      db	74
    382  3180					      endm
    383  3180							;Logical XOR
    384  3180					      macro	logxor
    385  3180					      db	75
    386  3180					      endm
    387  3180							;Wait for task to complete, or list of tasks
    388  3180					      macro	wtask
    389  3180					      db	76
    390  3180					      db	({1}-*)-1	;(addr-*)-1
    391  3180					      endm
    392  3180							;Get the current task id
    393  3180					      MACRO	taskpid
    394  3180					      db	77
    395  3180					      endm
    396  3180							;Trace the basic execution
    397  3180					      Macro	traceprogram
    398  3180					      db	78
    399  3180					      endm
    400  3180							;Do a basic program Trace
    401  3180					      Macro	debugbasic
    402  3180					      db	79
    403  3180					      endm
    404  3180
    405  3180							; Inter Process communications instructions
    406  3180					      Macro	ipcsend
    407  3180					      db	80
    408  3180					      endm
    409  3180					      Macro	ipcreceive
    410  3180					      db	81
    411  3180					      endm
    412  3180					      Macro	ipccheck
    413  3180					      db	82
    414  3180					      endm
    415  3180					      Macro	ipcio
    416  3180					      db	83
    417  3180					      endm
    418  3180					      Macro	pushmathstack
    419  3180					      db	84
    420  3180					      endm
    421  3180					      Macro	popmathstack
    422  3180					      db	85
    423  3180					      endm
    424  3180					      Macro	savemathstack
    425  3180					      db	86
    426  3180					      endm
    427  3180					      Macro	restoremathstack
    428  3180					      db	87
    429  3180					      endm
    430  3180					      Macro	incparmcount
    431  3180					      db	88
    432  3180					      endm
    433  3180					      Macro	taskgetmathstack
    434  3180					      db	89
    435  3180					      endm
    436  3180					      Macro	taskenable
    437  3180					      db	90
    438  3180					      endm
    439  3180					      Macro	tasksuspend
    440  3180					      db	91
    441  3180					      endm
    442  3180					      Macro	taskputmathptr
    443  3180					      db	92
    444  3180					      endm
    445  3180							; Test for an extension type of variable that allows access to a tasks variables
    446  3180							; Using  PID!<Var name>
    447  3180					      Macro	tstvt
    448  3180					      db	93
    449  3180					      db	({1}-*)-1	;(addr-*)-1
    450  3180					      endm
    451  3180
    452  3180							; Provide access to R2 for the IL program
    453  3180					      Macro	setr2
    454  3180					      db	94
    455  3180					      db	{1}	; R2 is only one byte
    456  3180					      endm
    457  3180
    458  3180							;Move stack top to temp
    459  3180					      Macro	stk2tmp
    460  3180					      db	95
    461  3180					      endm
    462  3180
    463  3180					      Macro	tmp2stk
    464  3180					      db	96
    465  3180					      endm
    466  3180
    467  3180					      Macro	tstbyte
    468  3180					      db	97
    469  3180					      db	({1}-*)-1	; (addr-*)-1 goto if match
    470  3180					      dw	{2}	; address to check
    471  3180					      db	{3}	; Value to compare
    472  3180					      endm
    473  3180
    474  3180					      Macro	incvar
    475  3180					      db	98
    476  3180					      endm
    477  3180					      Macro	decvar
    478  3180					      db	99
    479  3180					      endm
    480  3180
    481  3180					      Macro	slice
    482  3180					      db	100
    483  3180					      endm
    484  3180
    485  3180					      Macro	tstb
    486  3180					      db	101
    487  3180					      db	({1}-*)-1
    488  3180					      db	{2}
    489  3180					      endm
    490  3180
    491  3180					      Macro	tstw
    492  3180					      db	102
    493  3180					      db	({1}-*)-1
    494  3180					      dw	{2}
    495  3180					      endm
    496  3180
    497  3180					      Macro	ongoto
    498  3180					      db	103
    499  3180					      dw	{1}
    500  3180					      dw	{2}
    501  3180					      endm
    502  3180
    503  3180					      Macro	tstrelop
    504  3180					      db	104
    505  3180					      db	({1}-*)-1
    506  3180					      endm
    507  3180
    508  3180					      Macro	repeatline
    509  3180					      db	105
    510  3180					      endm
    511  3180
    512  3180							; Check for a precompiled branch, will take branch if precompiled value present
    513  3180					      Macro	tstbranch
    514  3180					      db	106
    515  3180					      db	({1}-*)-1
    516  3180					      endm
    517  3180
    518  3180					      Macro	fastxfer
    519  3180					      db	107
    520  3180					      endm
    521  3180
    522  3180							; Set all io to to a terminal for input output
    523  3180							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    524  3180							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    525  3180					      Macro	setterminal
    526  3180					      db	108
    527  3180					      endm
    528  3180
    529  3180							;Fetch a single byte from memory
    530  3180					      Macro	indb
    531  3180					      db	109
    532  3180					      endm
    533  3180
    534  3180							; Set a block of memory to a fixed value, byte or word
    535  3180							; Stack must contain destiniation address, length to set in bytes, value {byte of word} to initialize to
    536  3180					      Macro	setblock
    537  3180					      db	110
    538  3180					      db	{1}	; the data type to initialize	tByte or tInteger
    539  3180					      endm
    540  3180
    541  3180							; Copy a block of memory
    542  3180							; Stack must contain source address, destination address, length in bytes
    543  3180					      Macro	copyblock
    544  3180					      db	111
    545  3180					      endm
    546  3180
    547  3180							; Compare one block of memory to another
    548  3180							; Stack contains Length, Source1 Source 2
    549  3180							; Place on stack 0 equal, 1 s1>s2, -1 s1 < s2
    550  3180					      Macro	cmpmem
    551  3180					      db	112
    552  3180					      endm
    553  3180
    554  3180							; Shift Left and Right
    555  3180					      Macro	shift
    556  3180					      db	113
    557  3180					      db	{1}	; direction  0 = left 1 = right
    558  3180					      endm
    559  3180
    560  3180							; set of timer macros
    561  3180					      Macro	timerset
    562  3180					      db	114,1
    563  3180					      db	{1}	; value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    564  3180					      endm
    565  3180
    566  3180					      Macro	timerstop
    567  3180					      db	114,0,0
    568  3180					      endm
    569  3180
    570  3180					      Macro	timervaluelow
    571  3180					      db	114,2,0
    572  3180					      endm
    573  3180
    574  3180					      Macro	timervaluehigh
    575  3180					      db	114,3,0
    576  3180					      endm
    577  3180
    578  3180					      Macro	timer
    579  3180					      db	114
    580  3180					      endm
------- FILE mytb.asm
   2498  3180							;
   2499  3180				  -	      if	FIXED
   2500  3180				  -	      org	$1000
   2501  3180					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  3180					      include	"basic.il"
      1  3180					      seg	Code
      2  3180							; on goto table
      3  3180							; format :   first byte is value Base, subtracted from value found
      4  3180							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  3180				   BasicStmts
      0  3180					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  3180		       01 23		      .byte.b	kBeginKey,(kKeyCount+1)
      0  3182					      dw	ekLet
      1  3182		       0f 32		      .word.w	ekLet
      0  3184					      dw	ekInc
      1  3184		       41 32		      .word.w	ekInc
      0  3186					      dw	ekDec
      1  3186		       4e 32		      .word.w	ekDec
      0  3188					      dw	ekIreturn
      1  3188		       5b 32		      .word.w	ekIreturn
      0  318a					      dw	ekIf
      1  318a		       60 32		      .word.w	ekIf
      0  318c					      dw	ekThen
      1  318c		       66 32		      .word.w	ekThen
      0  318e					      dw	ekGoto
      1  318e		       6a 32		      .word.w	ekGoto
      0  3190					      dw	ekGosub
      1  3190		       0d 36		      .word.w	ekGosub
      0  3192					      dw	ekReturn
      1  3192		       1b 36		      .word.w	ekReturn
      0  3194					      dw	ekRem
      1  3194		       7e 32		      .word.w	ekRem
      0  3196					      dw	ekPrint	; should be entry for print
      1  3196		       94 32		      .word.w	ekPrint
      0  3198					      dw	ekTaske
      1  3198		       e1 32		      .word.w	ekTaske
      0  319a					      dw	ekTaskn
      1  319a		       f7 32		      .word.w	ekTaskn
      0  319c					      dw	ekTaskw
      1  319c		       fe 32		      .word.w	ekTaskw
      0  319e					      dw	ekPoke
      1  319e		       19 33		      .word.w	ekPoke
      0  31a0					      dw	ekPutch
      1  31a0		       7b 33		      .word.w	ekPutch
      0  31a2					      dw	ekCls
      1  31a2		       86 33		      .word.w	ekCls
      0  31a4					      dw	ekInput
      1  31a4		       8d 33		      .word.w	ekInput
      0  31a6					      dw	ekEnd
      1  31a6		       bb 33		      .word.w	ekEnd
      0  31a8					      dw	ekIrq
      1  31a8		       bf 33		      .word.w	ekIrq
      0  31aa					      dw	ekKill
      1  31aa		       ca 33		      .word.w	ekKill
      0  31ac					      dw	ekList
      1  31ac		       d5 33		      .word.w	ekList
      0  31ae					      dw	ekRun
      1  31ae		       da 33		      .word.w	ekRun
      0  31b0					      dw	ekNew
      1  31b0		       e3 33		      .word.w	ekNew
      0  31b2					      dw	ekSlice
      1  31b2		       e7 33		      .word.w	ekSlice
      0  31b4					      dw	ekTrace
      1  31b4		       f2 33		      .word.w	ekTrace
      0  31b6					      dw	ekExit
      1  31b6		       03 34		      .word.w	ekExit
      0  31b8					      dw	ekSave
      1  31b8		       04 34		      .word.w	ekSave
      0  31ba					      dw	ekLoad
      1  31ba		       0b 34		      .word.w	ekLoad
      0  31bc					      dw	ekErase
      1  31bc		       1b 34		      .word.w	ekErase
      0  31be					      dw	ekDir
      1  31be		       17 34		      .word.w	ekDir
      0  31c0					      dw	ekSetTerm
      1  31c0		       84 32		      .word.w	ekSetTerm
      0  31c2					      dw	ekSetMemB
      1  31c2		       30 33		      .word.w	ekSetMemB
      0  31c4					      dw	ekSetMemW
      1  31c4		       3c 33		      .word.w	ekSetMemW
      0  31c6					      dw	ekCopyMem
      1  31c6		       5e 33		      .word.w	ekCopyMem
     42  31c8							;
     43  31c8							; Logical operators
      0  31c8				   BasicLogical db	kOr,3
      1  31c8		       25 03		      .byte.b	kOr,3
      0  31ca					      dw	ekOr
      1  31ca		       50 34		      .word.w	ekOr
      0  31cc					      dw	ekXor
      1  31cc		       55 34		      .word.w	ekXor
      0  31ce					      dw	ekAnd
      1  31ce		       4b 34		      .word.w	ekAnd
     48  31d0
      0  31d0				   BasicShift db	kShr,2
      1  31d0		       28 02		      .byte.b	kShr,2
      0  31d2					      dw	ekShiftRight
      1  31d2		       40 34		      .word.w	ekShiftRight
      0  31d4					      dw	ekShiftLeft
      1  31d4		       3a 34		      .word.w	ekShiftLeft
     52  31d6
     53  31d6							;functions returning values
     54  31d6
      0  31d6				   BasicFuncs db	kBeginFunc,kFuncCount
      1  31d6		       2a 12		      .byte.b	kBeginFunc,kFuncCount
      0  31d8					      dw	ekTrue
      1  31d8		       aa 34		      .word.w	ekTrue
      0  31da					      dw	ekFalse
      1  31da		       ae 34		      .word.w	ekFalse
      0  31dc					      dw	ekFree
      1  31dc		       b2 34		      .word.w	ekFree
      0  31de					      dw	ekGetch
      1  31de		       ba 34		      .word.w	ekGetch
      0  31e0					      dw	ekPeek
      1  31e0		       ff 34		      .word.w	ekPeek
      0  31e2					      dw	ekTask
      1  31e2		       0a 35		      .word.w	ekTask
      0  31e4					      dw	ekIpcc
      1  31e4		       56 35		      .word.w	ekIpcc
      0  31e6					      dw	ekIpcs
      1  31e6		       31 35		      .word.w	ekIpcs
      0  31e8					      dw	ekIpcr
      1  31e8		       42 35		      .word.w	ekIpcr
      0  31ea					      dw	ekRnd
      1  31ea		       61 35		      .word.w	ekRnd
      0  31ec					      dw	ekStat
      1  31ec		       7f 35		      .word.w	ekStat
      0  31ee					      dw	ekAbs
      1  31ee		       74 35		      .word.w	ekAbs
      0  31f0					      dw	ekCall
      1  31f0		       8c 35		      .word.w	ekCall
      0  31f2					      dw	ekGofn
      1  31f2		       14 36		      .word.w	ekGofn
      0  31f4					      dw	ekPid
      1  31f4		       8a 35		      .word.w	ekPid
      0  31f6					      dw	ekAddr
      1  31f6		       c2 34		      .word.w	ekAddr
      0  31f8					      dw	ekCmpMem
      1  31f8		       d1 34		      .word.w	ekCmpMem
      0  31fa					      dw	eKTimer
      1  31fa		       e8 34		      .word.w	eKTimer
     74  31fc							;====================================================
     75  31fc							; file constants
     76  31fc		       00 00	   OPEN_APPEND equ	0	; append to file
     77  31fc		       00 01	   OPEN_CREATE equ	1	; truncate/create file
     78  31fc
     79  31fc							;=====================================================
     80  31fc							; This is the IL of the BASIC (or whatever) language.
     81  31fc							; Because of the way macros are implemented by as65,
     82  31fc							; labels can't be on the same line as a macro
     83  31fc							; invocation, so that's why labels are on separate
     84  31fc							; lines.
     85  31fc							;
     86  31fc		       31 fc	   IL	      equ	*
     87  31fc
     88  31fc							;THE IL CONTROL SECTION
     89  31fc
     90  31fc				   START
      0  31fc					      INIT		;INITIALIZE
      0  31fc					      db	22
      1  31fc		       16		      .byte.b	22
      0  31fd					      NLINE		;WRITE CRLF
      0  31fd					      db	5
      1  31fd		       05		      .byte.b	5
      0  31fe					      ERRGOTO	CO	;where to go after an error
      0  31fe					      db	31
      1  31fe		       1f		      .byte.b	31
      0  31ff					      dw	CO
      1  31ff		       02 32		      .word.w	CO
      0  3201					      VINIT		;clear all variables
      0  3201					      db	30
      1  3201		       1e		      .byte.b	30
     95  3202							;
     96  3202							; This is where we jump to get a line of commands or
     97  3202							; a program from the user.
     98  3202							;
     99  3202				   CO
      0  3202					      GETLINE		;WRITE PROMPT AND GET LINE
      0  3202					      db	23
      1  3202		       17		      .byte.b	23
      0  3203					      TSTL	XEC	;TEST FOR LINE NUMBER, if none then execute the line
      0  3203					      db	34
      1  3203		       22		      .byte.b	34
      0  3204					      db	(XEC-*)-1
      1  3204		       04		      .byte.b	(XEC-*)-1
      0  3205					      INSERT		;INSERT IT (MAY BE DELETE)
      0  3205					      db	24
      1  3205		       18		      .byte.b	24
      0  3206					      IJMP	CO
      0  3206					      db	29
      1  3206		       1d		      .byte.b	29
      0  3207					      dw	CO
      1  3207		       02 32		      .word.w	CO
    104  3209				   XEC
      0  3209					      XINIT		;INITIALIZE
      0  3209					      db	0
      1  3209		       00		      .byte.b	0
    106  320a							;============================================================================
    107  320a							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
    108  320a							;
    109  320a				   STMT
      0  320a					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  320a					      db	57
      1  320a		       39		      .byte.b	57
      0  320b					      db	(notirq-*)-1
      1  320b		       00		      .byte.b	(notirq-*)-1
    111  320c							;==========================================================================================
    112  320c							; Process a let statement implied or explicit.
    113  320c							;
    114  320c				   notirq
      0  320c					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  320c					      db	79
      1  320c		       4f		      .byte.b	79
      0  320d					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  320d					      db	49
      1  320d		       31		      .byte.b	49
      0  320e					      db	(DoVector-*)-1
      1  320e		       2d		      .byte.b	(DoVector-*)-1
    117  320f				   ekLet
      0  320f					      TSTV	DoVector	; Test for variable
      0  320f					      db	33
      1  320f		       21		      .byte.b	33
      0  3210					      db	(DoVector-*)-1
      1  3210		       2b		      .byte.b	(DoVector-*)-1
      0  3211					      CALL	FactVarPtrNoTst	; get a pointer to the variable
      0  3211					      db	28
      1  3211		       1c		      .byte.b	28
      0  3212					      dw	FactVarPtrNoTst
      1  3212		       d3 35		      .word.w	FactVarPtrNoTst
    120  3214
    121  3214				   LETINDEX_ALL
      0  3214					      TSTB	ERRMissingEquals,oEqual	; (This line originally omitted)
      0  3214					      db	101
      1  3214		       65		      .byte.b	101
      0  3215					      db	(ERRMissingEquals-*)-1
      1  3215		       20		      .byte.b	(ERRMissingEquals-*)-1
      0  3216					      db	oEqual
      1  3216		       f2		      .byte.b	oEqual
    123  3217				   LETBE
      0  3217					      TSTBYTE	LETAssignByte,R2,tByte	; Check for a byte conversion
      0  3217					      db	97
      1  3217		       61		      .byte.b	97
      0  3218					      db	(LETAssignByte-*)-1
      1  3218		       10		      .byte.b	(LETAssignByte-*)-1
      0  3219					      dw	R2
      1  3219		       58 00		      .word.w	R2
      0  321b					      db	tByte
      1  321b		       a2		      .byte.b	tByte
      0  321c					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  321c					      db	28
      1  321c		       1c		      .byte.b	28
      0  321d					      dw	EXPR
      1  321d		       23 34		      .word.w	EXPR
      0  321f					      DONE		; REPORT ERROR IF NOT NEXT
      0  321f					      db	1
      1  321f		       01		      .byte.b	1
      0  3220					      SETR2	tInteger	; Store an integer type
      0  3220					      db	94
      1  3220		       5e		      .byte.b	94
      0  3221					      db	tInteger
      1  3221		       a4		      .byte.b	tInteger
      0  3222					      STORE		; STORE RESULT at variable address
      0  3222					      db	19
      1  3222		       13		      .byte.b	19
      0  3223					      NXT	CO	; AND SEQUENCE TO NEXT
      0  3223					      db	6
      1  3223		       06		      .byte.b	6
      0  3224					      dw	CO
      1  3224		       02 32		      .word.w	CO
      0  3226					      IJMP	STMT	; Next statement
      0  3226					      db	29
      1  3226		       1d		      .byte.b	29
      0  3227					      dw	STMT
      1  3227		       0a 32		      .word.w	STMT
    131  3229
    132  3229				   LETAssignByte
      0  3229					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  3229					      db	28
      1  3229		       1c		      .byte.b	28
      0  322a					      dw	EXPR
      1  322a		       23 34		      .word.w	EXPR
      0  322c					      DONE		; REPORT ERROR IF NOT NEXT
      0  322c					      db	1
      1  322c		       01		      .byte.b	1
      0  322d					      SETR2	tByte	; Set to store a byte value
      0  322d					      db	94
      1  322d		       5e		      .byte.b	94
      0  322e					      db	tByte
      1  322e		       a2		      .byte.b	tByte
      0  322f					      STORE		; STORE RESULT at variable address
      0  322f					      db	19
      1  322f		       13		      .byte.b	19
      0  3230					      NXT	CO	; AND SEQUENCE TO NEXT
      0  3230					      db	6
      1  3230		       06		      .byte.b	6
      0  3231					      dw	CO
      1  3231		       02 32		      .word.w	CO
      0  3233					      IJMP	STMT	; Next statement
      0  3233					      db	29
      1  3233		       1d		      .byte.b	29
      0  3234					      dw	STMT
      1  3234		       0a 32		      .word.w	STMT
    139  3236
    140  3236				   ERRMissingEquals
      0  3236					      ERRMSG	ERR_MISSINGEQUALSIGN	; Missing asignment
      0  3236					      db	13
      1  3236		       0d		      .byte.b	13
      0  3237					      dw	ERR_MISSINGEQUALSIGN
      1  3237		       18 00		      .word.w	ERR_MISSINGEQUALSIGN
    142  3239
    143  3239				   ERRVEC2
      0  3239					      IJMP	UNKNOWN
      0  3239					      db	29
      1  3239		       1d		      .byte.b	29
      0  323a					      dw	UNKNOWN
      1  323a		       1f 34		      .word.w	UNKNOWN
    145  323c							;=============================================================
    146  323c							;Branch on a valid statement start
    147  323c				   DoVector
      0  323c					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  323c					      db	103
      1  323c		       67		      .byte.b	103
      0  323d					      dw	BasicStmts
      1  323d		       80 31		      .word.w	BasicStmts
      0  323f					      dw	UNKNOWN
      1  323f		       1f 34		      .word.w	UNKNOWN
    149  3241							;This will never return here!
    150  3241							;=============================================================
    151  3241							; Inc or dec a variable
    152  3241				   ekInc
      0  3241					      TSTV	ERRVEC2	; Verify we have a variable
      0  3241					      db	33
      1  3241		       21		      .byte.b	33
      0  3242					      db	(ERRVEC2-*)-1
      1  3242		       f6		      .byte.b	(ERRVEC2-*)-1
      0  3243					      CALL	FactVarPtrNoTst	; Get a pointer to the memory location to increment
      0  3243					      db	28
      1  3243		       1c		      .byte.b	28
      0  3244					      dw	FactVarPtrNoTst
      1  3244		       d3 35		      .word.w	FactVarPtrNoTst
    155  3246							;	  TSTB	     eDoInc,oBang		    ; Allow to inc or dec other tasks variables
    156  3246							;	  IND					    ; we just got a pid
    157  3246							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    158  3246				   eDoInc
      0  3246					      INCVAR		; Do the increment of the variable
      0  3246					      db	98
      1  3246		       62		      .byte.b	98
      0  3247					      DONE		; Test for end of line or end of statement ":"
      0  3247					      db	1
      1  3247		       01		      .byte.b	1
      0  3248					      NXT	CO	; Get the next statement, branch CO if end of program
      0  3248					      db	6
      1  3248		       06		      .byte.b	6
      0  3249					      dw	CO
      1  3249		       02 32		      .word.w	CO
      0  324b					      IJMP	STMT	; Process the next statement
      0  324b					      db	29
      1  324b		       1d		      .byte.b	29
      0  324c					      dw	STMT
      1  324c		       0a 32		      .word.w	STMT
    163  324e							;S1Dec:
    164  324e							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    165  324e				   ekDec
      0  324e					      TSTV	ERRVEC2	; Must be followed by a variable
      0  324e					      db	33
      1  324e		       21		      .byte.b	33
      0  324f					      db	(ERRVEC2-*)-1
      1  324f		       e9		      .byte.b	(ERRVEC2-*)-1
      0  3250					      CALL	FactVarPtrNoTst	; Get a pointer to the variable to update
      0  3250					      db	28
      1  3250		       1c		      .byte.b	28
      0  3251					      dw	FactVarPtrNoTst
      1  3251		       d3 35		      .word.w	FactVarPtrNoTst
    168  3253							;	  TSTB	     eDoDec,oBang		    ; Allow to inc or dec other tasks variables
    169  3253							;	  IND					    ; we just got a pid
    170  3253							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    171  3253				   eDoDec
      0  3253					      DECVAR		; Decrement the actual variable
      0  3253					      db	99
      1  3253		       63		      .byte.b	99
      0  3254					      DONE		; Test if end of line or : statement
      0  3254					      db	1
      1  3254		       01		      .byte.b	1
      0  3255					      NXT	CO	; If at end of program then got the console
      0  3255					      db	6
      1  3255		       06		      .byte.b	6
      0  3256					      dw	CO
      1  3256		       02 32		      .word.w	CO
      0  3258					      IJMP	STMT	; Process the next statement of command line
      0  3258					      db	29
      1  3258		       1d		      .byte.b	29
      0  3259					      dw	STMT
      1  3259		       0a 32		      .word.w	STMT
    176  325b							;=============================================================================================================================
    177  325b							; iret or ireturn, Return from interupt process
    178  325b							;
    179  325b							;S1Iret:
    180  325b							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    181  325b							;S1Sa:
    182  325b				   ekIreturn
      0  325b					      DONE		; Must be only thing on the line
      0  325b					      db	1
      1  325b		       01		      .byte.b	1
      0  325c					      IRET		; RESTORE LINE NUMBER OF CALL
      0  325c					      db	58
      1  325c		       3a		      .byte.b	58
      0  325d					      IJMP	STMT
      0  325d					      db	29
      1  325d		       1d		      .byte.b	29
      0  325e					      dw	STMT
      1  325e		       0a 32		      .word.w	STMT
    186  3260							;==============================================================================================================================
    187  3260							;Process if statement, if true then process all statements until end of line reached
    188  3260							;S1S1:
    189  3260							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    190  3260				   ekIf
      0  3260					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  3260					      db	28
      1  3260		       1c		      .byte.b	28
      0  3261					      dw	EXPR
      1  3261		       23 34		      .word.w	EXPR
      0  3263					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  3263					      db	101
      1  3263		       65		      .byte.b	101
      0  3264					      db	(S1W-*)-1
      1  3264		       01		      .byte.b	(S1W-*)-1
      0  3265					      db	kThen
      1  3265		       06		      .byte.b	kThen
    193  3266				   ekThen
    194  3266				   S1W
      0  3266					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  3266					      db	54
      1  3266		       36		      .byte.b	54
      0  3267					      IJMP	STMT
      0  3267					      db	29
      1  3267		       1d		      .byte.b	29
      0  3268					      dw	STMT
      1  3268		       0a 32		      .word.w	STMT
    197  326a							;===============================================================================================================================
    198  326a							; Test for GOTO
    199  326a							;S1Z:
    200  326a							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    201  326a							;
    202  326a				   ekGoto
      0  326a					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  326a					      db	106
      1  326a		       6a		      .byte.b	106
      0  326b					      db	(ekGotoCompiled-*)-1
      1  326b		       0e		      .byte.b	(ekGotoCompiled-*)-1
    204  326c							; Else we have the address and just goto that address
      0  326c					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  326c					      db	101
      1  326c		       65		      .byte.b	101
      0  326d					      db	(ekGotoLine-*)-1
      1  326d		       05		      .byte.b	(ekGotoLine-*)-1
      0  326e					      db	oPeriod
      1  326e		       e9		      .byte.b	oPeriod
      0  326f					      REPEATLINE		; Repeat the same line again
      0  326f					      db	105
      1  326f		       69		      .byte.b	105
      0  3270					      IJMP	STMT	; Go do the statement
      0  3270					      db	29
      1  3270		       1d		      .byte.b	29
      0  3271					      dw	STMT
      1  3271		       0a 32		      .word.w	STMT
    208  3273
    209  3273				   ekGotoLine
      0  3273					      CALL	EXPR	; GET LABEL
      0  3273					      db	28
      1  3273		       1c		      .byte.b	28
      0  3274					      dw	EXPR
      1  3274		       23 34		      .word.w	EXPR
      0  3276					      lit	0	; Place indicator for line num on stack
      0  3276					      db	27
      1  3276		       1b		      .byte.b	27
      0  3277					      dw	0
      1  3277		       00 00		      .word.w	0
      0  3279					      FASTXFER
      0  3279					      db	107
      1  3279		       6b		      .byte.b	107
    213  327a				   ekGotoCompiled
      0  327a					      lit	1	; tell it that mempointer on the stack
      0  327a					      db	27
      1  327a		       1b		      .byte.b	27
      0  327b					      dw	1
      1  327b		       01 00		      .word.w	1
      0  327d					      FASTXFER		; put top of stack into curptr
      0  327d					      db	107
      1  327d		       6b		      .byte.b	107
    216  327e
    217  327e
    218  327e							;==================================================================================================================================
    219  327e							; Process REM statement
    220  327e							;
    221  327e							;S2a:
    222  327e							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    223  327e				   ekRem
      0  327e					      NXT	CO	; The rest of the line is ignored
      0  327e					      db	6
      1  327e		       06		      .byte.b	6
      0  327f					      dw	CO
      1  327f		       02 32		      .word.w	CO
      0  3281					      IJMP	STMT	; Process the next statement
      0  3281					      db	29
      1  3281		       1d		      .byte.b	29
      0  3282					      dw	STMT
      1  3282		       0a 32		      .word.w	STMT
    226  3284							;====================================================================================================================================
    227  3284							; Set the Task input output slot each slot is 16 byte starting at e000
    228  3284							; so 0,1,...
    229  3284				   ekSetTerm
      0  3284					      CALL	EXPR
      0  3284					      db	28
      1  3284		       1c		      .byte.b	28
      0  3285					      dw	EXPR
      1  3285		       23 34		      .word.w	EXPR
      0  3287					      TSTB	ERRVEC,oComma
      0  3287					      db	101
      1  3287		       65		      .byte.b	101
      0  3288					      db	(ERRVEC-*)-1
      1  3288		       2f		      .byte.b	(ERRVEC-*)-1
      0  3289					      db	oComma
      1  3289		       e2		      .byte.b	oComma
      0  328a					      CALL	EXPR
      0  328a					      db	28
      1  328a		       1c		      .byte.b	28
      0  328b					      dw	EXPR
      1  328b		       23 34		      .word.w	EXPR
      0  328d					      SETTERMINAL
      0  328d					      db	108
      1  328d		       6c		      .byte.b	108
      0  328e					      NXT	CO	;Next statement to execute
      0  328e					      db	6
      1  328e		       06		      .byte.b	6
      0  328f					      dw	CO
      1  328f		       02 32		      .word.w	CO
      0  3291					      IJMP	STMT
      0  3291					      db	29
      1  3291		       1d		      .byte.b	29
      0  3292					      dw	STMT
      1  3292		       0a 32		      .word.w	STMT
    236  3294							;==================================================================================================================================
    237  3294							; Print statement
    238  3294							;
    239  3294							;S3:
    240  3294							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    241  3294				   ekPrint
      0  3294					      STARTIO		; Lock task until io completes
      0  3294					      db	70
      1  3294		       46		      .byte.b	70
    243  3295				   S4
      0  3295					      TSTDONE	S4a	; Test if we just want crlf printed
      0  3295					      db	50
      1  3295		       32		      .byte.b	50
      0  3296					      db	(S4a-*)-1
      1  3296		       03		      .byte.b	(S4a-*)-1
      0  3297					      IJMP	S6
      0  3297					      db	29
      1  3297		       1d		      .byte.b	29
      0  3298					      dw	S6
      1  3298		       af 32		      .word.w	S6
    246  329a
    247  329a				   S4a
      0  329a					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  329a					      db	101
      1  329a		       65		      .byte.b	101
      0  329b					      db	(S7-*)-1
      1  329b		       1f		      .byte.b	(S7-*)-1
      0  329c					      db	tString
      1  329c		       a0		      .byte.b	tString
      0  329d					      PRS		; PRINT STRING
      0  329d					      db	2
      1  329d		       02		      .byte.b	2
    250  329e				   S5
      0  329e					      TSTB	S6A,oComma	; IS THERE MORE?
      0  329e					      db	101
      1  329e		       65		      .byte.b	101
      0  329f					      db	(S6A-*)-1
      1  329f		       07		      .byte.b	(S6A-*)-1
      0  32a0					      db	oComma
      1  32a0		       e2		      .byte.b	oComma
      0  32a1					      SPC		; SPACE TO NEXT ZONE
      0  32a1					      db	4
      1  32a1		       04		      .byte.b	4
      0  32a2					      TSTDONE	S4	; Not end of line jump back
      0  32a2					      db	50
      1  32a2		       32		      .byte.b	50
      0  32a3					      db	(S4-*)-1
      1  32a3		       f1		      .byte.b	(S4-*)-1
      0  32a4					      IJMP	S6Z	; YES JUMP BACK
      0  32a4					      db	29
      1  32a4		       1d		      .byte.b	29
      0  32a5					      dw	S6Z
      1  32a5		       b1 32		      .word.w	S6Z
    255  32a7
    256  32a7							;
    257  32a7							; If a semicolon, don't do anything.
    258  32a7							;
    259  32a7				   S6A
      0  32a7					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  32a7					      db	101
      1  32a7		       65		      .byte.b	101
      0  32a8					      db	(S6-*)-1
      1  32a8		       06		      .byte.b	(S6-*)-1
      0  32a9					      db	oSemiColon
      1  32a9		       e3		      .byte.b	oSemiColon
      0  32aa					      TSTDONE	S4	; Jump Back if not end of line
      0  32aa					      db	50
      1  32aa		       32		      .byte.b	50
      0  32ab					      db	(S4-*)-1
      1  32ab		       e9		      .byte.b	(S4-*)-1
      0  32ac					      IJMP	S6Z
      0  32ac					      db	29
      1  32ac		       1d		      .byte.b	29
      0  32ad					      dw	S6Z
      1  32ad		       b1 32		      .word.w	S6Z
    263  32af
    264  32af				   S6
    265  32af
      0  32af					      DONE		; ERROR IF CR NOT NEXT
      0  32af					      db	1
      1  32af		       01		      .byte.b	1
      0  32b0					      NLINE
      0  32b0					      db	5
      1  32b0		       05		      .byte.b	5
    268  32b1				   S6Z
      0  32b1					      ENDIO		; release task io completed
      0  32b1					      db	71
      1  32b1		       47		      .byte.b	71
      0  32b2					      NXT	CO	; exit here if , or ; at end of print
      0  32b2					      db	6
      1  32b2		       06		      .byte.b	6
      0  32b3					      dw	CO
      1  32b3		       02 32		      .word.w	CO
      0  32b5					      IJMP	STMT
      0  32b5					      db	29
      1  32b5		       1d		      .byte.b	29
      0  32b6					      dw	STMT
      1  32b6		       0a 32		      .word.w	STMT
    272  32b8							;
    273  32b8							; A jump for code too far away for relative branch
    274  32b8							;
    275  32b8				   ERRVEC
      0  32b8					      IJMP	UNKNOWN
      0  32b8					      db	29
      1  32b8		       1d		      .byte.b	29
      0  32b9					      dw	UNKNOWN
      1  32b9		       1f 34		      .word.w	UNKNOWN
    277  32bb							;
    278  32bb							; Get here if there is an expression to print
    279  32bb				   S7
      0  32bb					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  32bb					      db	101
      1  32bb		       65		      .byte.b	101
      0  32bc					      db	(S7AUnsigned-*)-1
      1  32bc		       08		      .byte.b	(S7AUnsigned-*)-1
      0  32bd					      db	oDollar
      1  32bd		       e7		      .byte.b	oDollar
      0  32be					      CALL	EXPR
      0  32be					      db	28
      1  32be		       1c		      .byte.b	28
      0  32bf					      dw	EXPR
      1  32bf		       23 34		      .word.w	EXPR
      0  32c1					      HEXPRT
      0  32c1					      db	67
      1  32c1		       43		      .byte.b	67
      0  32c2					      IJMP	S5
      0  32c2					      db	29
      1  32c2		       1d		      .byte.b	29
      0  32c3					      dw	S5
      1  32c3		       9e 32		      .word.w	S5
    284  32c5
    285  32c5				   S7AUnsigned
    286  32c5
      0  32c5					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  32c5					      db	101
      1  32c5		       65		      .byte.b	101
      0  32c6					      db	(S7A-*)-1
      1  32c6		       0a		      .byte.b	(S7A-*)-1
      0  32c7					      db	oPercent
      1  32c7		       ed		      .byte.b	oPercent
      0  32c8					      CALL	EXPR
      0  32c8					      db	28
      1  32c8		       1c		      .byte.b	28
      0  32c9					      dw	EXPR
      1  32c9		       23 34		      .word.w	EXPR
      0  32cb					      SETR2	tUint
      0  32cb					      db	94
      1  32cb		       5e		      .byte.b	94
      0  32cc					      db	tUint
      1  32cc		       a9		      .byte.b	tUint
      0  32cd					      PRN
      0  32cd					      db	3
      1  32cd		       03		      .byte.b	3
      0  32ce					      IJMP	S5
      0  32ce					      db	29
      1  32ce		       1d		      .byte.b	29
      0  32cf					      dw	S5
      1  32cf		       9e 32		      .word.w	S5
    292  32d1
    293  32d1				   S7A
    294  32d1
      0  32d1					      CALL	EXPR
      0  32d1					      db	28
      1  32d1		       1c		      .byte.b	28
      0  32d2					      dw	EXPR
      1  32d2		       23 34		      .word.w	EXPR
      0  32d4					      TSTB	S7B,oDollar	; Print the value as a single character
      0  32d4					      db	101
      1  32d4		       65		      .byte.b	101
      0  32d5					      db	(S7B-*)-1
      1  32d5		       05		      .byte.b	(S7B-*)-1
      0  32d6					      db	oDollar
      1  32d6		       e7		      .byte.b	oDollar
      0  32d7					      PUTCHAR
      0  32d7					      db	52
      1  32d7		       34		      .byte.b	52
      0  32d8					      IJMP	S5
      0  32d8					      db	29
      1  32d8		       1d		      .byte.b	29
      0  32d9					      dw	S5
      1  32d9		       9e 32		      .word.w	S5
    299  32db
    300  32db				   S7B
      0  32db					      SETR2	tInteger	; Print the value as a signed number
      0  32db					      db	94
      1  32db		       5e		      .byte.b	94
      0  32dc					      db	tInteger
      1  32dc		       a4		      .byte.b	tInteger
      0  32dd					      PRN		; PRINT IT
      0  32dd					      db	3
      1  32dd		       03		      .byte.b	3
      0  32de					      IJMP	S5	; IS THERE MORE?
      0  32de					      db	29
      1  32de		       1d		      .byte.b	29
      0  32df					      dw	S5
      1  32df		       9e 32		      .word.w	S5
    304  32e1							;
    305  32e1							;===========================================================
    306  32e1							; PROCESS ALL THE TASK STATEMENTS
    307  32e1							;
    308  32e1							;S8:
    309  32e1							;	  TSTB	      S8G,kTaske		 ; End Task
    310  32e1				   ekTaske
      0  32e1					      TSTB	S8NoParm,oLeftBracket
      0  32e1					      db	101
      1  32e1		       65		      .byte.b	101
      0  32e2					      db	(S8NoParm-*)-1
      1  32e2		       0c		      .byte.b	(S8NoParm-*)-1
      0  32e3					      db	oLeftBracket
      1  32e3		       e0		      .byte.b	oLeftBracket
      0  32e4					      CALL	EXPR
      0  32e4					      db	28
      1  32e4		       1c		      .byte.b	28
      0  32e5					      dw	EXPR
      1  32e5		       23 34		      .word.w	EXPR
      0  32e7					      TSTB	UNKNOWNLnk,oRightBracket
      0  32e7					      db	101
      1  32e7		       65		      .byte.b	101
      0  32e8					      db	(UNKNOWNLnk-*)-1
      1  32e8		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  32e9					      db	oRightBracket
      1  32e9		       e1		      .byte.b	oRightBracket
      0  32ea					      ETASK
      0  32ea					      db	62
      1  32ea		       3e		      .byte.b	62
      0  32eb					      DONE
      0  32eb					      db	1
      1  32eb		       01		      .byte.b	1
      0  32ec					      IJMP	STMT
      0  32ec					      db	29
      1  32ec		       1d		      .byte.b	29
      0  32ed					      dw	STMT
      1  32ed		       0a 32		      .word.w	STMT
    317  32ef				   S8NoParm
      0  32ef					      LIT	0
      0  32ef					      db	27
      1  32ef		       1b		      .byte.b	27
      0  32f0					      dw	0
      1  32f0		       00 00		      .word.w	0
      0  32f2					      ETASK
      0  32f2					      db	62
      1  32f2		       3e		      .byte.b	62
      0  32f3					      DONE		; Must be last thing on a line
      0  32f3					      db	1
      1  32f3		       01		      .byte.b	1
      0  32f4					      IJMP	STMT
      0  32f4					      db	29
      1  32f4		       1d		      .byte.b	29
      0  32f5					      dw	STMT
      1  32f5		       0a 32		      .word.w	STMT
    322  32f7							;
    323  32f7							;===========================================================
    324  32f7							; The task gives up the rest of the cycles
    325  32f7							;S8G:
    326  32f7							;	  TSTB	      S8a,kTaskn	 ;Next task
    327  32f7				   ekTaskn
      0  32f7					      NTASK
      0  32f7					      db	63
      1  32f7		       3f		      .byte.b	63
      0  32f8					      NXT	CO	;Next statement to execute
      0  32f8					      db	6
      1  32f8		       06		      .byte.b	6
      0  32f9					      dw	CO
      1  32f9		       02 32		      .word.w	CO
      0  32fb					      IJMP	STMT
      0  32fb					      db	29
      1  32fb		       1d		      .byte.b	29
      0  32fc					      dw	STMT
      1  32fc		       0a 32		      .word.w	STMT
    331  32fe							;
    332  32fe							;===========================================================
    333  32fe							; Waits for a task or list of tasks to complete
    334  32fe
    335  32fe				   ekTaskw
      0  32fe					      TSTB	UNKNOWNLnk,oLeftBracket
      0  32fe					      db	101
      1  32fe		       65		      .byte.b	101
      0  32ff					      db	(UNKNOWNLnk-*)-1
      1  32ff		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  3300					      db	oLeftBracket
      1  3300		       e0		      .byte.b	oLeftBracket
    337  3301				   S8TSK
      0  3301					      Call	EXPR	;Gets the PID of task to wait for
      0  3301					      db	28
      1  3301		       1c		      .byte.b	28
      0  3302					      dw	EXPR
      1  3302		       23 34		      .word.w	EXPR
    339  3304				   S8LOOP
      0  3304					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  3304					      db	76
      1  3304		       4c		      .byte.b	76
      0  3305					      db	(S8LOOP-*)-1
      1  3305		       fe		      .byte.b	(S8LOOP-*)-1
      0  3306					      TSTB	S8aa,oComma	;Checks for more tasks
      0  3306					      db	101
      1  3306		       65		      .byte.b	101
      0  3307					      db	(S8aa-*)-1
      1  3307		       04		      .byte.b	(S8aa-*)-1
      0  3308					      db	oComma
      1  3308		       e2		      .byte.b	oComma
      0  3309					      IJMP	S8TSK	;Go for the next task number
      0  3309					      db	29
      1  3309		       1d		      .byte.b	29
      0  330a					      dw	S8TSK
      1  330a		       01 33		      .word.w	S8TSK
    343  330c				   S8aa
      0  330c					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  330c					      db	101
      1  330c		       65		      .byte.b	101
      0  330d					      db	(UNKNOWNLnk-*)-1
      1  330d		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  330e					      db	oRightBracket
      1  330e		       e1		      .byte.b	oRightBracket
      0  330f					      DONE
      0  330f					      db	1
      1  330f		       01		      .byte.b	1
      0  3310					      NXT	CO
      0  3310					      db	6
      1  3310		       06		      .byte.b	6
      0  3311					      dw	CO
      1  3311		       02 32		      .word.w	CO
      0  3313					      IJMP	STMT	;Next Statement
      0  3313					      db	29
      1  3313		       1d		      .byte.b	29
      0  3314					      dw	STMT
      1  3314		       0a 32		      .word.w	STMT
    348  3316
    349  3316
    350  3316
    351  3316				   UNKNOWNLnk
      0  3316					      iJMP	UNKNOWN
      0  3316					      db	29
      1  3316		       1d		      .byte.b	29
      0  3317					      dw	UNKNOWN
      1  3317		       1f 34		      .word.w	UNKNOWN
    353  3319
    354  3319							;
    355  3319							;===========================================================
    356  3319							; Update a memory location with a value
    357  3319							;  Use @[offset] to write a word value to memory
    358  3319							;
    359  3319							;S8a1:
    360  3319							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    361  3319				   ekPoke
      0  3319					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3319					      db	101
      1  3319		       65		      .byte.b	101
      0  331a					      db	(UNKNOWNV-*)-1
      1  331a		       a1		      .byte.b	(UNKNOWNV-*)-1
      0  331b					      db	oLeftBracket
      1  331b		       e0		      .byte.b	oLeftBracket
      0  331c					      CALL	EXPR	; Get address to write to
      0  331c					      db	28
      1  331c		       1c		      .byte.b	28
      0  331d					      dw	EXPR
      1  331d		       23 34		      .word.w	EXPR
      0  331f					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  331f					      db	101
      1  331f		       65		      .byte.b	101
      0  3320					      db	(UNKNOWNV-*)-1
      1  3320		       9b		      .byte.b	(UNKNOWNV-*)-1
      0  3321					      db	oComma
      1  3321		       e2		      .byte.b	oComma
      0  3322					      CALL	EXPR	; Get the value to poke
      0  3322					      db	28
      1  3322		       1c		      .byte.b	28
      0  3323					      dw	EXPR
      1  3323		       23 34		      .word.w	EXPR
      0  3325					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3325					      db	101
      1  3325		       65		      .byte.b	101
      0  3326					      db	(UNKNOWNV-*)-1
      1  3326		       95		      .byte.b	(UNKNOWNV-*)-1
      0  3327					      db	oRightBracket
      1  3327		       e1		      .byte.b	oRightBracket
      0  3328					      POKEMEM
      0  3328					      db	47
      1  3328		       2f		      .byte.b	47
      0  3329					      DONE
      0  3329					      db	1
      1  3329		       01		      .byte.b	1
      0  332a					      NXT	CO	;AND SEQUENCE TO NEXT
      0  332a					      db	6
      1  332a		       06		      .byte.b	6
      0  332b					      dw	CO
      1  332b		       02 32		      .word.w	CO
      0  332d					      IJMP	STMT
      0  332d					      db	29
      1  332d		       1d		      .byte.b	29
      0  332e					      dw	STMT
      1  332e		       0a 32		      .word.w	STMT
    371  3330							;
    372  3330							;================================================================
    373  3330							; Set a block of memory to a value word or byte
    374  3330							; SetMem(Value, Length, Destination)
    375  3330				   ekSetMemB
      0  3330					      CALL	ekSetMem
      0  3330					      db	28
      1  3330		       1c		      .byte.b	28
      0  3331					      dw	ekSetMem
      1  3331		       48 33		      .word.w	ekSetMem
      0  3333					      SETBLOCK	tByte	; set value as byte
      0  3333					      db	110
      1  3333		       6e		      .byte.b	110
      0  3334					      db	tByte
      1  3334		       a2		      .byte.b	tByte
      0  3335					      DONE
      0  3335					      db	1
      1  3335		       01		      .byte.b	1
      0  3336					      NXT	CO
      0  3336					      db	6
      1  3336		       06		      .byte.b	6
      0  3337					      dw	CO
      1  3337		       02 32		      .word.w	CO
      0  3339					      IJMP	STMT
      0  3339					      db	29
      1  3339		       1d		      .byte.b	29
      0  333a					      dw	STMT
      1  333a		       0a 32		      .word.w	STMT
    381  333c
    382  333c				   ekSetMemW
      0  333c					      CALL	ekSetMem
      0  333c					      db	28
      1  333c		       1c		      .byte.b	28
      0  333d					      dw	ekSetMem
      1  333d		       48 33		      .word.w	ekSetMem
      0  333f					      SETBLOCK	tInteger	; set value as byte
      0  333f					      db	110
      1  333f		       6e		      .byte.b	110
      0  3340					      db	tInteger
      1  3340		       a4		      .byte.b	tInteger
      0  3341					      DONE
      0  3341					      db	1
      1  3341		       01		      .byte.b	1
      0  3342					      NXT	CO
      0  3342					      db	6
      1  3342		       06		      .byte.b	6
      0  3343					      dw	CO
      1  3343		       02 32		      .word.w	CO
      0  3345					      IJMP	STMT
      0  3345					      db	29
      1  3345		       1d		      .byte.b	29
      0  3346					      dw	STMT
      1  3346		       0a 32		      .word.w	STMT
    388  3348
    389  3348				   ekSetMem
      0  3348					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3348					      db	101
      1  3348		       65		      .byte.b	101
      0  3349					      db	(UNKNOWNV-*)-1
      1  3349		       72		      .byte.b	(UNKNOWNV-*)-1
      0  334a					      db	oLeftBracket
      1  334a		       e0		      .byte.b	oLeftBracket
      0  334b					      CALL	EXPR	; Value to set
      0  334b					      db	28
      1  334b		       1c		      .byte.b	28
      0  334c					      dw	EXPR
      1  334c		       23 34		      .word.w	EXPR
      0  334e					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  334e					      db	101
      1  334e		       65		      .byte.b	101
      0  334f					      db	(UNKNOWNV-*)-1
      1  334f		       6c		      .byte.b	(UNKNOWNV-*)-1
      0  3350					      db	oComma
      1  3350		       e2		      .byte.b	oComma
      0  3351					      CALL	EXPR	; Get The Length
      0  3351					      db	28
      1  3351		       1c		      .byte.b	28
      0  3352					      dw	EXPR
      1  3352		       23 34		      .word.w	EXPR
      0  3354					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3354					      db	101
      1  3354		       65		      .byte.b	101
      0  3355					      db	(UNKNOWNV-*)-1
      1  3355		       66		      .byte.b	(UNKNOWNV-*)-1
      0  3356					      db	oComma
      1  3356		       e2		      .byte.b	oComma
      0  3357					      CALL	EXPR	; GET the address to start at
      0  3357					      db	28
      1  3357		       1c		      .byte.b	28
      0  3358					      dw	EXPR
      1  3358		       23 34		      .word.w	EXPR
      0  335a					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  335a					      db	101
      1  335a		       65		      .byte.b	101
      0  335b					      db	(UNKNOWNV-*)-1
      1  335b		       60		      .byte.b	(UNKNOWNV-*)-1
      0  335c					      db	oRightBracket
      1  335c		       e1		      .byte.b	oRightBracket
      0  335d					      RTN
      0  335d					      db	25
      1  335d		       19		      .byte.b	25
    398  335e							;
    399  335e							;================================================================
    400  335e							; Copy a block of memory
    401  335e							; CopyMem(Length, Destination, Source)
    402  335e				   ekCopyMem
      0  335e					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  335e					      db	101
      1  335e		       65		      .byte.b	101
      0  335f					      db	(UNKNOWNV-*)-1
      1  335f		       5c		      .byte.b	(UNKNOWNV-*)-1
      0  3360					      db	oLeftBracket
      1  3360		       e0		      .byte.b	oLeftBracket
      0  3361					      CALL	EXPR	; Length
      0  3361					      db	28
      1  3361		       1c		      .byte.b	28
      0  3362					      dw	EXPR
      1  3362		       23 34		      .word.w	EXPR
      0  3364					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3364					      db	101
      1  3364		       65		      .byte.b	101
      0  3365					      db	(UNKNOWNV-*)-1
      1  3365		       56		      .byte.b	(UNKNOWNV-*)-1
      0  3366					      db	oComma
      1  3366		       e2		      .byte.b	oComma
      0  3367					      CALL	EXPR	; Destination
      0  3367					      db	28
      1  3367		       1c		      .byte.b	28
      0  3368					      dw	EXPR
      1  3368		       23 34		      .word.w	EXPR
      0  336a					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  336a					      db	101
      1  336a		       65		      .byte.b	101
      0  336b					      db	(UNKNOWNV-*)-1
      1  336b		       50		      .byte.b	(UNKNOWNV-*)-1
      0  336c					      db	oComma
      1  336c		       e2		      .byte.b	oComma
      0  336d					      CALL	EXPR	; Source
      0  336d					      db	28
      1  336d		       1c		      .byte.b	28
      0  336e					      dw	EXPR
      1  336e		       23 34		      .word.w	EXPR
      0  3370					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3370					      db	101
      1  3370		       65		      .byte.b	101
      0  3371					      db	(UNKNOWNV-*)-1
      1  3371		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  3372					      db	oRightBracket
      1  3372		       e1		      .byte.b	oRightBracket
      0  3373					      COPYBLOCK		; Copy the memory
      0  3373					      db	111
      1  3373		       6f		      .byte.b	111
      0  3374					      DONE
      0  3374					      db	1
      1  3374		       01		      .byte.b	1
      0  3375					      NXT	CO
      0  3375					      db	6
      1  3375		       06		      .byte.b	6
      0  3376					      dw	CO
      1  3376		       02 32		      .word.w	CO
      0  3378					      IJMP	STMT
      0  3378					      db	29
      1  3378		       1d		      .byte.b	29
      0  3379					      dw	STMT
      1  3379		       0a 32		      .word.w	STMT
    414  337b
    415  337b							;================================================================
    416  337b							; Write a single byte to the output device
    417  337b							;
    418  337b				   ekPutch
      0  337b					      CALL	EXPR
      0  337b					      db	28
      1  337b		       1c		      .byte.b	28
      0  337c					      dw	EXPR
      1  337c		       23 34		      .word.w	EXPR
      0  337e					      PUTCHAR
      0  337e					      db	52
      1  337e		       34		      .byte.b	52
      0  337f					      DONE
      0  337f					      db	1
      1  337f		       01		      .byte.b	1
      0  3380					      NXT	CO	;AND SEQUENCE TO NEXT
      0  3380					      db	6
      1  3380		       06		      .byte.b	6
      0  3381					      dw	CO
      1  3381		       02 32		      .word.w	CO
      0  3383					      IJMP	STMT
      0  3383					      db	29
      1  3383		       1d		      .byte.b	29
      0  3384					      dw	STMT
      1  3384		       0a 32		      .word.w	STMT
    424  3386							;================================================================
    425  3386							; Clear the screen lines
    426  3386							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    427  3386							;
    428  3386				   ekCls
      0  3386					      CLEARSCREEN
      0  3386					      db	46
      1  3386		       2e		      .byte.b	46
      0  3387					      NXT	CO	;AND SEQUENCE TO NEXT
      0  3387					      db	6
      1  3387		       06		      .byte.b	6
      0  3388					      dw	CO
      1  3388		       02 32		      .word.w	CO
      0  338a					      IJMP	STMT
      0  338a					      db	29
      1  338a		       1d		      .byte.b	29
      0  338b					      dw	STMT
      1  338b		       0a 32		      .word.w	STMT
    432  338d							;==================================================================
    433  338d							; Get input from the terminal
    434  338d							;   Reads from the currently active input device
    435  338d							;
    436  338d				   ekInput
    437  338d				   S10
      0  338d					      TSTB	S10A,tString	;If there is a string print the prompt
      0  338d					      db	101
      1  338d		       65		      .byte.b	101
      0  338e					      db	(S10A-*)-1
      1  338e		       05		      .byte.b	(S10A-*)-1
      0  338f					      db	tString
      1  338f		       a0		      .byte.b	tString
      0  3390					      PRS
      0  3390					      db	2
      1  3390		       02		      .byte.b	2
      0  3391					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  3391					      db	101
      1  3391		       65		      .byte.b	101
      0  3392					      db	(S10Z-*)-1
      1  3392		       1e		      .byte.b	(S10Z-*)-1
      0  3393					      db	oSemiColon
      1  3393		       e3		      .byte.b	oSemiColon
    441  3394				   S10A
      0  3394					      TSTB	InNoString,oDollar	; Check if we are reading characters
      0  3394					      db	101
      1  3394		       65		      .byte.b	101
      0  3395					      db	(InNoString-*)-1
      1  3395		       0c		      .byte.b	(InNoString-*)-1
      0  3396					      db	oDollar
      1  3396		       e7		      .byte.b	oDollar
      0  3397					      TSTV	UNKNOWN
      0  3397					      db	33
      1  3397		       21		      .byte.b	33
      0  3398					      db	(UNKNOWN-*)-1
      1  3398		       86		      .byte.b	(UNKNOWN-*)-1
      0  3399					      CALL	FactVarPtrNoTst
      0  3399					      db	28
      1  3399		       1c		      .byte.b	28
      0  339a					      dw	FactVarPtrNoTst
      1  339a		       d3 35		      .word.w	FactVarPtrNoTst
      0  339c					      INSTR		;Move character From tty to AESTK
      0  339c					      db	59
      1  339c		       3b		      .byte.b	59
      0  339d					      SETR2	tByte
      0  339d					      db	94
      1  339d		       5e		      .byte.b	94
      0  339e					      db	tByte
      1  339e		       a2		      .byte.b	tByte
      0  339f					      IJMP	S10A2
      0  339f					      db	29
      1  339f		       1d		      .byte.b	29
      0  33a0					      dw	S10A2
      1  33a0		       aa 33		      .word.w	S10A2
    448  33a2
    449  33a2				   InNoString
      0  33a2					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  33a2					      db	33
      1  33a2		       21		      .byte.b	33
      0  33a3					      db	(UNKNOWN-*)-1
      1  33a3		       7b		      .byte.b	(UNKNOWN-*)-1
      0  33a4					      CALL	FactVarPtrNoTst
      0  33a4					      db	28
      1  33a4		       1c		      .byte.b	28
      0  33a5					      dw	FactVarPtrNoTst
      1  33a5		       d3 35		      .word.w	FactVarPtrNoTst
      0  33a7					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  33a7					      db	11
      1  33a7		       0b		      .byte.b	11
      0  33a8					      SETR2	tInteger
      0  33a8					      db	94
      1  33a8		       5e		      .byte.b	94
      0  33a9					      db	tInteger
      1  33a9		       a4		      .byte.b	tInteger
    454  33aa
    455  33aa				   S10A2
      0  33aa					      STORE		;STORE IT
      0  33aa					      db	19
      1  33aa		       13		      .byte.b	19
      0  33ab					      TSTB	S11,oComma	;IS THERE MORE?
      0  33ab					      db	101
      1  33ab		       65		      .byte.b	101
      0  33ac					      db	(S11-*)-1
      1  33ac		       07		      .byte.b	(S11-*)-1
      0  33ad					      db	oComma
      1  33ad		       e2		      .byte.b	oComma
      0  33ae					      IJMP	S10	;YES
      0  33ae					      db	29
      1  33ae		       1d		      .byte.b	29
      0  33af					      dw	S10
      1  33af		       8d 33		      .word.w	S10
    459  33b1				   S10Z
      0  33b1					      iJMP	UNKNOWN
      0  33b1					      db	29
      1  33b1		       1d		      .byte.b	29
      0  33b2					      dw	UNKNOWN
      1  33b2		       1f 34		      .word.w	UNKNOWN
    461  33b4				   S11
      0  33b4					      DONE		;MUST BE CR
      0  33b4					      db	1
      1  33b4		       01		      .byte.b	1
      0  33b5					      NXT	CO	;SEQUENCE TO NEXT
      0  33b5					      db	6
      1  33b5		       06		      .byte.b	6
      0  33b6					      dw	CO
      1  33b6		       02 32		      .word.w	CO
      0  33b8					      IJMP	STMT
      0  33b8					      db	29
      1  33b8		       1d		      .byte.b	29
      0  33b9					      dw	STMT
      1  33b9		       0a 32		      .word.w	STMT
    465  33bb							;=====================================================================
    466  33bb							; End of program, return to command line process
    467  33bb							; Main Task may also use taske or return to stopped
    468  33bb							;
    469  33bb				   ekEnd
      0  33bb					      FIN
      0  33bb					      db	12
      1  33bb		       0c		      .byte.b	12
    471  33bc				   UNKNOWNV
      0  33bc					      IJMP	UNKNOWN
      0  33bc					      db	29
      1  33bc		       1d		      .byte.b	29
      0  33bd					      dw	UNKNOWN
      1  33bd		       1f 34		      .word.w	UNKNOWN
    473  33bf							;====================================================================
    474  33bf							; IRQ <IRQ-HANDLER-Line expression>
    475  33bf							;   Specify a line number subroutine to call when an interupt is processed
    476  33bf							;   These subroutines must use iret to return.
    477  33bf							;
    478  33bf				   ekIrq
      0  33bf					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  33bf					      db	28
      1  33bf		       1c		      .byte.b	28
      0  33c0					      dw	EXPR
      1  33c0		       23 34		      .word.w	EXPR
      0  33c2					      DONE		;must be CR
      0  33c2					      db	1
      1  33c2		       01		      .byte.b	1
      0  33c3					      SETIRQ		;Set the line number now
      0  33c3					      db	56
      1  33c3		       38		      .byte.b	56
      0  33c4					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  33c4					      db	6
      1  33c4		       06		      .byte.b	6
      0  33c5					      dw	CO
      1  33c5		       02 32		      .word.w	CO
      0  33c7					      IJMP	STMT
      0  33c7					      db	29
      1  33c7		       1d		      .byte.b	29
      0  33c8					      dw	STMT
      1  33c8		       0a 32		      .word.w	STMT
    484  33ca
    485  33ca							;=========================================================================
    486  33ca							; KILL PID-expression	 kill a running task
    487  33ca							;  ignored of task has already stopped
    488  33ca							;
    489  33ca				   ekKill
      0  33ca					      CALL	EXPR
      0  33ca					      db	28
      1  33ca		       1c		      .byte.b	28
      0  33cb					      dw	EXPR
      1  33cb		       23 34		      .word.w	EXPR
      0  33cd					      DONE
      0  33cd					      db	1
      1  33cd		       01		      .byte.b	1
      0  33ce					      TASKKILL
      0  33ce					      db	65
      1  33ce		       41		      .byte.b	65
      0  33cf					      NXT	CO
      0  33cf					      db	6
      1  33cf		       06		      .byte.b	6
      0  33d0					      dw	CO
      1  33d0		       02 32		      .word.w	CO
      0  33d2					      IJMP	STMT
      0  33d2					      db	29
      1  33d2		       1d		      .byte.b	29
      0  33d3					      dw	STMT
      1  33d3		       0a 32		      .word.w	STMT
    495  33d5
    496  33d5							;============================================================================
    497  33d5							; List all program lines
    498  33d5							;
    499  33d5				   ekList
      0  33d5					      DONE
      0  33d5					      db	1
      1  33d5		       01		      .byte.b	1
      0  33d6					      LST
      0  33d6					      db	21
      1  33d6		       15		      .byte.b	21
      0  33d7					      IJMP	CO
      0  33d7					      db	29
      1  33d7		       1d		      .byte.b	29
      0  33d8					      dw	CO
      1  33d8		       02 32		      .word.w	CO
    503  33da							;=======================================================================
    504  33da							;RUN begin to executed the program in memory
    505  33da							;
    506  33da				   ekRun
      0  33da					      DONE
      0  33da					      db	1
      1  33da		       01		      .byte.b	1
      0  33db					      VINIT		;clear variables compile the line numbers
      0  33db					      db	30
      1  33db		       1e		      .byte.b	30
      0  33dc					      LIT	1	;GOTO line 1
      0  33dc					      db	27
      1  33dc		       1b		      .byte.b	27
      0  33dd					      dw	1
      1  33dd		       01 00		      .word.w	1
      0  33df					      XFER		;Bob's addition
      0  33df					      db	7
      1  33df		       07		      .byte.b	7
    511  33e0							; EXIT
      0  33e0					      IJMP	STMT	;and run!
      0  33e0					      db	29
      1  33e0		       1d		      .byte.b	29
      0  33e1					      dw	STMT
      1  33e1		       0a 32		      .word.w	STMT
    513  33e3							;=========================================================================
    514  33e3							;Clear the program memory, delete all proram lines
    515  33e3							;
    516  33e3				   ekNew
      0  33e3					      DONE
      0  33e3					      db	1
      1  33e3		       01		      .byte.b	1
      0  33e4					      IJMP	START
      0  33e4					      db	29
      1  33e4		       1d		      .byte.b	29
      0  33e5					      dw	START
      1  33e5		       fc 31		      .word.w	START
    519  33e7
    520  33e7							;========================================================================
    521  33e7							; Slice(slice legth expression)
    522  33e7							;   set the length of time between task switches
    523  33e7							;
    524  33e7				   ekSlice
      0  33e7					      CALL	EXPR
      0  33e7					      db	28
      1  33e7		       1c		      .byte.b	28
      0  33e8					      dw	EXPR
      1  33e8		       23 34		      .word.w	EXPR
      0  33ea					      SLICE
      0  33ea					      db	100
      1  33ea		       64		      .byte.b	100
      0  33eb					      DONE
      0  33eb					      db	1
      1  33eb		       01		      .byte.b	1
      0  33ec					      NXT	CO
      0  33ec					      db	6
      1  33ec		       06		      .byte.b	6
      0  33ed					      dw	CO
      1  33ed		       02 32		      .word.w	CO
      0  33ef					      IJMP	STMT
      0  33ef					      db	29
      1  33ef		       1d		      .byte.b	29
      0  33f0					      dw	STMT
      1  33f0		       0a 32		      .word.w	STMT
    530  33f2							;==========================================================================
    531  33f2							; Turn off and on the thrace functions
    532  33f2							; a debug terminal needs to be available
    533  33f2							; Trace( Trace flag expression)
    534  33f2							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    535  33f2							;	for individual lines of basic code. These can be combined
    536  33f2				   ekTrace
      0  33f2					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  33f2					      db	101
      1  33f2		       65		      .byte.b	101
      0  33f3					      db	(UNKNOWN-*)-1
      1  33f3		       2b		      .byte.b	(UNKNOWN-*)-1
      0  33f4					      db	oLeftBracket
      1  33f4		       e0		      .byte.b	oLeftBracket
      0  33f5					      CALL	EXPR
      0  33f5					      db	28
      1  33f5		       1c		      .byte.b	28
      0  33f6					      dw	EXPR
      1  33f6		       23 34		      .word.w	EXPR
      0  33f8					      TSTB	UNKNOWN,oRightBracket
      0  33f8					      db	101
      1  33f8		       65		      .byte.b	101
      0  33f9					      db	(UNKNOWN-*)-1
      1  33f9		       25		      .byte.b	(UNKNOWN-*)-1
      0  33fa					      db	oRightBracket
      1  33fa		       e1		      .byte.b	oRightBracket
      0  33fb					      TRACEPROGRAM
      0  33fb					      db	78
      1  33fb		       4e		      .byte.b	78
      0  33fc					      DONE
      0  33fc					      db	1
      1  33fc		       01		      .byte.b	1
      0  33fd					      NXT	CO
      0  33fd					      db	6
      1  33fd		       06		      .byte.b	6
      0  33fe					      dw	CO
      1  33fe		       02 32		      .word.w	CO
      0  3400					      IJMP	STMT
      0  3400					      db	29
      1  3400		       1d		      .byte.b	29
      0  3401					      dw	STMT
      1  3401		       0a 32		      .word.w	STMT
    544  3403							;=====================================================================
    545  3403							; Exit basic to machine monitor
    546  3403							;
    547  3403				   ekExit
      0  3403					      EXIT
      0  3403					      db	26
      1  3403		       1a		      .byte.b	26
    549  3404
    550  3404							;=======================================================================
    551  3404							; Commands related to saving/restoring programs
    552  3404							; to/from mass storage.
    553  3404							;=======================================================================
    554  3404							; Save a program file
    555  3404							;
    556  3404					      if	(XKIM || CTMON65) && DISK_ACCESS
    557  3404
    558  3404				   ekSave
      0  3404					      OPENWRITE	OPEN_CREATE
      0  3404					      db	40
      1  3404		       28		      .byte.b	40
      0  3405					      db	OPEN_CREATE
      1  3405		       01		      .byte.b	OPEN_CREATE
      0  3406					      DLIST
      0  3406					      db	43
      1  3406		       2b		      .byte.b	43
      0  3407					      DCLOSE
      0  3407					      db	41
      1  3407		       29		      .byte.b	41
      0  3408					      IJMP	CO
      0  3408					      db	29
      1  3408		       1d		      .byte.b	29
      0  3409					      dw	CO
      1  3409		       02 32		      .word.w	CO
    563  340b							;=========================================================================
    564  340b							; Load a program file
    565  340b							;
    566  340b				   ekLoad
      0  340b					      OPENREAD
      0  340b					      db	39
      1  340b		       27		      .byte.b	39
    568  340c				   S17CLP
      0  340c					      DGETLINE		;get line from file
      0  340c					      db	42
      1  340c		       2a		      .byte.b	42
      0  340d					      TSTL	S17EOL	;no line num means EOL
      0  340d					      db	34
      1  340d		       22		      .byte.b	34
      0  340e					      db	(S17EOL-*)-1
      1  340e		       04		      .byte.b	(S17EOL-*)-1
      0  340f					      INSERT		;put it into the program
      0  340f					      db	24
      1  340f		       18		      .byte.b	24
      0  3410					      IJMP	S17CLP	;keep going
      0  3410					      db	29
      1  3410		       1d		      .byte.b	29
      0  3411					      dw	S17CLP
      1  3411		       0c 34		      .word.w	S17CLP
    573  3413				   S17EOL
      0  3413					      DCLOSE		;close disk file
      0  3413					      db	41
      1  3413		       29		      .byte.b	41
      0  3414					      IJMP	CO	;back to start
      0  3414					      db	29
      1  3414		       1d		      .byte.b	29
      0  3415					      dw	CO
      1  3415		       02 32		      .word.w	CO
    576  3417							;=========================================================================
    577  3417							; Display the directory content
    578  3417							;
    579  3417				   ekDir
      0  3417					      DDIR		;Display the directory content
      0  3417					      db	44
      1  3417		       2c		      .byte.b	44
      0  3418					      IJMP	CO
      0  3418					      db	29
      1  3418		       1d		      .byte.b	29
      0  3419					      dw	CO
      1  3419		       02 32		      .word.w	CO
    582  341b							;=========================================================================
    583  341b							; Erase a file from disk
    584  341b							;
    585  341b				   ekErase
      0  341b					      RMFILE		;Erase the file from the disk
      0  341b					      db	45
      1  341b		       2d		      .byte.b	45
      0  341c					      IJMP	CO
      0  341c					      db	29
      1  341c		       1d		      .byte.b	29
      0  341d					      dw	CO
      1  341d		       02 32		      .word.w	CO
    588  341f
    589  341f					      endif
    590  341f
    591  341f							;===========================================================================
    592  341f							; Else, unknown command.
    593  341f							;
    594  341f				   UNKNOWN
      0  341f					      ENDIO
      0  341f					      db	71
      1  341f		       47		      .byte.b	71
    596  3420
    597  3420				   NotKnownStatement
    598  3420
      0  3420					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  3420					      db	13
      1  3420		       0d		      .byte.b	13
      0  3421					      dw	ERR_SYNTAX
      1  3421		       05 00		      .word.w	ERR_SYNTAX
    600  3423
    601  3423							;=======================================================
    602  3423							; Process Expresions, precidence is represented by the
    603  3423							; various call levels
    604  3423							;
    605  3423				   EXPR
      0  3423					      TSTB	EXPRLOGS,kNot
      0  3423					      db	101
      1  3423		       65		      .byte.b	101
      0  3424					      db	(EXPRLOGS-*)-1
      1  3424		       06		      .byte.b	(EXPRLOGS-*)-1
      0  3425					      db	kNot
      1  3425		       24		      .byte.b	kNot
    607  3426				   ekNot
      0  3426					      Call	EXPR
      0  3426					      db	28
      1  3426		       1c		      .byte.b	28
      0  3427					      dw	EXPR
      1  3427		       23 34		      .word.w	EXPR
      0  3429					      LOGNOT
      0  3429					      db	72
      1  3429		       48		      .byte.b	72
      0  342a					      RTN
      0  342a					      db	25
      1  342a		       19		      .byte.b	25
    611  342b
    612  342b							;=========================================================
    613  342b							;Look for logical operators, but does get first part of expression
    614  342b				   EXPRLOGS
      0  342b					      Call	EXPR2	; get the left first expression
      0  342b					      db	28
      1  342b		       1c		      .byte.b	28
      0  342c					      dw	EXPR2
      1  342c		       5a 34		      .word.w	EXPR2
      0  342e					      TSTRELOP	EXPSHIFT	; Exit level if no rel ops found
      0  342e					      db	104
      1  342e		       68		      .byte.b	104
      0  342f					      db	(EXPSHIFT-*)-1
      1  342f		       05		      .byte.b	(EXPSHIFT-*)-1
    617  3430							;	  TSTB	     iR0,oEqual
    618  3430							;	  LIT	     2		     ;=
    619  3430							;	  IJMP	     iRFound
    620  3430							;iR0:
    621  3430							;	  TSTB	      iR1,oLessEqual
    622  3430							;	  LIT	      3 	      ;<=
    623  3430							;	  IJMP	     iRFound
    624  3430							;iR1:
    625  3430							;	  TSTB	     iR3,oNotEqual
    626  3430							;	  LIT	     5		      ;<>
    627  3430							;	      IJMP	  iRFound
    628  3430							;iR3:
    629  3430							;	  TSTB	     iR4,oLess
    630  3430							;	  LIT	     1		     ;<
    631  3430							;	      IJMP	  iRFound
    632  3430							;iR4:
    633  3430							;	  TST	     iR5,oGreaterEqual
    634  3430							;	  LIT	     6		     ;>=
    635  3430							;	      IJMP	  iRFound
    636  3430							;iR5:
    637  3430							;	  TSTB	     iRDone,oGreater
    638  3430							;	  LIT	     4		     ;>
    639  3430				   iRFound
      0  3430					      Call	EXPR2	; EXPR; get the right side of the expression
      0  3430					      db	28
      1  3430		       1c		      .byte.b	28
      0  3431					      dw	EXPR2
      1  3431		       5a 34		      .word.w	EXPR2
      0  3433					      CMPR		; Push the value of the true false onto the stack
      0  3433					      db	10
      1  3433		       0a		      .byte.b	10
      0  3434					      RTN
      0  3434					      db	25
      1  3434		       19		      .byte.b	25
    643  3435
    644  3435							;=========================================================
    645  3435							;Look for shift left and shift right level
    646  3435				   EXPSHIFT
      0  3435					      OnGoto	BasicShift,EXPRLOGICAL
      0  3435					      db	103
      1  3435		       67		      .byte.b	103
      0  3436					      dw	BasicShift
      1  3436		       d0 31		      .word.w	BasicShift
      0  3438					      dw	EXPRLOGICAL
      1  3438		       46 34		      .word.w	EXPRLOGICAL
    648  343a
    649  343a				   ekShiftLeft
      0  343a					      Call	EXPR
      0  343a					      db	28
      1  343a		       1c		      .byte.b	28
      0  343b					      dw	EXPR
      1  343b		       23 34		      .word.w	EXPR
      0  343d					      SHIFT	0
      0  343d					      db	113
      1  343d		       71		      .byte.b	113
      0  343e					      db	0
      1  343e		       00		      .byte.b	0
      0  343f					      RTN
      0  343f					      db	25
      1  343f		       19		      .byte.b	25
    653  3440
    654  3440				   ekShiftRight
      0  3440					      Call	EXPR
      0  3440					      db	28
      1  3440		       1c		      .byte.b	28
      0  3441					      dw	EXPR
      1  3441		       23 34		      .word.w	EXPR
      0  3443					      SHIFT	1
      0  3443					      db	113
      1  3443		       71		      .byte.b	113
      0  3444					      db	1
      1  3444		       01		      .byte.b	1
      0  3445					      RTN
      0  3445					      db	25
      1  3445		       19		      .byte.b	25
    658  3446
    659  3446							;======================================================================
    660  3446				   EXPRLOGICAL
      0  3446					      OnGoto	BasicLogical,iLOGExit
      0  3446					      db	103
      1  3446		       67		      .byte.b	103
      0  3447					      dw	BasicLogical
      1  3447		       c8 31		      .word.w	BasicLogical
      0  3449					      dw	iLOGExit
      1  3449		       59 34		      .word.w	iLOGExit
    662  344b				   ekAnd
      0  344b					      Call	EXPR
      0  344b					      db	28
      1  344b		       1c		      .byte.b	28
      0  344c					      dw	EXPR
      1  344c		       23 34		      .word.w	EXPR
      0  344e					      LOGAND
      0  344e					      db	74
      1  344e		       4a		      .byte.b	74
      0  344f					      RTN
      0  344f					      db	25
      1  344f		       19		      .byte.b	25
    666  3450				   ekOr
      0  3450					      Call	EXPR
      0  3450					      db	28
      1  3450		       1c		      .byte.b	28
      0  3451					      dw	EXPR
      1  3451		       23 34		      .word.w	EXPR
      0  3453					      LOGOR
      0  3453					      db	73
      1  3453		       49		      .byte.b	73
      0  3454					      RTN
      0  3454					      db	25
      1  3454		       19		      .byte.b	25
    670  3455				   ekXor
      0  3455					      Call	EXPR
      0  3455					      db	28
      1  3455		       1c		      .byte.b	28
      0  3456					      dw	EXPR
      1  3456		       23 34		      .word.w	EXPR
      0  3458					      LOGXOR
      0  3458					      db	75
      1  3458		       4b		      .byte.b	75
    673  3459				   iLOGExit
      0  3459					      RTN
      0  3459					      db	25
      1  3459		       19		      .byte.b	25
    675  345a
    676  345a							; get the right part of an expression
    677  345a				   EXPR2
      0  345a					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  345a					      db	101
      1  345a		       65		      .byte.b	101
      0  345b					      db	(E0-*)-1
      1  345b		       08		      .byte.b	(E0-*)-1
      0  345c					      db	oMinus
      1  345c		       eb		      .byte.b	oMinus
      0  345d					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  345d					      db	28
      1  345d		       1c		      .byte.b	28
      0  345e					      dw	TERM
      1  345e		       80 34		      .word.w	TERM
      0  3460					      NEG		; Make value negated
      0  3460					      db	16
      1  3460		       10		      .byte.b	16
      0  3461					      IJMP	E1	; We have Left term process operators next
      0  3461					      db	29
      1  3461		       1d		      .byte.b	29
      0  3462					      dw	E1
      1  3462		       6a 34		      .word.w	E1
    682  3464				   E0
      0  3464					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  3464					      db	101
      1  3464		       65		      .byte.b	101
      0  3465					      db	(E1A-*)-1
      1  3465		       01		      .byte.b	(E1A-*)-1
      0  3466					      db	oPlus
      1  3466		       ea		      .byte.b	oPlus
    684  3467				   E1A
      0  3467					      CALL	TERM	; Get the left term if it was not negated
      0  3467					      db	28
      1  3467		       1c		      .byte.b	28
      0  3468					      dw	TERM
      1  3468		       80 34		      .word.w	TERM
    686  346a				   E1
      0  346a					      TST	E2,oPlus	; Check if we are adding left term to something
      0  346a					      db	32
      1  346a		       20		      .byte.b	32
      0  346b					      db	(E2-*)-1
      1  346b		       09		      .byte.b	(E2-*)-1
      0  346c					      db	oPlus,0
      1  346c		       ea 00		      .byte.b	oPlus,0
      0  346e					      CALL	TERM	; if adding then get the right side term
      0  346e					      db	28
      1  346e		       1c		      .byte.b	28
      0  346f					      dw	TERM
      1  346f		       80 34		      .word.w	TERM
      0  3471					      ADD		; Add it to left term
      0  3471					      db	14
      1  3471		       0e		      .byte.b	14
      0  3472					      IJMP	E1	; look for next + or -
      0  3472					      db	29
      1  3472		       1d		      .byte.b	29
      0  3473					      dw	E1
      1  3473		       6a 34		      .word.w	E1
    691  3475				   E2
      0  3475					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  3475					      db	101
      1  3475		       65		      .byte.b	101
      0  3476					      db	(E3-*)-1
      1  3476		       08		      .byte.b	(E3-*)-1
      0  3477					      db	oMinus
      1  3477		       eb		      .byte.b	oMinus
      0  3478					      CALL	TERM	; get right side to subtract Diffrence
      0  3478					      db	28
      1  3478		       1c		      .byte.b	28
      0  3479					      dw	TERM
      1  3479		       80 34		      .word.w	TERM
      0  347b					      SUB		; Subtract the value
      0  347b					      db	15
      1  347b		       0f		      .byte.b	15
      0  347c					      IJMP	E1	; Look for next + or -
      0  347c					      db	29
      1  347c		       1d		      .byte.b	29
      0  347d					      dw	E1
      1  347d		       6a 34		      .word.w	E1
    696  347f				   E3			; Finish processing the expression
      0  347f					      RTN		; We are finished processing the Expression
      0  347f					      db	25
      1  347f		       19		      .byte.b	25
    698  3480							;
    699  3480							; Get one of the terms of an expression
    700  3480							;
    701  3480				   TERM
      0  3480					      CALL	FACT	; Get a value
      0  3480					      db	28
      1  3480		       1c		      .byte.b	28
      0  3481					      dw	FACT
      1  3481		       a5 34		      .word.w	FACT
    703  3483				   T0			; Check for higher precidence operators
      0  3483					      TSTB	T1,oMultiply	; Check for *
      0  3483					      db	101
      1  3483		       65		      .byte.b	101
      0  3484					      db	(T1-*)-1
      1  3484		       08		      .byte.b	(T1-*)-1
      0  3485					      db	oMultiply
      1  3485		       ee		      .byte.b	oMultiply
      0  3486					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  3486					      db	28
      1  3486		       1c		      .byte.b	28
      0  3487					      dw	FACT
      1  3487		       a5 34		      .word.w	FACT
      0  3489					      MUL		; Multiply factors
      0  3489					      db	17
      1  3489		       11		      .byte.b	17
      0  348a					      IJMP	T0	; Check for * or /
      0  348a					      db	29
      1  348a		       1d		      .byte.b	29
      0  348b					      dw	T0
      1  348b		       83 34		      .word.w	T0
    708  348d				   T1
      0  348d					      TSTB	T2,oDivide	; Check for a division
      0  348d					      db	101
      1  348d		       65		      .byte.b	101
      0  348e					      db	(T2-*)-1
      1  348e		       08		      .byte.b	(T2-*)-1
      0  348f					      db	oDivide
      1  348f		       ec		      .byte.b	oDivide
      0  3490					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  3490					      db	28
      1  3490		       1c		      .byte.b	28
      0  3491					      dw	FACT
      1  3491		       a5 34		      .word.w	FACT
      0  3493					      DIV		; do division
      0  3493					      db	18
      1  3493		       12		      .byte.b	18
      0  3494					      IJMP	T0	; check for more * or /
      0  3494					      db	29
      1  3494		       1d		      .byte.b	29
      0  3495					      dw	T0
      1  3495		       83 34		      .word.w	T0
    713  3497				   T2
      0  3497					      TSTB	T3,oModulo	; Check for a division
      0  3497					      db	101
      1  3497		       65		      .byte.b	101
      0  3498					      db	(T3-*)-1
      1  3498		       08		      .byte.b	(T3-*)-1
      0  3499					      db	oModulo
      1  3499		       ed		      .byte.b	oModulo
      0  349a					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  349a					      db	28
      1  349a		       1c		      .byte.b	28
      0  349b					      dw	FACT
      1  349b		       a5 34		      .word.w	FACT
      0  349d					      MODULO		; do division for remainder
      0  349d					      db	60
      1  349d		       3c		      .byte.b	60
      0  349e					      IJMP	T0	; check for more * or / or %
      0  349e					      db	29
      1  349e		       1d		      .byte.b	29
      0  349f					      dw	T0
      1  349f		       83 34		      .word.w	T0
    718  34a1				   T3			; Finish processing the Term
      0  34a1					      RTN
      0  34a1					      db	25
      1  34a1		       19		      .byte.b	25
    720  34a2
    721  34a2				   UNKNOWNVEC
      0  34a2					      IJMP	UNKNOWN
      0  34a2					      db	29
      1  34a2		       1d		      .byte.b	29
      0  34a3					      dw	UNKNOWN
      1  34a3		       1f 34		      .word.w	UNKNOWN
    723  34a5
    724  34a5							;=============================================================================================
    725  34a5							; Factor an expression.  Always test for functions
    726  34a5							; first or else they'll be confused for variables.
    727  34a5							;
    728  34a5				   FACT
      0  34a5					      OnGoto	BasicFuncs,FactNumber
      0  34a5					      db	103
      1  34a5		       67		      .byte.b	103
      0  34a6					      dw	BasicFuncs
      1  34a6		       d6 31		      .word.w	BasicFuncs
      0  34a8					      dw	FactNumber
      1  34a8		       a5 35		      .word.w	FactNumber
    730  34aa
    731  34aa							;FACTCONTINUE:
    732  34aa							;	  TSTB	     F1AA,kTrue
    733  34aa				   ekTrue
      0  34aa					      LIT	-1
      0  34aa					      db	27
      1  34aa		       1b		      .byte.b	27
      0  34ab					      dw	-1
      1  34ab		       ff ff		      .word.w	-1
      0  34ad					      RTN
      0  34ad					      db	25
      1  34ad		       19		      .byte.b	25
    736  34ae							;F1AA:
    737  34ae							;	  TSTB	     F1AB,kFalse
    738  34ae				   ekFalse
      0  34ae					      LIT	0
      0  34ae					      db	27
      1  34ae		       1b		      .byte.b	27
      0  34af					      dw	0
      1  34af		       00 00		      .word.w	0
      0  34b1					      RTN
      0  34b1					      db	25
      1  34b1		       19		      .byte.b	25
    741  34b2							;==================================================================================
    742  34b2							; Returns the amount of free SPACE
    743  34b2				   ekFree
      0  34b2					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34b2					      db	101
      1  34b2		       65		      .byte.b	101
      0  34b3					      db	(UNKNOWNVEC-*)-1
      1  34b3		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  34b4					      db	oLeftBracket
      1  34b4		       e0		      .byte.b	oLeftBracket
      0  34b5					      TSTB	UNKNOWNVEC,oRightBracket
      0  34b5					      db	101
      1  34b5		       65		      .byte.b	101
      0  34b6					      db	(UNKNOWNVEC-*)-1
      1  34b6		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  34b7					      db	oRightBracket
      1  34b7		       e1		      .byte.b	oRightBracket
      0  34b8					      FREE
      0  34b8					      db	36
      1  34b8		       24		      .byte.b	36
      0  34b9					      RTN
      0  34b9					      db	25
      1  34b9		       19		      .byte.b	25
    748  34ba							;===================================================================================
    749  34ba							; getch() read a character from the input device
    750  34ba							;
    751  34ba				   ekGetch
      0  34ba					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34ba					      db	101
      1  34ba		       65		      .byte.b	101
      0  34bb					      db	(UNKNOWNVEC-*)-1
      1  34bb		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  34bc					      db	oLeftBracket
      1  34bc		       e0		      .byte.b	oLeftBracket
      0  34bd					      TSTB	UNKNOWNVEC,oRightBracket
      0  34bd					      db	101
      1  34bd		       65		      .byte.b	101
      0  34be					      db	(UNKNOWNVEC-*)-1
      1  34be		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  34bf					      db	oRightBracket
      1  34bf		       e1		      .byte.b	oRightBracket
      0  34c0					      GETCHAR
      0  34c0					      db	51
      1  34c0		       33		      .byte.b	51
      0  34c1					      RTN
      0  34c1					      db	25
      1  34c1		       19		      .byte.b	25
    756  34c2							;
    757  34c2							;====================================================================================
    758  34c2							; addr(variable definition)
    759  34c2							; Returns the address of a variable on top of the stack
    760  34c2				   ekAddr
      0  34c2					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34c2					      db	101
      1  34c2		       65		      .byte.b	101
      0  34c3					      db	(UNKNOWNVEC-*)-1
      1  34c3		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  34c4					      db	oLeftBracket
      1  34c4		       e0		      .byte.b	oLeftBracket
      0  34c5					      TSTV	ExpectedVariable
      0  34c5					      db	33
      1  34c5		       21		      .byte.b	33
      0  34c6					      db	(ExpectedVariable-*)-1
      1  34c6		       07		      .byte.b	(ExpectedVariable-*)-1
      0  34c7					      CALL	FactVarPtrNoTst
      0  34c7					      db	28
      1  34c7		       1c		      .byte.b	28
      0  34c8					      dw	FactVarPtrNoTst
      1  34c8		       d3 35		      .word.w	FactVarPtrNoTst
      0  34ca					      TSTB	UNKNOWNVEC,oRightBracket
      0  34ca					      db	101
      1  34ca		       65		      .byte.b	101
      0  34cb					      db	(UNKNOWNVEC-*)-1
      1  34cb		       d6		      .byte.b	(UNKNOWNVEC-*)-1
      0  34cc					      db	oRightBracket
      1  34cc		       e1		      .byte.b	oRightBracket
      0  34cd					      RTN
      0  34cd					      db	25
      1  34cd		       19		      .byte.b	25
    766  34ce
    767  34ce				   ExpectedVariable
      0  34ce					      ERRMSG	ERR_SYNTAX	;Expected Variable
      0  34ce					      db	13
      1  34ce		       0d		      .byte.b	13
      0  34cf					      dw	ERR_SYNTAX
      1  34cf		       05 00		      .word.w	ERR_SYNTAX
    769  34d1							;
    770  34d1							;================================================================
    771  34d1							; Compare a block of memory
    772  34d1							; CmpMem(Length, Source 1, Source 2)
    773  34d1							; returns on the stack 0 equal, 1 s1>s2, -1 s1<s2
    774  34d1				   ekCmpMem
      0  34d1					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  34d1					      db	101
      1  34d1		       65		      .byte.b	101
      0  34d2					      db	(UNKNOWNVEC-*)-1
      1  34d2		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  34d3					      db	oLeftBracket
      1  34d3		       e0		      .byte.b	oLeftBracket
      0  34d4					      CALL	EXPR	; Length
      0  34d4					      db	28
      1  34d4		       1c		      .byte.b	28
      0  34d5					      dw	EXPR
      1  34d5		       23 34		      .word.w	EXPR
      0  34d7					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  34d7					      db	101
      1  34d7		       65		      .byte.b	101
      0  34d8					      db	(UNKNOWNVEC-*)-1
      1  34d8		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  34d9					      db	oComma
      1  34d9		       e2		      .byte.b	oComma
      0  34da					      CALL	EXPR	; Source 1
      0  34da					      db	28
      1  34da		       1c		      .byte.b	28
      0  34db					      dw	EXPR
      1  34db		       23 34		      .word.w	EXPR
      0  34dd					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  34dd					      db	101
      1  34dd		       65		      .byte.b	101
      0  34de					      db	(UNKNOWNVEC-*)-1
      1  34de		       c3		      .byte.b	(UNKNOWNVEC-*)-1
      0  34df					      db	oComma
      1  34df		       e2		      .byte.b	oComma
      0  34e0					      CALL	EXPR	; Source 2
      0  34e0					      db	28
      1  34e0		       1c		      .byte.b	28
      0  34e1					      dw	EXPR
      1  34e1		       23 34		      .word.w	EXPR
      0  34e3					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  34e3					      db	101
      1  34e3		       65		      .byte.b	101
      0  34e4					      db	(UNKNOWNVEC-*)-1
      1  34e4		       bd		      .byte.b	(UNKNOWNVEC-*)-1
      0  34e5					      db	oRightBracket
      1  34e5		       e1		      .byte.b	oRightBracket
      0  34e6					      CMPMEM		; Compare the memory
      0  34e6					      db	112
      1  34e6		       70		      .byte.b	112
      0  34e7					      RTN
      0  34e7					      db	25
      1  34e7		       19		      .byte.b	25
    784  34e8							;
    785  34e8							;===============================================================================
    786  34e8							; Set/stop/return timer values
    787  34e8							;value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    788  34e8							;cmd	0 =
    789  34e8				   eKTimer
      0  34e8					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  34e8					      db	101
      1  34e8		       65		      .byte.b	101
      0  34e9					      db	(UNKNOWNVEC-*)-1
      1  34e9		       b8		      .byte.b	(UNKNOWNVEC-*)-1
      0  34ea					      db	oLeftBracket
      1  34ea		       e0		      .byte.b	oLeftBracket
      0  34eb					      CALL	EXPR	; purpose 0-4
      0  34eb					      db	28
      1  34eb		       1c		      .byte.b	28
      0  34ec					      dw	EXPR
      1  34ec		       23 34		      .word.w	EXPR
      0  34ee					      TSTB	eKTimerZero,oComma	; Must have a comma if more than one value
      0  34ee					      db	101
      1  34ee		       65		      .byte.b	101
      0  34ef					      db	(eKTimerZero-*)-1
      1  34ef		       07		      .byte.b	(eKTimerZero-*)-1
      0  34f0					      db	oComma
      1  34f0		       e2		      .byte.b	oComma
      0  34f1					      CALL	EXPR	; only used by set parameters
      0  34f1					      db	28
      1  34f1		       1c		      .byte.b	28
      0  34f2					      dw	EXPR
      1  34f2		       23 34		      .word.w	EXPR
      0  34f4					      iJMP	eKTimerOut	; get out
      0  34f4					      db	29
      1  34f4		       1d		      .byte.b	29
      0  34f5					      dw	eKTimerOut
      1  34f5		       fa 34		      .word.w	eKTimerOut
    795  34f7				   eKTimerZero
      0  34f7					      lit	0	; no second parameter
      0  34f7					      db	27
      1  34f7		       1b		      .byte.b	27
      0  34f8					      dw	0
      1  34f8		       00 00		      .word.w	0
    797  34fa				   eKTimerOut
      0  34fa					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  34fa					      db	101
      1  34fa		       65		      .byte.b	101
      0  34fb					      db	(UNKNOWNVEC-*)-1
      1  34fb		       a6		      .byte.b	(UNKNOWNVEC-*)-1
      0  34fc					      db	oRightBracket
      1  34fc		       e1		      .byte.b	oRightBracket
      0  34fd					      Timer
      0  34fd					      db	114
      1  34fd		       72		      .byte.b	114
      0  34fe					      RTN
      0  34fe					      db	25
      1  34fe		       19		      .byte.b	25
    801  34ff
    802  34ff							;====================================================================================
    803  34ff							; peek(mem address) return the value of a byte in memory
    804  34ff							; @[offset] return a word value from offset -- see tstv
    805  34ff							;
    806  34ff							;F1A2:
    807  34ff							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    808  34ff				   ekPeek
      0  34ff					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34ff					      db	101
      1  34ff		       65		      .byte.b	101
      0  3500					      db	(UNKNOWNVEC-*)-1
      1  3500		       a1		      .byte.b	(UNKNOWNVEC-*)-1
      0  3501					      db	oLeftBracket
      1  3501		       e0		      .byte.b	oLeftBracket
      0  3502					      CALL	EXPR	;Get the address to write to
      0  3502					      db	28
      1  3502		       1c		      .byte.b	28
      0  3503					      dw	EXPR
      1  3503		       23 34		      .word.w	EXPR
      0  3505					      TSTB	UNKNOWNVEC,oRightBracket
      0  3505					      db	101
      1  3505		       65		      .byte.b	101
      0  3506					      db	(UNKNOWNVEC-*)-1
      1  3506		       9b		      .byte.b	(UNKNOWNVEC-*)-1
      0  3507					      db	oRightBracket
      1  3507		       e1		      .byte.b	oRightBracket
      0  3508					      PEEKMEM
      0  3508					      db	48
      1  3508		       30		      .byte.b	48
      0  3509					      RTN
      0  3509					      db	25
      1  3509		       19		      .byte.b	25
    814  350a							;=======================================================================================
    815  350a							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    816  350a							;
    817  350a							;F2AZ:
    818  350a							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    819  350a				   ekTask
      0  350a					      TSTBRANCH	ekTaskCompiled
      0  350a					      db	106
      1  350a		       6a		      .byte.b	106
      0  350b					      db	(ekTaskCompiled-*)-1
      1  350b		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  350c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  350c					      db	101
      1  350c		       65		      .byte.b	101
      0  350d					      db	(UNKNOWNVEC-*)-1
      1  350d		       94		      .byte.b	(UNKNOWNVEC-*)-1
      0  350e					      db	oLeftBracket
      1  350e		       e0		      .byte.b	oLeftBracket
      0  350f					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  350f					      db	28
      1  350f		       1c		      .byte.b	28
      0  3510					      dw	EXPR
      1  3510		       23 34		      .word.w	EXPR
      0  3512					      lit	0
      0  3512					      db	27
      1  3512		       1b		      .byte.b	27
      0  3513					      dw	0
      1  3513		       00 00		      .word.w	0
      0  3515					      iJMP	ekTaskLinenum
      0  3515					      db	29
      1  3515		       1d		      .byte.b	29
      0  3516					      dw	ekTaskLinenum
      1  3516		       1b 35		      .word.w	ekTaskLinenum
    825  3518
    826  3518				   ekTaskCompiled
      0  3518					      lit	1
      0  3518					      db	27
      1  3518		       1b		      .byte.b	27
      0  3519					      dw	1
      1  3519		       01 00		      .word.w	1
    828  351b
    829  351b				   ekTaskLinenum
      0  351b					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  351b					      db	61
      1  351b		       3d		      .byte.b	61
      0  351c					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  351c					      db	101
      1  351c		       65		      .byte.b	101
      0  351d					      db	(F2AZNoParms-*)-1
      1  351d		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  351e					      db	oComma
      1  351e		       e2		      .byte.b	oComma
      0  351f					      SAVEMATHSTACK		;Push The mathstack
      0  351f					      db	86
      1  351f		       56		      .byte.b	86
      0  3520					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  3520					      db	89
      1  3520		       59		      .byte.b	89
    834  3521
    835  3521				   F2AZLOOP
      0  3521					      CALL	EXPR
      0  3521					      db	28
      1  3521		       1c		      .byte.b	28
      0  3522					      dw	EXPR
      1  3522		       23 34		      .word.w	EXPR
      0  3524					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  3524					      db	101
      1  3524		       65		      .byte.b	101
      0  3525					      db	(F2AZEndParm-*)-1
      1  3525		       04		      .byte.b	(F2AZEndParm-*)-1
      0  3526					      db	oComma
      1  3526		       e2		      .byte.b	oComma
      0  3527					      IJMP	F2AZLOOP	;check for more
      0  3527					      db	29
      1  3527		       1d		      .byte.b	29
      0  3528					      dw	F2AZLOOP
      1  3528		       21 35		      .word.w	F2AZLOOP
    839  352a
    840  352a				   F2AZEndParm
      0  352a					      RESTOREMATHSTACK		;Back to normal stack
      0  352a					      db	87
      1  352a		       57		      .byte.b	87
      0  352b					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  352b					      db	92
      1  352b		       5c		      .byte.b	92
    843  352c
    844  352c				   F2AZNoParms
      0  352c					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  352c					      db	101
      1  352c		       65		      .byte.b	101
      0  352d					      db	(UNKNOWNVEC-*)-1
      1  352d		       74		      .byte.b	(UNKNOWNVEC-*)-1
      0  352e					      db	oRightBracket
      1  352e		       e1		      .byte.b	oRightBracket
    846  352f
      0  352f					      TASKENABLE		;Enable the task to execute
      0  352f					      db	90
      1  352f		       5a		      .byte.b	90
    848  3530
      0  3530					      RTN		;Returns the Task number
      0  3530					      db	25
      1  3530		       19		      .byte.b	25
    850  3531							;=========================================================================================
    851  3531							; Check for IPC interproccess instructions
    852  3531							;   IPCS  - Send a message
    853  3531							;
    854  3531							;F2AZ1:
    855  3531							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    856  3531				   ekIpcs
      0  3531					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  3531					      db	101
      1  3531		       65		      .byte.b	101
      0  3532					      db	(UNKNOWNVEC-*)-1
      1  3532		       6f		      .byte.b	(UNKNOWNVEC-*)-1
      0  3533					      db	oLeftBracket
      1  3533		       e0		      .byte.b	oLeftBracket
      0  3534					      CALL	EXPR	;Get the message value
      0  3534					      db	28
      1  3534		       1c		      .byte.b	28
      0  3535					      dw	EXPR
      1  3535		       23 34		      .word.w	EXPR
      0  3537					      TSTB	UNKNOWNVEC,oComma
      0  3537					      db	101
      1  3537		       65		      .byte.b	101
      0  3538					      db	(UNKNOWNVEC-*)-1
      1  3538		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  3539					      db	oComma
      1  3539		       e2		      .byte.b	oComma
      0  353a					      CALL	EXPR	;Get pid of task to send to
      0  353a					      db	28
      1  353a		       1c		      .byte.b	28
      0  353b					      dw	EXPR
      1  353b		       23 34		      .word.w	EXPR
      0  353d					      TSTB	UNKNOWNVEC,oRightBracket
      0  353d					      db	101
      1  353d		       65		      .byte.b	101
      0  353e					      db	(UNKNOWNVEC-*)-1
      1  353e		       63		      .byte.b	(UNKNOWNVEC-*)-1
      0  353f					      db	oRightBracket
      1  353f		       e1		      .byte.b	oRightBracket
      0  3540					      IPCSEND		;Send msg and clear pid msg pending
      0  3540					      db	80
      1  3540		       50		      .byte.b	80
      0  3541					      RTN
      0  3541					      db	25
      1  3541		       19		      .byte.b	25
    864  3542							;================================================================================
    865  3542							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    866  3542							;
    867  3542				   ekIpcr
      0  3542					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  3542					      db	101
      1  3542		       65		      .byte.b	101
      0  3543					      db	(UNKNOWNVEC-*)-1
      1  3543		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  3544					      db	oLeftBracket
      1  3544		       e0		      .byte.b	oLeftBracket
      0  3545					      TSTB	F2AZa1,oRightBracket
      0  3545					      db	101
      1  3545		       65		      .byte.b	101
      0  3546					      db	(F2AZa1-*)-1
      1  3546		       07		      .byte.b	(F2AZa1-*)-1
      0  3547					      db	oRightBracket
      1  3547		       e1		      .byte.b	oRightBracket
      0  3548					      LIT	0	;We dont want the pid returned to us
      0  3548					      db	27
      1  3548		       1b		      .byte.b	27
      0  3549					      dw	0
      1  3549		       00 00		      .word.w	0
      0  354b					      IJMP	ekIpcrComplete
      0  354b					      db	29
      1  354b		       1d		      .byte.b	29
      0  354c					      dw	ekIpcrComplete
      1  354c		       53 35		      .word.w	ekIpcrComplete
    872  354e				   F2AZa1
      0  354e					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  354e					      db	33
      1  354e		       21		      .byte.b	33
      0  354f					      db	(UNKNOWNVEC-*)-1
      1  354f		       52		      .byte.b	(UNKNOWNVEC-*)-1
      0  3550					      TSTB	UNKNOWNVEC,oRightBracket
      0  3550					      db	101
      1  3550		       65		      .byte.b	101
      0  3551					      db	(UNKNOWNVEC-*)-1
      1  3551		       50		      .byte.b	(UNKNOWNVEC-*)-1
      0  3552					      db	oRightBracket
      1  3552		       e1		      .byte.b	oRightBracket
    875  3553
    876  3553				   ekIpcrComplete
      0  3553					      IPCIO		;Set the io bit and exit task till message
      0  3553					      db	83
      1  3553		       53		      .byte.b	83
      0  3554					      IPCRECEIVE		;Get the message
      0  3554					      db	81
      1  3554		       51		      .byte.b	81
      0  3555					      RTN
      0  3555					      db	25
      1  3555		       19		      .byte.b	25
    880  3556							;===============================================================================
    881  3556							; IPCC ---- check if a message is available
    882  3556				   ekIpcc
      0  3556					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3556					      db	101
      1  3556		       65		      .byte.b	101
      0  3557					      db	(UNKNOWNVEC-*)-1
      1  3557		       4a		      .byte.b	(UNKNOWNVEC-*)-1
      0  3558					      db	oLeftBracket
      1  3558		       e0		      .byte.b	oLeftBracket
      0  3559					      TSTB	UNKNOWNVEC,oRightBracket
      0  3559					      db	101
      1  3559		       65		      .byte.b	101
      0  355a					      db	(UNKNOWNVEC-*)-1
      1  355a		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  355b					      db	oRightBracket
      1  355b		       e1		      .byte.b	oRightBracket
      0  355c					      IPCCHECK
      0  355c					      db	82
      1  355c		       52		      .byte.b	82
      0  355d					      RTN
      0  355d					      db	25
      1  355d		       19		      .byte.b	25
    887  355e
    888  355e				   UNKNOWNID
      0  355e					      IJMP	UNKNOWN
      0  355e					      db	29
      1  355e		       1d		      .byte.b	29
      0  355f					      dw	UNKNOWN
      1  355f		       1f 34		      .word.w	UNKNOWN
    890  3561							;============================================================
    891  3561							; RND() is supposed to have an argument but if none
    892  3561							; was provided, just assume a large value.
    893  3561							;
    894  3561				   ekRnd
      0  3561					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3561					      db	101
      1  3561		       65		      .byte.b	101
      0  3562					      db	(UNKNOWNVEC-*)-1
      1  3562		       3f		      .byte.b	(UNKNOWNVEC-*)-1
      0  3563					      db	oLeftBracket
      1  3563		       e0		      .byte.b	oLeftBracket
      0  3564					      TSTB	F2A1,oRightBracket
      0  3564					      db	101
      1  3564		       65		      .byte.b	101
      0  3565					      db	(F2A1-*)-1
      1  3565		       06		      .byte.b	(F2A1-*)-1
      0  3566					      db	oRightBracket
      1  3566		       e1		      .byte.b	oRightBracket
      0  3567					      LIT	32766
      0  3567					      db	27
      1  3567		       1b		      .byte.b	27
      0  3568					      dw	32766
      1  3568		       fe 7f		      .word.w	32766
      0  356a					      RANDOM
      0  356a					      db	37
      1  356a		       25		      .byte.b	37
      0  356b					      RTN
      0  356b					      db	25
      1  356b		       19		      .byte.b	25
    900  356c
    901  356c				   F2A1
      0  356c					      CALL	EXPR	;GET RANGE
      0  356c					      db	28
      1  356c		       1c		      .byte.b	28
      0  356d					      dw	EXPR
      1  356d		       23 34		      .word.w	EXPR
      0  356f					      TSTB	UNKNOWNVEC,oRightBracket
      0  356f					      db	101
      1  356f		       65		      .byte.b	101
      0  3570					      db	(UNKNOWNVEC-*)-1
      1  3570		       31		      .byte.b	(UNKNOWNVEC-*)-1
      0  3571					      db	oRightBracket
      1  3571		       e1		      .byte.b	oRightBracket
      0  3572					      RANDOM
      0  3572					      db	37
      1  3572		       25		      .byte.b	37
      0  3573					      RTN
      0  3573					      db	25
      1  3573		       19		      .byte.b	25
    906  3574							;==========================================================
    907  3574							;	Return absolute value of expresion
    908  3574							;
    909  3574				   ekAbs
      0  3574					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3574					      db	101
      1  3574		       65		      .byte.b	101
      0  3575					      db	(UNKNOWNVEC-*)-1
      1  3575		       2c		      .byte.b	(UNKNOWNVEC-*)-1
      0  3576					      db	oLeftBracket
      1  3576		       e0		      .byte.b	oLeftBracket
      0  3577					      CALL	EXPR	;get value
      0  3577					      db	28
      1  3577		       1c		      .byte.b	28
      0  3578					      dw	EXPR
      1  3578		       23 34		      .word.w	EXPR
      0  357a					      TSTB	UNKNOWNVEC,oRightBracket
      0  357a					      db	101
      1  357a		       65		      .byte.b	101
      0  357b					      db	(UNKNOWNVEC-*)-1
      1  357b		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  357c					      db	oRightBracket
      1  357c		       e1		      .byte.b	oRightBracket
      0  357d					      ABS
      0  357d					      db	38
      1  357d		       26		      .byte.b	38
      0  357e					      RTN
      0  357e					      db	25
      1  357e		       19		      .byte.b	25
    915  357f							;============================================================
    916  357f							;     Return the the status of a task, provide the PID
    917  357f							;
    918  357f				   ekStat
      0  357f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  357f					      db	101
      1  357f		       65		      .byte.b	101
      0  3580					      db	(UNKNOWNVEC-*)-1
      1  3580		       21		      .byte.b	(UNKNOWNVEC-*)-1
      0  3581					      db	oLeftBracket
      1  3581		       e0		      .byte.b	oLeftBracket
      0  3582					      Call	EXPR
      0  3582					      db	28
      1  3582		       1c		      .byte.b	28
      0  3583					      dw	EXPR
      1  3583		       23 34		      .word.w	EXPR
      0  3585					      TSTB	UNKNOWNVEC,oRightBracket
      0  3585					      db	101
      1  3585		       65		      .byte.b	101
      0  3586					      db	(UNKNOWNVEC-*)-1
      1  3586		       1b		      .byte.b	(UNKNOWNVEC-*)-1
      0  3587					      db	oRightBracket
      1  3587		       e1		      .byte.b	oRightBracket
      0  3588					      TASKSTAT
      0  3588					      db	66
      1  3588		       42		      .byte.b	66
      0  3589					      RTN
      0  3589					      db	25
      1  3589		       19		      .byte.b	25
    924  358a							;==============================================================
    925  358a							; Return the current tasks pid
    926  358a							;
    927  358a				   ekPid
      0  358a					      TASKPID
      0  358a					      db	77
      1  358a		       4d		      .byte.b	77
      0  358b					      RTN
      0  358b					      db	25
      1  358b		       19		      .byte.b	25
    930  358c							;===========================================================================
    931  358c							; Call a machine function, provide the address to call and optionally
    932  358c							; the value to be passed in reg A
    933  358c				   ekCall
      0  358c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  358c					      db	101
      1  358c		       65		      .byte.b	101
      0  358d					      db	(UNKNOWNVEC-*)-1
      1  358d		       14		      .byte.b	(UNKNOWNVEC-*)-1
      0  358e					      db	oLeftBracket
      1  358e		       e0		      .byte.b	oLeftBracket
      0  358f					      CALL	EXPR
      0  358f					      db	28
      1  358f		       1c		      .byte.b	28
      0  3590					      dw	EXPR
      1  3590		       23 34		      .word.w	EXPR
      0  3592					      TSTB	F2B2A,oComma
      0  3592					      db	101
      1  3592		       65		      .byte.b	101
      0  3593					      db	(F2B2A-*)-1
      1  3593		       09		      .byte.b	(F2B2A-*)-1
      0  3594					      db	oComma
      1  3594		       e2		      .byte.b	oComma
      0  3595					      CALL	EXPR
      0  3595					      db	28
      1  3595		       1c		      .byte.b	28
      0  3596					      dw	EXPR
      1  3596		       23 34		      .word.w	EXPR
      0  3598					      TSTB	UNKNOWNVEC,oRightBracket
      0  3598					      db	101
      1  3598		       65		      .byte.b	101
      0  3599					      db	(UNKNOWNVEC-*)-1
      1  3599		       08		      .byte.b	(UNKNOWNVEC-*)-1
      0  359a					      db	oRightBracket
      1  359a		       e1		      .byte.b	oRightBracket
      0  359b					      CALLFUNC
      0  359b					      db	53
      1  359b		       35		      .byte.b	53
      0  359c					      RTN
      0  359c					      db	25
      1  359c		       19		      .byte.b	25
    941  359d							; Run the gosub within this function
    942  359d				   F2B2A
      0  359d					      TSTB	UNKNOWNID,oRightBracket
      0  359d					      db	101
      1  359d		       65		      .byte.b	101
      0  359e					      db	(UNKNOWNID-*)-1
      1  359e		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  359f					      db	oRightBracket
      1  359f		       e1		      .byte.b	oRightBracket
      0  35a0					      LIT	0	; No parameter passed so just load zero to A
      0  35a0					      db	27
      1  35a0		       1b		      .byte.b	27
      0  35a1					      dw	0
      1  35a1		       00 00		      .word.w	0
      0  35a3					      CALLFUNC
      0  35a3					      db	53
      1  35a3		       35		      .byte.b	53
      0  35a4					      RTN
      0  35a4					      db	25
      1  35a4		       19		      .byte.b	25
    947  35a5
    948  35a5
    949  35a5							;=================================================================================
    950  35a5							;Check for a number !
    951  35a5							;
    952  35a5				   FactNumber
      0  35a5					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  35a5					      db	35
      1  35a5		       23		      .byte.b	35
      0  35a6					      db	(FactVariable-*)-1
      1  35a6		       0f		      .byte.b	(FactVariable-*)-1
      0  35a7					      RTN
      0  35a7					      db	25
      1  35a7		       19		      .byte.b	25
    955  35a8
    956  35a8				   FactWithBracket
      0  35a8					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  35a8					      db	101
      1  35a8		       65		      .byte.b	101
      0  35a9					      db	(F2RTN-*)-1
      1  35a9		       08		      .byte.b	(F2RTN-*)-1
      0  35aa					      db	oLeftBracket
      1  35aa		       e0		      .byte.b	oLeftBracket
      0  35ab					      CALL	EXPR
      0  35ab					      db	28
      1  35ab		       1c		      .byte.b	28
      0  35ac					      dw	EXPR
      1  35ac		       23 34		      .word.w	EXPR
      0  35ae					      TST	F2,oRightBracket
      0  35ae					      db	32
      1  35ae		       20		      .byte.b	32
      0  35af					      db	(F2-*)-1
      1  35af		       03		      .byte.b	(F2-*)-1
      0  35b0					      db	oRightBracket,0
      1  35b0		       e1 00		      .byte.b	oRightBracket,0
    960  35b2				   F2RTN
      0  35b2					      RTN
      0  35b2					      db	25
      1  35b2		       19		      .byte.b	25
    962  35b3
    963  35b3				   F2
      0  35b3					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  35b3					      db	13
      1  35b3		       0d		      .byte.b	13
      0  35b4					      dw	ERR_SYNTAX
      1  35b4		       05 00		      .word.w	ERR_SYNTAX
    965  35b6							;
    966  35b6							;=============================================================================
    967  35b6							; See if this is just a simple variable
    968  35b6							;  Allow a subscript for any variable
    969  35b6							;
    970  35b6				   FactVariable
    971  35b6
      0  35b6					      SETR2	tInteger
      0  35b6					      db	94
      1  35b6		       5e		      .byte.b	94
      0  35b7					      db	tInteger
      1  35b7		       a4		      .byte.b	tInteger
      0  35b8					      TSTV	FactWithBracket
      0  35b8					      db	33
      1  35b8		       21		      .byte.b	33
      0  35b9					      db	(FactWithBracket-*)-1
      1  35b9		       ee		      .byte.b	(FactWithBracket-*)-1
      0  35ba					      TSTBYTE	FactFNParm,R2,GOSUB_RTN_VALUE
      0  35ba					      db	97
      1  35ba		       61		      .byte.b	97
      0  35bb					      db	(FactFNParm-*)-1
      1  35bb		       08		      .byte.b	(FactFNParm-*)-1
      0  35bc					      dw	R2
      1  35bc		       58 00		      .word.w	R2
      0  35be					      db	GOSUB_RTN_VALUE
      1  35be		       81		      .byte.b	GOSUB_RTN_VALUE
      0  35bf					      CALL	FactVarPTR
      0  35bf					      db	28
      1  35bf		       1c		      .byte.b	28
      0  35c0					      dw	FactVarPTR
      1  35c0		       d3 35		      .word.w	FactVarPTR
    976  35c2							;	  CALL	      FactVariableValue
      0  35c2					      IND		; get the variable value
      0  35c2					      db	20
      1  35c2		       14		      .byte.b	20
      0  35c3					      RTN
      0  35c3					      db	25
      1  35c3		       19		      .byte.b	25
    979  35c4
    980  35c4				   FactFNParm
      0  35c4					      TSTB	FactExpectedOpeningBracket,oLeftSQBracket
      0  35c4					      db	101
      1  35c4		       65		      .byte.b	101
      0  35c5					      db	(FactExpectedOpeningBracket-*)-1
      1  35c5		       44		      .byte.b	(FactExpectedOpeningBracket-*)-1
      0  35c6					      db	oLeftSQBracket
      1  35c6		       e4		      .byte.b	oLeftSQBracket
      0  35c7					      CALL	EXPR
      0  35c7					      db	28
      1  35c7		       1c		      .byte.b	28
      0  35c8					      dw	EXPR
      1  35c8		       23 34		      .word.w	EXPR
      0  35ca					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  35ca					      db	101
      1  35ca		       65		      .byte.b	101
      0  35cb					      db	(FactMissingRightBracket-*)-1
      1  35cb		       3b		      .byte.b	(FactMissingRightBracket-*)-1
      0  35cc					      db	oRightSQBracket
      1  35cc		       e5		      .byte.b	oRightSQBracket
      0  35cd					      SUBSCRIPT	GOSUB_RTN_VALUE
      0  35cd					      db	64
      1  35cd		       40		      .byte.b	64
      0  35ce					      db	GOSUB_RTN_VALUE
      1  35ce		       81		      .byte.b	GOSUB_RTN_VALUE
      0  35cf					      SETR2	tInteger
      0  35cf					      db	94
      1  35cf		       5e		      .byte.b	94
      0  35d0					      db	tInteger
      1  35d0		       a4		      .byte.b	tInteger
      0  35d1					      IND
      0  35d1					      db	20
      1  35d1		       14		      .byte.b	20
      0  35d2					      RTN
      0  35d2					      db	25
      1  35d2		       19		      .byte.b	25
    988  35d3
    989  35d3				   FactVarPTR
    990  35d3				   FactVarPtrNoTst
      0  35d3					      TSTB	F2CLocalTask,oBang
      0  35d3					      db	101
      1  35d3		       65		      .byte.b	101
      0  35d4					      db	(F2CLocalTask-*)-1
      1  35d4		       04		      .byte.b	(F2CLocalTask-*)-1
      0  35d5					      db	oBang
      1  35d5		       e8		      .byte.b	oBang
      0  35d6					      IND		; we just got a pid
      0  35d6					      db	20
      1  35d6		       14		      .byte.b	20
      0  35d7					      TSTVT	UNKNOWNID	; if it is not another variable then error, Call test var. task
      0  35d7					      db	93
      1  35d7		       5d		      .byte.b	93
      0  35d8					      db	(UNKNOWNID-*)-1
      1  35d8		       85		      .byte.b	(UNKNOWNID-*)-1
    994  35d9
    995  35d9				   F2CLocalTask
      0  35d9					      SETR2	tInteger	; Sets the default type to integer
      0  35d9					      db	94
      1  35d9		       5e		      .byte.b	94
      0  35da					      db	tInteger
      1  35da		       a4		      .byte.b	tInteger
      0  35db					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  35db					      db	101
      1  35db		       65		      .byte.b	101
      0  35dc					      db	(F2INTEGER-*)-1
      1  35dc		       11		      .byte.b	(F2INTEGER-*)-1
      0  35dd					      db	oDollar
      1  35dd		       e7		      .byte.b	oDollar
      0  35de					      SETR2	tByte
      0  35de					      db	94
      1  35de		       5e		      .byte.b	94
      0  35df					      db	tByte
      1  35df		       a2		      .byte.b	tByte
      0  35e0					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  35e0					      db	101
      1  35e0		       65		      .byte.b	101
      0  35e1					      db	(F2PTRLOADED-*)-1
      1  35e1		       22		      .byte.b	(F2PTRLOADED-*)-1
      0  35e2					      db	oLeftSQBracket
      1  35e2		       e4		      .byte.b	oLeftSQBracket
      0  35e3					      CALL	EXPR
      0  35e3					      db	28
      1  35e3		       1c		      .byte.b	28
      0  35e4					      dw	EXPR
      1  35e4		       23 34		      .word.w	EXPR
      0  35e6					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  35e6					      db	101
      1  35e6		       65		      .byte.b	101
      0  35e7					      db	(FactMissingRightBracket-*)-1
      1  35e7		       1f		      .byte.b	(FactMissingRightBracket-*)-1
      0  35e8					      db	oRightSQBracket
      1  35e8		       e5		      .byte.b	oRightSQBracket
      0  35e9					      SUBSCRIPT	tByte	; Byte type array
      0  35e9					      db	64
      1  35e9		       40		      .byte.b	64
      0  35ea					      db	tByte
      1  35ea		       a2		      .byte.b	tByte
      0  35eb					      SETR2	tByte	; Set byte data type
      0  35eb					      db	94
      1  35eb		       5e		      .byte.b	94
      0  35ec					      db	tByte
      1  35ec		       a2		      .byte.b	tByte
      0  35ed					      RTN
      0  35ed					      db	25
      1  35ed		       19		      .byte.b	25
   1005  35ee
   1006  35ee				   F2INTEGER
      0  35ee					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  35ee					      db	101
      1  35ee		       65		      .byte.b	101
      0  35ef					      db	(F2PTRLOADED-*)-1
      1  35ef		       14		      .byte.b	(F2PTRLOADED-*)-1
      0  35f0					      db	oLeftSQBracket
      1  35f0		       e4		      .byte.b	oLeftSQBracket
      0  35f1					      CALL	EXPR
      0  35f1					      db	28
      1  35f1		       1c		      .byte.b	28
      0  35f2					      dw	EXPR
      1  35f2		       23 34		      .word.w	EXPR
      0  35f4					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  35f4					      db	101
      1  35f4		       65		      .byte.b	101
      0  35f5					      db	(FactMissingRightBracket-*)-1
      1  35f5		       11		      .byte.b	(FactMissingRightBracket-*)-1
      0  35f6					      db	oRightSQBracket
      1  35f6		       e5		      .byte.b	oRightSQBracket
      0  35f7					      SUBSCRIPT	tInteger	; Integer type array
      0  35f7					      db	64
      1  35f7		       40		      .byte.b	64
      0  35f8					      db	tInteger
      1  35f8		       a4		      .byte.b	tInteger
      0  35f9					      SETR2	tInteger	; Set word datatype
      0  35f9					      db	94
      1  35f9		       5e		      .byte.b	94
      0  35fa					      db	tInteger
      1  35fa		       a4		      .byte.b	tInteger
      0  35fb					      TSTB	F2PTRLOADED,oBang	; for a word it can be fillowed by a! as ref to other task variables
      0  35fb					      db	101
      1  35fb		       65		      .byte.b	101
      0  35fc					      db	(F2PTRLOADED-*)-1
      1  35fc		       07		      .byte.b	(F2PTRLOADED-*)-1
      0  35fd					      db	oBang
      1  35fd		       e8		      .byte.b	oBang
      0  35fe					      IND		; Get the value of the task context to access
      0  35fe					      db	20
      1  35fe		       14		      .byte.b	20
      0  35ff					      TSTVT	UNKNOWNID	; if it is not another variable name then it is a halt error
      0  35ff					      db	93
      1  35ff		       5d		      .byte.b	93
      0  3600					      db	(UNKNOWNID-*)-1
      1  3600		       5d		      .byte.b	(UNKNOWNID-*)-1
      0  3601					      IJMP	FactVarPTR	; Process the value on the other side
      0  3601					      db	29
      1  3601		       1d		      .byte.b	29
      0  3602					      dw	FactVarPTR
      1  3602		       d3 35		      .word.w	FactVarPTR
   1016  3604				   F2PTRLOADED
      0  3604					      RTN
      0  3604					      db	25
      1  3604		       19		      .byte.b	25
   1018  3605
   1019  3605				   FactVariableValue
      0  3605					      IND		; YES, GET THE VALUE as word
      0  3605					      db	20
      1  3605		       14		      .byte.b	20
      0  3606					      RTN
      0  3606					      db	25
      1  3606		       19		      .byte.b	25
   1022  3607
   1023  3607				   FactMissingRightBracket
      0  3607					      IJMP	ReturnExpectBracket
      0  3607					      db	29
      1  3607		       1d		      .byte.b	29
      0  3608					      dw	ReturnExpectBracket
      1  3608		       3b 36		      .word.w	ReturnExpectBracket
   1025  360a				   FactExpectedOpeningBracket
      0  360a					      ERRMSG	ERR_EXPECTED_OPENING_BRACKET
      0  360a					      db	13
      1  360a		       0d		      .byte.b	13
      0  360b					      dw	ERR_EXPECTED_OPENING_BRACKET
      1  360b		       1a 00		      .word.w	ERR_EXPECTED_OPENING_BRACKET
   1027  360d							;===============================================================================================================================
   1028  360d							;========================= Gosub and function interface ========================================================================
   1029  360d							; Process gosub 1000(Parm1, ...) no return value
   1030  360d							;
   1031  360d				   ekGosub
      0  360d					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  360d					      db	28
      1  360d		       1c		      .byte.b	28
      0  360e					      dw	GOSUBSTATEMENT
      1  360e		       3f 36		      .word.w	GOSUBSTATEMENT
      0  3610					      DONE		; ERROR IF CR NOT NEXT
      0  3610					      db	1
      1  3610		       01		      .byte.b	1
      0  3611					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  3611					      db	8
      1  3611		       08		      .byte.b	8
      0  3612					      db	GOSUB_RTN
      1  3612		       01		      .byte.b	GOSUB_RTN
      0  3613					      FASTXFER		; AND JUMP to sub rtn
      0  3613					      db	107
      1  3613		       6b		      .byte.b	107
   1036  3614							;
   1037  3614							; End of gosub processing
   1038  3614							;===========================================================================
   1039  3614							; Same as gosub but expects a return value
   1040  3614							;   FN 1000(parm1, ....)  Expects an integer to be returned
   1041  3614							;
   1042  3614				   ekGofn
      0  3614					      Call	GOSUBSTATEMENT
      0  3614					      db	28
      1  3614		       1c		      .byte.b	28
      0  3615					      dw	GOSUBSTATEMENT
      1  3615		       3f 36		      .word.w	GOSUBSTATEMENT
      0  3617					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  3617					      db	8
      1  3617		       08		      .byte.b	8
      0  3618					      db	GOSUB_RTN_VALUE
      1  3618		       81		      .byte.b	GOSUB_RTN_VALUE
      0  3619					      FASTXFER
      0  3619					      db	107
      1  3619		       6b		      .byte.b	107
   1046  361a
   1047  361a				   GOFNRet
      0  361a					      RTN
      0  361a					      db	25
      1  361a		       19		      .byte.b	25
   1049  361b							;===============================================================================================================================
   1050  361b							; Return from a gosub
   1051  361b							;
   1052  361b				   ekReturn
      0  361b					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  361b					      db	101
      1  361b		       65		      .byte.b	101
      0  361c					      db	(S2NoReturnValue-*)-1
      1  361c		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  361d					      db	oLeftBracket
      1  361d		       e0		      .byte.b	oLeftBracket
      0  361e					      CALL	EXPR
      0  361e					      db	28
      1  361e		       1c		      .byte.b	28
      0  361f					      dw	EXPR
      1  361f		       23 34		      .word.w	EXPR
      0  3621					      TSTB	ReturnExpectBracket,oRightBracket	; Now a value is on the stack
      0  3621					      db	101
      1  3621		       65		      .byte.b	101
      0  3622					      db	(ReturnExpectBracket-*)-1
      1  3622		       18		      .byte.b	(ReturnExpectBracket-*)-1
      0  3623					      db	oRightBracket
      1  3623		       e1		      .byte.b	oRightBracket
      0  3624					      DONE
      0  3624					      db	1
      1  3624		       01		      .byte.b	1
      0  3625					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  3625					      db	9
      1  3625		       09		      .byte.b	9
      0  3626					      db	(S2RetFunc-*)-1
      1  3626		       11		      .byte.b	(S2RetFunc-*)-1
      0  3627					      db	1
      1  3627		       01		      .byte.b	1
      0  3628					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3628					      db	6
      1  3628		       06		      .byte.b	6
      0  3629					      dw	CO
      1  3629		       02 32		      .word.w	CO
      0  362b					      IJMP	STMT	; Process the new statement
      0  362b					      db	29
      1  362b		       1d		      .byte.b	29
      0  362c					      dw	STMT
      1  362c		       0a 32		      .word.w	STMT
   1060  362e
   1061  362e				   S2NoReturnValue
      0  362e					      DONE
      0  362e					      db	1
      1  362e		       01		      .byte.b	1
      0  362f					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  362f					      db	9
      1  362f		       09		      .byte.b	9
      0  3630					      db	(S2RetFunc-*)-1
      1  3630		       07		      .byte.b	(S2RetFunc-*)-1
      0  3631					      db	0
      1  3631		       00		      .byte.b	0
      0  3632					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3632					      db	6
      1  3632		       06		      .byte.b	6
      0  3633					      dw	CO
      1  3633		       02 32		      .word.w	CO
      0  3635					      IJMP	STMT	; Process the new statement
      0  3635					      db	29
      1  3635		       1d		      .byte.b	29
      0  3636					      dw	STMT
      1  3636		       0a 32		      .word.w	STMT
   1066  3638
   1067  3638				   S2RetFunc
      0  3638					      IJMP	GOFNRet	; Back into the Function
      0  3638					      db	29
      1  3638		       1d		      .byte.b	29
      0  3639					      dw	GOFNRet
      1  3639		       1a 36		      .word.w	GOFNRet
   1069  363b
   1070  363b				   ReturnExpectBracket
      0  363b					      ENDIO
      0  363b					      db	71
      1  363b		       47		      .byte.b	71
      0  363c					      ERRMSG	ERR_CLOSINGBRACKET
      0  363c					      db	13
      1  363c		       0d		      .byte.b	13
      0  363d					      dw	ERR_CLOSINGBRACKET
      1  363d		       17 00		      .word.w	ERR_CLOSINGBRACKET
   1073  363f							;
   1074  363f							; End of return from gosub
   1075  363f							;=============================================================
   1076  363f							; Gosub can be both a Function and a Subroutine
   1077  363f				   GOSUBSTATEMENT
      0  363f					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  363f					      db	106
      1  363f		       6a		      .byte.b	106
      0  3640					      db	(GOSUBCOMPILED-*)-1
      1  3640		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  3641					      CALL	EXPR	; GET DESTINATION
      0  3641					      db	28
      1  3641		       1c		      .byte.b	28
      0  3642					      dw	EXPR
      1  3642		       23 34		      .word.w	EXPR
      0  3644					      CALL	GOSUBCONT
      0  3644					      db	28
      1  3644		       1c		      .byte.b	28
      0  3645					      dw	GOSUBCONT
      1  3645		       52 36		      .word.w	GOSUBCONT
      0  3647					      lit	0	; mark as lookup on stack
      0  3647					      db	27
      1  3647		       1b		      .byte.b	27
      0  3648					      dw	0
      1  3648		       00 00		      .word.w	0
      0  364a					      RTN
      0  364a					      db	25
      1  364a		       19		      .byte.b	25
   1083  364b
   1084  364b				   GOSUBCOMPILED
      0  364b					      CALL	GOSUBCONT
      0  364b					      db	28
      1  364b		       1c		      .byte.b	28
      0  364c					      dw	GOSUBCONT
      1  364c		       52 36		      .word.w	GOSUBCONT
      0  364e					      lit	1	;mark as compiled on stack
      0  364e					      db	27
      1  364e		       1b		      .byte.b	27
      0  364f					      dw	1
      1  364f		       01 00		      .word.w	1
      0  3651					      RTN
      0  3651					      db	25
      1  3651		       19		      .byte.b	25
   1088  3652
   1089  3652				   GOSUBCONT
      0  3652					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters If not bracket get out
      0  3652					      db	101
      1  3652		       65		      .byte.b	101
      0  3653					      db	(GOSUBDONE-*)-1
      1  3653		       11		      .byte.b	(GOSUBDONE-*)-1
      0  3654					      db	oLeftBracket
      1  3654		       e0		      .byte.b	oLeftBracket
      0  3655					      STK2TMP		;Transfer stack top to temp, temp gets line to goto
      0  3655					      db	95
      1  3655		       5f		      .byte.b	95
      0  3656					      PUSHMATHSTACK		;Record stack frame for return
      0  3656					      db	84
      1  3656		       54		      .byte.b	84
   1093  3657				   GOSUBLOOP
      0  3657					      CALL	EXPR	; Allows what ever fits onto stack
      0  3657					      db	28
      1  3657		       1c		      .byte.b	28
      0  3658					      dw	EXPR
      1  3658		       23 34		      .word.w	EXPR
      0  365a					      INCPARMCOUNT
      0  365a					      db	88
      1  365a		       58		      .byte.b	88
      0  365b					      TSTB	GOSUBParmDONE,oComma
      0  365b					      db	101
      1  365b		       65		      .byte.b	101
      0  365c					      db	(GOSUBParmDONE-*)-1
      1  365c		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  365d					      db	oComma
      1  365d		       e2		      .byte.b	oComma
      0  365e					      IJMP	GOSUBLOOP
      0  365e					      db	29
      1  365e		       1d		      .byte.b	29
      0  365f					      dw	GOSUBLOOP
      1  365f		       57 36		      .word.w	GOSUBLOOP
   1098  3661				   GOSUBParmDONE
      0  3661					      TSTB	ReturnExpectBracket,oRightBracket
      0  3661					      db	101
      1  3661		       65		      .byte.b	101
      0  3662					      db	(ReturnExpectBracket-*)-1
      1  3662		       d8		      .byte.b	(ReturnExpectBracket-*)-1
      0  3663					      db	oRightBracket
      1  3663		       e1		      .byte.b	oRightBracket
      0  3664					      TMP2STK		; Restore line to goto
      0  3664					      db	96
      1  3664		       60		      .byte.b	96
   1101  3665				   GOSUBDONE
      0  3665					      RTN
      0  3665					      db	25
      1  3665		       19		      .byte.b	25
   1103  3666
   1104  3666		       36 66	   ILEND      equ	*
------- FILE mytb.asm
   2503  3666		       36 66	   PROGEND    equ	*
   2504  3666
   2505  3666
   2506  3666							;=====================================================
   2507  3666							; Define start of non page zero data
   2508 U36b9					      seg.u	TBData
   2509 U36b9
   2510 U36b9							;=====================================================
   2511 U36b9							; These are storage items not in page zero.
   2512 U36b9							;==================================================================================================
   2513 U36b9							; Task Management information
   2514 U36b9							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2515 U36b9							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2516 U36b9							; Task switchs happen at the beginning of the next Basic command line
   2517 U36b9							; It will not happen during an input or output operations
   2518 U36b9							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2519 U36b9							; Task Zero is always the root task, main line program
   2520 U36b9							;
   2521 U36b9							; Layout is repeated for each configured task
   2522 U36b9							; Task Table Byte   use masks follow
   2523 U36b9		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2524 U36b9		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2525 U36b9		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2526 U36b9		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2527 U36b9		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2528 U36b9
   2529 U36b9		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2530 U36ba		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2531 U36ba		       37 b4	   TASKTABLEEND equ	*	; End of task table
   2532 U36ba		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2533 U37b4
   2534 U37b4							;Task Cycle Counter and reset count
   2535 U37b4		       00 00	   taskCurrentCycles ds	2
   2536 U37b6		       00 00	   taskResetValue ds	2
   2537 U37b8		       00	   taskCounter ds	1	; Count of active tasks
   2538 U37b9
   2539 U37b9							;
   2540 U37b9							; Math stack and IL call and Gosub/For-next return stack definitions
   2541 U37b9							;
   2542 U37b9		       37 b9	   STACKSTART equ	*
   2543 U37b9		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2544 U3949		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2545 U3d31		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2546 U3fb1		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code,taskio block stdin,stdout,stdstat,iostatus
   2547 U3fb1		       00 48	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2548 U3fb1		       42 95	   STACKEND   equ	*
   2549 U3fb1		       0a dc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2550 U4295							;
   2551 U4295							;
   2552 U4295		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2553 U4319		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2554 U431a		       00	   printtx    ds	1	;temp X for print funcs
   2555 U431b		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2556 U431c		       00	   promptChar ds	1	;the character to use for a prompt
   2557 U431d		       00	   diddigit   ds	1	;for leading zero suppression
   2558 U431e		       00	   putsy      ds	1
   2559 U431f		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2560 U4321		       00	   sign       ds	1	;0 = positive, else negative
   2561 U4322		       00 00	   rtemp1     ds	2	;Temp for x and y
   2562 U4324		       00 00	   random     ds	2
   2563 U4326		       00	   tempy      ds	1	;temp y storage
   2564 U4327
   2565 U4327
   2566 U4327							; Moved from page zero as one clock cycle diff gives more space on page zero
   2567 U4327		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2568 U4329		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2569 U432a		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2570 U432b		       00	   lineLength ds	1	;Length of current line
   2571 U432c
   2572 U432c		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2573 U432d		       00	   taskRDPending ds	1	; 1 = background read is pending
   2574 U432e		       00 00 00 00 timercounter ds	4	; if timer is running then this is continuously incremented
   2575 U4332
   2576 U4332				  -	      if	XKIM
   2577 U4332				  -buffer     ds	BUFFER_SIZE
   2578 U4332					      endif
   2579 U4332							;
   2580 U4332							; PROGRAMEND is the end of the user's BASIC program.
   2581 U4332							; More precisely, it is one byte past the end.  Or,
   2582 U4332							; it's where the next line added to the end will be
   2583 U4332							; placed.
   2584 U4332							;
   2585 U4332		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2586 U4334		       00 00	   ProgramEnd ds	2	; End of users basic program, Next free byte after end
   2587 U4336		       00 00	   HighMem    ds	2	; highest location
   2588 U4338		       00 00	   UsedMem    ds	2	; size of user program
   2589 U433a		       00 00	   FreeMem    ds	2	; amount of free memory
   2590 U433c							;
   2591 U433c							;=====================================================
   2592 U433c							; This is the start of the user's BASIC program space.
   2593 U433c							;
   2594 U433c							; PERSONAL GOAL: This should be no larger than $0DFF.
   2595 U433c							;		  0200-05FF = 1K
   2596 U433c							;		  0200-09FF = 2K
   2597 U433c							;		  0200-0DFF = 3K
   2598 U433c							;		  0200-11FF = 4K
   2599 U433c							;		  0200-13FF = 4.5K
   2600 U433c							;
   2601 U433c				  -	      if	FIXED
   2602 U433c				  -	      org	$2000
   2603 U433c					      endif
   2604 U433c
   2605 U433c		       43 3c	   FreeMemStart equ	*
   2606 U433c							;/*
   2607 U433c							;  if	  CTMON65 || XKIM
   2608 U433c							;	  SEG Code
   2609 U433c							;	  org	  AutoRun
   2610 U433c							;	  dw	  TBasicCold
   2611 U433c							;  endif
   2612 U433c							;*/
   2613 U433c					      end
