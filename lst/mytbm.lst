------- FILE mytb.asm LEVEL 1 PASS 4
      1 U1194				   input      processor	6502
      2 U1194 ????						;=====================================================
      3 U1194 ????						; Bob's Tiny BASIC
      4 U1194 ????						;
      5 U1194 ????						; While working on the Corsham Technologies KIM Clone
      6 U1194 ????						; project, I wanted to include a TINY BASIC since that
      7 U1194 ????						; was a highly desirable feature of early computers.
      8 U1194 ????						;
      9 U1194 ????						; Rather than negotiating copyright issues for
     10 U1194 ????						; existing BASICs, I decided to just write one from
     11 U1194 ????						; scratch.
     12 U1194 ????						;
     13 U1194 ????						; 10/07/2017
     14 U1194 ????						;
     15 U1194 ????						; This implements a stripped down Tiny BASIC
     16 U1194 ????						; interpreter using the Interpretive Language (IL)
     17 U1194 ????						; method as described in the first few issues of
     18 U1194 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     19 U1194 ????						; to write various languages simply by changing the
     20 U1194 ????						; IL code rather than the interpreter itself.
     21 U1194 ????						;
     22 U1194 ????						; 10/15/2021 v0.4 - Bob Applegate
     23 U1194 ????						;		* Fxed major bug in findLine that
     24 U1194 ????						;		  caused corrupted lines, crashes, etc.
     25 U1194 ????						;		* If no parameter given to RND, assume
     26 U1194 ????						;		  32766.
     27 U1194 ????						;		* No more error 5 when a program
     28 U1194 ????						;		  reaches the end without an END.
     29 U1194 ????						;
     30 U1194 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.compare
     31 U1194 ????						;		 * Add some usefull system level functions
     32 U1194 ????						;		 * allow a larger number of tiny basic formats
     33 U1194 ????						;		 * Add byte at start of line holding length
     34 U1194 ????						;		   for faster execution of goto and gosub
     35 U1194 ????						;		 * Re-added gosub
     36 U1194 ????						;		 * allow ; or , at end if print stmt
     37 U1194 ????						;		   without CRLF being added.
     38 U1194 ????						;		 * Added extended function erase to
     39 U1194 ????						;		   use the extended ctmon65 rm file
     40 U1194 ????						;		 * Fix quoted text to not have to backtrack
     41 U1194 ????						;
     42 U1194 ????						; www.corshamtech.com
     43 U1194 ????						; bob@corshamtech.com
     44 U1194 ????						;
     45 U1194 ????						;=====================================================
     46 U1194 ????						;
     47 U1194 ????						; Create TRUE and FALSE values for conditionals.
     48 U1194 ????						;
     49 U1194 ????
     50 U1194 ????	       00 00	   FALSE      equ	0
     51 U1194 ????	       ff ff ff ff TRUE       equ	~FALSE
     52 U1194 ????						;
     53 U1194 ????						;---------------------------------------------------------
     54 U1194 ????						; One of these must be set to indicate which environment
     55 U1194 ????						; Tiny BASIC will be running in.  Here are the current
     56 U1194 ????						; environments:
     57 U1194 ????						;
     58 U1194 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     59 U1194 ????						; more K of RAM.
     60 U1194 ????						;
     61 U1194 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     62 U1194 ????						; which enhances, without replacing, the standard KIM
     63 U1194 ????						; monitor.  It gives access to routines to save/load files
     64 U1194 ????						; to a micro SD card.
     65 U1194 ????						;
     66 U1194 ????						; CTMON65 is a from-scratch monitor written for the
     67 U1194 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     68 U1194 ????						; easily be ported to other systems.  It has support for
     69 U1194 ????						; using a micro SD card for file storage/retrieval.
     70 U1194 ????						;
     71 U1194 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     72 U1194 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     73 U1194 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     74 U1194 ????						;
     75 U1194 ????						;   Need to define some macros for the dasm assembler
     76 U1194 ????						;
     77 U1194 ????				      MACRO	dw
     78 U1194 ????				      .word	{0}
     79 U1194 ????				      ENDM
     80 U1194 ????
     81 U1194 ????				      MACRO	db
     82 U1194 ????				      .byte	{0}
     83 U1194 ????				      ENDM
     84 U1194 ????
     85 U1194 ????						;
     86 U1194 ????						; If set, include disk functions.
     87 U1194 ????						;
     88 U1194 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
     89 U1194 ????						;
     90 U1194 ????						; If ILTRACE is set then dump out the address of every
     91 U1194 ????						; IL opcode before executing it.
     92 U1194 ????						;
     93 U1194 ????	       00 00	   ILTRACE    equ	FALSE
     94 U1194 ????						;
     95 U1194 ????						; If FIXED is set, put the IL code and the user
     96 U1194 ????						; program space at fixed locations in memory.	This is
     97 U1194 ????						; meant only for debugging.
     98 U1194 ????						;
     99 U1194 ????	       00 00	   FIXED      equ	FALSE
    100 U1194 ????						;
    101 U1194 ????						; Sets the arithmetic stack depth.  This is *TINY*
    102 U1194 ????						; BASIC, so keep this small!
    103 U1194 ????						;
    104 U1194 ????	       00 08	   STACKSIZE  equ	8	;number of entries
    105 U1194 ????	       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting max is 128
    106 U1194 ????						;
    107 U1194 ????						; Common ASCII constants
    108 U1194 ????						;
    109 U1194 ????	       00 07	   BEL	      equ	$07
    110 U1194 ????	       00 08	   BS	      equ	$08
    111 U1194 ????	       00 09	   TAB	      equ	$09
    112 U1194 ????	       00 0a	   LF	      equ	$0A
    113 U1194 ????	       00 0d	   CR	      equ	$0D
    114 U1194 ????	       00 22	   QUOTE      equ	$22
    115 U1194 ????	       00 20	   SPACE      equ	$20
    116 U1194 ????	       00 2c	   COMMA      equ	',
    117 U1194 ????	       00 3b	   SEMICOLON  equ	';
    118 U1194 ????						;
    119 U1194 ????						; These are error codes
    120 U1194 ????						;
    121 U1194 ????	       00 00	   ERR_NONE   equ	0
    122 U1194 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    123 U1194 ????	       00 02	   ERR_UNDER  equ	2	;stack underflow
    124 U1194 ????	       00 03	   ERR_OVER   equ	3	;stack overflow
    125 U1194 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    126 U1194 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    127 U1194 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    128 U1194 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    129 U1194 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    130 U1194 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    131 U1194 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    132 U1194 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    133 U1194 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;Stack overflow
    134 U1194 ????						;
    135 U1194 ????						;=====================================================
    136 U1194 ????						; Zero page storage.
    137 U1194 ????						;
    138 U1194 ????				      SEG.U	Data
    139 U0040					      org	$0040
    140 U0040
    141 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    142 U0041		       00 00 00 00*variables  ds	26*2	;2 bytes, A-Z
    143 U0041		       00 75	   variablesEnd equ	*
    144 U0075		       00 00	   ILPC       ds	2	;IL program counter
    145 U0077		       00 00	   dpl	      ds	2
    146 U0079		       00 00	   tempIL     ds	2
    147 U007b		       00	   tempIlY    ds	1
    148 U007c		       00	   offset     ds	1
    149 U007d		       00	   lineLength ds	1
    150 U007e							;
    151 U007e							; CURPTR is a pointer to curent BASIC line being
    152 U007e							; executed.  Always points to start of line, CUROFF
    153 U007e							; is the offset to the current character.
    154 U007e							;
    155 U007e		       00 00	   CURPTR     ds	2
    156 U0080		       00	   CUROFF     ds	1
    157 U0081							;
    158 U0081		       00 00	   GOSUBSTACK ds	2	;pointer to gosub stack
    159 U0083							;
    160 U0083
    161 U0083							;
    162 U0083							; R0 and R1 are used for arithmetic operations and
    163 U0083							; general use.
    164 U0083							;
    165 U0083		       00 00	   R0	      ds	2	;arithmetic register 0
    166 U0085		       00 00	   R1	      ds	2	;arithmetic register 1
    167 U0087							;
    168 U0087							; This is zero if in immediate mode, or non-zero
    169 U0087							; if currently running a program.  Any input from
    170 U0087							; the main loop clears this, and the XFER IL
    171 U0087							; statement will set it.
    172 U0087							;
    173 U0087		       00	   RunMode    ds	1
    174 U0088							;
    175 U0088							; Used for line insertion/removal.
    176 U0088							;
    177 U0088		       00 00	   FROM       ds	2
    178 U008a
    179 U008a							; THE ADDRESS USED BY THE PRINTER FUNCTION
    180 U008a							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    181 U008a							;
    182 U008a		       00 88	   PrtFrom    EQU	FROM
    183 U008a							;
    184 U008a							;=====================================================
    185 U008a							;
    186  10d6 ????				      SEG	Code
    187  0200					      org	$0200
    188  0200							;
    189  0200							; Cold start is at $0200.  Warm start is at $0203.
    190  0200							;
    191  0200		       4c 15 02    TBasicCold jmp	cold2	;jump around vectors
    192  0203		       4c 99 02    warm       jmp	warm2
    193  0206							;
    194  0206							; These are the user-supplied vectors to I/O routines.
    195  0206							; If you want, you can just patch these in the binary
    196  0206							; file, but it would be better to change the source
    197  0206							; code.
    198  0206							;
    199  0206				  -	      if	KIM
    200  0206				  -OUTCH      jmp	$1ea0	;output char in A
    201  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    202  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    203  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    204  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    205  0206					      endif
    206  0206				  -	      if	XKIM
    207  0206				  -	      include	"xkim.inc"
    208  0206				  -	      SEG	Code
    209  0206				  -OUTCH      jmp	$1ea0
    210  0206				  -GETCH      jmp	xkGETCH
    211  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    212  0206				  -OUTHEX     jmp	xkPRTBYT
    213  0206				  -MONITOR    jmp	extKIM
    214  0206				  -puts       equ	putsil
    215  0206				  -BUFFER_SIZE equ	132
    216  0206					      endif
    217  0206
    218  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 4
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 4
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							;
     11 Uf048 ????				      SEG.U	rom
     12 Uf000					      org	ROM_START
     13 Uf000							;
     14 Uf000							;=========================================================
     15 Uf000							; Jump table to common functions.  The entries in this
     16 Uf000							; table are used by external programs, so nothing can be
     17 Uf000							; moved or removed from this table.  New entries always
     18 Uf000							; go at the end.  Many of these are internal functions
     19 Uf000							; and I figured they might be handy for others.
     20 Uf000							;
     21 Uf000		       00 00 00    RESET      ds	3
     22 Uf003		       00 00 00    WARM       ds	3
     23 Uf006							;
     24 Uf006							; These are the major and minor revision numbers so that
     25 Uf006							; code can check to see which CTMON65 version is running.
     26 Uf006							;
     27 Uf006		       00	   CTMON65ver ds	1
     28 Uf007		       00	   CTMON65rev ds	1
     29 Uf008		       00		      ds	1	;unused
     30 Uf009							;
     31 Uf009							; Console related functions
     32 Uf009							;
     33 Uf009		       00 00 00    cin	      ds	3
     34 Uf00c		       00 00 00    cout       ds	3
     35 Uf00f		       00 00 00    cstatus    ds	3
     36 Uf012		       00 00 00    putsil     ds	3
     37 Uf015		       00 00 00    getline    ds	3
     38 Uf018		       00 00 00    crlf       ds	3
     39 Uf01b		       00 00 00    HexA       ds	3
     40 Uf01e							;
     41 Uf01e							; Low-level functions to access the SD card system
     42 Uf01e							;
     43 Uf01e					      if	SD_ENABLED	;SD ENABLED
     44 Uf01e		       00 00 00    xParInit   ds	3
     45 Uf021		       00 00 00    xParSetWrite ds	3
     46 Uf024		       00 00 00    xParSetRead ds	3
     47 Uf027		       00 00 00    xParWriteByte ds	3
     48 Uf02a		       00 00 00    xParReadByte ds	3
     49 Uf02d							;
     50 Uf02d							; Higher level SD card functions
     51 Uf02d							;
     52 Uf02d		       00 00 00    DiskPing   ds	3
     53 Uf030		       00 00 00    DiskDir    ds	3
     54 Uf033		       00 00 00    DiskDirNext ds	3
     55 Uf036		       00 00 00    DiskOpenRead ds	3
     56 Uf039		       00 00 00    DiskOpenWrite ds	3
     57 Uf03c		       00 00 00    DiskRead   ds	3
     58 Uf03f		       00 00 00    DiskWrite  ds	3
     59 Uf042		       00 00 00    DiskClose  ds	3
     60 Uf045		       00 00 00    DiskRmFile ds	3
     61 Uf048					      endif		;SD_ENABLED
     62 Uf048
     63 Uf048							;
     64 U008a					      SEG.U	Data
     65 Udf00					      org	RAM_START
     66 Udf00							;
     67 Udf00							; The use of memory starting from here will remain
     68 Udf00							; constant through different versions of CTMON65.
     69 Udf00							;
     70 Udf00		       00 00	   IRQvec     ds	2
     71 Udf02		       00 00	   NMIvec     ds	2
     72 Udf04							;
     73 Udf04							; Before a L(oad) command, these are set to $FF.
     74 Udf04							; After loading, if they are different, jump to
     75 Udf04							; that address.
     76 Udf04							;
     77 Udf04		       00 00	   AutoRun    ds	2
     78 Udf06							;
     79 Udf06							; Pointer to the subroutine that gets the next input
     80 Udf06							; character.  Used for doing disk/console input.
     81 Udf06							;
     82 Udf06		       00 00	   inputVector ds	2
     83 Udf08							;
     84 Udf08							; Same thing for output.
     85 Udf08							;
     86 Udf08		       00 00	   outputVector ds	2
     87 Udf0a							;
     88 Udf0a							; Buffer for GETLINE
     89 Udf0a							;
     90 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    220  0206					      SEG	Code
    221  0206
    222  0206		       4c 0c f0    OUTCH      jmp	cout
    223  0209		       4c 09 f0    GETCH      jmp	cin
    224  020c		       4c 18 f0    CRLF       jmp	crlf
    225  020f		       4c 1b f0    OUTHEX     jmp	HexA
    226  0212		       4c 03 f0    MONITOR    jmp	WARM
    227  0212		       f0 12	   puts       equ	putsil
    228  0215					      endif
    229  0215							;
    230  0215		       20 12 f0    cold2      jsr	puts
      0  0218					      db	CR,LF
      1  0218		       0d 0a		      .byte.b	CR,LF
      0  021a					      db	"Bob's Tiny BASIC v1.0.1"
      1  021a		       42 6f 62 27*	      .byte.b	"Bob's Tiny BASIC v1.0.1"
      0  0231					      db	CR,LF
      1  0231		       0d 0a		      .byte.b	CR,LF
      0  0233					      db	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      1  0233		       68 74 74 70*	      .byte.b	"https://github.com/CorshamTech/6502-Tiny-BASIC"
      0  0261					      db	CR,LF,0
      1  0261		       0d 0a 00 	      .byte.b	CR,LF,0
    236  0264							;
    237  0264		       20 a7 0c 	      jsr	GetSizes	;setup the free space available
    238  0267		       ad 8e 11 	      lda	HighMem
    239  026a		       e9 28		      sbc	#GOSUBSTACKSIZE*2
    240  026c		       85 81		      sta	GOSUBSTACK
    241  026e		       ad 8f 11 	      lda	HighMem+1
    242  0271		       e9 00		      sbc	#0
    243  0273		       85 82		      sta	GOSUBSTACK+1
    244  0275		       a9 4b		      lda	#IL&$ff
    245  0277		       85 75		      sta	ILPC
    246  0279		       a9 0e		      lda	#IL>>8
    247  027b		       85 76		      sta	ILPC+1
    248  027d							;
    249  027d		       a9 94		      lda	#ProgramStart&$ff	;user prog
    250  027f		       8d 8c 11 	      sta	PROGRAMEND
    251  0282		       a9 11		      lda	#ProgramStart>>8
    252  0284		       8d 8d 11 	      sta	PROGRAMEND+1
    253  0287							;
    254  0287							; Initialize the pseudo-random number sequence...
    255  0287							;
    256  0287		       a9 5a		      lda	#$5a
    257  0289		       8d 86 11 	      sta	rtemp1
    258  028c		       a9 9d		      lda	#%10011101
    259  028e		       8d 87 11 	      sta	random
    260  0291		       a9 5b		      lda	#%01011011
    261  0293		       8d 88 11 	      sta	random+1
    262  0296							;
    263  0296		       4c a6 02 	      jmp	coldtwo
    264  0299							;
    265  0299							; This is the warm start entry point
    266  0299							;
    267  0299		       20 0c 02    warm2      jsr	CRLF
    268  029c		       ad 81 11 	      lda	errGoto
    269  029f		       85 75		      sta	ILPC
    270  02a1		       ad 82 11 	      lda	errGoto+1
    271  02a4		       85 76		      sta	ILPC+1
    272  02a6							;
    273  02a6							; And continue with both starts here
    274  02a6							;
    275  02a6		       20 da 0c    coldtwo    jsr	SetOutConsole
    276  02a9							;
    277  02a9							; The ILTrace flag is now run-time settable.
    278  02a9							;
    279  02a9		       a9 00		      lda	#ILTRACE&$ff
    280  02ab		       85 40		      sta	ILTrace
    281  02ad							;
    282  02ad		       a9 00		      lda	#0
    283  02af		       85 87		      sta	RunMode
    284  02b1		       8d f9 10 	      sta	LINBUF
    285  02b4							; Clear everything from the stacks
    286  02b4		       8d e6 10 	      sta	mathStackPtr
    287  02b7		       8d f7 10 	      sta	retStackPtr
    288  02ba		       8d f8 10 	      sta	GoSubStackPtr
    289  02bd							;
    290  02bd		       a9 f9		      lda	#LINBUF&$ff
    291  02bf		       85 7e		      sta	CURPTR
    292  02c1		       a9 10		      lda	#LINBUF>>8
    293  02c3		       85 7f		      sta	CURPTR+1	;fall through...
    294  02c5							;
    295  02c5							;=====================================================
    296  02c5							; This is the top of the IL interpreter.  This fetches
    297  02c5							; and executes the instruction currently pointed to
    298  02c5							; by ILPC and adjusts ILPC to point to the next
    299  02c5							; instruction to execute.
    300  02c5							;
    301  02c5		       a5 40	   NextIL     lda	ILTrace
    302  02c7		       f0 03		      beq	NextIL2
    303  02c9		       20 62 0c 	      jsr	dbgLine
    304  02cc		       a4 80	   NextIL2    ldy	CUROFF
    305  02ce		       20 59 0c 	      jsr	SkipSpaces
    306  02d1		       84 80		      sty	CUROFF
    307  02d3							;
    308  02d3		       20 47 09    NextILStr  jsr	getILByte
    309  02d6							;
    310  02d6							; When the handler is called, these are the conditions
    311  02d6							; of several important items:
    312  02d6							;
    313  02d6							;    (ILPC) will point to the byte AFTER the IL
    314  02d6							;    opcode being executed.
    315  02d6							;
    316  02d6							;    (CURPTR),CUROFF will point to the start of the
    317  02d6							;    next word in the input buffer.  Ie, the next word
    318  02d6							;    in the user program.
    319  02d6							;
    320  02d6		       0a		      asl
    321  02d7		       c9 72		      cmp	#ILTBLend-ILTBL+2
    322  02d9		       90 33		      bcc	ILgood
    323  02db							;
    324  02db							; This handles an illegal IL opcode.  This is serious
    325  02db							; and there's no way to recover.
    326  02db							;
    327  02db		       20 12 f0    ILbad      jsr	puts
      0  02de					      db	CR,LF
      1  02de		       0d 0a		      .byte.b	CR,LF
      0  02e0					      db	"Illegal IL "
      1  02e0		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02eb					      db	0
      1  02eb		       00		      .byte.b	0
    331  02ec							;
    332  02ec							; Well this is awkward, we need to back up the IL
    333  02ec							; by one since it no longer points to the current
    334  02ec							; opcode.
    335  02ec							;
    336  02ec		       20 54 09 	      jsr	decIL
    337  02ef							;
    338  02ef		       a0 00		      ldy	#0
    339  02f1		       b1 75		      lda	(ILPC),y
    340  02f3		       20 0f 02 	      jsr	OUTHEX
    341  02f6		       20 12 f0 	      jsr	puts
      0  02f9					      db	" at ",0
      1  02f9		       20 61 74 20*	      .byte.b	" at ",0
    343  02fe		       a5 76		      lda	ILPC+1
    344  0300		       20 0f 02 	      jsr	OUTHEX
    345  0303		       a5 75		      lda	ILPC
    346  0305		       20 0f 02 	      jsr	OUTHEX
    347  0308		       20 0c 02 	      jsr	CRLF
    348  030b		       4c 12 02 	      jmp	MONITOR
    349  030e							;
    350  030e							; Just jump to the address (ILPC),y.  Have to do
    351  030e							; some goofy stuff.
    352  030e							;
    353  030e		       a8	   ILgood     tay		;move index into Y
    354  030f		       b9 1c 03 	      lda	ILTBL,y
    355  0312		       85 77		      sta	dpl
    356  0314		       b9 1d 03 	      lda	ILTBL+1,y
    357  0317		       85 78		      sta	dpl+1
    358  0319		       6c 77 00 	      jmp	(dpl)	;go to handler
    359  031c							;
    360  031c							;=====================================================
    361  031c							; This is the IL jump table.  The IL opcode is
    362  031c							; mulitplied by two, then looked-up in this table.
    363  031c							; There is absolutely nothing special about the order
    364  031c							; of entries here... they all decode at exactly the
    365  031c							; same speed.	However the entry number must match the
    366  031c							; values in IL.inc.
    367  031c							;
      0  031c				   ILTBL      dw	iXINIT	;0
      1  031c		       a2 03		      .word.w	iXINIT
      0  031e					      dw	iDONE	;1
      1  031e		       aa 03		      .word.w	iDONE
      0  0320					      dw	iPRS	;2
      1  0320		       bd 03		      .word.w	iPRS
      0  0322					      dw	iPRN	;3
      1  0322		       c7 03		      .word.w	iPRN
      0  0324					      dw	iSPC	;4
      1  0324		       d0 03		      .word.w	iSPC
      0  0326					      dw	iNLINE	;5
      1  0326		       07 07		      .word.w	iNLINE
      0  0328					      dw	iNXT	;6
      1  0328		       d8 03		      .word.w	iNXT
      0  032a					      dw	iXFER	;7
      1  032a		       f0 03		      .word.w	iXFER
      0  032c					      dw	iSAV	;8
      1  032c		       1d 04		      .word.w	iSAV
      0  032e					      dw	iRSTR	;9
      1  032e		       2c 04		      .word.w	iRSTR
      0  0330					      dw	iCMPR	;10
      1  0330		       38 04		      .word.w	iCMPR
      0  0332					      dw	iINNUM	;11
      1  0332		       7a 04		      .word.w	iINNUM
      0  0334					      dw	iFIN	;12
      1  0334		       9a 04		      .word.w	iFIN
      0  0336					      dw	iERR	;13
      1  0336		       ab 04		      .word.w	iERR
      0  0338					      dw	iADD	;14
      1  0338		       f7 04		      .word.w	iADD
      0  033a					      dw	iSUB	;15
      1  033a		       0d 05		      .word.w	iSUB
      0  033c					      dw	iNEG	;16
      1  033c		       23 05		      .word.w	iNEG
      0  033e					      dw	iMUL	;17
      1  033e		       3b 05		      .word.w	iMUL
      0  0340					      dw	iDIV	;18
      1  0340		       75 05		      .word.w	iDIV
      0  0342					      dw	iSTORE	;19
      1  0342		       be 05		      .word.w	iSTORE
      0  0344					      dw	iIND	;20
      1  0344		       d1 05		      .word.w	iIND
      0  0346					      dw	iLST	;21
      1  0346		       e1 05		      .word.w	iLST
      0  0348					      dw	iINIT	;22
      1  0348		       8c 03		      .word.w	iINIT
      0  034a					      dw	iGETLINE	;23
      1  034a		       40 06		      .word.w	iGETLINE
      0  034c					      dw	iINSRT	;24
      1  034c		       4c 06		      .word.w	iINSRT
      0  034e					      dw	iRTN	;25
      1  034e		       01 07		      .word.w	iRTN
      0  0350					      dw	MONITOR	;26
      1  0350		       12 02		      .word.w	MONITOR
      0  0352					      dw	iLIT	;27
      1  0352		       1a 07		      .word.w	iLIT
      0  0354					      dw	iCALL	;28
      1  0354		       0d 07		      .word.w	iCALL
      0  0356					      dw	iJMP	;29
      1  0356		       10 07		      .word.w	iJMP
      0  0358					      dw	iVINIT	;30
      1  0358		       27 07		      .word.w	iVINIT
      0  035a					      dw	iERRGOTO	;31
      1  035a		       35 07		      .word.w	iERRGOTO
      0  035c					      dw	iTST	;32
      1  035c		       41 07		      .word.w	iTST
      0  035e					      dw	iTSTV	;33
      1  035e		       c0 07		      .word.w	iTSTV
      0  0360					      dw	iTSTL	;34
      1  0360		       ea 07		      .word.w	iTSTL
      0  0362					      dw	iTSTN	;35
      1  0362		       04 08		      .word.w	iTSTN
      0  0364					      dw	iFREE	;36
      1  0364		       47 08		      .word.w	iFREE
      0  0366					      dw	iRANDOM	;37
      1  0366		       50 08		      .word.w	iRANDOM
      0  0368					      dw	iABS	;38
      1  0368		       26 09		      .word.w	iABS
    407  036a							;
    408  036a							; Disk functions.  There must be pointers
    409  036a							; to functions even if no disk is supported.
    410  036a							; Makes things easier in IL.inc.
    411  036a							;
    412  036a					      if	DISK_ACCESS
      0  036a					      dw	iOPENREAD	;39
      1  036a		       26 0d		      .word.w	iOPENREAD
      0  036c					      dw	iOPENWRITE	;40
      1  036c		       7a 0d		      .word.w	iOPENWRITE
      0  036e					      dw	iDCLOSE	;41
      1  036e		       fe 0d		      .word.w	iDCLOSE
      0  0370					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0370		       99 0d		      .word.w	iDGETLINE
      0  0372					      dw	iDLIST	;43 Did you remeber your towel?
      1  0372		       f8 0d		      .word.w	iDLIST
      0  0374					      dw	iDDIR	;44
      1  0374		       d3 0d		      .word.w	iDDIR
      0  0376					      dw	iRMFILE	;45
      1  0376		       54 0d		      .word.w	iRMFILE
    420  0378				  -	      else
    421  0378				  -	      dw	NextIL	;39
    422  0378				  -	      dw	NextIL	;40
    423  0378				  -	      dw	NextIL	;41
    424  0378				  -	      dw	NextIL	;42
    425  0378				  -	      dw	NextIL	;43
    426  0378				  -	      dw	NextIL	;44
    427  0378				  -	      dw	NextIL	;45
    428  0378					      endif
    429  0378							;
      0  0378					      dw	iCLEARSCREEN	;46
      1  0378		       15 0d		      .word.w	iCLEARSCREEN
      0  037a					      dw	iPOKEMEMORY	;47
      1  037a		       c8 08		      .word.w	iPOKEMEMORY
      0  037c					      dw	iPEEKMEMORY	;48
      1  037c		       dd 08		      .word.w	iPEEKMEMORY
      0  037e					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  037e		       86 07		      .word.w	iTSTLET
      0  0380					      dw	iTSTDONE	;50	Test if we are at the end of a line
      1  0380		       a3 07		      .word.w	iTSTDONE
      0  0382					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0382		       07 09		      .word.w	iGETCHAR
      0  0384					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0384		       1b 09		      .word.w	iPUTCHAR
      0  0386					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  0386		       f2 08		      .word.w	iCallFunc
      0  0388					      dw	iCallFunc2	;54	   call system rtn with value in a
      1  0388		       ed 08		      .word.w	iCallFunc2
      0  038a					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  038a		       6a 07		      .word.w	iTSTStr
    440  038c
    441  038c		       03 8c	   ILTBLend   equ	*
    442  038c							;
    443  038c							;=====================================================
    444  038c							;=====================================================
    445  038c							;=====================================================
    446  038c							; This marks the start of the handlers for IL opcodes.
    447  038c							;=====================================================
    448  038c							;=====================================================
    449  038c							;=====================================================
    450  038c							;
    451  038c							;
    452  038c		       a9 00	   iINIT      lda	#0	;clear IL stack pointer,gosub stack
    453  038e		       8d f7 10 	      sta	retStackPtr
    454  0391		       8d f8 10 	      sta	GoSubStackPtr
    455  0394							;
    456  0394		       a9 94		      lda	#ProgramStart&$ff	;user prog
    457  0396		       85 7e		      sta	CURPTR
    458  0398		       8d 8c 11 	      sta	PROGRAMEND
    459  039b		       a9 11		      lda	#ProgramStart>>8
    460  039d		       85 7f		      sta	CURPTR+1
    461  039f		       8d 8d 11 	      sta	PROGRAMEND+1
    462  03a2							;
    463  03a2							; fall into XINIT...
    464  03a2							;
    465  03a2							;=====================================================
    466  03a2							; This initializes for the start of the next line of
    467  03a2							; BASIC text.
    468  03a2							;
    469  03a2		       a9 00	   iXINIT     lda	#0
    470  03a4		       8d e6 10 	      sta	mathStackPtr	;clear math stack
    471  03a7		       4c c5 02    goodExit   jmp	NextIL
    472  03aa							;
    473  03aa							;=====================================================
    474  03aa							; Verify there is nothing else on this input line.
    475  03aa							; If there is, generate an error.
    476  03aa							;
    477  03aa		       a4 80	   iDONE      ldy	CUROFF
    478  03ac		       20 59 0c 	      jsr	SkipSpaces
    479  03af		       b1 7e		      lda	(CURPTR),y
    480  03b1		       f0 07		      beq	doneadv
    481  03b3		       a2 04		      ldx	#ERR_EXTRA_STUFF
    482  03b5		       a9 00		      lda	#0
    483  03b7		       4c ae 04 	      jmp	iErr2
    484  03ba							;
    485  03ba							; Advance to the next line
    486  03ba							;
    487  03ba				   doneadv
    488  03ba							;		jsr	FindNext2
    489  03ba		       4c c5 02 	      jmp	NextIL
    490  03bd							;
    491  03bd							;=====================================================
    492  03bd							; Print the string until a closing quote
    493  03bd							;
    494  03bd		       a4 80	   iPRS       ldy	CUROFF
    495  03bf							;
    496  03bf							; Odd logic here.  The main loop skipped any leading
    497  03bf							; whitespace inside the quoted text, so move back to
    498  03bf							; the quote, then move forward again.
    499  03bf							;
    500  03bf		       20 e8 0c 	      jsr	PrtQuoted
    501  03c2		       84 80		      sty	CUROFF
    502  03c4		       4c c5 02 	      jmp	NextIL
    503  03c7							;
    504  03c7							;=====================================================
    505  03c7							; Pop the top off the stack and print it as a signed
    506  03c7							; decimal number.
    507  03c7							;
    508  03c7		       20 95 0b    iPRN       jsr	popR0
    509  03ca		       20 ec 09 	      jsr	PrintDecimal
    510  03cd		       4c c5 02 	      jmp	NextIL
    511  03d0							;
    512  03d0							;=====================================================
    513  03d0							; Space to next zone.	Currently the code does not
    514  03d0							; keep track of which column the output is on, so
    515  03d0							; just print a tab.
    516  03d0							;
    517  03d0		       a9 09	   iSPC       lda	#TAB
    518  03d2		       20 06 02 	      jsr	OUTCH
    519  03d5		       4c c5 02 	      jmp	NextIL
    520  03d8							;
    521  03d8							;=====================================================
    522  03d8							; If in immediate mode, jump to the address following
    523  03d8							; the NXT instruction.  Else move to the next line of
    524  03d8							; user code and continue.
    525  03d8							;
    526  03d8		       a5 87	   iNXT       lda	RunMode
    527  03da		       d0 03		      bne	iNxtRun	;in run mode
    528  03dc							;
    529  03dc							; Get address and jump to it.
    530  03dc							;
    531  03dc		       4c 10 07 	      jmp	iJMP
    532  03df							;
    533  03df		       20 cd 09    iNxtRun    jsr	FindNextLine
    534  03e2		       20 df 09 	      jsr	AtEnd
    535  03e5		       d0 03		      bne	iNxtRun2	;not at end
    536  03e7							;
    537  03e7							; At the end of the program.  Pretend an END statement
    538  03e7							; was found.
    539  03e7							;
    540  03e7		       4c 9a 04    iFINv      jmp	iFIN
    541  03ea							;
    542  03ea		       20 43 09    iNxtRun2   jsr	getILWord	;ignore next word
    543  03ed		       4c c5 02 	      jmp	NextIL
    544  03f0							;
    545  03f0							;=====================================================
    546  03f0							; XFER takes the number on top of the stack and looks
    547  03f0							; for that line in the program, or the next line
    548  03f0							; higher.  Ie, if it's 1 but there is no line 1, then
    549  03f0							; find the next one after that.
    550  03f0							;
    551  03f0		       20 95 0b    iXFER      jsr	popR0
    552  03f3		       20 8a 09 	      jsr	findLine
    553  03f6		       20 df 09    iXFER2     jsr	AtEnd	;at end of user program?
    554  03f9		       f0 ec		      beq	iFINv
    555  03fb		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    556  03fd		       84 80		      sty	CUROFF
    557  03ff		       a9 ff		      lda	#$ff
    558  0401		       85 87		      sta	RunMode
    559  0403							;
    560  0403							; Transfer IL to STMT.  I don't like having this
    561  0403							; hard-coded; fix it.
    562  0403							;
    563  0403		       a9 59		      lda	#STMT&$ff
    564  0405		       85 75		      sta	ILPC
    565  0407		       a9 0e		      lda	#STMT>>8
    566  0409		       85 76		      sta	ILPC+1
    567  040b		       4c c5 02 	      jmp	NextIL
    568  040e							;
    569  040e							; Run
    570  040e							;
    571  040e				   iXferok
    572  040e		       a9 ff		      lda	#$ff
    573  0410		       85 87		      sta	RunMode	;we're running
    574  0412							;
    575  0412							; Need a more elegant way to do this
    576  0412							;
    577  0412		       a9 59		      lda	#STMT&$ff
    578  0414		       85 75		      sta	ILPC
    579  0416		       a9 0e		      lda	#STMT>>8
    580  0418		       85 76		      sta	ILPC+1
    581  041a		       4c c5 02 	      jmp	NextIL
    582  041d							;
    583  041d							;=====================================================
    584  041d							; Save the pointer to the next line to the call stack.
    585  041d							;
    586  041d		       20 63 0b    iSAV       jsr	pushLN
    587  0420		       b0 03		      bcs	iSAVErr
    588  0422		       4c c5 02 	      jmp	NextIL
    589  0425		       a2 0c	   iSAVErr    ldx	#12
    590  0427		       a9 00	   iSAVErr2   lda	#0
    591  0429		       4c ae 04 	      jmp	iErr2
    592  042c
    593  042c							;
    594  042c							;=====================================================
    595  042c							; Pop the next line from the call stack.
    596  042c							;
    597  042c		       20 a8 0b    iRSTR      jsr	popLN
    598  042f		       b0 f4		      bcs	iSAVErr
    599  0431		       4c c5 02 	      jmp	NextIL
    600  0434		       a2 0b	   iRSTRErr   ldx	#11
    601  0436		       d0 ef		      bne	iSAVErr2
    602  0438							;
    603  0438							;=====================================================
    604  0438							; Compare items on stack.  Okay, so on input there are
    605  0438							; three things on the stack
    606  0438							;
    607  0438							;    EXPR2 <- Top of stack
    608  0438							;    OP    <- relational operator, next on stack
    609  0438							;    EXPR1 <- last item on stack
    610  0438							;
    611  0438							; Comparison is: EXPR1 <operator> EXPR2
    612  0438							;
    613  0438							; Operator is one of...
    614  0438							;
    615  0438							;    2 is =
    616  0438							;    1 is <
    617  0438							;    3 is <=
    618  0438							;    5 is <>
    619  0438							;    4 is >
    620  0438							;    6 is >=
    621  0438							;
    622  0438							; Those are bit-mapped:
    623  0438							;
    624  0438							;    xxxxxGEL
    625  0438							;
    626  0438							;    G = Greater than
    627  0438							;    E = Equal
    628  0438							;    L = Less than
    629  0438							;
    630  0438							; If the comparison is false, do a NXT, ie, move to the
    631  0438							; next line and continue.  If true, continue executing
    632  0438							; on this line.
    633  0438							;
    634  0438		       00 01	   REL_LT     equ	%001
    635  0438		       00 02	   REL_EQUAL  equ	%010
    636  0438		       00 04	   REL_GT     equ	%100
    637  0438							;
    638  0438		       20 c7 0b    iCMPR      jsr	popR1
    639  043b		       20 da 0b 	      jsr	popMQ	;operator in MQ
    640  043e		       20 95 0b 	      jsr	popR0
    641  0441							;
    642  0441							; See if they are equal or not
    643  0441							;
    644  0441		       a5 83		      lda	R0
    645  0443		       c5 85		      cmp	R1
    646  0445		       d0 0a		      bne	iCMPRnoteq	;try not equal
    647  0447		       a5 84		      lda	R0+1
    648  0449		       c5 86		      cmp	R1+1
    649  044b		       d0 04		      bne	iCMPRnoteq
    650  044d							;
    651  044d							; Equal, set the flag in MQ+1
    652  044d							;
    653  044d		       a9 02		      lda	#REL_EQUAL
    654  044f		       d0 14		      bne	iCMPcom
    655  0451							;
    656  0451							; See if EXPR1 (R0) < EXPR2 (R1)
    657  0451							; See www.6502.org/tutorials/compare_beyond.html
    658  0451							;
    659  0451		       a5 83	   iCMPRnoteq lda	R0
    660  0453		       c5 85		      cmp	R1
    661  0455		       a5 84		      lda	R0+1
    662  0457		       e5 86		      sbc	R1+1
    663  0459		       50 02		      bvc	iCMPR_2
    664  045b		       49 80		      eor	#$80
    665  045d		       30 04	   iCMPR_2    bmi	iCMPlt
    666  045f		       a9 04		      lda	#REL_GT
    667  0461		       d0 02		      bne	iCMPcom
    668  0463		       a9 01	   iCMPlt     lda	#REL_LT	;R0 < R1
    669  0465		       0d 84 11    iCMPcom    ora	MQ+1
    670  0468							;
    671  0468							; Now compare the end result with what the caller
    672  0468							; was looking for.
    673  0468							;
    674  0468		       2d 83 11 	      and	MQ
    675  046b		       f0 07		      beq	iCMPno	;no match
    676  046d		       4c c5 02 	      jmp	NextIL
    677  0470							;
    678  0470							; R0 > R1
    679  0470							;
    680  0470		       a9 04	   iCMPgt     lda	#REL_GT
    681  0472		       d0 f1		      bne	iCMPcom
    682  0474							;
    683  0474							; Not a match, so jump to the next line of code.
    684  0474							;
    685  0474		       20 cd 09    iCMPno     jsr	FindNextLine
    686  0477		       4c f6 03 	      jmp	iXFER2
    687  047a							;
    688  047a							;=====================================================
    689  047a							; Get a line of text from the user, convert to a
    690  047a							; number, leave on top of stack.
    691  047a							;
    692  047a		       a5 80	   iINNUM     lda	CUROFF	;save state before GetLine
    693  047c		       48		      pha
    694  047d		       a5 7f		      lda	CURPTR+1
    695  047f		       48		      pha
    696  0480		       a5 7e		      lda	CURPTR
    697  0482		       48		      pha
    698  0483							;
    699  0483		       a9 3f		      lda	#'?
    700  0485		       20 cf 0a 	      jsr	GetLine
    701  0488		       20 58 0a 	      jsr	getDecimal
    702  048b		       20 50 0b 	      jsr	pushR0	;put onto stack
    703  048e							;
    704  048e		       68		      pla
    705  048f		       85 7e		      sta	CURPTR
    706  0491		       68		      pla
    707  0492		       85 7f		      sta	CURPTR+1
    708  0494		       68		      pla
    709  0495		       85 80		      sta	CUROFF
    710  0497							;
    711  0497		       4c c5 02 	      jmp	NextIL
    712  049a							;
    713  049a
    714  049a							;
    715  049a							;=====================================================
    716  049a							; Stop the currently running program.	Actually very
    717  049a							; simple to do... clear the RunMode flag, then set the
    718  049a							; ILPC to the standard handler and continue running.
    719  049a							;
    720  049a		       a9 00	   iFIN       lda	#0
    721  049c		       85 87		      sta	RunMode
    722  049e							;
    723  049e		       ad 81 11 	      lda	errGoto
    724  04a1		       85 75		      sta	ILPC
    725  04a3		       ad 82 11 	      lda	errGoto+1
    726  04a6		       85 76		      sta	ILPC+1
    727  04a8		       4c c5 02 	      jmp	NextIL
    728  04ab							;
    729  04ab							;=====================================================
    730  04ab							; Handle the ERR opcode.  Following the instruction is
    731  04ab							; a 16 bit error number.  Print an error message, and
    732  04ab							; if we're in run mode, print the line number.  Stop
    733  04ab							; program execution and return to the initial state.
    734  04ab							;
    735  04ab		       20 43 09    iERR       jsr	getILWord	;get err code
    736  04ae							;
    737  04ae							; Enter here with the error code in X (LSB) and A (MSB).
    738  04ae							;
    739  04ae		       86 83	   iErr2      stx	R0
    740  04b0		       85 84		      sta	R0+1
    741  04b2							;
    742  04b2		       20 12 f0 	      jsr	puts
      0  04b5					      db	"Error ",0
      1  04b5		       45 72 72 6f*	      .byte.b	"Error ",0
    744  04bc		       20 ec 09 	      jsr	PrintDecimal
    745  04bf							;
    746  04bf		       a5 87		      lda	RunMode	;running?
    747  04c1		       f0 1b		      beq	iERR2	;nope
    748  04c3		       20 12 f0 	      jsr	puts
      0  04c6					      db	" at line ",0
      1  04c6		       20 61 74 20*	      .byte.b	" at line ",0
    750  04d0		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    751  04d2		       b1 7e		      lda	(CURPTR),y
    752  04d4		       85 83		      sta	R0
    753  04d6		       c8		      iny
    754  04d7		       b1 7e		      lda	(CURPTR),y
    755  04d9		       85 84		      sta	R0+1
    756  04db		       20 ec 09 	      jsr	PrintDecimal
    757  04de							;
    758  04de		       20 0c 02    iERR2      jsr	CRLF
    759  04e1		       a9 00		      lda	#0
    760  04e3		       85 87		      sta	RunMode	;fall through...
    761  04e5							;
    762  04e5							;=====================================================
    763  04e5							; Reset the IL to be back at the idle loop.  Does not
    764  04e5							; clear variables so the user can see what state
    765  04e5							; the program is in.
    766  04e5							;
    767  04e5		       a9 00	   ResetIL    lda	#0
    768  04e7		       8d f7 10 	      sta	retStackPtr
    769  04ea		       ad 81 11 	      lda	errGoto
    770  04ed		       85 75		      sta	ILPC
    771  04ef		       ad 82 11 	      lda	errGoto+1
    772  04f2		       85 76		      sta	ILPC+1
    773  04f4		       4c c5 02 	      jmp	NextIL
    774  04f7							;
    775  04f7							;=====================================================
    776  04f7							; Pop two items off stack, add them, then place the
    777  04f7							; result back onto the stack.
    778  04f7							;
    779  04f7		       20 95 0b    iADD       jsr	popR0
    780  04fa		       20 c7 0b 	      jsr	popR1
    781  04fd		       18		      clc
    782  04fe		       a5 83		      lda	R0
    783  0500		       65 85		      adc	R1
    784  0502		       85 83		      sta	R0
    785  0504		       a5 84		      lda	R0+1
    786  0506		       65 86		      adc	R1+1
    787  0508		       85 84		      sta	R0+1
    788  050a		       4c 6f 05 	      jmp	pushR0nextIl
    789  050d							;
    790  050d							;=====================================================
    791  050d							; Pop two items off the stack.  Subtract the top of
    792  050d							; stack from the lower entry.
    793  050d							;
    794  050d		       20 c7 0b    iSUB       jsr	popR1
    795  0510		       20 95 0b 	      jsr	popR0
    796  0513		       38		      sec
    797  0514		       a5 83		      lda	R0
    798  0516		       e5 85		      sbc	R1
    799  0518		       85 83		      sta	R0
    800  051a		       a5 84		      lda	R0+1
    801  051c		       e5 86		      sbc	R1+1
    802  051e		       85 84		      sta	R0+1
    803  0520		       4c 6f 05 	      jmp	pushR0nextIl
    804  0523							;
    805  0523							;=====================================================
    806  0523							; Negate the top of stack.
    807  0523							;
    808  0523		       20 95 0b    iNEG       jsr	popR0
    809  0526		       a5 83		      lda	R0
    810  0528		       49 ff		      eor	#$ff
    811  052a		       85 83		      sta	R0
    812  052c		       a5 84		      lda	R0+1
    813  052e		       49 ff		      eor	#$ff
    814  0530		       85 84		      sta	R0+1
    815  0532		       e6 83		      inc	R0
    816  0534		       d0 02		      bne	iNEG2
    817  0536		       e6 84		      inc	R0+1
    818  0538		       4c 6f 05    iNEG2      jmp	pushR0nextIl
    819  053b							;
    820  053b							;=====================================================
    821  053b							; Multiply top two items on the stack, put the results
    822  053b							; on top.  This uses the algorithm documented on page
    823  053b							; 115 of "Microprocessor Programming for Computer
    824  053b							; Hobbyists" by Neill Graham.
    825  053b							;
    826  053b		       20 95 0b    iMUL       jsr	popR0	;AC
    827  053e		       20 c7 0b 	      jsr	popR1	;OP
    828  0541							;
    829  0541		       a5 83		      lda	R0
    830  0543		       8d 83 11 	      sta	MQ
    831  0546		       a5 84		      lda	R0+1
    832  0548		       8d 84 11 	      sta	MQ+1
    833  054b		       a9 00		      lda	#0	;clear result
    834  054d		       85 83		      sta	R0
    835  054f		       85 84		      sta	R0+1
    836  0551							;
    837  0551		       a2 10		      ldx	#16	;number of bits in value
    838  0553		       06 83	   multloop   asl	R0
    839  0555		       26 84		      rol	R0+1
    840  0557		       0e 83 11 	      asl	MQ
    841  055a		       2e 84 11 	      rol	MQ+1
    842  055d		       90 0d		      bcc	multno	;skip add if no carry
    843  055f							;
    844  055f							; Add R1 back into R0
    845  055f							;
    846  055f		       18		      clc
    847  0560		       a5 83		      lda	R0
    848  0562		       65 85		      adc	R1
    849  0564		       85 83		      sta	R0
    850  0566		       a5 84		      lda	R0+1
    851  0568		       65 86		      adc	R1+1
    852  056a		       85 84		      sta	R0+1
    853  056c							;
    854  056c		       ca	   multno     dex		;did all bits yet?
    855  056d		       d0 e4		      bne	multloop
    856  056f							;
    857  056f				   pushR0nextIl
    858  056f		       20 50 0b 	      jsr	pushR0	;OP
    859  0572		       4c c5 02 	      jmp	NextIL
    860  0575							;
    861  0575							;=====================================================
    862  0575							; Divide the top of stack into the next to top item.
    863  0575							; Leave results on stack.  Taken from:
    864  0575							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
    865  0575							;
    866  0575							; MQ = R0 / R1
    867  0575							; Remainder is in R0
    868  0575							;
    869  0575		       20 c7 0b    iDIV       jsr	popR1
    870  0578		       20 95 0b 	      jsr	popR0
    871  057b							;
    872  057b							; Check for divide by zero
    873  057b							;
    874  057b		       a5 85		      lda	R1
    875  057d		       05 86		      ora	R1+1
    876  057f		       f0 36		      beq	divby0
    877  0581							;
    878  0581		       20 ef 0b 	      jsr	SaveSigns
    879  0584		       a9 00		      lda	#0	;preset remainder to 0
    880  0586		       8d 83 11 	      sta	MQ
    881  0589		       8d 84 11 	      sta	MQ+1
    882  058c		       a2 10		      ldx	#16	;repeat for each bit: ...
    883  058e
    884  058e		       06 83	   divloop    asl	R0	;dividend lb & hb*2, msb -> Carry
    885  0590		       26 84		      rol	R0+1
    886  0592		       2e 83 11 	      rol	MQ	;remainder lb & hb * 2 + msb from carry
    887  0595		       2e 84 11 	      rol	MQ+1
    888  0598		       ad 83 11 	      lda	MQ
    889  059b		       38		      sec
    890  059c		       e5 85		      sbc	R1	;substract divisor to see if it fits in
    891  059e		       a8		      tay		;lb result -> Y, for we may need it later
    892  059f		       ad 84 11 	      lda	MQ+1
    893  05a2		       e5 86		      sbc	R1+1
    894  05a4		       90 08		      bcc	skip	;if carry=0 then divisor didn't fit in yet
    895  05a6
    896  05a6		       8d 84 11 	      sta	MQ+1	;else save substraction result as new remainder,
    897  05a9		       8c 83 11 	      sty	MQ
    898  05ac		       e6 83		      inc	R0	;and INCrement result cause divisor fit in 1 times
    899  05ae
    900  05ae		       ca	   skip       dex
    901  05af		       d0 dd		      bne	divloop
    902  05b1		       20 2a 0c 	      jsr	RestoreSigns
    903  05b4		       4c 6f 05 	      jmp	pushR0nextIl
    904  05b7							;
    905  05b7							; Indicate divide-by-zero error
    906  05b7							;
    907  05b7		       a2 06	   divby0     ldx	#ERR_DIVIDE_ZERO
    908  05b9		       a9 00		      lda	#0
    909  05bb		       4c ae 04 	      jmp	iErr2
    910  05be							;
    911  05be							;=====================================================
    912  05be							; This pops the top two items off the stack.  The top
    913  05be							; item is a data value and the other is an index into
    914  05be							; the variable table.	Save the value into that entry.
    915  05be							;
    916  05be		       20 95 0b    iSTORE     jsr	popR0	;data
    917  05c1		       20 c7 0b 	      jsr	popR1	;index
    918  05c4		       a6 85		      ldx	R1	;get index
    919  05c6		       a5 83		      lda	R0
    920  05c8		       95 41		      sta	variables,x
    921  05ca		       a5 84		      lda	R0+1
    922  05cc		       95 42		      sta	variables+1,x
    923  05ce		       4c c5 02 	      jmp	NextIL
    924  05d1							;
    925  05d1							;=====================================================
    926  05d1							; Replaces the top of stack with the variable whose
    927  05d1							; index it represents.
    928  05d1							;
    929  05d1		       20 c7 0b    iIND       jsr	popR1
    930  05d4		       a6 85		      ldx	R1	;get index
    931  05d6		       b5 41		      lda	variables,x
    932  05d8		       85 83		      sta	R0
    933  05da		       b5 42		      lda	variables+1,x
    934  05dc		       85 84		      sta	R0+1
    935  05de		       4c 6f 05 	      jmp	pushR0nextIl
    936  05e1							;
    937  05e1							;=====================================================
    938  05e1							; List the current BASIC program in memory.  Uses R0,
    939  05e1							; tempIly, and dpl.
    940  05e1							;
    941  05e1		       20 da 0c    iLST       jsr	SetOutConsole
    942  05e4		       a9 94	   iLST2      lda	#ProgramStart&$ff
    943  05e6		       85 77		      sta	dpl
    944  05e8		       a9 11		      lda	#ProgramStart>>8
    945  05ea		       85 78		      sta	dpl+1
    946  05ec							;
    947  05ec							; dpl/dph point to the current line.  See if we're at
    948  05ec							; the end of the program.
    949  05ec							;
    950  05ec		       a5 77	   iLSTloop   lda	dpl
    951  05ee		       cd 8c 11 	      cmp	PROGRAMEND
    952  05f1		       d0 07		      bne	iLstNotEnd
    953  05f3		       a5 78		      lda	dpl+1
    954  05f5		       cd 8d 11 	      cmp	PROGRAMEND+1
    955  05f8		       f0 40		      beq	iLstdone
    956  05fa							;
    957  05fa		       a0 01	   iLstNotEnd ldy	#1	;Change:  Skip first byte length
    958  05fc		       b1 77		      lda	(dpl),y	;line number LSB
    959  05fe		       85 83		      sta	R0
    960  0600		       c8		      iny
    961  0601		       b1 77		      lda	(dpl),y	;line number MSB
    962  0603		       85 84		      sta	R0+1
    963  0605		       c8		      iny
    964  0606		       84 7b		      sty	tempIlY
    965  0608		       20 ec 09 	      jsr	PrintDecimal
    966  060b		       a9 20		      lda	#SPACE
    967  060d		       20 e5 0c 	      jsr	VOUTCH
    968  0610		       a4 7b		      ldy	tempIlY
    969  0612		       b1 77	   iLSTl2     lda	(dpl),y
    970  0614		       f0 0a		      beq	iLST3	;end of this line
    971  0616		       84 7b		      sty	tempIlY
    972  0618		       20 e5 0c 	      jsr	VOUTCH
    973  061b		       a4 7b		      ldy	tempIlY
    974  061d		       c8		      iny
    975  061e		       d0 f2		      bne	iLSTl2	;do next char
    976  0620							;
    977  0620							; End of this line.  Print CR/LF, then move to the
    978  0620							; next line.
    979  0620							;
    980  0620		       c8	   iLST3      iny
    981  0621		       18		      clc
    982  0622		       98		      tya
    983  0623		       65 77		      adc	dpl
    984  0625		       85 77		      sta	dpl
    985  0627		       a5 78		      lda	dpl+1
    986  0629		       69 00		      adc	#0
    987  062b		       85 78		      sta	dpl+1
    988  062d							;
    989  062d							; Have to manually do CR/LF so it uses the vectored
    990  062d							; output function.
    991  062d							;
    992  062d		       a9 0d		      lda	#CR
    993  062f		       20 e5 0c 	      jsr	VOUTCH
    994  0632		       a9 0a		      lda	#LF
    995  0634		       20 e5 0c 	      jsr	VOUTCH
    996  0637		       4c ec 05 	      jmp	iLSTloop	;do next line
    997  063a							;
    998  063a		       20 da 0c    iLstdone   jsr	SetOutConsole
    999  063d		       4c c5 02 	      jmp	NextIL
   1000  0640							;
   1001  0640							;=====================================================
   1002  0640							; Get a line of text into LINBUF.  Terminate with a
   1003  0640							; null byte.
   1004  0640							;
   1005  0640		       a9 3e	   iGETLINE   lda	#'>	;prompt character
   1006  0642		       20 cf 0a 	      jsr	GetLine
   1007  0645							;
   1008  0645		       a9 00		      lda	#0
   1009  0647		       85 87		      sta	RunMode
   1010  0649		       4c c5 02 	      jmp	NextIL
   1011  064c							;
   1012  064c							;=====================================================
   1013  064c							; This is called when the input buffer contains a line
   1014  064c							; typed in by the user that starts with a line number.
   1015  064c							; Insert the line into the program or delete the line
   1016  064c							; if there is nothing after the line number,
   1017  064c							;
   1018  064c		       a0 00	   iINSRT     ldy	#0
   1019  064e		       20 58 0a 	      jsr	getDecimal	;convert line #
   1020  0651		       20 59 0c 	      jsr	SkipSpaces	;Ignore any spaces after the line number
   1021  0654		       84 7c		      sty	offset	;Save the start of the program line text
   1022  0656							;
   1023  0656							; Now find the line OR the next higher line OR the
   1024  0656							; end of the program.
   1025  0656							;
   1026  0656		       20 8a 09 	      jsr	findLine	; Look for the line number in the current program
   1027  0659							; Returns Z and curptr point to the line if found
   1028  0659							; Returns C and curptr at next higher line if not found and there is a higher line
   1029  0659							; Returns ZC clear and curptr to end of program if higher than all other lines
   1030  0659							;
   1031  0659							; If the line exists, it needs to be removed.
   1032  0659							;
   1033  0659		       d0 41		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1034  065b							;
   1035  065b							; Get length of line to be removed, we fall thru to here if we find a matching line
   1036  065b							;
   1037  065b							;		jsr	getCURPTRLength	;results in Y , curptr is pointing to point we need to insert the line
   1038  065b		       a0 00		      ldy	#0
   1039  065d		       b1 7e		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1040  065f		       a8		      tay
   1041  0660							;If it is equal we delete the line and replace it, get length
   1042  0660							;then adjust all program line after up or down depending on len of line
   1043  0660							;If next higher then just move everythimg down by length bytes
   1044  0660							;This call will return how many bytes in the line we found
   1045  0660		       84 7d		      sty	lineLength	;Save the length of the line we found
   1046  0662							;
   1047  0662							; Compute the new end of the program first.
   1048  0662							;
   1049  0662		       38		      sec		;Set the carry bit
   1050  0663		       ad 8c 11 	      lda	PROGRAMEND	;Get low byte of program end
   1051  0666		       e5 7d		      sbc	lineLength	;Subtract the length of the current line
   1052  0668		       8d 8c 11 	      sta	PROGRAMEND	;save it
   1053  066b		       ad 8d 11 	      lda	PROGRAMEND+1
   1054  066e		       e9 00		      sbc	#0	;Process the carry
   1055  0670		       8d 8d 11 	      sta	PROGRAMEND+1	;We now have the new end of program with the line removed
   1056  0673							;
   1057  0673							; Copy CURPTR into R1 for working
   1058  0673							;
   1059  0673		       a5 7e		      lda	CURPTR	;Save the current position to r1 copy destination
   1060  0675		       85 85		      sta	R1
   1061  0677		       a5 7f		      lda	CURPTR+1
   1062  0679		       85 86		      sta	R1+1
   1063  067b							;
   1064  067b							; See if we're at the end.
   1065  067b							;
   1066  067b		       a5 85	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1067  067d		       cd 8c 11 	      cmp	PROGRAMEND
   1068  0680		       d0 07		      bne	InsDelLoop
   1069  0682		       a5 86		      lda	R1+1
   1070  0684		       cd 8d 11 	      cmp	PROGRAMEND+1
   1071  0687		       f0 13		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1072  0689							;
   1073  0689							; Move one byte, move to next location.
   1074  0689							;
   1075  0689		       a4 7d	   InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1076  068b		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1077  068d		       b1 85		      lda	(R1),y
   1078  068f		       a0 00		      ldy	#0
   1079  0691		       91 85		      sta	(R1),y
   1080  0693		       e6 85		      inc	R1
   1081  0695		       d0 e4		      bne	InsDelChk
   1082  0697		       e6 86		      inc	R1+1
   1083  0699		       4c 7b 06 	      jmp	InsDelChk	; Check if we have moved the last byte
   1084  069c							;
   1085  069c							; Deletion is done.
   1086  069c							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1087  069c							;
   1088  069c		       a4 7c	   insert2    ldy	offset	;get back ptr	Get the current offset
   1089  069e		       b9 f9 10 	      lda	LINBUF,y	;next byte	Get the next byte o be stored
   1090  06a1		       f0 5b		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1091  06a3							;
   1092  06a3							; CURPTR points to where the line will be inserted.
   1093  06a3							;
   1094  06a3		       20 2c 0b 	      jsr	getLineLength	;get bytes needed Reload the number of bytes required for the new line
   1095  06a6							;
   1096  06a6		       ad 8c 11 	      lda	PROGRAMEND	;Load the start address for the copy
   1097  06a9							;At this point curptr still contains the location we will insert data
   1098  06a9		       85 88		      sta	FROM
   1099  06ab		       ad 8d 11 	      lda	PROGRAMEND+1
   1100  06ae		       85 89		      sta	FROM+1
   1101  06b0							;
   1102  06b0		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1103  06b2		       b1 88		      lda	(FROM),y
   1104  06b4		       a4 7d		      ldy	lineLength	;Now load y with new offset downward to store the byte
   1105  06b6		       91 88		      sta	(FROM),y	;Save the new byte
   1106  06b8							;
   1107  06b8		       a5 88		      lda	FROM	;Check if we have copies the last byte
   1108  06ba		       c5 7e		      cmp	CURPTR
   1109  06bc		       d0 06		      bne	mvUpMore
   1110  06be		       a5 89		      lda	FROM+1
   1111  06c0		       c5 7f		      cmp	CURPTR+1
   1112  06c2		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1113  06c4							;
   1114  06c4							; Not done yet
   1115  06c4							;
   1116  06c4		       a5 88	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1117  06c6		       d0 02		      bne	mvUpMore2
   1118  06c8		       c6 89		      dec	FROM+1
   1119  06ca		       c6 88	   mvUpMore2  dec	FROM
   1120  06cc		       4c b0 06 	      jmp	mvup1	;Loop until everything is moved
   1121  06cf							;
   1122  06cf							; All done with copy.
   1123  06cf							;
   1124  06cf		       18	   mvUpDone   clc		;Ok, We are now ready to copy the new line to the program
   1125  06d0		       a5 7d		      lda	lineLength	;Number of bytes to copy from line buff
   1126  06d2		       6d 8c 11 	      adc	PROGRAMEND	;Now pdate the end of program address for space we just opened
   1127  06d5		       8d 8c 11 	      sta	PROGRAMEND
   1128  06d8		       ad 8d 11 	      lda	PROGRAMEND+1
   1129  06db		       69 00		      adc	#0
   1130  06dd		       8d 8d 11 	      sta	PROGRAMEND+1	;Program end now points to the correct enpty space
   1131  06e0							;
   1132  06e0							;===================jlit use length before line newline
   1133  06e0
   1134  06e0		       a0 00		      ldy	#0	;Set offset of copy
   1135  06e2		       a5 7d		      lda	lineLength	;We will insert the actual length of the line first
   1136  06e4		       91 7e		      sta	(CURPTR),y	;Store the length
   1137  06e6		       c8		      iny
   1138  06e7		       a5 83		      lda	R0	;Store the line number next
   1139  06e9		       91 7e		      sta	(CURPTR),y
   1140  06eb		       c8		      iny
   1141  06ec		       a5 84		      lda	R0+1
   1142  06ee		       91 7e		      sta	(CURPTR),y
   1143  06f0		       c8		      iny
   1144  06f1							;
   1145  06f1		       a6 7c		      ldx	offset	;Load the offset into line buffer in page zero
   1146  06f3		       bd f9 10    mvUpLoop2  lda	LINBUF,x	;get a byte
   1147  06f6		       91 7e		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1148  06f8		       f0 04		      beq	mvUpFini	;hit the null at end of line then we are done
   1149  06fa		       e8		      inx
   1150  06fb		       c8		      iny
   1151  06fc		       d0 f5		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1152  06fe							;
   1153  06fe		       4c c5 02    mvUpFini   jmp	NextIL
   1154  0701							;
   1155  0701							;=====================================================
   1156  0701							; Pops the top value of the ILPC stack and stores it
   1157  0701							; in ILPC.  Ie, return from an IL subroutine.
   1158  0701							;
   1159  0701		       20 77 09    iRTN       jsr	popILPC
   1160  0704		       4c c5 02 	      jmp	NextIL
   1161  0707							;
   1162  0707							;=====================================================
   1163  0707							; NLINE print a newline
   1164  0707							;
   1165  0707		       20 0c 02    iNLINE     jsr	CRLF	;user supplied sub
   1166  070a		       4c c5 02 	      jmp	NextIL
   1167  070d							;
   1168  070d							;=====================================================
   1169  070d							; This saves the current ILPC value on the stack, then
   1170  070d							; jumps to the address specified by the next two bytes.
   1171  070d							;
   1172  070d		       20 5d 09    iCALL      jsr	pushILPC	;save ILPC
   1173  0710							;
   1174  0710							; Jmp to a specific location in the IL code.  The new
   1175  0710							; address immediately follows the opcode.
   1176  0710							;
   1177  0710		       20 43 09    iJMP       jsr	getILWord
   1178  0713		       86 75		      stx	ILPC
   1179  0715		       85 76		      sta	ILPC+1
   1180  0717		       4c c5 02 	      jmp	NextIL
   1181  071a							;
   1182  071a							;=====================================================
   1183  071a							; Push the next two bytes onto the arithmetic stack.
   1184  071a							;
   1185  071a		       20 43 09    iLIT       jsr	getILWord
   1186  071d		       86 83		      stx	R0
   1187  071f		       85 84		      sta	R0+1
   1188  0721		       20 50 0b 	      jsr	pushR0
   1189  0724		       4c c5 02 	      jmp	NextIL
   1190  0727							;
   1191  0727							;=====================================================
   1192  0727							; Initialize all variables.  Ie, set to zero.
   1193  0727							;
   1194  0727		       a9 00	   iVINIT     lda	#0
   1195  0729		       a2 00		      ldx	#0
   1196  072b		       95 41	   Vinit2     sta	variables,x
   1197  072d		       e8		      inx
   1198  072e		       e0 34		      cpx	#variablesEnd-variables
   1199  0730		       d0 f9		      bne	Vinit2
   1200  0732		       4c c5 02 	      jmp	NextIL
   1201  0735							;
   1202  0735							;=====================================================
   1203  0735							; Set the address of the error handler.  After any
   1204  0735							; error, set to the ILPC to the specified location.
   1205  0735							;
   1206  0735		       20 43 09    iERRGOTO   jsr	getILWord
   1207  0738		       8e 81 11 	      stx	errGoto
   1208  073b		       8d 82 11 	      sta	errGoto+1
   1209  073e		       4c c5 02 	      jmp	NextIL
   1210  0741							;
   1211  0741							;=====================================================
   1212  0741							; TST is followed by an 8 bit signed offset, then a
   1213  0741							; null terminated string.  Compare the string against
   1214  0741							; the string starting at (CURPTR),CUROFF.  If the
   1215  0741							; strings match, continue executing the next IL
   1216  0741							; opcode.  Else, add the offset to ILPC.
   1217  0741							;
   1218  0741		       20 47 09    iTST       jsr	getILByte
   1219  0744		       85 7c		      sta	offset
   1220  0746							;
   1221  0746		       20 3e 0b 	      jsr	saveIL	;in case of failure
   1222  0749		       a4 80		      ldy	CUROFF
   1223  074b		       84 77		      sty	dpl	;save for later
   1224  074d							;
   1225  074d		       20 47 09    iTSTloop   jsr	getILByte	;get next char
   1226  0750		       f0 11		      beq	iTSTm	;match!
   1227  0752		       a4 77		      ldy	dpl
   1228  0754		       d1 7e		      cmp	(CURPTR),y
   1229  0756		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1230  0758		       09 20		      ora	#$20	; lets allow lowercase as well
   1231  075a		       d1 7e		      cmp	(CURPTR),y
   1232  075c		       d0 22		      bne	iTSTfail	;mismatch
   1233  075e		       c8	   iTSTUpper  iny
   1234  075f		       84 77		      sty	dpl
   1235  0761		       d0 ea		      bne	iTSTloop
   1236  0763							;
   1237  0763							; It's a match!  Clean up a bit.
   1238  0763							;
   1239  0763		       a4 77	   iTSTm      ldy	dpl
   1240  0765		       84 80		      sty	CUROFF
   1241  0767		       4c c5 02 	      jmp	NextIL
   1242  076a							; Test for a single quote
   1243  076a		       20 47 09    iTSTStr    jsr	getILByte
   1244  076d		       85 7c		      sta	offset
   1245  076f		       20 3e 0b 	      jsr	saveIL
   1246  0772		       a4 80		      ldy	CUROFF
   1247  0774		       a9 22		      lda	#'"
   1248  0776		       d1 7e		      cmp	(CURPTR),y
   1249  0778		       d0 06		      bne	iTSTfail
   1250  077a		       c8		      iny
   1251  077b		       84 80		      sty	CUROFF
   1252  077d		       4c d3 02 	      jmp	NextILStr
   1253  0780							;
   1254  0780							; Not a match, reset ILPC and then move to the
   1255  0780							; offset.
   1256  0780							;
   1257  0780		       20 47 0b    iTSTfail   jsr	restoreIL
   1258  0783		       4c 27 08 	      jmp	tstBranch
   1259  0786							;
   1260  0786							;=================================================JLIT=
   1261  0786							; Test if we have a let statement without the let keyword
   1262  0786		       20 47 09    iTSTLET    jsr	getILByte
   1263  0789		       85 7c		      sta	offset
   1264  078b		       20 3e 0b 	      jsr	saveIL	; save to restore when done
   1265  078e
   1266  078e		       a4 80		      ldy	CUROFF
   1267  0790		       20 59 0c 	      jsr	SkipSpaces
   1268  0793		       c8		      iny		; skip the Variable name
   1269  0794		       20 59 0c 	      jsr	SkipSpaces	; skip any SkipSpaces
   1270  0797		       b1 7e		      lda	(CURPTR),y	; Get what should be an equal sign
   1271  0799		       c9 3d		      cmp	#'=	; check if equals
   1272  079b		       d0 e3		      bne	iTSTfail	; return it failed
   1273  079d		       20 47 0b 	      jsr	restoreIL	; restore the IL anyway
   1274  07a0		       4c c5 02 	      jmp	NextIL	; Then next instruction
   1275  07a3							;
   1276  07a3							;================================================jLIT=
   1277  07a3							;Test for end of line
   1278  07a3							;
   1279  07a3		       20 47 09    iTSTDONE   jsr	getILByte
   1280  07a6		       85 7c		      sta	offset
   1281  07a8		       20 3e 0b 	      jsr	saveIL
   1282  07ab
   1283  07ab		       a4 80		      ldy	CUROFF
   1284  07ad		       84 77		      sty	dpl
   1285  07af		       20 59 0c 	      jsr	SkipSpaces
   1286  07b2		       b1 7e		      lda	(CURPTR),y
   1287  07b4		       f0 07		      beq	iTSTDONEtrue
   1288  07b6		       a4 77		      ldy	dpl
   1289  07b8		       84 80		      sty	CUROFF
   1290  07ba		       4c 80 07 	      jmp	iTSTfail
   1291  07bd							;
   1292  07bd							; Advance to the next line
   1293  07bd							;
   1294  07bd		       4c c5 02    iTSTDONEtrue jmp	NextIL
   1295  07c0							;
   1296  07c0							;=====================================================
   1297  07c0							; TSTV is followed by an 8 bit signed offset.	If the
   1298  07c0							; value at (CURPTR),CUROFF appears to be a variable
   1299  07c0							; name, move to the next IL statement.  Else, add the
   1300  07c0							; offset to ILPC.
   1301  07c0							;
   1302  07c0		       20 47 09    iTSTV      jsr	getILByte	;offset
   1303  07c3		       85 7c		      sta	offset
   1304  07c5							;
   1305  07c5		       a4 80		      ldy	CUROFF
   1306  07c7		       20 59 0c 	      jsr	SkipSpaces
   1307  07ca		       b1 7e		      lda	(CURPTR),y
   1308  07cc							;
   1309  07cc		       09 20		      ora	#$20	;make lower then upper
   1310  07ce		       49 20		      eor	#$20	;allow lower case here
   1311  07d0		       c9 41		      cmp	#'A
   1312  07d2		       90 53		      bcc	tstBranch
   1313  07d4		       c9 5b		      cmp	#'Z+1
   1314  07d6		       b0 4f		      bcs	tstBranch
   1315  07d8							;
   1316  07d8							; The condition is true, so convert to an index, push
   1317  07d8							; it onto the stack and continue running.
   1318  07d8							;
   1319  07d8		       38		      sec
   1320  07d9		       e9 41		      sbc	#'A	;index is zero based
   1321  07db		       0a		      asl		;multiply by two
   1322  07dc		       85 83		      sta	R0
   1323  07de		       a9 00		      lda	#0
   1324  07e0		       85 84		      sta	R0+1
   1325  07e2		       20 50 0b 	      jsr	pushR0	;put index onto stack
   1326  07e5		       e6 80		      inc	CUROFF	;move to next input char
   1327  07e7		       4c c5 02 	      jmp	NextIL
   1328  07ea							;
   1329  07ea							;=====================================================
   1330  07ea							; TSTL seems basically the same as TSTN, but leave the
   1331  07ea							; value in R0 instead of pushing onto stack.
   1332  07ea							; This tests for a valid line number
   1333  07ea							;
   1334  07ea		       20 47 09    iTSTL      jsr	getILByte
   1335  07ed		       85 7c		      sta	offset
   1336  07ef							;
   1337  07ef		       a4 80		      ldy	CUROFF
   1338  07f1		       20 59 0c 	      jsr	SkipSpaces
   1339  07f4		       b1 7e		      lda	(CURPTR),y
   1340  07f6							;
   1341  07f6		       c9 30		      cmp	#'0
   1342  07f8		       90 2d		      bcc	tstBranch
   1343  07fa		       c9 3a		      cmp	#'9+1
   1344  07fc		       b0 29		      bcs	tstBranch
   1345  07fe							;
   1346  07fe							; It's a digit, so convert to a number.
   1347  07fe							;
   1348  07fe		       20 58 0a 	      jsr	getDecimal
   1349  0801		       4c c5 02 	      jmp	NextIL
   1350  0804							;
   1351  0804							;=====================================================
   1352  0804							; TSTN checks for a number.  This is very simplistic;
   1353  0804							; if the character is a digit, assume it's a number.
   1354  0804							; Convert to a number and push it onto the stack.
   1355  0804							;
   1356  0804		       20 47 09    iTSTN      jsr	getILByte
   1357  0807		       85 7c		      sta	offset
   1358  0809							;
   1359  0809		       a4 80		      ldy	CUROFF
   1360  080b		       20 59 0c 	      jsr	SkipSpaces
   1361  080e		       b1 7e		      lda	(CURPTR),y
   1362  0810		       c9 2d		      cmp	#'-	;negative?
   1363  0812		       f0 08		      beq	iTSTN_1
   1364  0814		       c9 30		      cmp	#'0
   1365  0816		       90 0f		      bcc	tstBranch
   1366  0818		       c9 3a		      cmp	#'9+1
   1367  081a		       b0 0b		      bcs	tstBranch
   1368  081c							;
   1369  081c							; It's a digit, so convert to a number.
   1370  081c							;
   1371  081c		       20 58 0a    iTSTN_1    jsr	getDecimal
   1372  081f		       84 80		      sty	CUROFF
   1373  0821		       20 50 0b 	      jsr	pushR0	;save onto stack
   1374  0824		       4c c5 02 	      jmp	NextIL
   1375  0827
   1376  0827							;
   1377  0827							; Common jump point for all TSTx instructions that
   1378  0827							; fail to meet the requirements.  This takes the
   1379  0827							; offset and adds/subtracts to/from ILPC.
   1380  0827							;
   1381  0827		       a5 7c	   tstBranch  lda	offset	;get signed offset
   1382  0829		       10 0e		      bpl	tstPositive
   1383  082b							;
   1384  082b							; Do negative branch.	Do sign extension.
   1385  082b							;
   1386  082b		       18		      clc
   1387  082c		       65 75		      adc	ILPC
   1388  082e		       85 75		      sta	ILPC
   1389  0830		       a5 76		      lda	ILPC+1
   1390  0832		       69 ff		      adc	#$ff
   1391  0834		       85 76		      sta	ILPC+1
   1392  0836		       4c c5 02 	      jmp	NextIL	;keep going
   1393  0839							;
   1394  0839		       18	   tstPositive clc
   1395  083a		       65 75		      adc	ILPC
   1396  083c		       85 75		      sta	ILPC
   1397  083e		       a5 76		      lda	ILPC+1
   1398  0840		       69 00		      adc	#0
   1399  0842		       85 76		      sta	ILPC+1
   1400  0844		       4c c5 02 	      jmp	NextIL
   1401  0847							;
   1402  0847							;=====================================================
   1403  0847							; This places the number of free bytes on top of the
   1404  0847							; stack.
   1405  0847							;
   1406  0847		       20 a7 0c    iFREE      jsr	GetSizes
   1407  084a		       20 50 0b 	      jsr	pushR0
   1408  084d		       4c c5 02 	      jmp	NextIL
   1409  0850							;
   1410  0850							;=====================================================
   1411  0850							; Generate a random number from 0-FFFF and then MOD
   1412  0850							; it with the value on top of stack.  Leaves number on
   1413  0850							; stack
   1414  0850							;
   1415  0850		       20 c7 0b    iRANDOM    jsr	popR1	;mod value
   1416  0853							;
   1417  0853							; If the value is zero, just return a one.
   1418  0853							;
   1419  0853		       a5 85		      lda	R1
   1420  0855		       05 86		      ora	R1+1
   1421  0857		       f0 63		      beq	irandom1
   1422  0859							;
   1423  0859		       ad 88 11 	      lda	random+1
   1424  085c		       8d 86 11 	      sta	rtemp1
   1425  085f		       ad 87 11 	      lda	random
   1426  0862		       0a		      asl
   1427  0863		       2e 86 11 	      rol	rtemp1
   1428  0866		       0a		      asl
   1429  0867		       2e 86 11 	      rol	rtemp1
   1430  086a		       18		      clc
   1431  086b		       6d 87 11 	      adc	random
   1432  086e		       48		      pha
   1433  086f		       ad 86 11 	      lda	rtemp1
   1434  0872		       6d 88 11 	      adc	random+1
   1435  0875		       8d 88 11 	      sta	random+1
   1436  0878		       68		      pla
   1437  0879		       69 11		      adc	#$11
   1438  087b		       8d 87 11 	      sta	random
   1439  087e		       ad 88 11 	      lda	random+1
   1440  0881		       69 36		      adc	#$36
   1441  0883		       8d 88 11 	      sta	random+1
   1442  0886
   1443  0886		       ad 87 11 	      lda	random
   1444  0889		       85 83		      sta	R0
   1445  088b		       ad 88 11 	      lda	random+1
   1446  088e		       29 7f		      and	#$7f	;make positive
   1447  0890		       85 84		      sta	R0+1
   1448  0892							;
   1449  0892							; R0 contains the number and R1 contains the max value.
   1450  0892							;
   1451  0892		       a5 83	   iRANDOM_2  lda	R0
   1452  0894		       c5 85		      cmp	R1
   1453  0896		       d0 16		      bne	iRANDOM_1
   1454  0898		       a5 84		      lda	R0+1
   1455  089a		       c5 86		      cmp	R1+1
   1456  089c		       d0 10		      bne	iRANDOM_1	;need to subtract
   1457  089e							;
   1458  089e							; Subtract R1 from R0
   1459  089e							;
   1460  089e		       38	   iRANDOM_sub sec
   1461  089f		       a5 83		      lda	R0
   1462  08a1		       e5 85		      sbc	R1
   1463  08a3		       85 83		      sta	R0
   1464  08a5		       a5 84		      lda	R0+1
   1465  08a7		       e5 86		      sbc	R1+1
   1466  08a9		       85 84		      sta	R0+1
   1467  08ab		       4c 92 08 	      jmp	iRANDOM_2
   1468  08ae							;
   1469  08ae							; See if R1 > R0.  If so, branch to subtract.
   1470  08ae							;
   1471  08ae		       a5 83	   iRANDOM_1  lda	R0
   1472  08b0		       c5 85		      cmp	R1
   1473  08b2		       a5 84		      lda	R0+1
   1474  08b4		       e5 86		      sbc	R1+1
   1475  08b6		       50 02		      bvc	iRANDOM_4
   1476  08b8		       49 80		      eor	#$80
   1477  08ba		       10 e2	   iRANDOM_4  bpl	iRANDOM_sub
   1478  08bc							;
   1479  08bc							; All done.  Almost.  Add one, then push the result.
   1480  08bc							;
   1481  08bc		       e6 83	   irandom1   inc	R0
   1482  08be		       d0 02		      bne	iRANDOM_3
   1483  08c0		       e6 84		      inc	R0+1
   1484  08c2				   iRANDOM_3
   1485  08c2		       20 50 0b 	      jsr	pushR0	;return value
   1486  08c5		       4c c5 02 	      jmp	NextIL
   1487  08c8							;
   1488  08c8							; Poke a value into a memory location
   1489  08c8		       8c 8b 11    iPOKEMEMORY sty	tempy
   1490  08cb		       20 95 0b 	      jsr	popR0
   1491  08ce		       20 c7 0b 	      jsr	popR1
   1492  08d1		       a0 00		      ldy	#0
   1493  08d3		       a5 83		      lda	R0
   1494  08d5		       91 85		      sta	(R1),y
   1495  08d7		       ac 8b 11 	      ldy	tempy
   1496  08da		       4c c5 02 	      jmp	NextIL
   1497  08dd							;
   1498  08dd							; Get a value from a memory location
   1499  08dd							;
   1500  08dd		       8c 8b 11    iPEEKMEMORY sty	tempy
   1501  08e0		       20 95 0b 	      jsr	popR0
   1502  08e3		       a0 00		      ldy	#0
   1503  08e5		       b1 83		      lda	(R0),y
   1504  08e7		       ac 8b 11 	      ldy	tempy
   1505  08ea		       4c 0f 09 	      jmp	iPutStack
   1506  08ed							;
   1507  08ed							; Call to address return what ever is in a to the stack
   1508  08ed							; func2 will load a value into a before the call
   1509  08ed		       20 c7 0b    iCallFunc2 jsr	popR1
   1510  08f0		       a5 85		      lda	R1
   1511  08f2		       20 01 09    iCallFunc  jsr	iCallRtn
   1512  08f5		       85 83		      sta	R0
   1513  08f7		       a9 00		      lda	#0
   1514  08f9		       85 84		      sta	R0+1
   1515  08fb		       20 50 0b 	      jsr	pushR0
   1516  08fe		       4c c5 02 	      jmp	NextIL
   1517  0901		       20 95 0b    iCallRtn   jsr	popR0
   1518  0904		       6c 83 00 	      jmp	(R0)
   1519  0907
   1520  0907
   1521  0907							;===========================================jlit======
   1522  0907							;Get a character from the terminal convert to value
   1523  0907							;leave the number on top f the stack
   1524  0907							;
   1525  0907		       20 09 02    iGETCHAR   jsr	GETCH
   1526  090a					      if	CTMON65
   1527  090a		       48		      pha
   1528  090b		       20 0c f0 	      jsr	cout	;echo echo echo
   1529  090e		       68		      pla
   1530  090f					      endif
   1531  090f		       85 83	   iPutStack  sta	R0
   1532  0911		       a9 00		      lda	#0
   1533  0913		       85 84		      sta	R0+1
   1534  0915		       20 50 0b 	      jsr	pushR0
   1535  0918		       4c c5 02 	      jmp	NextIL
   1536  091b							;===========================================jlit======
   1537  091b							;Put a character to the terminal convert to
   1538  091b							;
   1539  091b		       20 95 0b    iPUTCHAR   jsr	popR0
   1540  091e		       a5 83		      lda	R0
   1541  0920		       20 06 02 	      jsr	OUTCH
   1542  0923		       4c c5 02 	      jmp	NextIL
   1543  0926							;
   1544  0926							;
   1545  0926							;=====================================================
   1546  0926							; Replace TOS with its absolute value.
   1547  0926							;
   1548  0926		       20 95 0b    iABS       jsr	popR0
   1549  0929		       a5 84		      lda	R0+1
   1550  092b		       10 10		      bpl	iABS_1	;already positive
   1551  092d		       49 ff		      eor	#$ff
   1552  092f		       85 84		      sta	R0+1
   1553  0931		       a5 83		      lda	R0
   1554  0933		       49 ff		      eor	#$ff
   1555  0935		       85 83		      sta	R0
   1556  0937		       e6 83		      inc	R0
   1557  0939		       d0 02		      bne	iABS_1
   1558  093b		       e6 84		      inc	R0+1
   1559  093d		       20 50 0b    iABS_1     jsr	pushR0
   1560  0940		       4c c5 02 	      jmp	NextIL
   1561  0943							;================================================================
   1562  0943							;
------- FILE support.asm LEVEL 2 PASS 4
      0  0943					      include	"support.asm"
      1  0943							;
      2  0943							;=====================================================
      3  0943							;=====================================================
      4  0943							;=====================================================
      5  0943							; This marks the start of support functions used by
      6  0943							; the IL opcodes.  These are support functions, NOT
      7  0943							; the IL code.
      8  0943							;=====================================================
      9  0943		       00 14	   GOSUBSTACKSIZE equ	20	;Depth of gosub nesting
     10  0943							;=====================================================
     11  0943					      Seg	Code
     12  0943							;=====================================================
     13  0943							; This gets the next two bytes pointed to by ILPC and
     14  0943							; returns them; X contains LSB, A contains MSB.  ILPC
     15  0943							; is advanced by two, and Y contains 0 on return.
     16  0943
     17  0943							;
     18  0943		       20 47 09    getILWord  jsr	getILByte	;LSB
     19  0946		       aa		      tax
     20  0947							;
     21  0947							;=====================================================
     22  0947							; This gets the next byte pointed to by ILPC and
     23  0947							; returns it in A.  On return, X is unchanged but Y
     24  0947							; contains 0.
     25  0947							;
     26  0947		       a0 00	   getILByte  ldy	#0
     27  0949		       b1 75		      lda	(ILPC),y	;get byte
     28  094b		       08		      php		;save status
     29  094c		       e6 75		      inc	ILPC	;inc LSB
     30  094e		       d0 02		      bne	getILb2	;branch if no overflow
     31  0950		       e6 76		      inc	ILPC+1	;inc MSB
     32  0952		       28	   getILb2    plp		;restore status
     33  0953		       60		      rts
     34  0954							;
     35  0954							;=====================================================
     36  0954							; Decrement ILPC by one.
     37  0954							;
     38  0954		       a5 75	   decIL      lda	ILPC
     39  0956		       d0 02		      bne	decIL2
     40  0958		       c6 76		      dec	ILPC+1
     41  095a		       c6 75	   decIL2     dec	ILPC
     42  095c		       60		      rts
     43  095d							;
     44  095d							;=====================================================
     45  095d							; Push the ILPC onto the return stack.  Actually, this
     46  095d							; pushes the address of ILPC+2 since that's the next
     47  095d							; address to execute.
     48  095d							;
     49  095d		       ac f7 10    pushILPC   ldy	retStackPtr
     50  0960		       a5 75		      lda	ILPC
     51  0962		       18		      clc
     52  0963		       69 02		      adc	#2
     53  0965		       99 e7 10 	      sta	retStack,y
     54  0968		       08		      php		;save C bit
     55  0969		       c8		      iny
     56  096a		       a5 76		      lda	ILPC+1
     57  096c		       28		      plp		;restore C
     58  096d		       69 00		      adc	#0
     59  096f		       99 e7 10 	      sta	retStack,y
     60  0972		       c8		      iny
     61  0973		       8c f7 10 	      sty	retStackPtr
     62  0976		       60		      rts
     63  0977							;
     64  0977							;=====================================================
     65  0977							; Pull the top entry from return stack and put into
     66  0977							; ILPC.
     67  0977							;
     68  0977		       ac f7 10    popILPC    ldy	retStackPtr
     69  097a		       88		      dey
     70  097b		       b9 e7 10 	      lda	retStack,y
     71  097e		       85 76		      sta	ILPC+1
     72  0980		       88		      dey
     73  0981		       b9 e7 10 	      lda	retStack,y
     74  0984		       85 75		      sta	ILPC
     75  0986		       8c f7 10 	      sty	retStackPtr
     76  0989		       60		      rts
     77  098a							;
     78  098a							;=====================================================
     79  098a							; This searches for a specific line number that is in
     80  098a							; R0.	There are three possible return conditions:
     81  098a							; Line numbers are now the third byte, the first byte is now **************
     82  098a							; a pointer to the next line, of course no longer that 53 byte
     83  098a							; per line.
     84  098a							;
     85  098a							; Exact match was found:
     86  098a							;    * Z set
     87  098a							;    * CURPTR points to two-byte line number for that
     88  098a							;	line.
     89  098a							;
     90  098a							; Next highest line found:
     91  098a							;    * Z cleared
     92  098a							;    * C set
     93  098a							;    * CURPTR points to two-byte line number for that
     94  098a							;	line.
     95  098a							;
     96  098a							; End of program reached:
     97  098a							;    * Z cleared
     98  098a							;    * C cleared
     99  098a							;    * CURPTR points to first free byte at end of
    100  098a							;	program.  Ie, it has save value as PROGRAMEND.
    101  098a							;
    102  098a							; A, X, and Y are all undefined on return.
    103  098a							;
    104  098a
    105  098a		       a9 94	   findLine   lda	#ProgramStart&$ff	;Start of program -> CURPTR
    106  098c		       85 7e		      sta	CURPTR
    107  098e		       a9 11		      lda	#ProgramStart>>8
    108  0990		       85 7f		      sta	CURPTR+1
    109  0992							;
    110  0992							; At end of code?
    111  0992							;
    112  0992		       a5 7e	   iXFER1     lda	CURPTR	; chk CURPTR = END PROGRAM
    113  0994		       cd 8c 11 	      cmp	PROGRAMEND
    114  0997		       d0 0b		      bne	xfer2	;not end
    115  0999		       a5 7f		      lda	CURPTR+1
    116  099b		       cd 8d 11 	      cmp	PROGRAMEND+1
    117  099e		       d0 04		      bne	xfer2	;Not at end
    118  09a0							;
    119  09a0							; Line not found and the end of the program was
    120  09a0							; reached.  Return Z and C both clear.
    121  09a0							;
    122  09a0		       a9 01		      lda	#1	;clear Z
    123  09a2		       18		      clc		;clear C
    124  09a3		       60		      rts
    125  09a4							;
    126  09a4							; Check for an exact line number match
    127  09a4							;
    128  09a4		       a5 83	   xfer2      lda	R0
    129  09a6		       a0 01		      ldy	#1	; changed to skip extra length byte
    130  09a8		       d1 7e		      cmp	(CURPTR),y
    131  09aa		       d0 08		      bne	xfernotit
    132  09ac		       c8		      iny
    133  09ad		       a5 84		      lda	R0+1
    134  09af		       d1 7e		      cmp	(CURPTR),y
    135  09b1		       d0 01		      bne	xfernotit	; not a matching line number
    136  09b3							;
    137  09b3							; This is exactly the line we want.
    138  09b3							;
    139  09b3		       60		      rts		;it matches exactly
    140  09b4							;
    141  09b4							; See if this line is greater than the one we're
    142  09b4							; searching for.
    143  09b4							;
    144  09b4		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and lesat significat digit
    145  09b6		       b1 7e		      lda	(CURPTR),y	;compare MSB first
    146  09b8		       c5 84		      cmp	R0+1
    147  09ba		       90 0b		      bcc	xfer3
    148  09bc		       d0 07		      bne	xfer4
    149  09be		       88		      dey
    150  09bf		       b1 7e		      lda	(CURPTR),y	;compare LSB
    151  09c1		       c5 83		      cmp	R0
    152  09c3		       90 02		      bcc	xfer3
    153  09c5							;
    154  09c5							; This line is greater than the one we want, so
    155  09c5							; return Z clear and C set.
    156  09c5							;
    157  09c5		       38	   xfer4      sec		;We found a line number greater
    158  09c6		       60		      rts		;both conditions set
    159  09c7							;
    160  09c7							; Not the line (or droid) we're looking for.  Move to
    161  09c7							; the next line.
    162  09c7							;
    163  09c7		       20 cd 09    xfer3      jsr	FindNextLine
    164  09ca		       4c 92 09 	      jmp	iXFER1
    165  09cd							;
    166  09cd							;=====================================================
    167  09cd							; This advances CURPTR to the next line.  If there
    168  09cd							; are no more lines, this leaves CURPTR equal to
    169  09cd							; ProgramEnd.	Returns CUROFF set to 2.  This assumes
    170  09cd							; CURPTR is pointing to a valid line on entry.  This
    171  09cd							; pointer points to the two-byte line number.
    172  09cd							; Update this points to the 1 byte line length  ****************
    173  09cd							;
    174  09cd				   FindNextLine
    175  09cd		       a0 03		      ldy	#3	;skip line number and length byte
    176  09cf		       84 80		      sty	CUROFF	;this is the new offset
    177  09d1		       a0 00		      ldy	#0
    178  09d3		       b1 7e		      lda	(CURPTR),y	;Get the length
    179  09d5		       18		      clc
    180  09d6		       65 7e		      adc	CURPTR
    181  09d8		       85 7e		      sta	CURPTR
    182  09da		       90 02		      bcc	FindNext4	;exit
    183  09dc		       e6 7f		      inc	CURPTR+1
    184  09de		       60	   FindNext4  rts
    185  09df							;
    186  09df							;=====================================================
    187  09df							; This compares CURPTR to PROGRAMEND and returns Z set
    188  09df							; if they are equal, Z clear if not.
    189  09df							;
    190  09df		       a5 7e	   AtEnd      lda	CURPTR
    191  09e1		       cd 8c 11 	      cmp	PROGRAMEND
    192  09e4		       d0 05		      bne	atendexit
    193  09e6		       a5 7f		      lda	CURPTR+1
    194  09e8		       cd 8d 11 	      cmp	PROGRAMEND+1
    195  09eb		       60	   atendexit  rts
    196  09ec							;
    197  09ec							;=====================================================
    198  09ec							; Print the contents of R0 as a signed decimal number.
    199  09ec							; Does leading zero suppression.
    200  09ec							;
    201  09ec				   PrintDecimal
    202  09ec		       a5 84		      lda	R0+1	;MSB has sign
    203  09ee		       10 17		      bpl	pplus	;it's a positive number
    204  09f0							;
    205  09f0							; Negative numbers need more work.  Invert all the bits,
    206  09f0							; then add one.
    207  09f0							;
    208  09f0		       a9 2d		      lda	#'-
    209  09f2		       20 e5 0c 	      jsr	VOUTCH	;print the negative sign
    210  09f5							;
    211  09f5		       a5 83		      lda	R0	;invert bits
    212  09f7		       49 ff		      eor	#$ff
    213  09f9		       85 83		      sta	R0
    214  09fb		       a5 84		      lda	R0+1
    215  09fd		       49 ff		      eor	#$ff
    216  09ff		       85 84		      sta	R0+1
    217  0a01		       e6 83		      inc	R0	;add one
    218  0a03		       d0 02		      bne	pplus
    219  0a05		       e6 84		      inc	R0+1
    220  0a07							;
    221  0a07							; Print the value in R0 as a positive number.
    222  0a07							;
    223  0a07		       a2 00	   pplus      ldx	#0	;start of subtraction table
    224  0a09		       8e 7f 11 	      stx	diddigit	;no digits yet
    225  0a0c		       a0 00	   pploop     ldy	#0	;result of division
    226  0a0e		       a5 83	   pploop2    lda	R0	;LSB
    227  0a10		       38		      sec
    228  0a11		       fd 50 0a 	      sbc	dectable,x
    229  0a14		       85 83		      sta	R0
    230  0a16		       a5 84		      lda	R0+1
    231  0a18		       fd 51 0a 	      sbc	dectable+1,x
    232  0a1b		       10 2e		      bpl	pplusok	;no underflow
    233  0a1d							;
    234  0a1d							; Else, underflow.  Add back in the LSB of the
    235  0a1d							; table to R0.
    236  0a1d							;
    237  0a1d		       18		      clc
    238  0a1e		       a5 83		      lda	R0
    239  0a20		       7d 50 0a 	      adc	dectable,x
    240  0a23		       85 83		      sta	R0
    241  0a25							;
    242  0a25							; Print the value in Y.  Actually, see if Y is zero and
    243  0a25							; whether any digit has been printed yet.  If Y isn't
    244  0a25							; zero or we've printed a digit, go ahead and print.
    245  0a25							;
    246  0a25		       8e 7e 11 	      stx	printtx
    247  0a28		       98		      tya
    248  0a29		       09 00		      ora	#0	;set flags
    249  0a2b		       d0 05		      bne	pprintit	;non-zero, print
    250  0a2d							;
    251  0a2d		       ad 7f 11 	      lda	diddigit
    252  0a30		       f0 09		      beq	pprintno	;don't print
    253  0a32							;
    254  0a32		       98	   pprintit   tya
    255  0a33		       09 30		      ora	#'0
    256  0a35		       8d 7f 11 	      sta	diddigit
    257  0a38		       20 e5 0c 	      jsr	VOUTCH
    258  0a3b		       ae 7e 11    pprintno   ldx	printtx
    259  0a3e							;
    260  0a3e							; Move to the next table entry
    261  0a3e							;
    262  0a3e		       e8		      inx
    263  0a3f		       e8		      inx
    264  0a40		       e0 08		      cpx	#dectableend-dectable
    265  0a42		       d0 c8		      bne	pploop	;not at end
    266  0a44							;
    267  0a44							; At the end.	R0 contains the final value
    268  0a44							; to print.
    269  0a44							;
    270  0a44		       a5 83		      lda	R0
    271  0a46		       09 30		      ora	#'0
    272  0a48		       4c e5 0c 	      jmp	VOUTCH
    273  0a4b							;
    274  0a4b							; Finish doing the subtraction.
    275  0a4b							;
    276  0a4b		       85 84	   pplusok    sta	R0+1
    277  0a4d		       c8		      iny
    278  0a4e		       d0 be		      bne	pploop2
    279  0a50							;
    280  0a50							; Table of powers-of-ten
    281  0a50							;
      0  0a50				   dectable   dw	10000
      1  0a50		       10 27		      .word.w	10000
      0  0a52					      dw	1000
      1  0a52		       e8 03		      .word.w	1000
      0  0a54					      dw	100
      1  0a54		       64 00		      .word.w	100
      0  0a56					      dw	10
      1  0a56		       0a 00		      .word.w	10
    286  0a56		       0a 58	   dectableend equ	*
    287  0a58							;
    288  0a58							;=====================================================
    289  0a58							; Convert an ASCII string to a number.  On input,
    290  0a58							; (CURPTR),Y points to the first digit.  This gets
    291  0a58							; digit-by-digit until finding a non-number.  Returns
    292  0a58							; Y pointing to the non-digit, and R0 contains the
    293  0a58							; number.  This does NOT check for valid ranges, so
    294  0a58							; a value like "123456789" will produce something,
    295  0a58							; but not what you had expected.
    296  0a58							;
    297  0a58		       a9 00	   getDecimal lda	#0
    298  0a5a		       85 83		      sta	R0
    299  0a5c		       85 84		      sta	R0+1
    300  0a5e		       85 77		      sta	dpl	;temporary negative flag
    301  0a60							;
    302  0a60							; See if it's negative...
    303  0a60							;
    304  0a60		       84 13		      sty	$0013
    305  0a62		       b1 7e		      lda	(CURPTR),y
    306  0a64		       c9 2d		      cmp	#'-
    307  0a66		       d0 02		      bne	getDecLoop
    308  0a68		       e6 77		      inc	dpl	;it's negative
    309  0a6a							;
    310  0a6a		       b1 7e	   getDecLoop lda	(CURPTR),y
    311  0a6c		       c9 30		      cmp	#'0
    312  0a6e		       90 36		      bcc	getDdone
    313  0a70		       c9 3a		      cmp	#'9+1
    314  0a72		       b0 32		      bcs	getDdone
    315  0a74		       38		      sec
    316  0a75		       e9 30		      sbc	#'0	;convert to binary
    317  0a77		       48		      pha
    318  0a78							;
    319  0a78							; Now multiply R0 by 10.  Remember that
    320  0a78							; 2*N + 8*N = 10*N.
    321  0a78							;
    322  0a78		       06 83		      asl	R0
    323  0a7a		       26 84		      rol	R0+1	;*2
    324  0a7c		       a5 83		      lda	R0
    325  0a7e		       85 85		      sta	R1
    326  0a80		       a5 84		      lda	R0+1
    327  0a82		       85 86		      sta	R1+1
    328  0a84		       06 83		      asl	R0
    329  0a86		       26 84		      rol	R0+1	;*4
    330  0a88		       06 83		      asl	R0
    331  0a8a		       26 84		      rol	R0+1	;*8
    332  0a8c		       18		      clc		;now add the partial sums...
    333  0a8d		       a5 83		      lda	R0	;...to get *10
    334  0a8f		       65 85		      adc	R1
    335  0a91		       85 83		      sta	R0
    336  0a93		       a5 84		      lda	R0+1
    337  0a95		       65 86		      adc	R1+1
    338  0a97		       85 84		      sta	R0+1
    339  0a99							;
    340  0a99							; Add in the new digit
    341  0a99							;
    342  0a99		       68		      pla
    343  0a9a		       18		      clc
    344  0a9b		       65 83		      adc	R0
    345  0a9d		       85 83		      sta	R0
    346  0a9f		       90 02		      bcc	getD2
    347  0aa1		       e6 84		      inc	R0+1
    348  0aa3							;
    349  0aa3							; Move to next character
    350  0aa3							;
    351  0aa3		       c8	   getD2      iny
    352  0aa4		       d0 c4		      bne	getDecLoop
    353  0aa6							;
    354  0aa6							; All done with digits, so now deal with it being
    355  0aa6							; negative.  If zero, then don't check for negative
    356  0aa6							; flag.  Ie, -0 is stored as 0.
    357  0aa6							;
    358  0aa6		       a5 83	   getDdone   lda	R0
    359  0aa8		       05 84		      ora	R0+1
    360  0aaa		       f0 16		      beq	getDone2	;zero
    361  0aac		       a5 77		      lda	dpl
    362  0aae		       f0 12		      beq	getDone2	;positive
    363  0ab0							;
    364  0ab0							; Invert all the bits, then add one.
    365  0ab0							;
    366  0ab0		       a5 83		      lda	R0
    367  0ab2		       49 ff		      eor	#$ff
    368  0ab4		       85 83		      sta	R0
    369  0ab6		       a5 84		      lda	R0+1
    370  0ab8		       49 ff		      eor	#$ff
    371  0aba		       85 84		      sta	R0+1
    372  0abc							;
    373  0abc		       e6 83		      inc	R0
    374  0abe		       d0 02		      bne	getDone2
    375  0ac0		       e6 84		      inc	R0+1
    376  0ac2				   getDone2
    377  0ac2		       a5 83		      lda	R0
    378  0ac4		       85 10		      sta	$0010
    379  0ac6		       a5 84		      lda	R0+1
    380  0ac8		       85 11		      sta	$0011
    381  0aca		       a5 77		      lda	dpl
    382  0acc		       85 12		      sta	$012
    383  0ace
    384  0ace		       60		      rts
    385  0acf							;
    386  0acf							;=====================================================
    387  0acf							; Print the string that immediately follows the JSR to
    388  0acf							; this function.  Stops when a null byte is found,
    389  0acf							; then returns to the instruction immediately
    390  0acf							; following the null.
    391  0acf							;
    392  0acf							; Thanks to Ross Archer for this code.
    393  0acf							; http://www.6502.org/source/io/primm.htm
    394  0acf							;
    395  0acf				  -	      if	KIM
    396  0acf				  -puts       sty	putsy
    397  0acf				  -	      pla		;low part of "return" address
    398  0acf				  -			;(data start address)
    399  0acf				  -	      sta	dpl
    400  0acf				  -	      pla
    401  0acf				  -	      sta	dpl+1	;high part of "return" address
    402  0acf				  -			;(data start address)
    403  0acf				  -			;Note: we're pointing one short
    404  0acf				  -psinb      ldy	#1
    405  0acf				  -	      lda	(dpl),y	;Get next string character
    406  0acf				  -	      inc	dpl	;update the pointer
    407  0acf				  -	      bne	psinc	;if not, we're pntng to next char
    408  0acf				  -	      inc	dpl+1	;account for page crossing
    409  0acf				  -psinc      ora	#0	;Set flags according to contents of
    410  0acf				  -			;   Accumulator
    411  0acf				  -	      beq	psix1	;don't print the final NULL
    412  0acf				  -	      jsr	OUTCH	;write it out
    413  0acf				  -	      jmp	psinb	;back around
    414  0acf				  -psix1      inc	dpl
    415  0acf				  -	      bne	psix2
    416  0acf				  -	      inc	dpl+1	;account for page crossing
    417  0acf				  -psix2      ldy	putsy
    418  0acf				  -	      jmp	(dpl)	;return to byte following NULL
    419  0acf					      endif
    420  0acf							;
    421  0acf							;=====================================================
    422  0acf							; Gets a line of input into LINBUF.
    423  0acf							;
    424  0acf							; On entry:
    425  0acf							;    A contains the prompt character, or 0 if none.
    426  0acf							;
    427  0acf							; On exit:
    428  0acf							;    CURPTR points to LINBUF
    429  0acf							;    LINBUF contains the line with 0 at the end.
    430  0acf							;    Y has offset to first non-space character
    431  0acf							;    CURROFF has the same as Y.
    432  0acf							;
    433  0acf		       a2 f9	   GetLine    ldx	#LINBUF&$ff
    434  0ad1		       86 7e		      stx	CURPTR
    435  0ad3		       a2 10		      ldx	#LINBUF>>8
    436  0ad5		       86 7f		      stx	CURPTR+1
    437  0ad7							;
    438  0ad7							; Prompt
    439  0ad7							;
    440  0ad7		       48		      pha		;save for retries
    441  0ad8		       68	   GetLinePr  pla		;restore
    442  0ad9		       48		      pha		;save again
    443  0ada		       09 00		      ora	#0	;any prompt?
    444  0adc		       f0 08		      beq	getlinenp
    445  0ade		       20 06 02 	      jsr	OUTCH
    446  0ae1		       a9 20		      lda	#$20
    447  0ae3		       20 06 02 	      jsr	OUTCH	;space after prompt
    448  0ae6							;
    449  0ae6		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    450  0ae8		       8e 7d 11    getline1   stx	getlinx
    451  0aeb		       20 09 02 	      jsr	GETCH
    452  0aee					      if	CTMON65
    453  0aee		       48		      pha
    454  0aef		       20 0c f0 	      jsr	cout	;echo echo echo
    455  0af2		       68		      pla
    456  0af3					      endif
    457  0af3		       c9 0d		      cmp	#CR
    458  0af5		       f0 0d		      beq	getlind	;end of line
    459  0af7		       c9 08		      cmp	#BS	;backspace?
    460  0af9		       f0 21		      beq	getlinebs
    461  0afb		       ae 7d 11 	      ldx	getlinx
    462  0afe		       9d f9 10 	      sta	LINBUF,x
    463  0b01		       e8		      inx
    464  0b02		       d0 e4		      bne	getline1
    465  0b04							;
    466  0b04							; CR was hit
    467  0b04							;
    468  0b04		       a9 00	   getlind    lda	#0
    469  0b06		       ae 7d 11 	      ldx	getlinx
    470  0b09		       9d f9 10 	      sta	LINBUF,x
    471  0b0c		       85 80		      sta	CUROFF
    472  0b0e							;
    473  0b0e							; Output a CR/LF
    474  0b0e							;
    475  0b0e		       20 0c 02 	      jsr	CRLF
    476  0b11							;
    477  0b11							; If a blank line, prompt again.
    478  0b11							;
    479  0b11		       a0 00		      ldy	#0
    480  0b13		       20 59 0c 	      jsr	SkipSpaces
    481  0b16		       b1 7e		      lda	(CURPTR),y
    482  0b18		       f0 be		      beq	GetLinePr	;empty line
    483  0b1a		       68		      pla		;get rid of prompt char
    484  0b1b		       60		      rts
    485  0b1c							;
    486  0b1c							; Backspace was hit
    487  0b1c							;
    488  0b1c		       ae 7d 11    getlinebs  ldx	getlinx
    489  0b1f		       f0 c7		      beq	getline1	;at start of line
    490  0b21		       ca		      dex
    491  0b22		       20 12 f0 	      jsr	puts
      0  0b25					      db	27,"[K",0
      1  0b25		       1b 5b 4b 00	      .byte.b	27,"[K",0
    493  0b29		       4c e8 0a 	      jmp	getline1
    494  0b2c							;
    495  0b2c							;=====================================================
    496  0b2c							; Count the length of the line currently in LINBUF
    497  0b2c							; starting at offset Y.  Returns the length in X.  The
    498  0b2c							; starting offset in Y should point past the ASCII
    499  0b2c							; line number.  Also counts the trailing NULL and two
    500  0b2c							; extra bytes for where the line number will be.
    501  0b2c							; Update must now include leading length byte not the null at end ****************
    502  0b2c							;
    503  0b2c				   getLineLength
    504  0b2c		       a2 00		      ldx	#0	;size
    505  0b2e		       b9 f9 10    getLineL2  lda	LINBUF,y
    506  0b31		       f0 04		      beq	getLineL3
    507  0b33		       c8		      iny
    508  0b34		       e8		      inx
    509  0b35		       d0 f7		      bne	getLineL2
    510  0b37		       e8	   getLineL3  inx		;count null at end
    511  0b38		       e8		      inx		;line number LSB
    512  0b39		       e8		      inx		;MSB
    513  0b3a		       e8		      inx		;change: count new leading line length
    514  0b3b		       86 7d		      stx	lineLength
    515  0b3d		       60		      rts
    516  0b3e							;
    517  0b3e							;=====================================================
    518  0b3e							; Count the length of the line pointed to by CURPTR.
    519  0b3e							; This also counts the line number and the terminating
    520  0b3e							; null.  Ie, this string returns 8:
    521  0b3e							;
    522  0b3e							; <lineLow><lineHi>Hello<null>
    523  0b3e							;
    524  0b3e							; Another way of looking at it: add the return value
    525  0b3e							; to the CURPTR and it'll point to the next line's
    526  0b3e							; line number.  Returns the value in Y.
    527  0b3e							; Update to ject get the leading byte length ********************
    528  0b3e							;
    529  0b3e							;getCURPTRLength
    530  0b3e							;		ldy	CURPTR
    531  0b3e							;		ldy	#3	;change: skip line number and leading length byte
    532  0b3e							;getCLineL2	lda	(CURPTR),y
    533  0b3e							;		beq	getCLineL3
    534  0b3e							;		iny
    535  0b3e							;		bne	getCLineL2
    536  0b3e							;getCLineL3	iny		;count null at end
    537  0b3e							;		rts
    538  0b3e							;
    539  0b3e							;=====================================================
    540  0b3e							; This saves ILPC.  This saves to a single save area,
    541  0b3e							; so it can't be called more than once.
    542  0b3e							;
    543  0b3e		       a5 75	   saveIL     lda	ILPC
    544  0b40		       85 79		      sta	tempIL
    545  0b42		       a5 76		      lda	ILPC+1
    546  0b44		       85 7a		      sta	tempIL+1
    547  0b46		       60		      rts
    548  0b47							;
    549  0b47							;=====================================================
    550  0b47							; This restores ILPC.
    551  0b47							;
    552  0b47		       a5 79	   restoreIL  lda	tempIL
    553  0b49		       85 75		      sta	ILPC
    554  0b4b		       a5 7a		      lda	tempIL+1
    555  0b4d		       85 76		      sta	ILPC+1
    556  0b4f		       60		      rts
    557  0b50							;
    558  0b50							;=====================================================
    559  0b50							; This pushes R0 onto the stack.
    560  0b50							;
    561  0b50		       ae e6 10    pushR0     ldx	mathStackPtr
    562  0b53		       a5 83		      lda	R0
    563  0b55		       9d d6 10 	      sta	mathStack,x
    564  0b58		       e8		      inx
    565  0b59		       a5 84		      lda	R0+1
    566  0b5b		       9d d6 10 	      sta	mathStack,x
    567  0b5e		       e8		      inx
    568  0b5f		       8e e6 10 	      stx	mathStackPtr
    569  0b62		       60		      rts
    570  0b63
    571  0b63							;=====================================================
    572  0b63							; This pushes curptr basic current line onto the call stack.
    573  0b63
    574  0b63		       8c 86 11    pushLN     sty	rtemp1
    575  0b66		       ac f8 10 	      ldy	GoSubStackPtr
    576  0b69		       98		      tya
    577  0b6a		       c9 28		      cmp	#GOSUBSTACKSIZE*2
    578  0b6c		       f0 12		      beq	pusherr
    579  0b6e		       a5 7e		      lda	CURPTR
    580  0b70		       91 81		      sta	(GOSUBSTACK),y
    581  0b72		       c8		      iny
    582  0b73		       a5 7f		      lda	CURPTR+1
    583  0b75		       91 81		      sta	(GOSUBSTACK),y
    584  0b77		       c8		      iny
    585  0b78		       8c f8 10 	      sty	GoSubStackPtr
    586  0b7b		       ac 86 11 	      ldy	rtemp1
    587  0b7e		       18		      clc
    588  0b7f		       60		      rts
    589  0b80
    590  0b80		       38	   pusherr    sec
    591  0b81		       60		      rts
    592  0b82							;
    593  0b82							;=====================================================
    594  0b82							; This pushes R1 onto the stack
    595  0b82							;
    596  0b82		       ae e6 10    pushR1     ldx	mathStackPtr
    597  0b85		       a5 85		      lda	R1
    598  0b87		       9d d6 10 	      sta	mathStack,x
    599  0b8a		       e8		      inx
    600  0b8b		       a5 86		      lda	R1+1
    601  0b8d		       9d d6 10 	      sta	mathStack,x
    602  0b90		       e8		      inx
    603  0b91		       8e e6 10 	      stx	mathStackPtr
    604  0b94		       60		      rts
    605  0b95							;
    606  0b95							;=====================================================
    607  0b95							; This pops Top Of Stack and places it in R0.
    608  0b95							;
    609  0b95		       ae e6 10    popR0      ldx	mathStackPtr
    610  0b98		       ca		      dex
    611  0b99		       bd d6 10 	      lda	mathStack,x
    612  0b9c		       85 84		      sta	R0+1
    613  0b9e		       ca		      dex
    614  0b9f		       bd d6 10 	      lda	mathStack,x
    615  0ba2		       85 83		      sta	R0
    616  0ba4		       8e e6 10 	      stx	mathStackPtr
    617  0ba7		       60		      rts
    618  0ba8							;=====================================================
    619  0ba8							; This pops Top Of gosub call Stack and
    620  0ba8							; laces it in CURPTR.
    621  0ba8							;
    622  0ba8		       8c 86 11    popLN      sty	rtemp1
    623  0bab		       ac f8 10 	      ldy	GoSubStackPtr
    624  0bae		       88		      dey
    625  0baf		       98		      tya
    626  0bb0		       c9 ff		      cmp	#$FF
    627  0bb2		       f0 11		      beq	poperr
    628  0bb4		       b1 81		      lda	(GOSUBSTACK),y
    629  0bb6		       85 7f		      sta	CURPTR+1
    630  0bb8		       88		      dey
    631  0bb9		       b1 81		      lda	(GOSUBSTACK),y
    632  0bbb		       85 7e		      sta	CURPTR
    633  0bbd		       8c f8 10 	      sty	GoSubStackPtr
    634  0bc0		       ac 86 11 	      ldy	rtemp1
    635  0bc3		       18		      clc
    636  0bc4		       60		      rts
    637  0bc5		       38	   poperr     sec
      0  0bc6					      rtn
      0  0bc6					      db	25
      1  0bc6		       19		      .byte.b	25
    639  0bc7							;
    640  0bc7							;=====================================================
    641  0bc7							; This pops TOS and places it in R1.
    642  0bc7							;
    643  0bc7		       ae e6 10    popR1      ldx	mathStackPtr
    644  0bca		       ca		      dex
    645  0bcb		       bd d6 10 	      lda	mathStack,x
    646  0bce		       85 86		      sta	R1+1
    647  0bd0		       ca		      dex
    648  0bd1		       bd d6 10 	      lda	mathStack,x
    649  0bd4		       85 85		      sta	R1
    650  0bd6		       8e e6 10 	      stx	mathStackPtr
    651  0bd9		       60		      rts
    652  0bda							;
    653  0bda							;=====================================================
    654  0bda							; This pops TOS and places it in MQ.
    655  0bda							;
    656  0bda		       ae e6 10    popMQ      ldx	mathStackPtr
    657  0bdd		       ca		      dex
    658  0bde		       bd d6 10 	      lda	mathStack,x
    659  0be1		       8d 84 11 	      sta	MQ+1
    660  0be4		       ca		      dex
    661  0be5		       bd d6 10 	      lda	mathStack,x
    662  0be8		       8d 83 11 	      sta	MQ
    663  0beb		       8e e6 10 	      stx	mathStackPtr
    664  0bee		       60		      rts
    665  0bef							;
    666  0bef							;=====================================================
    667  0bef							; This assists with multiplication and division by
    668  0bef							; looking at R0 and R1 and saving a flag as to what
    669  0bef							; sign the result will be.  Math is always done on
    670  0bef							; positive numbers, so this converts negative numbers
    671  0bef							; into positives.  On exit, R0 and R1 are both
    672  0bef							; positive.  If the signs were different then 'signs'
    673  0bef							; will be non-zero.
    674  0bef							;
    675  0bef		       a9 00	   SaveSigns  lda	#0
    676  0bf1		       8d 85 11 	      sta	sign	;assume positive
    677  0bf4		       a5 84		      lda	R0+1	;MSB
    678  0bf6		       10 13		      bpl	SaveSigns1
    679  0bf8		       ee 85 11 	      inc	sign	;it's negative
    680  0bfb		       49 ff		      eor	#$ff	;flip bits
    681  0bfd		       85 84		      sta	R0+1
    682  0bff		       a5 83		      lda	R0
    683  0c01		       49 ff		      eor	#$ff
    684  0c03		       85 83		      sta	R0
    685  0c05		       e6 83		      inc	R0
    686  0c07		       d0 02		      bne	SaveSigns1
    687  0c09		       e6 84		      inc	R0+1
    688  0c0b		       a5 86	   SaveSigns1 lda	R1+1
    689  0c0d		       10 1a		      bpl	SaveSigns2
    690  0c0f		       48		      pha
    691  0c10		       ad 85 11 	      lda	sign
    692  0c13		       49 01		      eor	#1
    693  0c15		       8d 85 11 	      sta	sign
    694  0c18		       68		      pla
    695  0c19		       49 ff		      eor	#$ff	;flip bits
    696  0c1b		       85 86		      sta	R1+1
    697  0c1d		       a5 85		      lda	R1
    698  0c1f		       49 ff		      eor	#$ff
    699  0c21		       85 85		      sta	R1
    700  0c23		       e6 85		      inc	R1
    701  0c25		       d0 02		      bne	SaveSigns2
    702  0c27		       e6 86		      inc	R1+1
    703  0c29		       60	   SaveSigns2 rts
    704  0c2a							;
    705  0c2a							;=====================================================
    706  0c2a							; This looks at the value of 'signs' and will convert
    707  0c2a							; both R0 and R1 to negative if set.
    708  0c2a							;
    709  0c2a				   RestoreSigns
    710  0c2a		       ad 85 11 	      lda	sign
    711  0c2d		       f0 28		      beq	restoresigns2
    712  0c2f							;
    713  0c2f		       a5 83		      lda	R0
    714  0c31		       d0 02		      bne	restoresigns3
    715  0c33		       c6 84		      dec	R0+1
    716  0c35				   restoresigns3
    717  0c35		       c6 83		      dec	R0
    718  0c37		       a5 83		      lda	R0
    719  0c39		       49 ff		      eor	#$ff
    720  0c3b		       85 83		      sta	R0
    721  0c3d		       a5 84		      lda	R0+1
    722  0c3f		       49 ff		      eor	#$ff
    723  0c41		       85 84		      sta	R0+1
    724  0c43							;
    725  0c43		       a5 85		      lda	R1
    726  0c45		       d0 02		      bne	restoresigns4
    727  0c47		       c6 86		      dec	R1+1
    728  0c49				   restoresigns4
    729  0c49		       c6 85		      dec	R1
    730  0c4b		       a5 85		      lda	R1
    731  0c4d		       49 ff		      eor	#$ff
    732  0c4f		       85 85		      sta	R1
    733  0c51		       a5 86		      lda	R1+1
    734  0c53		       49 ff		      eor	#$ff
    735  0c55		       85 86		      sta	R1+1
    736  0c57							;
    737  0c57				   restoresigns2
    738  0c57		       60		      rts
    739  0c58							;
    740  0c58							;=====================================================
    741  0c58							; Skip over spaces.  Returns Y with the offset to
    742  0c58							; either the last character in the line, or the first
    743  0c58							; non-space character.
    744  0c58							;
    745  0c58		       c8	   skipsp2    iny
    746  0c59		       b1 7e	   SkipSpaces lda	(CURPTR),y
    747  0c5b		       f0 04		      beq	Skip3	;end of line
    748  0c5d		       c9 20		      cmp	#SPACE
    749  0c5f		       f0 f7		      beq	skipsp2
    750  0c61		       60	   Skip3      rts
    751  0c62							;
    752  0c62							;=====================================================
    753  0c62							; This is some debug logic which displays the current
    754  0c62							; value of the ILPC and the line buffer.
    755  0c62							;
    756  0c62		       20 12 f0    dbgLine    jsr	puts
      0  0c65					      db	"ILPC: ",0
      1  0c65		       49 4c 50 43*	      .byte.b	"ILPC: ",0
    758  0c6c		       a5 76		      lda	ILPC+1
    759  0c6e		       20 0f 02 	      jsr	OUTHEX
    760  0c71		       a5 75		      lda	ILPC
    761  0c73		       20 0f 02 	      jsr	OUTHEX
    762  0c76		       a9 20		      lda	#SPACE
    763  0c78		       20 06 02 	      jsr	OUTCH
    764  0c7b		       a0 00		      ldy	#0
    765  0c7d		       b1 75		      lda	(ILPC),y
    766  0c7f		       20 0f 02 	      jsr	OUTHEX
    767  0c82							;
    768  0c82							; Display the CURPTR value and offset
    769  0c82							;
    770  0c82		       20 12 f0 	      jsr	puts
      0  0c85					      db	", CURPTR: ",0
      1  0c85		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    772  0c90		       a5 7f		      lda	CURPTR+1
    773  0c92		       20 0f 02 	      jsr	OUTHEX
    774  0c95		       a5 7e		      lda	CURPTR
    775  0c97		       20 0f 02 	      jsr	OUTHEX
    776  0c9a		       a9 2b		      lda	#'+
    777  0c9c		       20 06 02 	      jsr	OUTCH
    778  0c9f		       a5 80		      lda	CUROFF
    779  0ca1		       20 0f 02 	      jsr	OUTHEX
    780  0ca4							;
    781  0ca4		       4c 0c 02 	      jmp	CRLF
    782  0ca7							;
    783  0ca7							;=====================================================
    784  0ca7							; This function might go away eventually, but was
    785  0ca7							; added to provide data for other pieces of code.
    786  0ca7							; It has some ties to the operating environment that
    787  0ca7							; will need to be customized for the target system.
    788  0ca7							;
    789  0ca7				   GetSizes
    790  0ca7							;
    791  0ca7							; Here is machine specific code to get the highest
    792  0ca7							; memory location that can be used by BASIC.
    793  0ca7							;
    794  0ca7					      if	ProgramStart < $2000
    795  0ca7		       a9 ff		      lda	#$ff
    796  0ca9		       8d 8e 11 	      sta	HighMem	;$13ff for KIM-1
    797  0cac		       a9 de		      lda	#$DE	;#$13
    798  0cae		       8d 8f 11 	      sta	HighMem+1
    799  0cb1				  -	      else
    800  0cb1				  -	      lda	#$ff
    801  0cb1				  -	      sta	HighMem	;$CFFF otherwise
    802  0cb1				  -	      lda	#$cf
    803  0cb1				  -	      sta	HighMem+1
    804  0cb1					      endif
    805  0cb1							;
    806  0cb1							; This computes the available memory remaining.
    807  0cb1							;
    808  0cb1		       38		      sec
    809  0cb2		       ad 8e 11 	      lda	HighMem
    810  0cb5		       ed 8c 11 	      sbc	PROGRAMEND
    811  0cb8		       8d 92 11 	      sta	FreeMem
    812  0cbb		       85 83		      sta	R0
    813  0cbd		       ad 8f 11 	      lda	HighMem+1
    814  0cc0		       ed 8d 11 	      sbc	PROGRAMEND+1
    815  0cc3		       8d 93 11 	      sta	FreeMem+1
    816  0cc6		       85 84		      sta	R0+1
    817  0cc8							;
    818  0cc8							; This computes the size of the current user program.
    819  0cc8							;
    820  0cc8		       38		      sec
    821  0cc9		       ad 8c 11 	      lda	PROGRAMEND
    822  0ccc		       e9 94		      sbc	#ProgramStart&$ff
    823  0cce		       8d 90 11 	      sta	UsedMem
    824  0cd1		       ad 8d 11 	      lda	PROGRAMEND+1
    825  0cd4		       e9 11		      sbc	#ProgramStart>>8
    826  0cd6		       8d 91 11 	      sta	UsedMem+1
    827  0cd9							;
    828  0cd9		       60		      rts
    829  0cda							;
    830  0cda							;=====================================================
    831  0cda							; Set output vector to the console output function
    832  0cda							;
    833  0cda				   SetOutConsole
    834  0cda		       a9 06		      lda	#OUTCH&$ff
    835  0cdc		       8d 89 11 	      sta	BOutVec
    836  0cdf		       a9 02		      lda	#OUTCH/256
    837  0ce1		       8d 8a 11 	      sta	BOutVec+1
    838  0ce4		       60		      rts
    839  0ce5							;
    840  0ce5							;=====================================================
    841  0ce5							; Jump to the output function in BOutVec
    842  0ce5							;
    843  0ce5		       6c 89 11    VOUTCH     jmp	(BOutVec)
    844  0ce8
    845  0ce8							;====================================================
    846  0ce8		       11 86	   PrtTerm    equ	rtemp1
    847  0ce8
    848  0ce8							; Print Y has the offset to use
    849  0ce8		       a5 7e	   PrtQuoted  lda	CURPTR
    850  0cea		       85 88		      sta	PrtFrom
    851  0cec		       a5 7f		      lda	CURPTR+1
    852  0cee		       85 89		      sta	PrtFrom+1
    853  0cf0		       a9 22		      lda	#'"
    854  0cf2		       8d 86 11 	      sta	PrtTerm
    855  0cf5		       4c 01 0d 	      jmp	PrtLoop
    856  0cf8							; Print a string pointed to by x= h, y=l terminated by a
    857  0cf8							; Return y as the length
    858  0cf8		       86 89	   PrtStr     stx	PrtFrom+1
    859  0cfa		       84 88		      sty	PrtFrom
    860  0cfc		       8d 86 11 	      sta	PrtTerm
    861  0cff		       a0 00		      ldy	#0
    862  0d01
    863  0d01		       b1 88	   PrtLoop    lda	(PrtFrom),y
    864  0d03		       cd 86 11 	      cmp	PrtTerm
    865  0d06		       f0 0b		      beq	PrtEnd
    866  0d08		       c9 00		      cmp	#0	; always end if 0 is found
    867  0d0a		       f0 07		      beq	PrtEnd
    868  0d0c		       20 06 02 	      jsr	OUTCH
    869  0d0f		       c8		      iny
    870  0d10		       4c 01 0d 	      jmp	PrtLoop
    871  0d13		       c8	   PrtEnd     iny		;return byte after the copy
    872  0d14		       60		      rts
    873  0d15
    874  0d15							;====================================================
    875  0d15							;Clear the terminal assume it is ansii or vt100
    876  0d15							;
    877  0d15				   iCLEARSCREEN
    878  0d15		       20 12 f0 	      jsr	puts
      0  0d18					      db	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,0
      1  0d18		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,0
    880  0d23		       4c c5 02 	      jmp	NextIL
------- FILE mytb.asm
   1564  0d26					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 4
      0  0d26					      include	"storage.asm"
      1  0d26							;
      2  0d26							;=====================================================
      3  0d26							;=====================================================
      4  0d26							;=====================================================
      5  0d26							; This file contains the functions for saving and
      6  0d26							; restoring programs from some sort of mass storage
      7  0d26							; device.  This particular version is for using the
      8  0d26							; Corsham Tech SD Card System.
      9  0d26							;=====================================================
     10  0d26							;=====================================================
     11  0d26							;=====================================================
     12  0d26
     13 Udf8e					      seg.u	Data
     14 Udf8e		       00	   diskBufLength ds	1
     15 Udf8f		       00	   diskBufOffset ds	1
     16 Udf90		       00 00 00 00*DiskFileName ds	14
     17 Udf9e
     18  0d26					      SEG	Code
     19  0d26
     20  0d26							;
     21  0d26							;=====================================================
     22  0d26							; Open a file for reading as a program.  The next
     23  0d26							; thing on the line should be the filename.
     24  0d26							;
     25  0d26				   iOPENREAD
     26  0d26					      if	XKIM || CTMON65
     27  0d26		       a4 80		      ldy	CUROFF
     28  0d28		       b1 7e		      lda	(CURPTR),y
     29  0d2a		       d0 07		      bne	iOPENfn	;might be filename
     30  0d2c							;
     31  0d2c							; No filename supplied.
     32  0d2c							;
     33  0d2c		       a9 00	   iOPENnofn  lda	#0
     34  0d2e		       a2 09		      ldx	#ERR_NO_FILENAME
     35  0d30		       4c ae 04 	      jmp	iErr2
     36  0d33							;
     37  0d33							; Add the offset into the buffer start
     38  0d33							;
     39  0d33		       18	   iOPENfn    clc
     40  0d34		       98		      tya
     41  0d35		       65 7e		      adc	CURPTR
     42  0d37		       a8		      tay		;LSB
     43  0d38		       a5 7f		      lda	CURPTR+1
     44  0d3a		       69 00		      adc	#0
     45  0d3c		       aa		      tax
     46  0d3d		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     47  0d40		       90 07		      bcc	Ropenok	;branch if opened ok
     48  0d42							;
     49  0d42							; Open failed
     50  0d42							;
     51  0d42		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     52  0d44		       a9 00	   Rdfail2    lda	#0
     53  0d46		       4c ae 04 	      jmp	iErr2
     54  0d49							;
     55  0d49							; Clear counts and offsets so the next read will
     56  0d49							; cause the file to be read.
     57  0d49							;
     58  0d49		       a9 00	   Ropenok    lda	#0
     59  0d4b		       8d 8f df 	      sta	diskBufOffset
     60  0d4e		       8d 8e df 	      sta	diskBufLength
     61  0d51		       4c c5 02 	      jmp	NextIL
     62  0d54					      endif
     63  0d54
     64  0d54							;
     65  0d54							;==============================jlit 08/02/2022========
     66  0d54							;Remove a file from the disk
     67  0d54				   iRMFILE
     68  0d54					      if	XKIM || CTMON65
     69  0d54		       a4 80		      ldy	CUROFF
     70  0d56		       b1 7e		      lda	(CURPTR),y
     71  0d58		       f0 19		      beq	iRMnofn
     72  0d5a							;
     73  0d5a		       18		      clc
     74  0d5b		       98		      tya
     75  0d5c		       65 7e		      adc	CURPTR
     76  0d5e		       a8		      tay		;LSB
     77  0d5f		       a5 7f		      lda	CURPTR+1
     78  0d61		       69 00		      adc	#0
     79  0d63		       aa		      tax
     80  0d64		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     81  0d67		       90 07		      bcc	wrmOk	;branch if removed ok
     82  0d69		       a9 00		      lda	#0
     83  0d6b		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     84  0d6d		       4c ae 04 	      jmp	iErr2
     85  0d70		       4c c5 02    wrmOk      jmp	NextIL
     86  0d73
     87  0d73							; No filename supplied.
     88  0d73							;
     89  0d73		       a9 00	   iRMnofn    lda	#0
     90  0d75		       a2 09		      ldx	#ERR_NO_FILENAME
     91  0d77		       4c ae 04 	      jmp	iErr2
     92  0d7a					      endif
     93  0d7a							;
     94  0d7a							;=====================================================
     95  0d7a				   iOPENWRITE
     96  0d7a					      if	XKIM || CTMON65
     97  0d7a		       a4 80		      ldy	CUROFF
     98  0d7c		       b1 7e		      lda	(CURPTR),y
     99  0d7e		       f0 f3		      beq	iRMnofn
    100  0d80							;
    101  0d80		       18		      clc
    102  0d81		       98		      tya
    103  0d82		       65 7e		      adc	CURPTR
    104  0d84		       a8		      tay		;LSB
    105  0d85		       a5 7f		      lda	CURPTR+1
    106  0d87		       69 00		      adc	#0
    107  0d89		       aa		      tax
    108  0d8a		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    109  0d8d		       90 07		      bcc	Wopenok	;branch if opened ok
    110  0d8f							;
    111  0d8f							; Open failed
    112  0d8f							;
    113  0d8f		       a9 00	   Wdfail     lda	#0
    114  0d91		       a2 08		      ldx	#ERR_WRITE_FAIL
    115  0d93		       4c ae 04 	      jmp	iErr2
    116  0d96							;
    117  0d96		       4c c5 02    Wopenok    jmp	NextIL
    118  0d99					      endif
    119  0d99							;
    120  0d99							;=====================================================
    121  0d99							; Gets a line of input from the disk file and puts it
    122  0d99							; into LINBUF.
    123  0d99							;
    124  0d99							; On exit:
    125  0d99							;    CURPTR points to LINBUF
    126  0d99							;    LINBUF contains the line with 0 at the end.
    127  0d99							;    Y has offset to first non-space character
    128  0d99							;    CURROFF has the same as Y.
    129  0d99							;
    130  0d99				   iDGETLINE
    131  0d99					      if	XKIM || CTMON65
    132  0d99		       a2 f9		      ldx	#LINBUF&$ff
    133  0d9b		       86 7e		      stx	CURPTR
    134  0d9d		       a2 10		      ldx	#LINBUF>>8
    135  0d9f		       86 7f		      stx	CURPTR+1
    136  0da1							;
    137  0da1		       a2 00		      ldx	#0	;offset
    138  0da3		       8e 7d 11    iDgetLoop  stx	getlinx
    139  0da6		       20 04 0e 	      jsr	getNextFileByte
    140  0da9		       b0 16		      bcs	iGetEOF
    141  0dab		       c9 0d		      cmp	#CR
    142  0dad		       f0 0d		      beq	iGetEOL
    143  0daf		       c9 0a		      cmp	#LF
    144  0db1		       f0 09		      beq	iGetEOL
    145  0db3		       ae 7d 11 	      ldx	getlinx
    146  0db6		       9d f9 10 	      sta	LINBUF,x
    147  0db9		       e8		      inx
    148  0dba		       d0 e7		      bne	iDgetLoop
    149  0dbc							;
    150  0dbc							; Handle end of line.	If the line has nothing, loop
    151  0dbc							; back and get another line.
    152  0dbc							;
    153  0dbc		       ae 7d 11    iGetEOL    ldx	getlinx	;blank line?
    154  0dbf		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    155  0dc1							;
    156  0dc1							; This can fall through when there is a line, or
    157  0dc1							; called directly when EOF is encountered.
    158  0dc1							;
    159  0dc1		       ae 7d 11    iGetEOF    ldx	getlinx
    160  0dc4		       a9 00		      lda	#0
    161  0dc6		       9d f9 10 	      sta	LINBUF,x
    162  0dc9		       85 80		      sta	CUROFF
    163  0dcb		       a0 00		      ldy	#0
    164  0dcd		       20 59 0c 	      jsr	SkipSpaces
    165  0dd0		       4c c5 02 	      jmp	NextIL
    166  0dd3					      endif
    167  0dd3
    168  0dd3							;
    169  0dd3							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    170  0dd3							; DISK
    171  0dd3							;
    172  0dd3				   iDDIR
    173  0dd3					      if	XKIM || CTMON65
    174  0dd3		       20 30 f0 	      jsr	DiskDir
    175  0dd6							;
    176  0dd6							; Get/Display each entry
    177  0dd6							;
    178  0dd6		       a2 df	   DiskDirLoop ldx	#DiskFileName/256	;pointer to buffer
    179  0dd8		       a0 90		      ldy	#DiskFileName&$ff
    180  0dda		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    181  0ddd		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    182  0ddf		       20 12 f0 	      jsr	puts
      0  0de2					      db	"   ",0
      1  0de2		       20 20 20 00	      .byte.b	"   ",0
    184  0de6							; Print the line to the console
    185  0de6		       a2 df		      ldx	#DiskFileName/256	;pointer to buffer
    186  0de8		       a0 90		      ldy	#DiskFileName&$ff
    187  0dea		       a5 00		      lda	0
    188  0dec		       20 f8 0c 	      jsr	PrtStr	;else print name
    189  0def		       20 18 f0 	      jsr	crlf
    190  0df2
    191  0df2		       4c d6 0d 	      jmp	DiskDirLoop	;do next entry
    192  0df5		       4c c5 02    DiskDirEnd jmp	NextIL
    193  0df8					      endif
    194  0df8							;
    195  0df8							;=====================================================
    196  0df8							; Does a LIST to a Disk file.
    197  0df8							;
    198  0df8				   iDLIST
    199  0df8					      if	XKIM || CTMON65
    200  0df8		       20 33 0e 	      jsr	SetOutDisk
    201  0dfb		       4c e4 05 	      jmp	iLST2
    202  0dfe					      endif
    203  0dfe							;
    204  0dfe							;=====================================================
    205  0dfe							; Closes any pending disk file.  Okay to call if there
    206  0dfe							; is no open file.
    207  0dfe							;
    208  0dfe				   iDCLOSE
    209  0dfe					      if	XKIM || CTMON65
    210  0dfe		       20 42 f0 	      jsr	DiskClose
    211  0e01		       4c c5 02 	      jmp	NextIL
    212  0e04					      endif
    213  0e04							;
    214  0e04							;=====================================================
    215  0e04							; This gets the next byte from an open disk file.  If
    216  0e04							; there are no more bytes left, this returns C set.
    217  0e04							; Else, C is clear and A contains the character.
    218  0e04							;
    219  0e04				   getNextFileByte
    220  0e04					      if	XKIM || CTMON65
    221  0e04		       ae 8f df 	      ldx	diskBufOffset
    222  0e07		       ec 8e df 	      cpx	diskBufLength
    223  0e0a		       d0 14		      bne	hasdata	;branch if still data
    224  0e0c							;
    225  0e0c							; There is no data left in the buffer, so read a
    226  0e0c							; block from the SD system.
    227  0e0c							;
    228  0e0c		       a9 84		      lda	#BUFFER_SIZE
    229  0e0e		       a2 df		      ldx	#buffer>>8
    230  0e10		       a0 0a		      ldy	#buffer&$ff
    231  0e12		       20 3c f0 	      jsr	DiskRead
    232  0e15		       b0 12		      bcs	getNextEof
    233  0e17							;
    234  0e17							; A contains the number of bytes actually read.
    235  0e17							;
    236  0e17		       8d 8e df 	      sta	diskBufLength	;save length
    237  0e1a		       c9 00		      cmp	#0	;shouldn't happen
    238  0e1c		       f0 0b		      beq	getNextEof
    239  0e1e							;
    240  0e1e		       a2 00		      ldx	#0
    241  0e20		       bd 0a df    hasdata    lda	buffer,x
    242  0e23		       e8		      inx
    243  0e24		       8e 8f df 	      stx	diskBufOffset
    244  0e27		       18		      clc
    245  0e28		       60		      rts
    246  0e29							;
    247  0e29		       a9 00	   getNextEof lda	#0
    248  0e2b		       8d 8f df 	      sta	diskBufOffset
    249  0e2e		       8d 8e df 	      sta	diskBufLength
    250  0e31		       38		      sec
    251  0e32		       60		      rts
    252  0e33							;
    253  0e33							;=====================================================
    254  0e33							; Set output vector to the disk output function
    255  0e33							;
    256  0e33		       a9 3e	   SetOutDisk lda	#DOUT&$ff
    257  0e35		       8d 89 11 	      sta	BOutVec
    258  0e38		       a9 0e		      lda	#DOUT/256
    259  0e3a		       8d 8a 11 	      sta	BOutVec+1
    260  0e3d		       60		      rts
    261  0e3e							;
    262  0e3e							;=====================================================
    263  0e3e
    264  0e3e		       8d 0a df    DOUT       sta	buffer
    265  0e41		       a9 01		      lda	#1
    266  0e43		       a0 0a		      ldy	#buffer&$ff
    267  0e45		       a2 df		      ldx	#buffer/256
    268  0e47		       20 3f f0 	      jsr	DiskWrite
    269  0e4a							;
    270  0e4a							; need error checking here
    271  0e4a							;
    272  0e4a		       60		      rts
    273  0e4b					      endif
    274  0e4b
    275  0e4b
------- FILE mytb.asm
   1566  0e4b					      endif
------- FILE IL.inc LEVEL 2 PASS 4
      0  0e4b					      include	"IL.inc"
      1  0e4b
      2  0e4b							;=====================================================
      3  0e4b							; IL.inc
      4  0e4b							; These are macros for IL instructions
      5  0e4b							;
      6  0e4b					      mac	dw
      7  0e4b					      .word	{0}
      8  0e4b					      endm
      9  0e4b					      mac	db
     10  0e4b					      .byte	{0}
     11  0e4b					      endm
     12  0e4b					      macro	xinit
     13  0e4b					      db	0
     14  0e4b					      endm		;reset the il to start clear all
     15  0e4b							;
     16  0e4b					      macro	done
     17  0e4b					      db	1
     18  0e4b					      endm		;print an error if not end of line
     19  0e4b							;
     20  0e4b					      macro	prs
     21  0e4b					      db	2
     22  0e4b					      endm		;print a quoted string
     23  0e4b							;
     24  0e4b					      macro	prn
     25  0e4b					      db	3
     26  0e4b					      endm		;print a number
     27  0e4b							;
     28  0e4b					      macro	spc
     29  0e4b					      db	4
     30  0e4b					      endm		;print space til new tabstop
     31  0e4b							;
     32  0e4b					      macro	nline
     33  0e4b					      db	5
     34  0e4b					      endm		;print a new line crlf
     35  0e4b							;
     36  0e4b							; My NXT is a bit different in that it takes one
     37  0e4b							; parameter, which is an address.  If the BASIC
     38  0e4b							; program is currently running then move to the
     39  0e4b							; next line and continue execution.  However, if
     40  0e4b							; in direct mode, jump to the specified IL label.
     41  0e4b							;
     42  0e4b					      macro	nxt
     43  0e4b					      db	6
     44  0e4b					      dw	{1}	; addr
     45  0e4b					      endm		; addr
     46  0e4b							;
     47  0e4b					      macro	xfer
     48  0e4b					      db	7
     49  0e4b					      endm
     50  0e4b							;
     51  0e4b					      macro	sav
     52  0e4b					      db	8
     53  0e4b					      endm
     54  0e4b							;
     55  0e4b					      macro	rstr
     56  0e4b					      db	9
     57  0e4b					      endm
     58  0e4b							;
     59  0e4b					      macro	cmpr
     60  0e4b					      db	10
     61  0e4b					      endm
     62  0e4b							;
     63  0e4b					      macro	innum
     64  0e4b					      db	11
     65  0e4b					      endm
     66  0e4b							;
     67  0e4b					      macro	fin
     68  0e4b					      db	12
     69  0e4b					      endm
     70  0e4b							;
     71  0e4b							; ERR is followed by an error number.	The error
     72  0e4b							; code is printed along with the line number.
     73  0e4b							; Control is passed to the statement set with
     74  0e4b							; the ERRGOTO statement.
     75  0e4b							;
     76  0e4b					      macro	errmsg
     77  0e4b					      db	13
     78  0e4b					      dw	{1}	;ecode
     79  0e4b					      endm		;ecode
     80  0e4b							;
     81  0e4b					      macro	add
     82  0e4b					      db	14
     83  0e4b					      endm
     84  0e4b							;
     85  0e4b					      macro	sub
     86  0e4b					      db	15
     87  0e4b					      endm
     88  0e4b							;
     89  0e4b					      macro	neg
     90  0e4b					      db	16
     91  0e4b					      endm
     92  0e4b							;
     93  0e4b					      macro	mul
     94  0e4b					      db	17
     95  0e4b					      endm
     96  0e4b							;
     97  0e4b					      macro	div
     98  0e4b					      db	18
     99  0e4b					      endm
    100  0e4b							;
    101  0e4b					      macro	store
    102  0e4b					      db	19
    103  0e4b					      endm
    104  0e4b							;
    105  0e4b					      macro	ind
    106  0e4b					      db	20
    107  0e4b					      endm
    108  0e4b							;
    109  0e4b					      macro	lst
    110  0e4b					      db	21
    111  0e4b					      endm
    112  0e4b							;
    113  0e4b					      macro	init
    114  0e4b					      db	22
    115  0e4b					      endm
    116  0e4b							;
    117  0e4b					      macro	getline
    118  0e4b					      db	23
    119  0e4b					      endm
    120  0e4b							;
    121  0e4b					      macro	insert
    122  0e4b					      db	24
    123  0e4b					      endm
    124  0e4b							;
    125  0e4b					      macro	rtn
    126  0e4b					      db	25
    127  0e4b					      endm
    128  0e4b							;
    129  0e4b					      macro	exit
    130  0e4b					      db	26
    131  0e4b					      endm
    132  0e4b							;
    133  0e4b					      macro	lit
    134  0e4b					      db	27
    135  0e4b					      dw	{1}	;value
    136  0e4b					      endm		; value LIT
    137  0e4b							;
    138  0e4b					      macro	call
    139  0e4b					      db	28
    140  0e4b					      dw	{1}	;addr
    141  0e4b					      endm		;addr
    142  0e4b							;
    143  0e4b							; IJMP will set the IL PC to the specified value.
    144  0e4b							;
    145  0e4b					      macro	ijmp
    146  0e4b					      db	29
    147  0e4b					      dw	{1}	;addr
    148  0e4b					      endm		;addr
    149  0e4b							;
    150  0e4b					      macro	vinit
    151  0e4b					      db	30
    152  0e4b					      endm
    153  0e4b							;
    154  0e4b							; ERRGOTO sets the point in the code where the IL
    155  0e4b							; interpreter will go after any error.
    156  0e4b							;
    157  0e4b					      macro	errgoto
    158  0e4b					      db	31
    159  0e4b					      dw	{1}	;addr
    160  0e4b					      endm		;addr
    161  0e4b							;
    162  0e4b					      macro	tst
    163  0e4b					      db	32
    164  0e4b					      db	({1}-*)-1	;(addr-*)-1
    165  0e4b					      db	{2},0	;string,0
    166  0e4b					      endm		;addr,string
    167  0e4b							;
    168  0e4b					      macro	tstv
    169  0e4b					      db	33
    170  0e4b					      db	({1}-*)-1	;(addr-*)-1
    171  0e4b					      endm		;addr
    172  0e4b							;
    173  0e4b					      macro	tstl
    174  0e4b					      db	34
    175  0e4b					      db	({1}-*)-1	;(addr-*)-1
    176  0e4b					      endm		;addr
    177  0e4b							;
    178  0e4b					      macro	tstn
    179  0e4b					      db	35
    180  0e4b					      db	({1}-*)-1	;(addr-*)-1
    181  0e4b					      endm		;addr
    182  0e4b							;
    183  0e4b							; FREE returns the amount of free RAM on top of
    184  0e4b							; the stack.  This is the amount of room the user
    185  0e4b							; program has available.
    186  0e4b							;
    187  0e4b					      macro	free
    188  0e4b					      db	36
    189  0e4b					      endm
    190  0e4b							;
    191  0e4b							; RANDOM takes the top item off the stack and
    192  0e4b							; replaces it with a random number that is
    193  0e4b							; MOD the initial value.  Ie, if the TOS is
    194  0e4b							; 42 then RANDOM returns a value from 0 to 41.
    195  0e4b							;
    196  0e4b					      macro	random
    197  0e4b					      db	37
    198  0e4b					      endm
    199  0e4b							;
    200  0e4b							; ABS will replace the top of stack with the
    201  0e4b							; absolute value.
    202  0e4b							;
    203  0e4b					      macro	abs
    204  0e4b					      db	38
    205  0e4b					      endm
    206  0e4b							;
    207  0e4b							; OPENREAD opens a file for reading, as in getting
    208  0e4b							; statements from it.
    209  0e4b							;
    210  0e4b					      macro	openread
    211  0e4b					      db	39
    212  0e4b					      endm
    213  0e4b							;
    214  0e4b							; OPENWRITE opens a file for writing, as in saving
    215  0e4b							; the current program to it.
    216  0e4b							;
    217  0e4b					      macro	openwrite
    218  0e4b					      db	40
    219  0e4b					      endm
    220  0e4b							;
    221  0e4b							; DCLOSE closes any open disk file.
    222  0e4b							;
    223  0e4b					      macro	dclose
    224  0e4b					      db	41
    225  0e4b					      endm
    226  0e4b							;
    227  0e4b							; DGETLINE gets one line from the disk file and puts it
    228  0e4b							; into LINBUFF.
    229  0e4b							;
    230  0e4b					      macro	dgetline
    231  0e4b					      db	42
    232  0e4b					      endm
    233  0e4b							;
    234  0e4b							; DLIST saves the program to an open disk file.
    235  0e4b							;
    236  0e4b					      macro	dlist
    237  0e4b					      db	43
    238  0e4b					      endm
    239  0e4b							; DDIR list the current directory
    240  0e4b							;
    241  0e4b					      macro	ddir
    242  0e4b					      db	44
    243  0e4b					      endm
    244  0e4b
    245  0e4b							; RMFILE remove a fle from disk
    246  0e4b					      macro	rmfile
    247  0e4b					      db	45
    248  0e4b					      endm
    249  0e4b
    250  0e4b							; CLEARSCREEN clear the screen
    251  0e4b					      macro	clearscreen
    252  0e4b					      db	46
    253  0e4b					      endm
    254  0e4b							; POKEMEM Poke value into memory
    255  0e4b					      macro	pokemem
    256  0e4b					      db	47
    257  0e4b					      endm
    258  0e4b							; PEEKMEM peek at value in memory
    259  0e4b					      macro	peekmem
    260  0e4b					      db	48
    261  0e4b					      endm
    262  0e4b							; TSTLET Test if the statement is a let without the keyword let
    263  0e4b					      macro	tstlet
    264  0e4b					      db	49
    265  0e4b					      db	({1}-*)-1	;(addr-*)-1
    266  0e4b					      endm		;addr
    267  0e4b							; TSTDONE if we reach the end of a statement
    268  0e4b					      macro	tstdone
    269  0e4b					      db	50
    270  0e4b					      db	({1}-*)-1	;(addr-*)-1
    271  0e4b					      endm		;addr
    272  0e4b							; GETCHAR	get a character from the input line leave it in RO
    273  0e4b					      macro	getchar
    274  0e4b					      db	51
    275  0e4b					      endm
    276  0e4b							; PUTCHAR	Put a character to the terminal
    277  0e4b					      macro	putchar
    278  0e4b					      db	52
    279  0e4b					      endm
    280  0e4b							; Call		Call a machine function return a to stack
    281  0e4b					      macro	callfunc
    282  0e4b					      db	53
    283  0e4b					      endm
    284  0e4b							; Call		Call a machine function return a to stack
    285  0e4b					      macro	callfunc2
    286  0e4b					      db	54
    287  0e4b					      endm
    288  0e4b							; TSTSTR	 Tests for the open quote in a string
    289  0e4b					      macro	tststr
    290  0e4b					      db	55
    291  0e4b					      db	({1}-*)-1	;(addr-*)-1
    292  0e4b					      endm
    293  0e4b
------- FILE mytb.asm
   1568  0e4b							;
   1569  0e4b				  -	      if	FIXED
   1570  0e4b				  -	      org	$1000
   1571  0e4b					      endif
------- FILE basic.il LEVEL 2 PASS 4
      0  0e4b					      include	"basic.il"
      1  0e4b							;LET
      2  0e4b							;=====================================================
      3  0e4b							;=====================================================
      4  0e4b							;=====================================================
      5  0e4b							; This is the IL of the BASIC (or whatever) language.
      6  0e4b							; Because of the way macros are implemented by as65,
      7  0e4b							; labels can't be on the same line as a macro
      8  0e4b							; invocation, so that's why labels are on separate
      9  0e4b							; lines.
     10  0e4b							;
     11  0e4b		       0e 4b	   IL	      equ	*
     12  0e4b
     13  0e4b							;THE IL CONTROL SECTION
     14  0e4b
     15  0e4b				   START
      0  0e4b					      INIT		;INITIALIZE
      0  0e4b					      db	22
      1  0e4b		       16		      .byte.b	22
      0  0e4c					      NLINE		;WRITE CRLF
      0  0e4c					      db	5
      1  0e4c		       05		      .byte.b	5
      0  0e4d					      ERRGOTO	CO	;where to go after an error
      0  0e4d					      db	31
      1  0e4d		       1f		      .byte.b	31
      0  0e4e					      dw	CO
      1  0e4e		       51 0e		      .word.w	CO
      0  0e50					      VINIT		;clear all variables
      0  0e50					      db	30
      1  0e50		       1e		      .byte.b	30
     20  0e51							;
     21  0e51							; This is where we jump to get a line of commands or
     22  0e51							; a program from the user.
     23  0e51							;
     24  0e51				   CO
      0  0e51					      GETLINE		;WRITE PROMPT AND GET LINE
      0  0e51					      db	23
      1  0e51		       17		      .byte.b	23
      0  0e52					      TSTL	XEC	;TEST FOR LINE NUMBER
      0  0e52					      db	34
      1  0e52		       22		      .byte.b	34
      0  0e53					      db	(XEC-*)-1
      1  0e53		       04		      .byte.b	(XEC-*)-1
      0  0e54					      INSERT		;INSERT IT (MAY BE DELETE)
      0  0e54					      db	24
      1  0e54		       18		      .byte.b	24
      0  0e55					      IJMP	CO
      0  0e55					      db	29
      1  0e55		       1d		      .byte.b	29
      0  0e56					      dw	CO
      1  0e56		       51 0e		      .word.w	CO
     29  0e58				   XEC
      0  0e58					      XINIT		;INITIALIZE
      0  0e58					      db	0
      1  0e58		       00		      .byte.b	0
     31  0e59
     32  0e59							;STATEMENT EXECUTOR
     33  0e59
     34  0e59				   STMT
      0  0e59					      TSTLET	LET	;Test if second field is =
      0  0e59					      db	49
      1  0e59		       31		      .byte.b	49
      0  0e5a					      db	(LET-*)-1
      1  0e5a		       03		      .byte.b	(LET-*)-1
      0  0e5b					      IJMP	DOLET	;allow the default to be let
      0  0e5b					      db	29
      1  0e5b		       1d		      .byte.b	29
      0  0e5c					      dw	DOLET
      1  0e5c		       64 0e		      .word.w	DOLET
     37  0e5e				   LET
      0  0e5e					      TST	S1,"LET"	;IS STATEMENT A LET
      0  0e5e					      db	32
      1  0e5e		       20		      .byte.b	32
      0  0e5f					      db	(S1-*)-1
      1  0e5f		       15		      .byte.b	(S1-*)-1
      0  0e60					      db	"LET",0
      1  0e60		       4c 45 54 00	      .byte.b	"LET",0
      0  0e64				   DOLET      TSTV	ERRVEC	;YES, PLACE VAR ADDRESS ON AESTK
      0  0e64					      db	33
      1  0e64		       21		      .byte.b	33
      0  0e65					      db	(ERRVEC-*)-1
      1  0e65		       80		      .byte.b	(ERRVEC-*)-1
      0  0e66					      TST	ERRVEC,"="	;(This line originally omitted)
      0  0e66					      db	32
      1  0e66		       20		      .byte.b	32
      0  0e67					      db	(ERRVEC-*)-1
      1  0e67		       7e		      .byte.b	(ERRVEC-*)-1
      0  0e68					      db	"=",0
      1  0e68		       3d 00		      .byte.b	"=",0
      0  0e6a					      CALL	EXPR	;PLACE EXPR VALUE ON AESTK
      0  0e6a					      db	28
      1  0e6a		       1c		      .byte.b	28
      0  0e6b					      dw	EXPR
      1  0e6b		       d4 0f		      .word.w	EXPR
      0  0e6d					      DONE		;REPORT ERROR IF NOT NEXT
      0  0e6d					      db	1
      1  0e6d		       01		      .byte.b	1
      0  0e6e					      STORE		;STORE RESULT
      0  0e6e					      db	19
      1  0e6e		       13		      .byte.b	19
      0  0e6f					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0e6f					      db	6
      1  0e6f		       06		      .byte.b	6
      0  0e70					      dw	CO
      1  0e70		       51 0e		      .word.w	CO
      0  0e72					      IJMP	STMT
      0  0e72					      db	29
      1  0e72		       1d		      .byte.b	29
      0  0e73					      dw	STMT
      1  0e73		       59 0e		      .word.w	STMT
     46  0e75				   S1
      0  0e75					      TST	S2b,"GO"	;GOTO OT GOSUB?
      0  0e75					      db	32
      1  0e75		       20		      .byte.b	32
      0  0e76					      db	(S2b-*)-1
      1  0e76		       19		      .byte.b	(S2b-*)-1
      0  0e77					      db	"GO",0
      1  0e77		       47 4f 00 	      .byte.b	"GO",0
      0  0e7a					      TST	S2,"TO"	;YES...TO, OR...SUB
      0  0e7a					      db	32
      1  0e7a		       20		      .byte.b	32
      0  0e7b					      db	(S2-*)-1
      1  0e7b		       08		      .byte.b	(S2-*)-1
      0  0e7c					      db	"TO",0
      1  0e7c		       54 4f 00 	      .byte.b	"TO",0
      0  0e7f					      CALL	EXPR	;GET LABEL
      0  0e7f					      db	28
      1  0e7f		       1c		      .byte.b	28
      0  0e80					      dw	EXPR
      1  0e80		       d4 0f		      .word.w	EXPR
      0  0e82					      DONE		;ERROR IF CR NOT NEXT
      0  0e82					      db	1
      1  0e82		       01		      .byte.b	1
      0  0e83					      XFER		;SET UP AND JUMP
      0  0e83					      db	7
      1  0e83		       07		      .byte.b	7
     52  0e84				   S2
      0  0e84					      TST	ERRVEC,"SUB"	;ERROR IF NO MATCH
      0  0e84					      db	32
      1  0e84		       20		      .byte.b	32
      0  0e85					      db	(ERRVEC-*)-1
      1  0e85		       60		      .byte.b	(ERRVEC-*)-1
      0  0e86					      db	"SUB",0
      1  0e86		       53 55 42 00	      .byte.b	"SUB",0
      0  0e8a					      CALL	EXPR	;GET DESTINATION
      0  0e8a					      db	28
      1  0e8a		       1c		      .byte.b	28
      0  0e8b					      dw	EXPR
      1  0e8b		       d4 0f		      .word.w	EXPR
      0  0e8d					      DONE		;ERROR IF CR NOT NEXT
      0  0e8d					      db	1
      1  0e8d		       01		      .byte.b	1
      0  0e8e					      SAV		;SAVE RETURN LINE
      0  0e8e					      db	8
      1  0e8e		       08		      .byte.b	8
      0  0e8f					      XFER		;AND JUMP
      0  0e8f					      db	7
      1  0e8f		       07		      .byte.b	7
     58  0e90				   S2b
      0  0e90					      TST	S3,"RE"	;Speed up pocessing but more memory
      0  0e90					      db	32
      1  0e90		       20		      .byte.b	32
      0  0e91					      db	(S3-*)-1
      1  0e91		       1f		      .byte.b	(S3-*)-1
      0  0e92					      db	"RE",0
      1  0e92		       52 45 00 	      .byte.b	"RE",0
      0  0e95					      TST	S2a,"T"
      0  0e95					      db	32
      1  0e95		       20		      .byte.b	32
      0  0e96					      db	(S2a-*)-1
      1  0e96		       10		      .byte.b	(S2a-*)-1
      0  0e97					      db	"T",0
      1  0e97		       54 00		      .byte.b	"T",0
      0  0e99					      TST	S2aa,"URN"	;RETURN STATEMENT
      0  0e99					      db	32
      1  0e99		       20		      .byte.b	32
      0  0e9a					      db	(S2aa-*)-1
      1  0e9a		       04		      .byte.b	(S2aa-*)-1
      0  0e9b					      db	"URN",0
      1  0e9b		       55 52 4e 00	      .byte.b	"URN",0
      0  0e9f				   S2aa       DONE		;MUST BE CR
      0  0e9f					      db	1
      1  0e9f		       01		      .byte.b	1
      0  0ea0					      RSTR		;RESTORE LINE NUMBER OF CALL
      0  0ea0					      db	9
      1  0ea0		       09		      .byte.b	9
      0  0ea1					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  0ea1					      db	6
      1  0ea1		       06		      .byte.b	6
      0  0ea2					      dw	CO
      1  0ea2		       51 0e		      .word.w	CO
      0  0ea4					      IJMP	STMT
      0  0ea4					      db	29
      1  0ea4		       1d		      .byte.b	29
      0  0ea5					      dw	STMT
      1  0ea5		       59 0e		      .word.w	STMT
     66  0ea7				   S2a
      0  0ea7					      TST	S3,"M"	;REMark.  Skip rest of line
      0  0ea7					      db	32
      1  0ea7		       20		      .byte.b	32
      0  0ea8					      db	(S3-*)-1
      1  0ea8		       08		      .byte.b	(S3-*)-1
      0  0ea9					      db	"M",0
      1  0ea9		       4d 00		      .byte.b	"M",0
      0  0eab					      NXT	CO
      0  0eab					      db	6
      1  0eab		       06		      .byte.b	6
      0  0eac					      dw	CO
      1  0eac		       51 0e		      .word.w	CO
      0  0eae					      IJMP	STMT
      0  0eae					      db	29
      1  0eae		       1d		      .byte.b	29
      0  0eaf					      dw	STMT
      1  0eaf		       59 0e		      .word.w	STMT
     70  0eb1
     71  0eb1				   S3
      0  0eb1					      TST	S3a,"?"	; ? symonym for print
      0  0eb1					      db	32
      1  0eb1		       20		      .byte.b	32
      0  0eb2					      db	(S3a-*)-1
      1  0eb2		       05		      .byte.b	(S3a-*)-1
      0  0eb3					      db	"?",0
      1  0eb3		       3f 00		      .byte.b	"?",0
      0  0eb5					      IJMP	S4
      0  0eb5					      db	29
      1  0eb5		       1d		      .byte.b	29
      0  0eb6					      dw	S4
      1  0eb6		       c3 0e		      .word.w	S4
     74  0eb8				   S3a
      0  0eb8					      TST	S8,"PR"	;allow short form of print
      0  0eb8					      db	32
      1  0eb8		       20		      .byte.b	32
      0  0eb9					      db	(S8-*)-1
      1  0eb9		       36		      .byte.b	(S8-*)-1
      0  0eba					      db	"PR",0
      1  0eba		       50 52 00 	      .byte.b	"PR",0
      0  0ebd					      TST	S4,"INT"	;PRINT
      0  0ebd					      db	32
      1  0ebd		       20		      .byte.b	32
      0  0ebe					      db	(S4-*)-1
      1  0ebe		       04		      .byte.b	(S4-*)-1
      0  0ebf					      db	"INT",0
      1  0ebf		       49 4e 54 00	      .byte.b	"INT",0
     77  0ec3				   S4
      0  0ec3					      TSTDONE	S4a	;Test if we just want crlf printed
      0  0ec3					      db	50
      1  0ec3		       32		      .byte.b	50
      0  0ec4					      db	(S4a-*)-1
      1  0ec4		       03		      .byte.b	(S4a-*)-1
      0  0ec5					      IJMP	S6
      0  0ec5					      db	29
      1  0ec5		       1d		      .byte.b	29
      0  0ec6					      dw	S6
      1  0ec6		       de 0e		      .word.w	S6
     80  0ec8
      0  0ec8				   S4a	      TSTSTR	S7	;TEST FOR QUOTED String
      0  0ec8					      db	55
      1  0ec8		       37		      .byte.b	55
      0  0ec9					      db	(S7-*)-1
      1  0ec9		       1f		      .byte.b	(S7-*)-1
      0  0eca					      PRS		;PRINT STRING
      0  0eca					      db	2
      1  0eca		       02		      .byte.b	2
     83  0ecb				   S5
      0  0ecb					      TST	S6A,COMMA	;IS THERE MORE?
      0  0ecb					      db	32
      1  0ecb		       20		      .byte.b	32
      0  0ecc					      db	(S6A-*)-1
      1  0ecc		       08		      .byte.b	(S6A-*)-1
      0  0ecd					      db	COMMA,0
      1  0ecd		       2c 00		      .byte.b	COMMA,0
      0  0ecf					      SPC		;SPACE TO NEXT ZONE
      0  0ecf					      db	4
      1  0ecf		       04		      .byte.b	4
      0  0ed0					      TSTDONE	S4	;Not end of line jump back
      0  0ed0					      db	50
      1  0ed0		       32		      .byte.b	50
      0  0ed1					      db	(S4-*)-1
      1  0ed1		       f1		      .byte.b	(S4-*)-1
      0  0ed2					      IJMP	S6a	;YES JUMP BACK
      0  0ed2					      db	29
      1  0ed2		       1d		      .byte.b	29
      0  0ed3					      dw	S6a
      1  0ed3		       e0 0e		      .word.w	S6a
     88  0ed5							;
     89  0ed5							; If a semicolon, don't do anything.
     90  0ed5							;
     91  0ed5				   S6A
      0  0ed5					      TST	S6,SEMICOLON	;IF semicolon also check if end of line
      0  0ed5					      db	32
      1  0ed5		       20		      .byte.b	32
      0  0ed6					      db	(S6-*)-1
      1  0ed6		       07		      .byte.b	(S6-*)-1
      0  0ed7					      db	SEMICOLON,0
      1  0ed7		       3b 00		      .byte.b	SEMICOLON,0
      0  0ed9					      TSTDONE	S4	;Jump Back if not end of line
      0  0ed9					      db	50
      1  0ed9		       32		      .byte.b	50
      0  0eda					      db	(S4-*)-1
      1  0eda		       e8		      .byte.b	(S4-*)-1
      0  0edb					      IJMP	S6a
      0  0edb					      db	29
      1  0edb		       1d		      .byte.b	29
      0  0edc					      dw	S6a
      1  0edc		       e0 0e		      .word.w	S6a
     95  0ede				   S6
      0  0ede					      DONE		;ERROR IF CR NOT NEXT
      0  0ede					      db	1
      1  0ede		       01		      .byte.b	1
      0  0edf					      NLINE
      0  0edf					      db	5
      1  0edf		       05		      .byte.b	5
      0  0ee0				   S6a	      NXT	CO	;exit here if , or ; at end of print
      0  0ee0					      db	6
      1  0ee0		       06		      .byte.b	6
      0  0ee1					      dw	CO
      1  0ee1		       51 0e		      .word.w	CO
      0  0ee3					      IJMP	STMT
      0  0ee3					      db	29
      1  0ee3		       1d		      .byte.b	29
      0  0ee4					      dw	STMT
      1  0ee4		       59 0e		      .word.w	STMT
    100  0ee6							;
    101  0ee6							; A jump for code too far away for relative branch
    102  0ee6							;
    103  0ee6				   ERRVEC
      0  0ee6					      IJMP	UNKNOWN
      0  0ee6					      db	29
      1  0ee6		       1d		      .byte.b	29
      0  0ee7					      dw	UNKNOWN
      1  0ee7		       d1 0f		      .word.w	UNKNOWN
    105  0ee9							;
    106  0ee9				   S7
      0  0ee9					      CALL	EXPR
      0  0ee9					      db	28
      1  0ee9		       1c		      .byte.b	28
      0  0eea					      dw	EXPR
      1  0eea		       d4 0f		      .word.w	EXPR
      0  0eec					      PRN		;PRINT IT
      0  0eec					      db	3
      1  0eec		       03		      .byte.b	3
      0  0eed					      IJMP	S5	;IS THERE MORE?
      0  0eed					      db	29
      1  0eed		       1d		      .byte.b	29
      0  0eee					      dw	S5
      1  0eee		       cb 0e		      .word.w	S5
    110  0ef0				   S8
      0  0ef0					      TST	S8a,"IF"	;IF STATEMENT
      0  0ef0					      db	32
      1  0ef0		       20		      .byte.b	32
      0  0ef1					      db	(S8a-*)-1
      1  0ef1		       17		      .byte.b	(S8a-*)-1
      0  0ef2					      db	"IF",0
      1  0ef2		       49 46 00 	      .byte.b	"IF",0
      0  0ef5					      CALL	EXPR	;GET EXPRESSION
      0  0ef5					      db	28
      1  0ef5		       1c		      .byte.b	28
      0  0ef6					      dw	EXPR
      1  0ef6		       d4 0f		      .word.w	EXPR
      0  0ef8					      CALL	RELOP	;DETERMINE OPR AND PUT ON STK
      0  0ef8					      db	28
      1  0ef8		       1c		      .byte.b	28
      0  0ef9					      dw	RELOP
      1  0ef9		       9e 10		      .word.w	RELOP
      0  0efb					      CALL	EXPR	;GET EXPRESSION
      0  0efb					      db	28
      1  0efb		       1c		      .byte.b	28
      0  0efc					      dw	EXPR
      1  0efc		       d4 0f		      .word.w	EXPR
      0  0efe					      TST	S8a1,"THEN"	;(This line originally omitted) not required
      0  0efe					      db	32
      1  0efe		       20		      .byte.b	32
      0  0eff					      db	(S8a1-*)-1
      1  0eff		       05		      .byte.b	(S8a1-*)-1
      0  0f00					      db	"THEN",0
      1  0f00		       54 48 45 4e*	      .byte.b	"THEN",0
      0  0f05				   S8a1       CMPR		;PERFORM COMPARISON -- PERFORMS NXT IF FALSE
      0  0f05					      db	10
      1  0f05		       0a		      .byte.b	10
      0  0f06					      IJMP	STMT
      0  0f06					      db	29
      1  0f06		       1d		      .byte.b	29
      0  0f07					      dw	STMT
      1  0f07		       59 0e		      .word.w	STMT
    118  0f09
    119  0f09				   S8a
      0  0f09					      TST	S8b,"POKE("	;Poke a value into memory
      0  0f09					      db	32
      1  0f09		       20		      .byte.b	32
      0  0f0a					      db	(S8b-*)-1
      1  0f0a		       1c		      .byte.b	(S8b-*)-1
      0  0f0b					      db	"POKE(",0
      1  0f0b		       50 4f 4b 45*	      .byte.b	"POKE(",0
      0  0f11					      CALL	EXPR	;Get address to write to
      0  0f11					      db	28
      1  0f11		       1c		      .byte.b	28
      0  0f12					      dw	EXPR
      1  0f12		       d4 0f		      .word.w	EXPR
      0  0f14					      TST	UNKNOWN,COMMA	;Must have a coma
      0  0f14					      db	32
      1  0f14		       20		      .byte.b	32
      0  0f15					      db	(UNKNOWN-*)-1
      1  0f15		       bb		      .byte.b	(UNKNOWN-*)-1
      0  0f16					      db	COMMA,0
      1  0f16		       2c 00		      .byte.b	COMMA,0
      0  0f18					      CALL	EXPR	;Get the value to poke
      0  0f18					      db	28
      1  0f18		       1c		      .byte.b	28
      0  0f19					      dw	EXPR
      1  0f19		       d4 0f		      .word.w	EXPR
      0  0f1b					      TST	UNKNOWN,")"
      0  0f1b					      db	32
      1  0f1b		       20		      .byte.b	32
      0  0f1c					      db	(UNKNOWN-*)-1
      1  0f1c		       b4		      .byte.b	(UNKNOWN-*)-1
      0  0f1d					      db	")",0
      1  0f1d		       29 00		      .byte.b	")",0
      0  0f1f					      POKEMEM
      0  0f1f					      db	47
      1  0f1f		       2f		      .byte.b	47
      0  0f20					      DONE
      0  0f20					      db	1
      1  0f20		       01		      .byte.b	1
      0  0f21					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0f21					      db	6
      1  0f21		       06		      .byte.b	6
      0  0f22					      dw	CO
      1  0f22		       51 0e		      .word.w	CO
      0  0f24					      IJMP	STMT
      0  0f24					      db	29
      1  0f24		       1d		      .byte.b	29
      0  0f25					      dw	STMT
      1  0f25		       59 0e		      .word.w	STMT
    129  0f27
    130  0f27				   S8b
      0  0f27					      TST	S8c,"PUTCH("	;Put a char to the terminal
      0  0f27					      db	32
      1  0f27		       20		      .byte.b	32
      0  0f28					      db	(S8c-*)-1
      1  0f28		       16		      .byte.b	(S8c-*)-1
      0  0f29					      db	"PUTCH(",0
      1  0f29		       50 55 54 43*	      .byte.b	"PUTCH(",0
      0  0f30					      CALL	EXPR
      0  0f30					      db	28
      1  0f30		       1c		      .byte.b	28
      0  0f31					      dw	EXPR
      1  0f31		       d4 0f		      .word.w	EXPR
      0  0f33					      TST	UNKNOWN,")"
      0  0f33					      db	32
      1  0f33		       20		      .byte.b	32
      0  0f34					      db	(UNKNOWN-*)-1
      1  0f34		       9c		      .byte.b	(UNKNOWN-*)-1
      0  0f35					      db	")",0
      1  0f35		       29 00		      .byte.b	")",0
      0  0f37					      PUTCHAR
      0  0f37					      db	52
      1  0f37		       34		      .byte.b	52
      0  0f38					      DONE
      0  0f38					      db	1
      1  0f38		       01		      .byte.b	1
      0  0f39					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0f39					      db	6
      1  0f39		       06		      .byte.b	6
      0  0f3a					      dw	CO
      1  0f3a		       51 0e		      .word.w	CO
      0  0f3c					      IJMP	STMT
      0  0f3c					      db	29
      1  0f3c		       1d		      .byte.b	29
      0  0f3d					      dw	STMT
      1  0f3d		       59 0e		      .word.w	STMT
    138  0f3f				   S8c
      0  0f3f					      TST	S9,"CLS"	;Clear the screen
      0  0f3f					      db	32
      1  0f3f		       20		      .byte.b	32
      0  0f40					      db	(S9-*)-1
      1  0f40		       0c		      .byte.b	(S9-*)-1
      0  0f41					      db	"CLS",0
      1  0f41		       43 4c 53 00	      .byte.b	"CLS",0
      0  0f45					      CLEARSCREEN
      0  0f45					      db	46
      1  0f45		       2e		      .byte.b	46
      0  0f46					      DONE
      0  0f46					      db	1
      1  0f46		       01		      .byte.b	1
      0  0f47					      NXT	CO	;AND SEQUENCE TO NEXT
      0  0f47					      db	6
      1  0f47		       06		      .byte.b	6
      0  0f48					      dw	CO
      1  0f48		       51 0e		      .word.w	CO
      0  0f4a					      IJMP	STMT
      0  0f4a					      db	29
      1  0f4a		       1d		      .byte.b	29
      0  0f4b					      dw	STMT
      1  0f4b		       59 0e		      .word.w	STMT
    144  0f4d				   S9
      0  0f4d					      TST	S13,"INPUT"	;INPUT STATEMENT
      0  0f4d					      db	32
      1  0f4d		       20		      .byte.b	32
      0  0f4e					      db	(S13-*)-1
      1  0f4e		       18		      .byte.b	(S13-*)-1
      0  0f4f					      db	"INPUT",0
      1  0f4f		       49 4e 50 55*	      .byte.b	"INPUT",0
    146  0f55				   S10
      0  0f55					      TSTV	UNKNOWN	;GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  0f55					      db	33
      1  0f55		       21		      .byte.b	33
      0  0f56					      db	(UNKNOWN-*)-1
      1  0f56		       7a		      .byte.b	(UNKNOWN-*)-1
      0  0f57					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  0f57					      db	11
      1  0f57		       0b		      .byte.b	11
      0  0f58					      STORE		;STORE IT
      0  0f58					      db	19
      1  0f58		       13		      .byte.b	19
      0  0f59					      TST	S11,COMMA	;IS THERE MORE?
      0  0f59					      db	32
      1  0f59		       20		      .byte.b	32
      0  0f5a					      db	(S11-*)-1
      1  0f5a		       05		      .byte.b	(S11-*)-1
      0  0f5b					      db	COMMA,0
      1  0f5b		       2c 00		      .byte.b	COMMA,0
      0  0f5d					      IJMP	S10	;YES
      0  0f5d					      db	29
      1  0f5d		       1d		      .byte.b	29
      0  0f5e					      dw	S10
      1  0f5e		       55 0f		      .word.w	S10
    152  0f60
    153  0f60				   S11
      0  0f60					      DONE		;MUST BE CR
      0  0f60					      db	1
      1  0f60		       01		      .byte.b	1
      0  0f61					      NXT	CO	;SEQUENCE TO NEXT
      0  0f61					      db	6
      1  0f61		       06		      .byte.b	6
      0  0f62					      dw	CO
      1  0f62		       51 0e		      .word.w	CO
      0  0f64					      IJMP	STMT
      0  0f64					      db	29
      1  0f64		       1d		      .byte.b	29
      0  0f65					      dw	STMT
      1  0f65		       59 0e		      .word.w	STMT
    157  0f67				   S13
      0  0f67					      TST	S14,"END"
      0  0f67					      db	32
      1  0f67		       20		      .byte.b	32
      0  0f68					      db	(S14-*)-1
      1  0f68		       05		      .byte.b	(S14-*)-1
      0  0f69					      db	"END",0
      1  0f69		       45 4e 44 00	      .byte.b	"END",0
      0  0f6d					      FIN
      0  0f6d					      db	12
      1  0f6d		       0c		      .byte.b	12
    160  0f6e				   S14
      0  0f6e					      TST	S15,"LIST"	;LIST COMMAND
      0  0f6e					      db	32
      1  0f6e		       20		      .byte.b	32
      0  0f6f					      db	(S15-*)-1
      1  0f6f		       0a		      .byte.b	(S15-*)-1
      0  0f70					      db	"LIST",0
      1  0f70		       4c 49 53 54*	      .byte.b	"LIST",0
      0  0f75					      DONE
      0  0f75					      db	1
      1  0f75		       01		      .byte.b	1
      0  0f76					      LST
      0  0f76					      db	21
      1  0f76		       15		      .byte.b	21
      0  0f77					      IJMP	CO
      0  0f77					      db	29
      1  0f77		       1d		      .byte.b	29
      0  0f78					      dw	CO
      1  0f78		       51 0e		      .word.w	CO
    165  0f7a				   S15
      0  0f7a					      TST	S16,"RUN"	;RUN COMMAND
      0  0f7a					      db	32
      1  0f7a		       20		      .byte.b	32
      0  0f7b					      db	(S16-*)-1
      1  0f7b		       0d		      .byte.b	(S16-*)-1
      0  0f7c					      db	"RUN",0
      1  0f7c		       52 55 4e 00	      .byte.b	"RUN",0
      0  0f80					      DONE
      0  0f80					      db	1
      1  0f80		       01		      .byte.b	1
      0  0f81					      VINIT		;clear variables
      0  0f81					      db	30
      1  0f81		       1e		      .byte.b	30
      0  0f82					      LIT	1	;GOTO line 1
      0  0f82					      db	27
      1  0f82		       1b		      .byte.b	27
      0  0f83					      dw	1
      1  0f83		       01 00		      .word.w	1
      0  0f85					      XFER		;Bob's addition
      0  0f85					      db	7
      1  0f85		       07		      .byte.b	7
    171  0f86							; EXIT
      0  0f86					      IJMP	STMT	;and run!
      0  0f86					      db	29
      1  0f86		       1d		      .byte.b	29
      0  0f87					      dw	STMT
      1  0f87		       59 0e		      .word.w	STMT
    173  0f89				   S16
      0  0f89					      TST	S17A,"NEW"	;clear program
      0  0f89					      db	32
      1  0f89		       20		      .byte.b	32
      0  0f8a					      db	(S17A-*)-1
      1  0f8a		       08		      .byte.b	(S17A-*)-1
      0  0f8b					      db	"NEW",0
      1  0f8b		       4e 45 57 00	      .byte.b	"NEW",0
      0  0f8f					      DONE
      0  0f8f					      db	1
      1  0f8f		       01		      .byte.b	1
      0  0f90					      IJMP	START
      0  0f90					      db	29
      1  0f90		       1d		      .byte.b	29
      0  0f91					      dw	START
      1  0f91		       4b 0e		      .word.w	START
    177  0f93
    178  0f93				   S17A
      0  0f93					      TST	S17B,"EXIT"	;allow them to exit BASIC
      0  0f93					      db	32
      1  0f93		       20		      .byte.b	32
      0  0f94					      db	(S17B-*)-1
      1  0f94		       06		      .byte.b	(S17B-*)-1
      0  0f95					      db	"EXIT",0
      1  0f95		       45 58 49 54*	      .byte.b	"EXIT",0
      0  0f9a					      EXIT
      0  0f9a					      db	26
      1  0f9a		       1a		      .byte.b	26
    181  0f9b
    182  0f9b							;
    183  0f9b							; Commands related to saving/restoring programs
    184  0f9b							; to/from mass storage.
    185  0f9b							;
    186  0f9b				   S17B
    187  0f9b					      if	(XKIM || CTMON65) && DISK_ACCESS
    188  0f9b
      0  0f9b					      TST	S17C,"SAVE"
      0  0f9b					      db	32
      1  0f9b		       20		      .byte.b	32
      0  0f9c					      db	(S17C-*)-1
      1  0f9c		       0b		      .byte.b	(S17C-*)-1
      0  0f9d					      db	"SAVE",0
      1  0f9d		       53 41 56 45*	      .byte.b	"SAVE",0
      0  0fa2					      OPENWRITE
      0  0fa2					      db	40
      1  0fa2		       28		      .byte.b	40
      0  0fa3					      DLIST
      0  0fa3					      db	43
      1  0fa3		       2b		      .byte.b	43
      0  0fa4					      DCLOSE
      0  0fa4					      db	41
      1  0fa4		       29		      .byte.b	41
      0  0fa5					      IJMP	CO
      0  0fa5					      db	29
      1  0fa5		       1d		      .byte.b	29
      0  0fa6					      dw	CO
      1  0fa6		       51 0e		      .word.w	CO
    194  0fa8
    195  0fa8				   S17C
      0  0fa8					      TST	S18,"LOAD"
      0  0fa8					      db	32
      1  0fa8		       20		      .byte.b	32
      0  0fa9					      db	(S18-*)-1
      1  0fa9		       11		      .byte.b	(S18-*)-1
      0  0faa					      db	"LOAD",0
      1  0faa		       4c 4f 41 44*	      .byte.b	"LOAD",0
      0  0faf					      OPENREAD
      0  0faf					      db	39
      1  0faf		       27		      .byte.b	39
    198  0fb0				   S17CLP
      0  0fb0					      DGETLINE		;get line from file
      0  0fb0					      db	42
      1  0fb0		       2a		      .byte.b	42
      0  0fb1					      TSTL	S17EOL	;no line num means EOL
      0  0fb1					      db	34
      1  0fb1		       22		      .byte.b	34
      0  0fb2					      db	(S17EOL-*)-1
      1  0fb2		       04		      .byte.b	(S17EOL-*)-1
      0  0fb3					      INSERT		;put it into the program
      0  0fb3					      db	24
      1  0fb3		       18		      .byte.b	24
      0  0fb4					      IJMP	S17CLP	;keep going
      0  0fb4					      db	29
      1  0fb4		       1d		      .byte.b	29
      0  0fb5					      dw	S17CLP
      1  0fb5		       b0 0f		      .word.w	S17CLP
    203  0fb7				   S17EOL
      0  0fb7					      DCLOSE		;close disk file
      0  0fb7					      db	41
      1  0fb7		       29		      .byte.b	41
      0  0fb8					      IJMP	CO	;back to start
      0  0fb8					      db	29
      1  0fb8		       1d		      .byte.b	29
      0  0fb9					      dw	CO
      1  0fb9		       51 0e		      .word.w	CO
    206  0fbb
      0  0fbb				   S18	      TST	S19,"DIR"
      0  0fbb					      db	32
      1  0fbb		       20		      .byte.b	32
      0  0fbc					      db	(S19-*)-1
      1  0fbc		       08		      .byte.b	(S19-*)-1
      0  0fbd					      db	"DIR",0
      1  0fbd		       44 49 52 00	      .byte.b	"DIR",0
      0  0fc1					      DDIR		;Display the directory content
      0  0fc1					      db	44
      1  0fc1		       2c		      .byte.b	44
      0  0fc2					      IJMP	CO
      0  0fc2					      db	29
      1  0fc2		       1d		      .byte.b	29
      0  0fc3					      dw	CO
      1  0fc3		       51 0e		      .word.w	CO
    210  0fc5					      endif
    211  0fc5
      0  0fc5				   S19	      TST	UNKNOWN,"ERASE"
      0  0fc5					      db	32
      1  0fc5		       20		      .byte.b	32
      0  0fc6					      db	(UNKNOWN-*)-1
      1  0fc6		       0a		      .byte.b	(UNKNOWN-*)-1
      0  0fc7					      db	"ERASE",0
      1  0fc7		       45 52 41 53*	      .byte.b	"ERASE",0
      0  0fcd					      RMFILE		;Erase the file from the disk
      0  0fcd					      db	45
      1  0fcd		       2d		      .byte.b	45
      0  0fce					      IJMP	CO
      0  0fce					      db	29
      1  0fce		       1d		      .byte.b	29
      0  0fcf					      dw	CO
      1  0fcf		       51 0e		      .word.w	CO
    215  0fcf					      endif
    216  0fd1
    217  0fd1							;
    218  0fd1							; Else, unknown command.
    219  0fd1							;
    220  0fd1				   UNKNOWN
      0  0fd1					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  0fd1					      db	13
      1  0fd1		       0d		      .byte.b	13
      0  0fd2					      dw	ERR_SYNTAX
      1  0fd2		       05 00		      .word.w	ERR_SYNTAX
    222  0fd4
    223  0fd4							;-----------------------------------------------------
    224  0fd4				   EXPR
      0  0fd4					      TST	E0,"-"
      0  0fd4					      db	32
      1  0fd4		       20		      .byte.b	32
      0  0fd5					      db	(E0-*)-1
      1  0fd5		       09		      .byte.b	(E0-*)-1
      0  0fd6					      db	"-",0
      1  0fd6		       2d 00		      .byte.b	"-",0
      0  0fd8					      CALL	TERM	;TEST FOR UNARY -.
      0  0fd8					      db	28
      1  0fd8		       1c		      .byte.b	28
      0  0fd9					      dw	TERM
      1  0fd9		       fd 0f		      .word.w	TERM
      0  0fdb					      NEG		;GET VALUE
      0  0fdb					      db	16
      1  0fdb		       10		      .byte.b	16
      0  0fdc					      IJMP	E1	;NEGATE IT
      0  0fdc					      db	29
      1  0fdc		       1d		      .byte.b	29
      0  0fdd					      dw	E1
      1  0fdd		       e6 0f		      .word.w	E1
    229  0fdf				   E0
      0  0fdf					      TST	E1A,"+"	;LOOK FOR MORE
      0  0fdf					      db	32
      1  0fdf		       20		      .byte.b	32
      0  0fe0					      db	(E1A-*)-1
      1  0fe0		       02		      .byte.b	(E1A-*)-1
      0  0fe1					      db	"+",0
      1  0fe1		       2b 00		      .byte.b	"+",0
    231  0fe3				   E1A
      0  0fe3					      CALL	TERM	;TEST FOR UNARY +
      0  0fe3					      db	28
      1  0fe3		       1c		      .byte.b	28
      0  0fe4					      dw	TERM
      1  0fe4		       fd 0f		      .word.w	TERM
    233  0fe6				   E1
      0  0fe6					      TST	E2,"+"	;LEADING TERM
      0  0fe6					      db	32
      1  0fe6		       20		      .byte.b	32
      0  0fe7					      db	(E2-*)-1
      1  0fe7		       09		      .byte.b	(E2-*)-1
      0  0fe8					      db	"+",0
      1  0fe8		       2b 00		      .byte.b	"+",0
      0  0fea					      CALL	TERM
      0  0fea					      db	28
      1  0fea		       1c		      .byte.b	28
      0  0feb					      dw	TERM
      1  0feb		       fd 0f		      .word.w	TERM
      0  0fed					      ADD
      0  0fed					      db	14
      1  0fed		       0e		      .byte.b	14
      0  0fee					      IJMP	E1
      0  0fee					      db	29
      1  0fee		       1d		      .byte.b	29
      0  0fef					      dw	E1
      1  0fef		       e6 0f		      .word.w	E1
    238  0ff1				   E2
      0  0ff1					      TST	E3,"-"	;ANY MORE?
      0  0ff1					      db	32
      1  0ff1		       20		      .byte.b	32
      0  0ff2					      db	(E3-*)-1
      1  0ff2		       09		      .byte.b	(E3-*)-1
      0  0ff3					      db	"-",0
      1  0ff3		       2d 00		      .byte.b	"-",0
      0  0ff5					      CALL	TERM	;DIFFERENCE TERM
      0  0ff5					      db	28
      1  0ff5		       1c		      .byte.b	28
      0  0ff6					      dw	TERM
      1  0ff6		       fd 0f		      .word.w	TERM
      0  0ff8					      SUB
      0  0ff8					      db	15
      1  0ff8		       0f		      .byte.b	15
      0  0ff9					      IJMP	E1
      0  0ff9					      db	29
      1  0ff9		       1d		      .byte.b	29
      0  0ffa					      dw	E1
      1  0ffa		       e6 0f		      .word.w	E1
    243  0ffc				   E3
    244  0ffc				   T2
      0  0ffc					      RTN		;ANY MORE?
      0  0ffc					      db	25
      1  0ffc		       19		      .byte.b	25
    246  0ffd				   TERM
      0  0ffd					      CALL	FACT
      0  0ffd					      db	28
      1  0ffd		       1c		      .byte.b	28
      0  0ffe					      dw	FACT
      1  0ffe		       19 10		      .word.w	FACT
    248  1000				   T0
      0  1000					      TST	T1,"*"
      0  1000					      db	32
      1  1000		       20		      .byte.b	32
      0  1001					      db	(T1-*)-1
      1  1001		       09		      .byte.b	(T1-*)-1
      0  1002					      db	"*",0
      1  1002		       2a 00		      .byte.b	"*",0
      0  1004					      CALL	FACT	;PRODUCT FACTOR.
      0  1004					      db	28
      1  1004		       1c		      .byte.b	28
      0  1005					      dw	FACT
      1  1005		       19 10		      .word.w	FACT
      0  1007					      MUL
      0  1007					      db	17
      1  1007		       11		      .byte.b	17
      0  1008					      IJMP	T0
      0  1008					      db	29
      1  1008		       1d		      .byte.b	29
      0  1009					      dw	T0
      1  1009		       00 10		      .word.w	T0
    253  100b				   T1
      0  100b					      TST	T2,"/"
      0  100b					      db	32
      1  100b		       20		      .byte.b	32
      0  100c					      db	(T2-*)-1
      1  100c		       ef		      .byte.b	(T2-*)-1
      0  100d					      db	"/",0
      1  100d		       2f 00		      .byte.b	"/",0
      0  100f					      CALL	FACT	;QUOTIENT FACTOR.
      0  100f					      db	28
      1  100f		       1c		      .byte.b	28
      0  1010					      dw	FACT
      1  1010		       19 10		      .word.w	FACT
      0  1012					      DIV
      0  1012					      db	18
      1  1012		       12		      .byte.b	18
      0  1013					      IJMP	T0
      0  1013					      db	29
      1  1013		       1d		      .byte.b	29
      0  1014					      dw	T0
      1  1014		       00 10		      .word.w	T0
    258  1016
    259  1016				   UNKNOWNVEC
      0  1016					      IJMP	UNKNOWN
      0  1016					      db	29
      1  1016		       1d		      .byte.b	29
      0  1017					      dw	UNKNOWN
      1  1017		       d1 0f		      .word.w	UNKNOWN
    261  1019
    262  1019							;
    263  1019							; Factor an expression.  Always test for functions
    264  1019							; first or else they'll be confused for variables.
    265  1019							;
    266  1019				   FACT
      0  1019					      TST	F1A,"FREE()"
      0  1019					      db	32
      1  1019		       20		      .byte.b	32
      0  101a					      db	(F1A-*)-1
      1  101a		       09		      .byte.b	(F1A-*)-1
      0  101b					      db	"FREE()",0
      1  101b		       46 52 45 45*	      .byte.b	"FREE()",0
      0  1022					      FREE
      0  1022					      db	36
      1  1022		       24		      .byte.b	36
      0  1023					      RTN
      0  1023					      db	25
      1  1023		       19		      .byte.b	25
    270  1024				   F1A
      0  1024					      TST	F1A2,"GETCH()"	; read char from the terminal
      0  1024					      db	32
      1  1024		       20		      .byte.b	32
      0  1025					      db	(F1A2-*)-1
      1  1025		       0a		      .byte.b	(F1A2-*)-1
      0  1026					      db	"GETCH()",0
      1  1026		       47 45 54 43*	      .byte.b	"GETCH()",0
      0  102e					      GETCHAR
      0  102e					      db	51
      1  102e		       33		      .byte.b	51
      0  102f					      RTN
      0  102f					      db	25
      1  102f		       19		      .byte.b	25
    274  1030				   F1A2
      0  1030					      TST	F2A,"PEEK("	;Return a value from memory
      0  1030					      db	32
      1  1030		       20		      .byte.b	32
      0  1031					      db	(F2A-*)-1
      1  1031		       0f		      .byte.b	(F2A-*)-1
      0  1032					      db	"PEEK(",0
      1  1032		       50 45 45 4b*	      .byte.b	"PEEK(",0
      0  1038					      CALL	EXPR	;Get the address to write to
      0  1038					      db	28
      1  1038		       1c		      .byte.b	28
      0  1039					      dw	EXPR
      1  1039		       d4 0f		      .word.w	EXPR
      0  103b					      TST	UNKNOWN,")"	;Closing bracket
      0  103b					      db	32
      1  103b		       20		      .byte.b	32
      0  103c					      db	(UNKNOWN-*)-1
      1  103c		       94		      .byte.b	(UNKNOWN-*)-1
      0  103d					      db	")",0
      1  103d		       29 00		      .byte.b	")",0
      0  103f					      PEEKMEM
      0  103f					      db	48
      1  103f		       30		      .byte.b	48
      0  1040					      RTN
      0  1040					      db	25
      1  1040		       19		      .byte.b	25
    280  1041							;
    281  1041							; RND() is supposed to have an argument but if none
    282  1041							; was provided, just assume a large value.
    283  1041							;
    284  1041				   F2A
      0  1041					      TST	F2B,"RND("
      0  1041					      db	32
      1  1041		       20		      .byte.b	32
      0  1042					      db	(F2B-*)-1
      1  1042		       17		      .byte.b	(F2B-*)-1
      0  1043					      db	"RND(",0
      1  1043		       52 4e 44 28*	      .byte.b	"RND(",0
      0  1048					      TST	F2A1,")"
      0  1048					      db	32
      1  1048		       20		      .byte.b	32
      0  1049					      db	(F2A1-*)-1
      1  1049		       07		      .byte.b	(F2A1-*)-1
      0  104a					      db	")",0
      1  104a		       29 00		      .byte.b	")",0
      0  104c					      LIT	32766
      0  104c					      db	27
      1  104c		       1b		      .byte.b	27
      0  104d					      dw	32766
      1  104d		       fe 7f		      .word.w	32766
      0  104f					      RANDOM
      0  104f					      db	37
      1  104f		       25		      .byte.b	37
      0  1050					      RTN
      0  1050					      db	25
      1  1050		       19		      .byte.b	25
    290  1051				   F2A1
      0  1051					      CALL	FACT	;GET RANGE
      0  1051					      db	28
      1  1051		       1c		      .byte.b	28
      0  1052					      dw	FACT
      1  1052		       19 10		      .word.w	FACT
      0  1054					      TST	UNKNOWN,")"
      0  1054					      db	32
      1  1054		       20		      .byte.b	32
      0  1055					      db	(UNKNOWN-*)-1
      1  1055		       7b		      .byte.b	(UNKNOWN-*)-1
      0  1056					      db	")",0
      1  1056		       29 00		      .byte.b	")",0
      0  1058					      RANDOM
      0  1058					      db	37
      1  1058		       25		      .byte.b	37
      0  1059					      RTN
      0  1059					      db	25
      1  1059		       19		      .byte.b	25
    295  105a
    296  105a				   F2B
      0  105a					      TST	F2B2,"ABS("
      0  105a					      db	32
      1  105a		       20		      .byte.b	32
      0  105b					      db	(F2B2-*)-1
      1  105b		       0e		      .byte.b	(F2B2-*)-1
      0  105c					      db	"ABS(",0
      1  105c		       41 42 53 28*	      .byte.b	"ABS(",0
      0  1061					      CALL	FACT	;get value
      0  1061					      db	28
      1  1061		       1c		      .byte.b	28
      0  1062					      dw	FACT
      1  1062		       19 10		      .word.w	FACT
      0  1064					      TST	UNKNOWN,")"
      0  1064					      db	32
      1  1064		       20		      .byte.b	32
      0  1065					      db	(UNKNOWN-*)-1
      1  1065		       6b		      .byte.b	(UNKNOWN-*)-1
      0  1066					      db	")",0
      1  1066		       29 00		      .byte.b	")",0
      0  1068					      ABS
      0  1068					      db	38
      1  1068		       26		      .byte.b	38
      0  1069					      RTN
      0  1069					      db	25
      1  1069		       19		      .byte.b	25
    302  106a
    303  106a				   F2B2
      0  106a					      TST	F2C,"CALL("	;call machine function
      0  106a					      db	32
      1  106a		       20		      .byte.b	32
      0  106b					      db	(F2C-*)-1
      1  106b		       1c		      .byte.b	(F2C-*)-1
      0  106c					      db	"CALL(",0
      1  106c		       43 41 4c 4c*	      .byte.b	"CALL(",0
      0  1072					      CALL	EXPR
      0  1072					      db	28
      1  1072		       1c		      .byte.b	28
      0  1073					      dw	EXPR
      1  1073		       d4 0f		      .word.w	EXPR
      0  1075					      TST	F2B2A,COMMA
      0  1075					      db	32
      1  1075		       20		      .byte.b	32
      0  1076					      db	(F2B2A-*)-1
      1  1076		       0b		      .byte.b	(F2B2A-*)-1
      0  1077					      db	COMMA,0
      1  1077		       2c 00		      .byte.b	COMMA,0
      0  1079					      CALL	EXPR
      0  1079					      db	28
      1  1079		       1c		      .byte.b	28
      0  107a					      dw	EXPR
      1  107a		       d4 0f		      .word.w	EXPR
      0  107c					      TST	UNKNOWN,")"
      0  107c					      db	32
      1  107c		       20		      .byte.b	32
      0  107d					      db	(UNKNOWN-*)-1
      1  107d		       53		      .byte.b	(UNKNOWN-*)-1
      0  107e					      db	")",0
      1  107e		       29 00		      .byte.b	")",0
      0  1080					      CALLFUNC2
      0  1080					      db	54
      1  1080		       36		      .byte.b	54
      0  1081					      RTN
      0  1081					      db	25
      1  1081		       19		      .byte.b	25
    311  1082
      0  1082				   F2B2A      TST	UNKNOWN,")"
      0  1082					      db	32
      1  1082		       20		      .byte.b	32
      0  1083					      db	(UNKNOWN-*)-1
      1  1083		       4d		      .byte.b	(UNKNOWN-*)-1
      0  1084					      db	")",0
      1  1084		       29 00		      .byte.b	")",0
      0  1086					      CALLFUNC
      0  1086					      db	53
      1  1086		       35		      .byte.b	53
      0  1087					      RTN
      0  1087					      db	25
      1  1087		       19		      .byte.b	25
    315  1088				   F2C
      0  1088					      TSTV	F0
      0  1088					      db	33
      1  1088		       21		      .byte.b	33
      0  1089					      db	(F0-*)-1
      1  1089		       02		      .byte.b	(F0-*)-1
      0  108a					      IND		;YES, GET THE VALUE.
      0  108a					      db	20
      1  108a		       14		      .byte.b	20
      0  108b					      RTN
      0  108b					      db	25
      1  108b		       19		      .byte.b	25
    319  108c				   F0
      0  108c					      TSTN	F1	;NUMBER, GET ITS VALUE.
      0  108c					      db	35
      1  108c		       23		      .byte.b	35
      0  108d					      db	(F1-*)-1
      1  108d		       01		      .byte.b	(F1-*)-1
      0  108e					      RTN
      0  108e					      db	25
      1  108e		       19		      .byte.b	25
    322  108f				   F1
      0  108f					      TST	F2A,"("	;PARENTHESIZED EXPR.
      0  108f					      db	32
      1  108f		       20		      .byte.b	32
      0  1090					      db	(F2A-*)-1
      1  1090		       b0		      .byte.b	(F2A-*)-1
      0  1091					      db	"(",0
      1  1091		       28 00		      .byte.b	"(",0
      0  1093					      CALL	EXPR
      0  1093					      db	28
      1  1093		       1c		      .byte.b	28
      0  1094					      dw	EXPR
      1  1094		       d4 0f		      .word.w	EXPR
      0  1096					      TST	F2,")"
      0  1096					      db	32
      1  1096		       20		      .byte.b	32
      0  1097					      db	(F2-*)-1
      1  1097		       03		      .byte.b	(F2-*)-1
      0  1098					      db	")",0
      1  1098		       29 00		      .byte.b	")",0
      0  109a					      RTN
      0  109a					      db	25
      1  109a		       19		      .byte.b	25
    327  109b
    328  109b				   F2
      0  109b					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  109b					      db	13
      1  109b		       0d		      .byte.b	13
      0  109c					      dw	ERR_SYNTAX
      1  109c		       05 00		      .word.w	ERR_SYNTAX
    330  109e
    331  109e				   RELOP
      0  109e					      TST	iR0,"="
      0  109e					      db	32
      1  109e		       20		      .byte.b	32
      0  109f					      db	(iR0-*)-1
      1  109f		       06		      .byte.b	(iR0-*)-1
      0  10a0					      db	"=",0
      1  10a0		       3d 00		      .byte.b	"=",0
      0  10a2					      LIT	2	;=
      0  10a2					      db	27
      1  10a2		       1b		      .byte.b	27
      0  10a3					      dw	2
      1  10a3		       02 00		      .word.w	2
      0  10a5					      RTN
      0  10a5					      db	25
      1  10a5		       19		      .byte.b	25
    335  10a6				   iR0
      0  10a6					      TST	R4,"<"
      0  10a6					      db	32
      1  10a6		       20		      .byte.b	32
      0  10a7					      db	(R4-*)-1
      1  10a7		       16		      .byte.b	(R4-*)-1
      0  10a8					      db	"<",0
      1  10a8		       3c 00		      .byte.b	"<",0
      0  10aa					      TST	iR1,"="
      0  10aa					      db	32
      1  10aa		       20		      .byte.b	32
      0  10ab					      db	(iR1-*)-1
      1  10ab		       06		      .byte.b	(iR1-*)-1
      0  10ac					      db	"=",0
      1  10ac		       3d 00		      .byte.b	"=",0
      0  10ae					      LIT	3	;<=
      0  10ae					      db	27
      1  10ae		       1b		      .byte.b	27
      0  10af					      dw	3
      1  10af		       03 00		      .word.w	3
      0  10b1					      RTN
      0  10b1					      db	25
      1  10b1		       19		      .byte.b	25
    340  10b2				   iR1
      0  10b2					      TST	R3,">"
      0  10b2					      db	32
      1  10b2		       20		      .byte.b	32
      0  10b3					      db	(R3-*)-1
      1  10b3		       06		      .byte.b	(R3-*)-1
      0  10b4					      db	">",0
      1  10b4		       3e 00		      .byte.b	">",0
      0  10b6					      LIT	5	;<>
      0  10b6					      db	27
      1  10b6		       1b		      .byte.b	27
      0  10b7					      dw	5
      1  10b7		       05 00		      .word.w	5
      0  10b9					      RTN
      0  10b9					      db	25
      1  10b9		       19		      .byte.b	25
    344  10ba				   R3
      0  10ba					      LIT	1	;<
      0  10ba					      db	27
      1  10ba		       1b		      .byte.b	27
      0  10bb					      dw	1
      1  10bb		       01 00		      .word.w	1
      0  10bd					      RTN
      0  10bd					      db	25
      1  10bd		       19		      .byte.b	25
    347  10be				   R4
      0  10be					      TST	UNKNOWNVEC,">"
      0  10be					      db	32
      1  10be		       20		      .byte.b	32
      0  10bf					      db	(UNKNOWNVEC-*)-1
      1  10bf		       56		      .byte.b	(UNKNOWNVEC-*)-1
      0  10c0					      db	">",0
      1  10c0		       3e 00		      .byte.b	">",0
      0  10c2					      TST	R5,"="
      0  10c2					      db	32
      1  10c2		       20		      .byte.b	32
      0  10c3					      db	(R5-*)-1
      1  10c3		       06		      .byte.b	(R5-*)-1
      0  10c4					      db	"=",0
      1  10c4		       3d 00		      .byte.b	"=",0
      0  10c6					      LIT	6	;>=
      0  10c6					      db	27
      1  10c6		       1b		      .byte.b	27
      0  10c7					      dw	6
      1  10c7		       06 00		      .word.w	6
      0  10c9					      RTN
      0  10c9					      db	25
      1  10c9		       19		      .byte.b	25
    352  10ca				   R5
      0  10ca					      TST	R6,"<"
      0  10ca					      db	32
      1  10ca		       20		      .byte.b	32
      0  10cb					      db	(R6-*)-1
      1  10cb		       06		      .byte.b	(R6-*)-1
      0  10cc					      db	"<",0
      1  10cc		       3c 00		      .byte.b	"<",0
      0  10ce					      LIT	1
      0  10ce					      db	27
      1  10ce		       1b		      .byte.b	27
      0  10cf					      dw	1
      1  10cf		       01 00		      .word.w	1
      0  10d1					      RTN		;(This line originally omitted)
      0  10d1					      db	25
      1  10d1		       19		      .byte.b	25
    356  10d2				   R6
      0  10d2					      LIT	4	;>???
      0  10d2					      db	27
      1  10d2		       1b		      .byte.b	27
      0  10d3					      dw	4
      1  10d3		       04 00		      .word.w	4
      0  10d5					      RTN
      0  10d5					      db	25
      1  10d5		       19		      .byte.b	25
    359  10d6
    360  10d6		       10 d6	   ILEND      equ	*
------- FILE mytb.asm
   1573  10d6		       10 d6	   PROGEND    equ	*
   1574  10d6
   1575  10d6							;=====================================================
   1576  10d6							;=====================================================
   1577  10d6							;=====================================================
   1578  10d6							; These are storage items not in page zero.
   1579  10d6							;
   1580 Udf9e					      seg.u	Data
   1581 U10d6					      org	PROGEND
   1582 U10d6
   1583 U10d6		       00 00 00 00*mathStack  ds	STACKSIZE*2
   1584 U10e6		       00	   mathStackPtr ds	1
   1585 U10e7		       00 00 00 00*retStack   ds	STACKSIZE*2
   1586 U10f7		       00	   retStackPtr ds	1
   1587 U10f8							;callStack	ds	GOSUBSTACKSIZE*2
   1588 U10f8		       00	   GoSubStackPtr ds	1
   1589 U10f9		       00 00 00 00*LINBUF     ds	132
   1590 U117d		       00	   getlinx    ds	1
   1591 U117e		       00	   printtx    ds	1	;temp X for print funcs
   1592 U117f		       00	   diddigit   ds	1	;for leading zero suppression
   1593 U1180		       00	   putsy      ds	1
   1594 U1181		       00 00	   errGoto    ds	2	;where to set ILPC on err
   1595 U1183		       00 00	   MQ	      ds	2	;used for some math
   1596 U1185		       00	   sign       ds	1	;0 = positive, else negative
   1597 U1186		       00	   rtemp1     ds	1
   1598 U1187		       00 00	   random     ds	2
   1599 U1189		       00 00	   BOutVec    ds	2
   1600 U118b		       00	   tempy      ds	1	;temp y storage
   1601 U118c				  -	      if	XKIM
   1602 U118c				  -buffer     ds	BUFFER_SIZE
   1603 U118c					      endif
   1604 U118c							;
   1605 U118c							; PROGRAMEND is the end of the user's BASIC program.
   1606 U118c							; More precisely, it is one byte past the end.  Or,
   1607 U118c							; it's where the next line added to the end will be
   1608 U118c							; placed.
   1609 U118c							;
   1610 U118c		       00 00	   PROGRAMEND ds	2
   1611 U118e		       00 00	   HighMem    ds	2	;highest location
   1612 U1190		       00 00	   UsedMem    ds	2	;size of user program
   1613 U1192		       00 00	   FreeMem    ds	2	;amount of free memory
   1614 U1194							;
   1615 U1194							;=====================================================
   1616 U1194							; This is the start of the user's BASIC program space.
   1617 U1194							;
   1618 U1194							; PERSONAL GOAL: This should be no larger than $0DFF.
   1619 U1194							;		  0200-05FF = 1K
   1620 U1194							;		  0200-09FF = 2K
   1621 U1194							;		  0200-0DFF = 3K
   1622 U1194							;		  0200-11FF = 4K
   1623 U1194							;		  0200-13FF = 4.5K
   1624 U1194							;
   1625 U1194				  -	      if	FIXED
   1626 U1194				  -	      org	$2000
   1627 U1194					      endif
   1628 U1194		       11 94	   ProgramStart equ	*
   1629 U1194							;/*
   1630 U1194							;	if	CTMON65 || XKIM
   1631 U1194							;		SEG Code
   1632 U1194							;		org	AutoRun
   1633 U1194							;		dw	TBasicCold
   1634 U1194							;	endif
   1635 U1194							;*/
   1636 U1194					      end
